From 0a89526535c0ed431e9ff60bc585d1fc6e819f6a Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 10 Dec 2020 14:09:36 +0200
Subject: [PATCH 001/147] gdi32: Track ticks since draw start per
 window_surface.

Track ticks since draw start per window_surface, instead of per window
as is currently the case. This helps reduce visual glitches caused by
badly timed flushes in backends which use the same (parent)
window_surface for children windows.

For example, with a shared window_surface, and with the current scheme
of per window start_tick tracking, we may flush while drawing a child
when performing a redraw originating from the parent:

flush
Draw parent (bounds is empty so parent start_ticks is reset)
Draw child 1 (bounds possibly not empty, child1 start_ticks not reset,
              and, depending on when child 1 was drawn independently,
              this could lead to a flush during the draw)

With per surface draw ticks:

flush
Draw parent (bounds is empty so surface start_ticks is reset)
Draw child 1 (bounds possibly not empty, but since surface start_ticks
              was reset by the parent it's unlikely that we flush during
              this draw)

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/win32u/dibdrv/dc.c   | 7 ++++---
 include/wine/gdi_driver.h | 1 +
 2 files changed, 5 insertions(+), 3 deletions(-)

diff --git a/dlls/win32u/dibdrv/dc.c b/dlls/win32u/dibdrv/dc.c
index a96b613d0a3..ad30a82d2cd 100644
--- a/dlls/win32u/dibdrv/dc.c
+++ b/dlls/win32u/dibdrv/dc.c
@@ -734,7 +734,6 @@ struct windrv_physdev
     struct gdi_physdev     dev;
     struct dibdrv_physdev *dibdrv;
     struct window_surface *surface;
-    DWORD                  start_ticks;
 };
 
 static const struct gdi_dc_funcs window_driver;
@@ -748,13 +747,15 @@ static inline void lock_surface( struct windrv_physdev *dev )
 {
     /* gdi_lock should not be locked */
     dev->surface->funcs->lock( dev->surface );
-    if (is_rect_empty( dev->dibdrv->bounds )) dev->start_ticks = NtGetTickCount();
+    if (is_rect_empty( dev->dibdrv->bounds ) || dev->surface->draw_start_ticks == 0)
+        dev->surface->draw_start_ticks = NtGetTickCount();
 }
 
 static inline void unlock_surface( struct windrv_physdev *dev )
 {
+    BOOL should_flush = NtGetTickCount() - dev->surface->draw_start_ticks > FLUSH_PERIOD;
     dev->surface->funcs->unlock( dev->surface );
-    if (NtGetTickCount() - dev->start_ticks > FLUSH_PERIOD) dev->surface->funcs->flush( dev->surface );
+    if (should_flush) dev->surface->funcs->flush( dev->surface );
 }
 
 static void CDECL unlock_bits_surface( struct gdi_image_bits *bits )
diff --git a/include/wine/gdi_driver.h b/include/wine/gdi_driver.h
index 567a6c21608..e0d21d02ab1 100644
--- a/include/wine/gdi_driver.h
+++ b/include/wine/gdi_driver.h
@@ -213,6 +213,7 @@ struct window_surface
     struct list                        entry; /* entry in global list managed by user32 */
     LONG                               ref;   /* reference count */
     RECT                               rect;  /* constant, no locking needed */
+    DWORD                              draw_start_ticks; /* start ticks of fresh draw */
     /* driver-specific fields here */
 };
 
-- 
2.34.1


From d20847281fc50d57a7b2e648b8ff66002e1fc363 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 23 Jun 2021 17:22:20 +0300
Subject: [PATCH 002/147] user32: Expose function to send internal thread
 messages.

Expose a function to drivers so that they can send internal messages to
specific threads, without the need to target a specific HWND.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/user32/message.c   | 13 +++++++++++++
 dlls/user32/user32.spec |  1 +
 include/winuser.h       |  3 +++
 3 files changed, 17 insertions(+)

diff --git a/dlls/user32/message.c b/dlls/user32/message.c
index d7dbc64d796..907233aa489 100644
--- a/dlls/user32/message.c
+++ b/dlls/user32/message.c
@@ -3388,6 +3388,19 @@ LRESULT MSG_SendInternalMessageTimeout( DWORD dest_pid, DWORD dest_tid,
     return ret;
 }
 
+/***********************************************************************
+ *		__wine_send_internal_message_timeout  (USER32.@)
+ *
+ * Same as SendMessageTimeoutW but sends the message to a specific thread
+ * without requiring a window handle. Only works for internal Wine messages.
+ */
+LRESULT CDECL __wine_send_internal_message_timeout( DWORD dest_pid, DWORD dest_tid,
+                                                    UINT msg, WPARAM wparam, LPARAM lparam,
+                                                    UINT flags, UINT timeout, PDWORD_PTR res_ptr )
+{
+    return MSG_SendInternalMessageTimeout( dest_pid, dest_tid, msg, wparam, lparam,
+                                           flags, timeout, res_ptr );
+}
 
 /***********************************************************************
  *		SendMessageTimeoutW  (USER32.@)
diff --git a/dlls/user32/user32.spec b/dlls/user32/user32.spec
index c963dbaaee1..d46768e6e58 100644
--- a/dlls/user32/user32.spec
+++ b/dlls/user32/user32.spec
@@ -839,3 +839,4 @@
 @ cdecl __wine_send_input(long ptr ptr)
 @ cdecl __wine_set_pixel_format(long long)
 @ cdecl __wine_set_user_driver(ptr long)
+@ cdecl __wine_send_internal_message_timeout(long long long long long long long ptr)
diff --git a/include/winuser.h b/include/winuser.h
index 1d37bd44344..fb7304a08dd 100644
--- a/include/winuser.h
+++ b/include/winuser.h
@@ -4408,6 +4408,9 @@ WORD        WINAPI SYSTEM_KillSystemTimer( WORD );
 
 #ifdef __WINESRC__
 WINUSERAPI BOOL CDECL __wine_send_input( HWND hwnd, const INPUT *input, const RAWINPUT *rawinput );
+LRESULT CDECL __wine_send_internal_message_timeout( DWORD dest_pid, DWORD dest_tid,
+                                                    UINT msg, WPARAM wparam, LPARAM lparam,
+                                                    UINT flags, UINT timeout, PDWORD_PTR res_ptr );
 
 /* Uxtheme hook functions and struct */
 
-- 
2.34.1


From e1dc70f68d4b4b959e66a46fd16d9e9936af3c6d Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 31 Aug 2021 15:48:36 +0300
Subject: [PATCH 003/147] winewayland.drv: Add initial driver stub.

Add the initial driver stub for the Wayland driver and enable building
it with the '--with-wayland' configure flag.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 configure                                 | 22 ++++++++++
 configure.ac                              |  6 +++
 dlls/winewayland.drv/Makefile.in          | 12 ++++++
 dlls/winewayland.drv/version.rc           | 22 ++++++++++
 dlls/winewayland.drv/waylanddrv.h         | 33 +++++++++++++++
 dlls/winewayland.drv/waylanddrv_main.c    | 51 +++++++++++++++++++++++
 dlls/winewayland.drv/winewayland.drv.spec |  0
 7 files changed, 146 insertions(+)
 create mode 100644 dlls/winewayland.drv/Makefile.in
 create mode 100644 dlls/winewayland.drv/version.rc
 create mode 100644 dlls/winewayland.drv/waylanddrv.h
 create mode 100644 dlls/winewayland.drv/waylanddrv_main.c
 create mode 100644 dlls/winewayland.drv/winewayland.drv.spec

diff --git a/configure.ac b/configure.ac
index c1eb2f99a8c..a5a680823ea 100644
--- a/configure.ac
+++ b/configure.ac
@@ -87,6 +87,7 @@ AC_ARG_WITH(xshm,      AS_HELP_STRING([--without-xshm],[do not use XShm (shared
             [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_XShm_h=no; fi])
 AC_ARG_WITH(xxf86vm,   AS_HELP_STRING([--without-xxf86vm],[do not use XFree video mode extension]),
             [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_xf86vmode_h=no; ac_cv_header_X11_extensions_xf86vmproto_h=no; fi])
+AC_ARG_WITH(wayland,   AS_HELP_STRING([--with-wayland],[build with wayland support]))
 
 AC_ARG_WITH(system-dllpath,AS_HELP_STRING([--with-system-dllpath=PATH],[load external PE dependencies from colon-separated path PATH]),
             AC_SUBST(system_dllpath,[$withval]))
@@ -1323,6 +1324,10 @@ else
                      [enable_winex11_drv])
 fi
 
+WINE_NOTICE_WITH(wayland, [false],
+                 [Wayland ${notice_platform}development files not found, the Wayland driver won't be supported.],
+                 [enable_winewayland_drv])
+
 dnl **** Check for OpenCL ****
 if test "$ac_cv_header_CL_cl_h" = "yes"
 then
@@ -3393,6 +3398,7 @@ WINE_CONFIG_MAKEFILE(dlls/wineps16.drv16,enable_win16)
 WINE_CONFIG_MAKEFILE(dlls/winepulse.drv)
 WINE_CONFIG_MAKEFILE(dlls/wineusb.sys)
 WINE_CONFIG_MAKEFILE(dlls/winevulkan)
+WINE_CONFIG_MAKEFILE(dlls/winewayland.drv)
 WINE_CONFIG_MAKEFILE(dlls/winex11.drv)
 WINE_CONFIG_MAKEFILE(dlls/winexinput.sys)
 WINE_CONFIG_MAKEFILE(dlls/wing.dll16,enable_win16)
diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
new file mode 100644
index 00000000000..3d55b385e95
--- /dev/null
+++ b/dlls/winewayland.drv/Makefile.in
@@ -0,0 +1,12 @@
+MODULE    = winewayland.drv
+CFLAGS = -std=c11 -Wno-declaration-after-statement
+EXTRACFLAGS = -std=c11 -Wno-declaration-after-statement
+CPPFLAGS = -std=c11 -Wno-declaration-after-statement
+EXTRACROSSCFLAGS = -std=c11 -Wno-declaration-after-statement
+
+EXTRADLLFLAGS = -mcygwin
+
+C_SRCS = \
+	waylanddrv_main.c \
+
+RC_SRCS = version.rc
diff --git a/dlls/winewayland.drv/version.rc b/dlls/winewayland.drv/version.rc
new file mode 100644
index 00000000000..2d99c24f99c
--- /dev/null
+++ b/dlls/winewayland.drv/version.rc
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define WINE_FILEDESCRIPTION_STR "Wine Wayland driver"
+#define WINE_FILENAME_STR "winewayland.drv"
+
+#include "wine/wine_common_ver.rc"
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
new file mode 100644
index 00000000000..726193b16de
--- /dev/null
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -0,0 +1,33 @@
+/*
+ * Wayland driver
+ *
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_WAYLANDDRV_H
+#define __WINE_WAYLANDDRV_H
+
+#ifndef __WINE_CONFIG_H
+# error You must include config.h to use this header
+#endif
+
+#include <stdarg.h>
+
+#include "windef.h"
+#include "winbase.h"
+
+#endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
new file mode 100644
index 00000000000..92ef39777bd
--- /dev/null
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -0,0 +1,51 @@
+/*
+ * WAYLANDDRV initialization code
+ *
+ * Copyright 1998 Patrik Stridvall
+ * Copyright 2000 Alexandre Julliard
+ * Copyright 2020 Alexandre Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+/***********************************************************************
+ *           WAYLANDDRV process initialisation routine
+ */
+static BOOL process_attach(void)
+{
+    return TRUE;
+}
+
+/***********************************************************************
+ *           WAYLANDDRV initialisation routine
+ */
+BOOL WINAPI DllMain(HINSTANCE hinst, DWORD reason, LPVOID reserved)
+{
+    BOOL ret = TRUE;
+
+    switch(reason)
+    {
+    case DLL_PROCESS_ATTACH:
+        DisableThreadLibraryCalls(hinst);
+        ret = process_attach();
+        break;
+    }
+
+    return ret;
+}
diff --git a/dlls/winewayland.drv/winewayland.drv.spec b/dlls/winewayland.drv/winewayland.drv.spec
new file mode 100644
index 00000000000..e69de29bb2d
-- 
2.34.1


From 18a15ca4104dc8c93edfbdea7d6d084fdd30e6d0 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 10 Dec 2020 18:41:03 +0200
Subject: [PATCH 004/147] explorer: Add the Wayland driver to the default
 driver list.

Add the Wayland driver at the end of the default driver list. This
ensures that, by default, under Wayland compositors that support
Xwayland, the more mature X11 driver will be used. One can force using
the wayland driver by ensuring X11 is not accessible, e.g., by unsetting
the DISPLAY environment variable.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 programs/explorer/desktop.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/programs/explorer/desktop.c b/programs/explorer/desktop.c
index 6d577dd0fd1..e1dce4953e2 100644
--- a/programs/explorer/desktop.c
+++ b/programs/explorer/desktop.c
@@ -39,7 +39,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(explorer);
 #define DESKTOP_CLASS_ATOM ((LPCWSTR)MAKEINTATOM(32769))
 #define DESKTOP_ALL_ACCESS 0x01ff
 
-static const WCHAR default_driver[] = {'m','a','c',',','x','1','1',0};
+static const WCHAR default_driver[] = {'m','a','c',',','x','1','1',',','w','a','y','l','a','n','d',0};
 
 static BOOL using_root;
 
-- 
2.34.1


From 1abcd4054dd0e325711879afdb448418a4392abf Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 31 Aug 2021 16:21:21 +0300
Subject: [PATCH 005/147] winewayland.drv: Perform basic per-process Wayland
 initialization.

Try to connect to the Wayland compositor, and fail driver initialization
if we are unable to do so.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 configure                              | 87 +++++++++++++++++++++++++-
 configure.ac                           |  9 ++-
 dlls/winewayland.drv/Makefile.in       |  3 +
 dlls/winewayland.drv/wayland.c         | 38 +++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  9 +++
 dlls/winewayland.drv/waylanddrv_main.c |  2 +
 include/config.h.in                    |  3 +
 7 files changed, 149 insertions(+), 2 deletions(-)
 create mode 100644 dlls/winewayland.drv/wayland.c

diff --git a/configure.ac b/configure.ac
index a5a680823ea..8c95ba8a600 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1324,7 +1324,14 @@ else
                      [enable_winex11_drv])
 fi
 
-WINE_NOTICE_WITH(wayland, [false],
+if test "x$with_wayland" = "xyes"
+then
+    WINE_PACKAGE_FLAGS(WAYLAND_CLIENT,[wayland-client],,,,
+        [AC_CHECK_HEADERS([wayland-client.h])
+         AC_CHECK_LIB(wayland-client,wl_display_connect,[:],
+                      [WAYLAND_CLIENT_LIBS=""],[$WAYLAND_CLIENT_LIBS])])
+fi
+WINE_NOTICE_WITH(wayland, [test -z "$WAYLAND_CLIENT_LIBS"],
                  [Wayland ${notice_platform}development files not found, the Wayland driver won't be supported.],
                  [enable_winewayland_drv])
 
diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 3d55b385e95..4057bbaa99d 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,4 +1,6 @@
 MODULE    = winewayland.drv
+EXTRAINCL = $(WAYLAND_CLIENT_CFLAGS)
+EXTRALIBS = $(WAYLAND_CLIENT_LIBS)
 CFLAGS = -std=c11 -Wno-declaration-after-statement
 EXTRACFLAGS = -std=c11 -Wno-declaration-after-statement
 CPPFLAGS = -std=c11 -Wno-declaration-after-statement
@@ -7,6 +9,7 @@ EXTRACROSSCFLAGS = -std=c11 -Wno-declaration-after-statement
 EXTRADLLFLAGS = -mcygwin
 
 C_SRCS = \
+	wayland.c \
 	waylanddrv_main.c \
 
 RC_SRCS = version.rc
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
new file mode 100644
index 00000000000..1a12d4fb9a4
--- /dev/null
+++ b/dlls/winewayland.drv/wayland.c
@@ -0,0 +1,38 @@
+/*
+ * Wayland core handling
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+struct wl_display *process_wl_display = NULL;
+
+/**********************************************************************
+ *          wayland_process_init
+ *
+ *  Initialise the per process wayland objects.
+ *
+ */
+BOOL wayland_process_init(void)
+{
+    process_wl_display = wl_display_connect(NULL);
+    return process_wl_display != NULL;
+}
+
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 726193b16de..c7758a3d979 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -26,8 +26,17 @@
 #endif
 
 #include <stdarg.h>
+#include <wayland-client.h>
 
 #include "windef.h"
 #include "winbase.h"
 
+extern struct wl_display *process_wl_display;
+
+/**********************************************************************
+ *          Wayland initialisation
+ */
+
+BOOL wayland_process_init(void);
+
 #endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 92ef39777bd..607a5770e0f 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -29,6 +29,8 @@
  */
 static BOOL process_attach(void)
 {
+    if (!wayland_process_init()) return FALSE;
+
     return TRUE;
 }
 
diff --git a/include/config.h.in b/include/config.h.in
index 9717dc17236..24286070d82 100644
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -697,6 +697,9 @@
 /* Define to 1 if you have the <valgrind/valgrind.h> header file. */
 #undef HAVE_VALGRIND_VALGRIND_H
 
+/* Define to 1 if you have the <wayland-client.h> header file. */
+#undef HAVE_WAYLAND_CLIENT_H
+
 /* Define to 1 if you have the <X11/extensions/shape.h> header file. */
 #undef HAVE_X11_EXTENSIONS_SHAPE_H
 
-- 
2.34.1


From d4997ba8167f8ade5701731c045c5a276dee80de Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 31 Aug 2021 17:16:12 +0300
Subject: [PATCH 006/147] winewayland.drv: Add stub for per-thread data.

Handle allocation and deallocation of per-thread data (currently without
any actual contents).

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |  1 +
 dlls/winewayland.drv/waylanddrv.h      | 19 ++++++++++
 dlls/winewayland.drv/waylanddrv_main.c | 52 ++++++++++++++++++++++++++
 3 files changed, 72 insertions(+)

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 4057bbaa99d..eac64770c64 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,4 +1,5 @@
 MODULE    = winewayland.drv
+IMPORTS   = user32
 EXTRAINCL = $(WAYLAND_CLIENT_CFLAGS)
 EXTRALIBS = $(WAYLAND_CLIENT_LIBS)
 CFLAGS = -std=c11 -Wno-declaration-after-statement
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index c7758a3d979..4e6a39aaf10 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -33,6 +33,25 @@
 
 extern struct wl_display *process_wl_display;
 
+/**********************************************************************
+ *          Wayland thread data
+ */
+
+struct wayland_thread_data
+{
+};
+
+extern struct wayland_thread_data *wayland_init_thread_data(void) DECLSPEC_HIDDEN;
+extern DWORD thread_data_tls_index DECLSPEC_HIDDEN;
+
+static inline struct wayland_thread_data *wayland_thread_data(void)
+{
+    DWORD err = GetLastError();  /* TlsGetValue always resets last error */
+    struct wayland_thread_data *data = TlsGetValue(thread_data_tls_index);
+    SetLastError(err);
+    return data;
+}
+
 /**********************************************************************
  *          Wayland initialisation
  */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 607a5770e0f..1ff07ceefc8 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -24,11 +24,63 @@
 
 #include "waylanddrv.h"
 
+#include "wine/debug.h"
+#include "wine/gdi_driver.h"
+#include "wine/heap.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+DWORD thread_data_tls_index = TLS_OUT_OF_INDEXES;
+
+/***********************************************************************
+ *           Initialize per thread data
+ */
+struct wayland_thread_data *wayland_init_thread_data(void)
+{
+    struct wayland_thread_data *data = wayland_thread_data();
+
+    if (data) return data;
+
+    if (!(data = heap_alloc_zero(sizeof(*data))))
+    {
+        ERR("could not create data\n");
+        ExitProcess(1);
+    }
+
+    TlsSetValue(thread_data_tls_index, data);
+
+    return data;
+}
+
+/***********************************************************************
+ *           ThreadDetach (WAYLAND.@)
+ */
+static void CDECL WAYLAND_ThreadDetach(void)
+{
+    struct wayland_thread_data *data = wayland_thread_data();
+
+    if (data)
+    {
+        heap_free(data);
+        /* clear data in case we get re-entered from user32 before the thread is truly dead */
+        TlsSetValue(thread_data_tls_index, NULL);
+    }
+}
+
+static const struct user_driver_funcs waylanddrv_funcs =
+{
+    .pThreadDetach = WAYLAND_ThreadDetach,
+};
+
 /***********************************************************************
  *           WAYLANDDRV process initialisation routine
  */
 static BOOL process_attach(void)
 {
+    if ((thread_data_tls_index = TlsAlloc()) == TLS_OUT_OF_INDEXES) return FALSE;
+
+    __wine_set_user_driver(&waylanddrv_funcs, WINE_GDI_DRIVER_VERSION);
+
     if (!wayland_process_init()) return FALSE;
 
     return TRUE;
-- 
2.34.1


From 09817e9975dc25809956d9b5ccad3fc98b2f3782 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 31 Aug 2021 16:53:51 +0300
Subject: [PATCH 007/147] winewayland.drv: Initialize basic per-thread Wayland
 instance.

Every thread that requires interaction with Wayland maintains its own
independent set of Wayland protocols objects. Events from Wayland
protocol objects are dispatched into a thread-specific Wayland event
queue.

This design simplifies synchronization, since there is no shared Wayland
state between threads, and will later make it easier to dispatch events
to the proper thread message queue. The downside is that there is some
duplication of event handling if multiple GUI threads are present.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c         | 105 ++++++++++++++++++++++++-
 dlls/winewayland.drv/waylanddrv.h      |  18 +++++
 dlls/winewayland.drv/waylanddrv_main.c |  10 +++
 3 files changed, 132 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 1a12d4fb9a4..c81a220ee27 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -22,8 +22,112 @@
 
 #include "waylanddrv.h"
 
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
 struct wl_display *process_wl_display = NULL;
 
+/**********************************************************************
+ *          Registry handling
+ */
+
+static void registry_handle_global(void *data, struct wl_registry *registry,
+                                   uint32_t id, const char *interface,
+                                   uint32_t version)
+{
+    struct wayland *wayland = data;
+
+    TRACE("interface=%s version=%d\n id=%u\n", interface, version, id);
+
+    if (strcmp(interface, "wl_compositor") == 0)
+    {
+        wayland->wl_compositor =
+            wl_registry_bind(registry, id, &wl_compositor_interface, 4);
+    }
+}
+
+static void registry_handle_global_remove(void *data, struct wl_registry *registry,
+                                          uint32_t id)
+{
+    TRACE("id=%d\n", id);
+}
+
+static const struct wl_registry_listener registry_listener = {
+    registry_handle_global,
+    registry_handle_global_remove
+};
+
+/**********************************************************************
+ *          wayland_init
+ *
+ *  Initialise a wayland instance.
+ */
+BOOL wayland_init(struct wayland *wayland)
+{
+    TRACE("wayland=%p wl_display=%p\n", wayland, process_wl_display);
+
+    wayland->process_id = GetCurrentProcessId();
+    wayland->thread_id = GetCurrentThreadId();
+    wayland->wl_display = process_wl_display;
+
+    if (!wayland->wl_display)
+    {
+        ERR("Failed to connect to wayland compositor\n");
+        return FALSE;
+    }
+
+    if (!(wayland->wl_event_queue = wl_display_create_queue(wayland->wl_display)))
+    {
+        ERR("Failed to create event queue\n");
+        return FALSE;
+    }
+
+    if (!(wayland->wl_registry = wl_display_get_registry(wayland->wl_display)))
+    {
+        ERR("Failed to get to wayland registry\n");
+        return FALSE;
+    }
+    wl_proxy_set_queue((struct wl_proxy *) wayland->wl_registry, wayland->wl_event_queue);
+
+    /* Populate registry */
+    wl_registry_add_listener(wayland->wl_registry, &registry_listener, wayland);
+
+    /* We need three roundtrips. One to get and bind globals, one to handle all
+     * initial events produced from registering the globals and one more to
+     * handle potential third-order registrations. */
+    wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
+    wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
+    wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
+
+    wayland->initialized = TRUE;
+
+    return TRUE;
+}
+
+/**********************************************************************
+ *          wayland_deinit
+ *
+ *  Deinitialise a wayland instance, releasing all associated resources.
+ */
+void wayland_deinit(struct wayland *wayland)
+{
+    TRACE("%p\n", wayland);
+
+    if (wayland->wl_compositor)
+        wl_compositor_destroy(wayland->wl_compositor);
+
+    if (wayland->wl_registry)
+        wl_registry_destroy(wayland->wl_registry);
+
+    if (wayland->wl_event_queue)
+        wl_event_queue_destroy(wayland->wl_event_queue);
+
+    wl_display_flush(wayland->wl_display);
+
+    memset(wayland, 0, sizeof(*wayland));
+}
+
 /**********************************************************************
  *          wayland_process_init
  *
@@ -35,4 +139,3 @@ BOOL wayland_process_init(void)
     process_wl_display = wl_display_connect(NULL);
     return process_wl_display != NULL;
 }
-
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 4e6a39aaf10..9728811c313 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -33,12 +33,28 @@
 
 extern struct wl_display *process_wl_display;
 
+/**********************************************************************
+ *          Definitions for wayland types
+ */
+
+struct wayland
+{
+    BOOL initialized;
+    DWORD process_id;
+    DWORD thread_id;
+    struct wl_display *wl_display;
+    struct wl_event_queue *wl_event_queue;
+    struct wl_registry *wl_registry;
+    struct wl_compositor *wl_compositor;
+};
+
 /**********************************************************************
  *          Wayland thread data
  */
 
 struct wayland_thread_data
 {
+    struct wayland wayland;
 };
 
 extern struct wayland_thread_data *wayland_init_thread_data(void) DECLSPEC_HIDDEN;
@@ -57,5 +73,7 @@ static inline struct wayland_thread_data *wayland_thread_data(void)
  */
 
 BOOL wayland_process_init(void);
+BOOL wayland_init(struct wayland *wayland);
+void wayland_deinit(struct wayland *wayland);
 
 #endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 1ff07ceefc8..905d1000c2d 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -29,6 +29,7 @@
 #include "wine/heap.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
 DWORD thread_data_tls_index = TLS_OUT_OF_INDEXES;
 
@@ -47,6 +48,14 @@ struct wayland_thread_data *wayland_init_thread_data(void)
         ExitProcess(1);
     }
 
+    if (!wayland_init(&data->wayland))
+    {
+        ERR_(winediag)("waylanddrv: Can't open wayland display. Please ensure "
+                       "that your wayland server is running and that "
+                       "$WAYLAND_DISPLAY is set correctly.\n");
+        ExitProcess(1);
+    }
+
     TlsSetValue(thread_data_tls_index, data);
 
     return data;
@@ -61,6 +70,7 @@ static void CDECL WAYLAND_ThreadDetach(void)
 
     if (data)
     {
+        wayland_deinit(&data->wayland);
         heap_free(data);
         /* clear data in case we get re-entered from user32 before the thread is truly dead */
         TlsSetValue(thread_data_tls_index, NULL);
-- 
2.34.1


From 137531e71d189bec3c8f33e9feb4a470341fef38 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 31 Aug 2021 17:39:54 +0300
Subject: [PATCH 008/147] winewayland.drv: Initialize Wayland thread data for
 desktop window thread.

Having access to the Wayland thread data will allow the desktop process
to eventually access information that requires interaction with the
Wayland compositor. A prime example is accessing display information.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |  1 +
 dlls/winewayland.drv/waylanddrv.h      |  6 ++++
 dlls/winewayland.drv/waylanddrv_main.c |  1 +
 dlls/winewayland.drv/window.c          | 49 ++++++++++++++++++++++++++
 4 files changed, 57 insertions(+)
 create mode 100644 dlls/winewayland.drv/window.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index eac64770c64..450b43af5d1 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -12,5 +12,6 @@ EXTRADLLFLAGS = -mcygwin
 C_SRCS = \
 	wayland.c \
 	waylanddrv_main.c \
+	window.c \
 
 RC_SRCS = version.rc
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 9728811c313..74133c90c58 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -76,4 +76,10 @@ BOOL wayland_process_init(void);
 BOOL wayland_init(struct wayland *wayland);
 void wayland_deinit(struct wayland *wayland);
 
+/**********************************************************************
+ *          USER driver functions
+ */
+
+extern BOOL CDECL WAYLAND_CreateWindow(HWND hwnd) DECLSPEC_HIDDEN;
+
 #endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 905d1000c2d..7ee7ec9435e 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -79,6 +79,7 @@ static void CDECL WAYLAND_ThreadDetach(void)
 
 static const struct user_driver_funcs waylanddrv_funcs =
 {
+    .pCreateWindow = WAYLAND_CreateWindow,
     .pThreadDetach = WAYLAND_ThreadDetach,
 };
 
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
new file mode 100644
index 00000000000..66e5c632ed8
--- /dev/null
+++ b/dlls/winewayland.drv/window.c
@@ -0,0 +1,49 @@
+/*
+ * Window related functions
+ *
+ * Copyright 1993, 1994, 1995, 1996, 2001, 2013-2017 Alexandre Julliard
+ * Copyright 1993 David Metcalfe
+ * Copyright 1995, 1996 Alex Korobka
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "winuser.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+/**********************************************************************
+ *           WAYLAND_CreateWindow
+ */
+BOOL CDECL WAYLAND_CreateWindow(HWND hwnd)
+{
+    TRACE("%p\n", hwnd);
+
+    if (hwnd == GetDesktopWindow())
+    {
+        /* Initialize wayland so that the desktop process has access
+         * to all the wayland related information (e.g., displays). */
+        wayland_init_thread_data();
+    }
+
+    return TRUE;
+}
-- 
2.34.1


From 2a314bbd2480d3be2c8481197d15236f371737f6 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 8 Nov 2021 12:34:39 +0200
Subject: [PATCH 009/147] winewayland.drv: Maintain a per-process wayland
 instance.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c    | 52 ++++++++++++++++++++++++++++++-
 dlls/winewayland.drv/waylanddrv.h |  3 ++
 2 files changed, 54 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index c81a220ee27..82c61589349 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -23,10 +23,22 @@
 #include "waylanddrv.h"
 
 #include "wine/debug.h"
+#include "wine/heap.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
 struct wl_display *process_wl_display = NULL;
+static struct wayland *process_wayland = NULL;
+CRITICAL_SECTION process_wayland_section;
+static CRITICAL_SECTION_DEBUG process_wayland_critsect_debug =
+{
+    0, 0, &process_wayland_section,
+    { &process_wayland_critsect_debug.ProcessLocksList,
+      &process_wayland_critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": process_wayland_section") }
+};
+CRITICAL_SECTION process_wayland_section = { &process_wayland_critsect_debug,
+                                             -1, 0, 0, 0, 0 };
 
 /**********************************************************************
  *          Registry handling
@@ -137,5 +149,43 @@ void wayland_deinit(struct wayland *wayland)
 BOOL wayland_process_init(void)
 {
     process_wl_display = wl_display_connect(NULL);
-    return process_wl_display != NULL;
+    if (!process_wl_display)
+        return FALSE;
+
+    process_wayland = heap_alloc_zero(sizeof(*process_wayland));
+    if (!process_wayland)
+        return FALSE;
+
+    return wayland_init(process_wayland);
+}
+
+/**********************************************************************
+ *          wayland_is_process
+ *
+ *  Checks whether a wayland instance is the per-process one.
+ */
+BOOL wayland_is_process(struct wayland *wayland)
+{
+    return wayland == process_wayland;
+}
+
+/**********************************************************************
+ *          wayland_process_acquire
+ *
+ *  Acquires the per-process wayland instance.
+ */
+struct wayland *wayland_process_acquire(void)
+{
+    EnterCriticalSection(&process_wayland_section);
+    return process_wayland;
+}
+
+/**********************************************************************
+ *          wayland_process_release
+ *
+ *  Releases the per-process wayland instance.
+ */
+void wayland_process_release(void)
+{
+    LeaveCriticalSection(&process_wayland_section);
 }
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 74133c90c58..ecad650ce6a 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -75,6 +75,9 @@ static inline struct wayland_thread_data *wayland_thread_data(void)
 BOOL wayland_process_init(void);
 BOOL wayland_init(struct wayland *wayland);
 void wayland_deinit(struct wayland *wayland);
+BOOL wayland_is_process(struct wayland *wayland);
+struct wayland *wayland_process_acquire(void);
+void wayland_process_release(void);
 
 /**********************************************************************
  *          USER driver functions
-- 
2.34.1


From 44c8c17f8cc702c1a1125ae1e364f36fba4b7efb Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 2 Sep 2021 14:04:43 +0300
Subject: [PATCH 010/147] tools: Support building Wayland protocol source
 files.

Wayland protocol descriptions are distributed as source XML files that
need to be transformed to C source and header files with a version of
the wayland-scanner tool compatible with the used libwayland library.

This commit enhances the makedep build tool to support building such
Wayland protocol XML files. Components can use the WAYLAND_PROTOCOL_SRCS
build variable to add protocol XML files to their build.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 configure       | 93 +++++++++++++++++++++++++++++++++++++++++++++++--
 configure.ac    | 11 ++++--
 tools/makedep.c | 39 +++++++++++++++++++++
 3 files changed, 138 insertions(+), 5 deletions(-)

diff --git a/configure.ac b/configure.ac
index 8c95ba8a600..95865edf813 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1330,9 +1330,16 @@ then
         [AC_CHECK_HEADERS([wayland-client.h])
          AC_CHECK_LIB(wayland-client,wl_display_connect,[:],
                       [WAYLAND_CLIENT_LIBS=""],[$WAYLAND_CLIENT_LIBS])])
+    WINE_PACKAGE_FLAGS(WAYLAND_PROTOCOLS, [wayland-protocols],,,,
+         [AC_SUBST(WAYLAND_PROTOCOLS_DATADIR,
+                   `$PKG_CONFIG --atleast-version=1.14 wayland-protocols && $PKG_CONFIG --variable=pkgdatadir wayland-protocols`)])
+    AC_PATH_PROG(WAYLAND_SCANNER,wayland-scanner,
+                 [`$PKG_CONFIG --variable=wayland_scanner wayland-scanner`])
 fi
-WINE_NOTICE_WITH(wayland, [test -z "$WAYLAND_CLIENT_LIBS"],
-                 [Wayland ${notice_platform}development files not found, the Wayland driver won't be supported.],
+WINE_NOTICE_WITH(wayland, [test -z "$WAYLAND_CLIENT_LIBS" ||
+                           test -z "$WAYLAND_PROTOCOLS_DATADIR" ||
+                           test -z "$WAYLAND_SCANNER"],
+                 [Wayland ${notice_platform}development files not found or not new enough, the Wayland driver won't be supported.],
                  [enable_winewayland_drv])
 
 dnl **** Check for OpenCL ****
diff --git a/tools/makedep.c b/tools/makedep.c
index e69dc3ce0a4..d295a25be42 100644
--- a/tools/makedep.c
+++ b/tools/makedep.c
@@ -165,6 +165,7 @@ static const char *msgfmt;
 static const char *ln_s;
 static const char *sed_cmd;
 static const char *delay_load_flag;
+static const char *wayland_scanner;
 
 struct makefile
 {
@@ -496,6 +497,15 @@ static char *replace_filename( const char *path, const char *name )
     return ret;
 }
 
+/*******************************************************************
+ *         get_filename
+ */
+static char *get_filename( const char *name )
+{
+    char *filename = strrchr( name, '/' );
+    if (!filename) return strdup( name );
+    return strdup( filename + 1 );
+}
 
 /*******************************************************************
  *         replace_substr
@@ -1333,6 +1343,9 @@ static struct file *open_include_file( const struct makefile *make, struct incl_
         return file;
     }
 
+    /* TODO: check for corresponding wayland protocol .xml file */
+    if (strendswith( pFile->name, "-client-protocol.h" )) return NULL;
+
     /* check for extra targets */
     if (strarray_exists( &make->extra_targets, pFile->name ))
     {
@@ -1824,6 +1837,19 @@ static void add_generated_sources( struct makefile *make )
             strarray_addall_uniq( &make->extra_imports,
                                   get_expanded_file_local_var( make, obj, "IMPORTS" ));
         }
+        if (strendswith( source->name, ".xml" ))
+        {
+            char *filename = get_filename( source->name );
+            char *code_filename = replace_extension ( filename , ".xml", "-protocol.c" );
+            char *header_filename = replace_extension ( filename , ".xml", "-client-protocol.h" );
+
+            add_generated_source( make, code_filename, NULL );
+            add_generated_source( make, header_filename, NULL );
+
+            free( filename );
+            free( code_filename );
+            free( header_filename );
+        }
     }
     if (make->testdll)
     {
@@ -2950,6 +2976,15 @@ static void output_source_spec( struct makefile *make, struct incl_file *source,
     output( "\n" );
 }
 
+static void output_source_xml( struct makefile *make, struct incl_file *source, const char *obj )
+{
+    char *base = get_filename( obj );
+    output( "%s-protocol.c: %s\n", obj_dir_path( make, base ), source->filename );
+    output( "\t%s%s private-code $< $@\n", cmd_prefix( "WAYLAND_SCANNER" ), wayland_scanner );
+    output( "%s-client-protocol.h: %s\n", obj_dir_path( make, base ), source->filename );
+    output( "\t%s%s client-header $< $@\n", cmd_prefix( "WAYLAND_SCANNER" ), wayland_scanner);
+    free( base );
+}
 
 /*******************************************************************
  *         output_source_default
@@ -3067,6 +3102,7 @@ static const struct
     { "in", output_source_in },
     { "x", output_source_x },
     { "spec", output_source_spec },
+    { "xml", output_source_xml },
     { NULL, output_source_default }
 };
 
@@ -4002,6 +4038,7 @@ static void output_silent_rules(void)
         "MSG",
         "SED",
         "TEST",
+        "WAYLAND_SCANNER",
         "WIDL",
         "WMC",
         "WRC"
@@ -4100,6 +4137,7 @@ static void load_sources( struct makefile *make )
         "IN_SRCS",
         "PO_SRCS",
         "MANPAGES",
+        "WAYLAND_PROTOCOL_SRCS",
         NULL
     };
     const char **var;
@@ -4335,6 +4373,7 @@ int main( int argc, char *argv[] )
     msgfmt             = get_expanded_make_variable( top_makefile, "MSGFMT" );
     sed_cmd            = get_expanded_make_variable( top_makefile, "SED_CMD" );
     ln_s               = get_expanded_make_variable( top_makefile, "LN_S" );
+    wayland_scanner    = get_expanded_make_variable( top_makefile, "WAYLAND_SCANNER" );
 
     if (root_src_dir && !strcmp( root_src_dir, "." )) root_src_dir = NULL;
     if (tools_dir && !strcmp( tools_dir, "." )) tools_dir = NULL;
-- 
2.34.1


From 14f71b583e97f84c6fd48b26c2b6b64111fc5b07 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 31 Aug 2021 18:21:04 +0300
Subject: [PATCH 011/147] winewayland.drv: Handle Wayland output global events.

The wl_output global objects are dynamically created and destroyed by
the Wayland compositor to convey information about the display outputs.
This commit handles the creation and removal of wl_output objects as
well as related informational events to maintain a complete per-thread
display output state.

In addition to the core wl_output protocol object, the
xdg-output-unstable-v1 extension is used, if present, to get additional
information about the outputs, including their unique name and logical
coordinates.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in      |   4 +
 dlls/winewayland.drv/wayland.c        |  44 +++
 dlls/winewayland.drv/wayland_output.c | 492 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h     |  38 ++
 4 files changed, 578 insertions(+)
 create mode 100644 dlls/winewayland.drv/wayland_output.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 450b43af5d1..f1e1d1cc655 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -11,7 +11,11 @@ EXTRADLLFLAGS = -mcygwin
 
 C_SRCS = \
 	wayland.c \
+	wayland_output.c \
 	waylanddrv_main.c \
 	window.c \
 
+WAYLAND_PROTOCOL_SRCS = \
+	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/xdg-output/xdg-output-unstable-v1.xml \
+
 RC_SRCS = version.rc
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 82c61589349..1f5c966121a 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -52,6 +52,27 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
 
     TRACE("interface=%s version=%d\n id=%u\n", interface, version, id);
 
+    if (strcmp(interface, "wl_output") == 0)
+    {
+        if (!wayland_output_create(wayland, id, version))
+            ERR("Failed to create wayland_output for global id=%u\n", id);
+    }
+    else if (strcmp(interface, "zxdg_output_manager_v1") == 0)
+    {
+        struct wayland_output *output;
+
+        wayland->zxdg_output_manager_v1 =
+            wl_registry_bind(registry, id, &zxdg_output_manager_v1_interface,
+                             version < 3 ? version : 3);
+
+        /* Add zxdg_output_v1 to existing outputs. */
+        wl_list_for_each(output, &wayland->output_list, link)
+            wayland_output_use_xdg_extension(output);
+    }
+
+    /* The per-process wayland instance only handles output related globals. */
+    if (wayland_is_process(wayland)) return;
+
     if (strcmp(interface, "wl_compositor") == 0)
     {
         wayland->wl_compositor =
@@ -62,7 +83,20 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
                                           uint32_t id)
 {
+    struct wayland *wayland = data;
+    struct wayland_output *output, *tmp;
+
     TRACE("id=%d\n", id);
+
+    wl_list_for_each_safe(output, tmp, &wayland->output_list, link)
+    {
+        if (output->global_id == id)
+        {
+            TRACE("removing output->name=%s\n", output->name);
+            wayland_output_destroy(output);
+            return;
+        }
+    }
 }
 
 static const struct wl_registry_listener registry_listener = {
@@ -102,6 +136,8 @@ BOOL wayland_init(struct wayland *wayland)
     }
     wl_proxy_set_queue((struct wl_proxy *) wayland->wl_registry, wayland->wl_event_queue);
 
+    wl_list_init(&wayland->output_list);
+
     /* Populate registry */
     wl_registry_add_listener(wayland->wl_registry, &registry_listener, wayland);
 
@@ -124,8 +160,16 @@ BOOL wayland_init(struct wayland *wayland)
  */
 void wayland_deinit(struct wayland *wayland)
 {
+    struct wayland_output *output, *output_tmp;
+
     TRACE("%p\n", wayland);
 
+    wl_list_for_each_safe(output, output_tmp, &wayland->output_list, link)
+        wayland_output_destroy(output);
+
+    if (wayland->zxdg_output_manager_v1)
+        zxdg_output_manager_v1_destroy(wayland->zxdg_output_manager_v1);
+
     if (wayland->wl_compositor)
         wl_compositor_destroy(wayland->wl_compositor);
 
diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
new file mode 100644
index 00000000000..4b624ed7379
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -0,0 +1,492 @@
+/*
+ * Wayland output handling
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+#include "wine/heap.h"
+
+#include <stdlib.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+struct default_mode { int32_t width; int32_t height; };
+struct default_mode default_modes[] = {
+    { 320,  200}, /* CGA 16:10 */
+    { 320,  240}, /* QVGA 4:3 */
+    { 400,  300}, /* qSVGA 4:3 */
+    { 480,  320}, /* HVGA 3:2 */
+    { 512,  384}, /* MAC 4:3 */
+    { 640,  360}, /* nHD 16:9 */
+    { 640,  400}, /* VESA-0100h 16:10 */
+    { 640,  480}, /* VGA 4:3 */
+    { 720,  480}, /* WVGA 3:2 */
+    { 720,  576}, /* PAL 5:4 */
+    { 768,  480}, /* WVGA 16:10 */
+    { 768,  576}, /* PAL* 4:3 */
+    { 800,  600}, /* SVGA 4:3 */
+    { 854,  480}, /* FWVGA 16:9 */
+    { 960,  540}, /* qHD 16:9 */
+    { 960,  640}, /* DVGA 3:2 */
+    {1024,  576}, /* WSVGA 16:9 */
+    {1024,  640}, /* WSVGA 16:10 */
+    {1024,  768}, /* XGA 4:3 */
+    {1152,  864}, /* XGA+ 4:3 */
+    {1280,  720}, /* HD 16:9 */
+    {1280,  768}, /* WXGA 5:3 */
+    {1280,  800}, /* WXGA 16:10 */
+    {1280,  960}, /* SXGA- 4:3 */
+    {1280, 1024}, /* SXGA 5:4 */
+    {1366,  768}, /* FWXGA 16:9 */
+    {1400, 1050}, /* SXGA+ 4:3 */
+    {1440,  900}, /* WSXGA 16:10 */
+    {1600,  900}, /* HD+ 16:9 */
+    {1600, 1200}, /* UXGA 4:3 */
+    {1680, 1050}, /* WSXGA+ 16:10 */
+    {1920, 1080}, /* FHD 16:9 */
+    {1920, 1200}, /* WUXGA 16:10 */
+    {2048, 1152}, /* QWXGA 16:9 */
+    {2048, 1536}, /* QXGA 4:3 */
+    {2560, 1440}, /* QHD 16:9 */
+    {2560, 1600}, /* WQXGA 16:10 */
+    {2560, 2048}, /* QSXGA 5:4 */
+    {2880, 1620}, /* 3K 16:9 */
+    {3200, 1800}, /* QHD+ 16:9 */
+    {3200, 2400}, /* QUXGA 4:3 */
+    {3840, 2160}, /* 4K 16:9 */
+    {3840, 2400}, /* WQUXGA 16:10 */
+    {5120, 2880}, /* 5K 16:9 */
+    {7680, 4320}, /* 8K 16:9 */
+};
+
+/**********************************************************************
+ *          Output handling
+ */
+
+/* Compare mode with the set of provided mode parameters and return -1 if the
+ * mode compares less than the parameters, 0 if the mode compares equal to the
+ * parameters, and 1 if the mode compares greater than the parameters.
+ *
+ * The comparison is based on comparing the width, height, bpp and refresh
+ * in that order.
+ */
+static int wayland_output_mode_cmp(struct wayland_output_mode *mode,
+                                   int32_t width, int32_t height,
+                                   int32_t refresh, int bpp)
+{
+    if (mode->width < width) return -1;
+    if (mode->width > width) return 1;
+    if (mode->height < height) return -1;
+    if (mode->height > height) return 1;
+    if (mode->bpp < bpp) return -1;
+    if (mode->bpp > bpp) return 1;
+    if (mode->refresh < refresh) return -1;
+    if (mode->refresh > refresh) return 1;
+    return 0;
+}
+
+static void wayland_output_add_mode(struct wayland_output *output,
+                                    int32_t width, int32_t height,
+                                    int32_t refresh, int bpp,
+                                    BOOL current, BOOL native)
+{
+    struct wayland_output_mode *mode;
+    struct wl_list *insert_after_link = output->mode_list.prev;
+
+    /* Update mode if it's already in list, otherwise find the insertion point
+     * to maintain the sorted order. */
+    wl_list_for_each(mode, &output->mode_list, link)
+    {
+        int cmp = wayland_output_mode_cmp(mode, width, height, refresh, bpp);
+        if (cmp == 0) /* mode == new */
+        {
+            /* Upgrade modes from virtual to native, never the reverse. */
+            if (native) mode->native = TRUE;
+            if (current)
+                output->current_mode = mode;
+            return;
+        }
+        else if (cmp == 1) /* mode > new */
+        {
+            insert_after_link = mode->link.prev;
+            break;
+        }
+    }
+
+    mode = heap_alloc_zero(sizeof(*mode));
+
+    mode->width = width;
+    mode->height = height;
+    mode->refresh = refresh;
+    mode->bpp = bpp;
+    mode->native = native;
+
+    if (current)
+        output->current_mode = mode;
+
+    wl_list_insert(insert_after_link, &mode->link);
+}
+
+static void wayland_output_add_mode_all_bpp(struct wayland_output *output,
+                                            int32_t width, int32_t height,
+                                            int32_t refresh, BOOL current,
+                                            BOOL native)
+{
+    wayland_output_add_mode(output, width, height, refresh, 32, current, native);
+    wayland_output_add_mode(output, width, height, refresh, 16, FALSE, native);
+    wayland_output_add_mode(output, width, height, refresh, 8, FALSE, native);
+}
+
+static void wayland_output_add_default_modes(struct wayland_output *output)
+{
+    int i;
+    struct wayland_output_mode *mode, *tmp;
+    int32_t max_width = 0;
+    int32_t max_height = 0;
+    int32_t current_refresh =
+        output->current_mode ? output->current_mode->refresh : 60000;
+
+    /* Remove all existing virtual modes and get the maximum native
+     * mode size. */
+    wl_list_for_each_safe(mode, tmp, &output->mode_list, link)
+    {
+        if (!mode->native)
+        {
+            wl_list_remove(&mode->link);
+            heap_free(mode);
+        }
+        else
+        {
+            max_width = mode->width > max_width ? mode->width : max_width;
+            max_height = mode->height > max_height ? mode->height : max_height;
+        }
+    }
+
+    for (i = 0; i < ARRAY_SIZE(default_modes); i++)
+    {
+        int32_t width = default_modes[i].width;
+        int32_t height = default_modes[i].height;
+
+        /* Skip if this mode is larger than the largest native mode. */
+        if (width > max_width || height > max_height)
+        {
+            TRACE("Skipping mode %dx%d (max: %dx%d)\n",
+                    width, height, max_width, max_height);
+            continue;
+        }
+
+        wayland_output_add_mode_all_bpp(output, width, height, current_refresh,
+                                        FALSE, FALSE);
+    }
+}
+
+static struct wayland_output **
+wayland_output_array_append(struct wayland_output **array, int size,
+                            struct wayland_output *output)
+{
+    struct wayland_output **realloc_array;
+
+    realloc_array = heap_realloc(array, sizeof(*array) * size);
+    if (!realloc_array)
+    {
+        heap_free(array);
+        return NULL;
+    }
+
+    realloc_array[size - 1] = output;
+
+    return realloc_array;
+}
+
+static void wayland_output_update_physical_coords(struct wayland_output *output)
+{
+    struct wayland_output *o;
+    struct wayland_output **changed = NULL;
+    int changed_size = 0;
+    int changed_i = 0;
+
+    /* Set some default values. */
+    output->x = output->logical_x;
+    output->y = output->logical_y;
+
+    /* Update output->x,y based on other outputs that are to
+     * to the left or above. */
+    wl_list_for_each(o, &output->wayland->output_list, link)
+    {
+        if (o == output || o->logical_w == 0 || o->logical_h == 0) continue;
+        if (output->logical_x == o->logical_x + o->logical_w)
+            output->x = o->x + o->current_mode->width;
+        if (output->logical_y == o->logical_y + o->logical_h)
+            output->y = o->y + o->current_mode->height;
+    }
+
+    changed = wayland_output_array_append(changed, ++changed_size, output);
+    if (!changed) { ERR("memory allocation failed"); return; }
+
+    /* Update the x,y of other outputs that are to the right or below and are
+     * directly or indirectly affected by the change output->x,y.
+     */
+    for (changed_i = 0; changed_i < changed_size; changed_i++)
+    {
+        struct wayland_output *cur = changed[changed_i];
+        wl_list_for_each(o, &output->wayland->output_list, link)
+        {
+            if (o == cur || o->logical_w == 0 || o->logical_h == 0) continue;
+            if (o->logical_x == cur->logical_x + cur->logical_w)
+            {
+                o->x = cur->x + cur->current_mode->width;
+                changed = wayland_output_array_append(changed, ++changed_size, o);
+                if (!changed) { ERR("memory allocation failed"); return; }
+            }
+            if (o->logical_y == cur->logical_y + cur->logical_h)
+            {
+                o->y = cur->y + cur->current_mode->height;
+                changed = wayland_output_array_append(changed, ++changed_size, o);
+                if (!changed) { ERR("memory allocation failed"); return; }
+            }
+        }
+    }
+
+    heap_free(changed);
+}
+
+static void wayland_output_clear_modes(struct wayland_output *output)
+{
+    struct wayland_output_mode *mode, *tmp;
+
+    wl_list_for_each_safe(mode, tmp, &output->mode_list, link)
+    {
+        wl_list_remove(&mode->link);
+        heap_free(mode);
+    }
+}
+
+static void wayland_output_done(struct wayland_output *output)
+{
+    struct wayland_output_mode *mode;
+    struct wayland_output *o;
+
+    TRACE("output->name=%s\n", output->name);
+
+    wayland_output_add_default_modes(output);
+    wayland_output_update_physical_coords(output);
+
+    wl_list_for_each(mode, &output->mode_list, link)
+    {
+        TRACE("mode %dx%d @ %d %s\n",
+              mode->width, mode->height, mode->refresh,
+              output->current_mode == mode ? "*" : "");
+    }
+
+    wl_list_for_each(o, &output->wayland->output_list, link)
+    {
+        if (!o->current_mode) continue;
+        TRACE("output->name=%s logical=%d,%d+%dx%d physical=%d,%d+%dx%d\n",
+              o->name,
+              o->logical_x, output->logical_y, o->logical_w, o->logical_h,
+              o->x, o->y, o->current_mode->width, o->current_mode->height);
+    }
+}
+
+static void output_handle_geometry(void *data, struct wl_output *wl_output,
+                                   int32_t x, int32_t y,
+                                   int32_t physical_width, int32_t physical_height,
+                                   int32_t subpixel,
+                                   const char *make, const char *model,
+                                   int32_t output_transform)
+{
+}
+
+static void output_handle_mode(void *data, struct wl_output *wl_output,
+                               uint32_t flags, int32_t width, int32_t height,
+                               int32_t refresh)
+{
+    struct wayland_output *output = data;
+
+    wayland_output_add_mode_all_bpp(output, width, height, refresh,
+                                    (flags & WL_OUTPUT_MODE_CURRENT),
+                                    TRUE);
+}
+
+static void output_handle_done(void *data, struct wl_output *wl_output)
+{
+    struct wayland_output *output = data;
+    if (!output->zxdg_output_v1 ||
+        zxdg_output_v1_get_version(output->zxdg_output_v1) >= 3)
+    {
+        wayland_output_done(output);
+    }
+}
+
+static void output_handle_scale(void *data, struct wl_output *wl_output,
+                                int32_t scale)
+{
+    struct wayland_output *output = data;
+    TRACE("output=%p scale=%d\n", output, scale);
+    output->scale = scale;
+}
+
+static const struct wl_output_listener output_listener = {
+    output_handle_geometry,
+    output_handle_mode,
+    output_handle_done,
+    output_handle_scale
+};
+
+static void zxdg_output_v1_handle_logical_position(void *data,
+                                                   struct zxdg_output_v1 *zxdg_output_v1,
+                                                   int32_t x,
+                                                   int32_t y)
+{
+    struct wayland_output *output = data;
+    TRACE("logical_x=%d logical_y=%d\n", x, y);
+    output->logical_x = x;
+    output->logical_y = y;
+}
+
+static void zxdg_output_v1_handle_logical_size(void *data,
+                                               struct zxdg_output_v1 *zxdg_output_v1,
+                                               int32_t width,
+                                               int32_t height)
+{
+    struct wayland_output *output = data;
+    TRACE("logical_w=%d logical_h=%d\n", width, height);
+    output->logical_w = width;
+    output->logical_h = height;
+}
+
+static void zxdg_output_v1_handle_done(void *data,
+                                       struct zxdg_output_v1 *zxdg_output_v1)
+{
+    if (zxdg_output_v1_get_version(zxdg_output_v1) < 3)
+    {
+        struct wayland_output *output = data;
+        wayland_output_done(output);
+    }
+}
+
+static void zxdg_output_v1_handle_name(void *data,
+                                       struct zxdg_output_v1 *zxdg_output_v1,
+                                       const char *name)
+{
+    struct wayland_output *output = data;
+
+    free(output->name);
+    output->name = strdup(name);
+}
+
+static void zxdg_output_v1_handle_description(void *data,
+                                              struct zxdg_output_v1 *zxdg_output_v1,
+                                              const char *description)
+{
+}
+
+static const struct zxdg_output_v1_listener zxdg_output_v1_listener = {
+    zxdg_output_v1_handle_logical_position,
+    zxdg_output_v1_handle_logical_size,
+    zxdg_output_v1_handle_done,
+    zxdg_output_v1_handle_name,
+    zxdg_output_v1_handle_description,
+};
+
+/**********************************************************************
+ *          wayland_output_create
+ *
+ *  Creates a wayland_output and adds it to the output list.
+ */
+BOOL wayland_output_create(struct wayland *wayland, uint32_t id, uint32_t version)
+{
+    struct wayland_output *output = heap_alloc_zero(sizeof(*output));
+
+    if (!output)
+    {
+        ERR("Couldn't allocate space for wayland_output\n");
+        goto err;
+    }
+
+    output->wayland = wayland;
+    output->wl_output = wl_registry_bind(wayland->wl_registry, id,
+                                         &wl_output_interface,
+                                         version < 2 ? version : 2);
+    output->global_id = id;
+    wl_output_add_listener(output->wl_output, &output_listener, output);
+
+    wl_list_init(&output->mode_list);
+    wl_list_init(&output->link);
+
+    output->scale = 1;
+
+    /* Have a fallback in case xdg_output is not supported or name is not sent. */
+    output->name = malloc(20);
+    if (output->name)
+    {
+        snprintf(output->name, 20, "WaylandOutput%d",
+                 wayland->next_fallback_output_id++);
+    }
+    else
+    {
+        ERR("Couldn't allocate space for output name\n");
+        goto err;
+    }
+
+    if (wayland->zxdg_output_manager_v1)
+        wayland_output_use_xdg_extension(output);
+
+    wl_list_insert(output->wayland->output_list.prev, &output->link);
+
+    return TRUE;
+
+err:
+    if (output) wayland_output_destroy(output);
+    return FALSE;
+}
+
+/**********************************************************************
+ *          wayland_output_destroy
+ *
+ *  Destroys a wayland_output.
+ */
+void wayland_output_destroy(struct wayland_output *output)
+{
+    wayland_output_clear_modes(output);
+    wl_list_remove(&output->link);
+    free(output->name);
+    if (output->zxdg_output_v1)
+        zxdg_output_v1_destroy(output->zxdg_output_v1);
+    wl_output_destroy(output->wl_output);
+
+    heap_free(output);
+}
+
+/**********************************************************************
+ *          wayland_output_use_xdg_extension
+ *
+ *  Use the zxdg_output_v1 extension to get output information.
+ */
+void wayland_output_use_xdg_extension(struct wayland_output *output)
+{
+    output->zxdg_output_v1 =
+        zxdg_output_manager_v1_get_xdg_output(output->wayland->zxdg_output_manager_v1,
+                                              output->wl_output);
+    zxdg_output_v1_add_listener(output->zxdg_output_v1, &zxdg_output_v1_listener,
+                                output);
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index ecad650ce6a..e9fe5be3407 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -27,6 +27,7 @@
 
 #include <stdarg.h>
 #include <wayland-client.h>
+#include "xdg-output-unstable-v1-client-protocol.h"
 
 #include "windef.h"
 #include "winbase.h"
@@ -46,6 +47,35 @@ struct wayland
     struct wl_event_queue *wl_event_queue;
     struct wl_registry *wl_registry;
     struct wl_compositor *wl_compositor;
+    struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
+    uint32_t next_fallback_output_id;
+    struct wl_list output_list;
+};
+
+struct wayland_output_mode
+{
+    struct wl_list link;
+    int32_t width;
+    int32_t height;
+    int32_t refresh;
+    int bpp;
+    BOOL native;
+};
+
+struct wayland_output
+{
+    struct wl_list link;
+    struct wayland *wayland;
+    struct wl_output *wl_output;
+    struct zxdg_output_v1 *zxdg_output_v1;
+    struct wl_list mode_list;
+    struct wayland_output_mode *current_mode;
+    int logical_x, logical_y;  /* logical position */
+    int logical_w, logical_h;  /* logical size */
+    int x, y;  /* position in native pixel coordinate space */
+    int scale; /* wayland output scale factor for hidpi */
+    char *name;
+    uint32_t global_id;
 };
 
 /**********************************************************************
@@ -79,6 +109,14 @@ BOOL wayland_is_process(struct wayland *wayland);
 struct wayland *wayland_process_acquire(void);
 void wayland_process_release(void);
 
+/**********************************************************************
+ *          Wayland output
+ */
+
+BOOL wayland_output_create(struct wayland *wayland, uint32_t id, uint32_t version);
+void wayland_output_destroy(struct wayland_output *output);
+void wayland_output_use_xdg_extension(struct wayland_output *output);
+
 /**********************************************************************
  *          USER driver functions
  */
-- 
2.34.1


From 76d4c731213de06c824bbc8667884a81d52f333c Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 9 Nov 2021 18:58:22 +0200
Subject: [PATCH 012/147] winewayland.drv: Add stub for driver window messages.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h      |  1 +
 dlls/winewayland.drv/waylanddrv_main.c |  1 +
 dlls/winewayland.drv/window.c          | 16 ++++++++++++++++
 3 files changed, 18 insertions(+)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index e9fe5be3407..ab79c6b4a1e 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -122,5 +122,6 @@ void wayland_output_use_xdg_extension(struct wayland_output *output);
  */
 
 extern BOOL CDECL WAYLAND_CreateWindow(HWND hwnd) DECLSPEC_HIDDEN;
+extern LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
 
 #endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 7ee7ec9435e..249bf08cbfd 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -81,6 +81,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
 {
     .pCreateWindow = WAYLAND_CreateWindow,
     .pThreadDetach = WAYLAND_ThreadDetach,
+    .pWindowMessage = WAYLAND_WindowMessage,
 };
 
 /***********************************************************************
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 66e5c632ed8..cc5c99318cf 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -47,3 +47,19 @@ BOOL CDECL WAYLAND_CreateWindow(HWND hwnd)
 
     return TRUE;
 }
+
+/**********************************************************************
+ *           WAYLAND_WindowMessage
+ */
+LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
+{
+    TRACE("msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp);
+
+    switch (msg)
+    {
+    default:
+        FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp);
+    }
+
+    return 0;
+}
-- 
2.34.1


From aa5f82184322eddb85a671a32a7aa08c886234a5 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 2 Sep 2021 15:28:21 +0300
Subject: [PATCH 013/147] winewayland.drv: Update Windows monitor information
 on Wayland changes.

Whenever the Wayland output display state changes (including during
initialization), update the monitor information on the Windows side to
reflect these changes. The update happens when handling output events
targeting the per-process Wayland instance.

We currently support a single GPU, and a single monitor for each
adapter.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |   3 +-
 dlls/winewayland.drv/display.c         | 140 +++++++++++++++++++++++++
 dlls/winewayland.drv/wayland.c         |   2 +
 dlls/winewayland.drv/wayland_output.c  |   3 +
 dlls/winewayland.drv/waylanddrv.h      |   7 ++
 dlls/winewayland.drv/waylanddrv_main.c |   1 +
 6 files changed, 155 insertions(+), 1 deletion(-)
 create mode 100644 dlls/winewayland.drv/display.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index f1e1d1cc655..8ccbac45930 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,5 +1,5 @@
 MODULE    = winewayland.drv
-IMPORTS   = user32
+IMPORTS   = user32 win32u
 EXTRAINCL = $(WAYLAND_CLIENT_CFLAGS)
 EXTRALIBS = $(WAYLAND_CLIENT_LIBS)
 CFLAGS = -std=c11 -Wno-declaration-after-statement
@@ -10,6 +10,7 @@ EXTRACROSSCFLAGS = -std=c11 -Wno-declaration-after-statement
 EXTRADLLFLAGS = -mcygwin
 
 C_SRCS = \
+	display.c \
 	wayland.c \
 	wayland_output.c \
 	waylanddrv_main.c \
diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
new file mode 100644
index 00000000000..4b5d2c2449d
--- /dev/null
+++ b/dlls/winewayland.drv/display.c
@@ -0,0 +1,140 @@
+/*
+ * WAYLAND display device functions
+ *
+ * Copyright 2019 Zhiyi Zhang for CodeWeavers
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define NONAMELESSUNION
+#define NONAMELESSSTRUCT
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "winreg.h"
+#include "wine/debug.h"
+#include "wine/unicode.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+static BOOL force_display_devices_refresh;
+
+static void wayland_refresh_display_devices(void)
+{
+    UINT32 num_path, num_mode;
+    force_display_devices_refresh = TRUE;
+    /* trigger refresh in win32u */
+    NtUserGetDisplayConfigBufferSizes(QDC_ONLY_ACTIVE_PATHS, &num_path, &num_mode);
+}
+
+void wayland_init_display_devices()
+{
+    wayland_refresh_display_devices();
+}
+
+static void wayland_add_gpu(const struct gdi_device_manager *device_manager,
+                            void *param)
+{
+    static const WCHAR wayland_gpuW[] = {'W','a','y','l','a','n','d','G','P','U',0};
+    struct gdi_gpu gpu = {0};
+    lstrcpyW(gpu.name, wayland_gpuW);
+
+    /* TODO: Fill in gpu information from vulkan. */
+
+    TRACE("id=0x%s name=%s\n",
+          wine_dbgstr_longlong(gpu.id), wine_dbgstr_w(gpu.name));
+
+    device_manager->add_gpu(&gpu, param);
+}
+
+static void wayland_add_adapter(const struct gdi_device_manager *device_manager,
+                                void *param, INT output_id)
+{
+    struct gdi_adapter adapter;
+    adapter.id = output_id;
+    adapter.state_flags = DISPLAY_DEVICE_ATTACHED_TO_DESKTOP;
+    if (output_id == 0)
+        adapter.state_flags |= DISPLAY_DEVICE_PRIMARY_DEVICE;
+
+    TRACE("id=0x%s state_flags=0x%x\n",
+          wine_dbgstr_longlong(adapter.id), adapter.state_flags);
+
+    device_manager->add_adapter(&adapter, param);
+}
+
+static void wayland_add_monitor(const struct gdi_device_manager *device_manager,
+                                void *param, struct wayland_output *output)
+{
+
+    struct gdi_monitor monitor = {0};
+
+    if (!MultiByteToWideChar(CP_UTF8, 0, output->name, -1, monitor.name,
+                             ARRAY_SIZE(monitor.name)))
+    {
+        monitor.name[0] = 0;
+    }
+
+    SetRect(&monitor.rc_monitor, output->x, output->y,
+            output->x + output->current_mode->width,
+            output->y + output->current_mode->height);
+
+    /* We don't have a direct way to get the work area in Wayland. */
+    monitor.rc_work = monitor.rc_monitor;
+
+    monitor.state_flags = DISPLAY_DEVICE_ATTACHED | DISPLAY_DEVICE_ACTIVE;
+
+    TRACE("name=%s rc_monitor=rc_work=%s state_flags=0x%x\n",
+          wine_dbgstr_w(monitor.name), wine_dbgstr_rect(&monitor.rc_monitor),
+          monitor.state_flags);
+
+    device_manager->add_monitor(&monitor, param);
+}
+
+/***********************************************************************
+ *      UpdateDisplayDevices (WAYLAND.@)
+ */
+void CDECL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
+                                        BOOL force, void *param)
+{
+    struct wayland *wayland;
+    struct wayland_output *output;
+    INT output_id = 0;
+
+    if (!force && !force_display_devices_refresh) return;
+
+    TRACE("force=%d force_refresh=%d\n", force, force_display_devices_refresh);
+
+    force_display_devices_refresh = FALSE;
+
+    wayland = wayland_process_acquire();
+
+    wayland_add_gpu(device_manager, param);
+
+    wl_list_for_each(output, &wayland->output_list, link)
+    {
+        if (!output->current_mode) continue;
+
+        /* TODO: Detect and support multiple monitors per adapter (i.e., mirroring). */
+        wayland_add_adapter(device_manager, param, output_id);
+        wayland_add_monitor(device_manager, param, output);
+
+        output_id++;
+    }
+
+    wayland_process_release();
+}
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 1f5c966121a..64c041d6c1c 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -94,6 +94,8 @@ static void registry_handle_global_remove(void *data, struct wl_registry *regist
         {
             TRACE("removing output->name=%s\n", output->name);
             wayland_output_destroy(output);
+            if (wayland_is_process(wayland))
+                wayland_init_display_devices();
             return;
         }
     }
diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index 4b624ed7379..7fdee76bcd0 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -305,6 +305,9 @@ static void wayland_output_done(struct wayland_output *output)
               o->logical_x, output->logical_y, o->logical_w, o->logical_h,
               o->x, o->y, o->current_mode->width, o->current_mode->height);
     }
+
+    if (wayland_is_process(output->wayland))
+        wayland_init_display_devices();
 }
 
 static void output_handle_geometry(void *data, struct wl_output *wl_output,
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index ab79c6b4a1e..661280da21a 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -31,6 +31,9 @@
 
 #include "windef.h"
 #include "winbase.h"
+#include "wingdi.h"
+
+#include "wine/gdi_driver.h"
 
 extern struct wl_display *process_wl_display;
 
@@ -108,6 +111,7 @@ void wayland_deinit(struct wayland *wayland);
 BOOL wayland_is_process(struct wayland *wayland);
 struct wayland *wayland_process_acquire(void);
 void wayland_process_release(void);
+void wayland_init_display_devices(void);
 
 /**********************************************************************
  *          Wayland output
@@ -122,6 +126,9 @@ void wayland_output_use_xdg_extension(struct wayland_output *output);
  */
 
 extern BOOL CDECL WAYLAND_CreateWindow(HWND hwnd) DECLSPEC_HIDDEN;
+extern void CDECL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
+                                               BOOL force, void *param) DECLSPEC_HIDDEN;
 extern LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
 
+
 #endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 249bf08cbfd..c26caa059b0 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -81,6 +81,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
 {
     .pCreateWindow = WAYLAND_CreateWindow,
     .pThreadDetach = WAYLAND_ThreadDetach,
+    .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
     .pWindowMessage = WAYLAND_WindowMessage,
 };
 
-- 
2.34.1


From 87f525e04efdb602e6b813d84d21eaabf9a45167 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 9 Nov 2021 19:22:04 +0200
Subject: [PATCH 014/147] winewayland.drv: Broadcast WM_DISPLAYCHANGE after
 monitor updates.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/display.c    | 32 +++++++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h |  9 +++++++++
 dlls/winewayland.drv/window.c     |  4 ++++
 3 files changed, 45 insertions(+)

diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index 4b5d2c2449d..9fcbd9554a1 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -42,9 +42,41 @@ static void wayland_refresh_display_devices(void)
     NtUserGetDisplayConfigBufferSizes(QDC_ONLY_ACTIVE_PATHS, &num_path, &num_mode);
 }
 
+static void wayland_broadcast_wm_display_change(void)
+{
+    struct wayland_output *output;
+    struct wayland *wayland = wayland_process_acquire();
+
+    /* During thread wayland initialization we will get our initial output
+     * information and init the display devices. There is no need to send out
+     * WM_DISPLAYCHANGE in this case, since this is the initial display state.
+     * Additionally, thread initialization may occur in a context that has
+     * acquired the internal Wine user32 lock, and sending messages would lead
+     * to an internal user32 lock error. */
+    if (wayland->initialized)
+    {
+        /* The first valid output is the primary. */
+        wl_list_for_each(output, &wayland->output_list, link)
+        {
+            int width, height;
+            if (!output->current_mode) continue;
+            width = output->current_mode->width;
+            height = output->current_mode->height;
+            wayland_process_release();
+
+            SendMessageW(GetDesktopWindow(), WM_WAYLAND_BROADCAST_DISPLAY_CHANGE,
+                         32, MAKELPARAM(width, height));
+            return;
+        }
+    }
+
+    wayland_process_release();
+}
+
 void wayland_init_display_devices()
 {
     wayland_refresh_display_devices();
+    wayland_broadcast_wm_display_change();
 }
 
 static void wayland_add_gpu(const struct gdi_device_manager *device_manager,
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 661280da21a..8a473046452 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -37,6 +37,15 @@
 
 extern struct wl_display *process_wl_display;
 
+/**********************************************************************
+  *          Internal messages and data
+  */
+
+enum wayland_window_message
+{
+    WM_WAYLAND_BROADCAST_DISPLAY_CHANGE = 0x80001000,
+};
+
 /**********************************************************************
  *          Definitions for wayland types
  */
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index cc5c99318cf..9a462d46f89 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -57,6 +57,10 @@ LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
 
     switch (msg)
     {
+    case WM_WAYLAND_BROADCAST_DISPLAY_CHANGE:
+        SendMessageTimeoutW(HWND_BROADCAST, WM_DISPLAYCHANGE, wp, lp,
+                            SMTO_ABORTIFHUNG, 2000, NULL);
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp);
     }
-- 
2.34.1


From 5b0594d541c432a20239cbd41550fca2fe0386e4 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 8 Nov 2021 13:23:34 +0200
Subject: [PATCH 015/147] winewayland.drv: Track the Wine monitor associated
 with a Wayland output.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/display.c        | 12 +++++++
 dlls/winewayland.drv/wayland_output.c | 51 +++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h     |  4 +++
 3 files changed, 67 insertions(+)

diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index 9fcbd9554a1..3ae5d3935f4 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -32,6 +32,7 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+static const WCHAR adapter_name_fmtW[] = {'\\','\\','.','\\','D','I','S','P','L','A','Y','%','d',0};
 static BOOL force_display_devices_refresh;
 
 static void wayland_refresh_display_devices(void)
@@ -168,5 +169,16 @@ void CDECL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_
         output_id++;
     }
 
+    /* Set wine name in wayland_output so that we can look it up. */
+    output_id = 0;
+    wl_list_for_each(output, &wayland->output_list, link)
+    {
+        snprintfW(output->wine_name, ARRAY_SIZE(output->wine_name),
+                  adapter_name_fmtW, output_id + 1);
+        TRACE("name=%s wine_name=%s\n",
+              output->name, wine_dbgstr_w(output->wine_name));
+        output_id++;
+    }
+
     wayland_process_release();
 }
diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index 7fdee76bcd0..b50230fb5e9 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -308,6 +308,8 @@ static void wayland_output_done(struct wayland_output *output)
 
     if (wayland_is_process(output->wayland))
         wayland_init_display_devices();
+    else
+        wayland_update_outputs_from_process(output->wayland);
 }
 
 static void output_handle_geometry(void *data, struct wl_output *wl_output,
@@ -493,3 +495,52 @@ void wayland_output_use_xdg_extension(struct wayland_output *output)
     zxdg_output_v1_add_listener(output->zxdg_output_v1, &zxdg_output_v1_listener,
                                 output);
 }
+
+/**********************************************************************
+ *          wayland_update_outputs_from_process
+ *
+ * Update the information in the outputs of this instance, using the
+ * information in the process wayland instance.
+ */
+void wayland_update_outputs_from_process(struct wayland *wayland)
+{
+    struct wayland_output *output;
+    struct wayland_output *process_output;
+    struct wayland *process_wayland = wayland_process_acquire();
+
+    TRACE("wayland=%p process_wayland=%p\n", wayland, process_wayland);
+
+    wl_list_for_each(output, &wayland->output_list, link)
+    {
+        wl_list_for_each(process_output, &process_wayland->output_list, link)
+        {
+            if (!strcmp(output->name, process_output->name))
+            {
+                lstrcpyW(output->wine_name, process_output->wine_name);
+                break;
+            }
+        }
+    }
+
+    wayland_process_release();
+}
+
+/**********************************************************************
+ *          wayland_output_get_by_wine_name
+ *
+ *  Returns the wayland_output with the specified Wine name (or NULL
+ *  if not present).
+ */
+struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
+                                                       LPCWSTR wine_name)
+{
+    struct wayland_output *output;
+
+    wl_list_for_each(output, &wayland->output_list, link)
+    {
+        if (!lstrcmpiW(wine_name, output->wine_name))
+            return output;
+    }
+
+    return NULL;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 8a473046452..6f574ffdc78 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -87,6 +87,7 @@ struct wayland_output
     int x, y;  /* position in native pixel coordinate space */
     int scale; /* wayland output scale factor for hidpi */
     char *name;
+    WCHAR wine_name[128];
     uint32_t global_id;
 };
 
@@ -129,6 +130,9 @@ void wayland_init_display_devices(void);
 BOOL wayland_output_create(struct wayland *wayland, uint32_t id, uint32_t version);
 void wayland_output_destroy(struct wayland_output *output);
 void wayland_output_use_xdg_extension(struct wayland_output *output);
+void wayland_update_outputs_from_process(struct wayland *wayland);
+struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
+                                                       LPCWSTR wine_name);
 
 /**********************************************************************
  *          USER driver functions
-- 
2.34.1


From c6498e7a7595c6c28c47fb211fb47b04a6287181 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 2 Sep 2021 15:34:01 +0300
Subject: [PATCH 016/147] winewayland.drv: Implement EnumDisplaySettingsEx.

Implement EnumDisplaySettingsEx by using the Wayland display output
information stored in the per-process instance.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |   2 +-
 dlls/winewayland.drv/display.c         | 216 +++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |   1 +
 dlls/winewayland.drv/waylanddrv_main.c |   1 +
 4 files changed, 219 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 8ccbac45930..c9ef96495ea 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,5 +1,5 @@
 MODULE    = winewayland.drv
-IMPORTS   = user32 win32u
+IMPORTS   = advapi32 user32 win32u
 EXTRAINCL = $(WAYLAND_CLIENT_CFLAGS)
 EXTRALIBS = $(WAYLAND_CLIENT_LIBS)
 CFLAGS = -std=c11 -Wno-declaration-after-statement
diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index 3ae5d3935f4..1aa6dc3333e 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -182,3 +182,219 @@ void CDECL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_
 
     wayland_process_release();
 }
+
+static HANDLE acquire_display_devices_init_mutex(void)
+{
+    static const WCHAR init_mutexW[] = {'d','i','s','p','l','a','y','_','d','e','v','i','c','e','_','i','n','i','t',0};
+    HANDLE mutex = CreateMutexW(NULL, FALSE, init_mutexW);
+
+    WaitForSingleObject(mutex, INFINITE);
+    return mutex;
+}
+
+static void release_display_devices_init_mutex(HANDLE mutex)
+{
+    ReleaseMutex(mutex);
+    CloseHandle(mutex);
+}
+
+static BOOL get_display_device_reg_key(const WCHAR *device_name, WCHAR *key, unsigned len)
+{
+    static const WCHAR display[] = {'\\','\\','.','\\','D','I','S','P','L','A','Y'};
+    static const WCHAR video_value_fmt[] = {'\\','D','e','v','i','c','e','\\',
+                                            'V','i','d','e','o','%','d',0};
+    static const WCHAR video_key[] = {'H','A','R','D','W','A','R','E','\\',
+                                      'D','E','V','I','C','E','M','A','P','\\',
+                                      'V','I','D','E','O','\\',0};
+    WCHAR value_name[MAX_PATH], buffer[MAX_PATH], *end_ptr;
+    DWORD adapter_index, size;
+
+    /* Device name has to be \\.\DISPLAY%d */
+    if (strncmpiW(device_name, display, ARRAY_SIZE(display)))
+        return FALSE;
+
+    /* Parse \\.\DISPLAY* */
+    adapter_index = strtolW(device_name + ARRAY_SIZE(display), &end_ptr, 10) - 1;
+    if (*end_ptr)
+        return FALSE;
+
+    /* Open \Device\Video* in HKLM\HARDWARE\DEVICEMAP\VIDEO\ */
+    sprintfW(value_name, video_value_fmt, adapter_index);
+    size = sizeof(buffer);
+    if (RegGetValueW(HKEY_LOCAL_MACHINE, video_key, value_name, RRF_RT_REG_SZ, NULL, buffer, &size))
+        return FALSE;
+
+    if (len < lstrlenW(buffer + 18) + 1)
+        return FALSE;
+
+    /* Skip \Registry\Machine\ prefix */
+    lstrcpyW(key, buffer + 18);
+    TRACE("display device %s registry settings key %s.\n", wine_dbgstr_w(device_name), wine_dbgstr_w(key));
+    return TRUE;
+}
+
+static BOOL read_registry_settings(const WCHAR *device_name, DEVMODEW *dm)
+{
+    WCHAR display_device_reg_key[MAX_PATH];
+    HANDLE mutex;
+    HKEY hkey;
+    DWORD type, size;
+    BOOL ret = TRUE;
+
+    dm->dmFields = 0;
+
+    mutex = acquire_display_devices_init_mutex();
+    if (!get_display_device_reg_key(device_name, display_device_reg_key,
+                                    ARRAY_SIZE(display_device_reg_key)))
+    {
+        ret = FALSE;
+        goto done;
+    }
+
+    if (RegOpenKeyExW(HKEY_CURRENT_CONFIG, display_device_reg_key, 0, KEY_READ, &hkey))
+    {
+        ret = FALSE;
+        goto done;
+    }
+
+#define query_value(name, data) \
+    size = sizeof(DWORD); \
+    if (RegQueryValueExA(hkey, name, 0, &type, (LPBYTE)(data), &size) || \
+        type != REG_DWORD || size != sizeof(DWORD)) \
+        ret = FALSE
+
+    query_value("DefaultSettings.BitsPerPel", &dm->dmBitsPerPel);
+    dm->dmFields |= DM_BITSPERPEL;
+    query_value("DefaultSettings.XResolution", &dm->dmPelsWidth);
+    dm->dmFields |= DM_PELSWIDTH;
+    query_value("DefaultSettings.YResolution", &dm->dmPelsHeight);
+    dm->dmFields |= DM_PELSHEIGHT;
+    query_value("DefaultSettings.VRefresh", &dm->dmDisplayFrequency);
+    dm->dmFields |= DM_DISPLAYFREQUENCY;
+    query_value("DefaultSettings.Flags", &dm->u2.dmDisplayFlags);
+    dm->dmFields |= DM_DISPLAYFLAGS;
+    query_value("DefaultSettings.XPanning", &dm->u1.s2.dmPosition.x);
+    query_value("DefaultSettings.YPanning", &dm->u1.s2.dmPosition.y);
+    dm->dmFields |= DM_POSITION;
+    query_value("DefaultSettings.Orientation", &dm->u1.s2.dmDisplayOrientation);
+    dm->dmFields |= DM_DISPLAYORIENTATION;
+    query_value("DefaultSettings.FixedOutput", &dm->u1.s2.dmDisplayFixedOutput);
+
+#undef query_value
+
+    RegCloseKey(hkey);
+
+done:
+    release_display_devices_init_mutex(mutex);
+    return ret;
+}
+
+static void populate_devmode(struct wayland_output_mode *output_mode, DEVMODEW *mode)
+{
+    mode->dmFields = DM_DISPLAYORIENTATION | DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT |
+                     DM_DISPLAYFLAGS | DM_DISPLAYFREQUENCY | DM_POSITION;
+    mode->u1.s2.dmDisplayOrientation = DMDO_DEFAULT;
+    mode->u2.dmDisplayFlags = 0;
+    mode->u1.s2.dmPosition.x = 0;
+    mode->u1.s2.dmPosition.y = 0;
+    mode->dmBitsPerPel = output_mode->bpp;
+    mode->dmPelsWidth = output_mode->width;
+    mode->dmPelsHeight = output_mode->height;
+    mode->dmDisplayFrequency = output_mode->refresh / 1000;
+}
+
+static BOOL wayland_get_current_devmode(struct wayland *wayland, LPCWSTR name, DEVMODEW *mode)
+{
+    struct wayland_output *output;
+
+    output = wayland_output_get_by_wine_name(wayland, name);
+    if (!output)
+        return FALSE;
+
+    if (!output->current_mode)
+        return FALSE;
+
+    populate_devmode(output->current_mode, mode);
+
+    return TRUE;
+}
+
+static BOOL wayland_get_devmode(struct wayland *wayland, LPCWSTR name, DWORD n, DEVMODEW *mode)
+{
+    struct wayland_output *output;
+    struct wayland_output_mode *output_mode;
+    DWORD i = 0;
+
+    output = wayland_output_get_by_wine_name(wayland, name);
+    if (!output)
+        return FALSE;
+
+    wl_list_for_each(output_mode, &output->mode_list, link)
+    {
+        if (i == n)
+        {
+            populate_devmode(output_mode, mode);
+            return TRUE;
+        }
+        i++;
+    }
+
+    return FALSE;
+}
+
+/***********************************************************************
+ *		EnumDisplaySettingsEx  (WAYLAND.@)
+ *
+ */
+BOOL CDECL WAYLAND_EnumDisplaySettingsEx(LPCWSTR name, DWORD n, LPDEVMODEW devmode, DWORD flags)
+{
+    static const WCHAR dev_name[CCHDEVICENAME] =
+        {'W','i','n','e',' ','W','a','y','l','a','n','d',' ','d','r','i','v','e','r',0};
+    struct wayland *wayland = wayland_process_acquire();
+
+    TRACE("(%s,%d,%p,0x%08x) wayland=%p\n", debugstr_w(name), n, devmode, flags, wayland);
+
+    if (n == ENUM_REGISTRY_SETTINGS)
+    {
+        if (!read_registry_settings(name, devmode) &&
+            !wayland_get_current_devmode(wayland, name, devmode))
+        {
+            ERR("Failed to get %s registry display settings and native mode.\n",
+                wine_dbgstr_w(name));
+            goto err;
+        }
+        goto done;
+    }
+
+    if (n == ENUM_CURRENT_SETTINGS)
+    {
+        if (!wayland_get_current_devmode(wayland, name, devmode))
+        {
+            ERR("Failed to get %s current display settings.\n", wine_dbgstr_w(name));
+            goto err;
+        }
+        goto done;
+    }
+
+    if (!wayland_get_devmode(wayland, name, n, devmode))
+    {
+        WARN("Modes index out of range\n");
+        SetLastError(ERROR_NO_MORE_FILES);
+        goto err;
+    }
+
+done:
+    wayland_process_release();
+    TRACE("=> %dx%d\n", devmode->dmPelsWidth, devmode->dmPelsHeight);
+    /* Set generic fields */
+    devmode->dmSize = FIELD_OFFSET(DEVMODEW, dmICMMethod);
+    devmode->dmDriverExtra = 0;
+    devmode->dmSpecVersion = DM_SPECVERSION;
+    devmode->dmDriverVersion = DM_SPECVERSION;
+    lstrcpyW(devmode->dmDeviceName, dev_name);
+    return TRUE;
+
+err:
+    wayland_process_release();
+    return FALSE;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 6f574ffdc78..fa8b9ded164 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -139,6 +139,7 @@ struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
  */
 
 extern BOOL CDECL WAYLAND_CreateWindow(HWND hwnd) DECLSPEC_HIDDEN;
+extern BOOL CDECL WAYLAND_EnumDisplaySettingsEx(LPCWSTR name, DWORD n, LPDEVMODEW devmode, DWORD flags) DECLSPEC_HIDDEN;
 extern void CDECL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
                                                BOOL force, void *param) DECLSPEC_HIDDEN;
 extern LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index c26caa059b0..3562e747d89 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -80,6 +80,7 @@ static void CDECL WAYLAND_ThreadDetach(void)
 static const struct user_driver_funcs waylanddrv_funcs =
 {
     .pCreateWindow = WAYLAND_CreateWindow,
+    .pEnumDisplaySettingsEx = WAYLAND_EnumDisplaySettingsEx,
     .pThreadDetach = WAYLAND_ThreadDetach,
     .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
     .pWindowMessage = WAYLAND_WindowMessage,
-- 
2.34.1


From 45e5eb27d0dac12e17695a9c301bde8972409c1e Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 2 Sep 2021 16:22:13 +0300
Subject: [PATCH 017/147] winewayland.drv: Introduce private driver window data
 structure.

Introduce a private driver window data structure and use it to keep
track of some basic window data. Access to the information is protected
for multithreaded access.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h      |   5 +-
 dlls/winewayland.drv/waylanddrv_main.c |   3 +-
 dlls/winewayland.drv/window.c          | 142 ++++++++++++++++++++++++-
 3 files changed, 146 insertions(+), 4 deletions(-)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index fa8b9ded164..c1809cbd532 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -139,10 +139,13 @@ struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
  */
 
 extern BOOL CDECL WAYLAND_CreateWindow(HWND hwnd) DECLSPEC_HIDDEN;
+extern void CDECL WAYLAND_DestroyWindow(HWND hwnd) DECLSPEC_HIDDEN;
 extern BOOL CDECL WAYLAND_EnumDisplaySettingsEx(LPCWSTR name, DWORD n, LPDEVMODEW devmode, DWORD flags) DECLSPEC_HIDDEN;
 extern void CDECL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
                                                BOOL force, void *param) DECLSPEC_HIDDEN;
 extern LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
-
+extern BOOL CDECL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flags,
+                                            const RECT *window_rect, const RECT *client_rect,
+                                            RECT *visible_rect, struct window_surface **surface) DECLSPEC_HIDDEN;
 
 #endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 3562e747d89..0b54723c7a2 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -25,7 +25,6 @@
 #include "waylanddrv.h"
 
 #include "wine/debug.h"
-#include "wine/gdi_driver.h"
 #include "wine/heap.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
@@ -80,10 +79,12 @@ static void CDECL WAYLAND_ThreadDetach(void)
 static const struct user_driver_funcs waylanddrv_funcs =
 {
     .pCreateWindow = WAYLAND_CreateWindow,
+    .pDestroyWindow = WAYLAND_DestroyWindow,
     .pEnumDisplaySettingsEx = WAYLAND_EnumDisplaySettingsEx,
     .pThreadDetach = WAYLAND_ThreadDetach,
     .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
     .pWindowMessage = WAYLAND_WindowMessage,
+    .pWindowPosChanging = WAYLAND_WindowPosChanging,
 };
 
 /***********************************************************************
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 9a462d46f89..a7a2228097c 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -25,12 +25,111 @@
 
 #include "waylanddrv.h"
 
-#include "wine/debug.h"
-
 #include "winuser.h"
 
+#include "wine/debug.h"
+#include "wine/heap.h"
+
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+/* private window data */
+struct wayland_win_data
+{
+    /* hwnd that this private data belongs to */
+    HWND           hwnd;
+    /* parent hwnd for child windows */
+    HWND           parent;
+    /* USER window rectangle relative to parent */
+    RECT           window_rect;
+    /* client area relative to parent */
+    RECT           client_rect;
+};
+
+static CRITICAL_SECTION win_data_section;
+static CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &win_data_section,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": win_data_section") }
+};
+static CRITICAL_SECTION win_data_section = {&critsect_debug, -1, 0, 0, 0, 0};
+
+static struct wayland_win_data *win_data_context[32768];
+
+static inline int context_idx(HWND hwnd)
+{
+    return LOWORD(hwnd) >> 1;
+}
+
+/***********************************************************************
+ *           wayland_win_data_destroy
+ */
+static void wayland_win_data_destroy(struct wayland_win_data *data)
+{
+    TRACE("hwnd=%p\n", data->hwnd);
+    win_data_context[context_idx(data->hwnd)] = NULL;
+
+    heap_free(data);
+
+    LeaveCriticalSection(&win_data_section);
+}
+
+/***********************************************************************
+ *           wayland_win_data_get
+ *
+ * Lock and return the data structure associated with a window.
+ */
+static struct wayland_win_data *wayland_win_data_get(HWND hwnd)
+{
+    struct wayland_win_data *data;
+
+    if (!hwnd) return NULL;
+
+    EnterCriticalSection(&win_data_section);
+    if ((data = win_data_context[context_idx(hwnd)]) && data->hwnd == hwnd)
+        return data;
+    LeaveCriticalSection(&win_data_section);
+
+    return NULL;
+}
+
+/***********************************************************************
+ *           wayland_win_data_release
+ *
+ * Release the data returned by wayland_win_data_get.
+ */
+static void wayland_win_data_release(struct wayland_win_data *data)
+{
+    if (data) LeaveCriticalSection(&win_data_section);
+}
+
+/***********************************************************************
+ *           wayland_win_data_create
+ *
+ * Create a data window structure for an existing window.
+ */
+static struct wayland_win_data *wayland_win_data_create(HWND hwnd)
+{
+    struct wayland_win_data *data;
+    HWND parent;
+
+    /* Don't create win data for desktop or HWND_MESSAGE windows. */
+    if (!(parent = GetAncestor(hwnd, GA_PARENT))) return NULL;
+    if (parent != GetDesktopWindow() && !GetAncestor(parent, GA_PARENT)) return NULL;
+
+    if (!(data = heap_alloc_zero(sizeof(*data))))
+        return NULL;
+
+    data->hwnd = hwnd;
+
+    EnterCriticalSection(&win_data_section);
+    win_data_context[context_idx(hwnd)] = data;
+
+    TRACE("hwnd=%p\n", data->hwnd);
+
+    return data;
+}
+
 /**********************************************************************
  *           WAYLAND_CreateWindow
  */
@@ -48,6 +147,45 @@ BOOL CDECL WAYLAND_CreateWindow(HWND hwnd)
     return TRUE;
 }
 
+/***********************************************************************
+ *           WAYLAND_DestroyWindow
+ */
+void CDECL WAYLAND_DestroyWindow(HWND hwnd)
+{
+    struct wayland_win_data *data;
+
+    TRACE("%p\n", hwnd);
+
+    if (!(data = wayland_win_data_get(hwnd))) return;
+    wayland_win_data_destroy(data);
+}
+
+/***********************************************************************
+ *           WAYLAND_WindowPosChanging
+ */
+BOOL CDECL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flags,
+                                     const RECT *window_rect, const RECT *client_rect,
+                                     RECT *visible_rect, struct window_surface **surface)
+{
+    struct wayland_win_data *data = wayland_win_data_get(hwnd);
+    BOOL exstyle = GetWindowLongW(hwnd, GWL_EXSTYLE);
+    DWORD style = GetWindowLongW(hwnd, GWL_STYLE);
+    HWND parent = GetAncestor(hwnd, GA_PARENT);
+
+    TRACE("win %p window %s client %s visible %s style %08x ex %08x flags %08x after %p\n",
+          hwnd, wine_dbgstr_rect(window_rect), wine_dbgstr_rect(client_rect),
+          wine_dbgstr_rect(visible_rect), style, exstyle, swp_flags, insert_after);
+
+    if (!data && !(data = wayland_win_data_create(hwnd))) return TRUE;
+
+    data->parent = (parent == GetDesktopWindow()) ? 0 : parent;
+    data->window_rect = *window_rect;
+    data->client_rect = *client_rect;
+
+    wayland_win_data_release(data);
+    return TRUE;
+}
+
 /**********************************************************************
  *           WAYLAND_WindowMessage
  */
-- 
2.34.1


From 21d13fa125fd2e45bcb6d7d871edbc88a294f15e Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 2 Sep 2021 17:11:53 +0300
Subject: [PATCH 018/147] winewayland.drv: Support dispatching Wayland buffer
 events independently.

Introduce a mechanism to dispatch Wayland buffer events, using a
separate per-thread Wayland event queue. We need this since buffer
events (e.g., buffer releases) may need to be manually dispatched in
contexts where it's unsafe to dispatch other events (e.g., in threads
other than the Wayland owner thread).

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c    | 29 +++++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h |  7 +++++++
 2 files changed, 36 insertions(+)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 64c041d6c1c..32c69734bbe 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -131,6 +131,12 @@ BOOL wayland_init(struct wayland *wayland)
         return FALSE;
     }
 
+    if (!(wayland->buffer_wl_event_queue = wl_display_create_queue(wayland->wl_display)))
+    {
+        ERR("Failed to create buffer event queue\n");
+        return FALSE;
+    }
+
     if (!(wayland->wl_registry = wl_display_get_registry(wayland->wl_display)))
     {
         ERR("Failed to get to wayland registry\n");
@@ -181,6 +187,12 @@ void wayland_deinit(struct wayland *wayland)
     if (wayland->wl_event_queue)
         wl_event_queue_destroy(wayland->wl_event_queue);
 
+    if (wayland->buffer_wl_event_queue)
+    {
+        wl_event_queue_destroy(wayland->buffer_wl_event_queue);
+        wayland->buffer_wl_event_queue = NULL;
+    }
+
     wl_display_flush(wayland->wl_display);
 
     memset(wayland, 0, sizeof(*wayland));
@@ -235,3 +247,20 @@ void wayland_process_release(void)
 {
     LeaveCriticalSection(&process_wayland_section);
 }
+
+/**********************************************************************
+ *          wayland_dispatch_buffer
+ *
+ * Dispatch buffer related events for the specified wayland instance.
+ *
+ * Returns the number of events dispatched.
+ */
+int wayland_dispatch_buffer(struct wayland *wayland)
+{
+    TRACE("wayland=%p buffer_queue=%p\n", wayland, wayland->buffer_wl_event_queue);
+
+    wl_display_flush(wayland->wl_display);
+
+    return wl_display_dispatch_queue_pending(wayland->wl_display,
+                                             wayland->buffer_wl_event_queue);
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index c1809cbd532..3d168c8cf66 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -57,6 +57,7 @@ struct wayland
     DWORD thread_id;
     struct wl_display *wl_display;
     struct wl_event_queue *wl_event_queue;
+    struct wl_event_queue *buffer_wl_event_queue;
     struct wl_registry *wl_registry;
     struct wl_compositor *wl_compositor;
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
@@ -134,6 +135,12 @@ void wayland_update_outputs_from_process(struct wayland *wayland);
 struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
                                                        LPCWSTR wine_name);
 
+/**********************************************************************
+ *          Wayland event dispatch
+ */
+
+int wayland_dispatch_buffer(struct wayland *wayland);
+
 /**********************************************************************
  *          USER driver functions
  */
-- 
2.34.1


From 4008a77d36c1da91b06ca425af1304a5fef8a6dc Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 2 Sep 2021 16:56:28 +0300
Subject: [PATCH 019/147] winewayland.drv: Add infrastructure for Wayland SHM
 buffers.

Add the infrastructure and functions needed to manage Wayland SHM (i.e.,
software) buffers and their damage tracking.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in   |   3 +-
 dlls/winewayland.drv/wayland.c     |   7 +
 dlls/winewayland.drv/wayland_shm.c | 250 +++++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h  |  25 +++
 4 files changed, 284 insertions(+), 1 deletion(-)
 create mode 100644 dlls/winewayland.drv/wayland_shm.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index c9ef96495ea..0b386f023ae 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,5 +1,5 @@
 MODULE    = winewayland.drv
-IMPORTS   = advapi32 user32 win32u
+IMPORTS   = advapi32 gdi32 user32 win32u
 EXTRAINCL = $(WAYLAND_CLIENT_CFLAGS)
 EXTRALIBS = $(WAYLAND_CLIENT_LIBS)
 CFLAGS = -std=c11 -Wno-declaration-after-statement
@@ -14,6 +14,7 @@ C_SRCS = \
 	wayland.c \
 	wayland_output.c \
 	waylanddrv_main.c \
+	wayland_shm.c \
 	window.c \
 
 WAYLAND_PROTOCOL_SRCS = \
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 32c69734bbe..a3929cd8a07 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -78,6 +78,10 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         wayland->wl_compositor =
             wl_registry_bind(registry, id, &wl_compositor_interface, 4);
     }
+    else if (strcmp(interface, "wl_shm") == 0)
+    {
+        wayland->wl_shm = wl_registry_bind(registry, id, &wl_shm_interface, 1);
+    }
 }
 
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
@@ -175,6 +179,9 @@ void wayland_deinit(struct wayland *wayland)
     wl_list_for_each_safe(output, output_tmp, &wayland->output_list, link)
         wayland_output_destroy(output);
 
+    if (wayland->wl_shm)
+        wl_shm_destroy(wayland->wl_shm);
+
     if (wayland->zxdg_output_manager_v1)
         zxdg_output_manager_v1_destroy(wayland->zxdg_output_manager_v1);
 
diff --git a/dlls/winewayland.drv/wayland_shm.c b/dlls/winewayland.drv/wayland_shm.c
new file mode 100644
index 00000000000..64a27a9dc4d
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_shm.c
@@ -0,0 +1,250 @@
+/*
+ * Wayland SHM buffers
+ *
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+/* For memfd_create */
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE
+#endif
+
+#include <sys/types.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <string.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <sys/mman.h>
+
+#include "waylanddrv.h"
+#include "wine/heap.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+static int fd_resize(int fd, off_t size)
+{
+    /*
+     * Filesystems that do support fallocate will return EINVAL or
+     * EOPNOTSUPP. In this case we need to fall back to ftruncate
+     */
+    errno = posix_fallocate(fd, 0, size);
+    if (errno == 0)
+        return 0;
+    else if (errno != EINVAL && errno != EOPNOTSUPP)
+        return -1;
+    if (ftruncate(fd, size) < 0)
+        return -1;
+
+    return 0;
+}
+
+static int shm_fd_create(off_t size)
+{
+    int fd;
+
+    fd = memfd_create("wayland-shm", MFD_CLOEXEC | MFD_ALLOW_SEALING);
+    if (fd >= 0)
+    {
+        /* We can add this seal before calling posix_fallocate(), as
+         * the file is currently zero-sized anyway.
+         *
+         * There is also no need to check for the return value, we
+         * couldn't do anything with it anyway.
+         */
+        fcntl(fd, F_ADD_SEALS, F_SEAL_SHRINK | F_SEAL_SEAL);
+    }
+
+    while (TRUE)
+    {
+        int ret = fd_resize(fd, size);
+        if (ret == 0) break;
+        if (ret < 0 && errno == EINTR) continue;
+        close(fd);
+        return -1;
+    }
+
+    return fd;
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_create
+ *
+ * Creates a SHM buffer with the specified width, height and format.
+ */
+struct wayland_shm_buffer *wayland_shm_buffer_create(struct wayland *wayland,
+                                                     int width, int height,
+                                                     enum wl_shm_format format)
+{
+    struct wayland_shm_buffer *shm_buffer;
+    struct wl_shm_pool *pool;
+    int fd = -1, size, stride;
+    void *data;
+
+    shm_buffer = heap_alloc_zero(sizeof(*shm_buffer));
+    if (!shm_buffer)
+        goto err;
+
+    wl_list_init(&shm_buffer->link);
+
+    assert(format == WL_SHM_FORMAT_ARGB8888 || format == WL_SHM_FORMAT_XRGB8888);
+
+    stride = width * 4;
+    size = stride * height;
+
+    TRACE("%p %dx%d format=%d size=%d\n", shm_buffer, width, height, format, size);
+
+    if (size == 0)
+        return shm_buffer;
+
+    fd = shm_fd_create(size);
+    if (fd < 0)
+    {
+        ERR("creating a buffer fd size %d failed: %s\n", size, strerror(errno));
+        goto err;
+    }
+
+    data = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+    if (data == MAP_FAILED)
+    {
+        ERR("mmap failed: %s size=%d\n", strerror(errno), size);
+        goto err;
+    }
+
+    pool = wl_shm_create_pool(wayland->wl_shm, fd, size);
+    shm_buffer->wl_buffer = wl_shm_pool_create_buffer(pool, 0, width, height,
+                                                      stride, format);
+    wl_shm_pool_destroy(pool);
+    close(fd);
+    fd = -1;
+
+    /* Buffer events go to their own queue so that we can dispatch them
+     * independently. */
+    wl_proxy_set_queue((struct wl_proxy *) shm_buffer->wl_buffer,
+                       wayland->buffer_wl_event_queue);
+
+    shm_buffer->width = width;
+    shm_buffer->height = height;
+    shm_buffer->stride = stride;
+    shm_buffer->format = format;
+    shm_buffer->map_data = data;
+    shm_buffer->map_size = size;
+    shm_buffer->damage_region = CreateRectRgn(0, 0, 0, 0);
+    if (!shm_buffer->damage_region)
+    {
+        ERR("failed to create buffer damage region\n");
+        goto err;
+    }
+
+    TRACE("%p %dx%d size=%d => map=%p\n", shm_buffer, width, height, size, data);
+
+    return shm_buffer;
+
+err:
+    if (fd >= 0)
+        close(fd);
+    if (shm_buffer)
+        wayland_shm_buffer_destroy(shm_buffer);
+    return NULL;
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_destroy
+ *
+ * Destroys a SHM buffer.
+ */
+void wayland_shm_buffer_destroy(struct wayland_shm_buffer *shm_buffer)
+{
+    TRACE("%p map=%p\n", shm_buffer, shm_buffer->map_data);
+
+    wl_list_remove(&shm_buffer->link);
+
+    if (shm_buffer->wl_buffer)
+        wl_buffer_destroy(shm_buffer->wl_buffer);
+    if (shm_buffer->map_data)
+        munmap(shm_buffer->map_data, shm_buffer->map_size);
+    if (shm_buffer->damage_region)
+        DeleteObject(shm_buffer->damage_region);
+
+    heap_free(shm_buffer);
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_clear_damage
+ *
+ *  Clears all damage accumulated by a SHM buffer.
+ */
+void wayland_shm_buffer_clear_damage(struct wayland_shm_buffer *shm_buffer)
+{
+    SetRectRgn(shm_buffer->damage_region, 0, 0, 0, 0);
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_add_damage
+ *
+ *  Adds damage (i.e., a region which needs update) to a SHM buffer.
+ */
+void wayland_shm_buffer_add_damage(struct wayland_shm_buffer *shm_buffer, HRGN damage)
+{
+    CombineRgn(shm_buffer->damage_region, shm_buffer->damage_region, damage, RGN_OR);
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_get_damage_clipped
+ *
+ * Returns the damage region data for this buffer clipped within the
+ * provided clip region (if any).
+ *
+ * The returned RGNDATA* should be freed by the caller.
+ */
+RGNDATA *wayland_shm_buffer_get_damage_clipped(struct wayland_shm_buffer *shm_buffer,
+                                               HRGN clip)
+{
+    RGNDATA *data = NULL;
+    DWORD size;
+    HRGN damage_region;
+
+    if (clip)
+    {
+        damage_region = CreateRectRgn(0, 0, 0, 0);
+        if (!damage_region) goto err;
+        CombineRgn(damage_region, shm_buffer->damage_region, clip, RGN_AND);
+    }
+    else
+    {
+        damage_region = shm_buffer->damage_region;
+    }
+
+    if (!(size = GetRegionData( damage_region, 0, NULL ))) goto err;
+    if (!(data = heap_alloc_zero( size ))) goto err;
+    if (!GetRegionData( damage_region, size, data )) goto err;
+
+    if (damage_region != shm_buffer->damage_region)
+        DeleteObject(damage_region);
+
+    return data;
+
+err:
+    if (damage_region && damage_region != shm_buffer->damage_region)
+        DeleteObject(damage_region);
+    heap_free(data);
+    return NULL;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 3d168c8cf66..bb75c456c9f 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -60,6 +60,7 @@ struct wayland
     struct wl_event_queue *buffer_wl_event_queue;
     struct wl_registry *wl_registry;
     struct wl_compositor *wl_compositor;
+    struct wl_shm *wl_shm;
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t next_fallback_output_id;
     struct wl_list output_list;
@@ -92,6 +93,18 @@ struct wayland_output
     uint32_t global_id;
 };
 
+struct wayland_shm_buffer
+{
+    struct wl_list link;
+    struct wl_buffer *wl_buffer;
+    int width, height, stride;
+    enum wl_shm_format format;
+    void *map_data;
+    size_t map_size;
+    BOOL busy;
+    HRGN damage_region;
+};
+
 /**********************************************************************
  *          Wayland thread data
  */
@@ -141,6 +154,18 @@ struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
 
 int wayland_dispatch_buffer(struct wayland *wayland);
 
+/**********************************************************************
+ *          Wayland SHM buffer
+ */
+
+struct wayland_shm_buffer *wayland_shm_buffer_create(struct wayland *wayland,
+                                                     int width, int height,
+                                                     enum wl_shm_format format);
+void wayland_shm_buffer_destroy(struct wayland_shm_buffer *shm_buffer);
+void wayland_shm_buffer_clear_damage(struct wayland_shm_buffer *shm_buffer);
+void wayland_shm_buffer_add_damage(struct wayland_shm_buffer *shm_buffer, HRGN damage);
+RGNDATA *wayland_shm_buffer_get_damage_clipped(struct wayland_shm_buffer *shm_buffer,
+                                               HRGN clip);
 /**********************************************************************
  *          USER driver functions
  */
-- 
2.34.1


From 1c8954b5241ecf5f6e501c18341ee02317661b84 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 2 Sep 2021 17:19:09 +0300
Subject: [PATCH 020/147] winewayland.drv: Add a Wayland SHM buffer queue.

Introduce a buffer queue object to handle a collection of Wayland SHM
buffers, including their acquisition by the driver and their release
by the Wayland compositor.

Each queue is initially empty, transparently and dynamically creating
up to 3 SHM buffers as needed.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in            |   1 +
 dlls/winewayland.drv/wayland_buffer_queue.c | 175 ++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h           |  21 +++
 3 files changed, 197 insertions(+)
 create mode 100644 dlls/winewayland.drv/wayland_buffer_queue.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 0b386f023ae..c6d169b91c0 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -14,6 +14,7 @@ C_SRCS = \
 	wayland.c \
 	wayland_output.c \
 	waylanddrv_main.c \
+	wayland_buffer_queue.c \
 	wayland_shm.c \
 	window.c \
 
diff --git a/dlls/winewayland.drv/wayland_buffer_queue.c b/dlls/winewayland.drv/wayland_buffer_queue.c
new file mode 100644
index 00000000000..7b69ed8a611
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_buffer_queue.c
@@ -0,0 +1,175 @@
+/*
+ * Wayland buffer queue
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+#include "wine/heap.h"
+#include "winuser.h"
+
+#include <errno.h>
+#include <assert.h>
+#include <time.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+static void buffer_release(void *data, struct wl_buffer *buffer)
+{
+    struct wayland_shm_buffer *shm_buffer = data;
+
+    TRACE("shm_buffer=%p\n", shm_buffer);
+
+    shm_buffer->busy = FALSE;
+}
+
+static const struct wl_buffer_listener buffer_listener = {
+    buffer_release
+};
+
+/**********************************************************************
+ *          wayland_buffer_queue_create
+ *
+ * Creates a buffer queue containing buffers with the specified width, height
+ * and format.
+ */
+struct wayland_buffer_queue *wayland_buffer_queue_create(struct wayland *wayland,
+                                                         int width, int height,
+                                                         enum wl_shm_format format)
+{
+    struct wayland_buffer_queue *queue;
+
+    queue = heap_alloc_zero(sizeof(*queue));
+    if (!queue)
+        return NULL;
+
+    queue->wayland = wayland;
+    queue->width = width;
+    queue->height = height;
+    queue->format = format;
+
+    wl_list_init(&queue->buffer_list);
+
+    return queue;
+}
+
+/**********************************************************************
+ *          wayland_buffer_queue_destroy
+ *
+ * Destroys a buffer queue and any contained buffers.
+ */
+void wayland_buffer_queue_destroy(struct wayland_buffer_queue *queue)
+{
+    struct wayland_shm_buffer *shm_buffer, *next;
+
+    wl_list_for_each_safe(shm_buffer, next, &queue->buffer_list, link)
+        wayland_shm_buffer_destroy(shm_buffer);
+
+    heap_free(queue);
+}
+
+/**********************************************************************
+ *          wayland_buffer_queue_acquire_buffer
+ *
+ * Acquires a free buffer from the buffer queue. If no free buffers
+ * are available this function blocks until it can provide one.
+ *
+ * The returned buffer is marked as unavailable until committed to
+ * a surface and subsequently released by the compositor.
+ */
+struct wayland_shm_buffer *wayland_buffer_queue_acquire_buffer(struct wayland_buffer_queue *queue)
+{
+    struct wayland_shm_buffer *shm_buffer;
+
+    TRACE("queue=%p\n", queue);
+
+    while (TRUE)
+    {
+        int nbuffers = 0;
+
+        /* Search through our buffers to find an available one. */
+        wl_list_for_each(shm_buffer, &queue->buffer_list, link)
+        {
+            if (!shm_buffer->busy)
+            {
+                shm_buffer->busy = TRUE;
+                goto out;
+            }
+            nbuffers++;
+        }
+
+        /* Dynamically create up to 3 buffers. */
+        if (nbuffers < 3)
+        {
+            HRGN full_dmg = CreateRectRgn(0, 0, queue->width, queue->height);
+            shm_buffer = wayland_shm_buffer_create(queue->wayland, queue->width,
+                                                   queue->height, queue->format);
+            if (shm_buffer)
+            {
+                wl_buffer_add_listener(shm_buffer->wl_buffer, &buffer_listener,
+                                       shm_buffer);
+                wl_list_insert(&queue->buffer_list, &shm_buffer->link);
+                wayland_shm_buffer_add_damage(shm_buffer, full_dmg);
+                shm_buffer->busy = TRUE;
+            }
+            DeleteObject(full_dmg);
+            /* If we failed to allocate a new buffer, but we have at least two
+             * buffers busy, there is a good chance the compositor will
+             * eventually release one of them, so dispatch events and wait
+             * below. Otherwise, give up and return a NULL buffer. */
+            if (shm_buffer)
+            {
+                goto out;
+            }
+            else if (nbuffers < 2)
+            {
+                ERR(" => failed to acquire buffer\n");
+                return NULL;
+            }
+        }
+
+        /* Keep dispatching buffer events to handle any pending buffer
+         * releases. If we have no events (and thus no newly available buffer),
+         * yield to allow other threads to perform work. */
+        while (wayland_dispatch_buffer(queue->wayland) == 0)
+            Sleep(0);
+    }
+
+out:
+    TRACE(" => %p %dx%d stride=%d map=[%p, %p)\n",
+          shm_buffer, shm_buffer->width, shm_buffer->height,
+          shm_buffer->stride, shm_buffer->map_data,
+          (unsigned char*)shm_buffer->map_data + shm_buffer->map_size);
+
+    return shm_buffer;
+}
+
+/**********************************************************************
+ *          wayland_buffer_queue_add_damage
+ *
+ * Adds damage to all buffers in this queue.
+ */
+void wayland_buffer_queue_add_damage(struct wayland_buffer_queue *queue, HRGN damage)
+{
+    struct wayland_shm_buffer *shm_buffer;
+
+    wl_list_for_each(shm_buffer, &queue->buffer_list, link)
+        wayland_shm_buffer_add_damage(shm_buffer, damage);
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index bb75c456c9f..95fbe005e8a 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -93,6 +93,16 @@ struct wayland_output
     uint32_t global_id;
 };
 
+struct wayland_buffer_queue
+{
+    struct wayland *wayland;
+    struct wl_list buffer_list;
+    int width;
+    int height;
+    enum wl_shm_format format;
+    HRGN damage_region;
+};
+
 struct wayland_shm_buffer
 {
     struct wl_list link;
@@ -154,6 +164,17 @@ struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
 
 int wayland_dispatch_buffer(struct wayland *wayland);
 
+/**********************************************************************
+ *          Wayland buffer queue
+ */
+
+struct wayland_buffer_queue *wayland_buffer_queue_create(struct wayland *wayland,
+                                                         int width, int heigh,
+                                                         enum wl_shm_format format);
+void wayland_buffer_queue_destroy(struct wayland_buffer_queue *queue);
+void wayland_buffer_queue_add_damage(struct wayland_buffer_queue *queue, HRGN damage);
+struct wayland_shm_buffer *wayland_buffer_queue_acquire_buffer(struct wayland_buffer_queue *queue);
+
 /**********************************************************************
  *          Wayland SHM buffer
  */
-- 
2.34.1


From 07d025448af7b5b5715f58de3c977c5b2e47f26d Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 28 Sep 2021 11:05:17 +0300
Subject: [PATCH 021/147] winewayland.drv: Introduce support for Wayland
 surfaces.

Introduce infrastructure to create, destroy and manage references to
Wayland surfaces.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |   2 +
 dlls/winewayland.drv/wayland.c         |  30 ++++
 dlls/winewayland.drv/wayland_surface.c | 206 +++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  35 +++++
 4 files changed, 273 insertions(+)
 create mode 100644 dlls/winewayland.drv/wayland_surface.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index c6d169b91c0..a6a9acd2279 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -16,9 +16,11 @@ C_SRCS = \
 	waylanddrv_main.c \
 	wayland_buffer_queue.c \
 	wayland_shm.c \
+	wayland_surface.c \
 	window.c \
 
 WAYLAND_PROTOCOL_SRCS = \
+	$(WAYLAND_PROTOCOLS_DATADIR)/stable/xdg-shell/xdg-shell.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/xdg-output/xdg-output-unstable-v1.xml \
 
 RC_SRCS = version.rc
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index a3929cd8a07..385ac73575c 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -40,6 +40,19 @@ static CRITICAL_SECTION_DEBUG process_wayland_critsect_debug =
 CRITICAL_SECTION process_wayland_section = { &process_wayland_critsect_debug,
                                              -1, 0, 0, 0, 0 };
 
+/**********************************************************************
+ *          xdg_wm_base handling
+ */
+
+static void xdg_wm_base_ping(void *data, struct xdg_wm_base *shell, uint32_t serial)
+{
+    xdg_wm_base_pong(shell, serial);
+}
+
+static const struct xdg_wm_base_listener xdg_wm_base_listener = {
+    xdg_wm_base_ping,
+};
+
 /**********************************************************************
  *          Registry handling
  */
@@ -78,6 +91,17 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         wayland->wl_compositor =
             wl_registry_bind(registry, id, &wl_compositor_interface, 4);
     }
+    else if (strcmp(interface, "wl_subcompositor") == 0)
+    {
+        wayland->wl_subcompositor =
+            wl_registry_bind(registry, id, &wl_subcompositor_interface, 1);
+    }
+    else if (strcmp(interface, "xdg_wm_base") == 0)
+    {
+        wayland->xdg_wm_base = wl_registry_bind(registry, id,
+                &xdg_wm_base_interface, 1);
+        xdg_wm_base_add_listener(wayland->xdg_wm_base, &xdg_wm_base_listener, wayland);
+    }
     else if (strcmp(interface, "wl_shm") == 0)
     {
         wayland->wl_shm = wl_registry_bind(registry, id, &wl_shm_interface, 1);
@@ -185,6 +209,12 @@ void wayland_deinit(struct wayland *wayland)
     if (wayland->zxdg_output_manager_v1)
         zxdg_output_manager_v1_destroy(wayland->zxdg_output_manager_v1);
 
+    if (wayland->xdg_wm_base)
+        xdg_wm_base_destroy(wayland->xdg_wm_base);
+
+    if (wayland->wl_subcompositor)
+        wl_subcompositor_destroy(wayland->wl_subcompositor);
+
     if (wayland->wl_compositor)
         wl_compositor_destroy(wayland->wl_compositor);
 
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
new file mode 100644
index 00000000000..e01c3be0f18
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -0,0 +1,206 @@
+/*
+ * Wayland surfaces
+ *
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+#include "wine/heap.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+/**********************************************************************
+ *          wayland_surface_create_plain
+ *
+ * Creates a plain, role-less wayland surface.
+ */
+struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland)
+{
+    struct wayland_surface *surface;
+
+    surface = heap_alloc_zero(sizeof(*surface));
+    if (!surface)
+        goto err;
+
+    TRACE("surface=%p\n", surface);
+
+    surface->wayland = wayland;
+
+    surface->wl_surface = wl_compositor_create_surface(wayland->wl_compositor);
+    if (!surface->wl_surface)
+        goto err;
+
+    wl_surface_set_user_data(surface->wl_surface, surface);
+
+    surface->ref = 1;
+    surface->role = WAYLAND_SURFACE_ROLE_NONE;
+
+    return surface;
+
+err:
+    if (surface)
+        wayland_surface_destroy(surface);
+    return NULL;
+}
+
+/**********************************************************************
+ *          wayland_surface_make_toplevel
+ *
+ * Gives the toplevel role to a plain wayland surface, optionally associated
+ * with a parent surface.
+ */
+void wayland_surface_make_toplevel(struct wayland_surface *surface,
+                                   struct wayland_surface *parent)
+{
+    struct wayland *wayland = surface->wayland;
+
+    TRACE("surface=%p parent=%p\n", surface, parent);
+
+    surface->xdg_surface =
+        xdg_wm_base_get_xdg_surface(wayland->xdg_wm_base, surface->wl_surface);
+    if (!surface->xdg_surface)
+        goto err;
+
+    surface->xdg_toplevel = xdg_surface_get_toplevel(surface->xdg_surface);
+    if (!surface->xdg_toplevel)
+        goto err;
+
+    if (parent && parent->xdg_toplevel)
+        xdg_toplevel_set_parent(surface->xdg_toplevel, parent->xdg_toplevel);
+
+    wl_surface_commit(surface->wl_surface);
+
+    surface->role = WAYLAND_SURFACE_ROLE_TOPLEVEL;
+
+    return;
+
+err:
+    if (surface->xdg_surface)
+    {
+        xdg_surface_destroy(surface->xdg_surface);
+        surface->xdg_surface = NULL;
+    }
+    ERR("Failed to assign toplevel role to wayland surface\n");
+}
+
+/**********************************************************************
+ *          wayland_surface_create_subsurface
+ *
+ * Assigns the subsurface role to a plain wayland surface, with the specified
+ * parent.
+ */
+void wayland_surface_make_subsurface(struct wayland_surface *surface,
+                                     struct wayland_surface *parent)
+{
+    struct wayland *wayland = surface->wayland;
+
+    TRACE("surface=%p parent=%p\n", surface, parent);
+
+    surface->parent = wayland_surface_ref(parent);
+    surface->wl_subsurface =
+        wl_subcompositor_get_subsurface(wayland->wl_subcompositor,
+                                        surface->wl_surface,
+                                        parent->wl_surface);
+    if (!surface->wl_subsurface)
+        goto err;
+    wl_subsurface_set_desync(surface->wl_subsurface);
+
+    wl_surface_commit(surface->wl_surface);
+
+    surface->role = WAYLAND_SURFACE_ROLE_SUBSURFACE;
+
+    return;
+
+err:
+    wayland_surface_unref(surface->parent);
+    surface->parent = NULL;
+    ERR("Failed to assign subsurface role to wayland surface\n");
+}
+
+/**********************************************************************
+ *          wayland_surface_destroy
+ *
+ * Destroys a wayland surface.
+ */
+void wayland_surface_destroy(struct wayland_surface *surface)
+{
+    TRACE("surface=%p\n", surface);
+
+    if (surface->xdg_toplevel)
+    {
+        xdg_toplevel_destroy(surface->xdg_toplevel);
+        surface->xdg_toplevel = NULL;
+    }
+
+    if (surface->xdg_surface)
+    {
+        xdg_surface_destroy(surface->xdg_surface);
+        surface->xdg_surface = NULL;
+    }
+
+    if (surface->wl_subsurface)
+    {
+        wl_subsurface_destroy(surface->wl_subsurface);
+        surface->wl_subsurface = NULL;
+    }
+
+    if (surface->wl_surface)
+    {
+        wl_surface_destroy(surface->wl_surface);
+        surface->wl_surface = NULL;
+    }
+
+    if (surface->parent)
+    {
+        wayland_surface_unref(surface->parent);
+        surface->parent = NULL;
+    }
+
+    wl_display_flush(surface->wayland->wl_display);
+
+    heap_free(surface);
+}
+
+/**********************************************************************
+ *          wayland_surface_ref
+ *
+ * Add a reference to a wayland_surface.
+ */
+struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface)
+{
+    LONG ref = InterlockedIncrement(&surface->ref);
+    TRACE("surface=%p ref=%d->%d\n", surface, ref - 1, ref);
+    return surface;
+}
+
+/**********************************************************************
+ *          wayland_surface_unref
+ *
+ * Remove a reference to wayland_surface, potentially destroying it.
+ */
+void wayland_surface_unref(struct wayland_surface *surface)
+{
+    LONG ref = InterlockedDecrement(&surface->ref);
+
+    TRACE("surface=%p ref=%d->%d\n", surface, ref + 1, ref);
+
+    if (ref == 0)
+        wayland_surface_destroy(surface);
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 95fbe005e8a..8b719e48294 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -28,6 +28,7 @@
 #include <stdarg.h>
 #include <wayland-client.h>
 #include "xdg-output-unstable-v1-client-protocol.h"
+#include "xdg-shell-client-protocol.h"
 
 #include "windef.h"
 #include "winbase.h"
@@ -46,6 +47,13 @@ enum wayland_window_message
     WM_WAYLAND_BROADCAST_DISPLAY_CHANGE = 0x80001000,
 };
 
+enum wayland_surface_role
+{
+    WAYLAND_SURFACE_ROLE_NONE,
+    WAYLAND_SURFACE_ROLE_SUBSURFACE,
+    WAYLAND_SURFACE_ROLE_TOPLEVEL,
+};
+
 /**********************************************************************
  *          Definitions for wayland types
  */
@@ -60,6 +68,8 @@ struct wayland
     struct wl_event_queue *buffer_wl_event_queue;
     struct wl_registry *wl_registry;
     struct wl_compositor *wl_compositor;
+    struct wl_subcompositor *wl_subcompositor;
+    struct xdg_wm_base *xdg_wm_base;
     struct wl_shm *wl_shm;
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t next_fallback_output_id;
@@ -93,6 +103,18 @@ struct wayland_output
     uint32_t global_id;
 };
 
+struct wayland_surface
+{
+    struct wayland *wayland;
+    struct wl_surface *wl_surface;
+    struct wl_subsurface *wl_subsurface;
+    struct xdg_surface *xdg_surface;
+    struct xdg_toplevel *xdg_toplevel;
+    struct wayland_surface *parent;
+    LONG ref;
+    enum wayland_surface_role role;
+};
+
 struct wayland_buffer_queue
 {
     struct wayland *wayland;
@@ -175,6 +197,19 @@ void wayland_buffer_queue_destroy(struct wayland_buffer_queue *queue);
 void wayland_buffer_queue_add_damage(struct wayland_buffer_queue *queue, HRGN damage);
 struct wayland_shm_buffer *wayland_buffer_queue_acquire_buffer(struct wayland_buffer_queue *queue);
 
+/**********************************************************************
+ *          Wayland surface
+ */
+
+struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland);
+void wayland_surface_make_toplevel(struct wayland_surface *surface,
+                                   struct wayland_surface *parent);
+void wayland_surface_make_subsurface(struct wayland_surface *surface,
+                                     struct wayland_surface *parent);
+void wayland_surface_destroy(struct wayland_surface *surface);
+struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface);
+void wayland_surface_unref(struct wayland_surface *surface);
+
 /**********************************************************************
  *          Wayland SHM buffer
  */
-- 
2.34.1


From e8c7d9c42a975c5595e2df31f2f235bbf9f7f2a5 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 28 Sep 2021 12:55:01 +0300
Subject: [PATCH 022/147] winewayland.drv: Basic handling of Wayland surface
 configure events.

Handle the initial configure event for top-level Wayland surfaces.  More
dynamic configure event handling will be implemented in future commits.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 89 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      | 19 ++++++
 2 files changed, 108 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index e01c3be0f18..9bfda5ddb74 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -26,6 +26,89 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+static void handle_xdg_surface_configure(void *data, struct xdg_surface *xdg_surface,
+                                         uint32_t serial)
+{
+    struct wayland_surface *surface = data;
+
+    TRACE("serial=%u\n", serial);
+
+    surface->pending.serial = serial;
+
+    wayland_surface_ack_pending_configure(surface);
+}
+
+/**********************************************************************
+ *          wayland_surface_ack_pending_configure
+ *
+ * Acks the pending configure event, making it current.
+ */
+void wayland_surface_ack_pending_configure(struct wayland_surface *surface)
+{
+    if (!surface->xdg_surface || !surface->pending.serial)
+        return;
+
+    TRACE("Setting current serial=%u size=%dx%d flags=%#x\n",
+          surface->pending.serial, surface->pending.width,
+          surface->pending.height, surface->pending.configure_flags);
+
+    surface->current = surface->pending;
+    xdg_surface_ack_configure(surface->xdg_surface, surface->current.serial);
+
+    memset(&surface->pending, 0, sizeof(surface->pending));
+}
+
+static const struct xdg_surface_listener xdg_surface_listener = {
+    handle_xdg_surface_configure,
+};
+
+static void handle_xdg_toplevel_configure(void *data,
+                                          struct xdg_toplevel *xdg_toplevel,
+                                          int32_t width, int32_t height,
+                                          struct wl_array *states)
+{
+    struct wayland_surface *surface = data;
+    uint32_t *state;
+    int flags = 0;
+
+    wl_array_for_each(state, states)
+    {
+        switch(*state)
+        {
+        case XDG_TOPLEVEL_STATE_MAXIMIZED:
+            flags |= WAYLAND_CONFIGURE_FLAG_MAXIMIZED;
+            break;
+        case XDG_TOPLEVEL_STATE_ACTIVATED:
+            flags |= WAYLAND_CONFIGURE_FLAG_ACTIVATED;
+            break;
+        case XDG_TOPLEVEL_STATE_RESIZING:
+            flags |= WAYLAND_CONFIGURE_FLAG_RESIZING;
+            break;
+        case XDG_TOPLEVEL_STATE_FULLSCREEN:
+            flags |= WAYLAND_CONFIGURE_FLAG_FULLSCREEN;
+            break;
+        default:
+            break;
+        }
+    }
+
+    surface->pending.width = width;
+    surface->pending.height = height;
+    surface->pending.configure_flags = flags;
+
+    TRACE("%dx%d flags=%#x\n", width, height, flags);
+}
+
+static void handle_xdg_toplevel_close(void *data, struct xdg_toplevel *xdg_toplevel)
+{
+    TRACE("\n");
+}
+
+static const struct xdg_toplevel_listener xdg_toplevel_listener = {
+    handle_xdg_toplevel_configure,
+    handle_xdg_toplevel_close,
+};
+
 /**********************************************************************
  *          wayland_surface_create_plain
  *
@@ -77,10 +160,12 @@ void wayland_surface_make_toplevel(struct wayland_surface *surface,
         xdg_wm_base_get_xdg_surface(wayland->xdg_wm_base, surface->wl_surface);
     if (!surface->xdg_surface)
         goto err;
+    xdg_surface_add_listener(surface->xdg_surface, &xdg_surface_listener, surface);
 
     surface->xdg_toplevel = xdg_surface_get_toplevel(surface->xdg_surface);
     if (!surface->xdg_toplevel)
         goto err;
+    xdg_toplevel_add_listener(surface->xdg_toplevel, &xdg_toplevel_listener, surface);
 
     if (parent && parent->xdg_toplevel)
         xdg_toplevel_set_parent(surface->xdg_toplevel, parent->xdg_toplevel);
@@ -89,6 +174,10 @@ void wayland_surface_make_toplevel(struct wayland_surface *surface,
 
     surface->role = WAYLAND_SURFACE_ROLE_TOPLEVEL;
 
+    /* Wait for the first configure event. */
+    while (!surface->current.serial)
+        wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
+
     return;
 
 err:
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 8b719e48294..71e2232e32c 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -54,6 +54,14 @@ enum wayland_surface_role
     WAYLAND_SURFACE_ROLE_TOPLEVEL,
 };
 
+enum wayland_configure_flags
+{
+    WAYLAND_CONFIGURE_FLAG_RESIZING   = (1 << 0),
+    WAYLAND_CONFIGURE_FLAG_ACTIVATED  = (1 << 1),
+    WAYLAND_CONFIGURE_FLAG_MAXIMIZED  = (1 << 2),
+    WAYLAND_CONFIGURE_FLAG_FULLSCREEN = (1 << 3),
+};
+
 /**********************************************************************
  *          Definitions for wayland types
  */
@@ -103,6 +111,14 @@ struct wayland_output
     uint32_t global_id;
 };
 
+struct wayland_surface_configure
+{
+    int width;
+    int height;
+    enum wayland_configure_flags configure_flags;
+    uint32_t serial;
+};
+
 struct wayland_surface
 {
     struct wayland *wayland;
@@ -111,6 +127,8 @@ struct wayland_surface
     struct xdg_surface *xdg_surface;
     struct xdg_toplevel *xdg_toplevel;
     struct wayland_surface *parent;
+    struct wayland_surface_configure pending;
+    struct wayland_surface_configure current;
     LONG ref;
     enum wayland_surface_role role;
 };
@@ -207,6 +225,7 @@ void wayland_surface_make_toplevel(struct wayland_surface *surface,
 void wayland_surface_make_subsurface(struct wayland_surface *surface,
                                      struct wayland_surface *parent);
 void wayland_surface_destroy(struct wayland_surface *surface);
+void wayland_surface_ack_pending_configure(struct wayland_surface *surface);
 struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface);
 void wayland_surface_unref(struct wayland_surface *surface);
 
-- 
2.34.1


From 84d8e4e3b07296baea0481ff850695d5e1dd5dcb Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 28 Sep 2021 13:03:11 +0300
Subject: [PATCH 023/147] winewayland.drv: Add functions to transform Wine
 coordinates to Wayland.

The functions are currently trivial, in the sense that they apply the
identity transformation. They will be enhanced as needed in future
commits to handle differences in the coordinate spaces, introduced, e.g,
by the use of scaling.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 29 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  6 ++++++
 2 files changed, 35 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 9bfda5ddb74..19ab02221eb 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -267,6 +267,35 @@ void wayland_surface_destroy(struct wayland_surface *surface)
     heap_free(surface);
 }
 
+/**********************************************************************
+ *          wayland_surface_coords_from_wine
+ *
+ * Converts the window-local wine coordinates to wayland surface-local coordinates.
+ */
+void wayland_surface_coords_from_wine(struct wayland_surface *surface,
+                                      int wine_x, int wine_y,
+                                      double *wayland_x, double *wayland_y)
+{
+    *wayland_x = wine_x;
+    *wayland_y = wine_y;
+}
+
+/**********************************************************************
+ *          wayland_surface_coords_rounded_from_wine
+ *
+ * Converts the window-local wine coordinates to wayland surface-local coordinates
+ * rounding to the closest integer value.
+ */
+void wayland_surface_coords_rounded_from_wine(struct wayland_surface *surface,
+                                              int wine_x, int wine_y,
+                                              int *wayland_x, int *wayland_y)
+{
+    double w_x, w_y;
+    wayland_surface_coords_from_wine(surface, wine_x, wine_y, &w_x, &w_y);
+    *wayland_x = round(w_x);
+    *wayland_y = round(w_y);
+}
+
 /**********************************************************************
  *          wayland_surface_ref
  *
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 71e2232e32c..1003512ac9e 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -226,6 +226,12 @@ void wayland_surface_make_subsurface(struct wayland_surface *surface,
                                      struct wayland_surface *parent);
 void wayland_surface_destroy(struct wayland_surface *surface);
 void wayland_surface_ack_pending_configure(struct wayland_surface *surface);
+void wayland_surface_coords_from_wine(struct wayland_surface *surface,
+                                      int wine_x, int wine_y,
+                                      double *wayland_x, double *wayland_y);
+void wayland_surface_coords_rounded_from_wine(struct wayland_surface *surface,
+                                              int wine_x, int wine_y,
+                                              int *wayland_x, int *wayland_y);
 struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface);
 void wayland_surface_unref(struct wayland_surface *surface);
 
-- 
2.34.1


From 87613f4af0e5403e1f278aedeb29bfd761b9fbf1 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 18 Nov 2021 10:15:43 +0200
Subject: [PATCH 024/147] winewayland.drv: Add function to check surface state
 compatibility.

Certain Wayland surface states place strict requirements on the surface
size. Introduce a function to check whether those requirements are met.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 35 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  3 +++
 2 files changed, 38 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 19ab02221eb..8f0307b275c 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -223,6 +223,41 @@ err:
     ERR("Failed to assign subsurface role to wayland surface\n");
 }
 
+/**********************************************************************
+ *          wayland_surface_configure_is_compatible
+ *
+ * Checks whether a wayland_surface_configure object is compatible with the
+ * the provided arguments.
+ */
+BOOL wayland_surface_configure_is_compatible(struct wayland_surface_configure *conf,
+                                             int width, int height,
+                                             enum wayland_configure_flags flags)
+{
+    static int mask = WAYLAND_CONFIGURE_FLAG_MAXIMIZED |
+                      WAYLAND_CONFIGURE_FLAG_FULLSCREEN;
+
+    /* We require the same state. */
+    if ((flags & mask) != (conf->configure_flags & mask))
+        return FALSE;
+
+    /* The maximized state requires the configured size. */
+    if ((conf->configure_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED) &&
+        (width != conf->width || height != conf->height))
+    {
+        return FALSE;
+    }
+
+    /* The fullscreen state requires sizes smaller or equal to the configured
+     * size. */
+    if ((conf->configure_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN) &&
+        (width > conf->width || height > conf->height))
+    {
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
 /**********************************************************************
  *          wayland_surface_destroy
  *
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 1003512ac9e..c46effe248a 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -224,6 +224,9 @@ void wayland_surface_make_toplevel(struct wayland_surface *surface,
                                    struct wayland_surface *parent);
 void wayland_surface_make_subsurface(struct wayland_surface *surface,
                                      struct wayland_surface *parent);
+BOOL wayland_surface_configure_is_compatible(struct wayland_surface_configure *conf,
+                                             int width, int height,
+                                             enum wayland_configure_flags flags);
 void wayland_surface_destroy(struct wayland_surface *surface);
 void wayland_surface_ack_pending_configure(struct wayland_surface *surface);
 void wayland_surface_coords_from_wine(struct wayland_surface *surface,
-- 
2.34.1


From aeb88bcc3dae5c0099a9390e4546dd92b3e262c9 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 28 Sep 2021 13:11:01 +0300
Subject: [PATCH 025/147] winewayland.drv: Add function to commit a buffer to a
 Wayland surface.

The buffer is committed along with damage information to allow the
Wayland compositor to potentially optimize presentation.

Some Wayland surface states, such as maximized and fullscreen, place
constraints on the effective surface size they accept. We honor
such constraints, not committing incompatible buffers, to avoid protocol
errors.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 95 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  4 ++
 2 files changed, 99 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 8f0307b275c..62283af798f 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -124,6 +124,9 @@ struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland)
 
     TRACE("surface=%p\n", surface);
 
+    InitializeCriticalSection(&surface->crit);
+    surface->crit.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": wayland_surface");
+
     surface->wayland = wayland;
 
     surface->wl_surface = wl_compositor_create_surface(wayland->wl_compositor);
@@ -258,6 +261,95 @@ BOOL wayland_surface_configure_is_compatible(struct wayland_surface_configure *c
     return TRUE;
 }
 
+static RGNDATA *get_region_data(HRGN region)
+{
+    RGNDATA *data = NULL;
+    DWORD size;
+
+    if (!(size = GetRegionData(region, 0, NULL))) goto err;
+    if (!(data = heap_alloc_zero(size))) goto err;
+
+    if (!GetRegionData(region, size, data)) goto err;
+
+    return data;
+
+err:
+    heap_free(data);
+    return NULL;
+}
+
+/**********************************************************************
+ *          wayland_surface_commit_buffer
+ *
+ * Commits a SHM buffer on a wayland surface. Returns whether the
+ * buffer was actually committed.
+ */
+BOOL wayland_surface_commit_buffer(struct wayland_surface *surface,
+                                   struct wayland_shm_buffer *shm_buffer,
+                                   HRGN surface_damage_region)
+{
+    RGNDATA *surface_damage;
+    int wayland_width, wayland_height;
+
+    /* Since multiple threads can commit a buffer to a wayland surface
+     * (e.g., child windows in different threads), we guard this function
+     * to ensure we get complete and atomic buffer commits. */
+    EnterCriticalSection(&surface->crit);
+
+    TRACE("surface=%p (%dx%d) flags=%#x buffer=%p (%dx%d)\n",
+          surface, surface->current.width, surface->current.height,
+          surface->current.configure_flags, shm_buffer,
+          shm_buffer->width, shm_buffer->height);
+
+    wayland_surface_coords_rounded_from_wine(surface,
+                                             shm_buffer->width, shm_buffer->height,
+                                             &wayland_width, &wayland_height);
+
+    /* Certain surface states are very strict about the dimensions of buffers
+     * they accept. To avoid wayland protocol errors, drop buffers not matching
+     * the expected dimensions of such surfaces. This typically happens
+     * transiently during resizing operations. */
+    if (!wayland_surface_configure_is_compatible(&surface->current,
+                                                 wayland_width,
+                                                 wayland_height,
+                                                 surface->current.configure_flags))
+    {
+        LeaveCriticalSection(&surface->crit);
+        TRACE("surface=%p buffer=%p dropping buffer\n", surface, shm_buffer);
+        shm_buffer->busy = FALSE;
+        return FALSE;
+    }
+
+    wl_surface_attach(surface->wl_surface, shm_buffer->wl_buffer, 0, 0);
+
+    /* Add surface damage, i.e., which parts of the surface have changed since
+     * the last surface commit. Note that this is different from the buffer
+     * damage returned by wayland_shm_buffer_get_damage(). */
+    surface_damage = get_region_data(surface_damage_region);
+    if (surface_damage)
+    {
+        RECT *rgn_rect = (RECT *)surface_damage->Buffer;
+        RECT *rgn_rect_end = rgn_rect + surface_damage->rdh.nCount;
+
+        for (;rgn_rect < rgn_rect_end; rgn_rect++)
+        {
+            wl_surface_damage_buffer(surface->wl_surface,
+                                     rgn_rect->left, rgn_rect->top,
+                                     rgn_rect->right - rgn_rect->left,
+                                     rgn_rect->bottom - rgn_rect->top);
+        }
+        heap_free(surface_damage);
+    }
+
+    wl_surface_commit(surface->wl_surface);
+
+    LeaveCriticalSection(&surface->crit);
+
+    wl_display_flush(surface->wayland->wl_display);
+
+    return TRUE;
+}
+
 /**********************************************************************
  *          wayland_surface_destroy
  *
@@ -297,6 +389,9 @@ void wayland_surface_destroy(struct wayland_surface *surface)
         surface->parent = NULL;
     }
 
+    surface->crit.DebugInfo->Spare[0] = 0;
+    DeleteCriticalSection(&surface->crit);
+
     wl_display_flush(surface->wayland->wl_display);
 
     heap_free(surface);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index c46effe248a..953f96a5f74 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -127,6 +127,7 @@ struct wayland_surface
     struct xdg_surface *xdg_surface;
     struct xdg_toplevel *xdg_toplevel;
     struct wayland_surface *parent;
+    CRITICAL_SECTION crit;
     struct wayland_surface_configure pending;
     struct wayland_surface_configure current;
     LONG ref;
@@ -227,6 +228,9 @@ void wayland_surface_make_subsurface(struct wayland_surface *surface,
 BOOL wayland_surface_configure_is_compatible(struct wayland_surface_configure *conf,
                                              int width, int height,
                                              enum wayland_configure_flags flags);
+BOOL wayland_surface_commit_buffer(struct wayland_surface *surface,
+                                   struct wayland_shm_buffer *shm_buffer,
+                                   HRGN surface_damage_region);
 void wayland_surface_destroy(struct wayland_surface *surface);
 void wayland_surface_ack_pending_configure(struct wayland_surface *surface);
 void wayland_surface_coords_from_wine(struct wayland_surface *surface,
-- 
2.34.1


From 667a88f1c1b53f88932b709a4a245c9513b83245 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 28 Sep 2021 13:24:03 +0300
Subject: [PATCH 026/147] winewayland.drv: Add function to unmap a Wayland
 surface.

Keep track of whether a Wayland surface is mapped or not, and allow
unmapping (i.e., hiding) it.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 17 +++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  2 ++
 2 files changed, 19 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 62283af798f..6773a4515d3 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -342,6 +342,7 @@ BOOL wayland_surface_commit_buffer(struct wayland_surface *surface,
     }
 
     wl_surface_commit(surface->wl_surface);
+    surface->mapped = TRUE;
 
     LeaveCriticalSection(&surface->crit);
 
@@ -397,6 +398,22 @@ void wayland_surface_destroy(struct wayland_surface *surface)
     heap_free(surface);
 }
 
+/**********************************************************************
+ *          wayland_surface_unmap
+ *
+ * Unmaps (i.e., hides) this surface.
+ */
+void wayland_surface_unmap(struct wayland_surface *surface)
+{
+    EnterCriticalSection(&surface->crit);
+
+    wl_surface_attach(surface->wl_surface, NULL, 0, 0);
+    wl_surface_commit(surface->wl_surface);
+    surface->mapped = FALSE;
+
+    LeaveCriticalSection(&surface->crit);
+}
+
 /**********************************************************************
  *          wayland_surface_coords_from_wine
  *
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 953f96a5f74..2ed617b3066 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -130,6 +130,7 @@ struct wayland_surface
     CRITICAL_SECTION crit;
     struct wayland_surface_configure pending;
     struct wayland_surface_configure current;
+    BOOL mapped;
     LONG ref;
     enum wayland_surface_role role;
 };
@@ -232,6 +233,7 @@ BOOL wayland_surface_commit_buffer(struct wayland_surface *surface,
                                    struct wayland_shm_buffer *shm_buffer,
                                    HRGN surface_damage_region);
 void wayland_surface_destroy(struct wayland_surface *surface);
+void wayland_surface_unmap(struct wayland_surface *surface);
 void wayland_surface_ack_pending_configure(struct wayland_surface *surface);
 void wayland_surface_coords_from_wine(struct wayland_surface *surface,
                                       int wine_x, int wine_y,
-- 
2.34.1


From 8ed9e385781a1ea94dbbbb84ba2c4373b8295b3b Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 28 Sep 2021 13:26:30 +0300
Subject: [PATCH 027/147] winewayland.drv: Allow associating a Wayland surface
 with a HWND.

There is no initial HWND association. It's the responsibility of the
surface creator to set it.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 4 ++--
 dlls/winewayland.drv/waylanddrv.h      | 1 +
 2 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 6773a4515d3..155d2789ec9 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -31,7 +31,7 @@ static void handle_xdg_surface_configure(void *data, struct xdg_surface *xdg_sur
 {
     struct wayland_surface *surface = data;
 
-    TRACE("serial=%u\n", serial);
+    TRACE("hwnd=%p serial=%u\n", surface->hwnd, serial);
 
     surface->pending.serial = serial;
 
@@ -358,7 +358,7 @@ BOOL wayland_surface_commit_buffer(struct wayland_surface *surface,
  */
 void wayland_surface_destroy(struct wayland_surface *surface)
 {
-    TRACE("surface=%p\n", surface);
+    TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
 
     if (surface->xdg_toplevel)
     {
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 2ed617b3066..1c39fa0c227 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -127,6 +127,7 @@ struct wayland_surface
     struct xdg_surface *xdg_surface;
     struct xdg_toplevel *xdg_toplevel;
     struct wayland_surface *parent;
+    HWND hwnd;
     CRITICAL_SECTION crit;
     struct wayland_surface_configure pending;
     struct wayland_surface_configure current;
-- 
2.34.1


From f5455ea8765d5ede792b258ceba502d5b0d55d13 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 26 Nov 2021 15:51:22 +0200
Subject: [PATCH 028/147] winewayland.drv: Introduce function to clear a
 surface's role.

Support clearing the role of Wayland surface. The same role (but
not a different one!) can be later assigned to the surface again.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 36 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  1 +
 2 files changed, 37 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 155d2789ec9..8e04f824bcb 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -226,6 +226,42 @@ err:
     ERR("Failed to assign subsurface role to wayland surface\n");
 }
 
+/**********************************************************************
+ *          wayland_surface_clear_role
+ *
+ * Clears the role related Wayland objects of a Wayland surface, making it a
+ * plain surface again. We can later assign the same role (but not a
+ * different one!) to the surface.
+ */
+void wayland_surface_clear_role(struct wayland_surface *surface)
+{
+    TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
+
+    if (surface->xdg_toplevel)
+    {
+        xdg_toplevel_destroy(surface->xdg_toplevel);
+        surface->xdg_toplevel = NULL;
+    }
+
+    if (surface->xdg_surface)
+    {
+        xdg_surface_destroy(surface->xdg_surface);
+        surface->xdg_surface = NULL;
+    }
+
+    if (surface->wl_subsurface)
+    {
+        wl_subsurface_destroy(surface->wl_subsurface);
+        surface->wl_subsurface = NULL;
+    }
+
+    memset(&surface->pending, 0, sizeof(surface->pending));
+    memset(&surface->current, 0, sizeof(surface->current));
+
+    /* We need to unmap, otherwise future role assignments may fail. */
+    wayland_surface_unmap(surface);
+}
+
 /**********************************************************************
  *          wayland_surface_configure_is_compatible
  *
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 1c39fa0c227..12bc68e720c 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -227,6 +227,7 @@ void wayland_surface_make_toplevel(struct wayland_surface *surface,
                                    struct wayland_surface *parent);
 void wayland_surface_make_subsurface(struct wayland_surface *surface,
                                      struct wayland_surface *parent);
+void wayland_surface_clear_role(struct wayland_surface *surface);
 BOOL wayland_surface_configure_is_compatible(struct wayland_surface_configure *conf,
                                              int width, int height,
                                              enum wayland_configure_flags flags);
-- 
2.34.1


From 6045b8eade6a077f29c49ed8a0adb5593fd2a61a Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 3 Sep 2021 10:38:51 +0300
Subject: [PATCH 029/147] winewayland.drv: Create backing Wayland surfaces for
 windows.

Associate Wayland surfaces with windows that need to be displayed by
the native window system. This includes all kinds of top-level windows,
but not child windows, since children are rendered by Wine in the
window surface of their parent top-level.

As a special case, we use Wayland subsurfaces to display windows
that we believe are transient (e.g., popups) and need relative
positioning. We currently use a very simple heuristic to detect such
cases: windows that have an owner but no caption. Future commits
will refine this heuristic.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h      |   9 ++
 dlls/winewayland.drv/waylanddrv_main.c |   1 +
 dlls/winewayland.drv/window.c          | 175 +++++++++++++++++++++++++
 3 files changed, 185 insertions(+)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 12bc68e720c..a2ae525971e 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -178,6 +178,11 @@ static inline struct wayland_thread_data *wayland_thread_data(void)
     return data;
 }
 
+static inline struct wayland *thread_init_wayland(void)
+{
+    return &wayland_init_thread_data()->wayland;
+}
+
 /**********************************************************************
  *          Wayland initialisation
  */
@@ -268,6 +273,10 @@ extern BOOL CDECL WAYLAND_EnumDisplaySettingsEx(LPCWSTR name, DWORD n, LPDEVMODE
 extern void CDECL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
                                                BOOL force, void *param) DECLSPEC_HIDDEN;
 extern LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
+extern void CDECL WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
+                                           const RECT *window_rect, const RECT *client_rect,
+                                           const RECT *visible_rect, const RECT *valid_rects,
+                                           struct window_surface *surface) DECLSPEC_HIDDEN;
 extern BOOL CDECL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flags,
                                             const RECT *window_rect, const RECT *client_rect,
                                             RECT *visible_rect, struct window_surface **surface) DECLSPEC_HIDDEN;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 0b54723c7a2..1e96be9c972 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -84,6 +84,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pThreadDetach = WAYLAND_ThreadDetach,
     .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
     .pWindowMessage = WAYLAND_WindowMessage,
+    .pWindowPosChanged = WAYLAND_WindowPosChanged,
     .pWindowPosChanging = WAYLAND_WindowPosChanging,
 };
 
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index a7a2228097c..e0fad2ceba8 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -43,6 +43,12 @@ struct wayland_win_data
     RECT           window_rect;
     /* client area relative to parent */
     RECT           client_rect;
+    /* wayland surface (if any) representing this window on the wayland side */
+    struct wayland_surface *wayland_surface;
+    /* whether this window is visible */
+    BOOL           visible;
+    /* whether a wayland surface update is needed */
+    BOOL           wayland_surface_needs_update;
 };
 
 static CRITICAL_SECTION win_data_section;
@@ -69,6 +75,7 @@ static void wayland_win_data_destroy(struct wayland_win_data *data)
     TRACE("hwnd=%p\n", data->hwnd);
     win_data_context[context_idx(data->hwnd)] = NULL;
 
+    if (data->wayland_surface) wayland_surface_unref(data->wayland_surface);
     heap_free(data);
 
     LeaveCriticalSection(&win_data_section);
@@ -121,6 +128,7 @@ static struct wayland_win_data *wayland_win_data_create(HWND hwnd)
         return NULL;
 
     data->hwnd = hwnd;
+    data->wayland_surface_needs_update = TRUE;
 
     EnterCriticalSection(&win_data_section);
     win_data_context[context_idx(hwnd)] = data;
@@ -130,6 +138,150 @@ static struct wayland_win_data *wayland_win_data_create(HWND hwnd)
     return data;
 }
 
+/***********************************************************************
+ *           wayland_surface_for_hwnd_lock
+ *
+ *  Gets the wayland surface for HWND while locking the private window data.
+ */
+static struct wayland_surface *wayland_surface_for_hwnd_lock(HWND hwnd)
+{
+    struct wayland_win_data *data = wayland_win_data_get(hwnd);
+
+    if (data && data->wayland_surface)
+        return data->wayland_surface;
+
+    wayland_win_data_release(data);
+
+    return NULL;
+}
+
+/***********************************************************************
+ *           wayland_surface_for_hwnd_unlock
+ */
+static void wayland_surface_for_hwnd_unlock(struct wayland_surface *surface)
+{
+    if (surface) LeaveCriticalSection(&win_data_section);
+}
+
+static BOOL wayland_win_data_wayland_surface_needs_update(struct wayland_win_data *data)
+{
+    if (data->wayland_surface_needs_update)
+        return TRUE;
+
+    /* If this is currently or potentially a toplevel surface, and its
+     * visibility state has changed, recreate win_data so that we only have
+     * xdg_toplevels for visible windows. */
+    if (data->wayland_surface && !data->wayland_surface->wl_subsurface)
+    {
+        BOOL visible = data->wayland_surface->xdg_toplevel != NULL;
+        if (data->visible != visible)
+            return TRUE;
+    }
+
+    return FALSE;
+}
+
+static struct wayland_surface *update_surface_for_role(struct wayland_win_data *data,
+                                                       enum wayland_surface_role role,
+                                                       struct wayland *wayland,
+                                                       struct wayland_surface *parent_surface)
+{
+    struct wayland_surface *surface = data->wayland_surface;
+
+    if (!surface ||
+        (role != WAYLAND_SURFACE_ROLE_NONE &&
+         surface->role != WAYLAND_SURFACE_ROLE_NONE &&
+         surface->role != role))
+    {
+        surface = wayland_surface_create_plain(wayland);
+        if (surface) EnterCriticalSection(&surface->crit);
+    }
+    else
+    {
+        /* Lock the wayland surface to avoid other threads interacting with it
+         * while we are updating. */
+        EnterCriticalSection(&surface->crit);
+        wayland_surface_clear_role(surface);
+        /* Clear the associated HWND, to allow a potential invocation of
+         * wayland_surface_make_toplevel below, to properly handle the
+         * initial configure event. */
+        surface->hwnd = 0;
+    }
+
+    if (role == WAYLAND_SURFACE_ROLE_TOPLEVEL)
+        wayland_surface_make_toplevel(surface, parent_surface);
+    else if (role == WAYLAND_SURFACE_ROLE_SUBSURFACE)
+        wayland_surface_make_subsurface(surface, parent_surface);
+
+    surface->hwnd = data->hwnd;
+
+    LeaveCriticalSection(&surface->crit);
+
+    return surface;
+}
+
+static void wayland_win_data_update_wayland_surface(struct wayland_win_data *data)
+{
+    struct wayland *wayland;
+    HWND effective_parent_hwnd;
+    struct wayland_surface *surface;
+    struct wayland_surface *parent_surface;
+    DWORD style;
+
+    TRACE("hwnd=%p\n", data->hwnd);
+
+    data->wayland_surface_needs_update = FALSE;
+
+    wayland = thread_init_wayland();
+
+    /* GWLP_HWNDPARENT gets the owner for any kind of toplevel windows,
+     * and the parent for child windows. */
+    effective_parent_hwnd = (HWND)GetWindowLongPtrW(data->hwnd, GWLP_HWNDPARENT);
+    parent_surface = NULL;
+
+    if (effective_parent_hwnd)
+    {
+        parent_surface = wayland_surface_for_hwnd_lock(effective_parent_hwnd);
+        wayland_surface_for_hwnd_unlock(parent_surface);
+    }
+
+    style = GetWindowLongW(data->hwnd, GWL_STYLE);
+
+    /* Use wayland subsurfaces for children windows and windows that are
+     * transient (i.e., don't have a titlebar). Otherwise, if the window is
+     * visible make it wayland toplevel. Finally, if the window is not visible
+     * create a plain (without a role) surface to avoid polluting the
+     * compositor with empty xdg_toplevels. */
+    if ((style & WS_CAPTION) != WS_CAPTION)
+    {
+        surface = update_surface_for_role(data, WAYLAND_SURFACE_ROLE_SUBSURFACE,
+                                          wayland, parent_surface);
+    }
+    else if (data->visible)
+    {
+        surface = update_surface_for_role(data, WAYLAND_SURFACE_ROLE_TOPLEVEL,
+                                          wayland, parent_surface);
+    }
+    else
+    {
+        surface = update_surface_for_role(data, WAYLAND_SURFACE_ROLE_NONE,
+                                          wayland, parent_surface);
+    }
+
+    if (data->wayland_surface != surface)
+    {
+        if (data->wayland_surface)
+            wayland_surface_unref(data->wayland_surface);
+        data->wayland_surface = surface;
+    }
+}
+
+static void update_wayland_state(struct wayland_win_data *data)
+{
+    if (wayland_win_data_wayland_surface_needs_update(data))
+        wayland_win_data_update_wayland_surface(data);
+}
+
 /**********************************************************************
  *           WAYLAND_CreateWindow
  */
@@ -181,11 +333,34 @@ BOOL CDECL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flag
     data->parent = (parent == GetDesktopWindow()) ? 0 : parent;
     data->window_rect = *window_rect;
     data->client_rect = *client_rect;
+    data->visible = (style & WS_VISIBLE) == WS_VISIBLE || (swp_flags & SWP_SHOWWINDOW);
 
     wayland_win_data_release(data);
     return TRUE;
 }
 
+/***********************************************************************
+ *           WAYLAND_WindowPosChanged
+ */
+void CDECL WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
+                                    const RECT *window_rect, const RECT *client_rect,
+                                    const RECT *visible_rect, const RECT *valid_rects,
+                                    struct window_surface *surface)
+{
+    struct wayland_win_data *data;
+
+    if (!(data = wayland_win_data_get(hwnd))) return;
+
+    TRACE("hwnd %p window %s client %s visible %s style %08x after %p flags %08x\n",
+          hwnd, wine_dbgstr_rect(window_rect), wine_dbgstr_rect(client_rect),
+          wine_dbgstr_rect(visible_rect), GetWindowLongW(hwnd, GWL_STYLE),
+          insert_after, swp_flags);
+
+    update_wayland_state(data);
+
+    wayland_win_data_release(data);
+}
+
 /**********************************************************************
  *           WAYLAND_WindowMessage
  */
-- 
2.34.1


From 72e15b9f4759fa9e57ea0d7b33c0c0032f43ae1c Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 3 Sep 2021 13:49:48 +0300
Subject: [PATCH 030/147] winewayland.drv: Implement window_surface for
 Wayland.

Implement struct window_surface for windows backed by wayland surfaces.
Each window_surface uses a Wayland SHM buffer queue to manage a set of
XRGB8888 (for now) buffers used to display the window contents.

During flushing the contents of the window_surface bitmap are copied to
a available SHM buffer and committed to the associated Wayland surface.
Surface damage, and the cumulative buffer damage, is taken into account
to minimize the amount of pixel data that needs to be copied.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in      |   1 +
 dlls/winewayland.drv/waylanddrv.h     |  11 +
 dlls/winewayland.drv/window.c         |  68 ++++++
 dlls/winewayland.drv/window_surface.c | 338 ++++++++++++++++++++++++++
 4 files changed, 418 insertions(+)
 create mode 100644 dlls/winewayland.drv/window_surface.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index a6a9acd2279..46ccc88d269 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -18,6 +18,7 @@ C_SRCS = \
 	wayland_shm.c \
 	wayland_surface.c \
 	window.c \
+	window_surface.c \
 
 WAYLAND_PROTOCOL_SRCS = \
 	$(WAYLAND_PROTOCOLS_DATADIR)/stable/xdg-shell/xdg-shell.xml \
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index a2ae525971e..03e2b13acd7 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -263,6 +263,17 @@ void wayland_shm_buffer_clear_damage(struct wayland_shm_buffer *shm_buffer);
 void wayland_shm_buffer_add_damage(struct wayland_shm_buffer *shm_buffer, HRGN damage);
 RGNDATA *wayland_shm_buffer_get_damage_clipped(struct wayland_shm_buffer *shm_buffer,
                                                HRGN clip);
+
+/**********************************************************************
+ *          Wayland window surface
+ */
+
+struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect);
+void CDECL wayland_window_surface_flush(struct window_surface *window_surface);
+BOOL wayland_window_surface_needs_flush(struct window_surface *surface);
+void wayland_window_surface_update_wayland_surface(struct window_surface *surface,
+                                                   struct wayland_surface *wayland_surface);
+
 /**********************************************************************
  *          USER driver functions
  */
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index e0fad2ceba8..38c79e70a68 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -45,6 +45,12 @@ struct wayland_win_data
     RECT           client_rect;
     /* wayland surface (if any) representing this window on the wayland side */
     struct wayland_surface *wayland_surface;
+    /* wine window_surface backing this window */
+    struct window_surface *window_surface;
+    /* pending wine window_surface for this window */
+    struct window_surface *pending_window_surface;
+    /* whether the pending_window_surface value is valid */
+    BOOL           has_pending_window_surface;
     /* whether this window is visible */
     BOOL           visible;
     /* whether a wayland surface update is needed */
@@ -75,6 +81,16 @@ static void wayland_win_data_destroy(struct wayland_win_data *data)
     TRACE("hwnd=%p\n", data->hwnd);
     win_data_context[context_idx(data->hwnd)] = NULL;
 
+    if (data->has_pending_window_surface && data->pending_window_surface)
+    {
+        wayland_window_surface_update_wayland_surface(data->pending_window_surface, NULL);
+        window_surface_release(data->pending_window_surface);
+    }
+    if (data->window_surface)
+    {
+        wayland_window_surface_update_wayland_surface(data->window_surface, NULL);
+        window_surface_release(data->window_surface);
+    }
     if (data->wayland_surface) wayland_surface_unref(data->wayland_surface);
     heap_free(data);
 
@@ -278,8 +294,29 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
 
 static void update_wayland_state(struct wayland_win_data *data)
 {
+    if (data->has_pending_window_surface)
+    {
+        if (data->window_surface)
+        {
+            if (data->window_surface != data->pending_window_surface)
+                wayland_window_surface_update_wayland_surface(data->window_surface, NULL);
+            window_surface_release(data->window_surface);
+        }
+        data->window_surface = data->pending_window_surface;
+        data->has_pending_window_surface = FALSE;
+        data->pending_window_surface = NULL;
+    }
+
     if (wayland_win_data_wayland_surface_needs_update(data))
         wayland_win_data_update_wayland_surface(data);
+
+    if (data->window_surface)
+    {
+        wayland_window_surface_update_wayland_surface(data->window_surface,
+                                                      data->wayland_surface);
+        if (wayland_window_surface_needs_flush(data->window_surface))
+            wayland_window_surface_flush(data->window_surface);
+    }
 }
 
 /**********************************************************************
@@ -323,6 +360,7 @@ BOOL CDECL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flag
     BOOL exstyle = GetWindowLongW(hwnd, GWL_EXSTYLE);
     DWORD style = GetWindowLongW(hwnd, GWL_STYLE);
     HWND parent = GetAncestor(hwnd, GA_PARENT);
+    RECT surface_rect;
 
     TRACE("win %p window %s client %s visible %s style %08x ex %08x flags %08x after %p\n",
           hwnd, wine_dbgstr_rect(window_rect), wine_dbgstr_rect(client_rect),
@@ -335,6 +373,30 @@ BOOL CDECL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flag
     data->client_rect = *client_rect;
     data->visible = (style & WS_VISIBLE) == WS_VISIBLE || (swp_flags & SWP_SHOWWINDOW);
 
+    /* Release the dummy surface wine provides for toplevels. */
+    if (*surface) window_surface_release(*surface);
+    *surface = NULL;
+
+    /* Check if we don't want a dedicated window surface. */
+    if (data->parent || (swp_flags & SWP_HIDEWINDOW) || !data->visible) goto done;
+
+    surface_rect = *window_rect;
+    OffsetRect(&surface_rect, -surface_rect.left, -surface_rect.top);
+
+    /* Check if we can reuse our current window surface. */
+    if (data->window_surface &&
+        EqualRect(&data->window_surface->rect, &surface_rect))
+    {
+        window_surface_add_ref(data->window_surface);
+        *surface = data->window_surface;
+        TRACE("reusing surface %p\n", *surface);
+        goto done;
+    }
+
+    /* Create new window surface. */
+    *surface = wayland_window_surface_create(data->hwnd, &surface_rect);
+
+done:
     wayland_win_data_release(data);
     return TRUE;
 }
@@ -356,6 +418,12 @@ void CDECL WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags
           wine_dbgstr_rect(visible_rect), GetWindowLongW(hwnd, GWL_STYLE),
           insert_after, swp_flags);
 
+    if (surface) window_surface_add_ref(surface);
+    if (data->has_pending_window_surface && data->pending_window_surface)
+        window_surface_release(data->pending_window_surface);
+    data->pending_window_surface = surface;
+    data->has_pending_window_surface = TRUE;
+
     update_wayland_state(data);
 
     wayland_win_data_release(data);
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
new file mode 100644
index 00000000000..b61d5bc0489
--- /dev/null
+++ b/dlls/winewayland.drv/window_surface.c
@@ -0,0 +1,338 @@
+/*
+ * Wayland window surface implementation
+ *
+ * Copyright 1993, 1994, 1995, 1996, 2001, 2013-2017 Alexandre Julliard
+ * Copyright 1993 David Metcalfe
+ * Copyright 1995, 1996 Alex Korobka
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include <assert.h>
+#include <limits.h>
+#include <stdlib.h>
+
+#include "winuser.h"
+
+#include "wine/debug.h"
+#include "wine/heap.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+struct wayland_window_surface
+{
+    struct window_surface header;
+    HWND                  hwnd;
+    struct wayland_surface *wayland_surface; /* Not owned by us */
+    struct wayland_buffer_queue *wayland_buffer_queue;
+    RECT                  bounds;
+    void                 *bits;
+    CRITICAL_SECTION      crit;
+    BOOL                  last_flush_failed;
+    BITMAPINFO            info;
+};
+
+static struct wayland_window_surface *wayland_window_surface_cast(
+    struct window_surface *window_surface)
+{
+    return (struct wayland_window_surface *)window_surface;
+}
+
+static inline int get_dib_stride(int width, int bpp)
+{
+    return ((width * bpp + 31) >> 3) & ~3;
+}
+
+static inline int get_dib_image_size(const BITMAPINFO *info)
+{
+    return get_dib_stride(info->bmiHeader.biWidth, info->bmiHeader.biBitCount) *
+           abs(info->bmiHeader.biHeight);
+}
+
+static inline void reset_bounds(RECT *bounds)
+{
+    bounds->left = bounds->top = INT_MAX;
+    bounds->right = bounds->bottom = INT_MIN;
+}
+
+/***********************************************************************
+ *           wayland_window_surface_lock
+ */
+static void CDECL wayland_window_surface_lock(struct window_surface *window_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+    EnterCriticalSection(&wws->crit);
+}
+
+/***********************************************************************
+ *           wayland_window_surface_unlock
+ */
+static void CDECL wayland_window_surface_unlock(struct window_surface *window_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+    LeaveCriticalSection(&wws->crit);
+}
+
+/***********************************************************************
+ *           wayland_window_surface_get_bitmap_info
+ */
+static void CDECL *wayland_window_surface_get_bitmap_info(struct window_surface *window_surface,
+                                                          BITMAPINFO *info)
+{
+    struct wayland_window_surface *surface = wayland_window_surface_cast(window_surface);
+    /* We don't store any additional information at the end of our BITMAPINFO, so
+     * just copy the structure itself. */
+    memcpy(info, &surface->info, sizeof(*info));
+    return surface->bits;
+}
+
+/***********************************************************************
+ *           wayland_window_surface_get_bounds
+ */
+static RECT CDECL *wayland_window_surface_get_bounds(struct window_surface *window_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+    return &wws->bounds;
+}
+
+/***********************************************************************
+ *           wayland_window_surface_set_region
+ */
+static void CDECL wayland_window_surface_set_region(struct window_surface *window_surface,
+                                                    HRGN region)
+{
+    /* TODO */
+}
+
+/***********************************************************************
+ *           wayland_window_surface_flush
+ */
+void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+    struct wayland_shm_buffer *buffer;
+    RECT damage_rect;
+    BOOL needs_flush;
+    RGNDATA *buffer_damage;
+    HRGN surface_damage_region = NULL;
+    RECT *rgn_rect;
+    RECT *rgn_rect_end;
+
+    window_surface->funcs->lock(window_surface);
+
+    TRACE("hwnd=%p surface_rect=%s bounds=%s\n", wws->hwnd,
+          wine_dbgstr_rect(&wws->header.rect), wine_dbgstr_rect(&wws->bounds));
+
+    needs_flush = IntersectRect(&damage_rect, &wws->header.rect, &wws->bounds);
+    if (needs_flush && (!wws->wayland_surface || !wws->wayland_buffer_queue))
+    {
+        TRACE("missing wayland surface=%p buffer_queue=%p, returning\n",
+              wws->wayland_surface, wws->wayland_buffer_queue);
+        wws->last_flush_failed = TRUE;
+        goto done;
+    }
+    wws->last_flush_failed = FALSE;
+
+    if (!needs_flush) goto done;
+
+    surface_damage_region = CreateRectRgnIndirect(&damage_rect);
+
+    TRACE("flushing surface %p hwnd %p surface_rect %s bits %p\n",
+          wws, wws->hwnd, wine_dbgstr_rect(&wws->header.rect),
+          wws->bits);
+
+    assert(wws->wayland_buffer_queue);
+
+    wayland_buffer_queue_add_damage(wws->wayland_buffer_queue, surface_damage_region);
+    buffer = wayland_buffer_queue_acquire_buffer(wws->wayland_buffer_queue);
+    if (!buffer)
+    {
+        WARN("failed to acquire wayland buffer, returning\n");
+        wws->last_flush_failed = TRUE;
+        goto done;
+    }
+    buffer_damage = wayland_shm_buffer_get_damage_clipped(buffer, NULL);
+
+    rgn_rect = (RECT *)buffer_damage->Buffer;
+    rgn_rect_end = rgn_rect + buffer_damage->rdh.nCount;
+
+    /* Flush damaged buffer region from window_surface bitmap to wayland SHM buffer. */
+    for (;rgn_rect < rgn_rect_end; rgn_rect++)
+    {
+        unsigned int *src, *dst;
+        int y, width, height;
+
+        TRACE("damage %s\n", wine_dbgstr_rect(rgn_rect));
+
+        if (IsRectEmpty(rgn_rect))
+            continue;
+
+        src = (unsigned int *)wws->bits +
+              rgn_rect->top * wws->info.bmiHeader.biWidth +
+              rgn_rect->left;
+        dst = (unsigned int *)((unsigned char *)buffer->map_data +
+              rgn_rect->top * buffer->stride +
+              rgn_rect->left * 4);
+        width = min(rgn_rect->right, buffer->width) - rgn_rect->left;
+        height = min(rgn_rect->bottom, buffer->height) - rgn_rect->top;
+
+        /* Fast path for full width rectangles. */
+        if (width == buffer->width)
+        {
+            memcpy(dst, src, height * buffer->stride);
+            continue;
+        }
+
+        for (y = 0; y < height; y++)
+        {
+            memcpy(dst, src, width * 4);
+
+            src += wws->info.bmiHeader.biWidth;
+            dst = (unsigned int*)((unsigned char*)dst + buffer->stride);
+        }
+    }
+
+    if (!wayland_surface_commit_buffer(wws->wayland_surface, buffer,
+                                       surface_damage_region))
+    {
+        wws->last_flush_failed = TRUE;
+    }
+
+    wayland_shm_buffer_clear_damage(buffer);
+
+    heap_free(buffer_damage);
+
+done:
+    if (!wws->last_flush_failed) reset_bounds(&wws->bounds);
+    if (surface_damage_region) DeleteObject(surface_damage_region);
+    window_surface->funcs->unlock(window_surface);
+}
+
+/***********************************************************************
+ *           wayland_window_surface_destroy
+ */
+static void CDECL wayland_window_surface_destroy(struct window_surface *window_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+
+    TRACE("surface=%p\n", wws);
+
+    wws->crit.DebugInfo->Spare[0] = 0;
+    DeleteCriticalSection(&wws->crit);
+    if (wws->wayland_surface) wayland_surface_unref(wws->wayland_surface);
+    if (wws->wayland_buffer_queue)
+        wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
+    heap_free(wws->bits);
+    heap_free(wws);
+}
+
+static const struct window_surface_funcs wayland_window_surface_funcs =
+{
+    wayland_window_surface_lock,
+    wayland_window_surface_unlock,
+    wayland_window_surface_get_bitmap_info,
+    wayland_window_surface_get_bounds,
+    wayland_window_surface_set_region,
+    wayland_window_surface_flush,
+    wayland_window_surface_destroy
+};
+
+/***********************************************************************
+ *           wayland_window_surface_create
+ */
+struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect)
+{
+    struct wayland_window_surface *wws;
+    int width = rect->right - rect->left, height = rect->bottom - rect->top;
+
+    TRACE("win %p rect %s\n", hwnd, wine_dbgstr_rect(rect));
+    wws = heap_alloc_zero(sizeof(*wws));
+    if (!wws) return NULL;
+    wws->info.bmiHeader.biSize = sizeof(wws->info.bmiHeader);
+    wws->info.bmiHeader.biClrUsed = 0;
+    wws->info.bmiHeader.biBitCount = 32;
+    wws->info.bmiHeader.biCompression = BI_RGB;
+    wws->info.bmiHeader.biWidth       = width;
+    wws->info.bmiHeader.biHeight      = -height; /* top-down */
+    wws->info.bmiHeader.biPlanes      = 1;
+    wws->info.bmiHeader.biSizeImage   = get_dib_image_size(&wws->info);
+
+    InitializeCriticalSection(&wws->crit);
+    wws->crit.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": wws");
+
+    wws->header.funcs = &wayland_window_surface_funcs;
+    wws->header.rect  = *rect;
+    wws->header.ref   = 1;
+    wws->hwnd         = hwnd;
+    reset_bounds(&wws->bounds);
+
+    if (!(wws->bits = heap_alloc(wws->info.bmiHeader.biSizeImage)))
+        goto failed;
+
+    TRACE("created %p hwnd %p %s bits %p-%p compression %d\n", wws, hwnd, wine_dbgstr_rect(rect),
+           wws->bits, (char *)wws->bits + wws->info.bmiHeader.biSizeImage,
+           wws->info.bmiHeader.biCompression);
+
+    return &wws->header;
+
+failed:
+    wayland_window_surface_destroy(&wws->header);
+    return NULL;
+}
+
+/***********************************************************************
+ *           wayland_window_surface_needs_flush
+ */
+BOOL wayland_window_surface_needs_flush(struct window_surface *window_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+    return wws->last_flush_failed;
+}
+
+/***********************************************************************
+ *           wayland_window_surface_update_wayland_surface
+ */
+void wayland_window_surface_update_wayland_surface(struct window_surface *window_surface,
+                                                   struct wayland_surface *wayland_surface)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+
+    window_surface->funcs->lock(window_surface);
+
+    if (wayland_surface) wayland_surface_ref(wayland_surface);
+    if (wws->wayland_surface) wayland_surface_unref(wws->wayland_surface);
+    wws->wayland_surface = wayland_surface;
+
+    /* We only need a buffer queue if we have a surface to commit to. */
+    if (wws->wayland_surface && !wws->wayland_buffer_queue)
+    {
+        wws->wayland_buffer_queue =
+            wayland_buffer_queue_create(wws->wayland_surface->wayland,
+                    wws->info.bmiHeader.biWidth, abs(wws->info.bmiHeader.biHeight),
+                    WL_SHM_FORMAT_XRGB8888);
+    }
+    else if (!wws->wayland_surface && wws->wayland_buffer_queue)
+    {
+        wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
+        wws->wayland_buffer_queue = NULL;
+    }
+
+    window_surface->funcs->unlock(window_surface);
+}
-- 
2.34.1


From cc06e777d5bd460399e28f9b8ee1b4d4ef14b136 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 3 Sep 2021 14:37:22 +0300
Subject: [PATCH 031/147] winewayland.drv: Read and dispatch Wayland events.

Create a separate reader thread to read Wayland events from the compositor
and dispatch them to their appropriate queues. The reader thread
notifies all Wayland-enabled threads of possible new events by using
an unnamed pipe for each thread. The read end of the pipe is
used as the Wine driver queue fd for the respective thread.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c         | 133 +++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |   3 +
 dlls/winewayland.drv/waylanddrv_main.c |  48 +++++++++
 3 files changed, 184 insertions(+)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 385ac73575c..3d5fe2c69d5 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -25,6 +25,11 @@
 #include "wine/debug.h"
 #include "wine/heap.h"
 
+#include <errno.h>
+#include <fcntl.h>
+#include <poll.h>
+#include <unistd.h>
+
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
 struct wl_display *process_wl_display = NULL;
@@ -40,6 +45,17 @@ static CRITICAL_SECTION_DEBUG process_wayland_critsect_debug =
 CRITICAL_SECTION process_wayland_section = { &process_wayland_critsect_debug,
                                              -1, 0, 0, 0, 0 };
 
+static CRITICAL_SECTION thread_wayland_section;
+static CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &thread_wayland_section,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": thread_wayland_section") }
+};
+static CRITICAL_SECTION thread_wayland_section = { &critsect_debug, -1, 0, 0, 0, 0 };
+
+static struct wl_list thread_wayland_list = {&thread_wayland_list, &thread_wayland_list};
+
 /**********************************************************************
  *          xdg_wm_base handling
  */
@@ -141,8 +157,14 @@ static const struct wl_registry_listener registry_listener = {
  */
 BOOL wayland_init(struct wayland *wayland)
 {
+    int flags;
+
     TRACE("wayland=%p wl_display=%p\n", wayland, process_wl_display);
 
+    wl_list_init(&wayland->thread_link);
+    wayland->event_notification_pipe[0] = -1;
+    wayland->event_notification_pipe[1] = -1;
+
     wayland->process_id = GetCurrentProcessId();
     wayland->thread_id = GetCurrentThreadId();
     wayland->wl_display = process_wl_display;
@@ -184,6 +206,24 @@ BOOL wayland_init(struct wayland *wayland)
     wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
     wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
 
+    if (!wayland_is_process(wayland))
+    {
+        /* Thread wayland instances have notification pipes to inform them when
+         * there might be new events in their queues. The read part of the pipe
+         * is also used as the wine server queue fd. */
+        if (pipe2(wayland->event_notification_pipe, O_CLOEXEC) == -1)
+            return FALSE;
+        /* Make just the read end non-blocking */
+        if ((flags = fcntl(wayland->event_notification_pipe[0], F_GETFL)) == -1)
+            return FALSE;
+        if (fcntl(wayland->event_notification_pipe[0], F_SETFL, flags | O_NONBLOCK) == -1)
+            return FALSE;
+        /* Keep a list of all thread wayland instances, so we can notify them. */
+        EnterCriticalSection(&thread_wayland_section);
+        wl_list_insert(&thread_wayland_list, &wayland->thread_link);
+        LeaveCriticalSection(&thread_wayland_section);
+    }
+
     wayland->initialized = TRUE;
 
     return TRUE;
@@ -200,6 +240,15 @@ void wayland_deinit(struct wayland *wayland)
 
     TRACE("%p\n", wayland);
 
+    EnterCriticalSection(&thread_wayland_section);
+    wl_list_remove(&wayland->thread_link);
+    LeaveCriticalSection(&thread_wayland_section);
+
+    if (wayland->event_notification_pipe[0] >= 0)
+        close(wayland->event_notification_pipe[0]);
+    if (wayland->event_notification_pipe[1] >= 0)
+        close(wayland->event_notification_pipe[1]);
+
     wl_list_for_each_safe(output, output_tmp, &wayland->output_list, link)
         wayland_output_destroy(output);
 
@@ -301,3 +350,87 @@ int wayland_dispatch_buffer(struct wayland *wayland)
     return wl_display_dispatch_queue_pending(wayland->wl_display,
                                              wayland->buffer_wl_event_queue);
 }
+
+static void wayland_notify_threads(void)
+{
+    struct wayland *w;
+    int ret;
+
+    EnterCriticalSection(&thread_wayland_section);
+
+    wl_list_for_each(w, &thread_wayland_list, thread_link)
+    {
+        while ((ret = write(w->event_notification_pipe[1], "a", 1)) != 1)
+        {
+            if (ret == -1 && errno != EINTR)
+            {
+                ERR("failed to write to notification pipe: %s\n", strerror(errno));
+                break;
+            }
+        }
+    }
+
+    LeaveCriticalSection(&thread_wayland_section);
+}
+
+/**********************************************************************
+ *          wayland_read_events
+ *
+ * Read wayland events from the compositor, place them in their proper
+ * event queues and notify threads about the possibility of new events.
+ *
+ * Returns whether the operation succeeded.
+ */
+BOOL wayland_read_events(void)
+{
+    struct pollfd pfd = {0};
+    int ret;
+
+    pfd.fd = wl_display_get_fd(process_wl_display);
+    pfd.events = POLLIN;
+
+    TRACE("waiting for events...\n");
+
+    /* In order to read events we need to prepare the read on some
+     * queue. We can safely use the default queue, since it's
+     * otherwise unused (all struct wayland instances dispatch to
+     * their own queues). */
+    while (wl_display_prepare_read(process_wl_display) != 0)
+    {
+        if (wl_display_dispatch_pending(process_wl_display) == -1)
+        {
+            TRACE("... failed wl_display_dispatch_pending errno=%d\n", errno);
+            return FALSE;
+        }
+    }
+
+    wl_display_flush(process_wl_display);
+
+    while ((ret = poll(&pfd, 1, -1)) == -1 && errno == EINTR) continue;
+
+    if (ret == -1 || !(pfd.revents & POLLIN))
+    {
+        TRACE("... failed poll errno=%d revents=0x%x\n",
+              ret == -1 ? errno : 0, pfd.revents);
+        wl_display_cancel_read(process_wl_display);
+        return FALSE;
+    }
+
+    if (wl_display_read_events(process_wl_display) == -1)
+    {
+        TRACE("... failed wl_display_read_events errno=%d\n", errno);
+        return FALSE;
+    }
+
+    if (wl_display_dispatch_pending(process_wl_display) == -1)
+    {
+        TRACE("... failed wl_display_dispatch_pending errno=%d\n", errno);
+        return FALSE;
+    }
+
+    wayland_notify_threads();
+
+    TRACE("... done\n");
+
+    return TRUE;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 03e2b13acd7..a3cde85999b 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -82,6 +82,8 @@ struct wayland
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t next_fallback_output_id;
     struct wl_list output_list;
+    int event_notification_pipe[2];
+    struct wl_list thread_link;
 };
 
 struct wayland_output_mode
@@ -211,6 +213,7 @@ struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
  */
 
 int wayland_dispatch_buffer(struct wayland *wayland);
+BOOL wayland_read_events(void);
 
 /**********************************************************************
  *          Wayland buffer queue
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 1e96be9c972..cf0b6bcbd4f 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -26,12 +26,54 @@
 
 #include "wine/debug.h"
 #include "wine/heap.h"
+#include "wine/server.h"
+
+#include <stdlib.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
 DWORD thread_data_tls_index = TLS_OUT_OF_INDEXES;
 
+static DWORD WINAPI wayland_read_thread(void *arg)
+{
+    while (wayland_read_events()) continue;
+    /* This thread terminates only if an unrecoverable error occured during
+     * event reading. */
+    exit(1);
+    return 0;
+}
+
+static void set_queue_fd(struct wayland *wayland)
+{
+    HANDLE handle;
+    int wfd;
+    int ret;
+
+    wfd = wayland->event_notification_pipe[0];
+
+    if (wine_server_fd_to_handle(wfd, GENERIC_READ | SYNCHRONIZE, 0, &handle))
+    {
+        ERR("Can't allocate handle for wayland fd\n");
+        ExitProcess(1);
+    }
+
+    SERVER_START_REQ(set_queue_fd)
+    {
+        req->handle = wine_server_obj_handle(handle);
+        ret = wine_server_call(req);
+    }
+    SERVER_END_REQ;
+
+    if (ret)
+    {
+        ERR("Can't store handle for wayland fd %x\n", ret);
+        ExitProcess(1);
+    }
+
+    CloseHandle(handle);
+}
+
 /***********************************************************************
  *           Initialize per thread data
  */
@@ -55,6 +97,7 @@ struct wayland_thread_data *wayland_init_thread_data(void)
         ExitProcess(1);
     }
 
+    set_queue_fd(&data->wayland);
     TlsSetValue(thread_data_tls_index, data);
 
     return data;
@@ -93,12 +136,17 @@ static const struct user_driver_funcs waylanddrv_funcs =
  */
 static BOOL process_attach(void)
 {
+    DWORD id;
+
     if ((thread_data_tls_index = TlsAlloc()) == TLS_OUT_OF_INDEXES) return FALSE;
 
     __wine_set_user_driver(&waylanddrv_funcs, WINE_GDI_DRIVER_VERSION);
 
     if (!wayland_process_init()) return FALSE;
 
+    /* All reads of wayland events happen from a dedicated thread. */
+    CreateThread(NULL, 0, wayland_read_thread, NULL, 0, &id);
+
     return TRUE;
 }
 
-- 
2.34.1


From efd565dc8891a752a3010dd4fbfb0f1350fc2736 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 3 Sep 2021 16:37:15 +0300
Subject: [PATCH 032/147] winewayland.drv: Add functions to transform Wayland
 to Wine coordinates.

The functions are currently trivial, in the sense that they apply the
identity transformation. They will be enhanced as needed in upcoming
commits to handle differences in the coordinate spaces, introduced, e.g,
by the use of scaling.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 40 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  6 ++++
 2 files changed, 46 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 8e04f824bcb..cc107c8e830 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -24,6 +24,8 @@
 #include "wine/debug.h"
 #include "wine/heap.h"
 
+#include "winuser.h"
+
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
 static void handle_xdg_surface_configure(void *data, struct xdg_surface *xdg_surface,
@@ -450,6 +452,31 @@ void wayland_surface_unmap(struct wayland_surface *surface)
     LeaveCriticalSection(&surface->crit);
 }
 
+/**********************************************************************
+ *          wayland_surface_coords_to_screen
+ *
+ * Converts the surface-local coordinates to Windows screen coordinates.
+ */
+void wayland_surface_coords_to_screen(struct wayland_surface *surface,
+                                      double wayland_x, double wayland_y,
+                                      int *screen_x, int *screen_y)
+{
+    RECT window_rect = {0};
+    int wine_x, wine_y;
+
+    wayland_surface_coords_to_wine(surface, wayland_x, wayland_y,
+                                   &wine_x, &wine_y);
+
+    GetWindowRect(surface->hwnd, &window_rect);
+
+    *screen_x = wine_x + window_rect.left;
+    *screen_y = wine_y + window_rect.top;
+
+    TRACE("hwnd=%p wayland=%.2f,%.2f rect=%s => screen=%d,%d\n",
+          surface->hwnd, wayland_x, wayland_y, wine_dbgstr_rect(&window_rect),
+          *screen_x, *screen_y);
+}
+
 /**********************************************************************
  *          wayland_surface_coords_from_wine
  *
@@ -479,6 +506,19 @@ void wayland_surface_coords_rounded_from_wine(struct wayland_surface *surface,
     *wayland_y = round(w_y);
 }
 
+/**********************************************************************
+ *          wayland_surface_coords_to_wine
+ *
+ * Converts the surface-local coordinates to wine windows-local coordinates.
+ */
+void wayland_surface_coords_to_wine(struct wayland_surface *surface,
+                                    double wayland_x, double wayland_y,
+                                    int *wine_x, int *wine_y)
+{
+    *wine_x = round(wayland_x);
+    *wine_y = round(wayland_y);
+}
+
 /**********************************************************************
  *          wayland_surface_ref
  *
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index a3cde85999b..09460f01da9 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -245,12 +245,18 @@ BOOL wayland_surface_commit_buffer(struct wayland_surface *surface,
 void wayland_surface_destroy(struct wayland_surface *surface);
 void wayland_surface_unmap(struct wayland_surface *surface);
 void wayland_surface_ack_pending_configure(struct wayland_surface *surface);
+void wayland_surface_coords_to_screen(struct wayland_surface *surface,
+                                      double wayland_x, double wayland_y,
+                                      int *screen_x, int *screen_y);
 void wayland_surface_coords_from_wine(struct wayland_surface *surface,
                                       int wine_x, int wine_y,
                                       double *wayland_x, double *wayland_y);
 void wayland_surface_coords_rounded_from_wine(struct wayland_surface *surface,
                                               int wine_x, int wine_y,
                                               int *wayland_x, int *wayland_y);
+void wayland_surface_coords_to_wine(struct wayland_surface *surface,
+                                    double wayland_x, double wayland_y,
+                                    int *wine_x, int *wine_y);
 struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface);
 void wayland_surface_unref(struct wayland_surface *surface);
 
-- 
2.34.1


From feb28a5672a53d784aeab0e5f47f5e0449def012 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 3 Sep 2021 16:49:33 +0300
Subject: [PATCH 033/147] winewayland.drv: Implement
 MsgWaitForMultipleObjectsEx.

Prepare for handling input events by dispatching (non-buffer) Wayland
events in MsgWaitForMultipleObjectsEx and tracking the types
events actually dispatched.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c         | 84 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      | 10 +++
 dlls/winewayland.drv/waylanddrv_main.c |  1 +
 3 files changed, 95 insertions(+)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 3d5fe2c69d5..7893edfc4ee 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -25,6 +25,8 @@
 #include "wine/debug.h"
 #include "wine/heap.h"
 
+#include "winuser.h"
+
 #include <errno.h>
 #include <fcntl.h>
 #include <poll.h>
@@ -334,6 +336,44 @@ void wayland_process_release(void)
     LeaveCriticalSection(&process_wayland_section);
 }
 
+/**********************************************************************
+ *          wayland_dispatch_non_buffer
+ *
+ * Dispatch all non-buffer events for the specified wayland instance.
+ *
+ * Returns the number of events dispatched.
+ */
+int wayland_dispatch_non_buffer(struct wayland *wayland)
+{
+    char buf[64];
+
+    TRACE("wayland=%p queue=%p\n", wayland, wayland->wl_event_queue);
+
+    wl_display_flush(wayland->wl_display);
+
+    /* Consume notifications */
+    while (TRUE)
+    {
+        int ret = read(wayland->event_notification_pipe[0], buf, sizeof(buf));
+        if (ret > 0) continue;
+        if (ret == -1)
+        {
+            if (errno == EINTR) continue;
+            if (errno == EAGAIN) break; /* no data to read */
+            ERR("failed to read from notification pipe: %s\n", strerror(errno));
+            break;
+        }
+        if (ret == 0)
+        {
+            ERR("failed to read from notification pipe: pipe is closed\n");
+            break;
+        }
+    }
+
+    return wl_display_dispatch_queue_pending(wayland->wl_display,
+                                             wayland->wl_event_queue);
+}
+
 /**********************************************************************
  *          wayland_dispatch_buffer
  *
@@ -434,3 +474,47 @@ BOOL wayland_read_events(void)
 
     return TRUE;
 }
+
+static BOOL process_wayland_events(DWORD mask)
+{
+    struct wayland *wayland = thread_wayland();
+    int dispatched;
+
+    if (!wayland)
+        return FALSE;
+
+    wayland->last_dispatch_mask = 0;
+
+    dispatched = wayland_dispatch_non_buffer(wayland);
+    if (dispatched)
+        wayland->last_dispatch_mask |= QS_SENDMESSAGE;
+
+    TRACE("dispatched=%d mask=%s%s%s%s%s%s%s\n",
+          dispatched,
+          (wayland->last_dispatch_mask & QS_KEY) ? "QS_KEY|" : "",
+          (wayland->last_dispatch_mask & QS_MOUSEMOVE) ? "QS_MOUSEMOVE|" : "",
+          (wayland->last_dispatch_mask & QS_MOUSEBUTTON) ? "QS_MOUSEBUTTON|" : "",
+          (wayland->last_dispatch_mask & QS_INPUT) ? "QS_INPUT|" : "",
+          (wayland->last_dispatch_mask & QS_PAINT) ? "QS_PAINT|" : "",
+          (wayland->last_dispatch_mask & QS_POSTMESSAGE) ? "QS_POSTMESSAGE|" : "",
+          (wayland->last_dispatch_mask & QS_SENDMESSAGE) ? "QS_SENDMESSAGE|" : "");
+
+    return wayland->last_dispatch_mask & mask;
+}
+
+/***********************************************************************
+ *           WAYLAND_MsgWaitForMultipleObjectsEx
+ */
+DWORD CDECL WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
+                                                DWORD timeout, DWORD mask, DWORD flags)
+{
+    DWORD ret;
+
+    if (process_wayland_events(mask))
+        return count - 1;
+
+    ret = WaitForMultipleObjectsEx(count, handles, flags & MWMO_WAITALL,
+                                   timeout, flags & MWMO_ALERTABLE);
+
+    return ret;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 09460f01da9..87f6fba41e2 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -82,6 +82,7 @@ struct wayland
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t next_fallback_output_id;
     struct wl_list output_list;
+    DWORD last_dispatch_mask;
     int event_notification_pipe[2];
     struct wl_list thread_link;
 };
@@ -185,6 +186,13 @@ static inline struct wayland *thread_init_wayland(void)
     return &wayland_init_thread_data()->wayland;
 }
 
+static inline struct wayland *thread_wayland(void)
+{
+    struct wayland_thread_data *data = wayland_thread_data();
+    if (!data) return NULL;
+    return &data->wayland;
+}
+
 /**********************************************************************
  *          Wayland initialisation
  */
@@ -290,6 +298,8 @@ void wayland_window_surface_update_wayland_surface(struct window_surface *surfac
 extern BOOL CDECL WAYLAND_CreateWindow(HWND hwnd) DECLSPEC_HIDDEN;
 extern void CDECL WAYLAND_DestroyWindow(HWND hwnd) DECLSPEC_HIDDEN;
 extern BOOL CDECL WAYLAND_EnumDisplaySettingsEx(LPCWSTR name, DWORD n, LPDEVMODEW devmode, DWORD flags) DECLSPEC_HIDDEN;
+extern DWORD CDECL WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
+                                                       DWORD timeout, DWORD mask, DWORD flags) DECLSPEC_HIDDEN;
 extern void CDECL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
                                                BOOL force, void *param) DECLSPEC_HIDDEN;
 extern LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index cf0b6bcbd4f..9556e809769 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -124,6 +124,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pCreateWindow = WAYLAND_CreateWindow,
     .pDestroyWindow = WAYLAND_DestroyWindow,
     .pEnumDisplaySettingsEx = WAYLAND_EnumDisplaySettingsEx,
+    .pMsgWaitForMultipleObjectsEx = WAYLAND_MsgWaitForMultipleObjectsEx,
     .pThreadDetach = WAYLAND_ThreadDetach,
     .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
     .pWindowMessage = WAYLAND_WindowMessage,
-- 
2.34.1


From 2571e9f4ef5d197a1ad75deaf62fd4ca1d43945c Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 4 Oct 2021 12:56:08 +0300
Subject: [PATCH 034/147] winewayland.drv: Handle Wayland pointer events.

Handle pointer events from the Wayland compositor, transform them
appropriately and send them to Wine core.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |   1 +
 dlls/winewayland.drv/wayland.c         |  40 +++++
 dlls/winewayland.drv/wayland_pointer.c | 225 +++++++++++++++++++++++++
 dlls/winewayland.drv/wayland_surface.c |   5 +
 dlls/winewayland.drv/waylanddrv.h      |  18 ++
 5 files changed, 289 insertions(+)
 create mode 100644 dlls/winewayland.drv/wayland_pointer.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 46ccc88d269..6ab7b7a87e9 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -15,6 +15,7 @@ C_SRCS = \
 	wayland_output.c \
 	waylanddrv_main.c \
 	wayland_buffer_queue.c \
+	wayland_pointer.c \
 	wayland_shm.c \
 	wayland_surface.c \
 	window.c \
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 7893edfc4ee..c9c78f117fa 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -71,6 +71,34 @@ static const struct xdg_wm_base_listener xdg_wm_base_listener = {
     xdg_wm_base_ping,
 };
 
+/**********************************************************************
+ *          Seat handling
+ */
+
+static void seat_handle_capabilities(void *data, struct wl_seat *seat,
+                                     enum wl_seat_capability caps)
+{
+    struct wayland *wayland = data;
+
+    if ((caps & WL_SEAT_CAPABILITY_POINTER) && !wayland->pointer.wl_pointer)
+    {
+        wayland_pointer_init(&wayland->pointer, wayland, wl_seat_get_pointer(seat));
+    }
+    else if (!(caps & WL_SEAT_CAPABILITY_POINTER) && wayland->pointer.wl_pointer)
+    {
+        wayland_pointer_deinit(&wayland->pointer);
+    }
+}
+
+static void seat_handle_name(void *data, struct wl_seat *seat, const char *name)
+{
+}
+
+static const struct wl_seat_listener seat_listener = {
+    seat_handle_capabilities,
+    seat_handle_name,
+};
+
 /**********************************************************************
  *          Registry handling
  */
@@ -124,6 +152,12 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
     {
         wayland->wl_shm = wl_registry_bind(registry, id, &wl_shm_interface, 1);
     }
+    else if (strcmp(interface, "wl_seat") == 0)
+    {
+        wayland->wl_seat = wl_registry_bind(registry, id, &wl_seat_interface,
+                                            version < 5 ? version : 5);
+        wl_seat_add_listener(wayland->wl_seat, &seat_listener, wayland);
+    }
 }
 
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
@@ -254,6 +288,12 @@ void wayland_deinit(struct wayland *wayland)
     wl_list_for_each_safe(output, output_tmp, &wayland->output_list, link)
         wayland_output_destroy(output);
 
+    if (wayland->pointer.wl_pointer)
+        wayland_pointer_deinit(&wayland->pointer);
+
+    if (wayland->wl_seat)
+        wl_seat_destroy(wayland->wl_seat);
+
     if (wayland->wl_shm)
         wl_shm_destroy(wayland->wl_shm);
 
diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
new file mode 100644
index 00000000000..d62cfef9dfb
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -0,0 +1,225 @@
+/*
+ * Wayland input handling
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "winuser.h"
+
+#include <linux/input.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+/**********************************************************************
+ *          Pointer handling
+ */
+
+static void pointer_handle_motion_internal(void *data, struct wl_pointer *pointer,
+                                           uint32_t time, wl_fixed_t sx, wl_fixed_t sy)
+{
+    struct wayland *wayland = data;
+    HWND focused_hwnd = wayland->pointer.focused_surface ?
+                        wayland->pointer.focused_surface->hwnd : 0;
+    INPUT input = {0};
+    int screen_x, screen_y;
+
+    if (!focused_hwnd)
+        return;
+
+    wayland_surface_coords_to_screen(wayland->pointer.focused_surface,
+                                     wl_fixed_to_double(sx),
+                                     wl_fixed_to_double(sy),
+                                     &screen_x, &screen_y);
+
+    TRACE("surface=%p hwnd=%p wayland_xy=%.2f,%.2f screen_xy=%d,%d\n",
+          wayland->pointer.focused_surface, focused_hwnd,
+          wl_fixed_to_double(sx), wl_fixed_to_double(sy),
+          screen_x, screen_y);
+
+    input.type           = INPUT_MOUSE;
+    input.mi.dx          = screen_x;
+    input.mi.dy          = screen_y;
+    input.mi.dwFlags     = MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE;
+
+    wayland->last_dispatch_mask |= QS_MOUSEMOVE;
+
+    __wine_send_input(focused_hwnd, &input, NULL);
+}
+
+static void pointer_handle_motion(void *data, struct wl_pointer *pointer,
+                                  uint32_t time, wl_fixed_t sx, wl_fixed_t sy)
+{
+    pointer_handle_motion_internal(data, pointer, time, sx, sy);
+}
+
+static void pointer_handle_enter(void *data, struct wl_pointer *pointer,
+                                 uint32_t serial, struct wl_surface *surface,
+                                 wl_fixed_t sx, wl_fixed_t sy)
+{
+    struct wayland *wayland = data;
+    struct wayland_surface *wayland_surface =
+        surface ? wl_surface_get_user_data(surface) : NULL;
+
+    /* Since pointer events can arrive in multiple threads, ensure we only
+     * handle them in the thread that owns the surface, to avoid passing
+     * duplicate events to Wine. */
+    if (wayland_surface && wayland_surface->hwnd &&
+        wayland_surface->wayland == wayland)
+    {
+        TRACE("surface=%p hwnd=%p\n", wayland_surface, wayland_surface->hwnd);
+        wayland->pointer.focused_surface = wayland_surface;
+        wayland->pointer.enter_serial = serial;
+        /* Handle the enter as a motion, to account for cases where the
+         * window first appears beneath the pointer and won't get a separate
+         * motion event. */
+        pointer_handle_motion_internal(data, pointer, 0, sx, sy);
+    }
+}
+
+static void pointer_handle_leave(void *data, struct wl_pointer *pointer,
+                                 uint32_t serial, struct wl_surface *surface)
+{
+    struct wayland *wayland = data;
+
+    if (wayland->pointer.focused_surface &&
+        wayland->pointer.focused_surface->wl_surface == surface)
+    {
+        TRACE("surface=%p hwnd=%p\n",
+              wayland->pointer.focused_surface,
+              wayland->pointer.focused_surface->hwnd);
+        wayland->pointer.focused_surface = NULL;
+        wayland->pointer.enter_serial = 0;
+    }
+}
+
+static void pointer_handle_button(void *data, struct wl_pointer *wl_pointer,
+                                  uint32_t serial, uint32_t time, uint32_t button,
+                                  uint32_t state)
+{
+    struct wayland *wayland = data;
+    HWND focused_hwnd = wayland->pointer.focused_surface ?
+                        wayland->pointer.focused_surface->hwnd : 0;
+    INPUT input = {0};
+
+    if (!focused_hwnd)
+        return;
+
+    TRACE("button=%#x state=%#x hwnd=%p\n", button, state, focused_hwnd);
+
+    input.type = INPUT_MOUSE;
+
+    switch (button)
+    {
+    case BTN_LEFT: input.mi.dwFlags = MOUSEEVENTF_LEFTDOWN; break;
+    case BTN_RIGHT: input.mi.dwFlags = MOUSEEVENTF_RIGHTDOWN; break;
+    case BTN_MIDDLE: input.mi.dwFlags = MOUSEEVENTF_MIDDLEDOWN; break;
+    default: break;
+    }
+
+    if (state == WL_POINTER_BUTTON_STATE_RELEASED)
+        input.mi.dwFlags <<= 1;
+
+    wayland->last_dispatch_mask |= QS_MOUSEBUTTON;
+
+    __wine_send_input(focused_hwnd, &input, NULL);
+}
+
+static void pointer_handle_axis(void *data, struct wl_pointer *wl_pointer,
+                                uint32_t time, uint32_t axis, wl_fixed_t value)
+{
+}
+
+static void pointer_handle_frame(void *data, struct wl_pointer *wl_pointer)
+{
+}
+
+static void pointer_handle_axis_source(void *data, struct wl_pointer *wl_pointer,
+                                       uint32_t axis_source)
+{
+}
+
+static void pointer_handle_axis_stop(void *data, struct wl_pointer *wl_pointer,
+                                     uint32_t time, uint32_t axis)
+{
+}
+
+static void pointer_handle_axis_discrete(void *data, struct wl_pointer *wl_pointer,
+                                         uint32_t axis, int32_t discrete)
+{
+    struct wayland *wayland = data;
+    HWND focused_hwnd = wayland->pointer.focused_surface ?
+                        wayland->pointer.focused_surface->hwnd : 0;
+    INPUT input = {0};
+
+    if (!focused_hwnd)
+        return;
+
+    TRACE("axis=%#x discrete=%d hwnd=%p\n", axis, discrete, focused_hwnd);
+
+    input.type = INPUT_MOUSE;
+
+    switch (axis)
+    {
+    case WL_POINTER_AXIS_VERTICAL_SCROLL:
+        input.mi.dwFlags = MOUSEEVENTF_WHEEL;
+        input.mi.mouseData = -WHEEL_DELTA * discrete;
+        break;
+    case WL_POINTER_AXIS_HORIZONTAL_SCROLL:
+        input.mi.dwFlags = MOUSEEVENTF_HWHEEL;
+        input.mi.mouseData = WHEEL_DELTA * discrete;
+        break;
+    default: break;
+    }
+
+    wayland->last_dispatch_mask |= QS_MOUSEBUTTON;
+
+    __wine_send_input(focused_hwnd, &input, NULL);
+}
+
+static const struct wl_pointer_listener pointer_listener = {
+    pointer_handle_enter,
+    pointer_handle_leave,
+    pointer_handle_motion,
+    pointer_handle_button,
+    pointer_handle_axis,
+    pointer_handle_frame,
+    pointer_handle_axis_source,
+    pointer_handle_axis_stop,
+    pointer_handle_axis_discrete,
+};
+
+void wayland_pointer_init(struct wayland_pointer *pointer, struct wayland *wayland,
+                          struct wl_pointer *wl_pointer)
+{
+    wayland->pointer.wayland = wayland;
+    wayland->pointer.wl_pointer = wl_pointer;
+    wl_pointer_add_listener(wayland->pointer.wl_pointer, &pointer_listener, wayland);
+}
+
+void wayland_pointer_deinit(struct wayland_pointer *pointer)
+{
+    if (pointer->wl_pointer)
+        wl_pointer_destroy(pointer->wl_pointer);
+
+    memset(pointer, 0, sizeof(*pointer));
+}
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index cc107c8e830..804798721b2 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -396,8 +396,13 @@ BOOL wayland_surface_commit_buffer(struct wayland_surface *surface,
  */
 void wayland_surface_destroy(struct wayland_surface *surface)
 {
+    struct wayland_pointer *pointer = &surface->wayland->pointer;
+
     TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
 
+    if (pointer->focused_surface == surface)
+        pointer->focused_surface = NULL;
+
     if (surface->xdg_toplevel)
     {
         xdg_toplevel_destroy(surface->xdg_toplevel);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 87f6fba41e2..29311fa8525 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -66,6 +66,14 @@ enum wayland_configure_flags
  *          Definitions for wayland types
  */
 
+struct wayland_pointer
+{
+    struct wayland *wayland;
+    struct wl_pointer *wl_pointer;
+    struct wayland_surface *focused_surface;
+    uint32_t enter_serial;
+};
+
 struct wayland
 {
     BOOL initialized;
@@ -79,9 +87,11 @@ struct wayland
     struct wl_subcompositor *wl_subcompositor;
     struct xdg_wm_base *xdg_wm_base;
     struct wl_shm *wl_shm;
+    struct wl_seat *wl_seat;
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t next_fallback_output_id;
     struct wl_list output_list;
+    struct wayland_pointer pointer;
     DWORD last_dispatch_mask;
     int event_notification_pipe[2];
     struct wl_list thread_link;
@@ -291,6 +301,14 @@ BOOL wayland_window_surface_needs_flush(struct window_surface *surface);
 void wayland_window_surface_update_wayland_surface(struct window_surface *surface,
                                                    struct wayland_surface *wayland_surface);
 
+/**********************************************************************
+ *          Wayland Pointer
+ */
+
+void wayland_pointer_init(struct wayland_pointer *pointer, struct wayland *wayland,
+                          struct wl_pointer *wl_pointer);
+void wayland_pointer_deinit(struct wayland_pointer *pointer);
+
 /**********************************************************************
  *          USER driver functions
  */
-- 
2.34.1


From 76d47b74ab1dc517be939d8525a7219c0a62950d Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 4 Oct 2021 13:02:25 +0300
Subject: [PATCH 035/147] winewayland.drv: Implement SetCursor.

Instruct the Wayland compositor to set or update the cursor surface for
the Wayland surface that has the pointer focus when SetCursor is called.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |   1 +
 dlls/winewayland.drv/wayland_cursor.c  | 372 +++++++++++++++++++++++++
 dlls/winewayland.drv/wayland_pointer.c |  26 ++
 dlls/winewayland.drv/waylanddrv.h      |  23 +-
 dlls/winewayland.drv/waylanddrv_main.c |   3 +
 dlls/winewayland.drv/window.c          |   4 +
 6 files changed, 428 insertions(+), 1 deletion(-)
 create mode 100644 dlls/winewayland.drv/wayland_cursor.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 6ab7b7a87e9..d28694cb3d6 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -15,6 +15,7 @@ C_SRCS = \
 	wayland_output.c \
 	waylanddrv_main.c \
 	wayland_buffer_queue.c \
+	wayland_cursor.c \
 	wayland_pointer.c \
 	wayland_shm.c \
 	wayland_surface.c \
diff --git a/dlls/winewayland.drv/wayland_cursor.c b/dlls/winewayland.drv/wayland_cursor.c
new file mode 100644
index 00000000000..24c67199594
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_cursor.c
@@ -0,0 +1,372 @@
+/*
+ * Wayland cursor handling
+ *
+ * Copyright 1993, 1994, 1995, 1996, 2001, 2013-2017 Alexandre Julliard
+ * Copyright 1993 David Metcalfe
+ * Copyright 1995, 1996 Alex Korobka
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#define NONAMELESSUNION
+#define NONAMELESSSTRUCT
+
+#include "waylanddrv.h"
+
+#include "winuser.h"
+#include "wine/debug.h"
+#include "wine/heap.h"
+#include "wine/server.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+static HCURSOR last_cursor;
+static HCURSOR invalid_cursor;
+
+/***********************************************************************
+ *           create_mono_cursor_buffer
+ *
+ * Return a monochrome icon/cursor wl_shm_buffer
+ */
+static struct wayland_shm_buffer *create_mono_cursor_buffer(struct wayland *wayland,
+                                                            HBITMAP bmp)
+{
+    struct wayland_shm_buffer *shm_buffer = NULL;
+    BITMAP bm;
+    char *mask = NULL;
+    unsigned int i, j, stride, mask_size, *ptr;
+
+    if (!GetObjectW(bmp, sizeof(bm), &bm)) return NULL;
+    stride = ((bm.bmWidth + 15) >> 3) & ~1;
+    mask_size = stride * bm.bmHeight;
+    if (!(mask = heap_alloc(mask_size))) return NULL;
+    if (!GetBitmapBits(bmp, mask_size, mask)) goto done;
+
+    bm.bmHeight /= 2;
+    shm_buffer = wayland_shm_buffer_create(wayland, bm.bmWidth, bm.bmHeight,
+                                           WL_SHM_FORMAT_ARGB8888);
+    if (!shm_buffer) goto done;
+
+    ptr = shm_buffer->map_data;
+    for (i = 0; i < bm.bmHeight; i++)
+    {
+        for (j = 0; j < bm.bmWidth; j++, ptr++)
+        {
+            int and = ((mask[i * stride + j / 8] << (j % 8)) & 0x80);
+            int xor = ((mask[(i + bm.bmHeight) * stride + j / 8] << (j % 8)) & 0x80);
+            if (!xor && and)
+                *ptr = 0;
+            else if (xor && !and)
+                *ptr = 0xffffffff;
+            else
+                /* we can't draw "invert" pixels, so render them as black instead */
+                *ptr = 0xff000000;
+        }
+    }
+
+done:
+    heap_free(mask);
+    return shm_buffer;
+}
+
+/***********************************************************************
+ *           get_bitmap_argb
+ *
+ * Return the bitmap bits in ARGB format. Helper for setting icons and cursors.
+ */
+static struct wayland_shm_buffer *create_color_cursor_buffer(struct wayland *wayland,
+                                                             HDC hdc, HBITMAP color,
+                                                             HBITMAP mask)
+{
+    struct wayland_shm_buffer *shm_buffer = NULL;
+    char buffer[FIELD_OFFSET(BITMAPINFO, bmiColors[256])];
+    BITMAPINFO *info = (BITMAPINFO *)buffer;
+    BITMAP bm;
+    unsigned int *ptr, *bits = NULL;
+    unsigned char *mask_bits = NULL;
+    int i, j;
+    BOOL has_alpha = FALSE;
+
+    if (!GetObjectW(color, sizeof(bm), &bm)) goto failed;
+
+    shm_buffer = wayland_shm_buffer_create(wayland, bm.bmWidth, bm.bmHeight,
+                                           WL_SHM_FORMAT_ARGB8888);
+    if (!shm_buffer) goto failed;
+    bits = shm_buffer->map_data;
+
+    info->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
+    info->bmiHeader.biWidth = bm.bmWidth;
+    info->bmiHeader.biHeight = -bm.bmHeight;
+    info->bmiHeader.biPlanes = 1;
+    info->bmiHeader.biBitCount = 32;
+    info->bmiHeader.biCompression = BI_RGB;
+    info->bmiHeader.biSizeImage = bm.bmWidth * bm.bmHeight * 4;
+    info->bmiHeader.biXPelsPerMeter = 0;
+    info->bmiHeader.biYPelsPerMeter = 0;
+    info->bmiHeader.biClrUsed = 0;
+    info->bmiHeader.biClrImportant = 0;
+
+    if (!GetDIBits(hdc, color, 0, bm.bmHeight, bits, info, DIB_RGB_COLORS)) goto failed;
+
+    for (i = 0; i < bm.bmWidth * bm.bmHeight; i++)
+        if ((has_alpha = (bits[i] & 0xff000000) != 0)) break;
+
+    if (!has_alpha)
+    {
+        unsigned int width_bytes = (bm.bmWidth + 31) / 32 * 4;
+        /* generate alpha channel from the mask */
+        info->bmiHeader.biBitCount = 1;
+        info->bmiHeader.biSizeImage = width_bytes * bm.bmHeight;
+        if (!(mask_bits = heap_alloc(info->bmiHeader.biSizeImage))) goto failed;
+        if (!GetDIBits(hdc, mask, 0, bm.bmHeight, mask_bits, info, DIB_RGB_COLORS)) goto failed;
+        ptr = bits;
+        for (i = 0; i < bm.bmHeight; i++)
+            for (j = 0; j < bm.bmWidth; j++, ptr++)
+                if (!((mask_bits[i * width_bytes + j / 8] << (j % 8)) & 0x80)) *ptr |= 0xff000000;
+        heap_free(mask_bits);
+    }
+
+    return shm_buffer;
+
+failed:
+    if (shm_buffer)
+        wayland_shm_buffer_destroy(shm_buffer);
+    heap_free(mask_bits);
+    return NULL;
+}
+
+static struct wayland_cursor *wayland_cursor_from_win32(struct wayland_pointer *pointer,
+                                                        HCURSOR handle)
+{
+    ICONINFOEXW info;
+    struct wayland_cursor *wayland_cursor = NULL;
+
+    if (!handle) goto failed;
+
+    wayland_cursor = heap_alloc_zero(sizeof(*wayland_cursor));
+    if (!wayland_cursor) goto failed;
+
+    info.cbSize = sizeof(info);
+    if (!GetIconInfoExW(handle, &info)) goto failed;
+
+    if (info.hbmColor)
+    {
+        HDC hdc = CreateCompatibleDC(0);
+        wayland_cursor->shm_buffer =
+            create_color_cursor_buffer(pointer->wayland, hdc, info.hbmColor, info.hbmMask);
+        DeleteDC(hdc);
+    }
+    else
+    {
+        wayland_cursor->shm_buffer =
+            create_mono_cursor_buffer(pointer->wayland, info.hbmMask);
+    }
+
+    if (!wayland_cursor->shm_buffer) goto failed;
+
+    /* make sure hotspot is valid */
+    if (info.xHotspot >= wayland_cursor->shm_buffer->width ||
+        info.yHotspot >= wayland_cursor->shm_buffer->height)
+    {
+        info.xHotspot = wayland_cursor->shm_buffer->width / 2;
+        info.yHotspot = wayland_cursor->shm_buffer->height / 2;
+    }
+
+    if (pointer->focused_surface)
+    {
+        wayland_surface_coords_rounded_from_wine(pointer->focused_surface,
+                                                 info.xHotspot, info.yHotspot,
+                                                 &wayland_cursor->hotspot_x,
+                                                 &wayland_cursor->hotspot_y);
+    }
+    else
+    {
+        wayland_cursor->hotspot_x = info.xHotspot;
+        wayland_cursor->hotspot_y = info.yHotspot;
+    }
+
+    DeleteObject(info.hbmColor);
+    DeleteObject(info.hbmMask);
+
+    return wayland_cursor;
+
+failed:
+    if (wayland_cursor)
+        wayland_cursor_destroy(wayland_cursor);
+
+    return NULL;
+}
+
+/***********************************************************************
+ *           wayland_cursor_destroy
+ *
+ *  Destroy a Wayland cursor and its associated resources.
+ */
+void wayland_cursor_destroy(struct wayland_cursor *wayland_cursor)
+{
+    if (!wayland_cursor)
+        return;
+
+    if (wayland_cursor->shm_buffer)
+        wayland_shm_buffer_destroy(wayland_cursor->shm_buffer);
+
+    heap_free(wayland_cursor);
+}
+
+/***********************************************************************
+ *           wayland_pointer_update_cursor_from_win32
+ *
+ *  Update a Wayland pointer to use the specified cursor, or NULL
+ *  to hide the cursor.
+ */
+void wayland_pointer_update_cursor_from_win32(struct wayland_pointer *pointer,
+                                              HCURSOR handle)
+{
+    struct wayland_cursor *wayland_cursor = pointer->cursor;
+
+    TRACE("pointer=%p pointer->hcursor=%p handle=%p\n",
+          pointer, pointer ? pointer->hcursor : 0, handle);
+
+    if (!pointer->wl_pointer)
+        return;
+
+    if (pointer->hcursor != handle)
+    {
+        wayland_cursor = wayland_cursor_from_win32(pointer, handle);
+        /* If we can't create a cursor from a valid handle, better to keep the
+         * previous cursor than make it disappear completely. */
+        if (!wayland_cursor && handle)
+            return;
+
+        if (pointer->cursor)
+            wayland_cursor_destroy(pointer->cursor);
+    }
+
+    pointer->cursor = wayland_cursor;
+    pointer->hcursor = handle;
+
+    if (!pointer->cursor)
+    {
+            wl_pointer_set_cursor(pointer->wl_pointer,
+                                  pointer->enter_serial,
+                                  NULL, 0, 0);
+            return;
+    }
+
+    wl_surface_attach(pointer->cursor_wl_surface,
+                      pointer->cursor->shm_buffer->wl_buffer,
+                      0, 0);
+    wl_surface_damage_buffer(pointer->cursor_wl_surface,
+                             0, 0,
+                             wayland_cursor->shm_buffer->width,
+                             wayland_cursor->shm_buffer->height);
+
+    wl_surface_commit(pointer->cursor_wl_surface);
+
+    wl_pointer_set_cursor(pointer->wl_pointer,
+                          pointer->enter_serial,
+                          pointer->cursor_wl_surface,
+                          pointer->cursor->hotspot_x,
+                          pointer->cursor->hotspot_y);
+}
+
+/***********************************************************************
+ *           wayland_init_set_cursor
+ *
+ *  Initalize internal information, so that we can track the last set
+ *  cursor properly.
+ */
+BOOL wayland_init_set_cursor(void)
+{
+    /* Allocate a handle that we are going to treat as invalid. */
+    SERVER_START_REQ(alloc_user_handle)
+    {
+        if (!wine_server_call_err(req))
+            invalid_cursor = wine_server_ptr_handle(reply->handle);
+    }
+    SERVER_END_REQ;
+
+    TRACE("invalid_cursor=%p\n", invalid_cursor);
+
+    last_cursor = invalid_cursor;
+
+    return invalid_cursor != NULL;
+}
+
+/***********************************************************************
+ *           wayland_invalidate_set_cursor
+ *
+ *  Invalidate the cursor we consider to be set, effectively forcing
+ *  the application of next SetCursor call.
+ */
+HCURSOR wayland_invalidate_set_cursor(void)
+{
+    return __atomic_exchange_n(&last_cursor, invalid_cursor, __ATOMIC_SEQ_CST);
+}
+
+static BOOL wayland_set_cursor(HCURSOR hcursor)
+{
+    HWND foreground = NULL;
+    struct wayland *wayland = thread_wayland();
+
+    if (wayland && wayland->pointer.focused_surface)
+        foreground = wayland->pointer.focused_surface->hwnd;
+
+    if (!foreground)
+        foreground = GetForegroundWindow();
+
+    if (!foreground)
+        return FALSE;
+
+    SendMessageW(foreground, WM_WAYLAND_SET_CURSOR, 0, (LPARAM)hcursor);
+
+    return TRUE;
+}
+
+/***********************************************************************
+ *           wayland_set_cursor_if_current_invalid
+ *
+ * If the currently set cursor is invalid, apply the provided cursor,
+ * otherwise do nothing.
+ */
+void wayland_set_cursor_if_current_invalid(HCURSOR hcursor)
+{
+    HCURSOR tmp_invalid = invalid_cursor;
+
+    TRACE("hcursor=%p last_cursor=%p\n", hcursor, last_cursor);
+
+    if (hcursor != invalid_cursor &&
+        __atomic_compare_exchange_n(&last_cursor, &tmp_invalid, hcursor,
+                                    FALSE, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST))
+    {
+        if (!wayland_set_cursor(hcursor)) wayland_invalidate_set_cursor();
+    }
+}
+
+/***********************************************************************
+ *           WAYLAND_SetCursor
+ */
+void CDECL WAYLAND_SetCursor(HCURSOR hcursor)
+{
+    TRACE("hcursor=%p last_cursor=%p\n", hcursor, last_cursor);
+
+    if (__atomic_exchange_n(&last_cursor, hcursor, __ATOMIC_SEQ_CST) != hcursor)
+    {
+        if (!wayland_set_cursor(hcursor)) wayland_invalidate_set_cursor();
+    }
+}
diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index d62cfef9dfb..06d9ef099cc 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -72,6 +72,15 @@ static void pointer_handle_motion(void *data, struct wl_pointer *pointer,
     pointer_handle_motion_internal(data, pointer, time, sx, sy);
 }
 
+static void CALLBACK set_cursor_if_current_invalid(HWND hwnd, UINT msg,
+                                                   UINT_PTR timer_id,
+                                                   DWORD elapsed)
+{
+    TRACE("hwnd=%p\n", hwnd);
+    KillTimer(hwnd, timer_id);
+    wayland_set_cursor_if_current_invalid((HCURSOR)timer_id);
+}
+
 static void pointer_handle_enter(void *data, struct wl_pointer *pointer,
                                  uint32_t serial, struct wl_surface *surface,
                                  wl_fixed_t sx, wl_fixed_t sy)
@@ -86,9 +95,18 @@ static void pointer_handle_enter(void *data, struct wl_pointer *pointer,
     if (wayland_surface && wayland_surface->hwnd &&
         wayland_surface->wayland == wayland)
     {
+        HCURSOR hcursor;
         TRACE("surface=%p hwnd=%p\n", wayland_surface, wayland_surface->hwnd);
         wayland->pointer.focused_surface = wayland_surface;
         wayland->pointer.enter_serial = serial;
+        /* Invalidate the set cursor cache, so that next update is
+         * unconditionally applied. */
+        hcursor = wayland_invalidate_set_cursor();
+        /* Schedule a cursor update, to ensure the current cursor is applied on
+         * this surface, but only if the application hasn't updated the cursor
+         * in the meantime. */
+        SetTimer(wayland_surface->hwnd, (UINT_PTR)hcursor, USER_TIMER_MINIMUM,
+                 set_cursor_if_current_invalid);
         /* Handle the enter as a motion, to account for cases where the
          * window first appears beneath the pointer and won't get a separate
          * motion event. */
@@ -214,6 +232,8 @@ void wayland_pointer_init(struct wayland_pointer *pointer, struct wayland *wayla
     wayland->pointer.wayland = wayland;
     wayland->pointer.wl_pointer = wl_pointer;
     wl_pointer_add_listener(wayland->pointer.wl_pointer, &pointer_listener, wayland);
+    wayland->pointer.cursor_wl_surface =
+        wl_compositor_create_surface(wayland->wl_compositor);
 }
 
 void wayland_pointer_deinit(struct wayland_pointer *pointer)
@@ -221,5 +241,11 @@ void wayland_pointer_deinit(struct wayland_pointer *pointer)
     if (pointer->wl_pointer)
         wl_pointer_destroy(pointer->wl_pointer);
 
+    if (pointer->cursor_wl_surface)
+        wl_surface_destroy(pointer->cursor_wl_surface);
+
+    if (pointer->cursor)
+        wayland_cursor_destroy(pointer->cursor);
+
     memset(pointer, 0, sizeof(*pointer));
 }
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 29311fa8525..bcd401f6ca1 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -45,6 +45,7 @@ extern struct wl_display *process_wl_display;
 enum wayland_window_message
 {
     WM_WAYLAND_BROADCAST_DISPLAY_CHANGE = 0x80001000,
+    WM_WAYLAND_SET_CURSOR = 0x80001001,
 };
 
 enum wayland_surface_role
@@ -66,12 +67,25 @@ enum wayland_configure_flags
  *          Definitions for wayland types
  */
 
+struct wayland_surface;
+struct wayland_shm_buffer;
+
+struct wayland_cursor
+{
+    struct wayland_shm_buffer *shm_buffer;
+    int hotspot_x;
+    int hotspot_y;
+};
+
 struct wayland_pointer
 {
     struct wayland *wayland;
     struct wl_pointer *wl_pointer;
     struct wayland_surface *focused_surface;
+    struct wl_surface *cursor_wl_surface;
     uint32_t enter_serial;
+    struct wayland_cursor *cursor;
+    HCURSOR hcursor;
 };
 
 struct wayland
@@ -302,12 +316,18 @@ void wayland_window_surface_update_wayland_surface(struct window_surface *surfac
                                                    struct wayland_surface *wayland_surface);
 
 /**********************************************************************
- *          Wayland Pointer
+ *          Wayland Pointer/Cursor
  */
 
 void wayland_pointer_init(struct wayland_pointer *pointer, struct wayland *wayland,
                           struct wl_pointer *wl_pointer);
 void wayland_pointer_deinit(struct wayland_pointer *pointer);
+void wayland_cursor_destroy(struct wayland_cursor *wayland_cursor);
+void wayland_pointer_update_cursor_from_win32(struct wayland_pointer *pointer,
+                                              HCURSOR handle);
+BOOL wayland_init_set_cursor(void);
+HCURSOR wayland_invalidate_set_cursor(void);
+void wayland_set_cursor_if_current_invalid(HCURSOR hcursor);
 
 /**********************************************************************
  *          USER driver functions
@@ -318,6 +338,7 @@ extern void CDECL WAYLAND_DestroyWindow(HWND hwnd) DECLSPEC_HIDDEN;
 extern BOOL CDECL WAYLAND_EnumDisplaySettingsEx(LPCWSTR name, DWORD n, LPDEVMODEW devmode, DWORD flags) DECLSPEC_HIDDEN;
 extern DWORD CDECL WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
                                                        DWORD timeout, DWORD mask, DWORD flags) DECLSPEC_HIDDEN;
+extern void CDECL WAYLAND_SetCursor(HCURSOR hcursor) DECLSPEC_HIDDEN;
 extern void CDECL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
                                                BOOL force, void *param) DECLSPEC_HIDDEN;
 extern LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 9556e809769..d8ede04bf57 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -125,6 +125,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pDestroyWindow = WAYLAND_DestroyWindow,
     .pEnumDisplaySettingsEx = WAYLAND_EnumDisplaySettingsEx,
     .pMsgWaitForMultipleObjectsEx = WAYLAND_MsgWaitForMultipleObjectsEx,
+    .pSetCursor = WAYLAND_SetCursor,
     .pThreadDetach = WAYLAND_ThreadDetach,
     .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
     .pWindowMessage = WAYLAND_WindowMessage,
@@ -143,6 +144,8 @@ static BOOL process_attach(void)
 
     __wine_set_user_driver(&waylanddrv_funcs, WINE_GDI_DRIVER_VERSION);
 
+    if (!wayland_init_set_cursor()) return FALSE;
+
     if (!wayland_process_init()) return FALSE;
 
     /* All reads of wayland events happen from a dedicated thread. */
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 38c79e70a68..c5d672f5e64 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -442,6 +442,10 @@ LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
         SendMessageTimeoutW(HWND_BROADCAST, WM_DISPLAYCHANGE, wp, lp,
                             SMTO_ABORTIFHUNG, 2000, NULL);
         break;
+    case WM_WAYLAND_SET_CURSOR:
+        wayland_pointer_update_cursor_from_win32(&thread_wayland()->pointer,
+                                                 (HCURSOR)lp);
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp);
     }
-- 
2.34.1


From 2d4436c3e6d7efb58e63436afd91a944421ffc1f Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 6 Sep 2021 13:24:54 +0300
Subject: [PATCH 036/147] winewayland.drv: Basic handling of Wayland keyboard
 events.

Handle Wayland keyboard events and translate them to Windows events,
currently using a hardcoded US key mapping.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 configure                                     |  85 +++-
 configure.ac                                  |   6 +-
 dlls/winewayland.drv/Makefile.in              |   5 +-
 dlls/winewayland.drv/wayland.c                |  12 +
 dlls/winewayland.drv/wayland_keyboard.c       | 379 ++++++++++++++++++
 .../winewayland.drv/wayland_keyboard_layout.h | 287 +++++++++++++
 dlls/winewayland.drv/wayland_surface.c        |   4 +
 dlls/winewayland.drv/waylanddrv.h             |  29 ++
 dlls/winewayland.drv/window.c                 |   9 +
 include/config.h.in                           |   3 +
 10 files changed, 815 insertions(+), 4 deletions(-)
 create mode 100644 dlls/winewayland.drv/wayland_keyboard.c
 create mode 100644 dlls/winewayland.drv/wayland_keyboard_layout.h

diff --git a/configure.ac b/configure.ac
index 95865edf813..4dc9faed3d3 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1335,10 +1335,14 @@ then
                    `$PKG_CONFIG --atleast-version=1.14 wayland-protocols && $PKG_CONFIG --variable=pkgdatadir wayland-protocols`)])
     AC_PATH_PROG(WAYLAND_SCANNER,wayland-scanner,
                  [`$PKG_CONFIG --variable=wayland_scanner wayland-scanner`])
+    WINE_PACKAGE_FLAGS(XKBCOMMON,[xkbcommon],,,,
+        [AC_CHECK_HEADERS([xkbcommon/xkbcommon.h])
+         AC_CHECK_LIB(xkbcommon,xkb_context_new,[:],[XKBCOMMON_LIBS=""],[$XKBCOMMON_LIBS])])
 fi
 WINE_NOTICE_WITH(wayland, [test -z "$WAYLAND_CLIENT_LIBS" ||
                            test -z "$WAYLAND_PROTOCOLS_DATADIR" ||
-                           test -z "$WAYLAND_SCANNER"],
+                           test -z "$WAYLAND_SCANNER" ||
+                           test -z "$XKBCOMMON_LIBS"],
                  [Wayland ${notice_platform}development files not found or not new enough, the Wayland driver won't be supported.],
                  [enable_winewayland_drv])
 
diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index d28694cb3d6..6b87e9897f3 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,7 +1,7 @@
 MODULE    = winewayland.drv
 IMPORTS   = advapi32 gdi32 user32 win32u
-EXTRAINCL = $(WAYLAND_CLIENT_CFLAGS)
-EXTRALIBS = $(WAYLAND_CLIENT_LIBS)
+EXTRAINCL = $(WAYLAND_CLIENT_CFLAGS) $(XKBCOMMON_CFLAGS)
+EXTRALIBS = $(WAYLAND_CLIENT_LIBS) $(XKBCOMMON_LIBS)
 CFLAGS = -std=c11 -Wno-declaration-after-statement
 EXTRACFLAGS = -std=c11 -Wno-declaration-after-statement
 CPPFLAGS = -std=c11 -Wno-declaration-after-statement
@@ -16,6 +16,7 @@ C_SRCS = \
 	waylanddrv_main.c \
 	wayland_buffer_queue.c \
 	wayland_cursor.c \
+	wayland_keyboard.c \
 	wayland_pointer.c \
 	wayland_shm.c \
 	wayland_surface.c \
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index c9c78f117fa..421142b92c1 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -88,6 +88,15 @@ static void seat_handle_capabilities(void *data, struct wl_seat *seat,
     {
         wayland_pointer_deinit(&wayland->pointer);
     }
+
+    if ((caps & WL_SEAT_CAPABILITY_KEYBOARD) && !wayland->keyboard.wl_keyboard)
+    {
+        wayland_keyboard_init(&wayland->keyboard, wayland, wl_seat_get_keyboard(seat));
+    }
+    else if (!(caps & WL_SEAT_CAPABILITY_KEYBOARD) && wayland->keyboard.wl_keyboard)
+    {
+        wayland_keyboard_deinit(&wayland->keyboard);
+    }
 }
 
 static void seat_handle_name(void *data, struct wl_seat *seat, const char *name)
@@ -291,6 +300,9 @@ void wayland_deinit(struct wayland *wayland)
     if (wayland->pointer.wl_pointer)
         wayland_pointer_deinit(&wayland->pointer);
 
+    if (wayland->keyboard.wl_keyboard)
+        wayland_keyboard_deinit(&wayland->keyboard);
+
     if (wayland->wl_seat)
         wl_seat_destroy(wayland->wl_seat);
 
diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
new file mode 100644
index 00000000000..de03e0a71bd
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -0,0 +1,379 @@
+/*
+ * Keyboard related functions
+ *
+ * Copyright 1993 Bob Amstadt
+ * Copyright 1996 Albrecht Kleine
+ * Copyright 1997 David Faure
+ * Copyright 1998 Morten Welinder
+ * Copyright 1998 Ulrich Weigand
+ * Copyright 1999 Ove Kven
+ * Copyright 2011, 2012, 2013 Ken Thomases for CodeWeavers Inc.
+ * Copyright 2013 Alexandre Julliard
+ * Copyright 2015 Josh DuBois for CodeWeavers Inc.
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define NONAMELESSUNION
+#define NONAMELESSSTRUCT
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "winuser.h"
+
+#include <unistd.h>
+
+#include "wayland_keyboard_layout.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(keyboard);
+WINE_DECLARE_DEBUG_CHANNEL(key);
+
+static DWORD _xkb_keycode_to_scancode(struct wayland_keyboard *keyboard,
+                                      xkb_keycode_t xkb_keycode)
+{
+    /* Use linux input keycode as scan code for now. */
+    return xkb_keycode - 8;
+}
+
+static UINT _xkb_keycode_to_vkey(struct wayland_keyboard *keyboard,
+                                 xkb_keycode_t xkb_keycode)
+{
+    return xkb_keycode < ARRAY_SIZE(xkb_keycode_to_vkey_us) ?
+           xkb_keycode_to_vkey_us[xkb_keycode] : 0;
+}
+
+/* xkb keycodes are offset by 8 from linux input keycodes. */
+static inline xkb_keycode_t linux_input_keycode_to_xkb(uint32_t key)
+{
+    return key + 8;
+}
+
+static void send_keyboard_input(HWND hwnd, WORD vkey, WORD scan, DWORD flags)
+{
+    INPUT input;
+
+    input.type             = INPUT_KEYBOARD;
+    input.u.ki.wVk         = vkey;
+    input.u.ki.wScan       = scan;
+    input.u.ki.dwFlags     = flags;
+    input.u.ki.time        = 0;
+    input.u.ki.dwExtraInfo = 0;
+
+    __wine_send_input(hwnd, &input, NULL);
+}
+
+/* Get the vkey corresponding to an xkb keycode, potentially translating it to
+ * take into account the current keyboard state. */
+static UINT translate_xkb_keycode_to_vkey(struct wayland_keyboard *keyboard,
+                                          xkb_keycode_t xkb_keycode)
+{
+    UINT vkey = _xkb_keycode_to_vkey(keyboard, xkb_keycode);
+
+    if (((vkey >= VK_NUMPAD0 && vkey <= VK_NUMPAD9) ||
+          vkey == VK_SEPARATOR || vkey == VK_DECIMAL) &&
+        !xkb_state_mod_name_is_active(keyboard->xkb_state, XKB_MOD_NAME_NUM,
+                                      XKB_STATE_MODS_EFFECTIVE))
+    {
+        switch (vkey)
+        {
+        case VK_NUMPAD0: vkey = VK_INSERT; break;
+        case VK_NUMPAD1: vkey = VK_END; break;
+        case VK_NUMPAD2: vkey = VK_DOWN; break;
+        case VK_NUMPAD3: vkey = VK_NEXT; break;
+        case VK_NUMPAD4: vkey = VK_LEFT; break;
+        case VK_NUMPAD5: vkey = 0; break;
+        case VK_NUMPAD6: vkey = VK_RIGHT; break;
+        case VK_NUMPAD7: vkey = VK_HOME; break;
+        case VK_NUMPAD8: vkey = VK_UP; break;
+        case VK_NUMPAD9: vkey = VK_PRIOR; break;
+        case VK_SEPARATOR: vkey = VK_DELETE; break;
+        case VK_DECIMAL: vkey = VK_DELETE; break;
+        default: break;
+        }
+    }
+    else if (vkey == VK_PAUSE &&
+             xkb_state_mod_name_is_active(keyboard->xkb_state,
+                                          XKB_MOD_NAME_CTRL,
+                                          XKB_STATE_MODS_EFFECTIVE))
+    {
+        vkey = VK_CANCEL;
+    }
+
+    return vkey;
+}
+
+static void wayland_keyboard_emit(struct wayland_keyboard *keyboard, uint32_t key,
+                                  uint32_t state, HWND hwnd)
+{
+    xkb_keycode_t xkb_keycode = linux_input_keycode_to_xkb(key);
+    UINT vkey = translate_xkb_keycode_to_vkey(keyboard, xkb_keycode);
+    UINT scan = _xkb_keycode_to_scancode(keyboard, xkb_keycode);
+    DWORD flags;
+
+    TRACE_(key)("xkb_keycode=%u vkey=0x%x scan=0x%x state=%d hwnd=%p\n",
+                xkb_keycode, vkey, scan, state, hwnd);
+
+    if (vkey == 0) return;
+
+    flags = 0;
+    if (state == WL_KEYBOARD_KEY_STATE_RELEASED) flags |= KEYEVENTF_KEYUP;
+    if (scan & 0x100) flags |= KEYEVENTF_EXTENDEDKEY;
+
+    send_keyboard_input(hwnd, vkey, scan & 0xff, flags);
+}
+
+/**********************************************************************
+ *          Keyboard handling
+ */
+
+static void keyboard_handle_keymap(void *data, struct wl_keyboard *keyboard,
+                                   uint32_t format, int fd, uint32_t size)
+{
+    close(fd);
+}
+
+static BOOL wayland_surface_for_window_is_mapped(HWND hwnd)
+{
+    DWORD_PTR res;
+
+    if (!hwnd) return FALSE;
+
+    if (!SendMessageTimeoutW(hwnd, WM_WAYLAND_QUERY_SURFACE_MAPPED,
+                             0, 0, SMTO_BLOCK, 50, &res))
+    {
+        return FALSE;
+    }
+
+    return res;
+}
+
+static void keyboard_handle_enter(void *data, struct wl_keyboard *keyboard,
+                                  uint32_t serial, struct wl_surface *surface,
+                                  struct wl_array *keys)
+{
+    struct wayland *wayland = data;
+    struct wayland_surface *wayland_surface =
+        surface ? wl_surface_get_user_data(surface) : NULL;
+
+    /* Since keyboard events can arrive in multiple threads, ensure we only
+     * handle them in the thread that owns the surface, to avoid passing
+     * duplicate events to Wine. */
+    if (wayland_surface && wayland_surface->hwnd &&
+        wayland_surface->wayland == wayland)
+    {
+        HWND foreground = GetForegroundWindow();
+        BOOL foreground_is_mapped;
+
+        if (foreground == GetDesktopWindow()) foreground = NULL;
+        foreground_is_mapped = wayland_surface_for_window_is_mapped(foreground);
+
+        TRACE("surface=%p hwnd=%p foreground=%p foreground_is_mapped=%d\n",
+              wayland_surface, wayland_surface->hwnd, foreground,
+              foreground_is_mapped);
+
+        wayland->keyboard.focused_surface = wayland_surface;
+        wayland->keyboard.enter_serial = serial;
+
+        /* If the foreground window is not mapped, it may not have had the
+         * chance to acquire the keyboard focus. If we change the foreground
+         * window now, we may cause side effects, e.g., some fullscreen games
+         * minimize if they lose focus. To avoid such side effects, err on the
+         * side of maintaining the Wine foreground state, with the expectation
+         * that the current foreground window will eventually also gain the
+         * Wayland keyboard focus. */
+        if (!foreground || foreground_is_mapped)
+        {
+            struct wayland_surface *toplevel = wayland_surface;
+            while (toplevel->parent) toplevel = toplevel->parent;
+            SetForegroundWindow(toplevel->hwnd);
+        }
+    }
+}
+
+static void CALLBACK maybe_unset_from_foreground(HWND hwnd, UINT msg,
+                                                 UINT_PTR timer_id,
+                                                 DWORD elapsed)
+{
+    struct wayland *wayland = thread_wayland();
+
+    TRACE("wayland=%p hwnd=%p\n", wayland, hwnd);
+
+    /* If no enter events have arrived since the previous leave event,
+     * the loss of focus was likely not transient, so drop the foreground state.
+     * We only drop the foreground state if it's ours to drop, i.e., some
+     * other window hasn't become foreground in the meantime. */
+    if (!wayland->keyboard.focused_surface && GetForegroundWindow() == hwnd)
+        SetForegroundWindow(GetDesktopWindow());
+
+    KillTimer(hwnd, timer_id);
+}
+
+static void keyboard_handle_leave(void *data, struct wl_keyboard *keyboard,
+        uint32_t serial, struct wl_surface *surface)
+{
+    struct wayland *wayland = data;
+    struct wayland_surface *focused_surface = wayland->keyboard.focused_surface;
+
+    if (focused_surface && focused_surface->wl_surface == surface)
+    {
+        TRACE("surface=%p hwnd=%p\n", focused_surface, focused_surface->hwnd);
+        KillTimer(focused_surface->hwnd, (UINT_PTR)keyboard);
+        /* This leave event may not signify a real loss of focus for the
+         * window. Such a case occurs when the focus changes from the main
+         * surface to a subsurface. Don't be too eager to lose the foreground
+         * state in such cases, as some fullscreen applications may become
+         * minimized. Instead wait a bit in case other enter events targeting a
+         * (sub)surface of the same HWND arrive soon after. */
+        SetTimer(focused_surface->hwnd,
+                 (UINT_PTR)&wayland->keyboard.focused_surface, 50,
+                 maybe_unset_from_foreground);
+        wayland->keyboard.focused_surface = NULL;
+        wayland->keyboard.enter_serial = 0;
+    }
+}
+
+static void CALLBACK repeat_key(HWND hwnd, UINT msg, UINT_PTR timer_id, DWORD elapsed)
+{
+    struct wayland *wayland = thread_wayland();
+
+    if (wayland->keyboard.repeat_interval_ms > 0)
+    {
+        wayland_keyboard_emit(&wayland->keyboard, wayland->keyboard.pressed_key,
+                              WL_KEYBOARD_KEY_STATE_PRESSED, hwnd);
+
+        SetTimer(hwnd, timer_id, wayland->keyboard.repeat_interval_ms,
+                 repeat_key);
+    }
+}
+
+static void keyboard_handle_key(void *data, struct wl_keyboard *keyboard,
+                                uint32_t serial, uint32_t time, uint32_t key,
+                                uint32_t state)
+{
+    struct wayland *wayland = data;
+    HWND focused_hwnd = wayland->keyboard.focused_surface ?
+                        wayland->keyboard.focused_surface->hwnd : 0;
+    UINT_PTR repeat_key_timer_id = (UINT_PTR)keyboard;
+
+    if (!focused_hwnd)
+        return;
+
+    TRACE("key=%d state=%#x focused_hwnd=%p\n", key, state, focused_hwnd);
+
+    wayland->last_dispatch_mask |= QS_KEY | QS_HOTKEY;
+
+    wayland_keyboard_emit(&wayland->keyboard, key, state, focused_hwnd);
+
+    if (state == WL_KEYBOARD_KEY_STATE_PRESSED)
+    {
+        wayland->keyboard.pressed_key = key;
+        if (wayland->keyboard.repeat_interval_ms > 0)
+        {
+            SetTimer(focused_hwnd, repeat_key_timer_id, wayland->keyboard.repeat_delay_ms,
+                     repeat_key);
+        }
+    }
+    else
+    {
+        wayland->keyboard.pressed_key = 0;
+        KillTimer(focused_hwnd, repeat_key_timer_id);
+    }
+}
+
+static void keyboard_handle_modifiers(void *data, struct wl_keyboard *keyboard,
+                                      uint32_t serial, uint32_t mods_depressed,
+                                      uint32_t mods_latched, uint32_t mods_locked,
+                                      uint32_t group)
+{
+    struct wayland *wayland = data;
+
+    TRACE("depressed=0x%x latched=0x%x locked=0x%x group=%d\n",
+          mods_depressed, mods_latched, mods_locked, group);
+
+    if (!wayland->keyboard.xkb_state) return;
+
+    xkb_state_update_mask(wayland->keyboard.xkb_state,
+                          mods_depressed, mods_latched, mods_locked, 0, 0, group);
+}
+
+static void keyboard_handle_repeat_info(void *data, struct wl_keyboard *keyboard,
+                                        int rate, int delay)
+{
+    struct wayland *wayland = data;
+
+    TRACE("rate=%d delay=%d\n", rate, delay);
+
+    /* Handle non-negative rate values, ignore invalid (negative) values.  A
+     * rate of 0 disables repeat. Note that a requested rate value larger than
+     * 100 may not actually lead to the desired repeat rate, since we are
+     * constrained by the USER_TIMER_MINIMUM (=10ms) resolution of win32
+     * timers. */
+    if (rate > 1000)
+        wayland->keyboard.repeat_interval_ms = 1;
+    else if (rate > 0)
+        wayland->keyboard.repeat_interval_ms = 1000 / rate;
+    else if (rate == 0)
+        wayland->keyboard.repeat_interval_ms = 0;
+
+    wayland->keyboard.repeat_delay_ms = delay;
+}
+
+static const struct wl_keyboard_listener keyboard_listener = {
+    keyboard_handle_keymap,
+    keyboard_handle_enter,
+    keyboard_handle_leave,
+    keyboard_handle_key,
+    keyboard_handle_modifiers,
+    keyboard_handle_repeat_info,
+};
+
+/***********************************************************************
+ *           wayland_keyboard_init
+ */
+void wayland_keyboard_init(struct wayland_keyboard *keyboard, struct wayland *wayland,
+                           struct wl_keyboard *wl_keyboard)
+{
+    keyboard->wl_keyboard = wl_keyboard;
+    /* Some sensible default values for the repeat rate and delay. */
+    keyboard->repeat_interval_ms = 40;
+    keyboard->repeat_delay_ms = 400;
+    keyboard->xkb_context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);
+    if (!keyboard->xkb_context)
+    {
+        ERR("Failed to create XKB context\n");
+        return;
+    }
+
+    wl_keyboard_add_listener(keyboard->wl_keyboard, &keyboard_listener, wayland);
+}
+
+/***********************************************************************
+ *           wayland_keyboard_deinit
+ */
+void wayland_keyboard_deinit(struct wayland_keyboard *keyboard)
+{
+    if (keyboard->wl_keyboard)
+        wl_keyboard_destroy(keyboard->wl_keyboard);
+
+    xkb_state_unref(keyboard->xkb_state);
+    xkb_context_unref(keyboard->xkb_context);
+
+    memset(keyboard, 0, sizeof(*keyboard));
+}
diff --git a/dlls/winewayland.drv/wayland_keyboard_layout.h b/dlls/winewayland.drv/wayland_keyboard_layout.h
new file mode 100644
index 00000000000..58a14aac378
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_keyboard_layout.h
@@ -0,0 +1,287 @@
+/*
+ * Wayland keyboard driver layouts, adapted from X11 driver.
+ *
+ * This header file contains the tables used by keyboard_layout.c
+ * to perform layout mapping.
+ *
+ * Copyright 1993 Bob Amstadt
+ * Copyright 1996 Albrecht Kleine
+ * Copyright 1997 David Faure
+ * Copyright 1998 Morten Welinder
+ * Copyright 1998 Ulrich Weigand
+ * Copyright 1999 Ove Kven
+ * Copyright 2021 Alexandros Frantzis
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_WAYLANDDRV_WAYLAND_KEYBOARD_LAYOUT_H
+#define __WINE_WAYLANDDRV_WAYLAND_KEYBOARD_LAYOUT_H
+
+static const UINT xkb_keycode_to_vkey_us[] =
+{
+    0, 0, 0, 0, 0, 0, 0, 0,
+    0,                   /* KEY_RESERVED  0 */
+    VK_ESCAPE,           /* KEY_ESC   1 */
+    '1',                 /* KEY_1   2 */
+    '2',                 /* KEY_2   3 */
+    '3',                 /* KEY_3   4 */
+    '4',                 /* KEY_4   5 */
+    '5',                 /* KEY_5   6 */
+    '6',                 /* KEY_6   7 */
+    '7',                 /* KEY_7   8 */
+    '8',                 /* KEY_8   9 */
+    '9',                 /* KEY_9   10 */
+    '0',                 /* KEY_0   11 */
+    VK_OEM_MINUS,        /* KEY_MINUS  12 */
+    VK_OEM_PLUS,         /* KEY_EQUAL  13 */
+    VK_BACK,             /* KEY_BACKSPACE 14 */
+    VK_TAB,              /* KEY_TAB   15 */
+    'Q',                 /* KEY_Q   16 */
+    'W',                 /* KEY_W   17 */
+    'E',                 /* KEY_E   18 */
+    'R',                 /* KEY_R   19 */
+    'T',                 /* KEY_T   20 */
+    'Y',                 /* KEY_Y   21 */
+    'U',                 /* KEY_U   22 */
+    'I',                 /* KEY_I   23 */
+    'O',                 /* KEY_O   24 */
+    'P',                 /* KEY_P   25 */
+    VK_OEM_4,            /* KEY_LEFTBRACE  26 */
+    VK_OEM_6,            /* KEY_RIGHTBRACE  27 */
+    VK_RETURN,           /* KEY_ENTER  28 */
+    VK_LCONTROL,         /* KEY_LEFTCTRL  29 */
+    'A',                 /* KEY_A   30 */
+    'S',                 /* KEY_S   31 */
+    'D',                 /* KEY_D   32 */
+    'F',                 /* KEY_F   33 */
+    'G',                 /* KEY_G   34 */
+    'H',                 /* KEY_H   35 */
+    'J',                 /* KEY_J   36 */
+    'K',                 /* KEY_K   37 */
+    'L',                 /* KEY_L   38 */
+    VK_OEM_1,            /* KEY_SEMICOLON  39 */
+    VK_OEM_7,            /* KEY_APOSTROPHE  40 */
+    VK_OEM_3,            /* KEY_GRAVE  41 */
+    VK_LSHIFT,           /* KEY_LEFTSHIFT  42 */
+    VK_OEM_5,            /* KEY_BACKSLASH  43 */
+    'Z',                 /* KEY_Z   44 */
+    'X',                 /* KEY_X   45 */
+    'C',                 /* KEY_C   46 */
+    'V',                 /* KEY_V   47 */
+    'B',                 /* KEY_B   48 */
+    'N',                 /* KEY_N   49 */
+    'M',                 /* KEY_M   50 */
+    VK_OEM_COMMA,        /* KEY_COMMA  51 */
+    VK_OEM_PERIOD,       /* KEY_DOT   52 */
+    VK_OEM_2,            /* KEY_SLASH  53 */
+    VK_RSHIFT,           /* KEY_RIGHTSHIFT  54 */
+    VK_MULTIPLY,         /* KEY_KPASTERISK  55 */
+    VK_LMENU,            /* KEY_LEFTALT  56 */
+    VK_SPACE,            /* KEY_SPACE  57 */
+    VK_CAPITAL,          /* KEY_CAPSLOCK  58 */
+    VK_F1,               /* KEY_F1   59 */
+    VK_F2,               /* KEY_F2   60 */
+    VK_F3,               /* KEY_F3   61 */
+    VK_F4,               /* KEY_F4   62 */
+    VK_F5,               /* KEY_F5   63 */
+    VK_F6,               /* KEY_F6   64 */
+    VK_F7,               /* KEY_F7   65 */
+    VK_F8,               /* KEY_F8   66 */
+    VK_F9,               /* KEY_F9   67 */
+    VK_F10,              /* KEY_F10   68 */
+    VK_NUMLOCK,          /* KEY_NUMLOCK  69 */
+    VK_SCROLL,           /* KEY_SCROLLLOCK  70 */
+    VK_NUMPAD7,          /* KEY_KP7   71 */
+    VK_NUMPAD8,          /* KEY_KP8   72 */
+    VK_NUMPAD9,          /* KEY_KP9   73 */
+    VK_SUBTRACT,         /* KEY_KPMINUS  74 */
+    VK_NUMPAD4,          /* KEY_KP4   75 */
+    VK_NUMPAD5,          /* KEY_KP5   76 */
+    VK_NUMPAD6,          /* KEY_KP6   77 */
+    VK_ADD,              /* KEY_KPPLUS  78 */
+    VK_NUMPAD1,          /* KEY_KP1   79 */
+    VK_NUMPAD2,          /* KEY_KP2   80 */
+    VK_NUMPAD3,          /* KEY_KP3   81 */
+    VK_NUMPAD0,          /* KEY_KP0   82 */
+    VK_DECIMAL,          /* KEY_KPDOT  83 */
+    0,                   /* 84 */
+    0,                   /* KEY_ZENKAKUHANKAKU 85 */
+    VK_OEM_102,          /* KEY_102ND  86 */
+    VK_F11,              /* KEY_F11   87 */
+    VK_F12,              /* KEY_F12   88 */
+    0,                   /* KEY_RO   89 */
+    0,                   /* KEY_KATAKANA  90 */
+    0,                   /* KEY_HIRAGANA  91 */
+    0,                   /* KEY_HENKAN  92 */
+    0,                   /* KEY_KATAKANAHIRAGANA 93 */
+    0,                   /* KEY_MUHENKAN  94 */
+    0,                   /* KEY_KPJPCOMMA  95 */
+    VK_RETURN,           /* KEY_KPENTER  96 */
+    VK_RCONTROL,         /* KEY_RIGHTCTRL  97 */
+    VK_DIVIDE,           /* KEY_KPSLASH  98 */
+    VK_SNAPSHOT,         /* KEY_SYSRQ  99 */
+    VK_RMENU,            /* KEY_RIGHTALT  100 */
+    0,                   /* KEY_LINEFEED  101 */
+    VK_HOME,             /* KEY_HOME  102 */
+    VK_UP,               /* KEY_UP   103 */
+    VK_PRIOR,            /* KEY_PAGEUP  104 */
+    VK_LEFT,             /* KEY_LEFT  105 */
+    VK_RIGHT,            /* KEY_RIGHT  106 */
+    VK_END,              /* KEY_END   107 */
+    VK_DOWN,             /* KEY_DOWN  108 */
+    VK_NEXT,             /* KEY_PAGEDOWN  109 */
+    VK_INSERT,           /* KEY_INSERT  110 */
+    VK_DELETE,           /* KEY_DELETE  111 */
+    0,                   /* KEY_MACRO  112 */
+    VK_VOLUME_MUTE,      /* KEY_MUTE  113 */
+    VK_VOLUME_DOWN,      /* KEY_VOLUMEDOWN  114 */
+    VK_VOLUME_UP,        /* KEY_VOLUMEUP  115 */
+    0,                   /* KEY_POWER  116  */
+    0,                   /* KEY_KPEQUAL  117 */
+    0,                   /* KEY_KPPLUSMINUS  118 */
+    VK_PAUSE,            /* KEY_PAUSE  119 */
+    0,                   /* KEY_SCALE  120  */
+    0,                   /* KEY_KPCOMMA  121 */
+    0,                   /* KEY_HANGEUL  122 */
+    0,                   /* KEY_HANJA  123 */
+    0,                   /* KEY_YEN   124 */
+    VK_LWIN,             /* KEY_LEFTMETA  125 */
+    VK_RWIN,             /* KEY_RIGHTMETA  126 */
+    0,                   /* KEY_COMPOSE  127 */
+    0,                   /* KEY_STOP  128  */
+    0,                   /* KEY_AGAIN  129 */
+    0,                   /* KEY_PROPS  130  */
+    0,                   /* KEY_UNDO  131  */
+    0,                   /* KEY_FRONT  132 */
+    0,                   /* KEY_COPY  133  */
+    0,                   /* KEY_OPEN  134  */
+    0,                   /* KEY_PASTE  135  */
+    0,                   /* KEY_FIND  136  */
+    0,                   /* KEY_CUT   137  */
+    0,                   /* KEY_HELP  138  */
+    0,                   /* KEY_MENU  139  */
+    0,                   /* KEY_CALC  140  */
+    0,                   /* KEY_SETUP  141 */
+    0,                   /* KEY_SLEEP  142  */
+    0,                   /* KEY_WAKEUP  143  */
+    0,                   /* KEY_FILE  144  */
+    0,                   /* KEY_SENDFILE  145 */
+    0,                   /* KEY_DELETEFILE  146 */
+    0,                   /* KEY_XFER  147 */
+    0,                   /* KEY_PROG1  148 */
+    0,                   /* KEY_PROG2  149 */
+    0,                   /* KEY_WWW   150  */
+    0,                   /* KEY_MSDOS  151 */
+    0,                   /* KEY_COFFEE  152 */
+    0,                   /* KEY_ROTATE_DISPLAY 153  */
+    0,                   /* KEY_CYCLEWINDOWS 154 */
+    0,                   /* KEY_MAIL  155 */
+    0,                   /* KEY_BOOKMARKS  156  */
+    0,                   /* KEY_COMPUTER  157 */
+    0,                   /* KEY_BACK  158  */
+    0,                   /* KEY_FORWARD  159  */
+    0,                   /* KEY_CLOSECD  160 */
+    0,                   /* KEY_EJECTCD  161 */
+    0,                   /* KEY_EJECTCLOSECD 162 */
+    VK_MEDIA_NEXT_TRACK, /* KEY_NEXTSONG  163 */
+    VK_MEDIA_PLAY_PAUSE, /* KEY_PLAYPAUSE  164 */
+    VK_MEDIA_PREV_TRACK, /* KEY_PREVIOUSSONG 165 */
+    0,                   /* KEY_STOPCD  166 */
+    0,                   /* KEY_RECORD  167 */
+    0,                   /* KEY_REWIND  168 */
+    0,                   /* KEY_PHONE  169  */
+    0,                   /* KEY_ISO   170 */
+    0,                   /* KEY_CONFIG  171  */
+    0,                   /* KEY_HOMEPAGE  172  */
+    0,                   /* KEY_REFRESH  173  */
+    0,                   /* KEY_EXIT  174  */
+    0,                   /* KEY_MOVE  175 */
+    0,                   /* KEY_EDIT  176 */
+    0,                   /* KEY_SCROLLUP  177 */
+    0,                   /* KEY_SCROLLDOWN  178 */
+    0,                   /* KEY_KPLEFTPAREN  179 */
+    0,                   /* KEY_KPRIGHTPAREN 180 */
+    0,                   /* KEY_NEW   181  */
+    0,                   /* KEY_REDO  182  */
+    VK_F13,              /* KEY_F13   183 */
+    VK_F14,              /* KEY_F14   184 */
+    VK_F15,              /* KEY_F15   185 */
+    VK_F16,              /* KEY_F16   186 */
+    VK_F17,              /* KEY_F17   187 */
+    VK_F18,              /* KEY_F18   188 */
+    VK_F19,              /* KEY_F19   189 */
+    VK_F20,              /* KEY_F20   190 */
+    VK_F21,              /* KEY_F21   191 */
+    VK_F22,              /* KEY_F22   192 */
+    VK_F23,              /* KEY_F23   193 */
+    VK_F24,              /* KEY_F24   194 */
+    0,                   /* 195 */
+    0,                   /* 196 */
+    0,                   /* 197 */
+    0,                   /* 198 */
+    0,                   /* 199 */
+    0,                   /* KEY_PLAYCD  200 */
+    0,                   /* KEY_PAUSECD  201 */
+    0,                   /* KEY_PROG3  202 */
+    0,                   /* KEY_PROG4  203 */
+    0,                   /* KEY_DASHBOARD  204  */
+    0,                   /* KEY_SUSPEND  205 */
+    0,                   /* KEY_CLOSE  206  */
+    VK_PLAY,             /* KEY_PLAY  207 */
+    0,                   /* KEY_FASTFORWARD  208 */
+    0,                   /* KEY_BASSBOOST  209 */
+    VK_PRINT,            /* KEY_PRINT  210  */
+    0,                   /* KEY_HP   211 */
+    0,                   /* KEY_CAMERA  212 */
+    0,                   /* KEY_SOUND  213 */
+    0,                   /* KEY_QUESTION  214  */
+    0,                   /* KEY_EMAIL  215 */
+    0,                   /* KEY_CHAT  216 */
+    0,                   /* KEY_SEARCH  217 */
+    0,                   /* KEY_CONNECT  218 */
+    0,                   /* KEY_FINANCE  219  */
+    0,                   /* KEY_SPORT  220 */
+    0,                   /* KEY_SHOP  221 */
+    0,                   /* KEY_ALTERASE  222 */
+    0,                   /* KEY_CANCEL  223  */
+    0,                   /* KEY_BRIGHTNESSDOWN 224 */
+    0,                   /* KEY_BRIGHTNESSUP 225 */
+    0,                   /* KEY_MEDIA  226 */
+    0,                   /* KEY_SWITCHVIDEOMODE 227  */
+    0,                   /* KEY_KBDILLUMTOGGLE 228 */
+    0,                   /* KEY_KBDILLUMDOWN 229 */
+    0,                   /* KEY_KBDILLUMUP  230 */
+    0,                   /* KEY_SEND  231  */
+    0,                   /* KEY_REPLY  232  */
+    0,                   /* KEY_FORWARDMAIL  233  */
+    0,                   /* KEY_SAVE  234  */
+    0,                   /* KEY_DOCUMENTS  235 */
+    0,                   /* KEY_BATTERY  236 */
+    0,                   /* KEY_BLUETOOTH  237 */
+    0,                   /* KEY_WLAN  238 */
+    0,                   /* KEY_UWB   239  */
+    0,                   /* KEY_UNKNOWN  240 */
+    0,                   /* KEY_VIDEO_NEXT  241  */
+    0,                   /* KEY_VIDEO_PREV  242  */
+    0,                   /* KEY_BRIGHTNESS_CYCLE 243  */
+    0,                   /* KEY_BRIGHTNESS_AUTO/ZERO 244 */
+    0,                   /* KEY_DISPLAY_OFF  245  */
+    0,                   /* KEY_WWAN  246  */
+    0,                   /* KEY_RFKILL  247  */
+    0,                   /* KEY_MICMUTE  248  */
+};
+
+#endif /* __WINE_WAYLANDDRV_WAYLAND_KEYBOARD_LAYOUT_H */
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 804798721b2..40535d8be58 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -397,12 +397,16 @@ BOOL wayland_surface_commit_buffer(struct wayland_surface *surface,
 void wayland_surface_destroy(struct wayland_surface *surface)
 {
     struct wayland_pointer *pointer = &surface->wayland->pointer;
+    struct wayland_keyboard *keyboard = &surface->wayland->keyboard;
 
     TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
 
     if (pointer->focused_surface == surface)
         pointer->focused_surface = NULL;
 
+    if (keyboard->focused_surface == surface)
+        keyboard->focused_surface = NULL;
+
     if (surface->xdg_toplevel)
     {
         xdg_toplevel_destroy(surface->xdg_toplevel);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index bcd401f6ca1..bf3f6cc86b1 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -27,6 +27,7 @@
 
 #include <stdarg.h>
 #include <wayland-client.h>
+#include <xkbcommon/xkbcommon.h>
 #include "xdg-output-unstable-v1-client-protocol.h"
 #include "xdg-shell-client-protocol.h"
 
@@ -46,6 +47,7 @@ enum wayland_window_message
 {
     WM_WAYLAND_BROADCAST_DISPLAY_CHANGE = 0x80001000,
     WM_WAYLAND_SET_CURSOR = 0x80001001,
+    WM_WAYLAND_QUERY_SURFACE_MAPPED = 0x80001002,
 };
 
 enum wayland_surface_role
@@ -70,6 +72,18 @@ enum wayland_configure_flags
 struct wayland_surface;
 struct wayland_shm_buffer;
 
+struct wayland_keyboard
+{
+    struct wl_keyboard *wl_keyboard;
+    struct wayland_surface *focused_surface;
+    int repeat_interval_ms;
+    int repeat_delay_ms;
+    uint32_t pressed_key;
+    uint32_t enter_serial;
+    struct xkb_context *xkb_context;
+    struct xkb_state *xkb_state;
+};
+
 struct wayland_cursor
 {
     struct wayland_shm_buffer *shm_buffer;
@@ -105,6 +119,7 @@ struct wayland
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t next_fallback_output_id;
     struct wl_list output_list;
+    struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
     DWORD last_dispatch_mask;
     int event_notification_pipe[2];
@@ -315,6 +330,14 @@ BOOL wayland_window_surface_needs_flush(struct window_surface *surface);
 void wayland_window_surface_update_wayland_surface(struct window_surface *surface,
                                                    struct wayland_surface *wayland_surface);
 
+/**********************************************************************
+ *          Wayland Keyboard
+ */
+
+void wayland_keyboard_init(struct wayland_keyboard *keyboard, struct wayland *wayland,
+                           struct wl_keyboard *wl_keyboard);
+void wayland_keyboard_deinit(struct wayland_keyboard *keyboard);
+
 /**********************************************************************
  *          Wayland Pointer/Cursor
  */
@@ -329,6 +352,12 @@ BOOL wayland_init_set_cursor(void);
 HCURSOR wayland_invalidate_set_cursor(void);
 void wayland_set_cursor_if_current_invalid(HCURSOR hcursor);
 
+/**********************************************************************
+ *          XKB helpers
+ */
+xkb_layout_index_t _xkb_state_get_active_layout(struct xkb_state *xkb_state);
+int _xkb_keysyms_to_utf8(const xkb_keysym_t *syms, int nsyms, char *utf8, int utf8_size);
+
 /**********************************************************************
  *          USER driver functions
  */
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index c5d672f5e64..f69cfb0ce8b 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -446,6 +446,15 @@ LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
         wayland_pointer_update_cursor_from_win32(&thread_wayland()->pointer,
                                                  (HCURSOR)lp);
         break;
+    case WM_WAYLAND_QUERY_SURFACE_MAPPED:
+        {
+            LRESULT res;
+            struct wayland_surface *wayland_surface = wayland_surface_for_hwnd_lock(hwnd);
+            res = wayland_surface ? wayland_surface->mapped : 0;
+            wayland_surface_for_hwnd_unlock(wayland_surface);
+            return res;
+        }
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp);
     }
diff --git a/include/config.h.in b/include/config.h.in
index 24286070d82..ba4cd3620a9 100644
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -754,6 +754,9 @@
 /* Define if you have the XKB extension */
 #undef HAVE_XKB
 
+/* Define to 1 if you have the <xkbcommon/xkbcommon.h> header file. */
+#undef HAVE_XKBCOMMON_XKBCOMMON_H
+
 /* Define if Xrender has the XRenderCreateLinearGradient function */
 #undef HAVE_XRENDERCREATELINEARGRADIENT
 
-- 
2.34.1


From 2b519cbc6b6f8b8a6e2ad8ca6ceabcb5226b1878 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 6 Sep 2021 13:55:18 +0300
Subject: [PATCH 037/147] winewayland.drv: Basic support for Wayland keymaps.

Handle the keymap information sent by the compositor, and try to match
the keycodes in the keymap to keys from a keyboard layout, in order to
be able to provide to virtual key and scan codes for each keycode.

Keyboard layouts are structures that contain information about the
virtual key code and scan code corresponding to each physical key, as
well as the xkb_keysym_t symbols emitted by each key for the normal and
shift states.

Each Wayland keycode is mapped to a layout key based on the similarity
of the symbols this keycode produces in the active Wayland keymap, to
the symbols for the key in the keyboard layout.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in              |   2 +
 dlls/winewayland.drv/wayland_keyboard.c       |  52 +-
 .../winewayland.drv/wayland_keyboard_layout.c | 205 ++++++++
 .../winewayland.drv/wayland_keyboard_layout.h | 446 ++++++++----------
 dlls/winewayland.drv/waylanddrv.h             |   3 +
 dlls/winewayland.drv/xkb_util.c               |  76 +++
 6 files changed, 527 insertions(+), 257 deletions(-)
 create mode 100644 dlls/winewayland.drv/wayland_keyboard_layout.c
 create mode 100644 dlls/winewayland.drv/xkb_util.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 6b87e9897f3..0714f4e5c48 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -17,11 +17,13 @@ C_SRCS = \
 	wayland_buffer_queue.c \
 	wayland_cursor.c \
 	wayland_keyboard.c \
+	wayland_keyboard_layout.c \
 	wayland_pointer.c \
 	wayland_shm.c \
 	wayland_surface.c \
 	window.c \
 	window_surface.c \
+	xkb_util.c \
 
 WAYLAND_PROTOCOL_SRCS = \
 	$(WAYLAND_PROTOCOLS_DATADIR)/stable/xdg-shell/xdg-shell.xml \
diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index de03e0a71bd..8863df685c3 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -38,25 +38,24 @@
 
 #include "winuser.h"
 
+#include <sys/mman.h>
 #include <unistd.h>
 
-#include "wayland_keyboard_layout.h"
-
 WINE_DEFAULT_DEBUG_CHANNEL(keyboard);
 WINE_DECLARE_DEBUG_CHANNEL(key);
 
 static DWORD _xkb_keycode_to_scancode(struct wayland_keyboard *keyboard,
                                       xkb_keycode_t xkb_keycode)
 {
-    /* Use linux input keycode as scan code for now. */
-    return xkb_keycode - 8;
+    return xkb_keycode < ARRAY_SIZE(keyboard->xkb_keycode_to_scancode) ?
+           keyboard->xkb_keycode_to_scancode[xkb_keycode] : 0;
 }
 
 static UINT _xkb_keycode_to_vkey(struct wayland_keyboard *keyboard,
                                  xkb_keycode_t xkb_keycode)
 {
-    return xkb_keycode < ARRAY_SIZE(xkb_keycode_to_vkey_us) ?
-           xkb_keycode_to_vkey_us[xkb_keycode] : 0;
+    return xkb_keycode < ARRAY_SIZE(keyboard->xkb_keycode_to_vkey) ?
+           keyboard->xkb_keycode_to_vkey[xkb_keycode] : 0;
 }
 
 /* xkb keycodes are offset by 8 from linux input keycodes. */
@@ -146,6 +145,40 @@ static void wayland_keyboard_emit(struct wayland_keyboard *keyboard, uint32_t ke
 static void keyboard_handle_keymap(void *data, struct wl_keyboard *keyboard,
                                    uint32_t format, int fd, uint32_t size)
 {
+    struct wayland *wayland = data;
+    struct xkb_keymap *xkb_keymap = NULL;
+    struct xkb_state *xkb_state = NULL;
+    char *keymap_str;
+
+    TRACE("format=%d fd=%d size=%d\n", format, fd, size);
+
+    if (format != WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1 ||
+        !wayland->keyboard.xkb_context)
+        goto out;
+
+    keymap_str = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);
+    if (!keymap_str)
+        goto out;
+
+    xkb_keymap = xkb_keymap_new_from_string(wayland->keyboard.xkb_context,
+                                            keymap_str,
+                                            XKB_KEYMAP_FORMAT_TEXT_V1,
+                                            0);
+    munmap(keymap_str, size);
+    if (!xkb_keymap)
+        goto out;
+
+    xkb_state = xkb_state_new(xkb_keymap);
+    xkb_keymap_unref(xkb_keymap);
+    if (!xkb_state)
+        goto out;
+
+    xkb_state_unref(wayland->keyboard.xkb_state);
+    wayland->keyboard.xkb_state = xkb_state;
+
+    wayland_keyboard_update_layout(&wayland->keyboard);
+
+out:
     close(fd);
 }
 
@@ -303,14 +336,21 @@ static void keyboard_handle_modifiers(void *data, struct wl_keyboard *keyboard,
                                       uint32_t group)
 {
     struct wayland *wayland = data;
+    uint32_t last_group;
 
     TRACE("depressed=0x%x latched=0x%x locked=0x%x group=%d\n",
           mods_depressed, mods_latched, mods_locked, group);
 
     if (!wayland->keyboard.xkb_state) return;
 
+    last_group = _xkb_state_get_active_layout(wayland->keyboard.xkb_state);
+
     xkb_state_update_mask(wayland->keyboard.xkb_state,
                           mods_depressed, mods_latched, mods_locked, 0, 0, group);
+
+    if (group != last_group)
+        wayland_keyboard_update_layout(&wayland->keyboard);
+
 }
 
 static void keyboard_handle_repeat_info(void *data, struct wl_keyboard *keyboard,
diff --git a/dlls/winewayland.drv/wayland_keyboard_layout.c b/dlls/winewayland.drv/wayland_keyboard_layout.c
new file mode 100644
index 00000000000..60786cce7d2
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_keyboard_layout.c
@@ -0,0 +1,205 @@
+/*
+ * Wayland keyboard driver layouts, adapted from X11 driver.
+ *
+ * Copyright 1993 Bob Amstadt
+ * Copyright 1996 Albrecht Kleine
+ * Copyright 1997 David Faure
+ * Copyright 1998 Morten Welinder
+ * Copyright 1998 Ulrich Weigand
+ * Copyright 1999 Ove Kven
+ * Copyright 2021 Alexandros Frantzis
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "ime.h"
+#include "winuser.h"
+
+#include "wayland_keyboard_layout.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(keyboard);
+WINE_DECLARE_DEBUG_CHANNEL(key);
+
+static int score_symbols(const xkb_keysym_t sym[MAIN_KEY_SYMBOLS_LEN],
+                         const xkb_keysym_t ref[MAIN_KEY_SYMBOLS_LEN])
+{
+    int score = 0, i;
+
+    for (i = 0; i < MAIN_KEY_SYMBOLS_LEN && ref[i]; i++)
+    {
+        if (ref[i] != sym[i]) return 0;
+        score++;
+    }
+
+    return score;
+}
+
+static void _xkb_keymap_populate_symbols_for_keycode(
+    struct xkb_keymap *xkb_keymap,
+    xkb_layout_index_t layout,
+    xkb_keysym_t symbols_for_keycode[256][MAIN_KEY_SYMBOLS_LEN])
+{
+    xkb_keycode_t xkb_keycode, min_xkb_keycode, max_xkb_keycode;
+
+    min_xkb_keycode = xkb_keymap_min_keycode(xkb_keymap);
+    max_xkb_keycode = xkb_keymap_max_keycode(xkb_keymap);
+    if (max_xkb_keycode > 255) max_xkb_keycode = 255;
+
+    for (xkb_keycode = min_xkb_keycode; xkb_keycode <= max_xkb_keycode; xkb_keycode++)
+    {
+        xkb_level_index_t num_levels =
+            xkb_keymap_num_levels_for_key(xkb_keymap, xkb_keycode, layout);
+        xkb_level_index_t level;
+
+        if (num_levels > MAIN_KEY_SYMBOLS_LEN) num_levels = MAIN_KEY_SYMBOLS_LEN;
+
+        for (level = 0; level < num_levels; level++)
+        {
+            const xkb_keysym_t *syms;
+            int nsyms = xkb_keymap_key_get_syms_by_level(xkb_keymap, xkb_keycode,
+                                                         layout, level, &syms);
+            if (nsyms)
+                symbols_for_keycode[xkb_keycode][level] = syms[0];
+        }
+    }
+}
+
+/* Populate the xkb_keycode_to_vkey[] and xkb_keycode_to_scan[] arrays based on
+ * the specified main_key layout (see wayland_keyboard_layout.h) and the
+ * xkb_keycode to xkb_keysym_t mappings which have been created from the
+ * currently active Wayland keymap. */
+static void populate_xkb_keycode_maps(struct wayland_keyboard *keyboard, int main_key_layout,
+                                      const xkb_keysym_t symbols_for_keycode[256][MAIN_KEY_SYMBOLS_LEN])
+{
+    xkb_keycode_t xkb_keycode;
+    char key_used[MAIN_KEY_LEN] = { 0 };
+    const xkb_keysym_t (*lsymbols)[MAIN_KEY_SYMBOLS_LEN] =
+        (*main_key_tab[main_key_layout].symbols);
+    const WORD *lvkey = (*main_key_tab[main_key_layout].vkey);
+    const WORD *lscan = (*main_key_tab[main_key_layout].scan);
+
+    for (xkb_keycode = 0; xkb_keycode < 256; xkb_keycode++)
+    {
+        int max_key = -1;
+        int max_score = 0;
+        xkb_keysym_t xkb_keysym = symbols_for_keycode[xkb_keycode][0];
+        UINT vkey = 0;
+        WORD scan = 0;
+
+        /* Map keypad keys to their num-locked values (i.e., second level), to
+         * avoid confusion with the dedicated keys with the same functions. */
+        if (xkb_keysym >= XKB_KEY_KP_Home && xkb_keysym <= XKB_KEY_KP_Delete)
+            xkb_keysym = symbols_for_keycode[xkb_keycode][1];
+
+        if ((xkb_keysym >> 8) == 0xFF)
+        {
+            vkey = xkb_keysym_0xff00_to_vkey[xkb_keysym & 0xff];
+            scan = xkb_keysym_0xff00_to_scan[xkb_keysym & 0xff];
+        }
+        else if ((xkb_keysym >> 8) == 0x1008FF)
+        {
+            vkey = xkb_keysym_xfree86_to_vkey[xkb_keysym & 0xff];
+            /* All vendor keys are extended with a scan code of 0 per testing
+             * on WinXP */
+            scan = 0x100;
+        }
+        else if (xkb_keysym == 0x20)
+        {
+            vkey = VK_SPACE;
+            scan = 0x39;
+        }
+        else
+        {
+            int key;
+
+            for (key = 0; key < MAIN_KEY_LEN; key++)
+            {
+                int score = score_symbols(symbols_for_keycode[xkb_keycode],
+                                          lsymbols[key]);
+                /* Consider this key if it has a better score, or the same
+                 * score as a previous match that is already in use (in order
+                 * to prefer unused keys). */
+                if (score > max_score ||
+                    (max_key >= 0 && score == max_score && key_used[max_key]))
+                {
+                    max_key = key;
+                    max_score = score;
+                }
+            }
+
+            if (max_key >= 0)
+            {
+                vkey = lvkey[max_key];
+                scan = lscan[max_key];
+                key_used[max_key] = 1;
+            }
+        }
+
+        keyboard->xkb_keycode_to_vkey[xkb_keycode] = vkey;
+        keyboard->xkb_keycode_to_scancode[xkb_keycode] = scan;
+
+        if (TRACE_ON(key))
+        {
+            char utf8[64];
+            _xkb_keysyms_to_utf8(symbols_for_keycode[xkb_keycode],
+                                 MAIN_KEY_SYMBOLS_LEN, utf8, sizeof(utf8));
+            TRACE_(key)("Mapped xkb_keycode=%d syms={0x%x,0x%x} utf8='%s' => "
+                        "vkey=0x%x scan=0x%x\n",
+                        xkb_keycode,
+                        symbols_for_keycode[xkb_keycode][0],
+                        symbols_for_keycode[xkb_keycode][1],
+                        utf8, vkey, scan);
+        }
+    }
+}
+
+/***********************************************************************
+ *           wayland_keyboard_update_layout
+ *
+ * Updates the internal weston_keyboard layout information (xkb keycode
+ * mappings etc) based on the current XKB layout.
+ */
+void wayland_keyboard_update_layout(struct wayland_keyboard *keyboard)
+{
+    xkb_layout_index_t layout;
+    struct xkb_state *xkb_state = keyboard->xkb_state;
+    struct xkb_keymap *xkb_keymap;
+    xkb_keysym_t symbols_for_keycode[256][MAIN_KEY_SYMBOLS_LEN] = { 0 };
+
+    if (!xkb_state)
+    {
+        TRACE("no xkb state, returning\n");
+        return;
+    }
+
+    layout = _xkb_state_get_active_layout(xkb_state);
+    if (layout == XKB_LAYOUT_INVALID)
+    {
+        TRACE("no active layout, returning\n");
+        return;
+    }
+
+    xkb_keymap = xkb_state_get_keymap(xkb_state);
+
+    _xkb_keymap_populate_symbols_for_keycode(xkb_keymap, layout, symbols_for_keycode);
+
+    populate_xkb_keycode_maps(keyboard, 0, symbols_for_keycode);
+}
diff --git a/dlls/winewayland.drv/wayland_keyboard_layout.h b/dlls/winewayland.drv/wayland_keyboard_layout.h
index 58a14aac378..2eafb6d2cb5 100644
--- a/dlls/winewayland.drv/wayland_keyboard_layout.h
+++ b/dlls/winewayland.drv/wayland_keyboard_layout.h
@@ -30,258 +30,202 @@
 #ifndef __WINE_WAYLANDDRV_WAYLAND_KEYBOARD_LAYOUT_H
 #define __WINE_WAYLANDDRV_WAYLAND_KEYBOARD_LAYOUT_H
 
-static const UINT xkb_keycode_to_vkey_us[] =
+#define MAIN_KEY_LEN 50
+/* We currently use two symbols (levels) per key to differentiate layouts. */
+#define MAIN_KEY_SYMBOLS_LEN 2
+
+/* Windows uses PS/2 scan code set 1 for the scan codes sent to applications. */
+static const WORD main_key_scan_ps2_set1[MAIN_KEY_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    0x29,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x7D,
+    /* Row D: AD01-AD12 */
+    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,
+    /* Row C: AC01-AC12 */
+    0x1E,0x1F,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x2B,
+    /* Row B: LSGT, AB01-AB11 */
+    0x56,0x2C,0x2D,0x2E,0x2F,0x30,0x31,0x32,0x33,0x34,0x35,0x73
+};
+
+static const WORD main_key_vkey_qwerty[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_3,'1','2','3','4','5','6','7','8','9','0',VK_OEM_MINUS,VK_OEM_PLUS,0,
+    'Q','W','E','R','T','Y','U','I','O','P',VK_OEM_4,VK_OEM_6,
+    'A','S','D','F','G','H','J','K','L',VK_OEM_1,VK_OEM_7,VK_OEM_5,
+    VK_OEM_102,'Z','X','C','V','B','N','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,
+};
+
+#define K(x) XKB_KEY_##x
+
+static const xkb_keysym_t main_key_symbols_us[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', ':'}, {'\'', '"'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+#undef K
+
+/*** Layout table. Add your keyboard mappings to this list */
+static struct {
+    LCID lcid; /* input locale identifier, look for LOCALE_ILANGUAGE
+                 in the appropriate dlls/kernel/nls/.nls file */
+    const char *name;
+    const xkb_keysym_t (*symbols)[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN];
+    const WORD (*scan)[MAIN_KEY_LEN]; /* scan codes mapping */
+    const WORD (*vkey)[MAIN_KEY_LEN]; /* virtual key codes mapping */
+} main_key_tab[]={
+    {0x0409, "us", &main_key_symbols_us, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+};
+
+static const WORD xkb_keysym_0xff00_to_vkey[256] =
+{
+    /* unused */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF00 */
+    /* special keys */
+    VK_BACK, VK_TAB, 0, VK_CLEAR, 0, VK_RETURN, 0, 0,           /* FF08 */
+    0, 0, 0, VK_PAUSE, VK_SCROLL, 0, 0, 0,                      /* FF10 */
+    0, 0, 0, VK_ESCAPE, 0, 0, 0, 0,                             /* FF18 */
+    /* Japanese special keys */
+    0, VK_KANJI, VK_NONCONVERT, VK_CONVERT,                     /* FF20 */
+    VK_DBE_ROMAN, 0, 0, VK_DBE_HIRAGANA,
+    0, 0, VK_DBE_SBCSCHAR, 0, 0, 0, 0, 0,                       /* FF28 */
+    /* Korean special keys (FF31-) */
+    VK_DBE_ALPHANUMERIC, VK_HANGUL, 0, 0, VK_HANJA, 0, 0, 0,    /* FF30 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF38 */
+    /* unused */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF40 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF48 */
+    /* cursor keys */
+    VK_HOME, VK_LEFT, VK_UP, VK_RIGHT,                          /* FF50 */
+    VK_DOWN, VK_PRIOR, VK_NEXT, VK_END,
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF58 */
+    /* misc keys */
+    VK_SELECT, VK_SNAPSHOT, VK_EXECUTE, VK_INSERT, 0,0,0, VK_APPS, /* FF60 */
+    0, VK_CANCEL, VK_HELP, VK_CANCEL, 0, 0, 0, 0,               /* FF68 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF70 */
+    /* keypad keys */
+    0, 0, 0, 0, 0, 0, 0, VK_NUMLOCK,                            /* FF78 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FF80 */
+    0, 0, 0, 0, 0, VK_RETURN, 0, 0,                             /* FF88 */
+    0, 0, 0, 0, 0, VK_HOME, VK_LEFT, VK_UP,                     /* FF90 */
+    VK_RIGHT, VK_DOWN, VK_PRIOR, VK_NEXT,                       /* FF98 */
+    VK_END, VK_CLEAR, VK_INSERT, VK_DELETE,
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FFA0 */
+    0, 0, VK_MULTIPLY, VK_ADD,                                  /* FFA8 */
+    /* Windows always generates VK_DECIMAL for Del/. on keypad while some
+     * X11 keyboard layouts generate XK_KP_Separator instead of XK_KP_Decimal
+     * in order to produce a locale dependent numeric separator.
+     */
+    VK_DECIMAL, VK_SUBTRACT, VK_DECIMAL, VK_DIVIDE,
+    VK_NUMPAD0, VK_NUMPAD1, VK_NUMPAD2, VK_NUMPAD3,             /* FFB0 */
+    VK_NUMPAD4, VK_NUMPAD5, VK_NUMPAD6, VK_NUMPAD7,
+    VK_NUMPAD8, VK_NUMPAD9, 0, 0, 0, VK_OEM_NEC_EQUAL,          /* FFB8 */
+    /* function keys */
+    VK_F1, VK_F2,
+    VK_F3, VK_F4, VK_F5, VK_F6, VK_F7, VK_F8, VK_F9, VK_F10,    /* FFC0 */
+    VK_F11, VK_F12, VK_F13, VK_F14, VK_F15, VK_F16, VK_F17, VK_F18, /* FFC8 */
+    VK_F19, VK_F20, VK_F21, VK_F22, VK_F23, VK_F24, 0, 0,       /* FFD0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FFD8 */
+    /* modifier keys */
+    0, VK_LSHIFT, VK_RSHIFT, VK_LCONTROL,                       /* FFE0 */
+    VK_RCONTROL, VK_CAPITAL, 0, VK_LMENU,
+    VK_RMENU, VK_LMENU, VK_RMENU, VK_LWIN, VK_RWIN, 0, 0, 0,    /* FFE8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* FFF0 */
+    0, 0, 0, 0, 0, 0, 0, VK_DELETE                              /* FFF8 */
+};
+
+static const WORD xkb_keysym_0xff00_to_scan[256] =
+{
+    /* unused */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF00 */
+    /* special keys */
+    0x0E, 0x0F, 0x00, /*?*/ 0, 0x00, 0x1C, 0x00, 0x00,           /* FF08 */
+    0x00, 0x00, 0x00, 0x45, 0x46, 0x00, 0x00, 0x00,              /* FF10 */
+    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,              /* FF18 */
+    /* Japanese special keys */
+    0x00, 0x29, 0x7B, 0x79, 0x70, 0x00, 0x00, 0x70,              /* FF20 */
+    0x00, 0x00, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF28 */
+    /* Korean special keys (FF31-) */
+    0x3A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF30 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF38 */
+    /* unused */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF40 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF48 */
+    /* cursor keys */
+    0x147, 0x14B, 0x148, 0x14D, 0x150, 0x149, 0x151, 0x14F,      /* FF50 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF58 */
+    /* misc keys */
+    /*?*/ 0, 0x137, /*?*/ 0, 0x152, 0x00, 0x00, 0x00, 0x15D,     /* FF60 */
+    /*?*/ 0, /*?*/ 0, 0x38, 0x146, 0x00, 0x00, 0x00, 0x00,       /* FF68 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF70 */
+    /* keypad keys */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x145,             /* FF78 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FF80 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x11C, 0x00, 0x00,             /* FF88 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x4B, 0x48,              /* FF90 */
+    0x4D, 0x50, 0x49, 0x51, 0x4F, 0x4C, 0x52, 0x53,              /* FF98 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FFA0 */
+    0x00, 0x00, 0x37, 0x4E, 0x53, 0x4A, 0x53, 0x135,             /* FFA8 */
+    0x52, 0x4F, 0x50, 0x51, 0x4B, 0x4C, 0x4D, 0x47,              /* FFB0 */
+    0x48, 0x49, 0x00, 0x00, 0x00, 0x00,                          /* FFB8 */
+    /* function keys */
+    0x3B, 0x3C,
+    0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x42, 0x43, 0x44,              /* FFC0 */
+    0x57, 0x58, 0x5B, 0x5C, 0x5D, 0x00, 0x00, 0x00,              /* FFC8 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FFD0 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FFD8 */
+    /* modifier keys */
+    0x00, 0x2A, 0x136, 0x1D, 0x11D, 0x3A, 0x00, 0x38,            /* FFE0 */
+    0x138, 0x38, 0x138, 0x15b, 0x15c, 0x00, 0x00, 0x00,          /* FFE8 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,              /* FFF0 */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x153              /* FFF8 */
+};
+
+static const WORD xkb_keysym_xfree86_to_vkey[256] =
 {
-    0, 0, 0, 0, 0, 0, 0, 0,
-    0,                   /* KEY_RESERVED  0 */
-    VK_ESCAPE,           /* KEY_ESC   1 */
-    '1',                 /* KEY_1   2 */
-    '2',                 /* KEY_2   3 */
-    '3',                 /* KEY_3   4 */
-    '4',                 /* KEY_4   5 */
-    '5',                 /* KEY_5   6 */
-    '6',                 /* KEY_6   7 */
-    '7',                 /* KEY_7   8 */
-    '8',                 /* KEY_8   9 */
-    '9',                 /* KEY_9   10 */
-    '0',                 /* KEY_0   11 */
-    VK_OEM_MINUS,        /* KEY_MINUS  12 */
-    VK_OEM_PLUS,         /* KEY_EQUAL  13 */
-    VK_BACK,             /* KEY_BACKSPACE 14 */
-    VK_TAB,              /* KEY_TAB   15 */
-    'Q',                 /* KEY_Q   16 */
-    'W',                 /* KEY_W   17 */
-    'E',                 /* KEY_E   18 */
-    'R',                 /* KEY_R   19 */
-    'T',                 /* KEY_T   20 */
-    'Y',                 /* KEY_Y   21 */
-    'U',                 /* KEY_U   22 */
-    'I',                 /* KEY_I   23 */
-    'O',                 /* KEY_O   24 */
-    'P',                 /* KEY_P   25 */
-    VK_OEM_4,            /* KEY_LEFTBRACE  26 */
-    VK_OEM_6,            /* KEY_RIGHTBRACE  27 */
-    VK_RETURN,           /* KEY_ENTER  28 */
-    VK_LCONTROL,         /* KEY_LEFTCTRL  29 */
-    'A',                 /* KEY_A   30 */
-    'S',                 /* KEY_S   31 */
-    'D',                 /* KEY_D   32 */
-    'F',                 /* KEY_F   33 */
-    'G',                 /* KEY_G   34 */
-    'H',                 /* KEY_H   35 */
-    'J',                 /* KEY_J   36 */
-    'K',                 /* KEY_K   37 */
-    'L',                 /* KEY_L   38 */
-    VK_OEM_1,            /* KEY_SEMICOLON  39 */
-    VK_OEM_7,            /* KEY_APOSTROPHE  40 */
-    VK_OEM_3,            /* KEY_GRAVE  41 */
-    VK_LSHIFT,           /* KEY_LEFTSHIFT  42 */
-    VK_OEM_5,            /* KEY_BACKSLASH  43 */
-    'Z',                 /* KEY_Z   44 */
-    'X',                 /* KEY_X   45 */
-    'C',                 /* KEY_C   46 */
-    'V',                 /* KEY_V   47 */
-    'B',                 /* KEY_B   48 */
-    'N',                 /* KEY_N   49 */
-    'M',                 /* KEY_M   50 */
-    VK_OEM_COMMA,        /* KEY_COMMA  51 */
-    VK_OEM_PERIOD,       /* KEY_DOT   52 */
-    VK_OEM_2,            /* KEY_SLASH  53 */
-    VK_RSHIFT,           /* KEY_RIGHTSHIFT  54 */
-    VK_MULTIPLY,         /* KEY_KPASTERISK  55 */
-    VK_LMENU,            /* KEY_LEFTALT  56 */
-    VK_SPACE,            /* KEY_SPACE  57 */
-    VK_CAPITAL,          /* KEY_CAPSLOCK  58 */
-    VK_F1,               /* KEY_F1   59 */
-    VK_F2,               /* KEY_F2   60 */
-    VK_F3,               /* KEY_F3   61 */
-    VK_F4,               /* KEY_F4   62 */
-    VK_F5,               /* KEY_F5   63 */
-    VK_F6,               /* KEY_F6   64 */
-    VK_F7,               /* KEY_F7   65 */
-    VK_F8,               /* KEY_F8   66 */
-    VK_F9,               /* KEY_F9   67 */
-    VK_F10,              /* KEY_F10   68 */
-    VK_NUMLOCK,          /* KEY_NUMLOCK  69 */
-    VK_SCROLL,           /* KEY_SCROLLLOCK  70 */
-    VK_NUMPAD7,          /* KEY_KP7   71 */
-    VK_NUMPAD8,          /* KEY_KP8   72 */
-    VK_NUMPAD9,          /* KEY_KP9   73 */
-    VK_SUBTRACT,         /* KEY_KPMINUS  74 */
-    VK_NUMPAD4,          /* KEY_KP4   75 */
-    VK_NUMPAD5,          /* KEY_KP5   76 */
-    VK_NUMPAD6,          /* KEY_KP6   77 */
-    VK_ADD,              /* KEY_KPPLUS  78 */
-    VK_NUMPAD1,          /* KEY_KP1   79 */
-    VK_NUMPAD2,          /* KEY_KP2   80 */
-    VK_NUMPAD3,          /* KEY_KP3   81 */
-    VK_NUMPAD0,          /* KEY_KP0   82 */
-    VK_DECIMAL,          /* KEY_KPDOT  83 */
-    0,                   /* 84 */
-    0,                   /* KEY_ZENKAKUHANKAKU 85 */
-    VK_OEM_102,          /* KEY_102ND  86 */
-    VK_F11,              /* KEY_F11   87 */
-    VK_F12,              /* KEY_F12   88 */
-    0,                   /* KEY_RO   89 */
-    0,                   /* KEY_KATAKANA  90 */
-    0,                   /* KEY_HIRAGANA  91 */
-    0,                   /* KEY_HENKAN  92 */
-    0,                   /* KEY_KATAKANAHIRAGANA 93 */
-    0,                   /* KEY_MUHENKAN  94 */
-    0,                   /* KEY_KPJPCOMMA  95 */
-    VK_RETURN,           /* KEY_KPENTER  96 */
-    VK_RCONTROL,         /* KEY_RIGHTCTRL  97 */
-    VK_DIVIDE,           /* KEY_KPSLASH  98 */
-    VK_SNAPSHOT,         /* KEY_SYSRQ  99 */
-    VK_RMENU,            /* KEY_RIGHTALT  100 */
-    0,                   /* KEY_LINEFEED  101 */
-    VK_HOME,             /* KEY_HOME  102 */
-    VK_UP,               /* KEY_UP   103 */
-    VK_PRIOR,            /* KEY_PAGEUP  104 */
-    VK_LEFT,             /* KEY_LEFT  105 */
-    VK_RIGHT,            /* KEY_RIGHT  106 */
-    VK_END,              /* KEY_END   107 */
-    VK_DOWN,             /* KEY_DOWN  108 */
-    VK_NEXT,             /* KEY_PAGEDOWN  109 */
-    VK_INSERT,           /* KEY_INSERT  110 */
-    VK_DELETE,           /* KEY_DELETE  111 */
-    0,                   /* KEY_MACRO  112 */
-    VK_VOLUME_MUTE,      /* KEY_MUTE  113 */
-    VK_VOLUME_DOWN,      /* KEY_VOLUMEDOWN  114 */
-    VK_VOLUME_UP,        /* KEY_VOLUMEUP  115 */
-    0,                   /* KEY_POWER  116  */
-    0,                   /* KEY_KPEQUAL  117 */
-    0,                   /* KEY_KPPLUSMINUS  118 */
-    VK_PAUSE,            /* KEY_PAUSE  119 */
-    0,                   /* KEY_SCALE  120  */
-    0,                   /* KEY_KPCOMMA  121 */
-    0,                   /* KEY_HANGEUL  122 */
-    0,                   /* KEY_HANJA  123 */
-    0,                   /* KEY_YEN   124 */
-    VK_LWIN,             /* KEY_LEFTMETA  125 */
-    VK_RWIN,             /* KEY_RIGHTMETA  126 */
-    0,                   /* KEY_COMPOSE  127 */
-    0,                   /* KEY_STOP  128  */
-    0,                   /* KEY_AGAIN  129 */
-    0,                   /* KEY_PROPS  130  */
-    0,                   /* KEY_UNDO  131  */
-    0,                   /* KEY_FRONT  132 */
-    0,                   /* KEY_COPY  133  */
-    0,                   /* KEY_OPEN  134  */
-    0,                   /* KEY_PASTE  135  */
-    0,                   /* KEY_FIND  136  */
-    0,                   /* KEY_CUT   137  */
-    0,                   /* KEY_HELP  138  */
-    0,                   /* KEY_MENU  139  */
-    0,                   /* KEY_CALC  140  */
-    0,                   /* KEY_SETUP  141 */
-    0,                   /* KEY_SLEEP  142  */
-    0,                   /* KEY_WAKEUP  143  */
-    0,                   /* KEY_FILE  144  */
-    0,                   /* KEY_SENDFILE  145 */
-    0,                   /* KEY_DELETEFILE  146 */
-    0,                   /* KEY_XFER  147 */
-    0,                   /* KEY_PROG1  148 */
-    0,                   /* KEY_PROG2  149 */
-    0,                   /* KEY_WWW   150  */
-    0,                   /* KEY_MSDOS  151 */
-    0,                   /* KEY_COFFEE  152 */
-    0,                   /* KEY_ROTATE_DISPLAY 153  */
-    0,                   /* KEY_CYCLEWINDOWS 154 */
-    0,                   /* KEY_MAIL  155 */
-    0,                   /* KEY_BOOKMARKS  156  */
-    0,                   /* KEY_COMPUTER  157 */
-    0,                   /* KEY_BACK  158  */
-    0,                   /* KEY_FORWARD  159  */
-    0,                   /* KEY_CLOSECD  160 */
-    0,                   /* KEY_EJECTCD  161 */
-    0,                   /* KEY_EJECTCLOSECD 162 */
-    VK_MEDIA_NEXT_TRACK, /* KEY_NEXTSONG  163 */
-    VK_MEDIA_PLAY_PAUSE, /* KEY_PLAYPAUSE  164 */
-    VK_MEDIA_PREV_TRACK, /* KEY_PREVIOUSSONG 165 */
-    0,                   /* KEY_STOPCD  166 */
-    0,                   /* KEY_RECORD  167 */
-    0,                   /* KEY_REWIND  168 */
-    0,                   /* KEY_PHONE  169  */
-    0,                   /* KEY_ISO   170 */
-    0,                   /* KEY_CONFIG  171  */
-    0,                   /* KEY_HOMEPAGE  172  */
-    0,                   /* KEY_REFRESH  173  */
-    0,                   /* KEY_EXIT  174  */
-    0,                   /* KEY_MOVE  175 */
-    0,                   /* KEY_EDIT  176 */
-    0,                   /* KEY_SCROLLUP  177 */
-    0,                   /* KEY_SCROLLDOWN  178 */
-    0,                   /* KEY_KPLEFTPAREN  179 */
-    0,                   /* KEY_KPRIGHTPAREN 180 */
-    0,                   /* KEY_NEW   181  */
-    0,                   /* KEY_REDO  182  */
-    VK_F13,              /* KEY_F13   183 */
-    VK_F14,              /* KEY_F14   184 */
-    VK_F15,              /* KEY_F15   185 */
-    VK_F16,              /* KEY_F16   186 */
-    VK_F17,              /* KEY_F17   187 */
-    VK_F18,              /* KEY_F18   188 */
-    VK_F19,              /* KEY_F19   189 */
-    VK_F20,              /* KEY_F20   190 */
-    VK_F21,              /* KEY_F21   191 */
-    VK_F22,              /* KEY_F22   192 */
-    VK_F23,              /* KEY_F23   193 */
-    VK_F24,              /* KEY_F24   194 */
-    0,                   /* 195 */
-    0,                   /* 196 */
-    0,                   /* 197 */
-    0,                   /* 198 */
-    0,                   /* 199 */
-    0,                   /* KEY_PLAYCD  200 */
-    0,                   /* KEY_PAUSECD  201 */
-    0,                   /* KEY_PROG3  202 */
-    0,                   /* KEY_PROG4  203 */
-    0,                   /* KEY_DASHBOARD  204  */
-    0,                   /* KEY_SUSPEND  205 */
-    0,                   /* KEY_CLOSE  206  */
-    VK_PLAY,             /* KEY_PLAY  207 */
-    0,                   /* KEY_FASTFORWARD  208 */
-    0,                   /* KEY_BASSBOOST  209 */
-    VK_PRINT,            /* KEY_PRINT  210  */
-    0,                   /* KEY_HP   211 */
-    0,                   /* KEY_CAMERA  212 */
-    0,                   /* KEY_SOUND  213 */
-    0,                   /* KEY_QUESTION  214  */
-    0,                   /* KEY_EMAIL  215 */
-    0,                   /* KEY_CHAT  216 */
-    0,                   /* KEY_SEARCH  217 */
-    0,                   /* KEY_CONNECT  218 */
-    0,                   /* KEY_FINANCE  219  */
-    0,                   /* KEY_SPORT  220 */
-    0,                   /* KEY_SHOP  221 */
-    0,                   /* KEY_ALTERASE  222 */
-    0,                   /* KEY_CANCEL  223  */
-    0,                   /* KEY_BRIGHTNESSDOWN 224 */
-    0,                   /* KEY_BRIGHTNESSUP 225 */
-    0,                   /* KEY_MEDIA  226 */
-    0,                   /* KEY_SWITCHVIDEOMODE 227  */
-    0,                   /* KEY_KBDILLUMTOGGLE 228 */
-    0,                   /* KEY_KBDILLUMDOWN 229 */
-    0,                   /* KEY_KBDILLUMUP  230 */
-    0,                   /* KEY_SEND  231  */
-    0,                   /* KEY_REPLY  232  */
-    0,                   /* KEY_FORWARDMAIL  233  */
-    0,                   /* KEY_SAVE  234  */
-    0,                   /* KEY_DOCUMENTS  235 */
-    0,                   /* KEY_BATTERY  236 */
-    0,                   /* KEY_BLUETOOTH  237 */
-    0,                   /* KEY_WLAN  238 */
-    0,                   /* KEY_UWB   239  */
-    0,                   /* KEY_UNKNOWN  240 */
-    0,                   /* KEY_VIDEO_NEXT  241  */
-    0,                   /* KEY_VIDEO_PREV  242  */
-    0,                   /* KEY_BRIGHTNESS_CYCLE 243  */
-    0,                   /* KEY_BRIGHTNESS_AUTO/ZERO 244 */
-    0,                   /* KEY_DISPLAY_OFF  245  */
-    0,                   /* KEY_WWAN  246  */
-    0,                   /* KEY_RFKILL  247  */
-    0,                   /* KEY_MICMUTE  248  */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF00 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF08 */
+    0, VK_VOLUME_DOWN, VK_VOLUME_MUTE, VK_VOLUME_UP,            /* 1008FF10 */
+    VK_MEDIA_PLAY_PAUSE, VK_MEDIA_STOP,
+    VK_MEDIA_PREV_TRACK, VK_MEDIA_NEXT_TRACK,
+    0, VK_LAUNCH_MAIL, 0, VK_BROWSER_SEARCH,                    /* 1008FF18 */
+    0, 0, 0, VK_BROWSER_HOME,
+    0, 0, 0, 0, 0, 0, VK_BROWSER_BACK, VK_BROWSER_FORWARD,      /* 1008FF20 */
+    VK_BROWSER_STOP, VK_BROWSER_REFRESH, 0, 0, 0, 0, 0, 0,      /* 1008FF28 */
+    VK_BROWSER_FAVORITES, 0, VK_LAUNCH_MEDIA_SELECT, 0,         /* 1008FF30 */
+    0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF38 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF40 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF48 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF50 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF58 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF60 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF68 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF70 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF78 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF80 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF88 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF90 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FF98 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFA0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFA8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFB0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFB8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFC0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFC8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFD0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFD8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFE0 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFE8 */
+    0, 0, 0, 0, 0, 0, 0, 0,                                     /* 1008FFF0 */
+    0, 0, 0, 0, 0, 0, 0, 0                                      /* 1008FFF8 */
 };
 
 #endif /* __WINE_WAYLANDDRV_WAYLAND_KEYBOARD_LAYOUT_H */
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index bf3f6cc86b1..a63cf617338 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -82,6 +82,8 @@ struct wayland_keyboard
     uint32_t enter_serial;
     struct xkb_context *xkb_context;
     struct xkb_state *xkb_state;
+    UINT xkb_keycode_to_vkey[256];
+    WORD xkb_keycode_to_scancode[256];
 };
 
 struct wayland_cursor
@@ -337,6 +339,7 @@ void wayland_window_surface_update_wayland_surface(struct window_surface *surfac
 void wayland_keyboard_init(struct wayland_keyboard *keyboard, struct wayland *wayland,
                            struct wl_keyboard *wl_keyboard);
 void wayland_keyboard_deinit(struct wayland_keyboard *keyboard);
+void wayland_keyboard_update_layout(struct wayland_keyboard *keyboard);
 
 /**********************************************************************
  *          Wayland Pointer/Cursor
diff --git a/dlls/winewayland.drv/xkb_util.c b/dlls/winewayland.drv/xkb_util.c
new file mode 100644
index 00000000000..2a33c7ba564
--- /dev/null
+++ b/dlls/winewayland.drv/xkb_util.c
@@ -0,0 +1,76 @@
+/*
+ * XKB related utility functions
+ *
+ * Copyright 2021 Alexandros Frantzis for Collabora Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <xkbcommon/xkbcommon.h>
+
+/**********************************************************************
+ *          _xkb_state_get_active_layout
+ *
+ * Gets the active layout of the xkb state.
+ */
+xkb_layout_index_t _xkb_state_get_active_layout(struct xkb_state *xkb_state)
+{
+    struct xkb_keymap *xkb_keymap = xkb_state_get_keymap(xkb_state);
+    xkb_layout_index_t num_layouts = xkb_keymap_num_layouts(xkb_keymap);
+    xkb_layout_index_t layout;
+
+    for (layout = 0; layout < num_layouts; layout++)
+    {
+        if (xkb_state_layout_index_is_active(xkb_state, layout,
+                                             XKB_STATE_LAYOUT_LOCKED))
+            return layout;
+    }
+
+    return XKB_LAYOUT_INVALID;
+}
+
+/**********************************************************************
+ *          _xkb_keysyms_to_utf8
+ *
+ * Get the null-terminated UTF-8 string representation of a sequence of
+ * keysyms. Returns the length of the UTF-8 string written, *not* including
+ * the null byte. If no bytes were produced or in case of error returns 0
+ * and produces a properly null-terminated empty string if possible.
+ */
+int _xkb_keysyms_to_utf8(const xkb_keysym_t *syms, int nsyms, char *utf8, int utf8_size)
+{
+    int i;
+    int utf8_len = 0;
+
+    if (utf8_size == 0) return 0;
+
+    for (i = 0; i < nsyms; i++)
+    {
+        int nwritten = xkb_keysym_to_utf8(syms[i], utf8 + utf8_len,
+                                          utf8_size - utf8_len);
+        if (nwritten <= 0)
+        {
+            utf8_len = 0;
+            break;
+        }
+
+        /* nwritten includes the terminating null byte */
+        utf8_len += nwritten - 1;
+    }
+
+    utf8[utf8_len] = '\0';
+
+    return utf8_len;
+}
-- 
2.34.1


From 71e04637769abb55a2fd673490b77f5a2e0a7403 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 6 Sep 2021 13:57:33 +0300
Subject: [PATCH 038/147] winewayland.drv: Add detection of best keyboard
 layout match.

Add a mechanism to detect the best matching keyboard layout for a given
Wayland keymap, by scoring the similarity of the symbols produced by
Wayland keycodes for that keymap, to the symbols for keys in the layout.

The scoring algorithm takes relative key order into account to provide
better detection of layouts that differ only in their key order.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 .../winewayland.drv/wayland_keyboard_layout.c | 92 ++++++++++++++++++-
 1 file changed, 91 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/wayland_keyboard_layout.c b/dlls/winewayland.drv/wayland_keyboard_layout.c
index 60786cce7d2..1172c95f9d8 100644
--- a/dlls/winewayland.drv/wayland_keyboard_layout.c
+++ b/dlls/winewayland.drv/wayland_keyboard_layout.c
@@ -52,6 +52,62 @@ static int score_symbols(const xkb_keysym_t sym[MAIN_KEY_SYMBOLS_LEN],
     return score;
 }
 
+static int score_layout(int layout,
+                        const xkb_keysym_t symbols_for_keycode[256][MAIN_KEY_SYMBOLS_LEN])
+{
+    xkb_keycode_t xkb_keycode;
+    int score = 0;
+    int prev_key = 1000;
+    char key_used[MAIN_KEY_LEN] = { 0 };
+
+    for (xkb_keycode = 0; xkb_keycode < 256; xkb_keycode++)
+    {
+        int key, key_score = 0;
+        const xkb_keysym_t *symbols = symbols_for_keycode[xkb_keycode];
+
+        if (*symbols == 0)
+            continue;
+
+        for (key = 0; key < MAIN_KEY_LEN; key++)
+        {
+            if (key_used[key]) continue;
+            key_score = score_symbols(symbols_for_keycode[xkb_keycode],
+                                      (*main_key_tab[layout].symbols)[key]);
+            if (key_score)
+                break;
+        }
+
+        if (TRACE_ON(key))
+        {
+            char utf8[64];
+            _xkb_keysyms_to_utf8(symbols, MAIN_KEY_SYMBOLS_LEN, utf8, sizeof(utf8));
+            TRACE_(key)("xkb_keycode=%d syms={0x%x,0x%x} utf8='%s' key=%d score=%d order=%d\n",
+                        xkb_keycode,
+                        symbols_for_keycode[xkb_keycode][0],
+                        symbols_for_keycode[xkb_keycode][1],
+                        utf8, key, key_score, key_score && (key > prev_key));
+        }
+
+        if (key_score)
+        {
+            /* Multiply score by 100 to allow the key order bonus to break ties,
+             * while not being a primary decision factor. */
+            score += key_score * 100;
+
+            /* xkb keycodes roughly follow a top left to bottom right direction
+             * on the keyboard as they increase, similarly to the keys in
+             * main_key_tab. Give a bonus to layouts that more closely match
+             * the expected ordering. We compare with the last key to get
+             * some reasonable (although local) measure of the order. */
+            score += (key > prev_key);
+            prev_key = key;
+            key_used[key] = 1;
+        }
+    }
+
+    return score;
+}
+
 static void _xkb_keymap_populate_symbols_for_keycode(
     struct xkb_keymap *xkb_keymap,
     xkb_layout_index_t layout,
@@ -82,6 +138,37 @@ static void _xkb_keymap_populate_symbols_for_keycode(
     }
 }
 
+static int detect_main_key_layout(struct wayland_keyboard *keyboard,
+                                  const xkb_keysym_t symbols_for_keycode[256][MAIN_KEY_SYMBOLS_LEN])
+{
+    int max_score = 0;
+    int max_i = 0;
+
+    for (int i = 0; i < ARRAY_SIZE(main_key_tab); i++)
+    {
+        int score = score_layout(i, symbols_for_keycode);
+        if (score > max_score)
+        {
+            max_i = i;
+            max_score = score;
+        }
+        TRACE("evaluated layout '%s' score %d\n", main_key_tab[i].name, score);
+    }
+
+    if (max_score == 0)
+    {
+        max_i = 0;
+        while (strcmp(main_key_tab[max_i].name, "us")) max_i++;
+        TRACE("failed to detect layout, falling back to layout 'us'\n");
+    }
+    else
+    {
+        TRACE("detected layout '%s' (score %d)\n", main_key_tab[max_i].name, max_score);
+    }
+
+    return max_i;
+}
+
 /* Populate the xkb_keycode_to_vkey[] and xkb_keycode_to_scan[] arrays based on
  * the specified main_key layout (see wayland_keyboard_layout.h) and the
  * xkb_keycode to xkb_keysym_t mappings which have been created from the
@@ -183,6 +270,7 @@ void wayland_keyboard_update_layout(struct wayland_keyboard *keyboard)
     struct xkb_state *xkb_state = keyboard->xkb_state;
     struct xkb_keymap *xkb_keymap;
     xkb_keysym_t symbols_for_keycode[256][MAIN_KEY_SYMBOLS_LEN] = { 0 };
+    int main_key_layout;
 
     if (!xkb_state)
     {
@@ -201,5 +289,7 @@ void wayland_keyboard_update_layout(struct wayland_keyboard *keyboard)
 
     _xkb_keymap_populate_symbols_for_keycode(xkb_keymap, layout, symbols_for_keycode);
 
-    populate_xkb_keycode_maps(keyboard, 0, symbols_for_keycode);
+    main_key_layout = detect_main_key_layout(keyboard, symbols_for_keycode);
+
+    populate_xkb_keycode_maps(keyboard, main_key_layout, symbols_for_keycode);
 }
-- 
2.34.1


From 8f88fbf58f778e5e6219d522d8666328e51c1b4e Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 6 Sep 2021 14:00:11 +0300
Subject: [PATCH 039/147] winewayland.drv: Add support for more keyboard
 layouts.

Add virtual key mappings, scan code mappings, and symbol mappings for
various keyboard layouts and languages.

These mappings were produced automatically by a helper program using
the xkbcommon library.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 .../winewayland.drv/wayland_keyboard_layout.h | 699 ++++++++++++++++++
 1 file changed, 699 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_keyboard_layout.h b/dlls/winewayland.drv/wayland_keyboard_layout.h
index 2eafb6d2cb5..26f688cc636 100644
--- a/dlls/winewayland.drv/wayland_keyboard_layout.h
+++ b/dlls/winewayland.drv/wayland_keyboard_layout.h
@@ -56,8 +56,586 @@ static const WORD main_key_vkey_qwerty[MAIN_KEY_LEN] =
     VK_OEM_102,'Z','X','C','V','B','N','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,
 };
 
+static const WORD main_key_vkey_qwerty_jp106[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    0,'1','2','3','4','5','6','7','8','9','0',VK_OEM_MINUS,VK_OEM_7,VK_OEM_5,
+    'Q','W','E','R','T','Y','U','I','O','P',VK_OEM_3,VK_OEM_4,
+    'A','S','D','F','G','H','J','K','L',VK_OEM_PLUS,VK_OEM_1,VK_OEM_6,
+    VK_OEM_102,'Z','X','C','V','B','N','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,
+};
+
+static const WORD main_key_vkey_qwerty_v2[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_5,'1','2','3','4','5','6','7','8','9','0',VK_OEM_PLUS,VK_OEM_4,0,
+    'Q','W','E','R','T','Y','U','I','O','P',VK_OEM_6,VK_OEM_1,
+    'A','S','D','F','G','H','J','K','L',VK_OEM_3,VK_OEM_7,VK_OEM_2,
+    VK_OEM_102,'Z','X','C','V','B','N','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_MINUS,
+};
+
+static const WORD main_key_vkey_qwertz[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_3,'1','2','3','4','5','6','7','8','9','0',VK_OEM_MINUS,VK_OEM_PLUS,0,
+    'Q','W','E','R','T','Z','U','I','O','P',VK_OEM_4,VK_OEM_6,
+    'A','S','D','F','G','H','J','K','L',VK_OEM_1,VK_OEM_7,VK_OEM_5,
+    VK_OEM_102,'Y','X','C','V','B','N','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,
+};
+
+static const WORD main_key_vkey_abnt_qwerty[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_3,'1','2','3','4','5','6','7','8','9','0',VK_OEM_MINUS,VK_OEM_PLUS,0,
+    'Q','W','E','R','T','Y','U','I','O','P',VK_OEM_4,VK_OEM_6,
+    'A','S','D','F','G','H','J','K','L',VK_OEM_1,VK_OEM_8,VK_OEM_5,
+    VK_OEM_7,'Z','X','C','V','B','N','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,VK_OEM_102,
+};
+
+static const WORD main_key_vkey_colemak[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_3,'1','2','3','4','5','6','7','8','9','0',VK_OEM_MINUS,VK_OEM_PLUS,0,
+    'Q','W','F','P','G','J','L','U','Y',VK_OEM_1,VK_OEM_4,VK_OEM_6,
+    'A','R','S','T','D','H','N','E','I','O',VK_OEM_7,VK_OEM_5,
+    VK_OEM_102,'Z','X','C','V','B','K','M',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,
+};
+
+static const WORD main_key_vkey_azerty[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_7,'1','2','3','4','5','6','7','8','9','0',VK_OEM_4,VK_OEM_PLUS,0,
+    'A','Z','E','R','T','Y','U','I','O','P',VK_OEM_6,VK_OEM_1,
+    'Q','S','D','F','G','H','J','K','L','M',VK_OEM_3,VK_OEM_5,
+    VK_OEM_102,'W','X','C','V','B','N',VK_OEM_COMMA,VK_OEM_PERIOD,VK_OEM_2,VK_OEM_8,
+};
+
+static const WORD main_key_vkey_dvorak[MAIN_KEY_LEN] =
+{
+    /* NOTE: this layout must concur with the scan codes layout above */
+    VK_OEM_3,'1','2','3','4','5','6','7','8','9','0',VK_OEM_4,VK_OEM_6,0,
+    VK_OEM_7,VK_OEM_COMMA,VK_OEM_PERIOD,'P','Y','F','G','C','R','L',VK_OEM_2,VK_OEM_PLUS,
+    'A','O','E','U','I','D','H','T','N','S',VK_OEM_MINUS,VK_OEM_5,
+    VK_OEM_102,VK_OEM_1,'Q','J','K','X','B','M','W','V','Z',
+};
+
 #define K(x) XKB_KEY_##x
 
+static const xkb_keysym_t main_key_symbols_be[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+   {K(twosuperior), K(threesuperior)}, {'&', '1'}, {K(eacute), '2'}, {'"', '3'}, {'\'', '4'}, {'(', '5'}, {K(section), '6'}, {K(egrave), '7'}, {'!', '8'}, {K(ccedilla), '9'}, {K(agrave), '0'}, {')', K(degree)}, {'-', '_'}, {},
+    /* Row D: AD01-AD12 */
+   {'a', 'A'}, {'z', 'Z'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(dead_circumflex), K(dead_diaeresis)}, {'$', '*'},
+    /* Row C: AC01-AC12 */
+   {'q', 'Q'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {'m', 'M'}, {K(ugrave), '%'}, {K(mu), K(sterling)},
+    /* Row B: LSGT, AB01-AB11 */
+   {'<', '>'}, {'w', 'W'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {',', '?'}, {';', '.'}, {':', '/'}, {'=', '+'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_bg_bds[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'(', ')'}, {'1', '!'}, {'2', '?'}, {'3', '+'}, {'4', '"'}, {'5', '%'}, {'6', '='}, {'7', ':'}, {'8', '/'}, {'9', K(endash)}, {'0', K(numerosign)}, {'-', '$'}, {'.', K(EuroSign)}, {},
+    /* Row D: AD01-AD12 */
+    {',', K(Cyrillic_yeru)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_i), K(Cyrillic_I)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Cyrillic_shcha), K(Cyrillic_SHCHA)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {';', K(section)},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_softsign), 0x100045d}, {K(Cyrillic_ya), K(Cyrillic_YA)}, {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {K(Cyrillic_che), K(Cyrillic_CHE)}, {K(doublelowquotemark), K(leftdoublequotemark)},
+    /* Row B: LSGT, AB01-AB11 */
+    {0x100045d, 0x100040d}, {K(Cyrillic_yu), K(Cyrillic_YU)}, {K(Cyrillic_shorti), K(Cyrillic_SHORTI)}, {K(Cyrillic_hardsign), K(Cyrillic_HARDSIGN)}, {K(Cyrillic_e), K(Cyrillic_E)}, {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_bg_phonetic[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Cyrillic_che), K(Cyrillic_CHE)}, {'1', '!'}, {'2', '@'}, {'3', K(numerosign)}, {'4', '$'}, {'5', '%'}, {'6', K(EuroSign)}, {'7', K(section)}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', K(endash)}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {K(Cyrillic_ya), K(Cyrillic_YA)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_hardsign), K(Cyrillic_HARDSIGN)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_i), K(Cyrillic_I)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Cyrillic_shcha), K(Cyrillic_SHCHA)},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {K(Cyrillic_shorti), K(Cyrillic_SHORTI)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {';', ':'}, {'\'', '"'}, {K(Cyrillic_yu), K(Cyrillic_YU)},
+    /* Row B: LSGT, AB01-AB11 */
+    {0x100045d, 0x100040d}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_softsign), 0x100045d}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {',', K(doublelowquotemark)}, {'.', K(leftdoublequotemark)}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_br_abnt2[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'\'', '"'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', K(dead_diaeresis)}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(dead_acute), K(dead_grave)}, {'[', '{'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ccedilla), K(Ccedilla)}, {K(dead_tilde), K(dead_circumflex)}, {']', '}'},
+    /* Row B: LSGT, AB01-AB11 */
+   {'\\', '|'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {';', ':'}, {'/', '?'},
+};
+
+static const xkb_keysym_t main_key_symbols_by[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Cyrillic_io), K(Cyrillic_IO)}, {'1', '!'}, {'2', '"'}, {'3', K(numerosign)}, {'4', ';'}, {'5', '%'}, {'6', ':'}, {'7', '?'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {K(Cyrillic_shorti), K(Cyrillic_SHORTI)}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Byelorussian_shortu), K(Byelorussian_SHORTU)}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {'\'', '\''},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Cyrillic_yeru), K(Cyrillic_YERU)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Cyrillic_e), K(Cyrillic_E)}, {'\\', '/'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'/', '|'}, {K(Cyrillic_ya), K(Cyrillic_YA)}, {K(Cyrillic_che), K(Cyrillic_CHE)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {K(Ukrainian_i), K(Ukrainian_I)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_softsign), K(Cyrillic_SOFTSIGN)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {K(Cyrillic_yu), K(Cyrillic_YU)}, {'.', ','}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ca[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'#', '|'}, {'1', '!'}, {'2', '"'}, {'3', '/'}, {'4', '$'}, {'5', '%'}, {'6', '?'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(dead_circumflex), K(dead_circumflex)}, {K(dead_cedilla), K(dead_diaeresis)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', ':'}, {K(dead_grave), K(dead_grave)}, {'<', '>'},
+    /* Row B: LSGT, AB01-AB11 */
+    {K(guillemotleft), K(guillemotright)}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '\''}, {'.', '.'}, {K(eacute), K(Eacute)}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ch_de[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(section), K(degree)}, {'1', '+'}, {'2', '"'}, {'3', '*'}, {'4', K(ccedilla)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {K(dead_circumflex), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(udiaeresis), K(egrave)}, {K(dead_diaeresis), '!'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(odiaeresis), K(eacute)}, {K(adiaeresis), K(agrave)}, {'$', K(sterling)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ch_fr[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(section), K(degree)}, {'1', '+'}, {'2', '"'}, {'3', '*'}, {'4', K(ccedilla)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {K(dead_circumflex), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(egrave), K(udiaeresis)}, {K(dead_diaeresis), '!'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(eacute), K(odiaeresis)}, {K(agrave), K(adiaeresis)}, {'$', K(sterling)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_cz[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {';', K(dead_abovering)}, {'+', '1'}, {K(ecaron), '2'}, {K(scaron), '3'}, {K(ccaron), '4'}, {K(rcaron), '5'}, {K(zcaron), '6'}, {K(yacute), '7'}, {K(aacute), '8'}, {K(iacute), '9'}, {K(eacute), '0'}, {'=', '%'}, {K(dead_acute), K(dead_caron)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(uacute), '/'}, {')', '('},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(uring), '"'}, {K(section), '!'}, {K(dead_diaeresis), '\''},
+    /* Row B: LSGT, AB01-AB11 */
+    {'\\', '|'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '?'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_cz_qwerty[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {';', K(dead_abovering)}, {'+', '1'}, {K(ecaron), '2'}, {K(scaron), '3'}, {K(ccaron), '4'}, {K(rcaron), '5'}, {K(zcaron), '6'}, {K(yacute), '7'}, {K(aacute), '8'}, {K(iacute), '9'}, {K(eacute), '0'}, {'=', '%'}, {K(dead_acute), K(dead_caron)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(uacute), '/'}, {')', '('},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(uring), '"'}, {K(section), '!'}, {K(dead_diaeresis), '\''},
+    /* Row B: LSGT, AB01-AB11 */
+    {'\\', '|'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '?'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_de[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(dead_circumflex), K(degree)}, {'1', '!'}, {'2', '"'}, {'3', K(section)}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {K(ssharp), '?'}, {K(dead_acute), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(udiaeresis), K(Udiaeresis)}, {'+', '*'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(odiaeresis), K(Odiaeresis)}, {K(adiaeresis), K(Adiaeresis)}, {'#', '\''},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_dk[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(onehalf), K(section)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', K(currency)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'+', '?'}, {K(dead_acute), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(aring), K(Aring)}, {K(dead_diaeresis), K(dead_circumflex)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ae), K(AE)}, {K(oslash), K(Oslash)}, {'\'', '*'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ee[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(dead_caron), K(dead_tilde)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', K(currency)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'+', '?'}, {K(dead_acute), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(udiaeresis), K(Udiaeresis)}, {K(otilde), K(Otilde)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(odiaeresis), K(Odiaeresis)}, {K(adiaeresis), K(Adiaeresis)}, {'\'', '*'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_es[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(masculine), K(ordfeminine)}, {'1', '!'}, {'2', '"'}, {'3', K(periodcentered)}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {K(exclamdown), K(questiondown)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(dead_grave), K(dead_circumflex)}, {'+', '*'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ntilde), K(Ntilde)}, {K(dead_acute), K(dead_diaeresis)}, {K(ccedilla), K(Ccedilla)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_fi[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(section), K(onehalf)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', K(currency)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'+', '?'}, {K(dead_acute), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(aring), K(Aring)}, {K(dead_diaeresis), K(dead_circumflex)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(odiaeresis), K(Odiaeresis)}, {K(adiaeresis), K(Adiaeresis)}, {'\'', '*'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_fr[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(twosuperior), '~'}, {'&', '1'}, {K(eacute), '2'}, {'"', '3'}, {'\'', '4'}, {'(', '5'}, {'-', '6'}, {K(egrave), '7'}, {'_', '8'}, {K(ccedilla), '9'}, {K(agrave), '0'}, {')', K(degree)}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'a', 'A'}, {'z', 'Z'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(dead_circumflex), K(dead_diaeresis)}, {'$', K(sterling)},
+    /* Row C: AC01-AC12 */
+    {'q', 'Q'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {'m', 'M'}, {K(ugrave), '%'}, {'*', K(mu)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'w', 'W'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {',', '?'}, {';', '.'}, {':', '/'}, {'!', K(section)}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_gb[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', K(notsign)}, {'1', '!'}, {'2', '"'}, {'3', K(sterling)}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', ':'}, {'\'', '@'}, {'#', '~'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'\\', '|'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_gr[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {';', ':'}, {K(Greek_finalsmallsigma), K(Greek_SIGMA)}, {K(Greek_epsilon), K(Greek_EPSILON)}, {K(Greek_rho), K(Greek_RHO)}, {K(Greek_tau), K(Greek_TAU)}, {K(Greek_upsilon), K(Greek_UPSILON)}, {K(Greek_theta), K(Greek_THETA)}, {K(Greek_iota), K(Greek_IOTA)}, {K(Greek_omicron), K(Greek_OMICRON)}, {K(Greek_pi), K(Greek_PI)}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {K(Greek_alpha), K(Greek_ALPHA)}, {K(Greek_sigma), K(Greek_SIGMA)}, {K(Greek_delta), K(Greek_DELTA)}, {K(Greek_phi), K(Greek_PHI)}, {K(Greek_gamma), K(Greek_GAMMA)}, {K(Greek_eta), K(Greek_ETA)}, {K(Greek_xi), K(Greek_XI)}, {K(Greek_kappa), K(Greek_KAPPA)}, {K(Greek_lamda), K(Greek_LAMDA)}, {K(dead_acute), K(dead_diaeresis)}, {'\'', '"'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {K(guillemotleft), K(guillemotright)}, {K(Greek_zeta), K(Greek_ZETA)}, {K(Greek_chi), K(Greek_CHI)}, {K(Greek_psi), K(Greek_PSI)}, {K(Greek_omega), K(Greek_OMEGA)}, {K(Greek_beta), K(Greek_BETA)}, {K(Greek_nu), K(Greek_NU)}, {K(Greek_mu), K(Greek_MU)}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_hr[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {'+', '*'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(scaron), K(Scaron)}, {K(dstroke), K(Dstroke)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ccaron), K(Ccaron)}, {K(cacute), K(Cacute)}, {K(zcaron), K(Zcaron)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_hu[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'0', K(section)}, {'1', '\''}, {'2', '"'}, {'3', '+'}, {'4', '!'}, {'5', '%'}, {'6', '/'}, {'7', '='}, {'8', '('}, {'9', ')'}, {K(odiaeresis), K(Odiaeresis)}, {K(udiaeresis), K(Udiaeresis)}, {K(oacute), K(Oacute)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(odoubleacute), K(Odoubleacute)}, {K(uacute), K(Uacute)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(eacute), K(Eacute)}, {K(aacute), K(Aacute)}, {K(udoubleacute), K(Udoubleacute)},
+    /* Row B: LSGT, AB01-AB11 */
+    {K(iacute), K(Iacute)}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '?'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_il[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {';', '~'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', ')'}, {'0', '('}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'/', 'Q'}, {'\'', 'W'}, {K(hebrew_qoph), 'E'}, {K(hebrew_resh), 'R'}, {K(hebrew_aleph), 'T'}, {K(hebrew_tet), 'Y'}, {K(hebrew_waw), 'U'}, {K(hebrew_finalnun), 'I'}, {K(hebrew_finalmem), 'O'}, {K(hebrew_pe), 'P'}, {']', '}'}, {'[', '{'},
+    /* Row C: AC01-AC12 */
+    {K(hebrew_shin), 'A'}, {K(hebrew_dalet), 'S'}, {K(hebrew_gimel), 'D'}, {K(hebrew_kaph), 'F'}, {K(hebrew_ayin), 'G'}, {K(hebrew_yod), 'H'}, {K(hebrew_chet), 'J'}, {K(hebrew_lamed), 'K'}, {K(hebrew_finalkaph), 'L'}, {K(hebrew_finalpe), ':'}, {',', '"'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {K(hebrew_zain), 'Z'}, {K(hebrew_samech), 'X'}, {K(hebrew_bet), 'C'}, {K(hebrew_he), 'V'}, {K(hebrew_nun), 'B'}, {K(hebrew_mem), 'N'}, {K(hebrew_zade), 'M'}, {K(hebrew_taw), '>'}, {K(hebrew_finalzade), '<'}, {'.', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_il_phonetic[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {K(hebrew_qoph), K(hebrew_qoph)}, {K(hebrew_waw), K(hebrew_waw)}, {K(hebrew_aleph), K(hebrew_aleph)}, {K(hebrew_resh), K(hebrew_resh)}, {K(hebrew_taw), K(hebrew_tet)}, {K(hebrew_ayin), K(hebrew_ayin)}, {K(hebrew_waw), K(hebrew_waw)}, {K(hebrew_yod), K(hebrew_yod)}, {K(hebrew_samech), K(hebrew_samech)}, {K(hebrew_pe), K(hebrew_finalpe)}, {}, {},
+    /* Row C: AC01-AC12 */
+    {K(hebrew_aleph), K(hebrew_aleph)}, {K(hebrew_shin), K(hebrew_shin)}, {K(hebrew_dalet), K(hebrew_dalet)}, {K(hebrew_pe), K(hebrew_finalpe)}, {K(hebrew_gimel), K(hebrew_gimel)}, {K(hebrew_he), K(hebrew_he)}, {K(hebrew_yod), K(hebrew_yod)}, {K(hebrew_kaph), K(hebrew_finalkaph)}, {K(hebrew_lamed), K(hebrew_lamed)}, {}, {}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {K(hebrew_zain), K(hebrew_zain)}, {K(hebrew_chet), K(hebrew_chet)}, {K(hebrew_zade), K(hebrew_finalzade)}, {K(hebrew_waw), K(hebrew_waw)}, {K(hebrew_bet), K(hebrew_bet)}, {K(hebrew_nun), K(hebrew_finalnun)}, {K(hebrew_mem), K(hebrew_finalmem)}, {}, {}, {}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_is[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(dead_abovering), K(dead_diaeresis)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {K(odiaeresis), K(Odiaeresis)}, {'-', '_'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(eth), K(ETH)}, {'\'', '?'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ae), K(AE)}, {K(dead_acute), K(dead_acute)}, {'+', '*'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {K(thorn), K(THORN)}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_it[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'\\', '|'}, {'1', '!'}, {'2', '"'}, {'3', K(sterling)}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {K(igrave), '^'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(egrave), K(eacute)}, {'+', '*'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ograve), K(ccedilla)}, {K(agrave), K(degree)}, {K(ugrave), K(section)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_jp_106[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Zenkaku_Hankaku), K(Kanji)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '\''}, {'8', '('}, {'9', ')'}, {'0', '~'}, {'-', '='}, {'^', '~'}, {'\\', '|'},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'@', '`'}, {'[', '{'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', '+'}, {':', '*'}, {']', '}'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {'\\', '_'},
+};
+
+static const xkb_keysym_t main_key_symbols_jp_kana86[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Zenkaku_Hankaku), K(Kanji)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '\''}, {'8', '('}, {'9', ')'}, {'0', K(kana_WO)}, {'-', '='}, {'^', '~'}, {K(yen), '|'},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'@', '`'}, {'[', '{'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', '+'}, {':', '*'}, {']', '}'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {'\\', '_'},
+};
+
+static const xkb_keysym_t main_key_symbols_jp_mac[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Zenkaku_Hankaku), K(Kanji)}, {K(kana_NU)}, {K(kana_FU)}, {K(kana_A), K(kana_a)}, {K(kana_U), K(kana_u)}, {K(kana_E), K(kana_e)}, {K(kana_O), K(kana_o)}, {K(kana_YA), K(kana_ya)}, {K(kana_YU), K(kana_yu)}, {K(kana_YO), K(kana_yo)}, {K(kana_WA), K(kana_WO)}, {K(kana_HO)}, {K(kana_HE)}, {K(prolongedsound)},
+    /* Row D: AD01-AD12 */
+    {K(kana_TA)}, {K(kana_TE)}, {K(kana_I), K(kana_i)}, {K(kana_SU)}, {K(kana_KA)}, {K(kana_N)}, {K(kana_NA)}, {K(kana_NI)}, {K(kana_RA)}, {K(kana_SE)}, {K(voicedsound)}, {K(semivoicedsound), K(kana_openingbracket)},
+    /* Row C: AC01-AC12 */
+    {K(kana_CHI)}, {K(kana_TO)}, {K(kana_SHI)}, {K(kana_HA)}, {K(kana_KI)}, {K(kana_KU)}, {K(kana_MA)}, {K(kana_NO)}, {K(kana_RI)}, {K(kana_RE)}, {K(kana_KE)}, {K(kana_MU), K(kana_closingbracket)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {K(kana_TSU), K(kana_tsu)}, {K(kana_SA)}, {K(kana_SO)}, {K(kana_HI)}, {K(kana_KO)}, {K(kana_MI)}, {K(kana_MO)}, {K(kana_NE), K(kana_comma)}, {K(kana_RU), K(kana_fullstop)}, {K(kana_ME), K(kana_conjunctive)}, {K(kana_RO)},
+};
+
+static const xkb_keysym_t main_key_symbols_lt[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {K(aogonek), K(Aogonek)}, {K(ccaron), K(Ccaron)}, {K(eogonek), K(Eogonek)}, {K(eabovedot), K(Eabovedot)}, {K(iogonek), K(Iogonek)}, {K(scaron), K(Scaron)}, {K(uogonek), K(Uogonek)}, {K(umacron), K(Umacron)}, {K(doublelowquotemark), '('}, {K(leftdoublequotemark), ')'}, {'-', '_'}, {K(zcaron), K(Zcaron)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', ':'}, {'\'', '"'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {K(endash), K(EuroSign)}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_nl[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'@', K(section)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '_'}, {'8', '('}, {'9', ')'}, {'0', '\''}, {'/', '?'}, {K(degree), K(dead_tilde)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(dead_diaeresis), K(dead_circumflex)}, {'*', '|'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {'+', K(plusminus)}, {K(dead_acute), K(dead_grave)}, {'<', '>'},
+    /* Row B: LSGT, AB01-AB11 */
+    {']', '['}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '='}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_no[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'|', K(section)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', K(currency)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'+', '?'}, {'\\', K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(aring), K(Aring)}, {K(dead_diaeresis), K(dead_circumflex)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(oslash), K(Oslash)}, {K(ae), K(AE)}, {'\'', '*'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_pl[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', ':'}, {'\'', '"'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_pl_dvp[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'$', '~'}, {'&', '%'}, {'[', '7'}, {'{', '5'}, {'}', '3'}, {'(', '1'}, {'=', '9'}, {'*', '0'}, {')', '2'}, {'+', '4'}, {']', '6'}, {'!', '8'}, {'#', '`'}, {},
+    /* Row D: AD01-AD12 */
+    {';', ':'}, {',', '<'}, {'.', '>'}, {'p', 'P'}, {'y', 'Y'}, {'f', 'F'}, {'g', 'G'}, {'c', 'C'}, {'r', 'R'}, {'l', 'L'}, {'/', '?'}, {'@', '^'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'o', 'O'}, {'e', 'E'}, {'u', 'U'}, {'i', 'I'}, {'d', 'D'}, {'h', 'H'}, {'t', 'T'}, {'n', 'N'}, {'s', 'S'}, {'-', '_'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'\'', '"'}, {'q', 'Q'}, {'j', 'J'}, {'k', 'K'}, {'x', 'X'}, {'b', 'B'}, {'m', 'M'}, {'w', 'W'}, {'v', 'V'}, {'z', 'Z'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_pt[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'\\', '|'}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {K(guillemotleft), K(guillemotright)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'+', '*'}, {K(dead_acute), K(dead_grave)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ccedilla), K(Ccedilla)}, {K(masculine), K(ordfeminine)}, {K(dead_tilde), K(dead_circumflex)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ru[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Cyrillic_io), K(Cyrillic_IO)}, {'1', '!'}, {'2', '"'}, {'3', K(numerosign)}, {'4', ';'}, {'5', '%'}, {'6', ':'}, {'7', '?'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {K(Cyrillic_shorti), K(Cyrillic_SHORTI)}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Cyrillic_shcha), K(Cyrillic_SHCHA)}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {K(Cyrillic_hardsign), K(Cyrillic_HARDSIGN)},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Cyrillic_yeru), K(Cyrillic_YERU)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Cyrillic_e), K(Cyrillic_E)}, {'\\', '/'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'/', '|'}, {K(Cyrillic_ya), K(Cyrillic_YA)}, {K(Cyrillic_che), K(Cyrillic_CHE)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {K(Cyrillic_i), K(Cyrillic_I)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_softsign), K(Cyrillic_SOFTSIGN)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {K(Cyrillic_yu), K(Cyrillic_YU)}, {'.', ','}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ru_phonetic[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(Cyrillic_yu), K(Cyrillic_YU)}, {'1', '!'}, {'2', '@'}, {'3', K(Cyrillic_io)}, {'4', K(Cyrillic_IO)}, {'5', K(Cyrillic_hardsign)}, {'6', K(Cyrillic_HARDSIGN)}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {K(Cyrillic_che), K(Cyrillic_CHE)}, {},
+    /* Row D: AD01-AD12 */
+    {K(Cyrillic_ya), K(Cyrillic_YA)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_yeru), K(Cyrillic_YERU)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_i), K(Cyrillic_I)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Cyrillic_shcha), K(Cyrillic_SHCHA)},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {K(Cyrillic_shorti), K(Cyrillic_SHORTI)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {';', ':'}, {'\'', '"'}, {K(Cyrillic_e), K(Cyrillic_E)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'|', K(brokenbar)}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_softsign), K(Cyrillic_SOFTSIGN)}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_rs[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] = {
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {'+', '*'}, {},
+    /* Row D: AD01-AD12 */
+    {K(Cyrillic_lje), K(Cyrillic_LJE)}, {K(Cyrillic_nje), K(Cyrillic_NJE)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_i), K(Cyrillic_I)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Serbian_dje), K(Serbian_DJE)},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {K(Cyrillic_je), K(Cyrillic_JE)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {K(Cyrillic_che), K(Cyrillic_CHE)}, {K(Serbian_tshe), K(Serbian_TSHE)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Cyrillic_dzhe), K(Cyrillic_DZHE)}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_se[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(section), K(onehalf)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', K(currency)}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'+', '?'}, {K(dead_acute), K(dead_grave)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(aring), K(Aring)}, {K(dead_diaeresis), K(dead_circumflex)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(odiaeresis), K(Odiaeresis)}, {K(adiaeresis), K(Adiaeresis)}, {'\'', '*'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_si[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(cedilla), K(diaeresis)}, {'1', '!'}, {'2', '"'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'\'', '?'}, {'+', '*'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(scaron), K(Scaron)}, {K(dstroke), K(Dstroke)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ccaron), K(Ccaron)}, {K(cacute), K(Cacute)}, {K(zcaron), K(Zcaron)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', ';'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_sk[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {';', K(dead_abovering)}, {'+', '1'}, {K(lcaron), '2'}, {K(scaron), '3'}, {K(ccaron), '4'}, {K(tcaron), '5'}, {K(zcaron), '6'}, {K(yacute), '7'}, {K(aacute), '8'}, {K(iacute), '9'}, {K(eacute), '0'}, {'=', '%'}, {K(dead_acute), K(dead_caron)}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'z', 'Z'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {K(uacute), '/'}, {K(adiaeresis), '('},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(ocircumflex), '"'}, {K(section), '!'}, {K(ncaron), ')'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'\\', '|'}, {'y', 'Y'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '?'}, {'.', ':'}, {'-', '_'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_th[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'_', '%'}, {K(Thai_lakkhangyao), '+'}, {'/', K(Thai_leknung)}, {'-', K(Thai_leksong)}, {K(Thai_phosamphao), K(Thai_leksam)}, {K(Thai_thothung), K(Thai_leksi)}, {K(Thai_sarau), K(Thai_sarauu)}, {K(Thai_saraue), K(Thai_baht)}, {K(Thai_khokhwai), K(Thai_lekha)}, {K(Thai_totao), K(Thai_lekhok)}, {K(Thai_chochan), K(Thai_lekchet)}, {K(Thai_khokhai), K(Thai_lekpaet)}, {K(Thai_chochang), K(Thai_lekkao)}, {},
+    /* Row D: AD01-AD12 */
+    {K(Thai_maiyamok), K(Thai_leksun)}, {K(Thai_saraaimaimalai), '"'}, {K(Thai_saraam), K(Thai_dochada)}, {K(Thai_phophan), K(Thai_thonangmontho)}, {K(Thai_saraa), K(Thai_thothong)}, {K(Thai_maihanakat), K(Thai_nikhahit)}, {K(Thai_saraii), K(Thai_maitri)}, {K(Thai_rorua), K(Thai_nonen)}, {K(Thai_nonu), K(Thai_paiyannoi)}, {K(Thai_yoyak), K(Thai_yoying)}, {K(Thai_bobaimai), K(Thai_thothan)}, {K(Thai_loling), ','},
+    /* Row C: AC01-AC12 */
+    {K(Thai_fofan), K(Thai_ru)}, {K(Thai_hohip), K(Thai_khorakhang)}, {K(Thai_kokai), K(Thai_topatak)}, {K(Thai_dodek), K(Thai_sarao)}, {K(Thai_sarae), K(Thai_chochoe)}, {K(Thai_maitho), K(Thai_maitaikhu)}, {K(Thai_maiek), K(Thai_maichattawa)}, {K(Thai_saraaa), K(Thai_sorusi)}, {K(Thai_sosua), K(Thai_sosala)}, {K(Thai_wowaen), K(Thai_soso)}, {K(Thai_ngongu), '.'}, {K(Thai_khokhuat), K(Thai_khokhon)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {K(Thai_phophung), '('}, {K(Thai_popla), ')'}, {K(Thai_saraae), K(Thai_choching)}, {K(Thai_oang), K(Thai_honokhuk)}, {K(Thai_sarai), K(Thai_phinthu)}, {K(Thai_sarauee), K(Thai_thanthakhat)}, {K(Thai_thothahan), '?'}, {K(Thai_moma), K(Thai_thophuthao)}, {K(Thai_saraaimaimuan), K(Thai_lochula)}, {K(Thai_fofa), K(Thai_lu)}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_tr[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'"', K(eacute)}, {'1', '!'}, {'2', '\''}, {'3', '^'}, {'4', '+'}, {'5', '%'}, {'6', '&'}, {'7', '/'}, {'8', '('}, {'9', ')'}, {'0', '='}, {'*', '?'}, {'-', '_'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {K(idotless), 'I'}, {'o', 'O'}, {'p', 'P'}, {K(gbreve), K(Gbreve)}, {K(udiaeresis), K(Udiaeresis)},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {K(scedilla), K(Scedilla)}, {'i', K(Iabovedot)}, {',', ';'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {K(odiaeresis), K(Odiaeresis)}, {K(ccedilla), K(Ccedilla)}, {'.', ':'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_tr_f[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'+', '*'}, {'1', '!'}, {'2', '"'}, {'3', '^'}, {'4', '$'}, {'5', '%'}, {'6', '&'}, {'7', '\''}, {'8', '('}, {'9', ')'}, {'0', '='}, {'/', '?'}, {'-', '_'}, {},
+    /* Row D: AD01-AD12 */
+    {'f', 'F'}, {'g', 'G'}, {K(gbreve), K(Gbreve)}, {K(idotless), 'I'}, {'o', 'O'}, {'d', 'D'}, {'r', 'R'}, {'n', 'N'}, {'h', 'H'}, {'p', 'P'}, {'q', 'Q'}, {'w', 'W'},
+    /* Row C: AC01-AC12 */
+    {'u', 'U'}, {'i', K(Iabovedot)}, {'e', 'E'}, {'a', 'A'}, {K(udiaeresis), K(Udiaeresis)}, {'t', 'T'}, {'k', 'K'}, {'m', 'M'}, {'l', 'L'}, {'y', 'Y'}, {K(scedilla), K(Scedilla)}, {'x', 'X'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {'j', 'J'}, {K(odiaeresis), K(Odiaeresis)}, {'v', 'V'}, {'c', 'C'}, {K(ccedilla), K(Ccedilla)}, {'z', 'Z'}, {'s', 'S'}, {'b', 'B'}, {'.', ':'}, {',', ';'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_ua[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'\'', 0x10002bc}, {'1', '!'}, {'2', '"'}, {'3', K(numerosign)}, {'4', ';'}, {'5', '%'}, {'6', ':'}, {'7', '?'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {K(Cyrillic_shorti), K(Cyrillic_SHORTI)}, {K(Cyrillic_tse), K(Cyrillic_TSE)}, {K(Cyrillic_u), K(Cyrillic_U)}, {K(Cyrillic_ka), K(Cyrillic_KA)}, {K(Cyrillic_ie), K(Cyrillic_IE)}, {K(Cyrillic_en), K(Cyrillic_EN)}, {K(Cyrillic_ghe), K(Cyrillic_GHE)}, {K(Cyrillic_sha), K(Cyrillic_SHA)}, {K(Cyrillic_shcha), K(Cyrillic_SHCHA)}, {K(Cyrillic_ze), K(Cyrillic_ZE)}, {K(Cyrillic_ha), K(Cyrillic_HA)}, {K(Ukrainian_yi), K(Ukrainian_YI)},
+    /* Row C: AC01-AC12 */
+    {K(Cyrillic_ef), K(Cyrillic_EF)}, {K(Ukrainian_i), K(Ukrainian_I)}, {K(Cyrillic_ve), K(Cyrillic_VE)}, {K(Cyrillic_a), K(Cyrillic_A)}, {K(Cyrillic_pe), K(Cyrillic_PE)}, {K(Cyrillic_er), K(Cyrillic_ER)}, {K(Cyrillic_o), K(Cyrillic_O)}, {K(Cyrillic_el), K(Cyrillic_EL)}, {K(Cyrillic_de), K(Cyrillic_DE)}, {K(Cyrillic_zhe), K(Cyrillic_ZHE)}, {K(Ukrainian_ie), K(Ukrainian_IE)}, {K(Ukrainian_ghe_with_upturn), K(Ukrainian_GHE_WITH_UPTURN)},
+    /* Row B: LSGT, AB01-AB11 */
+    {'/', '|'}, {K(Cyrillic_ya), K(Cyrillic_YA)}, {K(Cyrillic_che), K(Cyrillic_CHE)}, {K(Cyrillic_es), K(Cyrillic_ES)}, {K(Cyrillic_em), K(Cyrillic_EM)}, {K(Cyrillic_i), K(Cyrillic_I)}, {K(Cyrillic_te), K(Cyrillic_TE)}, {K(Cyrillic_softsign), K(Cyrillic_SOFTSIGN)}, {K(Cyrillic_be), K(Cyrillic_BE)}, {K(Cyrillic_yu), K(Cyrillic_YU)}, {'.', ','}, {},
+};
+
 static const xkb_keysym_t main_key_symbols_us[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
 {
     /* Row E: TLDE, AE01-AE13 */
@@ -70,8 +648,83 @@ static const xkb_keysym_t main_key_symbols_us[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN
     {'<', '>'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
 };
 
+
+static const xkb_keysym_t main_key_symbols_us_colemak[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'f', 'F'}, {'p', 'P'}, {'g', 'G'}, {'j', 'J'}, {'l', 'L'}, {'u', 'U'}, {'y', 'Y'}, {';', ':'}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'r', 'R'}, {'s', 'S'}, {'t', 'T'}, {'d', 'D'}, {'h', 'H'}, {'n', 'N'}, {'e', 'E'}, {'i', 'I'}, {'o', 'O'}, {'\'', '"'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'-', '_'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'k', 'K'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_us_dvorak[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {'`', '~'}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'[', '{'}, {']', '}'}, {},
+    /* Row D: AD01-AD12 */
+    {'\'', '"'}, {',', '<'}, {'.', '>'}, {'p', 'P'}, {'y', 'Y'}, {'f', 'F'}, {'g', 'G'}, {'c', 'C'}, {'r', 'R'}, {'l', 'L'}, {'/', '?'}, {'=', '+'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'o', 'O'}, {'e', 'E'}, {'u', 'U'}, {'i', 'I'}, {'d', 'D'}, {'h', 'H'}, {'t', 'T'}, {'n', 'N'}, {'s', 'S'}, {'-', '_'}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'<', '>'}, {';', ':'}, {'q', 'Q'}, {'j', 'J'}, {'k', 'K'}, {'x', 'X'}, {'b', 'B'}, {'m', 'M'}, {'w', 'W'}, {'v', 'V'}, {'z', 'Z'}, {},
+};
+
+static const xkb_keysym_t main_key_symbols_us_intl[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    /* Row E: TLDE, AE01-AE13 */
+    {K(dead_grave), K(dead_tilde)}, {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', K(dead_circumflex)}, {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'}, {},
+    /* Row D: AD01-AD12 */
+    {'q', 'Q'}, {'w', 'W'}, {'e', 'E'}, {'r', 'R'}, {'t', 'T'}, {'y', 'Y'}, {'u', 'U'}, {'i', 'I'}, {'o', 'O'}, {'p', 'P'}, {'[', '{'}, {']', '}'},
+    /* Row C: AC01-AC12 */
+    {'a', 'A'}, {'s', 'S'}, {'d', 'D'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {';', ':'}, {K(dead_acute), K(dead_diaeresis)}, {'\\', '|'},
+    /* Row B: LSGT, AB01-AB11 */
+    {'\\', '|'}, {'z', 'Z'}, {'x', 'X'}, {'c', 'C'}, {'v', 'V'}, {'b', 'B'}, {'n', 'N'}, {'m', 'M'}, {',', '<'}, {'.', '>'}, {'/', '?'}, {},
+};
+
 #undef K
 
+/*** The VNC keyboard layout is a special case */
+
+static const WORD main_key_scan_vnc[MAIN_KEY_LEN] =
+{
+    0x02,0x03,0x04,0x05,0x06,0x07,
+    0x08,0x09,0x0A,0x0B,0x0C,0x0D,
+    0x1A,0x1B,0x27,0x28,0x29,0x33,
+    0x34,0x35,0x2B,0x1E,0x30,0x2E,
+    0x20,0x12,0x21,0x22,0x23,0x17,
+    0x24,0x25,0x26,0x32,0x31,0x18,
+    0x19,0x10,0x13,0x1F,0x14,0x16,
+    0x2F,0x11,0x2D,0x15,0x2C,0x56
+};
+
+static const WORD main_key_vkey_vnc[MAIN_KEY_LEN] =
+{
+    '1','2','3','4','5','6',
+    '7','8','9','0',VK_OEM_MINUS,VK_OEM_PLUS,
+    VK_OEM_4,VK_OEM_6,VK_OEM_1,VK_OEM_7,VK_OEM_3,VK_OEM_COMMA,
+    VK_OEM_PERIOD,VK_OEM_2,VK_OEM_5, 'A','B','C',
+    'D','E','F','G','H','I',
+    'J','K','L','M','N','O',
+    'P','Q','R','S','T','U',
+    'V','W','X','Y','Z', VK_OEM_102
+};
+
+static const xkb_keysym_t main_key_symbols_vnc[MAIN_KEY_LEN][MAIN_KEY_SYMBOLS_LEN] =
+{
+    {'1', '!'}, {'2', '@'}, {'3', '#'}, {'4', '$'}, {'5', '%'}, {'6', '^'},
+    {'7', '&'}, {'8', '*'}, {'9', '('}, {'0', ')'}, {'-', '_'}, {'=', '+'},
+    {'[', '{'}, {']', '}'}, {';', ':'}, {'\'', '"'}, {'`', '~'}, {',', '<'},
+    {'.', '>'}, {'/', '?'}, {'\\', '|'}, {'a', 'A'}, {'b', 'B'}, {'c', 'C'},
+    {'d', 'D'}, {'e', 'E'}, {'f', 'F'}, {'g', 'G'}, {'h', 'H'}, {'i', 'I'},
+    {'j', 'J'}, {'k', 'K'}, {'l', 'L'}, {'m', 'M'}, {'n', 'N'}, {'o', 'O'},
+    {'p', 'P'}, {'q', 'Q'}, {'r', 'R'}, {'s', 'S'}, {'t', 'T'}, {'u', 'U'},
+    {'v', 'V'}, {'w', 'W'}, {'x', 'X'}, {'y', 'Y'}, {'z', 'Z'}
+};
+
 /*** Layout table. Add your keyboard mappings to this list */
 static struct {
     LCID lcid; /* input locale identifier, look for LOCALE_ILANGUAGE
@@ -81,7 +734,53 @@ static struct {
     const WORD (*scan)[MAIN_KEY_LEN]; /* scan codes mapping */
     const WORD (*vkey)[MAIN_KEY_LEN]; /* virtual key codes mapping */
 } main_key_tab[]={
+    {0x0402, "bg_bds", &main_key_symbols_bg_bds, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0402, "bg_phonetic", &main_key_symbols_bg_phonetic, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0405, "cz", &main_key_symbols_cz, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0405, "cz_qwerty", &main_key_symbols_cz_qwerty, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0406, "dk", &main_key_symbols_dk, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0407, "de", &main_key_symbols_de, &main_key_scan_ps2_set1, &main_key_vkey_qwertz},
+    {0x0408, "gr", &main_key_symbols_gr, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
     {0x0409, "us", &main_key_symbols_us, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0409, "us_colemak", &main_key_symbols_us_colemak, &main_key_scan_ps2_set1, &main_key_vkey_colemak},
+    {0x0409, "us_dvorak", &main_key_symbols_us_dvorak, &main_key_scan_ps2_set1, &main_key_vkey_dvorak},
+    {0x0409, "us_intl", &main_key_symbols_us_intl, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0409, "vnc", &main_key_symbols_vnc, &main_key_scan_vnc, &main_key_vkey_vnc},
+    {0x040a, "es", &main_key_symbols_es, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x040b, "fi", &main_key_symbols_fi, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x040c, "fr", &main_key_symbols_fr, &main_key_scan_ps2_set1, &main_key_vkey_azerty},
+    {0x040d, "il", &main_key_symbols_il, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x040d, "il_phonetic", &main_key_symbols_il_phonetic, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x040e, "hu", &main_key_symbols_hu, &main_key_scan_ps2_set1, &main_key_vkey_qwertz},
+    {0x040f, "is", &main_key_symbols_is, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0410, "it", &main_key_symbols_it, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0411, "jp_106", &main_key_symbols_jp_106, &main_key_scan_ps2_set1, &main_key_vkey_qwerty_jp106},
+    {0x0411, "jp_kana86", &main_key_symbols_jp_kana86, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0411, "jp_mac", &main_key_symbols_jp_mac, &main_key_scan_ps2_set1, &main_key_vkey_qwerty_jp106},
+    {0x0413, "nl", &main_key_symbols_nl, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0414, "no", &main_key_symbols_no, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0415, "pl_dvp", &main_key_symbols_pl_dvp, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0416, "br_abnt2", &main_key_symbols_br_abnt2, &main_key_scan_ps2_set1, &main_key_vkey_abnt_qwerty},
+    {0x0419, "ru", &main_key_symbols_ru, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0419, "ru_phonetic", &main_key_symbols_ru_phonetic, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x041a, "hr", &main_key_symbols_hr, &main_key_scan_ps2_set1, &main_key_vkey_qwertz},
+    {0x041b, "sk", &main_key_symbols_sk, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x041d, "se", &main_key_symbols_se, &main_key_scan_ps2_set1, &main_key_vkey_qwerty_v2},
+    {0x041e, "th", &main_key_symbols_th, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x041f, "tr_f", &main_key_symbols_tr_f, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x041f, "tr", &main_key_symbols_tr, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0422, "ua", &main_key_symbols_ua, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0423, "by", &main_key_symbols_by, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0424, "si", &main_key_symbols_si, &main_key_scan_ps2_set1, &main_key_vkey_qwertz},
+    {0x0425, "ee", &main_key_symbols_ee, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0427, "lt", &main_key_symbols_lt, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0807, "ch_de", &main_key_symbols_ch_de, &main_key_scan_ps2_set1, &main_key_vkey_qwertz},
+    {0x0809, "gb", &main_key_symbols_gb, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x080c, "be", &main_key_symbols_be, &main_key_scan_ps2_set1, &main_key_vkey_azerty},
+    {0x0816, "pt", &main_key_symbols_pt, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0c0c, "ca", &main_key_symbols_ca, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x0c1a, "rs", &main_key_symbols_rs, &main_key_scan_ps2_set1, &main_key_vkey_qwerty},
+    {0x100c, "ch_fr", &main_key_symbols_ch_fr, &main_key_scan_ps2_set1, &main_key_vkey_qwertz},
 };
 
 static const WORD xkb_keysym_0xff00_to_vkey[256] =
-- 
2.34.1


From 148cb6df9f162cbeaeec6c57899e62cb44ca39b5 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 6 Sep 2021 14:14:40 +0300
Subject: [PATCH 040/147] winewayland.drv: Implement ToUnicodeEx.

We use the the current XKB state and XKB compose state to perform the
translation.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_keyboard.c | 156 ++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h       |   4 +
 dlls/winewayland.drv/waylanddrv_main.c  |   1 +
 3 files changed, 161 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index 8863df685c3..92ffbfd42a0 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -35,9 +35,11 @@
 #include "waylanddrv.h"
 
 #include "wine/debug.h"
+#include "wine/unicode.h"
 
 #include "winuser.h"
 
+#include <stdlib.h>
 #include <sys/mman.h>
 #include <unistd.h>
 
@@ -58,6 +60,19 @@ static UINT _xkb_keycode_to_vkey(struct wayland_keyboard *keyboard,
            keyboard->xkb_keycode_to_vkey[xkb_keycode] : 0;
 }
 
+static xkb_keycode_t vkey_to_xkb_keycode(struct wayland_keyboard *keyboard, UINT vkey)
+{
+    xkb_keycode_t i;
+
+    for (i = 0; i < ARRAY_SIZE(keyboard->xkb_keycode_to_vkey); i++)
+    {
+        if (keyboard->xkb_keycode_to_vkey[i] == vkey)
+            return i;
+    }
+
+    return 0;
+}
+
 /* xkb keycodes are offset by 8 from linux input keycodes. */
 static inline xkb_keycode_t linux_input_keycode_to_xkb(uint32_t key)
 {
@@ -78,6 +93,64 @@ static void send_keyboard_input(HWND hwnd, WORD vkey, WORD scan, DWORD flags)
     __wine_send_input(hwnd, &input, NULL);
 }
 
+static WCHAR dead_xkb_keysym_to_wchar(xkb_keysym_t xkb_keysym)
+{
+    switch (xkb_keysym)
+    {
+    case XKB_KEY_dead_grave: return 0x0060;
+    case XKB_KEY_dead_acute: return 0x00B4;
+    case XKB_KEY_dead_circumflex: return 0x005E;
+    case XKB_KEY_dead_tilde: return 0x007E;
+    case XKB_KEY_dead_macron: return 0x00AF;
+    case XKB_KEY_dead_breve: return 0x02D8;
+    case XKB_KEY_dead_abovedot: return 0x02D9;
+    case XKB_KEY_dead_diaeresis: return 0x00A8;
+    case XKB_KEY_dead_abovering: return 0x02DA;
+    case XKB_KEY_dead_doubleacute: return 0x02DD;
+    case XKB_KEY_dead_caron: return 0x02C7;
+    case XKB_KEY_dead_cedilla: return 0x00B8;
+    case XKB_KEY_dead_ogonek: return 0x02DB;
+    case XKB_KEY_dead_iota: return 0x037A;
+    case XKB_KEY_dead_voiced_sound: return 0x309B;
+    case XKB_KEY_dead_semivoiced_sound: return 0x309C;
+    case XKB_KEY_dead_belowdot: return 0x002E;
+    case XKB_KEY_dead_stroke: return 0x002D;
+    case XKB_KEY_dead_abovecomma: return 0x1FBF;
+    case XKB_KEY_dead_abovereversedcomma: return 0x1FFE;
+    case XKB_KEY_dead_doublegrave: return 0x02F5;
+    case XKB_KEY_dead_belowring: return 0x02F3;
+    case XKB_KEY_dead_belowmacron: return 0x02CD;
+    case XKB_KEY_dead_belowtilde: return 0x02F7;
+    case XKB_KEY_dead_currency: return 0x00A4;
+    case XKB_KEY_dead_lowline: return 0x005F;
+    case XKB_KEY_dead_aboveverticalline: return 0x02C8;
+    case XKB_KEY_dead_belowverticalline: return 0x02CC;
+    case XKB_KEY_dead_longsolidusoverlay: return 0x002F;
+    case XKB_KEY_dead_a: return 0x0061;
+    case XKB_KEY_dead_A: return 0x0041;
+    case XKB_KEY_dead_e: return 0x0065;
+    case XKB_KEY_dead_E: return 0x0045;
+    case XKB_KEY_dead_i: return 0x0069;
+    case XKB_KEY_dead_I: return 0x0049;
+    case XKB_KEY_dead_o: return 0x006F;
+    case XKB_KEY_dead_O: return 0x004F;
+    case XKB_KEY_dead_u: return 0x0075;
+    case XKB_KEY_dead_U: return 0x0055;
+    case XKB_KEY_dead_small_schwa: return 0x0259;
+    case XKB_KEY_dead_capital_schwa: return 0x018F;
+    /* The following are non-spacing characters, couldn't find good
+     * spacing alternatives. */
+    case XKB_KEY_dead_hook: return 0x0309;
+    case XKB_KEY_dead_horn: return 0x031B;
+    case XKB_KEY_dead_belowcircumflex: return 0x032D;
+    case XKB_KEY_dead_belowbreve: return 0x032E;
+    case XKB_KEY_dead_belowdiaeresis: return 0x0324;
+    case XKB_KEY_dead_invertedbreve: return 0x0311;
+    case XKB_KEY_dead_belowcomma: return 0x0326;
+    default: return 0;
+    }
+}
+
 /* Get the vkey corresponding to an xkb keycode, potentially translating it to
  * take into account the current keyboard state. */
 static UINT translate_xkb_keycode_to_vkey(struct wayland_keyboard *keyboard,
@@ -175,6 +248,8 @@ static void keyboard_handle_keymap(void *data, struct wl_keyboard *keyboard,
 
     xkb_state_unref(wayland->keyboard.xkb_state);
     wayland->keyboard.xkb_state = xkb_state;
+    if (wayland->keyboard.xkb_compose_state)
+        xkb_compose_state_reset(wayland->keyboard.xkb_compose_state);
 
     wayland_keyboard_update_layout(&wayland->keyboard);
 
@@ -390,6 +465,17 @@ static const struct wl_keyboard_listener keyboard_listener = {
 void wayland_keyboard_init(struct wayland_keyboard *keyboard, struct wayland *wayland,
                            struct wl_keyboard *wl_keyboard)
 {
+    struct xkb_compose_table *compose_table;
+    const char *locale;
+
+    locale = getenv("LC_ALL");
+    if (!locale || !*locale)
+        locale = getenv("LC_CTYPE");
+    if (!locale || !*locale)
+        locale = getenv("LANG");
+    if (!locale || !*locale)
+        locale = "C";
+
     keyboard->wl_keyboard = wl_keyboard;
     /* Some sensible default values for the repeat rate and delay. */
     keyboard->repeat_interval_ms = 40;
@@ -400,6 +486,20 @@ void wayland_keyboard_init(struct wayland_keyboard *keyboard, struct wayland *wa
         ERR("Failed to create XKB context\n");
         return;
     }
+    compose_table =
+        xkb_compose_table_new_from_locale(keyboard->xkb_context, locale,
+                                          XKB_COMPOSE_COMPILE_NO_FLAGS);
+    if (!compose_table)
+    {
+        ERR("Failed to create XKB compose table\n");
+        return;
+    }
+
+    keyboard->xkb_compose_state =
+        xkb_compose_state_new(compose_table, XKB_COMPOSE_STATE_NO_FLAGS);
+    xkb_compose_table_unref(compose_table);
+    if (!keyboard->xkb_compose_state)
+        ERR("Failed to create XKB compose table\n");
 
     wl_keyboard_add_listener(keyboard->wl_keyboard, &keyboard_listener, wayland);
 }
@@ -412,8 +512,64 @@ void wayland_keyboard_deinit(struct wayland_keyboard *keyboard)
     if (keyboard->wl_keyboard)
         wl_keyboard_destroy(keyboard->wl_keyboard);
 
+    xkb_compose_state_unref(keyboard->xkb_compose_state);
     xkb_state_unref(keyboard->xkb_state);
     xkb_context_unref(keyboard->xkb_context);
 
     memset(keyboard, 0, sizeof(*keyboard));
 }
+
+/***********************************************************************
+ *           WAYLAND_ToUnicodeEx
+ */
+INT CDECL WAYLAND_ToUnicodeEx(UINT virt, UINT scan, const BYTE *state,
+                              LPWSTR buf, int nchars, UINT flags, HKL hkl)
+{
+    struct wayland *wayland = thread_init_wayland();
+    char utf8[64];
+    int utf8_len = 0;
+    struct xkb_compose_state *compose_state = wayland->keyboard.xkb_compose_state;
+    enum xkb_compose_status compose_status = XKB_COMPOSE_NOTHING;
+    xkb_keycode_t xkb_keycode;
+    xkb_keysym_t xkb_keysym;
+
+    if (!wayland->keyboard.xkb_state) return 0;
+
+    if (scan & 0x8000) return 0;  /* key up */
+
+    xkb_keycode = vkey_to_xkb_keycode(&wayland->keyboard, virt);
+
+    /* Try to compose */
+    xkb_keysym = xkb_state_key_get_one_sym(wayland->keyboard.xkb_state, xkb_keycode);
+    if (xkb_keysym != XKB_KEY_NoSymbol && compose_state &&
+        xkb_compose_state_feed(compose_state, xkb_keysym) == XKB_COMPOSE_FEED_ACCEPTED)
+    {
+        compose_status = xkb_compose_state_get_status(compose_state);
+    }
+
+    TRACE_(key)("vkey=0x%x scan=0x%x xkb_keycode=%d xkb_keysym=0x%x compose_status=%d\n",
+                virt, scan, xkb_keycode, xkb_keysym, compose_status);
+
+    if (compose_status == XKB_COMPOSE_NOTHING)
+    {
+        utf8_len = xkb_state_key_get_utf8(wayland->keyboard.xkb_state,
+                                          xkb_keycode, utf8, sizeof(utf8));
+    }
+    else if (compose_status == XKB_COMPOSE_COMPOSED)
+    {
+        utf8_len = xkb_compose_state_get_utf8(compose_state, utf8, sizeof(utf8));
+        TRACE_(key)("composed\n");
+    }
+    else if (compose_status == XKB_COMPOSE_COMPOSING && nchars > 0)
+    {
+        if ((buf[0] = dead_xkb_keysym_to_wchar(xkb_keysym)))
+        {
+            TRACE_(key)("returning dead char 0x%04x\n", buf[0]);
+            return -1;
+        }
+    }
+
+    TRACE_(key)("utf8 len=%d '%s'\n", utf8_len, utf8_len ? utf8 : "");
+
+    return MultiByteToWideChar(CP_UTF8, 0, utf8, utf8_len, buf, nchars);
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index a63cf617338..25178127ff7 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -28,6 +28,7 @@
 #include <stdarg.h>
 #include <wayland-client.h>
 #include <xkbcommon/xkbcommon.h>
+#include <xkbcommon/xkbcommon-compose.h>
 #include "xdg-output-unstable-v1-client-protocol.h"
 #include "xdg-shell-client-protocol.h"
 
@@ -82,6 +83,7 @@ struct wayland_keyboard
     uint32_t enter_serial;
     struct xkb_context *xkb_context;
     struct xkb_state *xkb_state;
+    struct xkb_compose_state *xkb_compose_state;
     UINT xkb_keycode_to_vkey[256];
     WORD xkb_keycode_to_scancode[256];
 };
@@ -371,6 +373,8 @@ extern BOOL CDECL WAYLAND_EnumDisplaySettingsEx(LPCWSTR name, DWORD n, LPDEVMODE
 extern DWORD CDECL WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
                                                        DWORD timeout, DWORD mask, DWORD flags) DECLSPEC_HIDDEN;
 extern void CDECL WAYLAND_SetCursor(HCURSOR hcursor) DECLSPEC_HIDDEN;
+extern INT CDECL WAYLAND_ToUnicodeEx(UINT virt, UINT scan, const BYTE *state,
+                                     LPWSTR buf, int nchars, UINT flags, HKL hkl) DECLSPEC_HIDDEN;
 extern void CDECL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
                                                BOOL force, void *param) DECLSPEC_HIDDEN;
 extern LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index d8ede04bf57..c0968b2be61 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -126,6 +126,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pEnumDisplaySettingsEx = WAYLAND_EnumDisplaySettingsEx,
     .pMsgWaitForMultipleObjectsEx = WAYLAND_MsgWaitForMultipleObjectsEx,
     .pSetCursor = WAYLAND_SetCursor,
+    .pToUnicodeEx = WAYLAND_ToUnicodeEx,
     .pThreadDetach = WAYLAND_ThreadDetach,
     .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
     .pWindowMessage = WAYLAND_WindowMessage,
-- 
2.34.1


From 0176098df23b92fb21c1506c8aab544bbbf84ee9 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 6 Sep 2021 14:20:54 +0300
Subject: [PATCH 041/147] winewayland.drv: Implement GetKeyNameText.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_keyboard.c | 178 ++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h       |   1 +
 dlls/winewayland.drv/waylanddrv_main.c  |   1 +
 3 files changed, 180 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index 92ffbfd42a0..2893b9da107 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -46,6 +46,99 @@
 WINE_DEFAULT_DEBUG_CHANNEL(keyboard);
 WINE_DECLARE_DEBUG_CHANNEL(key);
 
+static const struct
+{
+    DWORD       vkey;
+    const char *name;
+} vkey_names[] = {
+    { VK_ADD,                   "Num +" },
+    { VK_BACK,                  "Backspace" },
+    { VK_CAPITAL,               "Caps Lock" },
+    { VK_CONTROL,               "Ctrl" },
+    { VK_DECIMAL,               "Num Del" },
+    { VK_DELETE,                "Delete" },
+    { VK_DIVIDE,                "Num /" },
+    { VK_DOWN,                  "Down" },
+    { VK_END,                   "End" },
+    { VK_ESCAPE,                "Esc" },
+    { VK_F1,                    "F1" },
+    { VK_F2,                    "F2" },
+    { VK_F3,                    "F3" },
+    { VK_F4,                    "F4" },
+    { VK_F5,                    "F5" },
+    { VK_F6,                    "F6" },
+    { VK_F7,                    "F7" },
+    { VK_F8,                    "F8" },
+    { VK_F9,                    "F9" },
+    { VK_F10,                   "F10" },
+    { VK_F11,                   "F11" },
+    { VK_F12,                   "F12" },
+    { VK_F13,                   "F13" },
+    { VK_F14,                   "F14" },
+    { VK_F15,                   "F15" },
+    { VK_F16,                   "F16" },
+    { VK_F17,                   "F17" },
+    { VK_F18,                   "F18" },
+    { VK_F19,                   "F19" },
+    { VK_F20,                   "F20" },
+    { VK_F21,                   "F21" },
+    { VK_F22,                   "F22" },
+    { VK_F23,                   "F23" },
+    { VK_F24,                   "F24" },
+    { VK_HELP,                  "Help" },
+    { VK_HOME,                  "Home" },
+    { VK_INSERT,                "Insert" },
+    { VK_LCONTROL,              "Ctrl" },
+    { VK_LEFT,                  "Left" },
+    { VK_LMENU,                 "Alt" },
+    { VK_LSHIFT,                "Shift" },
+    { VK_LWIN,                  "Win" },
+    { VK_MENU,                  "Alt" },
+    { VK_MULTIPLY,              "Num *" },
+    { VK_NEXT,                  "Page Down" },
+    { VK_NUMLOCK,               "Num Lock" },
+    { VK_NUMPAD0,               "Num 0" },
+    { VK_NUMPAD1,               "Num 1" },
+    { VK_NUMPAD2,               "Num 2" },
+    { VK_NUMPAD3,               "Num 3" },
+    { VK_NUMPAD4,               "Num 4" },
+    { VK_NUMPAD5,               "Num 5" },
+    { VK_NUMPAD6,               "Num 6" },
+    { VK_NUMPAD7,               "Num 7" },
+    { VK_NUMPAD8,               "Num 8" },
+    { VK_NUMPAD9,               "Num 9" },
+    { VK_OEM_CLEAR,             "Num Clear" },
+    { VK_OEM_NEC_EQUAL,         "Num =" },
+    { VK_PRIOR,                 "Page Up" },
+    { VK_RCONTROL,              "Right Ctrl" },
+    { VK_RETURN,                "Return" },
+    { VK_RETURN,                "Num Enter" },
+    { VK_RIGHT,                 "Right" },
+    { VK_RMENU,                 "Right Alt" },
+    { VK_RSHIFT,                "Right Shift" },
+    { VK_RWIN,                  "Right Win" },
+    { VK_SEPARATOR,             "Num ," },
+    { VK_SHIFT,                 "Shift" },
+    { VK_SPACE,                 "Space" },
+    { VK_SUBTRACT,              "Num -" },
+    { VK_TAB,                   "Tab" },
+    { VK_UP,                    "Up" },
+    { VK_VOLUME_DOWN,           "Volume Down" },
+    { VK_VOLUME_MUTE,           "Mute" },
+    { VK_VOLUME_UP,             "Volume Up" },
+    { VK_OEM_MINUS,             "-" },
+    { VK_OEM_PLUS,              "=" },
+    { VK_OEM_1,                 ";" },
+    { VK_OEM_2,                 "/" },
+    { VK_OEM_3,                 "`" },
+    { VK_OEM_4,                 "[" },
+    { VK_OEM_5,                 "\\" },
+    { VK_OEM_6,                 "]" },
+    { VK_OEM_7,                 "'" },
+    { VK_OEM_COMMA,             "," },
+    { VK_OEM_PERIOD,            "." },
+};
+
 static DWORD _xkb_keycode_to_scancode(struct wayland_keyboard *keyboard,
                                       xkb_keycode_t xkb_keycode)
 {
@@ -53,6 +146,17 @@ static DWORD _xkb_keycode_to_scancode(struct wayland_keyboard *keyboard,
            keyboard->xkb_keycode_to_scancode[xkb_keycode] : 0;
 }
 
+static xkb_keycode_t scancode_to_xkb_keycode(struct wayland_keyboard *keyboard, WORD scan)
+{
+    UINT j;
+
+    for (j = 0; j < ARRAY_SIZE(keyboard->xkb_keycode_to_scancode); j++)
+        if ((keyboard->xkb_keycode_to_scancode[j] & 0xff) == (scan & 0xff))
+            return j;
+
+    return 0;
+}
+
 static UINT _xkb_keycode_to_vkey(struct wayland_keyboard *keyboard,
                                  xkb_keycode_t xkb_keycode)
 {
@@ -73,6 +177,22 @@ static xkb_keycode_t vkey_to_xkb_keycode(struct wayland_keyboard *keyboard, UINT
     return 0;
 }
 
+static UINT scancode_to_vkey(struct wayland_keyboard *keyboard, DWORD scan)
+{
+    return _xkb_keycode_to_vkey(keyboard, scancode_to_xkb_keycode(keyboard, scan));
+}
+
+static const char* vkey_to_name(UINT vkey)
+{
+    UINT j;
+
+    for (j = 0; j < ARRAY_SIZE(vkey_names); j++)
+        if (vkey_names[j].vkey == vkey)
+            return vkey_names[j].name;
+
+    return NULL;
+}
+
 /* xkb keycodes are offset by 8 from linux input keycodes. */
 static inline xkb_keycode_t linux_input_keycode_to_xkb(uint32_t key)
 {
@@ -573,3 +693,61 @@ INT CDECL WAYLAND_ToUnicodeEx(UINT virt, UINT scan, const BYTE *state,
 
     return MultiByteToWideChar(CP_UTF8, 0, utf8, utf8_len, buf, nchars);
 }
+
+/***********************************************************************
+ *           GetKeyNameText
+ */
+INT CDECL WAYLAND_GetKeyNameText(LONG lparam, LPWSTR buffer, INT size)
+{
+    struct wayland *wayland = thread_init_wayland();
+    int scan, vkey, len;
+    const char *name;
+    char key[2];
+
+    scan = (lparam >> 16) & 0x1FF;
+    vkey = scancode_to_vkey(&wayland->keyboard, scan);
+
+    if (lparam & (1 << 25))
+    {
+        /* Caller doesn't care about distinctions between left and
+           right keys. */
+        switch (vkey)
+        {
+        case VK_LSHIFT:
+        case VK_RSHIFT:
+            vkey = VK_SHIFT; break;
+        case VK_LCONTROL:
+        case VK_RCONTROL:
+            vkey = VK_CONTROL; break;
+        case VK_LMENU:
+        case VK_RMENU:
+            vkey = VK_MENU; break;
+        }
+    }
+
+    if ((vkey >= 0x30 && vkey <= 0x39) || (vkey >= 0x41 && vkey <= 0x5a))
+    {
+        key[0] = vkey;
+        if (vkey >= 0x41)
+            key[0] += 0x20;
+        key[1] = 0;
+        name = key;
+    }
+    else
+    {
+        name = vkey_to_name(vkey);
+    }
+
+    len = MultiByteToWideChar(CP_UTF8, 0, name, -1, buffer, size);
+    if (len) len--;
+
+    if (!len)
+    {
+        static const WCHAR format[] = {'K','e','y',' ','0','x','%','0','2','x',0};
+        snprintfW(buffer, size, format, vkey);
+        len = strlenW(buffer);
+    }
+
+    TRACE_(key)("lparam 0x%08x -> %s\n", lparam, debugstr_w(buffer));
+    return len;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 25178127ff7..74f9265a00d 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -370,6 +370,7 @@ int _xkb_keysyms_to_utf8(const xkb_keysym_t *syms, int nsyms, char *utf8, int ut
 extern BOOL CDECL WAYLAND_CreateWindow(HWND hwnd) DECLSPEC_HIDDEN;
 extern void CDECL WAYLAND_DestroyWindow(HWND hwnd) DECLSPEC_HIDDEN;
 extern BOOL CDECL WAYLAND_EnumDisplaySettingsEx(LPCWSTR name, DWORD n, LPDEVMODEW devmode, DWORD flags) DECLSPEC_HIDDEN;
+extern INT CDECL WAYLAND_GetKeyNameText(LONG lparam, LPWSTR buffer, INT size) DECLSPEC_HIDDEN;
 extern DWORD CDECL WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
                                                        DWORD timeout, DWORD mask, DWORD flags) DECLSPEC_HIDDEN;
 extern void CDECL WAYLAND_SetCursor(HCURSOR hcursor) DECLSPEC_HIDDEN;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index c0968b2be61..3ef31fab2c2 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -124,6 +124,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pCreateWindow = WAYLAND_CreateWindow,
     .pDestroyWindow = WAYLAND_DestroyWindow,
     .pEnumDisplaySettingsEx = WAYLAND_EnumDisplaySettingsEx,
+    .pGetKeyNameText = WAYLAND_GetKeyNameText,
     .pMsgWaitForMultipleObjectsEx = WAYLAND_MsgWaitForMultipleObjectsEx,
     .pSetCursor = WAYLAND_SetCursor,
     .pToUnicodeEx = WAYLAND_ToUnicodeEx,
-- 
2.34.1


From 6900a670c315c5b753f01ff011c53e5e451641e1 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 6 Sep 2021 14:24:49 +0300
Subject: [PATCH 042/147] winewayland.drv: Implement MapVirtualKeyEx.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_keyboard.c | 135 ++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h       |   1 +
 dlls/winewayland.drv/waylanddrv_main.c  |   1 +
 3 files changed, 137 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index 2893b9da107..85f5cc477a4 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -177,6 +177,11 @@ static xkb_keycode_t vkey_to_xkb_keycode(struct wayland_keyboard *keyboard, UINT
     return 0;
 }
 
+static WORD vkey_to_scancode(struct wayland_keyboard *keyboard, UINT vkey)
+{
+    return _xkb_keycode_to_scancode(keyboard, vkey_to_xkb_keycode(keyboard, vkey));
+}
+
 static UINT scancode_to_vkey(struct wayland_keyboard *keyboard, DWORD scan)
 {
     return _xkb_keycode_to_vkey(keyboard, scancode_to_xkb_keycode(keyboard, scan));
@@ -271,6 +276,28 @@ static WCHAR dead_xkb_keysym_to_wchar(xkb_keysym_t xkb_keysym)
     }
 }
 
+static WCHAR _xkb_keysyms_to_wchar(const xkb_keysym_t *syms, int nsyms)
+{
+    char utf8[64];
+    int utf8_len;
+    WCHAR wchars[8];
+    WCHAR normalized[8];
+    int nchars;
+
+    utf8_len = _xkb_keysyms_to_utf8(syms, nsyms, utf8, sizeof(utf8));
+
+    nchars = MultiByteToWideChar(CP_UTF8, 0, utf8, utf8_len, wchars,
+                                 ARRAY_SIZE(wchars));
+    if (nchars == 0)
+        return 0;
+
+    if (NormalizeString(NormalizationC, wchars, nchars, normalized,
+                        ARRAY_SIZE(normalized)) != 1)
+        return 0;
+
+    return normalized[0];
+}
+
 /* Get the vkey corresponding to an xkb keycode, potentially translating it to
  * take into account the current keyboard state. */
 static UINT translate_xkb_keycode_to_vkey(struct wayland_keyboard *keyboard,
@@ -311,6 +338,48 @@ static UINT translate_xkb_keycode_to_vkey(struct wayland_keyboard *keyboard,
     return vkey;
 }
 
+static UINT map_vkey_to_wchar_with_deadchar_bit(struct wayland_keyboard *keyboard, UINT vkey)
+{
+    WCHAR wchar;
+    xkb_keycode_t xkb_keycode;
+    struct xkb_keymap *xkb_keymap;
+    xkb_layout_index_t layout;
+    const xkb_keysym_t *syms;
+    int nsyms;
+
+    if (!keyboard->xkb_state) return 0;
+
+    layout = _xkb_state_get_active_layout(keyboard->xkb_state);
+    if (layout == XKB_LAYOUT_INVALID)
+    {
+        TRACE_(key)("no active layout, returning wchar 0\n");
+        return 0;
+    }
+
+    xkb_keymap = xkb_state_get_keymap(keyboard->xkb_state);
+    xkb_keycode = vkey_to_xkb_keycode(keyboard, vkey);
+
+    nsyms = xkb_keymap_key_get_syms_by_level(xkb_keymap, xkb_keycode,
+                                             layout, 0, &syms);
+    if (nsyms > 0)
+    {
+        /* Set the high bit to 1 if this is dead char. */
+        if ((wchar = dead_xkb_keysym_to_wchar(syms[0])))
+            wchar |= 0x80000000;
+        else
+            wchar = _xkb_keysyms_to_wchar(syms, nsyms);
+    }
+    else
+    {
+        wchar = 0;
+    }
+
+    TRACE_(key)("vkey=0x%x xkb_keycode=%d nsyms=%d xkb_keysym[0]=0x%x => wchar=0x%x\n",
+                vkey, xkb_keycode, nsyms, nsyms ? syms[0] : 0, wchar);
+
+    return wchar;
+}
+
 static void wayland_keyboard_emit(struct wayland_keyboard *keyboard, uint32_t key,
                                   uint32_t state, HWND hwnd)
 {
@@ -751,3 +820,69 @@ INT CDECL WAYLAND_GetKeyNameText(LONG lparam, LPWSTR buffer, INT size)
     TRACE_(key)("lparam 0x%08x -> %s\n", lparam, debugstr_w(buffer));
     return len;
 }
+
+/***********************************************************************
+ *           WAYLAND_MapVirtualKeyEx
+ */
+UINT CDECL WAYLAND_MapVirtualKeyEx(UINT code, UINT maptype, HKL hkl)
+{
+    struct wayland *wayland = thread_init_wayland();
+    UINT ret = 0;
+
+    TRACE_(key)("code=0x%x, maptype=%d, hkl %p\n", code, maptype, hkl);
+
+    switch (maptype)
+    {
+    case MAPVK_VK_TO_VSC_EX:
+    case MAPVK_VK_TO_VSC:
+        /* vkey to scancode */
+        switch (code)
+        {
+        case VK_SHIFT:
+            code = VK_LSHIFT;
+            break;
+        case VK_CONTROL:
+            code = VK_LCONTROL;
+            break;
+        case VK_MENU:
+            code = VK_LMENU;
+            break;
+        }
+
+        ret = vkey_to_scancode(&wayland->keyboard, code);
+
+        /* set scan code prefix */
+        if (maptype == MAPVK_VK_TO_VSC_EX &&
+            (code == VK_RCONTROL || code == VK_RMENU))
+            ret |= 0xe000;
+        break;
+    case MAPVK_VSC_TO_VK:
+    case MAPVK_VSC_TO_VK_EX:
+        /* scancode to vkey */
+        ret = scancode_to_vkey(&wayland->keyboard, code);
+        if (maptype == MAPVK_VSC_TO_VK)
+        {
+            switch (ret)
+            {
+            case VK_LSHIFT:
+            case VK_RSHIFT:
+                ret = VK_SHIFT; break;
+            case VK_LCONTROL:
+            case VK_RCONTROL:
+                ret = VK_CONTROL; break;
+            case VK_LMENU:
+            case VK_RMENU:
+                ret = VK_MENU; break;
+            }
+        }
+        break;
+    case MAPVK_VK_TO_CHAR:
+        ret = map_vkey_to_wchar_with_deadchar_bit(&wayland->keyboard, code);
+        break;
+    default:
+        FIXME("Unknown maptype %d\n", maptype);
+        break;
+    }
+    TRACE_(key)("returning 0x%04x\n", ret);
+    return ret;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 74f9265a00d..f1d24a20942 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -371,6 +371,7 @@ extern BOOL CDECL WAYLAND_CreateWindow(HWND hwnd) DECLSPEC_HIDDEN;
 extern void CDECL WAYLAND_DestroyWindow(HWND hwnd) DECLSPEC_HIDDEN;
 extern BOOL CDECL WAYLAND_EnumDisplaySettingsEx(LPCWSTR name, DWORD n, LPDEVMODEW devmode, DWORD flags) DECLSPEC_HIDDEN;
 extern INT CDECL WAYLAND_GetKeyNameText(LONG lparam, LPWSTR buffer, INT size) DECLSPEC_HIDDEN;
+extern UINT CDECL WAYLAND_MapVirtualKeyEx(UINT code, UINT maptype, HKL hkl) DECLSPEC_HIDDEN;
 extern DWORD CDECL WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
                                                        DWORD timeout, DWORD mask, DWORD flags) DECLSPEC_HIDDEN;
 extern void CDECL WAYLAND_SetCursor(HCURSOR hcursor) DECLSPEC_HIDDEN;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 3ef31fab2c2..fb58349e312 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -125,6 +125,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pDestroyWindow = WAYLAND_DestroyWindow,
     .pEnumDisplaySettingsEx = WAYLAND_EnumDisplaySettingsEx,
     .pGetKeyNameText = WAYLAND_GetKeyNameText,
+    .pMapVirtualKeyEx = WAYLAND_MapVirtualKeyEx,
     .pMsgWaitForMultipleObjectsEx = WAYLAND_MsgWaitForMultipleObjectsEx,
     .pSetCursor = WAYLAND_SetCursor,
     .pToUnicodeEx = WAYLAND_ToUnicodeEx,
-- 
2.34.1


From ca2be1e42296382b8fd9c832cea528030cd4211f Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 6 Sep 2021 14:31:19 +0300
Subject: [PATCH 043/147] winewayland.drv: Implement VkKeyScanEx.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_keyboard.c | 93 +++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h       |  1 +
 dlls/winewayland.drv/waylanddrv_main.c  |  1 +
 3 files changed, 95 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index 85f5cc477a4..aab3eb8a3a3 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -298,6 +298,31 @@ static WCHAR _xkb_keysyms_to_wchar(const xkb_keysym_t *syms, int nsyms)
     return normalized[0];
 }
 
+static SHORT _xkb_mod_mask_to_win32(struct xkb_keymap *xkb_keymap,
+                                    xkb_mod_mask_t mod_mask)
+{
+    xkb_mod_index_t num_mods, i;
+    SHORT ret = 0;
+
+    num_mods = xkb_keymap_num_mods(xkb_keymap);
+    for (i = 0; i < num_mods; i++)
+    {
+        if (mod_mask & (1 << i))
+        {
+            const char *mod_name = xkb_keymap_mod_get_name(xkb_keymap, i);
+
+            if (!strcmp(mod_name, XKB_MOD_NAME_SHIFT))
+                ret |= 0x0100;
+            else if (!strcmp(mod_name, XKB_MOD_NAME_CTRL))
+                ret |= 0x0200;
+            else if (!strcmp(mod_name, XKB_MOD_NAME_ALT))
+                ret |= 0x0400;
+        }
+    }
+
+    return ret;
+}
+
 /* Get the vkey corresponding to an xkb keycode, potentially translating it to
  * take into account the current keyboard state. */
 static UINT translate_xkb_keycode_to_vkey(struct wayland_keyboard *keyboard,
@@ -886,3 +911,71 @@ UINT CDECL WAYLAND_MapVirtualKeyEx(UINT code, UINT maptype, HKL hkl)
     TRACE_(key)("returning 0x%04x\n", ret);
     return ret;
 }
+
+/***********************************************************************
+ *           WAYLAND_VkKeyScanEx
+ */
+SHORT CDECL WAYLAND_VkKeyScanEx(WCHAR ch, HKL hkl)
+{
+    struct wayland *wayland = thread_init_wayland();
+    xkb_layout_index_t layout;
+    struct xkb_state *xkb_state = wayland->keyboard.xkb_state;
+    struct xkb_keymap *xkb_keymap;
+    xkb_keycode_t xkb_keycode, min_xkb_keycode, max_xkb_keycode;
+
+    TRACE_(key)("ch %04x hkl %p ...\n", ch, hkl);
+
+    if (!xkb_state)
+    {
+        TRACE_(key)("... no xkb state , returning -1\n");
+        return -1;
+    }
+
+    layout = _xkb_state_get_active_layout(xkb_state);
+    if (layout == XKB_LAYOUT_INVALID)
+    {
+        TRACE_(key)("... no active layout, returning -1\n");
+        return -1;
+    }
+
+    xkb_keymap = xkb_state_get_keymap(xkb_state);
+    min_xkb_keycode = xkb_keymap_min_keycode(xkb_keymap);
+    max_xkb_keycode = xkb_keymap_max_keycode(xkb_keymap);
+
+    /* Search through all keycodes and their shift levels for one that
+     * produces a keysym that matches the requested character. */
+    for (xkb_keycode = min_xkb_keycode; xkb_keycode <= max_xkb_keycode; xkb_keycode++)
+    {
+        xkb_level_index_t num_levels =
+            xkb_keymap_num_levels_for_key(xkb_keymap, xkb_keycode, layout);
+        xkb_level_index_t level;
+
+        for (level = 0; level < num_levels; level++)
+        {
+            const xkb_keysym_t *syms;
+            int nsyms = xkb_keymap_key_get_syms_by_level(xkb_keymap, xkb_keycode,
+                                                         layout, level, &syms);
+
+            if (_xkb_keysyms_to_wchar(syms, nsyms) == ch)
+            {
+                UINT vkey;
+                xkb_mod_mask_t mod_mask;
+                SHORT ret;
+
+                vkey = _xkb_keycode_to_vkey(&wayland->keyboard, xkb_keycode);
+                if (vkey == 0)
+                    continue;
+
+                xkb_keymap_key_get_mods_for_level(xkb_keymap, xkb_keycode,
+                                                  layout, level, &mod_mask, 1);
+                ret = _xkb_mod_mask_to_win32(xkb_keymap, mod_mask) | vkey;
+
+                TRACE_(key)("... returning %04x\n", ret);
+                return ret;
+            }
+        }
+    }
+
+    TRACE_(key)("... matching vkey not found, returning -1\n");
+    return -1;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index f1d24a20942..b90b982a6ea 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -379,6 +379,7 @@ extern INT CDECL WAYLAND_ToUnicodeEx(UINT virt, UINT scan, const BYTE *state,
                                      LPWSTR buf, int nchars, UINT flags, HKL hkl) DECLSPEC_HIDDEN;
 extern void CDECL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
                                                BOOL force, void *param) DECLSPEC_HIDDEN;
+extern SHORT CDECL WAYLAND_VkKeyScanEx(WCHAR ch, HKL hkl) DECLSPEC_HIDDEN;
 extern LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
 extern void CDECL WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
                                            const RECT *window_rect, const RECT *client_rect,
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index fb58349e312..8e696e71210 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -129,6 +129,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pMsgWaitForMultipleObjectsEx = WAYLAND_MsgWaitForMultipleObjectsEx,
     .pSetCursor = WAYLAND_SetCursor,
     .pToUnicodeEx = WAYLAND_ToUnicodeEx,
+    .pVkKeyScanEx = WAYLAND_VkKeyScanEx,
     .pThreadDetach = WAYLAND_ThreadDetach,
     .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
     .pWindowMessage = WAYLAND_WindowMessage,
-- 
2.34.1


From c28fd0df8cfca0557a759b4f83c218bd4fb6875d Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 8 Sep 2021 11:34:08 +0300
Subject: [PATCH 044/147] winewayland.drv: Refine heuristics for relative
 positioning of windows.

Before this commit, the simple heuristic for using a Wayland subsurface
and relative positioning to display a window was: it doesn't have a
caption AND it has an owner.

Since many applications use unowned top-level windows for various kinds
of popups, this commit enhances our heuristic to detect such windows and
use relative positioning for them too. Since for such windows we don't
have a owner window, and thus a Wayland surface parent to attach them
to, we use the most recent surface the user interacted with as the
effective owner.

The updated heuristic is: If a window has an effective owner AND it
doesn't have a caption, min/max buttons or sysmenu AND it's relatively
small compared to the monitor size THEN we use subsurface/relative
positioning.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_keyboard.c |   1 +
 dlls/winewayland.drv/wayland_pointer.c  |   3 +
 dlls/winewayland.drv/waylanddrv.h       |   1 +
 dlls/winewayland.drv/window.c           | 233 ++++++++++++++++++++++--
 4 files changed, 227 insertions(+), 11 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index aab3eb8a3a3..84046796f4d 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -600,6 +600,7 @@ static void keyboard_handle_key(void *data, struct wl_keyboard *keyboard,
     TRACE("key=%d state=%#x focused_hwnd=%p\n", key, state, focused_hwnd);
 
     wayland->last_dispatch_mask |= QS_KEY | QS_HOTKEY;
+    wayland->last_event_type = INPUT_KEYBOARD;
 
     wayland_keyboard_emit(&wayland->keyboard, key, state, focused_hwnd);
 
diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 06d9ef099cc..6d227e98f80 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -62,6 +62,7 @@ static void pointer_handle_motion_internal(void *data, struct wl_pointer *pointe
     input.mi.dwFlags     = MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE;
 
     wayland->last_dispatch_mask |= QS_MOUSEMOVE;
+    wayland->last_event_type = INPUT_MOUSE;
 
     __wine_send_input(focused_hwnd, &input, NULL);
 }
@@ -158,6 +159,7 @@ static void pointer_handle_button(void *data, struct wl_pointer *wl_pointer,
         input.mi.dwFlags <<= 1;
 
     wayland->last_dispatch_mask |= QS_MOUSEBUTTON;
+    wayland->last_event_type = INPUT_MOUSE;
 
     __wine_send_input(focused_hwnd, &input, NULL);
 }
@@ -210,6 +212,7 @@ static void pointer_handle_axis_discrete(void *data, struct wl_pointer *wl_point
     }
 
     wayland->last_dispatch_mask |= QS_MOUSEBUTTON;
+    wayland->last_event_type = INPUT_MOUSE;
 
     __wine_send_input(focused_hwnd, &input, NULL);
 }
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index b90b982a6ea..c3329b1518b 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -126,6 +126,7 @@ struct wayland
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
     DWORD last_dispatch_mask;
+    DWORD last_event_type;
     int event_notification_pipe[2];
     struct wl_list thread_link;
 };
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index f69cfb0ce8b..72ce622edd8 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -39,6 +39,9 @@ struct wayland_win_data
     HWND           hwnd;
     /* parent hwnd for child windows */
     HWND           parent;
+    /* effective parent hwnd (what the driver considers to
+     * be the parent for relative positioning) */
+    HWND           effective_parent;
     /* USER window rectangle relative to parent */
     RECT           window_rect;
     /* client area relative to parent */
@@ -53,6 +56,9 @@ struct wayland_win_data
     BOOL           has_pending_window_surface;
     /* whether this window is visible */
     BOOL           visible;
+    /* Save previous state to be able to decide when to recreate wayland surface */
+    HWND           old_parent;
+    RECT           old_window_rect;
     /* whether a wayland surface update is needed */
     BOOL           wayland_surface_needs_update;
 };
@@ -179,11 +185,217 @@ static void wayland_surface_for_hwnd_unlock(struct wayland_surface *surface)
     if (surface) LeaveCriticalSection(&win_data_section);
 }
 
+static BOOL can_be_effective_parent(HWND hwnd, HWND parent_hwnd)
+{
+    struct wayland_surface *parent_surface;
+
+    if (parent_hwnd == 0)
+        return FALSE;
+
+    if (parent_hwnd == hwnd)
+    {
+        TRACE("hwnd=%p can't use parent=%p since it's itself\n",
+              hwnd, parent_hwnd);
+        return FALSE;
+    }
+
+    if (!(parent_surface = wayland_surface_for_hwnd_lock(parent_hwnd)))
+    {
+        TRACE("hwnd=%p can't use parent=%p since we are not tracking it\n",
+              hwnd, parent_hwnd);
+        return FALSE;
+    }
+    wayland_surface_for_hwnd_unlock(parent_surface);
+
+    if (!(GetWindowLongW(parent_hwnd, GWL_STYLE) & WS_VISIBLE))
+    {
+        TRACE("hwnd=%p can't use parent=%p since it's not visible\n",
+              hwnd, parent_hwnd);
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+static HWND guess_popup_parent(struct wayland *wayland, HWND hwnd)
+{
+    HWND pointer_hwnd;
+    HWND cursor_hwnd;
+    HWND keyboard_hwnd;
+    HWND focus_hwnd;
+    HWND popup_hwnd;
+    POINT cursor;
+
+    pointer_hwnd = wayland->pointer.focused_surface ?
+                   wayland->pointer.focused_surface->hwnd : NULL;
+    if (pointer_hwnd)
+        pointer_hwnd = GetAncestor(pointer_hwnd, GA_ROOT);
+
+    GetCursorPos(&cursor);
+    cursor_hwnd = WindowFromPoint(cursor);
+    if (cursor_hwnd)
+        cursor_hwnd = GetAncestor(cursor_hwnd, GA_ROOT);
+
+    keyboard_hwnd = wayland->keyboard.focused_surface ?
+                    wayland->keyboard.focused_surface->hwnd : NULL;
+    if (keyboard_hwnd)
+        keyboard_hwnd = GetAncestor(keyboard_hwnd, GA_ROOT);
+
+    focus_hwnd = GetFocus();
+    if (focus_hwnd)
+        focus_hwnd = GetAncestor(focus_hwnd, GA_ROOT);
+
+    TRACE("pointer_hwnd=%p cursor_hwnd=%p keyboard_hwnd=%p focus_hwnd=%p "
+          "last_event_type=%d\n",
+          pointer_hwnd, cursor_hwnd, keyboard_hwnd, focus_hwnd,
+          wayland->last_event_type);
+
+    /* If we have a recent mouse event, the popup parent is likely the window
+     * under the cursor, so prefer it. Otherwise prefer the window with
+     * the keyboard focus. */
+    if (wayland->last_event_type == INPUT_MOUSE)
+    {
+        if (can_be_effective_parent(hwnd, pointer_hwnd))
+            popup_hwnd = pointer_hwnd;
+        else if (can_be_effective_parent(hwnd, cursor_hwnd))
+            popup_hwnd = cursor_hwnd;
+        else if (can_be_effective_parent(hwnd, keyboard_hwnd))
+            popup_hwnd = keyboard_hwnd;
+        else if (can_be_effective_parent(hwnd, focus_hwnd))
+            popup_hwnd = focus_hwnd;
+        else
+            popup_hwnd = 0;
+    }
+    else
+    {
+        if (can_be_effective_parent(hwnd, keyboard_hwnd))
+            popup_hwnd = keyboard_hwnd;
+        else if (can_be_effective_parent(hwnd, focus_hwnd))
+            popup_hwnd = focus_hwnd;
+        else if (can_be_effective_parent(hwnd, pointer_hwnd))
+            popup_hwnd = pointer_hwnd;
+        else if (can_be_effective_parent(hwnd, cursor_hwnd))
+            popup_hwnd = cursor_hwnd;
+        else
+            popup_hwnd = 0;
+    }
+
+    TRACE("=> popup_hwnd=%p\n", popup_hwnd);
+
+    return popup_hwnd;
+}
+
+/* Whether we consider this window to be a transient popup, so we can
+ * display it as a Wayland subsurface with relative positioning. */
+static BOOL wayland_win_data_can_be_popup(struct wayland_win_data *data)
+{
+    DWORD style;
+    HMONITOR hmonitor;
+    MONITORINFO mi;
+    double monitor_width;
+    double monitor_height;
+    int window_width;
+    int window_height;
+
+    style = GetWindowLongW(data->hwnd, GWL_STYLE);
+
+    /* Child windows can't be popups, unless they are children of the desktop
+     * (thus effectively top-level). */
+    if ((style & WS_CHILD) && GetWindowLongPtrW(data->hwnd, GWLP_HWNDPARENT))
+    {
+        TRACE("hwnd=%p is child => FALSE\n", data->hwnd);
+        return FALSE;
+    }
+
+    /* Minimized windows can't be popups. */
+    if (style & WS_MINIMIZE)
+    {
+        TRACE("hwnd=%p is minimized => FALSE\n", data->hwnd);
+        return FALSE;
+    }
+
+    /* If the window has top bar elements, don't consider it a popup candidate. */
+    if ((style & WS_CAPTION) == WS_CAPTION ||
+        (style & (WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)))
+    {
+        TRACE("hwnd=%p style=0x%08x => FALSE\n", data->hwnd, style);
+        return FALSE;
+    }
+
+    mi.cbSize = sizeof(mi);
+    if (!(hmonitor = MonitorFromRect(&data->window_rect, MONITOR_DEFAULTTOPRIMARY)) ||
+        !GetMonitorInfoW(hmonitor, &mi))
+    {
+        SetRectEmpty(&mi.rcMonitor);
+    }
+
+    monitor_width = mi.rcMonitor.right - mi.rcMonitor.left;
+    monitor_height = mi.rcMonitor.bottom - mi.rcMonitor.top;
+    window_width = data->window_rect.right - data->window_rect.left;
+    window_height = data->window_rect.bottom - data->window_rect.top;
+
+    /* If the window has an unreasonably small size or is too large, don't consider
+     * it a popup candidate. */
+    if (window_width <= 1 || window_height <= 1 ||
+        window_width * window_height > 0.5 * monitor_width * monitor_height)
+    {
+        TRACE("hwnd=%p window=%s monitor=%s => FALSE\n",
+              data->hwnd, wine_dbgstr_rect(&data->window_rect),
+              wine_dbgstr_rect(&mi.rcMonitor));
+        return FALSE;
+    }
+
+    TRACE("hwnd=%p style=0x%08x window=%s monitor=%s => TRUE\n",
+          data->hwnd, style, wine_dbgstr_rect(&data->window_rect),
+          wine_dbgstr_rect(&mi.rcMonitor));
+
+    return TRUE;
+}
+
+static HWND wayland_win_data_get_effective_parent(struct wayland_win_data *data)
+{
+    struct wayland *wayland = thread_init_wayland();
+    /* GWLP_HWNDPARENT gets the owner for any kind of toplevel windows,
+     * and the parent for child windows. */
+    HWND parent_hwnd = (HWND)GetWindowLongPtrW(data->hwnd, GWLP_HWNDPARENT);
+    HWND effective_parent_hwnd;
+
+    if (!can_be_effective_parent(data->hwnd, parent_hwnd))
+        parent_hwnd = 0;
+
+    /* Many applications use top level, unowned (or owned by the desktop)
+     * popup windows for menus and tooltips and depend on screen
+     * coordinates for correct positioning. Since wayland can't deal with
+     * screen coordinates, try to guess the effective parent window of such
+     * popups and manage them as wayland subsurfaces. */
+    if (!parent_hwnd && wayland_win_data_can_be_popup(data))
+        effective_parent_hwnd = guess_popup_parent(wayland, data->hwnd);
+    else
+        effective_parent_hwnd = parent_hwnd;
+
+    TRACE("hwnd=%p parent=%p effective_parent=%p\n",
+          data->hwnd, parent_hwnd, effective_parent_hwnd);
+
+    return effective_parent_hwnd;
+}
+
 static BOOL wayland_win_data_wayland_surface_needs_update(struct wayland_win_data *data)
 {
     if (data->wayland_surface_needs_update)
         return TRUE;
 
+    /* Change of parentage (either actual or effective) requires recreating the
+     * whole win_data to ensure we have a properly owned wayland surface. We
+     * check for change of effective parent only if the window changed in any
+     * way, to avoid spuriously reassigning parent windows when new windows
+     * are created. */
+    if ((!EqualRect(&data->window_rect, &data->old_window_rect) &&
+         data->effective_parent != wayland_win_data_get_effective_parent(data)) ||
+        data->parent != data->old_parent)
+    {
+        return TRUE;
+    }
+
     /* If this is currently or potentially a toplevel surface, and its
      * visibility state has changed, recreate win_data so that we only have
      * xdg_toplevels for visible windows. */
@@ -242,7 +454,6 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
     HWND effective_parent_hwnd;
     struct wayland_surface *surface;
     struct wayland_surface *parent_surface;
-    DWORD style;
 
     TRACE("hwnd=%p\n", data->hwnd);
 
@@ -250,9 +461,7 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
 
     wayland = thread_init_wayland();
 
-    /* GWLP_HWNDPARENT gets the owner for any kind of toplevel windows,
-     * and the parent for child windows. */
-    effective_parent_hwnd = (HWND)GetWindowLongPtrW(data->hwnd, GWLP_HWNDPARENT);
+    effective_parent_hwnd = wayland_win_data_get_effective_parent(data);
     parent_surface = NULL;
 
     if (effective_parent_hwnd)
@@ -261,14 +470,14 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
         wayland_surface_for_hwnd_unlock(parent_surface);
     }
 
-    style = GetWindowLongW(data->hwnd, GWL_STYLE);
+    data->effective_parent = effective_parent_hwnd;
 
-    /* Use wayland subsurfaces for children windows and windows that are
-     * transient (i.e., don't have a titlebar). Otherwise, if the window is
-     * visible make it wayland toplevel. Finally, if the window is not visible
-     * create a plain (without a role) surface to avoid polluting the
-     * compositor with empty xdg_toplevels. */
-    if ((style & WS_CAPTION) != WS_CAPTION)
+    /* Use wayland subsurfaces for children windows and toplevels that we
+     * consider to be popups and have an effective parent. Otherwise, if the
+     * window is visible make it wayland toplevel. Finally, if the window is
+     * not visible create a plain (without a role) surface to avoid polluting
+     * the compositor with empty xdg_toplevels. */
+    if (parent_surface && (data->parent || wayland_win_data_can_be_popup(data)))
     {
         surface = update_surface_for_role(data, WAYLAND_SURFACE_ROLE_SUBSURFACE,
                                           wayland, parent_surface);
@@ -368,6 +577,8 @@ BOOL CDECL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flag
 
     if (!data && !(data = wayland_win_data_create(hwnd))) return TRUE;
 
+    data->old_parent = data->parent;
+    data->old_window_rect = data->window_rect;
     data->parent = (parent == GetDesktopWindow()) ? 0 : parent;
     data->window_rect = *window_rect;
     data->client_rect = *client_rect;
-- 
2.34.1


From 501d0411d07cdc2e6726788500c7030dbee2a012 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 8 Sep 2021 12:01:12 +0300
Subject: [PATCH 045/147] winewayland.drv: Update Wayland surface state.

When the properties of window change, update the state of the Wayland
surface backing that window. This potentially involves requesting a
state change from the compositor and setting proper values for the
surface geometry and subsurface position, when applicable.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c |  92 ++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |   5 +
 dlls/winewayland.drv/window.c          | 188 +++++++++++++++++++++++++
 3 files changed, 285 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 40535d8be58..d76f3bbb29d 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -264,6 +264,98 @@ void wayland_surface_clear_role(struct wayland_surface *surface)
     wayland_surface_unmap(surface);
 }
 
+/**********************************************************************
+ *          wayland_surface_reconfigure_position
+ *
+ * Configures the position of a wayland surface relative to its parent.
+ * This only applies to surfaces having the subsurface role.
+ *
+ * The coordinates should be given in wine's coordinate space.
+ *
+ * This function sets up but doesn't actually apply any new configuration.
+ * The wayland_surface_reconfigure_apply() needs to be called for changes
+ * to take effect.
+ */
+void wayland_surface_reconfigure_position(struct wayland_surface *surface,
+                                          int wine_x, int wine_y)
+{
+    int x, y;
+
+    wayland_surface_coords_rounded_from_wine(surface, wine_x, wine_y, &x, &y);
+
+    TRACE("surface=%p hwnd=%p wine=%d,%d wayland=%d,%d\n",
+          surface, surface->hwnd, wine_x, wine_y, x, y);
+
+    if (surface->wl_subsurface)
+        wl_subsurface_set_position(surface->wl_subsurface, x, y);
+}
+
+/**********************************************************************
+ *          wayland_surface_reconfigure_geometry
+ *
+ * Configures the geometry of a wayland surface, i.e., the rectangle
+ * within that surface that contains the surface's visible bounds.
+ *
+ * The coordinates and sizes should be given in wine's coordinate space.
+ *
+ * This function sets up but doesn't actually apply any new configuration.
+ * The wayland_surface_reconfigure_apply() needs to be called for changes
+ * to take effect.
+ */
+void wayland_surface_reconfigure_geometry(struct wayland_surface *surface,
+                                          int wine_x, int wine_y,
+                                          int wine_width, int wine_height)
+{
+    int x, y, width, height;
+
+    wayland_surface_coords_rounded_from_wine(surface, wine_x, wine_y, &x, &y);
+    wayland_surface_coords_rounded_from_wine(surface, wine_width, wine_height,
+                                             &width, &height);
+
+    TRACE("surface=%p hwnd=%p wine=%d,%d+%dx%d wayland=%d,%d+%dx%d\n",
+          surface, surface->hwnd,
+          wine_x, wine_y, wine_width, wine_height,
+          x, y, width, height);
+
+    if (surface->xdg_surface && width != 0 && height != 0)
+    {
+        enum wayland_configure_flags flags = surface->current.configure_flags;
+
+        /* Sometimes rounding errors in our coordinate space transformations
+         * can lead to invalid geometry values, so enforce acceptable geometry
+         * values to avoid causing a protocol error. */
+        if (flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED)
+        {
+            width = surface->current.width;
+            height = surface->current.height;
+        }
+        else if (flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN)
+        {
+            if (width > surface->current.width)
+                width = surface->current.width;
+            if (height > surface->current.height)
+                height = surface->current.height;
+        }
+
+        xdg_surface_set_window_geometry(surface->xdg_surface, x, y, width, height);
+    }
+}
+
+/**********************************************************************
+ *          wayland_surface_reconfigure_apply
+ *
+ * Applies the configuration set by previous calls to the
+ * wayland_surface_reconfigure{_glvk}() functions.
+ */
+void wayland_surface_reconfigure_apply(struct wayland_surface *surface)
+{
+    wl_surface_commit(surface->wl_surface);
+
+    /* Commit the parent so any subsurface repositioning takes effect. */
+    if (surface->parent)
+        wl_surface_commit(surface->parent->wl_surface);
+}
+
 /**********************************************************************
  *          wayland_surface_configure_is_compatible
  *
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index c3329b1518b..c6e79e49daa 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -295,6 +295,11 @@ BOOL wayland_surface_commit_buffer(struct wayland_surface *surface,
                                    struct wayland_shm_buffer *shm_buffer,
                                    HRGN surface_damage_region);
 void wayland_surface_destroy(struct wayland_surface *surface);
+void wayland_surface_reconfigure_position(struct wayland_surface *surface,
+                                          int x, int y);
+void wayland_surface_reconfigure_geometry(struct wayland_surface *surface,
+                                          int x, int y, int width, int height);
+void wayland_surface_reconfigure_apply(struct wayland_surface *surface);
 void wayland_surface_unmap(struct wayland_surface *surface);
 void wayland_surface_ack_pending_configure(struct wayland_surface *surface);
 void wayland_surface_coords_to_screen(struct wayland_surface *surface,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 72ce622edd8..550b3ace7a2 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -54,6 +54,10 @@ struct wayland_win_data
     struct window_surface *pending_window_surface;
     /* whether the pending_window_surface value is valid */
     BOOL           has_pending_window_surface;
+    /* whether the window is currently fullscreen */
+    BOOL           fullscreen;
+    /* whether the window is currently maximized */
+    BOOL           maximized;
     /* whether this window is visible */
     BOOL           visible;
     /* Save previous state to be able to decide when to recreate wayland surface */
@@ -472,6 +476,10 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
 
     data->effective_parent = effective_parent_hwnd;
 
+    /* Reset window state, so that it can be properly applied again. */
+    data->maximized = FALSE;
+    data->fullscreen = FALSE;
+
     /* Use wayland subsurfaces for children windows and toplevels that we
      * consider to be popups and have an effective parent. Otherwise, if the
      * window is visible make it wayland toplevel. Finally, if the window is
@@ -501,6 +509,183 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
     }
 }
 
+static BOOL wayland_win_data_update_wayland_xdg_state(struct wayland_win_data *data)
+{
+    int wayland_width, wayland_height;
+    BOOL compat_with_current = FALSE;
+    BOOL compat_with_pending = FALSE;
+    int width = data->window_rect.right - data->window_rect.left;
+    int height = data->window_rect.bottom - data->window_rect.top;
+    struct wayland_surface *wsurface = data->wayland_surface;
+    enum wayland_configure_flags conf_flags = 0;
+    DWORD style = GetWindowLongW(data->hwnd, GWL_STYLE);
+    HMONITOR hmonitor;
+    MONITORINFOEXW mi;
+    struct wayland_output *output;
+    RECT window_in_monitor;
+
+    mi.cbSize = sizeof(mi);
+    if ((hmonitor = MonitorFromWindow(data->hwnd, MONITOR_DEFAULTTOPRIMARY)) &&
+        GetMonitorInfoW(hmonitor, (MONITORINFO *)&mi))
+    {
+        output = wayland_output_get_by_wine_name(wsurface->wayland, mi.szDevice);
+    }
+    else
+    {
+        output = NULL;
+        SetRectEmpty(&mi.rcMonitor);
+    }
+
+    TRACE("hwnd=%p window=%dx%d monitor=%dx%d maximized=%d fullscreen=%d\n",
+          data->hwnd, width, height,
+          mi.rcMonitor.right - mi.rcMonitor.left,
+          mi.rcMonitor.bottom - mi.rcMonitor.top,
+          data->maximized, data->fullscreen);
+
+    /* Set the wayland fullscreen state if the window rect covers the
+     * current monitor. Note that we set/maintain the fullscreen wayland state,
+     * even if the window style is also maximized. */
+    if (!IsRectEmpty(&mi.rcMonitor) &&
+        IntersectRect(&window_in_monitor, &data->window_rect, &mi.rcMonitor) &&
+        EqualRect(&window_in_monitor, &mi.rcMonitor) &&
+        !(style & (WS_MINIMIZE|WS_CAPTION)))
+    {
+        conf_flags |= WAYLAND_CONFIGURE_FLAG_FULLSCREEN;
+    }
+    if (style & WS_MAXIMIZE)
+    {
+        conf_flags |= WAYLAND_CONFIGURE_FLAG_MAXIMIZED;
+    }
+
+    /* First do all state unsettings, before setting new state. Some wayland
+     * compositors misbehave if the order is reversed. */
+    if (data->maximized && !(conf_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
+    {
+        xdg_toplevel_unset_maximized(wsurface->xdg_toplevel);
+        data->maximized = FALSE;
+    }
+
+    if (data->fullscreen && !(conf_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN))
+    {
+        xdg_toplevel_unset_fullscreen(wsurface->xdg_toplevel);
+        data->fullscreen = FALSE;
+    }
+
+    if (!data->maximized && (conf_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
+    {
+        xdg_toplevel_set_maximized(wsurface->xdg_toplevel);
+        data->maximized = TRUE;
+    }
+
+   /* Set the fullscreen state after the maximized state on the wayland surface
+    * to ensure compositors apply the final fullscreen state properly. */
+    if (!data->fullscreen && (conf_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN))
+    {
+        xdg_toplevel_set_fullscreen(wsurface->xdg_toplevel,
+                                    output ? output->wl_output : NULL);
+        data->fullscreen = TRUE;
+    }
+
+    TRACE("hwnd=%p current state maximized=%d fullscreen=%d\n",
+          data->hwnd, data->maximized, data->fullscreen);
+
+    wayland_surface_coords_rounded_from_wine(wsurface, width, height,
+                                             &wayland_width, &wayland_height);
+
+    if (wsurface->current.serial &&
+        wayland_surface_configure_is_compatible(&wsurface->current,
+                                                wayland_width, wayland_height,
+                                                conf_flags))
+    {
+        compat_with_current = TRUE;
+    }
+
+    if (wsurface->pending.serial &&
+        wayland_surface_configure_is_compatible(&wsurface->pending,
+                                                wayland_width, wayland_height,
+                                                conf_flags))
+    {
+        compat_with_pending = TRUE;
+    }
+
+    TRACE("current conf serial=%d size=%dx%d flags=%#x\n compat=%d\n",
+          wsurface->current.serial, wsurface->current.width,
+          wsurface->current.height, wsurface->current.configure_flags,
+          compat_with_current);
+    TRACE("pending conf serial=%d size=%dx%d flags=%#x compat=%d\n",
+          wsurface->pending.serial, wsurface->pending.width,
+          wsurface->pending.height, wsurface->pending.configure_flags,
+          compat_with_pending);
+
+    /* Only update the wayland surface state to match the window
+     * configuration if the surface can accept the new config, in order to
+     * avoid transient states that may cause glitches. */
+    if (!compat_with_pending && !compat_with_current)
+    {
+        TRACE("hwnd=%p window state not compatible with current or "
+              "pending wayland surface configuration\n", data->hwnd);
+        return FALSE;
+    }
+
+    if (compat_with_pending)
+        wayland_surface_ack_pending_configure(wsurface);
+
+    return TRUE;
+}
+
+static void wayland_win_data_update_wayland_surface_state(struct wayland_win_data *data)
+{
+    RECT screen_rect;
+    RECT parent_screen_rect;
+    int width = data->window_rect.right - data->window_rect.left;
+    int height = data->window_rect.bottom - data->window_rect.top;
+    struct wayland_surface *wsurface = data->wayland_surface;
+    DWORD style = GetWindowLongW(data->hwnd, GWL_STYLE);
+
+    TRACE("hwnd=%p window=%dx%d style=0x%x\n", data->hwnd, width, height, style);
+
+    if (!(style & WS_VISIBLE))
+    {
+        wayland_surface_unmap(wsurface);
+        return;
+    }
+
+    /* Lock the wayland surface to avoid commits from other threads while we
+     * are setting up the new state. */
+    EnterCriticalSection(&wsurface->crit);
+
+    if (wsurface->xdg_toplevel &&
+        !wayland_win_data_update_wayland_xdg_state(data))
+    {
+        LeaveCriticalSection(&wsurface->crit);
+        return;
+    }
+
+    if (wsurface->wl_subsurface)
+    {
+        /* In addition to children windows, we manage some top level, popup window
+         * with subsurfaces (see wayland_win_data_get_effective_parent), which use
+         * coordinates relative to their parent surface. */
+        if (!GetWindowRect(data->hwnd, &screen_rect))
+            SetRectEmpty(&screen_rect);
+        if (!GetWindowRect(data->effective_parent, &parent_screen_rect))
+            SetRectEmpty(&parent_screen_rect);
+
+        wayland_surface_reconfigure_position(
+            wsurface,
+            screen_rect.left - parent_screen_rect.left,
+            screen_rect.top - parent_screen_rect.top);
+    }
+    else if (wsurface->xdg_surface)
+    {
+        wayland_surface_reconfigure_geometry(wsurface, 0, 0, width, height);
+    }
+
+    wayland_surface_reconfigure_apply(wsurface);
+
+    LeaveCriticalSection(&wsurface->crit);
+}
+
 static void update_wayland_state(struct wayland_win_data *data)
 {
     if (data->has_pending_window_surface)
@@ -519,6 +704,9 @@ static void update_wayland_state(struct wayland_win_data *data)
     if (wayland_win_data_wayland_surface_needs_update(data))
         wayland_win_data_update_wayland_surface(data);
 
+    if (data->wayland_surface)
+        wayland_win_data_update_wayland_surface_state(data);
+
     if (data->window_surface)
     {
         wayland_window_surface_update_wayland_surface(data->window_surface,
-- 
2.34.1


From aaa4f2522f09a82f3b8abe4a9c30357752cd382e Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 17 Nov 2021 18:12:25 +0200
Subject: [PATCH 046/147] winewayland.drv: Handle window sizes larger than
 required by Wayland.

If the application provides a window larger than what is required by the
current Wayland state, use only the portion of the window visible on its
main monitor to keep Wayland from issuing a protocol error.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 14 ++---
 dlls/winewayland.drv/window.c          | 78 +++++++++++++++++++++++++-
 2 files changed, 83 insertions(+), 9 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index d76f3bbb29d..bee3243b05c 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -373,20 +373,18 @@ BOOL wayland_surface_configure_is_compatible(struct wayland_surface_configure *c
     if ((flags & mask) != (conf->configure_flags & mask))
         return FALSE;
 
-    /* The maximized state requires the configured size. */
+    /* The maximized state requires the configured size. During surface
+     * reconfiguration we can use surface geometry to provide smaller areas
+     * from larger sizes, so only smaller sizes are incompatible. */
     if ((conf->configure_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED) &&
-        (width != conf->width || height != conf->height))
+        (width < conf->width || height < conf->height))
     {
         return FALSE;
     }
 
     /* The fullscreen state requires sizes smaller or equal to the configured
-     * size. */
-    if ((conf->configure_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN) &&
-        (width > conf->width || height > conf->height))
-    {
-        return FALSE;
-    }
+     * size. We can provide this during surface reconfiguration using surface
+     * geometry, so we are always compatible with a fullscreen state. */
 
     return TRUE;
 }
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 550b3ace7a2..1e6ebce5b36 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -633,6 +633,78 @@ static BOOL wayland_win_data_update_wayland_xdg_state(struct wayland_win_data *d
     return TRUE;
 }
 
+static void wayland_win_data_get_rect_in_monitor(struct wayland_win_data *data,
+                                                 enum wayland_configure_flags flags,
+                                                 RECT *rect)
+{
+    HMONITOR hmonitor;
+    MONITORINFO mi;
+    RECT *area = NULL;
+
+    mi.cbSize = sizeof(mi);
+    if ((hmonitor = MonitorFromWindow(data->hwnd, MONITOR_DEFAULTTOPRIMARY)) &&
+        GetMonitorInfoW(hmonitor, (MONITORINFO *)&mi))
+    {
+        if (flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN)
+            area = &mi.rcMonitor;
+        else if (flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN)
+            area = &mi.rcWork;
+    }
+
+    if (area)
+    {
+        IntersectRect(rect, area, &data->window_rect);
+        OffsetRect(rect, -data->window_rect.left, -data->window_rect.top);
+    }
+    else
+    {
+        SetRectEmpty(rect);
+    }
+}
+
+static void wayland_win_data_get_compatible_rect(struct wayland_win_data *data,
+                                                 RECT *rect)
+{
+    int width = data->window_rect.right - data->window_rect.left;
+    int height = data->window_rect.bottom - data->window_rect.top;
+    int wine_conf_width, wine_conf_height;
+    enum wayland_configure_flags conf_flags =
+        data->wayland_surface->current.configure_flags;
+
+    /* Get the window size corresponding to the Wayland surfaces configuration. */
+    wayland_surface_coords_to_wine(data->wayland_surface,
+                                   data->wayland_surface->current.width,
+                                   data->wayland_surface->current.height,
+                                   &wine_conf_width,
+                                   &wine_conf_height);
+
+    /* If Wayland requires a surface size smaller than what wine provides,
+     * use part of the window contents for the surface. */
+    if (((conf_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED) ||
+         (conf_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN)) &&
+        (width > wine_conf_width || height > wine_conf_height))
+    {
+        wayland_win_data_get_rect_in_monitor(data, conf_flags, rect);
+        /* If the window rect in the monitor is smaller than required
+         * fall back to an appropriately sized rect at the top-left. */
+        if (rect->right - rect->left < wine_conf_width ||
+            rect->bottom - rect->top < wine_conf_height)
+        {
+            SetRect(rect, 0, 0, wine_conf_width, wine_conf_height);
+        }
+        else
+        {
+            rect->right = min(rect->right, rect->left + wine_conf_width);
+            rect->bottom = min(rect->bottom, rect->top + wine_conf_height);
+        }
+        TRACE("Window is too large for wayland state, using subarea\n");
+    }
+    else
+    {
+        SetRect(rect, 0, 0, width, height);
+    }
+}
+
 static void wayland_win_data_update_wayland_surface_state(struct wayland_win_data *data)
 {
     RECT screen_rect;
@@ -678,7 +750,11 @@ static void wayland_win_data_update_wayland_surface_state(struct wayland_win_dat
     }
     else if (wsurface->xdg_surface)
     {
-        wayland_surface_reconfigure_geometry(wsurface, 0, 0, width, height);
+        RECT compat;
+        wayland_win_data_get_compatible_rect(data, &compat);
+        wayland_surface_reconfigure_geometry(wsurface, compat.left, compat.top,
+                                             compat.right - compat.left,
+                                             compat.bottom - compat.top);
     }
 
     wayland_surface_reconfigure_apply(wsurface);
-- 
2.34.1


From 451bb9f147d48b6f4a935ed3024e81d12adc7af0 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 8 Sep 2021 12:09:31 +0300
Subject: [PATCH 047/147] winewayland.drv: Disallow commits during state
 transitions.

When a surface transitions to a new state, disallow commits until the
compositor has acknowledged the transition, in order to avoid glitches.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 10 ++++++----
 dlls/winewayland.drv/waylanddrv.h      |  1 +
 dlls/winewayland.drv/window.c          |  3 +++
 3 files changed, 10 insertions(+), 4 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index bee3243b05c..c07e179c3db 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -136,6 +136,7 @@ struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland)
         goto err;
 
     wl_surface_set_user_data(surface->wl_surface, surface);
+    surface->drawing_allowed = TRUE;
 
     surface->ref = 1;
     surface->role = WAYLAND_SURFACE_ROLE_NONE;
@@ -437,10 +438,11 @@ BOOL wayland_surface_commit_buffer(struct wayland_surface *surface,
      * they accept. To avoid wayland protocol errors, drop buffers not matching
      * the expected dimensions of such surfaces. This typically happens
      * transiently during resizing operations. */
-    if (!wayland_surface_configure_is_compatible(&surface->current,
-                                                 wayland_width,
-                                                 wayland_height,
-                                                 surface->current.configure_flags))
+    if (!surface->drawing_allowed ||
+        !wayland_surface_configure_is_compatible(&surface->current,
+                                             wayland_width,
+                                             wayland_height,
+                                             surface->current.configure_flags))
     {
         LeaveCriticalSection(&surface->crit);
         TRACE("surface=%p buffer=%p dropping buffer\n", surface, shm_buffer);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index c6e79e49daa..9ddacde69a4 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -181,6 +181,7 @@ struct wayland_surface
     BOOL mapped;
     LONG ref;
     enum wayland_surface_role role;
+    BOOL drawing_allowed;
 };
 
 struct wayland_buffer_queue
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 1e6ebce5b36..d75ee2c0301 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -624,6 +624,7 @@ static BOOL wayland_win_data_update_wayland_xdg_state(struct wayland_win_data *d
     {
         TRACE("hwnd=%p window state not compatible with current or "
               "pending wayland surface configuration\n", data->hwnd);
+        wsurface->drawing_allowed = FALSE;
         return FALSE;
     }
 
@@ -759,6 +760,8 @@ static void wayland_win_data_update_wayland_surface_state(struct wayland_win_dat
 
     wayland_surface_reconfigure_apply(wsurface);
 
+    wsurface->drawing_allowed = TRUE;
+
     LeaveCriticalSection(&wsurface->crit);
 }
 
-- 
2.34.1


From 776df27c3fec72f780ff06497fbf2dcbb7113fe2 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 18 Nov 2021 14:33:51 +0200
Subject: [PATCH 048/147] winewayland.drv: Disallow commits to unmappable
 surfaces.

Wayland surfaces without a role, which we use for hidden windows, are
not mappable, so any commits on them are never going to be visible.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 9 ++++++++-
 dlls/winewayland.drv/window.c          | 3 ++-
 2 files changed, 10 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index c07e179c3db..e8f7500b705 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -136,7 +136,8 @@ struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland)
         goto err;
 
     wl_surface_set_user_data(surface->wl_surface, surface);
-    surface->drawing_allowed = TRUE;
+    /* Plain surfaces are unmappable, so don't draw on them. */
+    surface->drawing_allowed = FALSE;
 
     surface->ref = 1;
     surface->role = WAYLAND_SURFACE_ROLE_NONE;
@@ -162,6 +163,8 @@ void wayland_surface_make_toplevel(struct wayland_surface *surface,
 
     TRACE("surface=%p parent=%p\n", surface, parent);
 
+    surface->drawing_allowed = TRUE;
+
     surface->xdg_surface =
         xdg_wm_base_get_xdg_surface(wayland->xdg_wm_base, surface->wl_surface);
     if (!surface->xdg_surface)
@@ -208,6 +211,8 @@ void wayland_surface_make_subsurface(struct wayland_surface *surface,
 
     TRACE("surface=%p parent=%p\n", surface, parent);
 
+    surface->drawing_allowed = TRUE;
+
     surface->parent = wayland_surface_ref(parent);
     surface->wl_subsurface =
         wl_subcompositor_get_subsurface(wayland->wl_subcompositor,
@@ -240,6 +245,8 @@ void wayland_surface_clear_role(struct wayland_surface *surface)
 {
     TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
 
+    surface->drawing_allowed = FALSE;
+
     if (surface->xdg_toplevel)
     {
         xdg_toplevel_destroy(surface->xdg_toplevel);
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index d75ee2c0301..ea34c090aa7 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -760,7 +760,8 @@ static void wayland_win_data_update_wayland_surface_state(struct wayland_win_dat
 
     wayland_surface_reconfigure_apply(wsurface);
 
-    wsurface->drawing_allowed = TRUE;
+    if (wsurface->xdg_toplevel || wsurface->wl_subsurface)
+        wsurface->drawing_allowed = TRUE;
 
     LeaveCriticalSection(&wsurface->crit);
 }
-- 
2.34.1


From e8cc0b9cffae0ec78b066d32ca4ab9904ea39199 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 8 Sep 2021 12:30:53 +0300
Subject: [PATCH 049/147] winewayland.drv: Handle dynamic Wayland surface
 configure events.

When a Wayland configure event arrives, change the window size and
state to match what the compositor has requested.

While resizing, configure events can come continuously and due to the
amount of other message their handling produces (e.g., paints), have the
potential to keep the message loop busy for some time. This may lead
Wine core to think that the app never goes idle (see win.c:
flush_window_surfaces), and thus start flushing at unfortunate times
(e.g., in between partial window paints), causing visual artifacts.

To mitigate this we handle the configure message only if the message
queue is empty, ensuring that the loop has had time to become idle.  If
the queue is not currently empty, we schedule a timer message, which due
to having the lowest priority is guaranteed to be triggered only on
otherwise empty queues.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c |  20 +-
 dlls/winewayland.drv/waylanddrv.h      |   2 +
 dlls/winewayland.drv/window.c          | 243 +++++++++++++++++++++++--
 3 files changed, 247 insertions(+), 18 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index e8f7500b705..72b95c0d148 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -32,12 +32,30 @@ static void handle_xdg_surface_configure(void *data, struct xdg_surface *xdg_sur
                                          uint32_t serial)
 {
     struct wayland_surface *surface = data;
+    uint32_t last_serial = surface->pending.serial;
+    BOOL last_processed = surface->pending.processed;
 
     TRACE("hwnd=%p serial=%u\n", surface->hwnd, serial);
 
     surface->pending.serial = serial;
+    surface->pending.processed = FALSE;
+
+    /* If we have an unprocessed WM_WAYLAND_CONFIGURE message, no need to
+     * repost. Note that checking only for a valid serial is not enough to
+     * guarantee that there is a pending WM_WAYLAND_CONFIGURE message: we may
+     * have processed the message but not acked the configure request due to
+     * surface size incompatibilities (see window.c:
+     * wayland_win_data_update_wayland_surface_state()). */
+    if (last_serial && !last_processed)
+    {
+        TRACE("not reposting, last_serial=%u\n", last_serial);
+        return;
+    }
 
-    wayland_surface_ack_pending_configure(surface);
+    if (surface->hwnd)
+        PostMessageW(surface->hwnd, WM_WAYLAND_CONFIGURE, 0, 0);
+    else
+        wayland_surface_ack_pending_configure(surface);
 }
 
 /**********************************************************************
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 9ddacde69a4..24c4c2d9732 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -49,6 +49,7 @@ enum wayland_window_message
     WM_WAYLAND_BROADCAST_DISPLAY_CHANGE = 0x80001000,
     WM_WAYLAND_SET_CURSOR = 0x80001001,
     WM_WAYLAND_QUERY_SURFACE_MAPPED = 0x80001002,
+    WM_WAYLAND_CONFIGURE = 0x80001003,
 };
 
 enum wayland_surface_role
@@ -164,6 +165,7 @@ struct wayland_surface_configure
     int height;
     enum wayland_configure_flags configure_flags;
     uint32_t serial;
+    BOOL processed;
 };
 
 struct wayland_surface
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index ea34c090aa7..925951e74af 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -54,10 +54,18 @@ struct wayland_win_data
     struct window_surface *pending_window_surface;
     /* whether the pending_window_surface value is valid */
     BOOL           has_pending_window_surface;
+    /* whether this window is currently being resized */
+    BOOL           resizing;
+    /* the window_rect this window should be restored to after unmaximizing */
+    RECT           restore_rect;
     /* whether the window is currently fullscreen */
     BOOL           fullscreen;
     /* whether the window is currently maximized */
     BOOL           maximized;
+    /* whether we are currently handling a wayland configure event */
+    BOOL           handling_wayland_configure_event;
+    /* the configure flags for the configure event we are handling */
+    enum wayland_configure_flags wayland_configure_event_flags;
     /* whether this window is visible */
     BOOL           visible;
     /* Save previous state to be able to decide when to recreate wayland surface */
@@ -536,44 +544,58 @@ static BOOL wayland_win_data_update_wayland_xdg_state(struct wayland_win_data *d
         SetRectEmpty(&mi.rcMonitor);
     }
 
-    TRACE("hwnd=%p window=%dx%d monitor=%dx%d maximized=%d fullscreen=%d\n",
+    TRACE("hwnd=%p window=%dx%d monitor=%dx%d maximized=%d fullscreen=%d handling_event=%d\n",
           data->hwnd, width, height,
           mi.rcMonitor.right - mi.rcMonitor.left,
           mi.rcMonitor.bottom - mi.rcMonitor.top,
-          data->maximized, data->fullscreen);
+          data->maximized, data->fullscreen, data->handling_wayland_configure_event);
 
-    /* Set the wayland fullscreen state if the window rect covers the
-     * current monitor. Note that we set/maintain the fullscreen wayland state,
-     * even if the window style is also maximized. */
-    if (!IsRectEmpty(&mi.rcMonitor) &&
-        IntersectRect(&window_in_monitor, &data->window_rect, &mi.rcMonitor) &&
-        EqualRect(&window_in_monitor, &mi.rcMonitor) &&
-        !(style & (WS_MINIMIZE|WS_CAPTION)))
+    /* If we are currently handling a wayland configure event (i.e., we are
+     * being called through handle_wm_wayland_configure() -> SetWindowPos()),
+     * use the event configure flags directly. Otherwise try to infer the flags
+     * from the window style and rectangle. */
+    if (data->handling_wayland_configure_event)
     {
-        conf_flags |= WAYLAND_CONFIGURE_FLAG_FULLSCREEN;
+        conf_flags = data->wayland_configure_event_flags;
     }
-    if (style & WS_MAXIMIZE)
+    else
     {
-        conf_flags |= WAYLAND_CONFIGURE_FLAG_MAXIMIZED;
+        /* Set the wayland fullscreen state if the window rect covers the
+         * current monitor exactly. Note that we set/maintain the fullscreen
+         * wayland state, even if the window style is also maximized. */
+        if (!IsRectEmpty(&mi.rcMonitor) &&
+            IntersectRect(&window_in_monitor, &data->window_rect, &mi.rcMonitor) &&
+            EqualRect(&window_in_monitor, &mi.rcMonitor) &&
+            !(style & (WS_MINIMIZE|WS_CAPTION)))
+        {
+            conf_flags |= WAYLAND_CONFIGURE_FLAG_FULLSCREEN;
+        }
+        if (style & WS_MAXIMIZE)
+        {
+            conf_flags |= WAYLAND_CONFIGURE_FLAG_MAXIMIZED;
+        }
     }
 
     /* First do all state unsettings, before setting new state. Some wayland
      * compositors misbehave if the order is reversed. */
     if (data->maximized && !(conf_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
     {
-        xdg_toplevel_unset_maximized(wsurface->xdg_toplevel);
+        if (!data->handling_wayland_configure_event)
+            xdg_toplevel_unset_maximized(wsurface->xdg_toplevel);
         data->maximized = FALSE;
     }
 
     if (data->fullscreen && !(conf_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN))
     {
-        xdg_toplevel_unset_fullscreen(wsurface->xdg_toplevel);
+        if (!data->handling_wayland_configure_event)
+            xdg_toplevel_unset_fullscreen(wsurface->xdg_toplevel);
         data->fullscreen = FALSE;
     }
 
     if (!data->maximized && (conf_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
     {
-        xdg_toplevel_set_maximized(wsurface->xdg_toplevel);
+        if (!data->handling_wayland_configure_event)
+            xdg_toplevel_set_maximized(wsurface->xdg_toplevel);
         data->maximized = TRUE;
     }
 
@@ -581,11 +603,23 @@ static BOOL wayland_win_data_update_wayland_xdg_state(struct wayland_win_data *d
     * to ensure compositors apply the final fullscreen state properly. */
     if (!data->fullscreen && (conf_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN))
     {
-        xdg_toplevel_set_fullscreen(wsurface->xdg_toplevel,
-                                    output ? output->wl_output : NULL);
+        if (!data->handling_wayland_configure_event)
+        {
+            xdg_toplevel_set_fullscreen(wsurface->xdg_toplevel,
+                                        output ? output->wl_output : NULL);
+        }
         data->fullscreen = TRUE;
     }
 
+    if (!(conf_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN) &&
+        !(conf_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED) &&
+        !(style & WS_MINIMIZE))
+    {
+        data->restore_rect = data->window_rect;
+        TRACE("setting hwnd=%p restore_rect=%s\n",
+              data->hwnd, wine_dbgstr_rect(&data->restore_rect));
+    }
+
     TRACE("hwnd=%p current state maximized=%d fullscreen=%d\n",
           data->hwnd, data->maximized, data->fullscreen);
 
@@ -908,6 +942,151 @@ void CDECL WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags
     wayland_win_data_release(data);
 }
 
+static LRESULT handle_wm_wayland_configure(HWND hwnd)
+{
+    struct wayland_win_data *data;
+    struct wayland_surface *wsurface;
+    DWORD flags;
+    int width, height, wine_width, wine_height;
+    BOOL needs_move_to_origin;
+    int origin_x, origin_y;
+    UINT swp_flags;
+    BOOL needs_enter_size_move = FALSE;
+    BOOL needs_exit_size_move = FALSE;
+
+    if (!(data = wayland_win_data_get(hwnd))) return 0;
+    if (!data->wayland_surface || !data->wayland_surface->xdg_toplevel)
+    {
+        TRACE("no suitable wayland surface, returning\n");
+        wayland_win_data_release(data);
+        return 0;
+    }
+
+    wsurface = data->wayland_surface;
+
+    TRACE("serial=%d size=%dx%d flags=%#x restore_rect=%s\n",
+          wsurface->pending.serial, wsurface->pending.width,
+          wsurface->pending.height, wsurface->pending.configure_flags,
+          wine_dbgstr_rect(&data->restore_rect));
+
+    if (wsurface->pending.serial == 0)
+    {
+        TRACE("pending configure event already handled, returning\n");
+        wayland_win_data_release(data);
+        return 0;
+    }
+
+    wsurface->pending.processed = TRUE;
+
+    data->wayland_configure_event_flags = wsurface->pending.configure_flags;
+
+    width = wsurface->pending.width;
+    height = wsurface->pending.height;
+    flags = wsurface->pending.configure_flags;
+
+    /* If we are free to set our size, first try the restore size, then
+     * the current size. */
+    if (width == 0)
+    {
+        int ignore;
+        width = data->restore_rect.right - data->restore_rect.left;
+        if (width == 0)
+            width = data->window_rect.right - data->window_rect.left;
+        wayland_surface_coords_rounded_from_wine(wsurface, width, 0,
+                                                 &width, &ignore);
+        wsurface->pending.width = width;
+    }
+    if (height == 0)
+    {
+        int ignore;
+        height = data->restore_rect.bottom - data->restore_rect.top;
+        if (height == 0)
+            height = data->window_rect.bottom - data->window_rect.top;
+        wayland_surface_coords_rounded_from_wine(wsurface, 0, height,
+                                                 &ignore, &height);
+        wsurface->pending.height = height;
+    }
+
+    wayland_surface_coords_to_wine(wsurface, width, height,
+                                   &wine_width, &wine_height);
+
+    TRACE("hwnd=%p effective_size=%dx%d wine_size=%dx%d\n",
+          data->hwnd, width, height, wine_width, wine_height);
+
+    if ((flags & WAYLAND_CONFIGURE_FLAG_RESIZING) && !data->resizing)
+    {
+        data->resizing = TRUE;
+        needs_enter_size_move = TRUE;
+    }
+
+    if (!(flags & WAYLAND_CONFIGURE_FLAG_RESIZING) && data->resizing)
+    {
+        data->resizing = FALSE;
+        needs_exit_size_move = TRUE;
+    }
+
+    /* Parts of the window that are outside the win32 display are not
+     * accessible to mouse events, although they may be visible and accessible
+     * to the user from a wayland compositor pespective. To mitigate this, we
+     * place all top-level windows at 0,0, to maximize the area that can reside
+     * within the win32 display. */
+    origin_x = 0;
+    origin_y = 0;
+    needs_move_to_origin = data->window_rect.top != origin_x ||
+                           data->window_rect.left != origin_y;
+    TRACE("current=%d,%d origin=%d,%d\n",
+          data->window_rect.left, data->window_rect.top,
+          origin_x, origin_y);
+
+    wayland_win_data_release(data);
+
+    if (needs_enter_size_move)
+        SendMessageW(hwnd, WM_ENTERSIZEMOVE, 0, 0);
+
+    if (needs_exit_size_move)
+        SendMessageW(hwnd, WM_EXITSIZEMOVE, 0, 0);
+
+    if ((data = wayland_win_data_get(hwnd)))
+    {
+        data->handling_wayland_configure_event = TRUE;
+        wayland_win_data_release(data);
+    }
+
+    if (flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED)
+        SetWindowLongW(hwnd, GWL_STYLE, GetWindowLongW(hwnd, GWL_STYLE) | WS_MAXIMIZE);
+    else
+        SetWindowLongW(hwnd, GWL_STYLE, GetWindowLongW(hwnd, GWL_STYLE) & ~WS_MAXIMIZE);
+
+    swp_flags = SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOOWNERZORDER;
+
+    if (!needs_move_to_origin) swp_flags |= SWP_NOMOVE;
+    if (wine_width > 0 && wine_height > 0)
+        swp_flags |= SWP_FRAMECHANGED;
+    else
+        swp_flags |= SWP_NOSIZE | SWP_NOREDRAW;
+    /* When we are maximized or fullscreen, wayland is particular about the
+     * surface size it accepts, so don't allow the app to change it. */
+    if (flags & (WAYLAND_CONFIGURE_FLAG_MAXIMIZED|WAYLAND_CONFIGURE_FLAG_FULLSCREEN))
+        swp_flags |= SWP_NOSENDCHANGING;
+
+    SetWindowPos(hwnd, 0, origin_x, origin_y, wine_width, wine_height, swp_flags);
+
+    if ((data = wayland_win_data_get(hwnd)))
+    {
+        data->handling_wayland_configure_event = FALSE;
+        wayland_win_data_release(data);
+    }
+
+    return 0;
+}
+
+static void CALLBACK post_configure(HWND hwnd, UINT msg, UINT_PTR timer_id, DWORD elapsed)
+{
+    TRACE("hwnd=%p\n", hwnd);
+    KillTimer(hwnd, timer_id);
+    handle_wm_wayland_configure(hwnd);
+}
+
 /**********************************************************************
  *           WAYLAND_WindowMessage
  */
@@ -934,6 +1113,36 @@ LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
             return res;
         }
         break;
+    case WM_WAYLAND_CONFIGURE:
+        /* While resizing, configure events can come continuously and due to the
+         * amount of other message their handling produces (e.g., paints), have
+         * the potential to keep the message loop busy for some time. This may
+         * lead Wine core to think that the app never goes idle (see
+         * win.c:flush_window_surfaces), and thus start flushing at unfortunate
+         * times (e.g., in between partial window paints), causing visual
+         * artifacts.
+         *
+         * To mitigate this we handle the configure message only if the message
+         * queue is empty, ensuring that the loop has had time to become idle.
+         * If the queue is not currently empty, we schedule a timer message,
+         * which due to having the lowest priority is guaranteed to be triggered
+         * only on otherwise empty queues.
+         */
+        if (!GetQueueStatus(QS_ALLINPUT))
+        {
+            return handle_wm_wayland_configure(hwnd);
+        }
+        else
+        {
+            struct wayland_surface *wayland_surface = wayland_surface_for_hwnd_lock(hwnd);
+            if (wayland_surface && wayland_surface->xdg_toplevel)
+            {
+                SetTimer(hwnd, (UINT_PTR)wayland_surface->wl_surface, 10,
+                         post_configure);
+            }
+            wayland_surface_for_hwnd_unlock(wayland_surface);
+        }
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp);
     }
-- 
2.34.1


From a39bd6661428e10073a149f00a51f51c674f8673 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 8 Sep 2021 12:40:58 +0300
Subject: [PATCH 050/147] winewayland.drv: Handle window minimization and
 restoration.

Request a minimized state from the Wayland compositor when a window
is minimized.

Since Wayland doesn't provide any explicit information about the
minimization state of surfaces, we heurestically infer a restoration
from a minimized state by using the keyboard focus of the surface.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_keyboard.c | 15 ++++++++++++
 dlls/winewayland.drv/waylanddrv.h       |  1 +
 dlls/winewayland.drv/waylanddrv_main.c  |  1 +
 dlls/winewayland.drv/window.c           | 32 +++++++++++++++++++++++--
 4 files changed, 47 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index 84046796f4d..4f634e319f5 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -524,6 +524,21 @@ static void keyboard_handle_enter(void *data, struct wl_keyboard *keyboard,
         {
             struct wayland_surface *toplevel = wayland_surface;
             while (toplevel->parent) toplevel = toplevel->parent;
+
+            if (IsIconic(toplevel->hwnd))
+            {
+                /* If a minimized window is already activated from Wine's
+                 * perspective, reactivating it is a null operation, and thus
+                 * won't trigger any activation side-effects (e.g., many games
+                 * change the display mode when they are activated). In order
+                 * to get those effects properly applied, deactivate the window
+                 * now, so it can be properly reactivated after restoration. */
+                if (foreground == toplevel->hwnd)
+                    SetForegroundWindow(GetDesktopWindow());
+                ShowWindow(toplevel->hwnd, SW_RESTORE);
+                ShowOwnedPopups(toplevel->hwnd, TRUE);
+            }
+
             SetForegroundWindow(toplevel->hwnd);
         }
     }
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 24c4c2d9732..35c98c28f3d 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -384,6 +384,7 @@ extern UINT CDECL WAYLAND_MapVirtualKeyEx(UINT code, UINT maptype, HKL hkl) DECL
 extern DWORD CDECL WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
                                                        DWORD timeout, DWORD mask, DWORD flags) DECLSPEC_HIDDEN;
 extern void CDECL WAYLAND_SetCursor(HCURSOR hcursor) DECLSPEC_HIDDEN;
+extern UINT CDECL WAYLAND_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp) DECLSPEC_HIDDEN;
 extern INT CDECL WAYLAND_ToUnicodeEx(UINT virt, UINT scan, const BYTE *state,
                                      LPWSTR buf, int nchars, UINT flags, HKL hkl) DECLSPEC_HIDDEN;
 extern void CDECL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 8e696e71210..e29432ff414 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -128,6 +128,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pMapVirtualKeyEx = WAYLAND_MapVirtualKeyEx,
     .pMsgWaitForMultipleObjectsEx = WAYLAND_MsgWaitForMultipleObjectsEx,
     .pSetCursor = WAYLAND_SetCursor,
+    .pShowWindow = WAYLAND_ShowWindow,
     .pToUnicodeEx = WAYLAND_ToUnicodeEx,
     .pVkKeyScanEx = WAYLAND_VkKeyScanEx,
     .pThreadDetach = WAYLAND_ThreadDetach,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 925951e74af..97974d38117 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -942,6 +942,32 @@ void CDECL WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags
     wayland_win_data_release(data);
 }
 
+/***********************************************************************
+ *           WAYLAND_ShowWindow
+ */
+UINT CDECL WAYLAND_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp)
+{
+    struct wayland_surface *wsurface;
+
+    TRACE("hwnd=%p cmd=%d\n", hwnd, cmd);
+
+    if (IsRectEmpty(rect)) return swp;
+    if (!IsIconic(hwnd)) return swp;
+    /* always hide icons off-screen */
+    if (rect->left != -32000 || rect->top != -32000)
+    {
+        OffsetRect(rect, -32000 - rect->left, -32000 - rect->top);
+        swp &= ~(SWP_NOMOVE | SWP_NOCLIENTMOVE);
+    }
+
+    if ((wsurface = wayland_surface_for_hwnd_lock(hwnd)) && wsurface->xdg_toplevel)
+        xdg_toplevel_set_minimized(wsurface->xdg_toplevel);
+
+    wayland_surface_for_hwnd_unlock(wsurface);
+
+    return swp;
+}
+
 static LRESULT handle_wm_wayland_configure(HWND hwnd)
 {
     struct wayland_win_data *data;
@@ -989,7 +1015,8 @@ static LRESULT handle_wm_wayland_configure(HWND hwnd)
     if (width == 0)
     {
         int ignore;
-        width = data->restore_rect.right - data->restore_rect.left;
+        if (!IsIconic(hwnd))
+            width = data->restore_rect.right - data->restore_rect.left;
         if (width == 0)
             width = data->window_rect.right - data->window_rect.left;
         wayland_surface_coords_rounded_from_wine(wsurface, width, 0,
@@ -999,7 +1026,8 @@ static LRESULT handle_wm_wayland_configure(HWND hwnd)
     if (height == 0)
     {
         int ignore;
-        height = data->restore_rect.bottom - data->restore_rect.top;
+        if (!IsIconic(hwnd))
+            height = data->restore_rect.bottom - data->restore_rect.top;
         if (height == 0)
             height = data->window_rect.bottom - data->window_rect.top;
         wayland_surface_coords_rounded_from_wine(wsurface, 0, height,
-- 
2.34.1


From 03cd919be705b918e2b9365844ce3c0cde805d13 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 8 Sep 2021 12:49:26 +0300
Subject: [PATCH 051/147] winewayland.drv: Handle interactive window resizing.

Propagate resize notification to the Wayland compositor, so it can
update the surface size by sending new Wayland configure events.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_pointer.c |  5 +++
 dlls/winewayland.drv/waylanddrv.h      |  2 ++
 dlls/winewayland.drv/waylanddrv_main.c |  1 +
 dlls/winewayland.drv/window.c          | 46 ++++++++++++++++++++++++++
 4 files changed, 54 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 6d227e98f80..87da2c10843 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -161,6 +161,11 @@ static void pointer_handle_button(void *data, struct wl_pointer *wl_pointer,
     wayland->last_dispatch_mask |= QS_MOUSEBUTTON;
     wayland->last_event_type = INPUT_MOUSE;
 
+    if (state == WL_POINTER_BUTTON_STATE_PRESSED)
+        wayland->last_button_serial = serial;
+    else
+        wayland->last_button_serial = 0;
+
     __wine_send_input(focused_hwnd, &input, NULL);
 }
 
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 35c98c28f3d..4243df13e10 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -127,6 +127,7 @@ struct wayland
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
     DWORD last_dispatch_mask;
+    uint32_t last_button_serial;
     DWORD last_event_type;
     int event_notification_pipe[2];
     struct wl_list thread_link;
@@ -385,6 +386,7 @@ extern DWORD CDECL WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE
                                                        DWORD timeout, DWORD mask, DWORD flags) DECLSPEC_HIDDEN;
 extern void CDECL WAYLAND_SetCursor(HCURSOR hcursor) DECLSPEC_HIDDEN;
 extern UINT CDECL WAYLAND_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp) DECLSPEC_HIDDEN;
+extern LRESULT CDECL WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam) DECLSPEC_HIDDEN;
 extern INT CDECL WAYLAND_ToUnicodeEx(UINT virt, UINT scan, const BYTE *state,
                                      LPWSTR buf, int nchars, UINT flags, HKL hkl) DECLSPEC_HIDDEN;
 extern void CDECL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index e29432ff414..99bf1f3fa1b 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -129,6 +129,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pMsgWaitForMultipleObjectsEx = WAYLAND_MsgWaitForMultipleObjectsEx,
     .pSetCursor = WAYLAND_SetCursor,
     .pShowWindow = WAYLAND_ShowWindow,
+    .pSysCommand = WAYLAND_SysCommand,
     .pToUnicodeEx = WAYLAND_ToUnicodeEx,
     .pVkKeyScanEx = WAYLAND_VkKeyScanEx,
     .pThreadDetach = WAYLAND_ThreadDetach,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 97974d38117..3236f5fa4f6 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -968,6 +968,52 @@ UINT CDECL WAYLAND_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp)
     return swp;
 }
 
+static enum xdg_toplevel_resize_edge hittest_to_resize_edge(WPARAM hittest)
+{
+    switch (hittest) {
+    case WMSZ_LEFT:        return XDG_TOPLEVEL_RESIZE_EDGE_LEFT;
+    case WMSZ_RIGHT:       return XDG_TOPLEVEL_RESIZE_EDGE_RIGHT;
+    case WMSZ_TOP:         return XDG_TOPLEVEL_RESIZE_EDGE_TOP;
+    case WMSZ_TOPLEFT:     return XDG_TOPLEVEL_RESIZE_EDGE_TOP_LEFT;
+    case WMSZ_TOPRIGHT:    return XDG_TOPLEVEL_RESIZE_EDGE_TOP_RIGHT;
+    case WMSZ_BOTTOM:      return XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM;
+    case WMSZ_BOTTOMLEFT:  return XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_LEFT;
+    case WMSZ_BOTTOMRIGHT: return XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_RIGHT;
+    default:               return XDG_TOPLEVEL_RESIZE_EDGE_NONE;
+    }
+}
+
+/***********************************************************************
+ *          WAYLAND_SysCommand
+ */
+LRESULT CDECL WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam)
+{
+    LRESULT ret = -1;
+    WPARAM command = wparam & 0xfff0;
+    WPARAM hittest = wparam & 0x0f;
+    struct wayland_surface *wsurface;
+
+    TRACE("cmd=%lx hwnd=%p, %x, %lx,\n", command, hwnd, (unsigned)wparam, lparam);
+
+    if (!(wsurface = wayland_surface_for_hwnd_lock(hwnd)) || !wsurface->xdg_toplevel)
+        goto done;
+
+    if (command == SC_SIZE)
+    {
+        if (wsurface->wayland->last_button_serial)
+        {
+            xdg_toplevel_resize(wsurface->xdg_toplevel, wsurface->wayland->wl_seat,
+                                wsurface->wayland->last_button_serial,
+                                hittest_to_resize_edge(hittest));
+        }
+        ret = 0;
+    }
+
+done:
+    wayland_surface_for_hwnd_unlock(wsurface);
+    return ret;
+}
+
 static LRESULT handle_wm_wayland_configure(HWND hwnd)
 {
     struct wayland_win_data *data;
-- 
2.34.1


From 644e97e6810fb80cd91b78ee83c666ea2d2a7682 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 8 Sep 2021 12:51:31 +0300
Subject: [PATCH 052/147] winewayland.drv: Handle interactive window movement.

Propagate window movement requests to the compositor. Note that although
the Wayland surface may move on screen, the client (Wine in this case)
is never aware, since such absolute positioning information is not
provided by the Wayland protocol.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/window.c | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 3236f5fa4f6..e28e211eb0f 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -1008,6 +1008,15 @@ LRESULT CDECL WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam)
         }
         ret = 0;
     }
+    else if (command == SC_MOVE)
+    {
+        if (wsurface->wayland->last_button_serial)
+        {
+            xdg_toplevel_move(wsurface->xdg_toplevel, wsurface->wayland->wl_seat,
+                              wsurface->wayland->last_button_serial);
+        }
+        ret = 0;
+    }
 
 done:
     wayland_surface_for_hwnd_unlock(wsurface);
-- 
2.34.1


From 546f38a6c2153fcd7371e0760dcc8f50b8d6001b Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 8 Sep 2021 15:53:46 +0300
Subject: [PATCH 053/147] winewayland.drv: Support window and window_surface
 regions.

Use buffers with an alpha channel (ARGB8888) to implement window
regions. Pixels outside the region are left as transparent in the
buffer.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h      |   3 +
 dlls/winewayland.drv/waylanddrv_main.c |   1 +
 dlls/winewayland.drv/window.c          |  17 +++
 dlls/winewayland.drv/window_surface.c  | 168 +++++++++++++++++++++++--
 4 files changed, 179 insertions(+), 10 deletions(-)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 4243df13e10..a3a05831218 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -343,6 +343,8 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface);
 BOOL wayland_window_surface_needs_flush(struct window_surface *surface);
 void wayland_window_surface_update_wayland_surface(struct window_surface *surface,
                                                    struct wayland_surface *wayland_surface);
+void wayland_window_surface_set_window_region(struct window_surface *window_surface,
+                                              HRGN win_region);
 
 /**********************************************************************
  *          Wayland Keyboard
@@ -385,6 +387,7 @@ extern UINT CDECL WAYLAND_MapVirtualKeyEx(UINT code, UINT maptype, HKL hkl) DECL
 extern DWORD CDECL WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
                                                        DWORD timeout, DWORD mask, DWORD flags) DECLSPEC_HIDDEN;
 extern void CDECL WAYLAND_SetCursor(HCURSOR hcursor) DECLSPEC_HIDDEN;
+extern void CDECL WAYLAND_SetWindowRgn(HWND hwnd, HRGN hrgn, BOOL redraw) DECLSPEC_HIDDEN;
 extern UINT CDECL WAYLAND_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp) DECLSPEC_HIDDEN;
 extern LRESULT CDECL WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam) DECLSPEC_HIDDEN;
 extern INT CDECL WAYLAND_ToUnicodeEx(UINT virt, UINT scan, const BYTE *state,
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 99bf1f3fa1b..8305ace1b61 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -128,6 +128,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pMapVirtualKeyEx = WAYLAND_MapVirtualKeyEx,
     .pMsgWaitForMultipleObjectsEx = WAYLAND_MsgWaitForMultipleObjectsEx,
     .pSetCursor = WAYLAND_SetCursor,
+    .pSetWindowRgn = WAYLAND_SetWindowRgn,
     .pShowWindow = WAYLAND_ShowWindow,
     .pSysCommand = WAYLAND_SysCommand,
     .pToUnicodeEx = WAYLAND_ToUnicodeEx,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index e28e211eb0f..3728db3cb1e 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -968,6 +968,23 @@ UINT CDECL WAYLAND_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp)
     return swp;
 }
 
+/***********************************************************************
+ *           WAYLAND_SetWindowRgn
+ */
+void CDECL WAYLAND_SetWindowRgn(HWND hwnd, HRGN hrgn, BOOL redraw)
+{
+    struct wayland_win_data *data;
+
+    TRACE("hwnd=%p\n", hwnd);
+
+    if ((data = wayland_win_data_get(hwnd)))
+    {
+        if (data->window_surface)
+            wayland_window_surface_set_window_region(data->window_surface, hrgn);
+        wayland_win_data_release(data);
+    }
+}
+
 static enum xdg_toplevel_resize_edge hittest_to_resize_edge(WPARAM hittest)
 {
     switch (hittest) {
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index b61d5bc0489..b39bb0984db 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -43,6 +43,8 @@ struct wayland_window_surface
     struct wayland_surface *wayland_surface; /* Not owned by us */
     struct wayland_buffer_queue *wayland_buffer_queue;
     RECT                  bounds;
+    HRGN                  region; /* region set through window_surface funcs */
+    HRGN                  total_region; /* Total region (surface->region AND window_region) */
     void                 *bits;
     CRITICAL_SECTION      crit;
     BOOL                  last_flush_failed;
@@ -72,6 +74,104 @@ static inline void reset_bounds(RECT *bounds)
     bounds->right = bounds->bottom = INT_MIN;
 }
 
+/***********************************************************************
+ *           wayland_window_surface_preferred_format
+ */
+static int get_preferred_format(struct wayland_window_surface *wws)
+{
+    int format;
+    HRGN window_region = CreateRectRgn(0, 0, 0, 0);
+
+    /* Use ARGB to implement window regions (areas out of the region are
+     * transparent). */
+    if ((window_region && GetWindowRgn(wws->hwnd, window_region) != ERROR))
+        format = WL_SHM_FORMAT_ARGB8888;
+    else
+        format = WL_SHM_FORMAT_XRGB8888;
+
+    if (window_region) DeleteObject(window_region);
+
+    return format;
+}
+
+/***********************************************************************
+ *           recreate_wayland_buffer_queue
+ */
+static void recreate_wayland_buffer_queue(struct wayland_window_surface *wws)
+{
+    int width;
+    int height;
+    int format;
+
+    if (!wws->wayland_buffer_queue || !wws->wayland_surface) return;
+
+    width = wws->wayland_buffer_queue->width;
+    height = wws->wayland_buffer_queue->height;
+    format = get_preferred_format(wws);
+
+    wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
+
+    wws->wayland_buffer_queue =
+        wayland_buffer_queue_create(wws->wayland_surface->wayland,
+                                    width, height, format);
+}
+
+/***********************************************************************
+ *           wayland_window_surface_set_window_region
+ */
+void wayland_window_surface_set_window_region(struct window_surface *window_surface,
+                                              HRGN win_region)
+{
+    struct wayland_window_surface *wws =
+        wayland_window_surface_cast(window_surface);
+    HRGN region = 0;
+
+    TRACE("hwnd %p surface %p region %p\n", wws->hwnd, wws, win_region);
+
+    if (win_region == (HRGN)1)  /* hack: win_region == 1 means retrieve region from server */
+    {
+        region = CreateRectRgn(0, 0, 0, 0);
+        if (region && GetWindowRgn(wws->hwnd, region) == ERROR)
+        {
+            DeleteObject(region);
+            region = 0;
+        }
+    }
+    else if (win_region)
+    {
+        region = CreateRectRgn(0, 0, 0, 0);
+        if (region) CombineRgn(region, win_region, 0, RGN_COPY);
+    }
+
+    if (wws->region)
+    {
+        if (region)
+        {
+            CombineRgn(region, region, wws->region, RGN_AND);
+        }
+        else
+        {
+            region = CreateRectRgn(0, 0, 0, 0);
+            if (region) CombineRgn(region, wws->region, 0, RGN_COPY);
+        }
+    }
+
+    window_surface->funcs->lock(window_surface);
+
+    if (wws->total_region) DeleteObject(wws->total_region);
+    wws->total_region = region;
+    *window_surface->funcs->get_bounds(window_surface) = wws->header.rect;
+    /* Unconditionally recreate the buffer queue to ensure we have clean buffers, so
+     * that areas outside the region are transparent. */
+    recreate_wayland_buffer_queue(wws);
+
+    TRACE("hwnd %p bounds %s rect %s\n", wws->hwnd,
+          wine_dbgstr_rect(window_surface->funcs->get_bounds(window_surface)),
+          wine_dbgstr_rect(&wws->header.rect));
+
+    window_surface->funcs->unlock(window_surface);
+}
+
 /***********************************************************************
  *           wayland_window_surface_lock
  */
@@ -118,7 +218,23 @@ static RECT CDECL *wayland_window_surface_get_bounds(struct window_surface *wind
 static void CDECL wayland_window_surface_set_region(struct window_surface *window_surface,
                                                     HRGN region)
 {
-    /* TODO */
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+
+    TRACE("updating hwnd=%p surface=%p region=%p\n", wws->hwnd, wws, region);
+
+    window_surface->funcs->lock(window_surface);
+    if (!region)
+    {
+        if (wws->region) DeleteObject(wws->region);
+        wws->region = NULL;
+    }
+    else
+    {
+        if (!wws->region) wws->region = CreateRectRgn(0, 0, 0, 0);
+        CombineRgn(wws->region, region, 0, RGN_COPY);
+    }
+    window_surface->funcs->unlock(window_surface);
+    wayland_window_surface_set_window_region(&wws->header, (HRGN)1);
 }
 
 /***********************************************************************
@@ -141,6 +257,23 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
           wine_dbgstr_rect(&wws->header.rect), wine_dbgstr_rect(&wws->bounds));
 
     needs_flush = IntersectRect(&damage_rect, &wws->header.rect, &wws->bounds);
+    if (needs_flush)
+    {
+        RECT total_region_box;
+        surface_damage_region = CreateRectRgnIndirect(&damage_rect);
+        /* If the total_region is empty we are guaranteed to have empty SHM
+         * buffers. In order for this empty content to take effect, we still
+         * need to commit with non-empty damage, so don't AND with the
+         * total_region in this case, to ensure we don't end up with an empty
+         * surface_damage_region. */
+        if (wws->total_region &&
+            GetRgnBox(wws->total_region, &total_region_box) != NULLREGION)
+        {
+            needs_flush = CombineRgn(surface_damage_region, surface_damage_region,
+                                     wws->total_region, RGN_AND);
+        }
+    }
+
     if (needs_flush && (!wws->wayland_surface || !wws->wayland_buffer_queue))
     {
         TRACE("missing wayland surface=%p buffer_queue=%p, returning\n",
@@ -152,11 +285,9 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
 
     if (!needs_flush) goto done;
 
-    surface_damage_region = CreateRectRgnIndirect(&damage_rect);
-
-    TRACE("flushing surface %p hwnd %p surface_rect %s bits %p\n",
+    TRACE("flushing surface %p hwnd %p surface_rect %s bits %p region %p\n",
           wws, wws->hwnd, wine_dbgstr_rect(&wws->header.rect),
-          wws->bits);
+          wws->bits, wws->total_region);
 
     assert(wws->wayland_buffer_queue);
 
@@ -168,7 +299,7 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
         wws->last_flush_failed = TRUE;
         goto done;
     }
-    buffer_damage = wayland_shm_buffer_get_damage_clipped(buffer, NULL);
+    buffer_damage = wayland_shm_buffer_get_damage_clipped(buffer, wws->total_region);
 
     rgn_rect = (RECT *)buffer_damage->Buffer;
     rgn_rect_end = rgn_rect + buffer_damage->rdh.nCount;
@@ -177,7 +308,8 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
     for (;rgn_rect < rgn_rect_end; rgn_rect++)
     {
         unsigned int *src, *dst;
-        int y, width, height;
+        int x, y, width, height;
+        BOOL apply_surface_alpha;
 
         TRACE("damage %s\n", wine_dbgstr_rect(rgn_rect));
 
@@ -193,8 +325,13 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
         width = min(rgn_rect->right, buffer->width) - rgn_rect->left;
         height = min(rgn_rect->bottom, buffer->height) - rgn_rect->top;
 
+        /* If we have an ARGB buffer we need to explicitly apply the surface
+         * alpha (assumed to be 255 currently) to ensure the destination has
+         * sensible alpha values. */
+        apply_surface_alpha = buffer->format == WL_SHM_FORMAT_ARGB8888;
+
         /* Fast path for full width rectangles. */
-        if (width == buffer->width)
+        if (width == buffer->width && !apply_surface_alpha)
         {
             memcpy(dst, src, height * buffer->stride);
             continue;
@@ -202,7 +339,15 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
 
         for (y = 0; y < height; y++)
         {
-            memcpy(dst, src, width * 4);
+            if (!apply_surface_alpha)
+            {
+                memcpy(dst, src, width * 4);
+            }
+            else
+            {
+                for (x = 0; x < width; x++)
+                    dst[x] = 0xff000000 | src[x];
+            }
 
             src += wws->info.bmiHeader.biWidth;
             dst = (unsigned int*)((unsigned char*)dst + buffer->stride);
@@ -236,6 +381,8 @@ static void CDECL wayland_window_surface_destroy(struct window_surface *window_s
 
     wws->crit.DebugInfo->Spare[0] = 0;
     DeleteCriticalSection(&wws->crit);
+    if (wws->region) DeleteObject(wws->region);
+    if (wws->total_region) DeleteObject(wws->total_region);
     if (wws->wayland_surface) wayland_surface_unref(wws->wayland_surface);
     if (wws->wayland_buffer_queue)
         wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
@@ -281,6 +428,7 @@ struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect
     wws->header.rect  = *rect;
     wws->header.ref   = 1;
     wws->hwnd         = hwnd;
+    wayland_window_surface_set_window_region(&wws->header, (HRGN)1);
     reset_bounds(&wws->bounds);
 
     if (!(wws->bits = heap_alloc(wws->info.bmiHeader.biSizeImage)))
@@ -326,7 +474,7 @@ void wayland_window_surface_update_wayland_surface(struct window_surface *window
         wws->wayland_buffer_queue =
             wayland_buffer_queue_create(wws->wayland_surface->wayland,
                     wws->info.bmiHeader.biWidth, abs(wws->info.bmiHeader.biHeight),
-                    WL_SHM_FORMAT_XRGB8888);
+                    get_preferred_format(wws));
     }
     else if (!wws->wayland_surface && wws->wayland_buffer_queue)
     {
-- 
2.34.1


From ee2aa881c76b951570831a52dd8c7e846980d29a Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 9 Sep 2021 10:47:53 +0300
Subject: [PATCH 054/147] winewayland.drv: Implement
 SetLayeredWindowAttributes.

Support color-keying and whole window opacity by manipulating the pixel
alpha values of ARGB8888 buffers.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h      |  7 ++-
 dlls/winewayland.drv/waylanddrv_main.c |  2 +
 dlls/winewayland.drv/window.c          | 57 ++++++++++++++++++++++-
 dlls/winewayland.drv/window_surface.c  | 63 ++++++++++++++++++++++----
 4 files changed, 119 insertions(+), 10 deletions(-)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index a3a05831218..1473eeaef99 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -338,13 +338,16 @@ RGNDATA *wayland_shm_buffer_get_damage_clipped(struct wayland_shm_buffer *shm_bu
  *          Wayland window surface
  */
 
-struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect);
+struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect,
+                                                     COLORREF color_key, BYTE alpha);
 void CDECL wayland_window_surface_flush(struct window_surface *window_surface);
 BOOL wayland_window_surface_needs_flush(struct window_surface *surface);
 void wayland_window_surface_update_wayland_surface(struct window_surface *surface,
                                                    struct wayland_surface *wayland_surface);
 void wayland_window_surface_set_window_region(struct window_surface *window_surface,
                                               HRGN win_region);
+void wayland_window_surface_update_layered(struct window_surface *window_surface,
+                                           COLORREF color_key, BYTE alpha);
 
 /**********************************************************************
  *          Wayland Keyboard
@@ -387,7 +390,9 @@ extern UINT CDECL WAYLAND_MapVirtualKeyEx(UINT code, UINT maptype, HKL hkl) DECL
 extern DWORD CDECL WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
                                                        DWORD timeout, DWORD mask, DWORD flags) DECLSPEC_HIDDEN;
 extern void CDECL WAYLAND_SetCursor(HCURSOR hcursor) DECLSPEC_HIDDEN;
+extern void CDECL WAYLAND_SetLayeredWindowAttributes(HWND hwnd, COLORREF key, BYTE alpha, DWORD flags) DECLSPEC_HIDDEN;
 extern void CDECL WAYLAND_SetWindowRgn(HWND hwnd, HRGN hrgn, BOOL redraw) DECLSPEC_HIDDEN;
+extern void CDECL WAYLAND_SetWindowStyle(HWND hwnd, INT offset, STYLESTRUCT *style) DECLSPEC_HIDDEN;
 extern UINT CDECL WAYLAND_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp) DECLSPEC_HIDDEN;
 extern LRESULT CDECL WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam) DECLSPEC_HIDDEN;
 extern INT CDECL WAYLAND_ToUnicodeEx(UINT virt, UINT scan, const BYTE *state,
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 8305ace1b61..f5d9adae6ab 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -128,7 +128,9 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pMapVirtualKeyEx = WAYLAND_MapVirtualKeyEx,
     .pMsgWaitForMultipleObjectsEx = WAYLAND_MsgWaitForMultipleObjectsEx,
     .pSetCursor = WAYLAND_SetCursor,
+    .pSetLayeredWindowAttributes = WAYLAND_SetLayeredWindowAttributes,
     .pSetWindowRgn = WAYLAND_SetWindowRgn,
+    .pSetWindowStyle = WAYLAND_SetWindowStyle,
     .pShowWindow = WAYLAND_ShowWindow,
     .pSysCommand = WAYLAND_SysCommand,
     .pToUnicodeEx = WAYLAND_ToUnicodeEx,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 3728db3cb1e..cb7be660a4f 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -872,6 +872,9 @@ BOOL CDECL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flag
     DWORD style = GetWindowLongW(hwnd, GWL_STYLE);
     HWND parent = GetAncestor(hwnd, GA_PARENT);
     RECT surface_rect;
+    DWORD flags;
+    COLORREF color_key;
+    BYTE alpha;
 
     TRACE("win %p window %s client %s visible %s style %08x ex %08x flags %08x after %p\n",
           hwnd, wine_dbgstr_rect(window_rect), wine_dbgstr_rect(client_rect),
@@ -907,7 +910,16 @@ BOOL CDECL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flag
     }
 
     /* Create new window surface. */
-    *surface = wayland_window_surface_create(data->hwnd, &surface_rect);
+    color_key = alpha = flags = 0;
+    if (!(exstyle & WS_EX_LAYERED) ||
+        !GetLayeredWindowAttributes(hwnd, &color_key, &alpha, &flags))
+    {
+        flags = 0;
+    }
+    if (!(flags & LWA_COLORKEY)) color_key = CLR_INVALID;
+    if (!(flags & LWA_ALPHA)) alpha = 255;
+
+    *surface = wayland_window_surface_create(data->hwnd, &surface_rect, color_key, alpha);
 
 done:
     wayland_win_data_release(data);
@@ -985,6 +997,49 @@ void CDECL WAYLAND_SetWindowRgn(HWND hwnd, HRGN hrgn, BOOL redraw)
     }
 }
 
+/***********************************************************************
+ *           WAYLAND_SetWindowStyle
+ */
+void CDECL WAYLAND_SetWindowStyle(HWND hwnd, INT offset, STYLESTRUCT *style)
+{
+    struct wayland_win_data *data;
+    DWORD changed = style->styleNew ^ style->styleOld;
+
+    TRACE("hwnd=%p offset=%d changed=%#x\n", hwnd, offset, changed);
+
+    if (hwnd == GetDesktopWindow()) return;
+    if (!(data = wayland_win_data_get(hwnd))) return;
+
+    if (offset == GWL_EXSTYLE && (changed & WS_EX_LAYERED))
+    {
+        TRACE("hwnd=%p changed layered\n", hwnd);
+        if (data->window_surface)
+            wayland_window_surface_update_layered(data->window_surface, CLR_INVALID, 255);
+    }
+
+    wayland_win_data_release(data);
+}
+
+/***********************************************************************
+ *	     WAYLAND_SetLayeredWindowAttributes
+ */
+void CDECL WAYLAND_SetLayeredWindowAttributes(HWND hwnd, COLORREF key, BYTE alpha, DWORD flags)
+{
+    struct wayland_win_data *data;
+
+    TRACE("hwnd=%p\n", hwnd);
+
+    if (!(flags & LWA_COLORKEY)) key = CLR_INVALID;
+    if (!(flags & LWA_ALPHA)) alpha = 255;
+
+    if ((data = wayland_win_data_get(hwnd)))
+    {
+        if (data->window_surface)
+            wayland_window_surface_update_layered(data->window_surface, key, alpha);
+        wayland_win_data_release(data);
+    }
+}
+
 static enum xdg_toplevel_resize_edge hittest_to_resize_edge(WPARAM hittest)
 {
     switch (hittest) {
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index b39bb0984db..ef3e86ea53d 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -45,6 +45,8 @@ struct wayland_window_surface
     RECT                  bounds;
     HRGN                  region; /* region set through window_surface funcs */
     HRGN                  total_region; /* Total region (surface->region AND window_region) */
+    COLORREF              color_key;
+    BYTE                  alpha;
     void                 *bits;
     CRITICAL_SECTION      crit;
     BOOL                  last_flush_failed;
@@ -84,7 +86,8 @@ static int get_preferred_format(struct wayland_window_surface *wws)
 
     /* Use ARGB to implement window regions (areas out of the region are
      * transparent). */
-    if ((window_region && GetWindowRgn(wws->hwnd, window_region) != ERROR))
+    if ((window_region && GetWindowRgn(wws->hwnd, window_region) != ERROR) ||
+        wws->color_key != CLR_INVALID || wws->alpha != 255)
         format = WL_SHM_FORMAT_ARGB8888;
     else
         format = WL_SHM_FORMAT_XRGB8888;
@@ -285,9 +288,12 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
 
     if (!needs_flush) goto done;
 
-    TRACE("flushing surface %p hwnd %p surface_rect %s bits %p region %p\n",
+    TRACE("flushing surface %p hwnd %p surface_rect %s bits %p color_key %08x "
+          "alpha %02x compression %d region %p\n",
           wws, wws->hwnd, wine_dbgstr_rect(&wws->header.rect),
-          wws->bits, wws->total_region);
+          wws->bits, wws->color_key, wws->alpha,
+          wws->info.bmiHeader.biCompression,
+          wws->total_region);
 
     assert(wws->wayland_buffer_queue);
 
@@ -326,12 +332,12 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
         height = min(rgn_rect->bottom, buffer->height) - rgn_rect->top;
 
         /* If we have an ARGB buffer we need to explicitly apply the surface
-         * alpha (assumed to be 255 currently) to ensure the destination has
-         * sensible alpha values. */
+         * alpha to ensure the destination has sensible alpha values. */
         apply_surface_alpha = buffer->format == WL_SHM_FORMAT_ARGB8888;
 
         /* Fast path for full width rectangles. */
-        if (width == buffer->width && !apply_surface_alpha)
+        if (width == buffer->width && !apply_surface_alpha &&
+            wws->color_key == CLR_INVALID)
         {
             memcpy(dst, src, height * buffer->stride);
             continue;
@@ -343,11 +349,24 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
             {
                 memcpy(dst, src, width * 4);
             }
-            else
+            else if (wws->alpha == 255)
             {
                 for (x = 0; x < width; x++)
                     dst[x] = 0xff000000 | src[x];
             }
+            else
+            {
+                for (x = 0; x < width; x++)
+                {
+                    dst[x] = ((wws->alpha << 24) |
+                              (((BYTE)(src[x] >> 16) * wws->alpha / 255) << 16) |
+                              (((BYTE)(src[x] >> 8) * wws->alpha / 255) << 8) |
+                              (((BYTE)src[x] * wws->alpha / 255)));
+                }
+            }
+
+            if (wws->color_key != CLR_INVALID)
+                for (x = 0; x < width; x++) if ((src[x] & 0xffffff) == wws->color_key) dst[x] = 0;
 
             src += wws->info.bmiHeader.biWidth;
             dst = (unsigned int*)((unsigned char*)dst + buffer->stride);
@@ -404,7 +423,8 @@ static const struct window_surface_funcs wayland_window_surface_funcs =
 /***********************************************************************
  *           wayland_window_surface_create
  */
-struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect)
+struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect,
+                                                     COLORREF color_key, BYTE alpha)
 {
     struct wayland_window_surface *wws;
     int width = rect->right - rect->left, height = rect->bottom - rect->top;
@@ -428,6 +448,8 @@ struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect
     wws->header.rect  = *rect;
     wws->header.ref   = 1;
     wws->hwnd         = hwnd;
+    wws->color_key    = color_key;
+    wws->alpha        = alpha;
     wayland_window_surface_set_window_region(&wws->header, (HRGN)1);
     reset_bounds(&wws->bounds);
 
@@ -484,3 +506,28 @@ void wayland_window_surface_update_wayland_surface(struct window_surface *window
 
     window_surface->funcs->unlock(window_surface);
 }
+
+/***********************************************************************
+ *           wayland_window_surface_update_layered
+ */
+void wayland_window_surface_update_layered(struct window_surface *window_surface,
+                                           COLORREF color_key, BYTE alpha)
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+
+    window_surface->funcs->lock(window_surface);
+
+    if (alpha != wws->alpha || color_key != wws->color_key)
+        *window_surface->funcs->get_bounds(window_surface) = wws->header.rect;
+
+    wws->alpha = alpha;
+    wws->color_key = color_key;
+
+    if (wws->wayland_buffer_queue &&
+        wws->wayland_buffer_queue->format != get_preferred_format(wws))
+    {
+        recreate_wayland_buffer_queue(wws);
+    }
+
+    window_surface->funcs->unlock(window_surface);
+}
-- 
2.34.1


From c5e60803b9b2d71826557e942813cdb52203fd09 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 9 Sep 2021 14:39:51 +0300
Subject: [PATCH 055/147] winewayland.drv: Implement UpdateLayeredWindow.

Support per-pixel alpha values and background blending.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h      |  9 ++-
 dlls/winewayland.drv/waylanddrv_main.c |  1 +
 dlls/winewayland.drv/window.c          | 98 +++++++++++++++++++++++++-
 dlls/winewayland.drv/window_surface.c  | 39 +++++++---
 4 files changed, 132 insertions(+), 15 deletions(-)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 1473eeaef99..ca32bb73981 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -35,6 +35,7 @@
 #include "windef.h"
 #include "winbase.h"
 #include "wingdi.h"
+#include "winuser.h"
 
 #include "wine/gdi_driver.h"
 
@@ -339,7 +340,8 @@ RGNDATA *wayland_shm_buffer_get_damage_clipped(struct wayland_shm_buffer *shm_bu
  */
 
 struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect,
-                                                     COLORREF color_key, BYTE alpha);
+                                                     COLORREF color_key, BYTE alpha,
+                                                     BOOL src_alpha);
 void CDECL wayland_window_surface_flush(struct window_surface *window_surface);
 BOOL wayland_window_surface_needs_flush(struct window_surface *surface);
 void wayland_window_surface_update_wayland_surface(struct window_surface *surface,
@@ -347,7 +349,8 @@ void wayland_window_surface_update_wayland_surface(struct window_surface *surfac
 void wayland_window_surface_set_window_region(struct window_surface *window_surface,
                                               HRGN win_region);
 void wayland_window_surface_update_layered(struct window_surface *window_surface,
-                                           COLORREF color_key, BYTE alpha);
+                                           COLORREF color_key, BYTE alpha,
+                                           BOOL src_alpha);
 
 /**********************************************************************
  *          Wayland Keyboard
@@ -399,6 +402,8 @@ extern INT CDECL WAYLAND_ToUnicodeEx(UINT virt, UINT scan, const BYTE *state,
                                      LPWSTR buf, int nchars, UINT flags, HKL hkl) DECLSPEC_HIDDEN;
 extern void CDECL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
                                                BOOL force, void *param) DECLSPEC_HIDDEN;
+extern BOOL CDECL WAYLAND_UpdateLayeredWindow(HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
+                                              const RECT *window_rect) DECLSPEC_HIDDEN;
 extern SHORT CDECL WAYLAND_VkKeyScanEx(WCHAR ch, HKL hkl) DECLSPEC_HIDDEN;
 extern LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
 extern void CDECL WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index f5d9adae6ab..34d6a7e3f34 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -134,6 +134,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pShowWindow = WAYLAND_ShowWindow,
     .pSysCommand = WAYLAND_SysCommand,
     .pToUnicodeEx = WAYLAND_ToUnicodeEx,
+    .pUpdateLayeredWindow = WAYLAND_UpdateLayeredWindow,
     .pVkKeyScanEx = WAYLAND_VkKeyScanEx,
     .pThreadDetach = WAYLAND_ThreadDetach,
     .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index cb7be660a4f..68e678ce6ea 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -919,7 +919,7 @@ BOOL CDECL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flag
     if (!(flags & LWA_COLORKEY)) color_key = CLR_INVALID;
     if (!(flags & LWA_ALPHA)) alpha = 255;
 
-    *surface = wayland_window_surface_create(data->hwnd, &surface_rect, color_key, alpha);
+    *surface = wayland_window_surface_create(data->hwnd, &surface_rect, color_key, alpha, FALSE);
 
 done:
     wayland_win_data_release(data);
@@ -1014,7 +1014,7 @@ void CDECL WAYLAND_SetWindowStyle(HWND hwnd, INT offset, STYLESTRUCT *style)
     {
         TRACE("hwnd=%p changed layered\n", hwnd);
         if (data->window_surface)
-            wayland_window_surface_update_layered(data->window_surface, CLR_INVALID, 255);
+            wayland_window_surface_update_layered(data->window_surface, CLR_INVALID, 255, FALSE);
     }
 
     wayland_win_data_release(data);
@@ -1035,11 +1035,103 @@ void CDECL WAYLAND_SetLayeredWindowAttributes(HWND hwnd, COLORREF key, BYTE alph
     if ((data = wayland_win_data_get(hwnd)))
     {
         if (data->window_surface)
-            wayland_window_surface_update_layered(data->window_surface, key, alpha);
+            wayland_window_surface_update_layered(data->window_surface, key, alpha, FALSE);
         wayland_win_data_release(data);
     }
 }
 
+/*****************************************************************************
+ *           WAYLAND_UpdateLayeredWindow
+ */
+BOOL CDECL WAYLAND_UpdateLayeredWindow(HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
+                                       const RECT *window_rect)
+{
+    struct window_surface *window_surface;
+    struct wayland_win_data *data;
+    BLENDFUNCTION blend = { AC_SRC_OVER, 0, 255, 0 };
+    COLORREF color_key = (info->dwFlags & ULW_COLORKEY) ? info->crKey : CLR_INVALID;
+    char buffer[FIELD_OFFSET(BITMAPINFO, bmiColors[256])];
+    BITMAPINFO *bmi = (BITMAPINFO *)buffer;
+    void *src_bits, *dst_bits;
+    RECT rect, src_rect;
+    HDC hdc = 0;
+    HBITMAP dib;
+    BOOL ret = FALSE;
+
+    if (!(data = wayland_win_data_get(hwnd))) return FALSE;
+
+    TRACE("hwnd %p colorkey %x dirty %s flags %x src_alpha %d alpha_format %d\n",
+          hwnd, info->crKey, wine_dbgstr_rect(info->prcDirty), info->dwFlags,
+          info->pblend->SourceConstantAlpha, info->pblend->AlphaFormat == AC_SRC_ALPHA);
+
+    rect = *window_rect;
+    OffsetRect(&rect, -window_rect->left, -window_rect->top);
+
+    window_surface = data->window_surface;
+    if (!window_surface || !EqualRect(&window_surface->rect, &rect))
+    {
+        data->window_surface =
+            wayland_window_surface_create(data->hwnd, &rect, 255, color_key, TRUE);
+        if (window_surface) window_surface_release(window_surface);
+        window_surface = data->window_surface;
+        wayland_window_surface_update_wayland_surface(data->window_surface,
+                                                      data->wayland_surface);
+    }
+    else
+    {
+        wayland_window_surface_update_layered(window_surface, 255, color_key, TRUE);
+    }
+
+    if (window_surface) window_surface_add_ref(window_surface);
+    wayland_win_data_release(data);
+
+    if (!window_surface) return FALSE;
+    if (!info->hdcSrc)
+    {
+        window_surface_release(window_surface);
+        return TRUE;
+    }
+
+    dst_bits = window_surface->funcs->get_info(window_surface, bmi);
+
+    if (!(dib = CreateDIBSection(info->hdcDst, bmi, DIB_RGB_COLORS, &src_bits, NULL, 0))) goto done;
+    if (!(hdc = CreateCompatibleDC(0))) goto done;
+
+    SelectObject(hdc, dib);
+
+    window_surface->funcs->lock(window_surface);
+
+    if (info->prcDirty)
+    {
+        IntersectRect(&rect, &rect, info->prcDirty);
+        memcpy(src_bits, dst_bits, bmi->bmiHeader.biSizeImage);
+        PatBlt(hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, BLACKNESS);
+    }
+    src_rect = rect;
+    if (info->pptSrc) OffsetRect(&src_rect, info->pptSrc->x, info->pptSrc->y);
+    DPtoLP(info->hdcSrc, (POINT *)&src_rect, 2);
+
+    ret = GdiAlphaBlend(hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top,
+                        info->hdcSrc, src_rect.left, src_rect.top,
+                        src_rect.right - src_rect.left, src_rect.bottom - src_rect.top,
+                        (info->dwFlags & ULW_ALPHA) ? *info->pblend : blend);
+    if (ret)
+    {
+        RECT *bounds = window_surface->funcs->get_bounds(window_surface);
+        memcpy(dst_bits, src_bits, bmi->bmiHeader.biSizeImage);
+        UnionRect(bounds, bounds, &rect);
+    }
+
+    window_surface->funcs->unlock(window_surface);
+    window_surface->funcs->flush(window_surface);
+
+done:
+    window_surface_release(window_surface);
+    if (hdc) DeleteDC(hdc);
+    if (dib) DeleteObject(dib);
+    return ret;
+}
+
 static enum xdg_toplevel_resize_edge hittest_to_resize_edge(WPARAM hittest)
 {
     switch (hittest) {
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index ef3e86ea53d..b4061942104 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -47,6 +47,7 @@ struct wayland_window_surface
     HRGN                  total_region; /* Total region (surface->region AND window_region) */
     COLORREF              color_key;
     BYTE                  alpha;
+    BOOL                  src_alpha;
     void                 *bits;
     CRITICAL_SECTION      crit;
     BOOL                  last_flush_failed;
@@ -87,7 +88,7 @@ static int get_preferred_format(struct wayland_window_surface *wws)
     /* Use ARGB to implement window regions (areas out of the region are
      * transparent). */
     if ((window_region && GetWindowRgn(wws->hwnd, window_region) != ERROR) ||
-        wws->color_key != CLR_INVALID || wws->alpha != 255)
+        wws->color_key != CLR_INVALID || wws->alpha != 255 || wws->src_alpha)
         format = WL_SHM_FORMAT_ARGB8888;
     else
         format = WL_SHM_FORMAT_XRGB8888;
@@ -289,9 +290,9 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
     if (!needs_flush) goto done;
 
     TRACE("flushing surface %p hwnd %p surface_rect %s bits %p color_key %08x "
-          "alpha %02x compression %d region %p\n",
+          "alpha %02x src_alpha %d compression %d region %p\n",
           wws, wws->hwnd, wine_dbgstr_rect(&wws->header.rect),
-          wws->bits, wws->color_key, wws->alpha,
+          wws->bits, wws->color_key, wws->alpha, wws->src_alpha,
           wws->info.bmiHeader.biCompression,
           wws->total_region);
 
@@ -332,8 +333,12 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
         height = min(rgn_rect->bottom, buffer->height) - rgn_rect->top;
 
         /* If we have an ARGB buffer we need to explicitly apply the surface
-         * alpha to ensure the destination has sensible alpha values. */
-        apply_surface_alpha = buffer->format == WL_SHM_FORMAT_ARGB8888;
+         * alpha to ensure the destination has sensible alpha values. The
+         * exception is when the surface uses source alpha values and the
+         * surface alpha is 255, in which case we can just copy pixel values
+         * as they are. */
+        apply_surface_alpha = buffer->format == WL_SHM_FORMAT_ARGB8888 &&
+                              (wws->alpha != 255 || !wws->src_alpha);
 
         /* Fast path for full width rectangles. */
         if (width == buffer->width && !apply_surface_alpha &&
@@ -349,12 +354,12 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
             {
                 memcpy(dst, src, width * 4);
             }
-            else if (wws->alpha == 255)
+            else if (wws->alpha == 255 && !wws->src_alpha)
             {
                 for (x = 0; x < width; x++)
                     dst[x] = 0xff000000 | src[x];
             }
-            else
+            else if (!wws->src_alpha)
             {
                 for (x = 0; x < width; x++)
                 {
@@ -364,6 +369,16 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
                               (((BYTE)src[x] * wws->alpha / 255)));
                 }
             }
+            else
+            {
+                for (x = 0; x < width; x++)
+                {
+                    dst[x] = ((((BYTE)(src[x] >> 24) * wws->alpha / 255) << 24) |
+                              (((BYTE)(src[x] >> 16) * wws->alpha / 255) << 16) |
+                              (((BYTE)(src[x] >> 8) * wws->alpha / 255) << 8) |
+                              (((BYTE)src[x] * wws->alpha / 255)));
+                }
+            }
 
             if (wws->color_key != CLR_INVALID)
                 for (x = 0; x < width; x++) if ((src[x] & 0xffffff) == wws->color_key) dst[x] = 0;
@@ -424,7 +439,8 @@ static const struct window_surface_funcs wayland_window_surface_funcs =
  *           wayland_window_surface_create
  */
 struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect,
-                                                     COLORREF color_key, BYTE alpha)
+                                                     COLORREF color_key, BYTE alpha,
+                                                     BOOL src_alpha)
 {
     struct wayland_window_surface *wws;
     int width = rect->right - rect->left, height = rect->bottom - rect->top;
@@ -450,6 +466,7 @@ struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect
     wws->hwnd         = hwnd;
     wws->color_key    = color_key;
     wws->alpha        = alpha;
+    wws->src_alpha    = src_alpha;
     wayland_window_surface_set_window_region(&wws->header, (HRGN)1);
     reset_bounds(&wws->bounds);
 
@@ -511,17 +528,19 @@ void wayland_window_surface_update_wayland_surface(struct window_surface *window
  *           wayland_window_surface_update_layered
  */
 void wayland_window_surface_update_layered(struct window_surface *window_surface,
-                                           COLORREF color_key, BYTE alpha)
+                                           COLORREF color_key, BYTE alpha,
+                                           BOOL src_alpha)
 {
     struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
 
     window_surface->funcs->lock(window_surface);
 
-    if (alpha != wws->alpha || color_key != wws->color_key)
+    if (alpha != wws->alpha || color_key != wws->color_key || src_alpha != wws->src_alpha)
         *window_surface->funcs->get_bounds(window_surface) = wws->header.rect;
 
     wws->alpha = alpha;
     wws->color_key = color_key;
+    wws->src_alpha = src_alpha;
 
     if (wws->wayland_buffer_queue &&
         wws->wayland_buffer_queue->format != get_preferred_format(wws))
-- 
2.34.1


From 22a4bc147ececcb664301ebedba6188554be83f8 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 10 Sep 2021 14:25:25 +0300
Subject: [PATCH 056/147] winewayland.drv: Fix thread safety issue with
 UpdateLayeredWindow.

In some cases, notably when the app calls UpdateLayeredWindow, position
and size changes may be emitted from a thread other than the window
thread. Since in the current implementation updating the Wayland state
needs to happen in the context of the window thread to avoid racy
interactions, post a message to update the state in the right thread.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h |  1 +
 dlls/winewayland.drv/window.c     | 28 +++++++++++++++++++++++++++-
 2 files changed, 28 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index ca32bb73981..1380412282c 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -51,6 +51,7 @@ enum wayland_window_message
     WM_WAYLAND_SET_CURSOR = 0x80001001,
     WM_WAYLAND_QUERY_SURFACE_MAPPED = 0x80001002,
     WM_WAYLAND_CONFIGURE = 0x80001003,
+    WM_WAYLAND_STATE_UPDATE = 0x80001004,
 };
 
 enum wayland_surface_role
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 68e678ce6ea..cf66b86151d 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -73,6 +73,8 @@ struct wayland_win_data
     RECT           old_window_rect;
     /* whether a wayland surface update is needed */
     BOOL           wayland_surface_needs_update;
+    /* Whether we have a pending/unprocessed WM_WAYLAND_STATE_UPDATE message */
+    BOOL           pending_state_update_message;
 };
 
 static CRITICAL_SECTION win_data_section;
@@ -949,7 +951,20 @@ void CDECL WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags
     data->pending_window_surface = surface;
     data->has_pending_window_surface = TRUE;
 
-    update_wayland_state(data);
+    /* In some cases, notably when the app calls UpdateLayeredWindow, position
+     * and size changes may be emitted from a thread other than the window
+     * thread. Since in the current implementation updating the wayland state
+     * needs to happen in the context of the window thread to avoid racy
+     * interactions, post a message to update the state in the right thread. */
+    if (GetCurrentThreadId() == GetWindowThreadProcessId(hwnd, NULL))
+    {
+        update_wayland_state(data);
+    }
+    else if (!data->pending_state_update_message)
+    {
+        PostMessageW(hwnd, WM_WAYLAND_STATE_UPDATE, 0, 0);
+        data->pending_state_update_message = TRUE;
+    }
 
     wayland_win_data_release(data);
 }
@@ -1390,6 +1405,17 @@ LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
             wayland_surface_for_hwnd_unlock(wayland_surface);
         }
         break;
+    case WM_WAYLAND_STATE_UPDATE:
+        {
+            struct wayland_win_data *data = wayland_win_data_get(hwnd);
+            if (data)
+            {
+                data->pending_state_update_message = FALSE;
+                update_wayland_state(data);
+                wayland_win_data_release(data);
+            }
+        }
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp);
     }
-- 
2.34.1


From 2306db69f11cc76223bf6a786ac67dfb708484df Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 10 Sep 2021 15:38:48 +0300
Subject: [PATCH 057/147] winewayland.drv: Store a list of Wayland child
 surfaces.

Make each Wayland surfaces aware of its subsurfaces, and also maintain a
list of toplevel surfaces. This will allow us to efficiently apply
property changes (e.g., changing the output associated with a surface)
to whole surface tree hierarchies in upcoming commits.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c         |  5 +++
 dlls/winewayland.drv/wayland_surface.c | 52 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  3 ++
 3 files changed, 60 insertions(+)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 421142b92c1..593e88b675f 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -240,6 +240,7 @@ BOOL wayland_init(struct wayland *wayland)
     wl_proxy_set_queue((struct wl_proxy *) wayland->wl_registry, wayland->wl_event_queue);
 
     wl_list_init(&wayland->output_list);
+    wl_list_init(&wayland->toplevel_list);
 
     /* Populate registry */
     wl_registry_add_listener(wayland->wl_registry, &registry_listener, wayland);
@@ -282,6 +283,7 @@ BOOL wayland_init(struct wayland *wayland)
 void wayland_deinit(struct wayland *wayland)
 {
     struct wayland_output *output, *output_tmp;
+    struct wayland_surface *toplevel, *toplevel_tmp;
 
     TRACE("%p\n", wayland);
 
@@ -289,6 +291,9 @@ void wayland_deinit(struct wayland *wayland)
     wl_list_remove(&wayland->thread_link);
     LeaveCriticalSection(&thread_wayland_section);
 
+    wl_list_for_each_safe(toplevel, toplevel_tmp, &wayland->toplevel_list, link)
+        wayland_surface_destroy(toplevel);
+
     if (wayland->event_notification_pipe[0] >= 0)
         close(wayland->event_notification_pipe[0]);
     if (wayland->event_notification_pipe[1] >= 0)
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 72b95c0d148..f6ea816b3b0 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -153,6 +153,8 @@ struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland)
     if (!surface->wl_surface)
         goto err;
 
+    wl_list_init(&surface->link);
+    wl_list_init(&surface->child_list);
     wl_surface_set_user_data(surface->wl_surface, surface);
     /* Plain surfaces are unmappable, so don't draw on them. */
     surface->drawing_allowed = FALSE;
@@ -160,6 +162,10 @@ struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland)
     surface->ref = 1;
     surface->role = WAYLAND_SURFACE_ROLE_NONE;
 
+    /* Although not technically toplevel, plain surfaces have no parent, so
+     * track them in the toplevel list. */
+    wl_list_insert(&wayland->toplevel_list, &surface->link);
+
     return surface;
 
 err:
@@ -197,6 +203,9 @@ void wayland_surface_make_toplevel(struct wayland_surface *surface,
     if (parent && parent->xdg_toplevel)
         xdg_toplevel_set_parent(surface->xdg_toplevel, parent->xdg_toplevel);
 
+    /* Plain surfaces (which are the only kind can become toplevel) are
+     * already tracked in the toplevel_list, there is no need to readd. */
+
     wl_surface_commit(surface->wl_surface);
 
     surface->role = WAYLAND_SURFACE_ROLE_TOPLEVEL;
@@ -232,6 +241,14 @@ void wayland_surface_make_subsurface(struct wayland_surface *surface,
     surface->drawing_allowed = TRUE;
 
     surface->parent = wayland_surface_ref(parent);
+
+    /* Remove from toplevel_list (added as a plain surface) and add to parent
+     * child list. */
+    wl_list_remove(&surface->link);
+    EnterCriticalSection(&parent->crit);
+    wl_list_insert(&parent->child_list, &surface->link);
+    LeaveCriticalSection(&parent->crit);
+
     surface->wl_subsurface =
         wl_subcompositor_get_subsurface(wayland->wl_subcompositor,
                                         surface->wl_surface,
@@ -265,6 +282,18 @@ void wayland_surface_clear_role(struct wayland_surface *surface)
 
     surface->drawing_allowed = FALSE;
 
+    if (surface->parent)
+    {
+        /* As a plain surface, this should now tracked in the toplevel_list. */
+        EnterCriticalSection(&surface->parent->crit);
+        wl_list_remove(&surface->link);
+        LeaveCriticalSection(&surface->parent->crit);
+        wl_list_insert(&surface->wayland->toplevel_list, &surface->link);
+
+        wayland_surface_unref(surface->parent);
+        surface->parent = NULL;
+    }
+
     if (surface->xdg_toplevel)
     {
         xdg_toplevel_destroy(surface->xdg_toplevel);
@@ -515,6 +544,7 @@ void wayland_surface_destroy(struct wayland_surface *surface)
 {
     struct wayland_pointer *pointer = &surface->wayland->pointer;
     struct wayland_keyboard *keyboard = &surface->wayland->keyboard;
+    struct wayland_surface *child, *child_tmp;
 
     TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
 
@@ -524,6 +554,20 @@ void wayland_surface_destroy(struct wayland_surface *surface)
     if (keyboard->focused_surface == surface)
         keyboard->focused_surface = NULL;
 
+    /* There are children left only when we force a destruction during
+     * thread deinitialization, otherwise the children hold a reference
+     * to the parent and won't let it be destroyed. */
+    EnterCriticalSection(&surface->crit);
+    wl_list_for_each_safe(child, child_tmp, &surface->child_list, link)
+    {
+        /* Since the current surface (the parent) is being destroyed,
+         * disassociate from the child to avoid the child trying to
+         * destroy the parent. */
+        child->parent = NULL;
+        wayland_surface_destroy(child);
+    }
+    LeaveCriticalSection(&surface->crit);
+
     if (surface->xdg_toplevel)
     {
         xdg_toplevel_destroy(surface->xdg_toplevel);
@@ -550,9 +594,17 @@ void wayland_surface_destroy(struct wayland_surface *surface)
 
     if (surface->parent)
     {
+        EnterCriticalSection(&surface->parent->crit);
+        wl_list_remove(&surface->link);
+        LeaveCriticalSection(&surface->parent->crit);
+
         wayland_surface_unref(surface->parent);
         surface->parent = NULL;
     }
+    else
+    {
+        wl_list_remove(&surface->link);
+    }
 
     surface->crit.DebugInfo->Spare[0] = 0;
     DeleteCriticalSection(&surface->crit);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 1380412282c..801d20f70fa 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -126,6 +126,7 @@ struct wayland
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t next_fallback_output_id;
     struct wl_list output_list;
+    struct wl_list toplevel_list;
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
     DWORD last_dispatch_mask;
@@ -173,6 +174,7 @@ struct wayland_surface_configure
 
 struct wayland_surface
 {
+    struct wl_list link;
     struct wayland *wayland;
     struct wl_surface *wl_surface;
     struct wl_subsurface *wl_subsurface;
@@ -187,6 +189,7 @@ struct wayland_surface
     LONG ref;
     enum wayland_surface_role role;
     BOOL drawing_allowed;
+    struct wl_list child_list;
 };
 
 struct wayland_buffer_queue
-- 
2.34.1


From e5973a800854280ea3af2c910ab77587ab1efe58 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 27 Oct 2021 17:41:37 +0300
Subject: [PATCH 058/147] winewayland.drv: Update children surfaces when parent
 is updated

When a parent Wayland surface is recreated, mark the children surfaces
as requiring an update, so that the get eventually recreated using the
new parent.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/window.c | 19 +++++++++++++++++++
 1 file changed, 19 insertions(+)

diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index cf66b86151d..0bd27f82b0c 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -514,7 +514,26 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
     if (data->wayland_surface != surface)
     {
         if (data->wayland_surface)
+        {
+            struct wayland_surface *child;
+
+            /* Dependent Wayland surfaces require an update, so that they point
+             * to the updated surface. */
+            EnterCriticalSection(&data->wayland_surface->crit);
+            wl_list_for_each(child, &data->wayland_surface->child_list, link)
+            {
+                struct wayland_win_data *child_data;
+                if ((child_data = wayland_win_data_get(child->hwnd)))
+                {
+                    child_data->wayland_surface_needs_update = TRUE;
+                    wayland_win_data_release(child_data);
+                }
+            }
+            LeaveCriticalSection(&data->wayland_surface->crit);
+
             wayland_surface_unref(data->wayland_surface);
+        }
+
         data->wayland_surface = surface;
     }
 }
-- 
2.34.1


From 0a6b0257924d31ab2a17c766bd995fc96eaf51ea Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 10 Sep 2021 18:40:24 +0300
Subject: [PATCH 059/147] winewayland.drv: Handle Wayland surface output
 positioning.

Track the output(s) a Wayland surface is visible in, to allow us to
update the position of the associated window in the Windows virtual
screen space.

We always place windows at the top-left origin of their main output.
The main output is updated to be the leftmost output a surface has
entered. Support for more intuitive handling of windows with RTL layouts
remains to be done.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c         |   8 ++
 dlls/winewayland.drv/wayland_surface.c | 153 ++++++++++++++++++++++++-
 dlls/winewayland.drv/waylanddrv.h      |  11 ++
 dlls/winewayland.drv/window.c          |  87 ++++++++++++--
 4 files changed, 251 insertions(+), 8 deletions(-)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 593e88b675f..10713e29871 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -181,7 +181,15 @@ static void registry_handle_global_remove(void *data, struct wl_registry *regist
     {
         if (output->global_id == id)
         {
+            struct wayland_surface *surface;
+
             TRACE("removing output->name=%s\n", output->name);
+
+            /* Remove the output from toplevels, as some compositors don't send
+             * a leave event if the output is disconnected. */
+            wl_list_for_each(surface, &wayland->toplevel_list, link)
+                wayland_surface_leave_output(surface, output);
+
             wayland_output_destroy(output);
             if (wayland_is_process(wayland))
                 wayland_init_display_devices();
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index f6ea816b3b0..5d88ef88d87 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -28,6 +28,9 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+static void wayland_surface_set_main_output(struct wayland_surface *surface,
+                                            struct wayland_output *output);
+
 static void handle_xdg_surface_configure(void *data, struct xdg_surface *xdg_surface,
                                          uint32_t serial)
 {
@@ -129,6 +132,72 @@ static const struct xdg_toplevel_listener xdg_toplevel_listener = {
     handle_xdg_toplevel_close,
 };
 
+static struct wayland_output *wayland_surface_get_origin_output(
+        struct wayland_surface *surface)
+{
+    struct wayland_output_ref *ref;
+    struct wayland_output *leftmost = NULL;
+
+    /* The leftmost entered output is the origin.
+     * TODO: Consider Right-To-Left setups. */
+    wl_list_for_each(ref, &surface->output_ref_list, link)
+    {
+        if (!leftmost || ref->output->x < leftmost->x)
+            leftmost = ref->output;
+    }
+
+    return leftmost;
+}
+
+static void handle_wl_surface_enter(void *data,
+                                    struct wl_surface *wl_surface,
+                                    struct wl_output *wl_output)
+{
+    struct wayland_surface *surface = data;
+    struct wayland_output *output =
+        wl_output ? wl_output_get_user_data(wl_output) : NULL;
+    struct wayland_output_ref *ref;
+    struct wayland_output *origin;
+
+    /* We want enter/leave events only for toplevels */
+    if (!surface->xdg_toplevel) return;
+
+    if (!output || output->wayland != surface->wayland) return;
+
+    TRACE("hwnd=%p output->name=%s\n", surface->hwnd, output->name);
+
+    ref = heap_alloc_zero(sizeof(*ref));
+    if (!ref) { ERR("memory allocation failed"); return; }
+    ref->output = output;
+    wl_list_insert(&surface->output_ref_list, &ref->link);
+
+    origin = wayland_surface_get_origin_output(surface);
+    wayland_surface_set_main_output(surface, origin);
+}
+
+static void handle_wl_surface_leave(void *data,
+                                    struct wl_surface *wl_surface,
+                                    struct wl_output *wl_output)
+{
+    struct wayland_surface *surface = data;
+    struct wayland_output *output =
+        wl_output ? wl_output_get_user_data(wl_output) : NULL;
+
+    /* We want enter/leave events only for toplevels */
+    if (!surface->xdg_toplevel) return;
+
+    if (!output || output->wayland != surface->wayland) return;
+
+    TRACE("hwnd=%p output->name=%s\n", surface->hwnd, output->name);
+
+    wayland_surface_leave_output(surface, output);
+}
+
+static const struct wl_surface_listener wl_surface_listener = {
+    handle_wl_surface_enter,
+    handle_wl_surface_leave,
+};
+
 /**********************************************************************
  *          wayland_surface_create_plain
  *
@@ -153,9 +222,10 @@ struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland)
     if (!surface->wl_surface)
         goto err;
 
+    wl_list_init(&surface->output_ref_list);
     wl_list_init(&surface->link);
     wl_list_init(&surface->child_list);
-    wl_surface_set_user_data(surface->wl_surface, surface);
+    wl_surface_add_listener(surface->wl_surface, &wl_surface_listener, surface);
     /* Plain surfaces are unmappable, so don't draw on them. */
     surface->drawing_allowed = FALSE;
 
@@ -257,6 +327,8 @@ void wayland_surface_make_subsurface(struct wayland_surface *surface,
         goto err;
     wl_subsurface_set_desync(surface->wl_subsurface);
 
+    surface->main_output = parent->main_output;
+
     wl_surface_commit(surface->wl_surface);
 
     surface->role = WAYLAND_SURFACE_ROLE_SUBSURFACE;
@@ -545,6 +617,7 @@ void wayland_surface_destroy(struct wayland_surface *surface)
     struct wayland_pointer *pointer = &surface->wayland->pointer;
     struct wayland_keyboard *keyboard = &surface->wayland->keyboard;
     struct wayland_surface *child, *child_tmp;
+    struct wayland_output_ref *ref, *ref_tmp;
 
     TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
 
@@ -568,6 +641,12 @@ void wayland_surface_destroy(struct wayland_surface *surface)
     }
     LeaveCriticalSection(&surface->crit);
 
+    wl_list_for_each_safe(ref, ref_tmp, &surface->output_ref_list, link)
+    {
+        wl_list_remove(&ref->link);
+        heap_free(ref);
+    }
+
     if (surface->xdg_toplevel)
     {
         xdg_toplevel_destroy(surface->xdg_toplevel);
@@ -723,3 +802,75 @@ void wayland_surface_unref(struct wayland_surface *surface)
     if (ref == 0)
         wayland_surface_destroy(surface);
 }
+
+static void wayland_surface_tree_set_main_output(struct wayland_surface *surface,
+                                                 struct wayland_output *output)
+{
+    struct wayland_surface *child;
+
+    surface->main_output = output;
+
+    EnterCriticalSection(&surface->crit);
+
+    wl_list_for_each(child, &surface->child_list, link)
+        wayland_surface_tree_set_main_output(child, output);
+
+    LeaveCriticalSection(&surface->crit);
+}
+
+/**********************************************************************
+ *          wayland_surface_set_main_output
+ *
+ * Sets the main output for a surface, i.e., the output whose scale will be
+ * used for surface scaling.
+ */
+static void wayland_surface_set_main_output(struct wayland_surface *surface,
+                                            struct wayland_output *output)
+{
+    /* Don't update non-toplevels. */
+    if (surface->parent) return;
+
+    TRACE("surface=%p output->name=%s => output->name=%s\n",
+          surface,
+          surface->main_output ? surface->main_output->name : NULL,
+          output ? output->name : NULL);
+
+    if (surface->main_output != output)
+    {
+        wayland_surface_tree_set_main_output(surface, output);
+        if (surface->hwnd)
+            SendMessageW(surface->hwnd, WM_WAYLAND_SURFACE_OUTPUT_CHANGE, 0, 0);
+    }
+}
+
+/**********************************************************************
+ *          wayland_surface_leave_output
+ *
+ * Removes an output from the set of outputs a surface is presented on.
+ *
+ * It is OK to call this function even if the surface is not presented
+ * on the specified output, in which case this function is a NOP.
+ */
+void wayland_surface_leave_output(struct wayland_surface *surface,
+                                  struct wayland_output *output)
+{
+    struct wayland_output_ref *ref, *tmp;
+
+    wl_list_for_each_safe(ref, tmp, &surface->output_ref_list, link)
+    {
+        if (ref->output == output)
+        {
+            wl_list_remove(&ref->link);
+            heap_free(ref);
+            break;
+        }
+    }
+
+    if (surface->main_output == output)
+    {
+        struct wayland_output *origin =
+            wayland_surface_get_origin_output(surface);
+
+        wayland_surface_set_main_output(surface, origin);
+    }
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 801d20f70fa..ed659873f20 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -52,6 +52,7 @@ enum wayland_window_message
     WM_WAYLAND_QUERY_SURFACE_MAPPED = 0x80001002,
     WM_WAYLAND_CONFIGURE = 0x80001003,
     WM_WAYLAND_STATE_UPDATE = 0x80001004,
+    WM_WAYLAND_SURFACE_OUTPUT_CHANGE = 0x80001005,
 };
 
 enum wayland_surface_role
@@ -172,6 +173,12 @@ struct wayland_surface_configure
     BOOL processed;
 };
 
+struct wayland_output_ref
+{
+    struct wl_list link;
+    struct wayland_output *output;
+};
+
 struct wayland_surface
 {
     struct wl_list link;
@@ -188,6 +195,8 @@ struct wayland_surface
     BOOL mapped;
     LONG ref;
     enum wayland_surface_role role;
+    struct wl_list output_ref_list;
+    struct wayland_output *main_output;
     BOOL drawing_allowed;
     struct wl_list child_list;
 };
@@ -325,6 +334,8 @@ void wayland_surface_coords_to_wine(struct wayland_surface *surface,
                                     int *wine_x, int *wine_y);
 struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface);
 void wayland_surface_unref(struct wayland_surface *surface);
+void wayland_surface_leave_output(struct wayland_surface *surface,
+                                  struct wayland_output *output);
 
 /**********************************************************************
  *          Wayland SHM buffer
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 0bd27f82b0c..e6cd2efec19 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -1311,13 +1311,22 @@ static LRESULT handle_wm_wayland_configure(HWND hwnd)
      * to the user from a wayland compositor pespective. To mitigate this, we
      * place all top-level windows at 0,0, to maximize the area that can reside
      * within the win32 display. */
-    origin_x = 0;
-    origin_y = 0;
-    needs_move_to_origin = data->window_rect.top != origin_x ||
-                           data->window_rect.left != origin_y;
-    TRACE("current=%d,%d origin=%d,%d\n",
-          data->window_rect.left, data->window_rect.top,
-          origin_x, origin_y);
+    if (data->wayland_surface->main_output)
+    {
+        origin_x = data->wayland_surface->main_output->x;
+        origin_y = data->wayland_surface->main_output->y;
+        needs_move_to_origin = data->window_rect.top != origin_x ||
+                               data->window_rect.left != origin_y;
+        TRACE("current=%d,%d origin=%d,%d\n",
+              data->window_rect.left, data->window_rect.top,
+              origin_x, origin_y);
+    }
+    else
+    {
+        origin_x = 0;
+        origin_y = 0;
+        needs_move_to_origin = FALSE;
+    }
 
     wayland_win_data_release(data);
 
@@ -1368,6 +1377,67 @@ static void CALLBACK post_configure(HWND hwnd, UINT msg, UINT_PTR timer_id, DWOR
     handle_wm_wayland_configure(hwnd);
 }
 
+static void handle_wm_wayland_surface_output_change(HWND hwnd)
+{
+    struct wayland_surface *wsurface;
+    int x, y, w, h;
+    UINT swp_flags;
+
+    TRACE("hwnd=%p\n", hwnd);
+
+    wsurface = wayland_surface_for_hwnd_lock(hwnd);
+    if (!wsurface || !wsurface->xdg_toplevel)
+    {
+        TRACE("no suitable wayland surface, returning\n");
+        goto out;
+    }
+
+    swp_flags = SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOOWNERZORDER |
+                SWP_FRAMECHANGED | SWP_NOSENDCHANGING;
+
+    if (wsurface->main_output)
+    {
+        x = wsurface->main_output->x;
+        y = wsurface->main_output->y;
+        TRACE("moving window to %d,%d\n", x, y);
+    }
+    else
+    {
+        x = y = 0;
+        swp_flags |= SWP_NOMOVE;
+    }
+
+    /* If we are fullscreen or maximized we need to provide a particular buffer
+     * size to the wayland compositor on the new output (hence swp_flags
+     * includes SWP_NOSENDCHANGING). */
+    if (wsurface->current.serial &&
+        (wsurface->current.configure_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
+    {
+        wayland_surface_coords_to_wine(wsurface, wsurface->current.width,
+                                       wsurface->current.height,
+                                       &w, &h);
+        TRACE("resizing window to maximized %dx%d\n", w, h);
+    }
+    else if (wsurface->current.serial &&
+             (wsurface->current.configure_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN))
+    {
+        wayland_surface_coords_to_wine(wsurface, wsurface->current.width,
+                                       wsurface->current.height,
+                                       &w, &h);
+        TRACE("resizing window to fullscreen %dx%d\n", w, h);
+    }
+    else
+    {
+        w = h = 0;
+        swp_flags |= SWP_NOSIZE;
+    }
+
+    SetWindowPos(hwnd, 0, x, y, w, h, swp_flags);
+
+out:
+    wayland_surface_for_hwnd_unlock(wsurface);
+}
+
 /**********************************************************************
  *           WAYLAND_WindowMessage
  */
@@ -1435,6 +1505,9 @@ LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
             }
         }
         break;
+    case WM_WAYLAND_SURFACE_OUTPUT_CHANGE:
+        handle_wm_wayland_surface_output_change(hwnd);
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp);
     }
-- 
2.34.1


From 83f48b6f24a0dce13df6e890f0ef48f01fd4cfaa Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 26 Oct 2021 13:16:38 +0300
Subject: [PATCH 060/147] winewayland.drv: Track the Wayland output containing
 a window.

Track the output Wine considers to contain the window backed by a
surface. Transiently, this may be different from the output we consider
to be the "main" one for this surface. We will use this information in
upcoming commits to make an educated guess about which Wayland output a
surface will be displayed on, in case the Wayland compositor has not yet
sent the relevant output enter event(s) for a surface.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c         |  4 +++
 dlls/winewayland.drv/wayland_surface.c | 38 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  3 ++
 dlls/winewayland.drv/window.c          |  2 ++
 4 files changed, 47 insertions(+)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 10713e29871..414c2c4885b 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -188,7 +188,11 @@ static void registry_handle_global_remove(void *data, struct wl_registry *regist
             /* Remove the output from toplevels, as some compositors don't send
              * a leave event if the output is disconnected. */
             wl_list_for_each(surface, &wayland->toplevel_list, link)
+            {
                 wayland_surface_leave_output(surface, output);
+                if (surface->wine_output == output)
+                    wayland_surface_set_wine_output(surface, NULL);
+            }
 
             wayland_output_destroy(output);
             if (wayland_is_process(wayland))
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 5d88ef88d87..8f90e94b85c 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -328,6 +328,7 @@ void wayland_surface_make_subsurface(struct wayland_surface *surface,
     wl_subsurface_set_desync(surface->wl_subsurface);
 
     surface->main_output = parent->main_output;
+    surface->wine_output = parent->wine_output;
 
     wl_surface_commit(surface->wl_surface);
 
@@ -874,3 +875,40 @@ void wayland_surface_leave_output(struct wayland_surface *surface,
         wayland_surface_set_main_output(surface, origin);
     }
 }
+
+static void wayland_surface_tree_set_wine_output(struct wayland_surface *surface,
+                                                 struct wayland_output *output)
+{
+    struct wayland_surface *child;
+
+    surface->wine_output = output;
+
+    EnterCriticalSection(&surface->crit);
+
+    wl_list_for_each(child, &surface->child_list, link)
+        wayland_surface_tree_set_wine_output(child, output);
+
+    LeaveCriticalSection(&surface->crit);
+}
+
+/**********************************************************************
+ *          wayland_surface_set_wine_output
+ *
+ * Sets the output which Wine considers to contain the window backed by this
+ * surface. Transiently, this may be different from the output we consider to
+ * be the "main" one for this surface.
+ */
+void wayland_surface_set_wine_output(struct wayland_surface *surface,
+                                     struct wayland_output *output)
+{
+    /* Don't update non-toplevels. */
+    if (surface->parent) return;
+
+    TRACE("surface=%p output->name=%s => output->name=%s\n",
+          surface,
+          surface->wine_output ? surface->wine_output->name : NULL,
+          output ? output->name : NULL);
+
+    if (surface->wine_output != output)
+        wayland_surface_tree_set_wine_output(surface, output);
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index ed659873f20..00451445faf 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -197,6 +197,7 @@ struct wayland_surface
     enum wayland_surface_role role;
     struct wl_list output_ref_list;
     struct wayland_output *main_output;
+    struct wayland_output *wine_output;
     BOOL drawing_allowed;
     struct wl_list child_list;
 };
@@ -336,6 +337,8 @@ struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface);
 void wayland_surface_unref(struct wayland_surface *surface);
 void wayland_surface_leave_output(struct wayland_surface *surface,
                                   struct wayland_output *output);
+void wayland_surface_set_wine_output(struct wayland_surface *surface,
+                                     struct wayland_output *output);
 
 /**********************************************************************
  *          Wayland SHM buffer
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index e6cd2efec19..8fe743c49ef 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -571,6 +571,8 @@ static BOOL wayland_win_data_update_wayland_xdg_state(struct wayland_win_data *d
           mi.rcMonitor.bottom - mi.rcMonitor.top,
           data->maximized, data->fullscreen, data->handling_wayland_configure_event);
 
+    wayland_surface_set_wine_output(data->wayland_surface, output);
+
     /* If we are currently handling a wayland configure event (i.e., we are
      * being called through handle_wm_wayland_configure() -> SetWindowPos()),
      * use the event configure flags directly. Otherwise try to infer the flags
-- 
2.34.1


From b32be7ca9e15c515dba875c57e71cdf41e5498fa Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Sat, 11 Sep 2021 01:51:44 +0300
Subject: [PATCH 061/147] winewayland.drv: Use output scale on Wayland surface
 buffers.

Use the scale of the main output of each Wayland surface to always
render at the native resolution on that output. This effectively turns
off compositor-side scaling, giving applications/Wine complete control
over how to scale.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_cursor.c  |  5 +++
 dlls/winewayland.drv/wayland_surface.c | 56 ++++++++++++++++++++++----
 dlls/winewayland.drv/waylanddrv.h      |  1 +
 3 files changed, 54 insertions(+), 8 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_cursor.c b/dlls/winewayland.drv/wayland_cursor.c
index 24c67199594..06053cde139 100644
--- a/dlls/winewayland.drv/wayland_cursor.c
+++ b/dlls/winewayland.drv/wayland_cursor.c
@@ -275,6 +275,11 @@ void wayland_pointer_update_cursor_from_win32(struct wayland_pointer *pointer,
                              0, 0,
                              wayland_cursor->shm_buffer->width,
                              wayland_cursor->shm_buffer->height);
+    if (pointer->focused_surface)
+        wl_surface_set_buffer_scale(pointer->cursor_wl_surface,
+                                    wayland_surface_get_buffer_scale(pointer->focused_surface));
+    else
+        wl_surface_set_buffer_scale(pointer->cursor_wl_surface, 1);
 
     wl_surface_commit(pointer->cursor_wl_surface);
 
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 8f90e94b85c..fca1e4205f2 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -329,6 +329,8 @@ void wayland_surface_make_subsurface(struct wayland_surface *surface,
 
     surface->main_output = parent->main_output;
     surface->wine_output = parent->wine_output;
+    wl_surface_set_buffer_scale(surface->wl_surface,
+                                wayland_surface_get_buffer_scale(parent));
 
     wl_surface_commit(surface->wl_surface);
 
@@ -710,6 +712,17 @@ void wayland_surface_unmap(struct wayland_surface *surface)
     LeaveCriticalSection(&surface->crit);
 }
 
+/* If the surface has a main output set, use that, otherwise use the output
+ * which Wine considers to contain the associated window. */
+static struct wayland_output *wayland_surface_get_main_output(
+        struct wayland_surface *surface)
+{
+    if (surface->main_output)
+        return surface->main_output;
+
+    return surface->wine_output;
+}
+
 /**********************************************************************
  *          wayland_surface_coords_to_screen
  *
@@ -744,8 +757,10 @@ void wayland_surface_coords_from_wine(struct wayland_surface *surface,
                                       int wine_x, int wine_y,
                                       double *wayland_x, double *wayland_y)
 {
-    *wayland_x = wine_x;
-    *wayland_y = wine_y;
+    int scale = wayland_surface_get_buffer_scale(surface);
+
+    *wayland_x = wine_x / (double)scale;
+    *wayland_y = wine_y / (double)scale;
 }
 
 /**********************************************************************
@@ -773,8 +788,10 @@ void wayland_surface_coords_to_wine(struct wayland_surface *surface,
                                     double wayland_x, double wayland_y,
                                     int *wine_x, int *wine_y)
 {
-    *wine_x = round(wayland_x);
-    *wine_y = round(wayland_y);
+    int scale = wayland_surface_get_buffer_scale(surface);
+
+    *wine_x = round(wayland_x * scale);
+    *wine_y = round(wayland_y * scale);
 }
 
 /**********************************************************************
@@ -804,17 +821,19 @@ void wayland_surface_unref(struct wayland_surface *surface)
         wayland_surface_destroy(surface);
 }
 
-static void wayland_surface_tree_set_main_output(struct wayland_surface *surface,
-                                                 struct wayland_output *output)
+static void wayland_surface_tree_set_main_output_and_scale(struct wayland_surface *surface,
+                                                           struct wayland_output *output,
+                                                           int scale)
 {
     struct wayland_surface *child;
 
     surface->main_output = output;
+    wl_surface_set_buffer_scale(surface->wl_surface, scale);
 
     EnterCriticalSection(&surface->crit);
 
     wl_list_for_each(child, &surface->child_list, link)
-        wayland_surface_tree_set_main_output(child, output);
+        wayland_surface_tree_set_main_output_and_scale(child, output, scale);
 
     LeaveCriticalSection(&surface->crit);
 }
@@ -838,7 +857,8 @@ static void wayland_surface_set_main_output(struct wayland_surface *surface,
 
     if (surface->main_output != output)
     {
-        wayland_surface_tree_set_main_output(surface, output);
+        wayland_surface_tree_set_main_output_and_scale(surface, output,
+                                                       output ? output->scale : 1);
         if (surface->hwnd)
             SendMessageW(surface->hwnd, WM_WAYLAND_SURFACE_OUTPUT_CHANGE, 0, 0);
     }
@@ -912,3 +932,23 @@ void wayland_surface_set_wine_output(struct wayland_surface *surface,
     if (surface->wine_output != output)
         wayland_surface_tree_set_wine_output(surface, output);
 }
+
+/**********************************************************************
+ *          wayland_surface_get_buffer_scale
+ *
+ */
+int wayland_surface_get_buffer_scale(struct wayland_surface *surface)
+{
+    /* Use the toplevel surface to get the scale */
+    struct wayland_surface *toplevel = surface;
+    struct wayland_output *output;
+    int scale = 1;
+
+    while (toplevel->parent) toplevel = toplevel->parent;
+
+    output = wayland_surface_get_main_output(surface);
+    if (output) scale = output->scale;
+
+    TRACE("hwnd=%p (toplevel=%p) => scale=%d\n", surface->hwnd, toplevel->hwnd, scale);
+    return scale;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 00451445faf..21183bbdcb9 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -339,6 +339,7 @@ void wayland_surface_leave_output(struct wayland_surface *surface,
                                   struct wayland_output *output);
 void wayland_surface_set_wine_output(struct wayland_surface *surface,
                                      struct wayland_output *output);
+int wayland_surface_get_buffer_scale(struct wayland_surface *surface);
 
 /**********************************************************************
  *          Wayland SHM buffer
-- 
2.34.1


From be9289d56574f2cdb8dea5591528c777ce15fd30 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 13 Sep 2021 17:14:48 +0300
Subject: [PATCH 062/147] winewayland.drv: Support tracking the Wine current
 display mode.

Track the Wine current display mode independently from the Wayland
current display mode, so these two are can be made to differ in upcoming
commits.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/display.c        | 32 ++++++++++++++++++++-------
 dlls/winewayland.drv/wayland_output.c |  6 +++++
 dlls/winewayland.drv/waylanddrv.h     |  1 +
 3 files changed, 31 insertions(+), 8 deletions(-)

diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index 1aa6dc3333e..a4d609330e0 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -60,9 +60,9 @@ static void wayland_broadcast_wm_display_change(void)
         wl_list_for_each(output, &wayland->output_list, link)
         {
             int width, height;
-            if (!output->current_mode) continue;
-            width = output->current_mode->width;
-            height = output->current_mode->height;
+            if (!output->current_wine_mode) continue;
+            width = output->current_wine_mode->width;
+            height = output->current_wine_mode->height;
             wayland_process_release();
 
             SendMessageW(GetDesktopWindow(), WM_WAYLAND_BROADCAST_DISPLAY_CHANGE,
@@ -123,8 +123,8 @@ static void wayland_add_monitor(const struct gdi_device_manager *device_manager,
     }
 
     SetRect(&monitor.rc_monitor, output->x, output->y,
-            output->x + output->current_mode->width,
-            output->y + output->current_mode->height);
+            output->x + output->current_wine_mode->width,
+            output->y + output->current_wine_mode->height);
 
     /* We don't have a direct way to get the work area in Wayland. */
     monitor.rc_work = monitor.rc_monitor;
@@ -160,7 +160,7 @@ void CDECL WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_
 
     wl_list_for_each(output, &wayland->output_list, link)
     {
-        if (!output->current_mode) continue;
+        if (!output->current_wine_mode) continue;
 
         /* TODO: Detect and support multiple monitors per adapter (i.e., mirroring). */
         wayland_add_adapter(device_manager, param, output_id);
@@ -303,7 +303,7 @@ static void populate_devmode(struct wayland_output_mode *output_mode, DEVMODEW *
     mode->dmDisplayFrequency = output_mode->refresh / 1000;
 }
 
-static BOOL wayland_get_current_devmode(struct wayland *wayland, LPCWSTR name, DEVMODEW *mode)
+static BOOL wayland_get_native_devmode(struct wayland *wayland, LPCWSTR name, DEVMODEW *mode)
 {
     struct wayland_output *output;
 
@@ -319,6 +319,22 @@ static BOOL wayland_get_current_devmode(struct wayland *wayland, LPCWSTR name, D
     return TRUE;
 }
 
+static BOOL wayland_get_current_devmode(struct wayland *wayland, LPCWSTR name, DEVMODEW *mode)
+{
+    struct wayland_output *output;
+
+    output = wayland_output_get_by_wine_name(wayland, name);
+    if (!output)
+        return FALSE;
+
+    if (!output->current_wine_mode)
+        return FALSE;
+
+    populate_devmode(output->current_wine_mode, mode);
+
+    return TRUE;
+}
+
 static BOOL wayland_get_devmode(struct wayland *wayland, LPCWSTR name, DWORD n, DEVMODEW *mode)
 {
     struct wayland_output *output;
@@ -357,7 +373,7 @@ BOOL CDECL WAYLAND_EnumDisplaySettingsEx(LPCWSTR name, DWORD n, LPDEVMODEW devmo
     if (n == ENUM_REGISTRY_SETTINGS)
     {
         if (!read_registry_settings(name, devmode) &&
-            !wayland_get_current_devmode(wayland, name, devmode))
+            !wayland_get_native_devmode(wayland, name, devmode))
         {
             ERR("Failed to get %s registry display settings and native mode.\n",
                 wine_dbgstr_w(name));
diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index b50230fb5e9..74d9fb80535 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -122,7 +122,10 @@ static void wayland_output_add_mode(struct wayland_output *output,
             /* Upgrade modes from virtual to native, never the reverse. */
             if (native) mode->native = TRUE;
             if (current)
+            {
                 output->current_mode = mode;
+                output->current_wine_mode = mode;
+            }
             return;
         }
         else if (cmp == 1) /* mode > new */
@@ -141,7 +144,10 @@ static void wayland_output_add_mode(struct wayland_output *output,
     mode->native = native;
 
     if (current)
+    {
         output->current_mode = mode;
+        output->current_wine_mode = mode;
+    }
 
     wl_list_insert(insert_after_link, &mode->link);
 }
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 21183bbdcb9..96383f04e42 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -155,6 +155,7 @@ struct wayland_output
     struct zxdg_output_v1 *zxdg_output_v1;
     struct wl_list mode_list;
     struct wayland_output_mode *current_mode;
+    struct wayland_output_mode *current_wine_mode;
     int logical_x, logical_y;  /* logical position */
     int logical_w, logical_h;  /* logical size */
     int x, y;  /* position in native pixel coordinate space */
-- 
2.34.1


From 10aff1fae8865f9ba82a263c6270409bac46e459 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 13 Sep 2021 17:17:32 +0300
Subject: [PATCH 063/147] winewayland.drv: Update coordinate transformations
 for Wine display modes.

Update coordinate transformation functions to handle the case where the
Wayland display mode and the Wine display mode differ.

This is achieved by introducing an additional transformation scale
factor which will be set in upcoming commits when the Wine display mode
changes.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_output.c  |  1 +
 dlls/winewayland.drv/wayland_surface.c | 82 ++++++++++++++++++++++++--
 dlls/winewayland.drv/waylanddrv.h      |  7 +++
 dlls/winewayland.drv/window.c          | 19 ++++--
 4 files changed, 100 insertions(+), 9 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index 74d9fb80535..91679975af0 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -445,6 +445,7 @@ BOOL wayland_output_create(struct wayland *wayland, uint32_t id, uint32_t versio
     wl_list_init(&output->link);
 
     output->scale = 1;
+    output->wine_scale = 1.0;
 
     /* Have a fallback in case xdg_output is not supported or name is not sent. */
     output->name = malloc(20);
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index fca1e4205f2..19554b98c55 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -757,10 +757,23 @@ void wayland_surface_coords_from_wine(struct wayland_surface *surface,
                                       int wine_x, int wine_y,
                                       double *wayland_x, double *wayland_y)
 {
+    struct wayland_output *output = wayland_surface_get_main_output(surface);
     int scale = wayland_surface_get_buffer_scale(surface);
 
-    *wayland_x = wine_x / (double)scale;
-    *wayland_y = wine_y / (double)scale;
+    if (output)
+    {
+        *wayland_x = wine_x * output->wine_scale / scale;
+        *wayland_y = wine_y * output->wine_scale / scale;
+    }
+    else
+    {
+        *wayland_x = wine_x / (double)scale;
+        *wayland_y = wine_y / (double)scale;
+    }
+
+    TRACE("hwnd=%p wine_scale=%f wine=%d,%d => wayland=%.2f,%.2f\n",
+          surface->hwnd, output ? output->wine_scale : -1.0, wine_x, wine_y,
+          *wayland_x, *wayland_y);
 }
 
 /**********************************************************************
@@ -788,10 +801,71 @@ void wayland_surface_coords_to_wine(struct wayland_surface *surface,
                                     double wayland_x, double wayland_y,
                                     int *wine_x, int *wine_y)
 {
+    struct wayland_output *output = wayland_surface_get_main_output(surface);
     int scale = wayland_surface_get_buffer_scale(surface);
 
-    *wine_x = round(wayland_x * scale);
-    *wine_y = round(wayland_y * scale);
+    if (output)
+    {
+        *wine_x = round(wayland_x * scale / output->wine_scale);
+        *wine_y = round(wayland_y * scale / output->wine_scale);
+    }
+    else
+    {
+        *wine_x = round(wayland_x * scale);
+        *wine_y = round(wayland_y * scale);
+    }
+
+    TRACE("hwnd=%p wine_scale=%f wayland=%.2f,%.2f => wine=%d,%d\n",
+          surface->hwnd, output ? output->wine_scale : -1.0,
+          wayland_x, wayland_y, *wine_x, *wine_y);
+}
+
+/**********************************************************************
+ *          wayland_surface_find_wine_fullscreen_fit
+ *
+ * Finds the size of a fullscreen Wine window that when scaled best fits into a
+ * wayland surface with the provided size, while maintaining the aspect
+ * ratio of the current Wine display mode.
+ */
+void wayland_surface_find_wine_fullscreen_fit(struct wayland_surface *surface,
+                                              int wayland_width, int wayland_height,
+                                              int *wine_width, int *wine_height)
+{
+    struct wayland_output *output = wayland_surface_get_main_output(surface);
+    double subarea_width, subarea_height;
+
+    TRACE("hwnd=%p wayland_width=%d wayland_height=%d\n",
+          surface->hwnd, wayland_width, wayland_height);
+
+    /* If the wine mode doesn't match the wayland mode, Find the largest subarea
+     * within wayland_width x wayland_height that has an aspect ratio equal to
+     * the wine display mode aspect ratio. */
+    if (output)
+    {
+        double aspect = ((double)wayland_width) / wayland_height;
+        double wine_aspect = ((double)output->current_wine_mode->width) /
+                             output->current_wine_mode->height;
+        if (aspect > wine_aspect)
+        {
+            subarea_width = wayland_height * wine_aspect;
+            subarea_height = wayland_height;
+        }
+        else
+        {
+            subarea_width = wayland_width;
+            subarea_height = wayland_width / wine_aspect;
+        }
+    }
+    else
+    {
+        subarea_width = wayland_width;
+        subarea_height = wayland_height;
+    }
+
+    /* Transform the calculated subarea to wine coordinates. */
+    wayland_surface_coords_to_wine(surface,
+                                   subarea_width, subarea_height,
+                                   wine_width, wine_height);
 }
 
 /**********************************************************************
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 96383f04e42..9eeb015e3bd 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -160,6 +160,10 @@ struct wayland_output
     int logical_w, logical_h;  /* logical size */
     int x, y;  /* position in native pixel coordinate space */
     int scale; /* wayland output scale factor for hidpi */
+    /* Scale factor by which we need to multiply values in the wine coordinate
+     * space to get values in the wayland coordinate space for this output. Used
+     * when emulating a display mode change. */
+    double wine_scale;
     char *name;
     WCHAR wine_name[128];
     uint32_t global_id;
@@ -334,6 +338,9 @@ void wayland_surface_coords_rounded_from_wine(struct wayland_surface *surface,
 void wayland_surface_coords_to_wine(struct wayland_surface *surface,
                                     double wayland_x, double wayland_y,
                                     int *wine_x, int *wine_y);
+void wayland_surface_find_wine_fullscreen_fit(struct wayland_surface *surface,
+                                              int wayland_width, int wayland_height,
+                                              int *wine_width, int *wine_height);
 struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface);
 void wayland_surface_unref(struct wayland_surface *surface);
 void wayland_surface_leave_output(struct wayland_surface *surface,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 8fe743c49ef..ae8905c4d6d 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -1290,8 +1290,17 @@ static LRESULT handle_wm_wayland_configure(HWND hwnd)
         wsurface->pending.height = height;
     }
 
-    wayland_surface_coords_to_wine(wsurface, width, height,
-                                   &wine_width, &wine_height);
+    if ((flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN) &&
+        !(flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
+    {
+        wayland_surface_find_wine_fullscreen_fit(wsurface, width, height,
+                                                 &wine_width, &wine_height);
+    }
+    else
+    {
+        wayland_surface_coords_to_wine(wsurface, width, height,
+                                       &wine_width, &wine_height);
+    }
 
     TRACE("hwnd=%p effective_size=%dx%d wine_size=%dx%d\n",
           data->hwnd, width, height, wine_width, wine_height);
@@ -1423,9 +1432,9 @@ static void handle_wm_wayland_surface_output_change(HWND hwnd)
     else if (wsurface->current.serial &&
              (wsurface->current.configure_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN))
     {
-        wayland_surface_coords_to_wine(wsurface, wsurface->current.width,
-                                       wsurface->current.height,
-                                       &w, &h);
+        wayland_surface_find_wine_fullscreen_fit(wsurface, wsurface->current.width,
+                                                 wsurface->current.height,
+                                                 &w, &h);
         TRACE("resizing window to fullscreen %dx%d\n", w, h);
     }
     else
-- 
2.34.1


From 0d7a8dae54929271bf0f4e326f9ade940aa8992e Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 13 Sep 2021 17:18:46 +0300
Subject: [PATCH 064/147] winewayland.drv: Scale surfaces to apply Wine display
 modes.

Use the viewporter protocol to scale surfaces on the Wayland compositor
side, in order to create the illusion that the monitor has performed a
display mode change.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |  1 +
 dlls/winewayland.drv/wayland.c         |  7 ++++
 dlls/winewayland.drv/wayland_surface.c | 45 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  5 +++
 dlls/winewayland.drv/window.c          |  2 ++
 5 files changed, 60 insertions(+)

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 0714f4e5c48..5943ba994c3 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -26,6 +26,7 @@ C_SRCS = \
 	xkb_util.c \
 
 WAYLAND_PROTOCOL_SRCS = \
+	$(WAYLAND_PROTOCOLS_DATADIR)/stable/viewporter/viewporter.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/stable/xdg-shell/xdg-shell.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/xdg-output/xdg-output-unstable-v1.xml \
 
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 414c2c4885b..70690ff4b20 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -167,6 +167,10 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
                                             version < 5 ? version : 5);
         wl_seat_add_listener(wayland->wl_seat, &seat_listener, wayland);
     }
+    else if (strcmp(interface, "wp_viewporter") == 0)
+    {
+        wayland->wp_viewporter = wl_registry_bind(registry, id, &wp_viewporter_interface, 1);
+    }
 }
 
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
@@ -323,6 +327,9 @@ void wayland_deinit(struct wayland *wayland)
     if (wayland->wl_seat)
         wl_seat_destroy(wayland->wl_seat);
 
+    if (wayland->wp_viewporter)
+        wp_viewporter_destroy(wayland->wp_viewporter);
+
     if (wayland->wl_shm)
         wl_shm_destroy(wayland->wl_shm);
 
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 19554b98c55..c138bd7100c 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -222,6 +222,13 @@ struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland)
     if (!surface->wl_surface)
         goto err;
 
+    if (surface->wayland->wp_viewporter)
+    {
+        surface->wp_viewport =
+            wp_viewporter_get_viewport(surface->wayland->wp_viewporter,
+                                       surface->wl_surface);
+    }
+
     wl_list_init(&surface->output_ref_list);
     wl_list_init(&surface->link);
     wl_list_init(&surface->child_list);
@@ -471,6 +478,38 @@ void wayland_surface_reconfigure_geometry(struct wayland_surface *surface,
     }
 }
 
+/**********************************************************************
+ *          wayland_surface_reconfigure_size
+ *
+ * Configures the size of a wayland surface.
+ *
+ * The sizes should be given in wine's coordinate space.
+ *
+ * This function sets up but doesn't actually apply any new configuration.
+ * The wayland_surface_reconfigure_apply() needs to be called for changes
+ * to take effect.
+ */
+void wayland_surface_reconfigure_size(struct wayland_surface *surface,
+                                      int wine_width, int wine_height)
+{
+    int width, height;
+
+    wayland_surface_coords_rounded_from_wine(surface, wine_width, wine_height,
+                                             &width, &height);
+
+    TRACE("surface=%p hwnd=%p wine=%dx%d wayland=%dx%d\n",
+          surface, surface->hwnd, wine_width, wine_height, width, height);
+
+    /* Use a viewport, if supported, to handle display mode changes. */
+    if (surface->wp_viewport)
+    {
+        if (width != 0 && height != 0)
+            wp_viewport_set_destination(surface->wp_viewport, width, height);
+        else
+            wp_viewport_set_destination(surface->wp_viewport, -1, -1);
+    }
+}
+
 /**********************************************************************
  *          wayland_surface_reconfigure_apply
  *
@@ -650,6 +689,12 @@ void wayland_surface_destroy(struct wayland_surface *surface)
         heap_free(ref);
     }
 
+    if (surface->wp_viewport)
+    {
+        wp_viewport_destroy(surface->wp_viewport);
+        surface->wp_viewport = NULL;
+    }
+
     if (surface->xdg_toplevel)
     {
         xdg_toplevel_destroy(surface->xdg_toplevel);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 9eeb015e3bd..5e0684dceba 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -29,6 +29,7 @@
 #include <wayland-client.h>
 #include <xkbcommon/xkbcommon.h>
 #include <xkbcommon/xkbcommon-compose.h>
+#include "viewporter-client-protocol.h"
 #include "xdg-output-unstable-v1-client-protocol.h"
 #include "xdg-shell-client-protocol.h"
 
@@ -124,6 +125,7 @@ struct wayland
     struct xdg_wm_base *xdg_wm_base;
     struct wl_shm *wl_shm;
     struct wl_seat *wl_seat;
+    struct wp_viewporter *wp_viewporter;
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t next_fallback_output_id;
     struct wl_list output_list;
@@ -192,6 +194,7 @@ struct wayland_surface
     struct wl_subsurface *wl_subsurface;
     struct xdg_surface *xdg_surface;
     struct xdg_toplevel *xdg_toplevel;
+    struct wp_viewport *wp_viewport;
     struct wayland_surface *parent;
     HWND hwnd;
     CRITICAL_SECTION crit;
@@ -323,6 +326,8 @@ void wayland_surface_reconfigure_position(struct wayland_surface *surface,
                                           int x, int y);
 void wayland_surface_reconfigure_geometry(struct wayland_surface *surface,
                                           int x, int y, int width, int height);
+void wayland_surface_reconfigure_size(struct wayland_surface *surface,
+                                      int width, int height);
 void wayland_surface_reconfigure_apply(struct wayland_surface *surface);
 void wayland_surface_unmap(struct wayland_surface *surface);
 void wayland_surface_ack_pending_configure(struct wayland_surface *surface);
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index ae8905c4d6d..cf43501388e 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -791,6 +791,8 @@ static void wayland_win_data_update_wayland_surface_state(struct wayland_win_dat
         return;
     }
 
+    wayland_surface_reconfigure_size(wsurface, width, height);
+
     if (wsurface->wl_subsurface)
     {
         /* In addition to children windows, we manage some top level, popup window
-- 
2.34.1


From da8897a1c0b9992db90ec9b8c0715504de71fd38 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 29 Sep 2021 13:45:18 +0300
Subject: [PATCH 065/147] winewayland.drv: Implement Wine monitor change
 notification.

Introduce a mechanism to synchronously notify all Wayland capable
threads about changes in the current Wine monitor setup.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c        | 32 +++++++++++++++++++++
 dlls/winewayland.drv/wayland_output.c | 41 +++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h     |  6 ++++
 dlls/winewayland.drv/window.c         | 24 ++++++++++++++++
 4 files changed, 103 insertions(+)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 70690ff4b20..c90397da9dc 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -594,3 +594,35 @@ DWORD CDECL WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handl
 
     return ret;
 }
+
+/**********************************************************************
+ *          wayland_notify_wine_monitor_change
+ *
+ * Notify all wayland instances about a change in the state of wine monitors.
+ * The notification is synchronous, this function returns after all wayland
+ * instances have handled the event, except if it a thread is slow to process
+ * the message, and thus likely to be blocked by this synchronous operation.
+ */
+void wayland_notify_wine_monitor_change(void)
+{
+    struct wayland *w;
+
+    EnterCriticalSection(&thread_wayland_section);
+
+    /* Each thread maintains its own output mode information, so we need to
+     * notify all threads about the wine mode change. We can't guarantee that
+     * all threads will have windows to which we could potentially send the
+     * notification message to, so we use the internal send function to target
+     * the threads directly. We can't use PostThreadMessage since we require
+     * synchronous message handling. */
+    wl_list_for_each(w, &thread_wayland_list, thread_link)
+    {
+        /* Use a timeout of 50ms to avoid blocking indefinitely if the
+         * target thread is not processing (and to avoid deadlocks). */
+        __wine_send_internal_message_timeout(w->process_id, w->thread_id,
+                                             WM_WAYLAND_MONITOR_CHANGE,
+                                             0, 0, 0, 50, NULL);
+    }
+
+    LeaveCriticalSection(&thread_wayland_section);
+}
diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index 91679975af0..9e026a0d555 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -524,6 +524,9 @@ void wayland_update_outputs_from_process(struct wayland *wayland)
             if (!strcmp(output->name, process_output->name))
             {
                 lstrcpyW(output->wine_name, process_output->wine_name);
+                wayland_output_set_wine_mode(output,
+                                             process_output->current_wine_mode->width,
+                                             process_output->current_wine_mode->height);
                 break;
             }
         }
@@ -551,3 +554,41 @@ struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
 
     return NULL;
 }
+
+/**********************************************************************
+ *          wayland_output_set_wine_mode
+ *
+ * Set the current wine mode for the specified output.
+ */
+void wayland_output_set_wine_mode(struct wayland_output *output, int width, int height)
+{
+    struct wayland_output_mode *output_mode;
+
+    TRACE("output->name=%s width=%d height=%d\n", output->name, width, height);
+
+    /* We always use 32bpp modes since that's the only one we really
+     * support. */
+    wl_list_for_each(output_mode, &output->mode_list, link)
+    {
+        if (output_mode->width == width && output_mode->height == height &&
+            output_mode->bpp == 32)
+        {
+            output->current_wine_mode = output_mode;
+            break;
+        }
+    }
+
+    if (!output->current_wine_mode || !output->current_mode)
+    {
+        output->wine_scale = 1.0;
+    }
+    else
+    {
+        double scale_x = ((double)output->current_mode->width) /
+                         output->current_wine_mode->width;
+        double scale_y = ((double)output->current_mode->height) /
+                         output->current_wine_mode->height;
+        /* We want to keep the aspect ratio of the target mode. */
+        output->wine_scale = fmin(scale_x, scale_y);
+    }
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 5e0684dceba..8eb9db81384 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -54,6 +54,7 @@ enum wayland_window_message
     WM_WAYLAND_CONFIGURE = 0x80001003,
     WM_WAYLAND_STATE_UPDATE = 0x80001004,
     WM_WAYLAND_SURFACE_OUTPUT_CHANGE = 0x80001005,
+    WM_WAYLAND_MONITOR_CHANGE = 0x80001006,
 };
 
 enum wayland_surface_role
@@ -286,6 +287,11 @@ void wayland_output_use_xdg_extension(struct wayland_output *output);
 void wayland_update_outputs_from_process(struct wayland *wayland);
 struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
                                                        LPCWSTR wine_name);
+struct wayland_output *wayland_output_get_by_id(struct wayland *wayland,
+                                                uint32_t id);
+void wayland_output_set_wine_mode(struct wayland_output *output,
+                                  int width, int height);
+void wayland_notify_wine_monitor_change(void);
 
 /**********************************************************************
  *          Wayland event dispatch
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index cf43501388e..ba14fc747f8 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -1451,6 +1451,27 @@ out:
     wayland_surface_for_hwnd_unlock(wsurface);
 }
 
+static void handle_wm_wayland_monitor_change(struct wayland *wayland)
+{
+    struct wayland_surface *surface, *tmp;
+
+    wayland_update_outputs_from_process(wayland);
+
+    /* Update the state of all surfaces tracked by the wayland thread instance,
+     * in case any surface was affected by the monitor changes (e.g., gained or
+     * lost the fullscreen state). We use the safe iteration variant since a
+     * state update may cause the surface to be recreated. */
+    wl_list_for_each_safe(surface, tmp, &wayland->toplevel_list, link)
+    {
+        struct wayland_win_data *data = wayland_win_data_get(surface->hwnd);
+        if (data)
+        {
+            update_wayland_state(data);
+            wayland_win_data_release(data);
+        }
+    }
+}
+
 /**********************************************************************
  *           WAYLAND_WindowMessage
  */
@@ -1521,6 +1542,9 @@ LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
     case WM_WAYLAND_SURFACE_OUTPUT_CHANGE:
         handle_wm_wayland_surface_output_change(hwnd);
         break;
+    case WM_WAYLAND_MONITOR_CHANGE:
+        handle_wm_wayland_monitor_change(thread_wayland());
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp);
     }
-- 
2.34.1


From 7c756905388b002b75121b3c51f935dd04525e8b Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 29 Sep 2021 13:47:29 +0300
Subject: [PATCH 066/147] winewayland.drv: Implement ChangeDisplaySettingsEx.

Change the current Wine display mode the and notify all Wayland threads
about the change.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/display.c         | 194 +++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |   2 +
 dlls/winewayland.drv/waylanddrv_main.c |   1 +
 3 files changed, 197 insertions(+)

diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index a4d609330e0..9a0a6871899 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -289,6 +289,51 @@ done:
     return ret;
 }
 
+static BOOL write_registry_settings(const WCHAR *device_name, const DEVMODEW *dm)
+{
+    WCHAR display_device_reg_key[MAX_PATH];
+    HANDLE mutex;
+    HKEY hkey;
+    BOOL ret = TRUE;
+
+    mutex = acquire_display_devices_init_mutex();
+    if (!get_display_device_reg_key(device_name, display_device_reg_key,
+                                    ARRAY_SIZE(display_device_reg_key)))
+    {
+        ret = FALSE;
+        goto done;
+    }
+
+    if (RegCreateKeyExW(HKEY_CURRENT_CONFIG, display_device_reg_key, 0, NULL,
+                        REG_OPTION_VOLATILE, KEY_WRITE, NULL, &hkey, NULL))
+    {
+        ret = FALSE;
+        goto done;
+    }
+
+#define set_value(name, data) \
+    if (RegSetValueExA(hkey, name, 0, REG_DWORD, (const BYTE*)(data), sizeof(DWORD))) \
+        ret = FALSE
+
+    set_value("DefaultSettings.BitsPerPel", &dm->dmBitsPerPel);
+    set_value("DefaultSettings.XResolution", &dm->dmPelsWidth);
+    set_value("DefaultSettings.YResolution", &dm->dmPelsHeight);
+    set_value("DefaultSettings.VRefresh", &dm->dmDisplayFrequency);
+    set_value("DefaultSettings.Flags", &dm->u2.dmDisplayFlags);
+    set_value("DefaultSettings.XPanning", &dm->u1.s2.dmPosition.x);
+    set_value("DefaultSettings.YPanning", &dm->u1.s2.dmPosition.y);
+    set_value("DefaultSettings.Orientation", &dm->u1.s2.dmDisplayOrientation);
+    set_value("DefaultSettings.FixedOutput", &dm->u1.s2.dmDisplayFixedOutput);
+
+#undef set_value
+
+    RegCloseKey(hkey);
+
+done:
+    release_display_devices_init_mutex(mutex);
+    return ret;
+}
+
 static void populate_devmode(struct wayland_output_mode *output_mode, DEVMODEW *mode)
 {
     mode->dmFields = DM_DISPLAYORIENTATION | DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT |
@@ -414,3 +459,152 @@ err:
     wayland_process_release();
     return FALSE;
 }
+
+static struct wayland_output_mode *get_matching_output_mode_32bpp(struct wayland_output *output,
+                                                                  LPDEVMODEW devmode)
+{
+    struct wayland_output_mode *output_mode;
+    DEVMODEW full_mode;
+
+    if (output->current_wine_mode)
+        populate_devmode(output->current_wine_mode, &full_mode);
+    else
+        populate_devmode(output->current_mode, &full_mode);
+
+    if (devmode->dmFields & DM_PELSWIDTH)
+        full_mode.dmPelsWidth = devmode->dmPelsWidth;
+    if (devmode->dmFields & DM_PELSHEIGHT)
+        full_mode.dmPelsHeight = devmode->dmPelsHeight;
+    if (devmode->dmFields & DM_BITSPERPEL)
+        full_mode.dmBitsPerPel = devmode->dmBitsPerPel;
+
+    wl_list_for_each(output_mode, &output->mode_list, link)
+    {
+        if (full_mode.dmPelsWidth == output_mode->width &&
+            full_mode.dmPelsHeight == output_mode->height &&
+            output_mode->bpp == 32)
+        {
+            return output_mode;
+        }
+    }
+
+    return NULL;
+}
+
+static BOOL wayland_restore_all_outputs(struct wayland *wayland)
+{
+    struct wayland_output *output;
+
+    wl_list_for_each(output, &wayland->output_list, link)
+    {
+        struct wayland_output_mode *output_mode = NULL;
+        DEVMODEW devmode;
+
+        if (read_registry_settings(output->wine_name, &devmode))
+            output_mode = get_matching_output_mode_32bpp(output, &devmode);
+        else
+            output_mode = output->current_mode;
+
+        if (!output_mode)
+            return FALSE;
+
+        if (output_mode != output->current_wine_mode)
+        {
+            wayland_output_set_wine_mode(output, output_mode->width,
+                                         output_mode->height);
+        }
+    }
+
+    return TRUE;
+}
+
+/***********************************************************************
+ *		ChangeDisplaySettingsEx  (WAYLAND.@)
+ *
+ */
+LONG CDECL WAYLAND_ChangeDisplaySettingsEx(LPCWSTR devname, LPDEVMODEW devmode,
+                                           HWND hwnd, DWORD flags, LPVOID lpvoid)
+{
+    LONG ret;
+    struct wayland *wayland = wayland_process_acquire();
+    struct wayland_output *output;
+    struct wayland_output_mode *output_mode;
+
+    TRACE("(%s,%p,%p,0x%08x,%p) %dx%d@%d wayland=%p\n",
+          debugstr_w(devname), devmode, hwnd, flags, lpvoid,
+          devmode ? devmode->dmPelsWidth : -1,
+          devmode ? devmode->dmPelsHeight : -1,
+          devmode ? devmode->dmDisplayFrequency : -1, wayland);
+
+    if (devname && devmode)
+    {
+        DEVMODEW full_mode;
+
+        output = wayland_output_get_by_wine_name(wayland, devname);
+        if (!output)
+        {
+            ret = DISP_CHANGE_BADPARAM;
+            goto out;
+        }
+
+        output_mode = get_matching_output_mode_32bpp(output, devmode);
+        if (!output_mode)
+        {
+            ret = DISP_CHANGE_BADMODE;
+            goto out;
+        }
+
+        populate_devmode(output_mode, &full_mode);
+
+        if (flags & CDS_UPDATEREGISTRY)
+        {
+            if (!write_registry_settings(devname, &full_mode))
+            {
+                ERR("Failed to write %s display settings to registry.\n", wine_dbgstr_w(devname));
+                ret = DISP_CHANGE_NOTUPDATED;
+                goto out;
+            }
+        }
+    }
+
+    if (flags & (CDS_TEST | CDS_NORESET))
+    {
+        ret = DISP_CHANGE_SUCCESSFUL;
+        goto out;
+    }
+
+    if (devname && devmode)
+    {
+        wayland_output_set_wine_mode(output, output_mode->width, output_mode->height);
+    }
+    else
+    {
+        if (!wayland_restore_all_outputs(wayland))
+        {
+            ret = DISP_CHANGE_BADMODE;
+            goto out;
+        }
+    }
+
+    wayland_refresh_display_devices();
+
+    wayland_notify_wine_monitor_change();
+
+    if (devname && devmode)
+    {
+        TRACE("set current wine mode %dx%d wine_scale %f\n",
+              output_mode->width, output_mode->height, output->wine_scale);
+    }
+    else
+    {
+        TRACE("restored all outputs to registry (or native) settings\n");
+    }
+
+    ret = DISP_CHANGE_SUCCESSFUL;
+
+out:
+    wayland_process_release();
+    if (ret == DISP_CHANGE_SUCCESSFUL)
+        wayland_broadcast_wm_display_change();
+    return ret;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 8eb9db81384..cff1e2cad21 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -423,6 +423,8 @@ int _xkb_keysyms_to_utf8(const xkb_keysym_t *syms, int nsyms, char *utf8, int ut
  *          USER driver functions
  */
 
+extern LONG CDECL WAYLAND_ChangeDisplaySettingsEx(LPCWSTR devname, LPDEVMODEW devmode,
+                                                  HWND hwnd, DWORD flags, LPVOID lpvoid) DECLSPEC_HIDDEN;
 extern BOOL CDECL WAYLAND_CreateWindow(HWND hwnd) DECLSPEC_HIDDEN;
 extern void CDECL WAYLAND_DestroyWindow(HWND hwnd) DECLSPEC_HIDDEN;
 extern BOOL CDECL WAYLAND_EnumDisplaySettingsEx(LPCWSTR name, DWORD n, LPDEVMODEW devmode, DWORD flags) DECLSPEC_HIDDEN;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 34d6a7e3f34..1bba4b58f23 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -121,6 +121,7 @@ static void CDECL WAYLAND_ThreadDetach(void)
 
 static const struct user_driver_funcs waylanddrv_funcs =
 {
+    .pChangeDisplaySettingsEx = WAYLAND_ChangeDisplaySettingsEx,
     .pCreateWindow = WAYLAND_CreateWindow,
     .pDestroyWindow = WAYLAND_DestroyWindow,
     .pEnumDisplaySettingsEx = WAYLAND_EnumDisplaySettingsEx,
-- 
2.34.1


From 1478c7d139517160f1998557bd385006807c1875 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 13 Sep 2021 16:59:19 +0300
Subject: [PATCH 067/147] winewayland.drv: Add skeleton GDI driver.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |  1 +
 dlls/winewayland.drv/gdi.c             | 84 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      | 11 ++++
 dlls/winewayland.drv/waylanddrv_main.c |  7 ++-
 4 files changed, 102 insertions(+), 1 deletion(-)
 create mode 100644 dlls/winewayland.drv/gdi.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 5943ba994c3..e97409b90f4 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -11,6 +11,7 @@ EXTRADLLFLAGS = -mcygwin
 
 C_SRCS = \
 	display.c \
+	gdi.c \
 	wayland.c \
 	wayland_output.c \
 	waylanddrv_main.c \
diff --git a/dlls/winewayland.drv/gdi.c b/dlls/winewayland.drv/gdi.c
new file mode 100644
index 00000000000..321884b437d
--- /dev/null
+++ b/dlls/winewayland.drv/gdi.c
@@ -0,0 +1,84 @@
+/*
+ * Wayland gdi functions
+ *
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/heap.h"
+
+typedef struct
+{
+    struct gdi_physdev dev;
+} WAYLAND_PDEVICE;
+
+static inline WAYLAND_PDEVICE *get_wayland_dev(PHYSDEV dev)
+{
+    return (WAYLAND_PDEVICE *)dev;
+}
+
+static WAYLAND_PDEVICE *create_wayland_physdev(void)
+{
+    WAYLAND_PDEVICE *physDev;
+
+    physDev = heap_alloc_zero(sizeof(*physDev));
+
+    return physDev;
+}
+
+/**********************************************************************
+ *           WAYLAND_CreateDC
+ */
+BOOL CDECL WAYLAND_CreateDC(PHYSDEV *pdev, LPCWSTR device,
+                            LPCWSTR output, const DEVMODEW* initData)
+{
+    WAYLAND_PDEVICE *physDev = create_wayland_physdev();
+
+    if (!physDev) return FALSE;
+
+    push_dc_driver(pdev, &physDev->dev, &waylanddrv_funcs.dc_funcs);
+
+    return TRUE;
+}
+
+/**********************************************************************
+ *           WAYLAND_CreateCompatibleDC
+ */
+BOOL CDECL WAYLAND_CreateCompatibleDC(PHYSDEV orig, PHYSDEV *pdev)
+{
+    WAYLAND_PDEVICE *physDev = create_wayland_physdev();
+
+    if (!physDev) return FALSE;
+
+    push_dc_driver(pdev, &physDev->dev, &waylanddrv_funcs.dc_funcs);
+
+    return TRUE;
+}
+
+/**********************************************************************
+ *           WAYLAND_DeleteDC
+ */
+BOOL CDECL WAYLAND_DeleteDC(PHYSDEV dev)
+{
+    WAYLAND_PDEVICE *physDev = get_wayland_dev(dev);
+
+    HeapFree(GetProcessHeap(), 0, physDev);
+    return TRUE;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index cff1e2cad21..ed2d3296ef4 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -41,6 +41,7 @@
 #include "wine/gdi_driver.h"
 
 extern struct wl_display *process_wl_display;
+extern const struct user_driver_funcs waylanddrv_funcs;
 
 /**********************************************************************
   *          Internal messages and data
@@ -454,4 +455,14 @@ extern BOOL CDECL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT s
                                             const RECT *window_rect, const RECT *client_rect,
                                             RECT *visible_rect, struct window_surface **surface) DECLSPEC_HIDDEN;
 
+/**********************************************************************
+ *          GDI driver functions
+ */
+
+extern BOOL CDECL WAYLAND_CreateDC(PHYSDEV *pdev, LPCWSTR device,
+                                   LPCWSTR output, const DEVMODEW* initData) DECLSPEC_HIDDEN;
+extern BOOL CDECL WAYLAND_CreateCompatibleDC(PHYSDEV orig, PHYSDEV *pdev) DECLSPEC_HIDDEN;
+extern BOOL CDECL WAYLAND_CreateCompatibleDC(PHYSDEV orig, PHYSDEV *pdev) DECLSPEC_HIDDEN;
+extern BOOL CDECL WAYLAND_DeleteDC(PHYSDEV dev) DECLSPEC_HIDDEN;
+
 #endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 1bba4b58f23..28902e02458 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -119,8 +119,13 @@ static void CDECL WAYLAND_ThreadDetach(void)
     }
 }
 
-static const struct user_driver_funcs waylanddrv_funcs =
+const struct user_driver_funcs waylanddrv_funcs =
 {
+    .dc_funcs.pCreateDC = WAYLAND_CreateDC,
+    .dc_funcs.pCreateCompatibleDC = WAYLAND_CreateCompatibleDC,
+    .dc_funcs.pDeleteDC = WAYLAND_DeleteDC,
+    .dc_funcs.priority = GDI_PRIORITY_GRAPHICS_DRV,
+
     .pChangeDisplaySettingsEx = WAYLAND_ChangeDisplaySettingsEx,
     .pCreateWindow = WAYLAND_CreateWindow,
     .pDestroyWindow = WAYLAND_DestroyWindow,
-- 
2.34.1


From 82f4b396fade0a4cff80984afbc7b4808d5de572 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 30 Sep 2021 13:41:29 +0300
Subject: [PATCH 068/147] winewayland.drv: Add helper to get client rect in
 window coordinates.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h |  6 ++++++
 dlls/winewayland.drv/window.c     | 23 +++++++++++++++++++++++
 2 files changed, 29 insertions(+)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index ed2d3296ef4..373d68894b7 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -420,6 +420,12 @@ void wayland_set_cursor_if_current_invalid(HCURSOR hcursor);
 xkb_layout_index_t _xkb_state_get_active_layout(struct xkb_state *xkb_state);
 int _xkb_keysyms_to_utf8(const xkb_keysym_t *syms, int nsyms, char *utf8, int utf8_size);
 
+/**********************************************************************
+ *          Misc. helpers
+ */
+
+void wayland_get_client_rect_in_win_coords(HWND hwnd, RECT *client_rect);
+
 /**********************************************************************
  *          USER driver functions
  */
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index ba14fc747f8..15f7776e5da 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -1551,3 +1551,26 @@ LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
 
     return 0;
 }
+
+/*****************************************************************************
+ *           wayland_get_client_rect_in_win_coords
+ */
+void wayland_get_client_rect_in_win_coords(HWND hwnd, RECT *client_rect)
+{
+    RECT window_rect;
+    POINT origin = {0, 0};
+
+    if (!ClientToScreen(hwnd, &origin)) goto err;
+    if (!GetWindowRect(hwnd, &window_rect)) goto err;
+    if (!GetClientRect(hwnd, client_rect)) goto err;
+
+    OffsetRect(client_rect,
+               origin.x - window_rect.left,
+               origin.y - window_rect.top);
+
+    return;
+
+err:
+    ERR("Failed to get client rect for hwnd %p", hwnd);
+    SetRectEmpty(client_rect);
+}
-- 
2.34.1


From 94cc25d90f1859ef873b35328b98789c58a78fb6 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 13 Sep 2021 17:48:15 +0300
Subject: [PATCH 069/147] winewayland.drv: Prepare for handling windows with
 OpenGL/VK content.

Use a Wayland subsurface as the target surface for OpenGL/VK rendering
and support reconfiguring it appropriately. The toplevel Wayland surface
is used for all non-client rendering.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 configure                              |  82 +++++++++
 configure.ac                           |   4 +
 dlls/winewayland.drv/Makefile.in       |   4 +-
 dlls/winewayland.drv/wayland_surface.c | 233 +++++++++++++++++++++++--
 dlls/winewayland.drv/waylanddrv.h      |   9 +
 dlls/winewayland.drv/window.c          |  11 +-
 include/config.h.in                    |   3 +
 7 files changed, 328 insertions(+), 18 deletions(-)

diff --git a/configure.ac b/configure.ac
index 4dc9faed3d3..922b29ac024 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1338,6 +1338,10 @@ then
     WINE_PACKAGE_FLAGS(XKBCOMMON,[xkbcommon],,,,
         [AC_CHECK_HEADERS([xkbcommon/xkbcommon.h])
          AC_CHECK_LIB(xkbcommon,xkb_context_new,[:],[XKBCOMMON_LIBS=""],[$XKBCOMMON_LIBS])])
+    WINE_PACKAGE_FLAGS(WAYLAND_EGL,[wayland-egl],,,,
+        [AC_CHECK_HEADERS([wayland-egl.h])
+         AC_CHECK_LIB(wayland-egl,wl_egl_window_create,[:],
+                      [WAYLAND_EGL_LIBS=""],[$WAYLAND_EGL_LIBS])])
 fi
 WINE_NOTICE_WITH(wayland, [test -z "$WAYLAND_CLIENT_LIBS" ||
                            test -z "$WAYLAND_PROTOCOLS_DATADIR" ||
diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index e97409b90f4..dfcccaa0faa 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,7 +1,7 @@
 MODULE    = winewayland.drv
 IMPORTS   = advapi32 gdi32 user32 win32u
-EXTRAINCL = $(WAYLAND_CLIENT_CFLAGS) $(XKBCOMMON_CFLAGS)
-EXTRALIBS = $(WAYLAND_CLIENT_LIBS) $(XKBCOMMON_LIBS)
+EXTRAINCL = $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_EGL_CFLAGS) $(XKBCOMMON_CFLAGS)
+EXTRALIBS = $(WAYLAND_CLIENT_LIBS) $(WAYLAND_EGL_LIBS) $(XKBCOMMON_LIBS)
 CFLAGS = -std=c11 -Wno-declaration-after-statement
 EXTRACFLAGS = -std=c11 -Wno-declaration-after-statement
 CPPFLAGS = -std=c11 -Wno-declaration-after-statement
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index c138bd7100c..084ef6834dc 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -435,6 +435,9 @@ void wayland_surface_reconfigure_position(struct wayland_surface *surface,
  *
  * The coordinates and sizes should be given in wine's coordinate space.
  *
+ * Note that this doesn't configure any associated GL/VK subsurface,
+ * wayland_surface_reconfigure_glvk() needs to be called separately.
+ *
  * This function sets up but doesn't actually apply any new configuration.
  * The wayland_surface_reconfigure_apply() needs to be called for changes
  * to take effect.
@@ -510,21 +513,6 @@ void wayland_surface_reconfigure_size(struct wayland_surface *surface,
     }
 }
 
-/**********************************************************************
- *          wayland_surface_reconfigure_apply
- *
- * Applies the configuration set by previous calls to the
- * wayland_surface_reconfigure{_glvk}() functions.
- */
-void wayland_surface_reconfigure_apply(struct wayland_surface *surface)
-{
-    wl_surface_commit(surface->wl_surface);
-
-    /* Commit the parent so any subsurface repositioning takes effect. */
-    if (surface->parent)
-        wl_surface_commit(surface->parent->wl_surface);
-}
-
 /**********************************************************************
  *          wayland_surface_configure_is_compatible
  *
@@ -689,6 +677,12 @@ void wayland_surface_destroy(struct wayland_surface *surface)
         heap_free(ref);
     }
 
+    if (surface->wl_egl_window)
+    {
+        wl_egl_window_destroy(surface->wl_egl_window);
+        surface->wl_egl_window = NULL;
+    }
+
     if (surface->wp_viewport)
     {
         wp_viewport_destroy(surface->wp_viewport);
@@ -741,6 +735,211 @@ void wayland_surface_destroy(struct wayland_surface *surface)
     heap_free(surface);
 }
 
+static struct wayland_surface *wayland_surface_create_glvk_common(struct wayland_surface *surface)
+{
+    struct wayland_surface *glvk;
+
+    TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
+
+    glvk = wayland_surface_create_plain(surface->wayland);
+    if (!glvk)
+        goto err;
+
+    glvk->parent = wayland_surface_ref(surface);
+
+    /* Remove from toplevel_list (added as a plain surface) and add to parent
+     * child list. */
+    wl_list_remove(&glvk->link);
+    EnterCriticalSection(&glvk->parent->crit);
+    wl_list_insert(&glvk->parent->child_list, &glvk->link);
+    LeaveCriticalSection(&glvk->parent->crit);
+
+    glvk->wl_subsurface =
+        wl_subcompositor_get_subsurface(glvk->wayland->wl_subcompositor,
+                                        glvk->wl_surface,
+                                        surface->wl_surface);
+    if (!glvk->wl_subsurface)
+        goto err;
+    wl_subsurface_set_desync(glvk->wl_subsurface);
+    /* Place the glvk subsurface just above the parent surface, so that it
+     * doesn't end up obscuring any other subsurfaces. */
+    wl_subsurface_place_above(glvk->wl_subsurface, surface->wl_surface);
+
+    glvk->hwnd = surface->hwnd;
+    glvk->main_output = surface->main_output;
+    glvk->wine_output = surface->wine_output;
+    wl_surface_set_buffer_scale(glvk->wl_surface, wayland_surface_get_buffer_scale(surface));
+    glvk->role = WAYLAND_SURFACE_ROLE_SUBSURFACE;
+
+    return glvk;
+
+err:
+    if (glvk)
+        wayland_surface_destroy(glvk);
+
+    return NULL;
+}
+
+static struct wayland_surface *wayland_surface_ref_glvk(struct wayland_surface *surface)
+{
+    struct wayland_surface *glvk = NULL;
+    EnterCriticalSection(&surface->crit);
+    if (surface->glvk)
+        glvk = wayland_surface_ref(surface->glvk);
+    LeaveCriticalSection(&surface->crit);
+    return glvk;
+}
+
+/**********************************************************************
+ *          wayland_surface_create_gl
+ *
+ * Creates a GL subsurface for this wayland surface.
+ */
+BOOL wayland_surface_create_or_ref_gl(struct wayland_surface *surface)
+{
+    struct wayland_surface *glvk;
+    RECT client_rect;
+
+    TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
+
+    if (wayland_surface_ref_glvk(surface))
+        return TRUE;
+
+    glvk = wayland_surface_create_glvk_common(surface);
+    if (!glvk)
+        goto err;
+
+    glvk->wl_egl_window = wl_egl_window_create(glvk->wl_surface, 1, 1);
+    if (!glvk->wl_egl_window)
+        goto err;
+
+    EnterCriticalSection(&surface->crit);
+    surface->glvk = glvk;
+    LeaveCriticalSection(&surface->crit);
+
+    /* Set initial position in the client area. */
+    wayland_get_client_rect_in_win_coords(surface->hwnd, &client_rect);
+
+    wayland_surface_reconfigure_glvk(surface,
+                                     client_rect.left, client_rect.top,
+                                     client_rect.right - client_rect.left,
+                                     client_rect.bottom - client_rect.top);
+
+    wayland_surface_reconfigure_apply(surface);
+
+    return TRUE;
+
+err:
+    if (glvk)
+        wayland_surface_destroy(glvk);
+
+    return FALSE;
+}
+
+/**********************************************************************
+ *          wayland_surface_unref_glvk
+ *
+ * Unreferences the associated GL/VK subsurface for this wayland surface.
+ */
+void wayland_surface_unref_glvk(struct wayland_surface *surface)
+{
+    struct wayland_surface *glvk_to_destroy = NULL;
+    LONG ref = -12345;
+
+    EnterCriticalSection(&surface->crit);
+    if (surface->glvk && (ref = InterlockedDecrement(&surface->glvk->ref)) == 0)
+    {
+        glvk_to_destroy = surface->glvk;
+        surface->glvk = NULL;
+    }
+    TRACE("surface=%p glvk=%p ref=%d->%d\n",
+          surface, glvk_to_destroy ? glvk_to_destroy : surface->glvk, ref + 1, ref);
+    LeaveCriticalSection(&surface->crit);
+
+    if (glvk_to_destroy)
+        wayland_surface_destroy(glvk_to_destroy);
+}
+
+/**********************************************************************
+ *          wayland_surface_reconfigure_glvk
+ *
+ * Configures the position and size of the GL/VK subsurface associated with
+ * a wayland surface.
+ *
+ * The coordinates and sizes should be given in wine's coordinate space.
+ *
+ * This function sets up but doesn't actually apply any new configuration.
+ * The wayland_surface_reconfigure_apply() needs to be called for changes
+ * to take effect.
+ */
+void wayland_surface_reconfigure_glvk(struct wayland_surface *surface,
+                                      int wine_x, int wine_y,
+                                      int wine_width, int wine_height)
+{
+    int x, y, width, height;
+    struct wayland_surface *glvk = wayland_surface_ref_glvk(surface);
+
+    if (!glvk)
+        return;
+
+    wayland_surface_coords_rounded_from_wine(surface, wine_x, wine_y, &x, &y);
+    wayland_surface_coords_rounded_from_wine(surface, wine_width, wine_height,
+                                             &width, &height);
+
+    TRACE("surface=%p hwnd=%p %d,%d+%dx%d %d,%d+%dx%d\n",
+          surface, surface->hwnd,
+          wine_x, wine_y, wine_width, wine_height,
+          x, y, width, height);
+
+    glvk->offset_x = wine_x;
+    glvk->offset_y = wine_y;
+
+    wl_subsurface_set_position(glvk->wl_subsurface, x, y);
+
+    /* The EGL window size needs to be in wine coords since this affects
+     * the effective EGL buffer size. */
+    if (glvk->wl_egl_window)
+        wl_egl_window_resize(glvk->wl_egl_window, wine_width, wine_height, 0, 0);
+
+    /* Use a viewport, if supported, to ensure GL surfaces remain inside their
+     * parent's boundaries when resizing and also to handle display mode
+     * changes. If the size is invalid use a 1x1 destination (instead of
+     * unsetting with -1x-1) since many apps don't respect a GL/VK 0x0 size
+     * which can happen, e.g., when an app is minimized. */
+    if (glvk->wp_viewport)
+    {
+        if (width != 0 && height != 0)
+            wp_viewport_set_destination(glvk->wp_viewport, width, height);
+        else
+            wp_viewport_set_destination(glvk->wp_viewport, 1, 1);
+    }
+
+    wayland_surface_unref_glvk(surface);
+}
+
+/**********************************************************************
+ *          wayland_surface_reconfigure_apply
+ *
+ * Applies the configuration set by previous calls to the
+ * wayland_surface_reconfigure{_glvk}() functions.
+ */
+void wayland_surface_reconfigure_apply(struct wayland_surface *surface)
+{
+    struct wayland_surface *glvk = wayland_surface_ref_glvk(surface);
+
+    if (glvk)
+    {
+        wl_surface_commit(glvk->wl_surface);
+        wayland_surface_unref_glvk(surface);
+    }
+
+    wl_surface_commit(surface->wl_surface);
+
+    /* Commit the parent so any subsurface repositioning takes effect. */
+    if (surface->parent)
+        wl_surface_commit(surface->parent->wl_surface);
+}
+
 /**********************************************************************
  *          wayland_surface_unmap
  *
@@ -785,6 +984,10 @@ void wayland_surface_coords_to_screen(struct wayland_surface *surface,
 
     GetWindowRect(surface->hwnd, &window_rect);
 
+    /* Some wayland surfaces are offset relative to their window rect,
+     * e.g., GL subsurfaces. */
+    OffsetRect(&window_rect, surface->offset_x, surface->offset_y);
+
     *screen_x = wine_x + window_rect.left;
     *screen_y = wine_y + window_rect.top;
 
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 373d68894b7..3a97897a6a5 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -27,6 +27,7 @@
 
 #include <stdarg.h>
 #include <wayland-client.h>
+#include <wayland-egl.h>
 #include <xkbcommon/xkbcommon.h>
 #include <xkbcommon/xkbcommon-compose.h>
 #include "viewporter-client-protocol.h"
@@ -197,7 +198,11 @@ struct wayland_surface
     struct xdg_surface *xdg_surface;
     struct xdg_toplevel *xdg_toplevel;
     struct wp_viewport *wp_viewport;
+    struct wl_egl_window *wl_egl_window;
     struct wayland_surface *parent;
+    struct wayland_surface *glvk;
+    /* The offset of this surface relative to its owning win32 window */
+    int offset_x, offset_y;
     HWND hwnd;
     CRITICAL_SECTION crit;
     struct wayland_surface_configure pending;
@@ -336,6 +341,10 @@ void wayland_surface_reconfigure_geometry(struct wayland_surface *surface,
 void wayland_surface_reconfigure_size(struct wayland_surface *surface,
                                       int width, int height);
 void wayland_surface_reconfigure_apply(struct wayland_surface *surface);
+BOOL wayland_surface_create_or_ref_gl(struct wayland_surface *surface);
+void wayland_surface_unref_glvk(struct wayland_surface *surface);
+void wayland_surface_reconfigure_glvk(struct wayland_surface *surface, int x, int y,
+                                      int width, int height);
 void wayland_surface_unmap(struct wayland_surface *surface);
 void wayland_surface_ack_pending_configure(struct wayland_surface *surface);
 void wayland_surface_coords_to_screen(struct wayland_surface *surface,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 15f7776e5da..cadcfcbc531 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -817,7 +817,16 @@ static void wayland_win_data_update_wayland_surface_state(struct wayland_win_dat
                                              compat.bottom - compat.top);
     }
 
-    wayland_surface_reconfigure_apply(wsurface);
+    /* The GL/VK subsurface (if any), is positioned over the client area of the
+     * window. The position of the GL/VK subsurface is relative to the window
+     * top-left. */
+    wayland_surface_reconfigure_glvk(wsurface,
+                                     data->client_rect.left - data->window_rect.left,
+                                     data->client_rect.top - data->window_rect.top,
+                                     data->client_rect.right - data->client_rect.left,
+                                     data->client_rect.bottom - data->client_rect.top);
+
+    wayland_surface_reconfigure_apply(data->wayland_surface);
 
     if (wsurface->xdg_toplevel || wsurface->wl_subsurface)
         wsurface->drawing_allowed = TRUE;
diff --git a/include/config.h.in b/include/config.h.in
index ba4cd3620a9..347b1c2613d 100644
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -700,6 +700,9 @@
 /* Define to 1 if you have the <wayland-client.h> header file. */
 #undef HAVE_WAYLAND_CLIENT_H
 
+/* Define to 1 if you have the <wayland-egl.h> header file. */
+#undef HAVE_WAYLAND_EGL_H
+
 /* Define to 1 if you have the <X11/extensions/shape.h> header file. */
 #undef HAVE_X11_EXTENSIONS_SHAPE_H
 
-- 
2.34.1


From 793ae5429072c0f5e968f26d4c6a7f64994d7de4 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 29 Sep 2021 14:17:56 +0300
Subject: [PATCH 070/147] winewayland.drv: Add skeleton OpenGL driver.

The driver opens the EGL and GL libraries and creates stubs for standard
GL functions.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 configure                         | 165 ++++++++++++++++++++++++++++++
 configure.ac                      |   3 +
 dlls/winewayland.drv/Makefile.in  |   1 +
 dlls/winewayland.drv/opengl.c     | 104 +++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h |   6 ++
 5 files changed, 279 insertions(+)
 create mode 100644 dlls/winewayland.drv/opengl.c

diff --git a/configure.ac b/configure.ac
index 922b29ac024..11d35f35eed 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1342,6 +1342,9 @@ then
         [AC_CHECK_HEADERS([wayland-egl.h])
          AC_CHECK_LIB(wayland-egl,wl_egl_window_create,[:],
                       [WAYLAND_EGL_LIBS=""],[$WAYLAND_EGL_LIBS])])
+    WINE_CHECK_SONAME(EGL,eglGetProcAddress)
+    WINE_CHECK_SONAME(GL,glFlush)
+    WINE_CHECK_SONAME(GLESv2,glFlush)
 fi
 WINE_NOTICE_WITH(wayland, [test -z "$WAYLAND_CLIENT_LIBS" ||
                            test -z "$WAYLAND_PROTOCOLS_DATADIR" ||
diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index dfcccaa0faa..7754eea8842 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -12,6 +12,7 @@ EXTRADLLFLAGS = -mcygwin
 C_SRCS = \
 	display.c \
 	gdi.c \
+	opengl.c \
 	wayland.c \
 	wayland_output.c \
 	waylanddrv_main.c \
diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
new file mode 100644
index 00000000000..4cdca1a5fd1
--- /dev/null
+++ b/dlls/winewayland.drv/opengl.c
@@ -0,0 +1,104 @@
+/*
+ * Wayland OpenGL functions
+ *
+ * Copyright 2000 Lionel Ulmer
+ * Copyright 2005 Alex Woods
+ * Copyright 2005 Raphael Junqueira
+ * Copyright 2006-2009 Roderick Colenbrander
+ * Copyright 2006 Tomas Carnecky
+ * Copyright 2013 Matteo Bruni
+ * Copyright 2012, 2013, 2014, 2017 Alexandre Julliard
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#define GLAPIENTRY /* nothing */
+#include "wine/wgl.h"
+#undef GLAPIENTRY
+#include "wine/wgl_driver.h"
+#include "wine/debug.h"
+
+#include <EGL/egl.h>
+#include <assert.h>
+#include <dlfcn.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+static void *egl_handle;
+static void *opengl_handle;
+
+static BOOL egl_init(void)
+{
+    static int retval = -1;
+
+    if (retval != -1) return retval;
+    retval = 0;
+
+    if (!(egl_handle = dlopen(SONAME_LIBEGL, RTLD_NOW|RTLD_GLOBAL)))
+    {
+        ERR("failed to load %s: %s\n", SONAME_LIBEGL, dlerror());
+        return FALSE;
+    }
+
+    if (!(opengl_handle = dlopen(SONAME_LIBGL, RTLD_NOW|RTLD_GLOBAL)))
+    {
+        WARN("failed to load %s: %s, trying GLESv2\n", SONAME_LIBGL, dlerror());
+        if (!(opengl_handle = dlopen(SONAME_LIBGLESV2, RTLD_NOW|RTLD_GLOBAL)))
+        {
+            ERR("failed to load %s: %s\n", SONAME_LIBGLESV2, dlerror());
+            return FALSE;
+        }
+    }
+
+    retval = 1;
+    return TRUE;
+}
+
+/* generate stubs for GL functions that are not exported */
+
+#define USE_GL_FUNC(name) \
+static void glstub_##name(void) \
+{ \
+    ERR(#name " called\n"); \
+    assert(0); \
+    ExitProcess(1); \
+}
+
+ALL_WGL_FUNCS
+#undef USE_GL_FUNC
+
+static struct opengl_funcs egl_funcs =
+{
+#define USE_GL_FUNC(name) (void *)glstub_##name,
+    .gl = { ALL_WGL_FUNCS }
+#undef USE_GL_FUNC
+};
+
+struct opengl_funcs *wayland_get_wgl_driver(UINT version)
+{
+    if (version != WINE_WGL_DRIVER_VERSION)
+    {
+        ERR("version mismatch, opengl32 wants %u but driver has %u\n",
+            version, WINE_WGL_DRIVER_VERSION);
+        return NULL;
+    }
+    if (!egl_init()) return NULL;
+    return &egl_funcs;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 3a97897a6a5..e417139f829 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -423,6 +423,12 @@ BOOL wayland_init_set_cursor(void);
 HCURSOR wayland_invalidate_set_cursor(void);
 void wayland_set_cursor_if_current_invalid(HCURSOR hcursor);
 
+/**********************************************************************
+ *          OpenGL support
+ */
+
+struct opengl_funcs *wayland_get_wgl_driver(UINT version);
+
 /**********************************************************************
  *          XKB helpers
  */
-- 
2.34.1


From c4058cf3ddc32ed4909f984a1218ee9f7de7261b Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 29 Sep 2021 14:25:46 +0300
Subject: [PATCH 071/147] winewayland.drv: Perform basic EGL initialization.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 19 +++++++++++++++++++
 1 file changed, 19 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 4cdca1a5fd1..260d1ad0399 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -43,10 +43,17 @@ WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
 static void *egl_handle;
 static void *opengl_handle;
+static EGLDisplay egl_display;
+
+#define DECL_FUNCPTR(f) static __typeof__(f) * p_##f = NULL
+DECL_FUNCPTR(eglGetDisplay);
+DECL_FUNCPTR(eglInitialize);
+#undef DECL_FUNCPTR
 
 static BOOL egl_init(void)
 {
     static int retval = -1;
+    EGLint major, minor;
 
     if (retval != -1) return retval;
     retval = 0;
@@ -67,6 +74,18 @@ static BOOL egl_init(void)
         }
     }
 
+#define LOAD_FUNCPTR(func) do { \
+        if (!(p_##func = dlsym(egl_handle, #func))) \
+        { ERR("can't find symbol %s\n", #func); return FALSE; }    \
+    } while(0)
+    LOAD_FUNCPTR(eglGetDisplay);
+    LOAD_FUNCPTR(eglInitialize);
+#undef LOAD_FUNCPTR
+
+    egl_display = p_eglGetDisplay((EGLNativeDisplayType) process_wl_display);
+    if (!p_eglInitialize(egl_display, &major, &minor)) return FALSE;
+    TRACE("display %p version %u.%u\n", egl_display, major, minor);
+
     retval = 1;
     return TRUE;
 }
-- 
2.34.1


From 8ca0b702155519dc8b115fc195d185a330e1ee89 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 29 Sep 2021 14:30:53 +0300
Subject: [PATCH 072/147] winewayland.drv: Initialize standard GL and extension
 functions.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 289 ++++++++++++++++++++++++++++++++++
 1 file changed, 289 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 260d1ad0399..048b909774a 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -44,12 +44,300 @@ WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 static void *egl_handle;
 static void *opengl_handle;
 static EGLDisplay egl_display;
+static struct opengl_funcs egl_funcs;
 
 #define DECL_FUNCPTR(f) static __typeof__(f) * p_##f = NULL
 DECL_FUNCPTR(eglGetDisplay);
 DECL_FUNCPTR(eglInitialize);
 #undef DECL_FUNCPTR
 
+static void init_extensions(void)
+{
+    void *ptr;
+
+    /* load standard functions and extensions exported from the OpenGL library */
+
+#define USE_GL_FUNC(func) if ((ptr = dlsym(opengl_handle, #func))) egl_funcs.gl.p_##func = ptr;
+    ALL_WGL_FUNCS
+#undef USE_GL_FUNC
+
+#define LOAD_FUNCPTR(func) egl_funcs.ext.p_##func = dlsym(opengl_handle, #func)
+    LOAD_FUNCPTR(glActiveShaderProgram);
+    LOAD_FUNCPTR(glActiveTexture);
+    LOAD_FUNCPTR(glAttachShader);
+    LOAD_FUNCPTR(glBeginQuery);
+    LOAD_FUNCPTR(glBeginTransformFeedback);
+    LOAD_FUNCPTR(glBindAttribLocation);
+    LOAD_FUNCPTR(glBindBuffer);
+    LOAD_FUNCPTR(glBindBufferBase);
+    LOAD_FUNCPTR(glBindBufferRange);
+    LOAD_FUNCPTR(glBindFramebuffer);
+    LOAD_FUNCPTR(glBindImageTexture);
+    LOAD_FUNCPTR(glBindProgramPipeline);
+    LOAD_FUNCPTR(glBindRenderbuffer);
+    LOAD_FUNCPTR(glBindSampler);
+    LOAD_FUNCPTR(glBindTransformFeedback);
+    LOAD_FUNCPTR(glBindVertexArray);
+    LOAD_FUNCPTR(glBindVertexBuffer);
+    LOAD_FUNCPTR(glBlendBarrierKHR);
+    LOAD_FUNCPTR(glBlendColor);
+    LOAD_FUNCPTR(glBlendEquation);
+    LOAD_FUNCPTR(glBlendEquationSeparate);
+    LOAD_FUNCPTR(glBlendFuncSeparate);
+    LOAD_FUNCPTR(glBlitFramebuffer);
+    LOAD_FUNCPTR(glBufferData);
+    LOAD_FUNCPTR(glBufferSubData);
+    LOAD_FUNCPTR(glCheckFramebufferStatus);
+    LOAD_FUNCPTR(glClearBufferfi);
+    LOAD_FUNCPTR(glClearBufferfv);
+    LOAD_FUNCPTR(glClearBufferiv);
+    LOAD_FUNCPTR(glClearBufferuiv);
+    LOAD_FUNCPTR(glClearDepthf);
+    LOAD_FUNCPTR(glClientWaitSync);
+    LOAD_FUNCPTR(glCompileShader);
+    LOAD_FUNCPTR(glCompressedTexImage2D);
+    LOAD_FUNCPTR(glCompressedTexImage3D);
+    LOAD_FUNCPTR(glCompressedTexSubImage2D);
+    LOAD_FUNCPTR(glCompressedTexSubImage3D);
+    LOAD_FUNCPTR(glCopyBufferSubData);
+    LOAD_FUNCPTR(glCopyTexSubImage3D);
+    LOAD_FUNCPTR(glCreateProgram);
+    LOAD_FUNCPTR(glCreateShader);
+    LOAD_FUNCPTR(glCreateShaderProgramv);
+    LOAD_FUNCPTR(glDeleteBuffers);
+    LOAD_FUNCPTR(glDeleteFramebuffers);
+    LOAD_FUNCPTR(glDeleteProgram);
+    LOAD_FUNCPTR(glDeleteProgramPipelines);
+    LOAD_FUNCPTR(glDeleteQueries);
+    LOAD_FUNCPTR(glDeleteRenderbuffers);
+    LOAD_FUNCPTR(glDeleteSamplers);
+    LOAD_FUNCPTR(glDeleteShader);
+    LOAD_FUNCPTR(glDeleteSync);
+    LOAD_FUNCPTR(glDeleteTransformFeedbacks);
+    LOAD_FUNCPTR(glDeleteVertexArrays);
+    LOAD_FUNCPTR(glDepthRangef);
+    LOAD_FUNCPTR(glDetachShader);
+    LOAD_FUNCPTR(glDisableVertexAttribArray);
+    LOAD_FUNCPTR(glDispatchCompute);
+    LOAD_FUNCPTR(glDispatchComputeIndirect);
+    LOAD_FUNCPTR(glDrawArraysIndirect);
+    LOAD_FUNCPTR(glDrawArraysInstanced);
+    LOAD_FUNCPTR(glDrawBuffers);
+    LOAD_FUNCPTR(glDrawElementsIndirect);
+    LOAD_FUNCPTR(glDrawElementsInstanced);
+    LOAD_FUNCPTR(glDrawRangeElements);
+    LOAD_FUNCPTR(glEnableVertexAttribArray);
+    LOAD_FUNCPTR(glEndQuery);
+    LOAD_FUNCPTR(glEndTransformFeedback);
+    LOAD_FUNCPTR(glFenceSync);
+    LOAD_FUNCPTR(glFlushMappedBufferRange);
+    LOAD_FUNCPTR(glFramebufferParameteri);
+    LOAD_FUNCPTR(glFramebufferRenderbuffer);
+    LOAD_FUNCPTR(glFramebufferTexture2D);
+    LOAD_FUNCPTR(glFramebufferTextureEXT);
+    LOAD_FUNCPTR(glFramebufferTextureLayer);
+    LOAD_FUNCPTR(glGenBuffers);
+    LOAD_FUNCPTR(glGenFramebuffers);
+    LOAD_FUNCPTR(glGenProgramPipelines);
+    LOAD_FUNCPTR(glGenQueries);
+    LOAD_FUNCPTR(glGenRenderbuffers);
+    LOAD_FUNCPTR(glGenSamplers);
+    LOAD_FUNCPTR(glGenTransformFeedbacks);
+    LOAD_FUNCPTR(glGenVertexArrays);
+    LOAD_FUNCPTR(glGenerateMipmap);
+    LOAD_FUNCPTR(glGetActiveAttrib);
+    LOAD_FUNCPTR(glGetActiveUniform);
+    LOAD_FUNCPTR(glGetActiveUniformBlockName);
+    LOAD_FUNCPTR(glGetActiveUniformBlockiv);
+    LOAD_FUNCPTR(glGetActiveUniformsiv);
+    LOAD_FUNCPTR(glGetAttachedShaders);
+    LOAD_FUNCPTR(glGetAttribLocation);
+    LOAD_FUNCPTR(glGetBooleani_v);
+    LOAD_FUNCPTR(glGetBufferParameteri64v);
+    LOAD_FUNCPTR(glGetBufferParameteriv);
+    LOAD_FUNCPTR(glGetBufferPointerv);
+    LOAD_FUNCPTR(glGetFragDataLocation);
+    LOAD_FUNCPTR(glGetFramebufferAttachmentParameteriv);
+    LOAD_FUNCPTR(glGetFramebufferParameteriv);
+    LOAD_FUNCPTR(glGetInteger64i_v);
+    LOAD_FUNCPTR(glGetInteger64v);
+    LOAD_FUNCPTR(glGetIntegeri_v);
+    LOAD_FUNCPTR(glGetInternalformativ);
+    LOAD_FUNCPTR(glGetMultisamplefv);
+    LOAD_FUNCPTR(glGetProgramBinary);
+    LOAD_FUNCPTR(glGetProgramInfoLog);
+    LOAD_FUNCPTR(glGetProgramInterfaceiv);
+    LOAD_FUNCPTR(glGetProgramPipelineInfoLog);
+    LOAD_FUNCPTR(glGetProgramPipelineiv);
+    LOAD_FUNCPTR(glGetProgramResourceIndex);
+    LOAD_FUNCPTR(glGetProgramResourceLocation);
+    LOAD_FUNCPTR(glGetProgramResourceName);
+    LOAD_FUNCPTR(glGetProgramResourceiv);
+    LOAD_FUNCPTR(glGetProgramiv);
+    LOAD_FUNCPTR(glGetQueryObjectuiv);
+    LOAD_FUNCPTR(glGetQueryiv);
+    LOAD_FUNCPTR(glGetRenderbufferParameteriv);
+    LOAD_FUNCPTR(glGetSamplerParameterfv);
+    LOAD_FUNCPTR(glGetSamplerParameteriv);
+    LOAD_FUNCPTR(glGetShaderInfoLog);
+    LOAD_FUNCPTR(glGetShaderPrecisionFormat);
+    LOAD_FUNCPTR(glGetShaderSource);
+    LOAD_FUNCPTR(glGetShaderiv);
+    LOAD_FUNCPTR(glGetStringi);
+    LOAD_FUNCPTR(glGetSynciv);
+    LOAD_FUNCPTR(glGetTexParameterIivEXT);
+    LOAD_FUNCPTR(glGetTexParameterIuivEXT);
+    LOAD_FUNCPTR(glGetTransformFeedbackVarying);
+    LOAD_FUNCPTR(glGetUniformBlockIndex);
+    LOAD_FUNCPTR(glGetUniformIndices);
+    LOAD_FUNCPTR(glGetUniformLocation);
+    LOAD_FUNCPTR(glGetUniformfv);
+    LOAD_FUNCPTR(glGetUniformiv);
+    LOAD_FUNCPTR(glGetUniformuiv);
+    LOAD_FUNCPTR(glGetVertexAttribIiv);
+    LOAD_FUNCPTR(glGetVertexAttribIuiv);
+    LOAD_FUNCPTR(glGetVertexAttribPointerv);
+    LOAD_FUNCPTR(glGetVertexAttribfv);
+    LOAD_FUNCPTR(glGetVertexAttribiv);
+    LOAD_FUNCPTR(glInvalidateFramebuffer);
+    LOAD_FUNCPTR(glInvalidateSubFramebuffer);
+    LOAD_FUNCPTR(glIsBuffer);
+    LOAD_FUNCPTR(glIsFramebuffer);
+    LOAD_FUNCPTR(glIsProgram);
+    LOAD_FUNCPTR(glIsProgramPipeline);
+    LOAD_FUNCPTR(glIsQuery);
+    LOAD_FUNCPTR(glIsRenderbuffer);
+    LOAD_FUNCPTR(glIsSampler);
+    LOAD_FUNCPTR(glIsShader);
+    LOAD_FUNCPTR(glIsSync);
+    LOAD_FUNCPTR(glIsTransformFeedback);
+    LOAD_FUNCPTR(glIsVertexArray);
+    LOAD_FUNCPTR(glLinkProgram);
+    LOAD_FUNCPTR(glMapBufferRange);
+    LOAD_FUNCPTR(glMemoryBarrier);
+    LOAD_FUNCPTR(glMemoryBarrierByRegion);
+    LOAD_FUNCPTR(glPauseTransformFeedback);
+    LOAD_FUNCPTR(glProgramBinary);
+    LOAD_FUNCPTR(glProgramParameteri);
+    LOAD_FUNCPTR(glProgramUniform1f);
+    LOAD_FUNCPTR(glProgramUniform1fv);
+    LOAD_FUNCPTR(glProgramUniform1i);
+    LOAD_FUNCPTR(glProgramUniform1iv);
+    LOAD_FUNCPTR(glProgramUniform1ui);
+    LOAD_FUNCPTR(glProgramUniform1uiv);
+    LOAD_FUNCPTR(glProgramUniform2f);
+    LOAD_FUNCPTR(glProgramUniform2fv);
+    LOAD_FUNCPTR(glProgramUniform2i);
+    LOAD_FUNCPTR(glProgramUniform2iv);
+    LOAD_FUNCPTR(glProgramUniform2ui);
+    LOAD_FUNCPTR(glProgramUniform2uiv);
+    LOAD_FUNCPTR(glProgramUniform3f);
+    LOAD_FUNCPTR(glProgramUniform3fv);
+    LOAD_FUNCPTR(glProgramUniform3i);
+    LOAD_FUNCPTR(glProgramUniform3iv);
+    LOAD_FUNCPTR(glProgramUniform3ui);
+    LOAD_FUNCPTR(glProgramUniform3uiv);
+    LOAD_FUNCPTR(glProgramUniform4f);
+    LOAD_FUNCPTR(glProgramUniform4fv);
+    LOAD_FUNCPTR(glProgramUniform4i);
+    LOAD_FUNCPTR(glProgramUniform4iv);
+    LOAD_FUNCPTR(glProgramUniform4ui);
+    LOAD_FUNCPTR(glProgramUniform4uiv);
+    LOAD_FUNCPTR(glProgramUniformMatrix2fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix2x3fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix2x4fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix3fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix3x2fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix3x4fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix4fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix4x2fv);
+    LOAD_FUNCPTR(glProgramUniformMatrix4x3fv);
+    LOAD_FUNCPTR(glReleaseShaderCompiler);
+    LOAD_FUNCPTR(glRenderbufferStorage);
+    LOAD_FUNCPTR(glRenderbufferStorageMultisample);
+    LOAD_FUNCPTR(glResumeTransformFeedback);
+    LOAD_FUNCPTR(glSampleCoverage);
+    LOAD_FUNCPTR(glSampleMaski);
+    LOAD_FUNCPTR(glSamplerParameterf);
+    LOAD_FUNCPTR(glSamplerParameterfv);
+    LOAD_FUNCPTR(glSamplerParameteri);
+    LOAD_FUNCPTR(glSamplerParameteriv);
+    LOAD_FUNCPTR(glShaderBinary);
+    LOAD_FUNCPTR(glShaderSource);
+    LOAD_FUNCPTR(glStencilFuncSeparate);
+    LOAD_FUNCPTR(glStencilMaskSeparate);
+    LOAD_FUNCPTR(glStencilOpSeparate);
+    LOAD_FUNCPTR(glTexBufferEXT);
+    LOAD_FUNCPTR(glTexImage3D);
+    LOAD_FUNCPTR(glTexParameterIivEXT);
+    LOAD_FUNCPTR(glTexParameterIuivEXT);
+    LOAD_FUNCPTR(glTexStorage2D);
+    LOAD_FUNCPTR(glTexStorage2DMultisample);
+    LOAD_FUNCPTR(glTexStorage3D);
+    LOAD_FUNCPTR(glTexSubImage3D);
+    LOAD_FUNCPTR(glTransformFeedbackVaryings);
+    LOAD_FUNCPTR(glUniform1f);
+    LOAD_FUNCPTR(glUniform1fv);
+    LOAD_FUNCPTR(glUniform1i);
+    LOAD_FUNCPTR(glUniform1iv);
+    LOAD_FUNCPTR(glUniform1ui);
+    LOAD_FUNCPTR(glUniform1uiv);
+    LOAD_FUNCPTR(glUniform2f);
+    LOAD_FUNCPTR(glUniform2fv);
+    LOAD_FUNCPTR(glUniform2i);
+    LOAD_FUNCPTR(glUniform2iv);
+    LOAD_FUNCPTR(glUniform2ui);
+    LOAD_FUNCPTR(glUniform2uiv);
+    LOAD_FUNCPTR(glUniform3f);
+    LOAD_FUNCPTR(glUniform3fv);
+    LOAD_FUNCPTR(glUniform3i);
+    LOAD_FUNCPTR(glUniform3iv);
+    LOAD_FUNCPTR(glUniform3ui);
+    LOAD_FUNCPTR(glUniform3uiv);
+    LOAD_FUNCPTR(glUniform4f);
+    LOAD_FUNCPTR(glUniform4fv);
+    LOAD_FUNCPTR(glUniform4i);
+    LOAD_FUNCPTR(glUniform4iv);
+    LOAD_FUNCPTR(glUniform4ui);
+    LOAD_FUNCPTR(glUniform4uiv);
+    LOAD_FUNCPTR(glUniformBlockBinding);
+    LOAD_FUNCPTR(glUniformMatrix2fv);
+    LOAD_FUNCPTR(glUniformMatrix2x3fv);
+    LOAD_FUNCPTR(glUniformMatrix2x4fv);
+    LOAD_FUNCPTR(glUniformMatrix3fv);
+    LOAD_FUNCPTR(glUniformMatrix3x2fv);
+    LOAD_FUNCPTR(glUniformMatrix3x4fv);
+    LOAD_FUNCPTR(glUniformMatrix4fv);
+    LOAD_FUNCPTR(glUniformMatrix4x2fv);
+    LOAD_FUNCPTR(glUniformMatrix4x3fv);
+    LOAD_FUNCPTR(glUnmapBuffer);
+    LOAD_FUNCPTR(glUseProgram);
+    LOAD_FUNCPTR(glUseProgramStages);
+    LOAD_FUNCPTR(glValidateProgram);
+    LOAD_FUNCPTR(glValidateProgramPipeline);
+    LOAD_FUNCPTR(glVertexAttrib1f);
+    LOAD_FUNCPTR(glVertexAttrib1fv);
+    LOAD_FUNCPTR(glVertexAttrib2f);
+    LOAD_FUNCPTR(glVertexAttrib2fv);
+    LOAD_FUNCPTR(glVertexAttrib3f);
+    LOAD_FUNCPTR(glVertexAttrib3fv);
+    LOAD_FUNCPTR(glVertexAttrib4f);
+    LOAD_FUNCPTR(glVertexAttrib4fv);
+    LOAD_FUNCPTR(glVertexAttribBinding);
+    LOAD_FUNCPTR(glVertexAttribDivisor);
+    LOAD_FUNCPTR(glVertexAttribFormat);
+    LOAD_FUNCPTR(glVertexAttribI4i);
+    LOAD_FUNCPTR(glVertexAttribI4iv);
+    LOAD_FUNCPTR(glVertexAttribI4ui);
+    LOAD_FUNCPTR(glVertexAttribI4uiv);
+    LOAD_FUNCPTR(glVertexAttribIFormat);
+    LOAD_FUNCPTR(glVertexAttribIPointer);
+    LOAD_FUNCPTR(glVertexAttribPointer);
+    LOAD_FUNCPTR(glVertexBindingDivisor);
+    LOAD_FUNCPTR(glWaitSync);
+#undef LOAD_FUNCPTR
+}
+
 static BOOL egl_init(void)
 {
     static int retval = -1;
@@ -86,6 +374,7 @@ static BOOL egl_init(void)
     if (!p_eglInitialize(egl_display, &major, &minor)) return FALSE;
     TRACE("display %p version %u.%u\n", egl_display, major, minor);
 
+    init_extensions();
     retval = 1;
     return TRUE;
 }
-- 
2.34.1


From 3b0c33c610a24f38ffee5470f89890c4a1883f54 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 29 Sep 2021 14:33:33 +0300
Subject: [PATCH 073/147] winewayland.drv: Implement
 wglGetExtensionsString{ARB,EXT}.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 32 ++++++++++++++++++++++++++++++++
 1 file changed, 32 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 048b909774a..bc1b0ee4d7a 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -44,6 +44,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 static void *egl_handle;
 static void *opengl_handle;
 static EGLDisplay egl_display;
+static char wgl_extensions[4096];
 static struct opengl_funcs egl_funcs;
 
 #define DECL_FUNCPTR(f) static __typeof__(f) * p_##f = NULL
@@ -51,10 +52,41 @@ DECL_FUNCPTR(eglGetDisplay);
 DECL_FUNCPTR(eglInitialize);
 #undef DECL_FUNCPTR
 
+/***********************************************************************
+ *		wayland_wglGetExtensionsStringARB
+ */
+static const char *wayland_wglGetExtensionsStringARB(HDC hdc)
+{
+    TRACE("() returning \"%s\"\n", wgl_extensions);
+    return wgl_extensions;
+}
+
+/***********************************************************************
+ *		wayland_wglGetExtensionsStringEXT
+ */
+static const char *wayland_wglGetExtensionsStringEXT(void)
+{
+    TRACE("() returning \"%s\"\n", wgl_extensions);
+    return wgl_extensions;
+}
+
+static void register_extension(const char *ext)
+{
+    if (wgl_extensions[0]) strcat(wgl_extensions, " ");
+    strcat(wgl_extensions, ext);
+    TRACE("%s\n", ext);
+}
+
 static void init_extensions(void)
 {
     void *ptr;
 
+    register_extension("WGL_ARB_extensions_string");
+    egl_funcs.ext.p_wglGetExtensionsStringARB = wayland_wglGetExtensionsStringARB;
+
+    register_extension("WGL_EXT_extensions_string");
+    egl_funcs.ext.p_wglGetExtensionsStringEXT = wayland_wglGetExtensionsStringEXT;
+
     /* load standard functions and extensions exported from the OpenGL library */
 
 #define USE_GL_FUNC(func) if ((ptr = dlsym(opengl_handle, #func))) egl_funcs.gl.p_##func = ptr;
-- 
2.34.1


From 96e5ad592ae8004269ed82e56abae8ee8669eb8c Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 14:37:55 +0300
Subject: [PATCH 074/147] winewayland.drv: Implement wglGetProcAddress.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index bc1b0ee4d7a..759db450ddf 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -49,9 +49,22 @@ static struct opengl_funcs egl_funcs;
 
 #define DECL_FUNCPTR(f) static __typeof__(f) * p_##f = NULL
 DECL_FUNCPTR(eglGetDisplay);
+DECL_FUNCPTR(eglGetProcAddress);
 DECL_FUNCPTR(eglInitialize);
 #undef DECL_FUNCPTR
 
+/***********************************************************************
+ *		wayland_wglGetProcAddress
+ */
+static PROC WINAPI wayland_wglGetProcAddress(LPCSTR name)
+{
+    PROC ret;
+    if (!strncmp(name, "wgl", 3)) return NULL;
+    ret = (PROC)p_eglGetProcAddress(name);
+    TRACE("%s -> %p\n", name, ret);
+    return ret;
+}
+
 /***********************************************************************
  *		wayland_wglGetExtensionsStringARB
  */
@@ -399,6 +412,7 @@ static BOOL egl_init(void)
         { ERR("can't find symbol %s\n", #func); return FALSE; }    \
     } while(0)
     LOAD_FUNCPTR(eglGetDisplay);
+    LOAD_FUNCPTR(eglGetProcAddress);
     LOAD_FUNCPTR(eglInitialize);
 #undef LOAD_FUNCPTR
 
@@ -426,6 +440,10 @@ ALL_WGL_FUNCS
 
 static struct opengl_funcs egl_funcs =
 {
+    .wgl =
+    {
+        .p_wglGetProcAddress = wayland_wglGetProcAddress,
+    },
 #define USE_GL_FUNC(name) (void *)glstub_##name,
     .gl = { ALL_WGL_FUNCS }
 #undef USE_GL_FUNC
-- 
2.34.1


From 900bf58b215ff175d42ef056ae40b998d44ccaf8 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 12:26:45 +0300
Subject: [PATCH 075/147] winewayland.drv: Initialize OpenGL pixel formats.

Create an array of supported pixel formats, each backed by an EGLConfig.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 71 +++++++++++++++++++++++++++++++++++
 1 file changed, 71 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 759db450ddf..ff42ab950ad 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -34,6 +34,7 @@
 #undef GLAPIENTRY
 #include "wine/wgl_driver.h"
 #include "wine/debug.h"
+#include "wine/heap.h"
 
 #include <EGL/egl.h>
 #include <assert.h>
@@ -41,13 +42,22 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+struct wgl_pixel_format
+{
+    EGLConfig config;
+};
+
 static void *egl_handle;
 static void *opengl_handle;
 static EGLDisplay egl_display;
 static char wgl_extensions[4096];
 static struct opengl_funcs egl_funcs;
+static struct wgl_pixel_format *pixel_formats;
+static int nb_pixel_formats, nb_onscreen_formats;
 
 #define DECL_FUNCPTR(f) static __typeof__(f) * p_##f = NULL
+DECL_FUNCPTR(eglGetConfigAttrib);
+DECL_FUNCPTR(eglGetConfigs);
 DECL_FUNCPTR(eglGetDisplay);
 DECL_FUNCPTR(eglGetProcAddress);
 DECL_FUNCPTR(eglInitialize);
@@ -383,6 +393,63 @@ static void init_extensions(void)
 #undef LOAD_FUNCPTR
 }
 
+static BOOL init_pixel_formats(void)
+{
+    EGLint count, i, pass;
+    EGLConfig *egl_configs;
+
+    p_eglGetConfigs(egl_display, NULL, 0, &count);
+    egl_configs = heap_alloc(count * sizeof(*egl_configs));
+    pixel_formats = heap_alloc(count * sizeof(*pixel_formats));
+    p_eglGetConfigs(egl_display, egl_configs, count, &count);
+    if (!count || !egl_configs || !pixel_formats)
+    {
+        heap_free(egl_configs);
+        heap_free(pixel_formats);
+        ERR("eglGetConfigs returned no configs\n");
+        return FALSE;
+    }
+
+    /* Use two passes: the first pass adds the onscreen formats to the format list,
+     * the second offscreen ones. */
+    for (pass = 0; pass < 2; pass++)
+    {
+        for (i = 0; i < count; i++)
+        {
+            EGLint id, type, visual_id, native, render, color, r, g, b, d, s;
+
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_SURFACE_TYPE, &type);
+            if (!(type & EGL_WINDOW_BIT) == !pass) continue;
+
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_RENDERABLE_TYPE, &render);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_CONFIG_ID, &id);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_NATIVE_VISUAL_ID, &visual_id);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_NATIVE_RENDERABLE, &native);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_COLOR_BUFFER_TYPE, &color);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_RED_SIZE, &r);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_GREEN_SIZE, &g);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_BLUE_SIZE, &b);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_DEPTH_SIZE, &d);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_STENCIL_SIZE, &s);
+
+            /* Some drivers expose 10 bit components which are not typically what
+             * applications want. */
+            if (r > 8 || g > 8 || b > 8) continue;
+
+            pixel_formats[nb_pixel_formats++].config = egl_configs[i];
+            TRACE("%u: config %u id %u type %x visual %u native %u render %x "
+                  "colortype %u rgb %u,%u,%u depth %u stencil %u\n",
+                   nb_pixel_formats, i, id, type, visual_id, native, render,
+                   color, r, g, b, d, s);
+        }
+        if (pass == 0) nb_onscreen_formats = nb_pixel_formats;
+    }
+
+    heap_free(egl_configs);
+
+    return TRUE;
+}
+
 static BOOL egl_init(void)
 {
     static int retval = -1;
@@ -411,6 +478,8 @@ static BOOL egl_init(void)
         if (!(p_##func = dlsym(egl_handle, #func))) \
         { ERR("can't find symbol %s\n", #func); return FALSE; }    \
     } while(0)
+    LOAD_FUNCPTR(eglGetConfigAttrib);
+    LOAD_FUNCPTR(eglGetConfigs);
     LOAD_FUNCPTR(eglGetDisplay);
     LOAD_FUNCPTR(eglGetProcAddress);
     LOAD_FUNCPTR(eglInitialize);
@@ -420,6 +489,8 @@ static BOOL egl_init(void)
     if (!p_eglInitialize(egl_display, &major, &minor)) return FALSE;
     TRACE("display %p version %u.%u\n", egl_display, major, minor);
 
+    if (!init_pixel_formats()) return FALSE;
+
     init_extensions();
     retval = 1;
     return TRUE;
-- 
2.34.1


From c4594b05b687229c6835a060c80b545e8940ca6d Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 12:32:28 +0300
Subject: [PATCH 076/147] winewayland.drv: Implement wglDescribePixelFormat.

Populate the PIXELFORMATDESCRIPTOR using information from the backind
EGLConfig.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 54 +++++++++++++++++++++++++++++++++++
 1 file changed, 54 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index ff42ab950ad..630bb2ae449 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -63,6 +63,59 @@ DECL_FUNCPTR(eglGetProcAddress);
 DECL_FUNCPTR(eglInitialize);
 #undef DECL_FUNCPTR
 
+static inline BOOL is_onscreen_pixel_format(int format)
+{
+    return format > 0 && format <= nb_onscreen_formats;
+}
+
+/***********************************************************************
+ *		wayland_wglDescribePixelFormat
+ */
+static int WINAPI wayland_wglDescribePixelFormat(HDC hdc, int fmt, UINT size,
+                                                 PIXELFORMATDESCRIPTOR *pfd)
+{
+    EGLint val;
+    EGLConfig config;
+
+    if (!pfd) return nb_onscreen_formats;
+    if (!is_onscreen_pixel_format(fmt)) return 0;
+    if (size < sizeof(*pfd)) return 0;
+    config = pixel_formats[fmt - 1].config;
+
+    memset(pfd, 0, sizeof(*pfd));
+    pfd->nSize = sizeof(*pfd);
+    pfd->nVersion = 1;
+    pfd->dwFlags = PFD_SUPPORT_OPENGL | PFD_DRAW_TO_WINDOW | PFD_DOUBLEBUFFER |
+                   PFD_SUPPORT_COMPOSITION;
+    pfd->iPixelType = PFD_TYPE_RGBA;
+    pfd->iLayerType = PFD_MAIN_PLANE;
+
+    p_eglGetConfigAttrib(egl_display, config, EGL_BUFFER_SIZE, &val);
+    pfd->cColorBits = val;
+    p_eglGetConfigAttrib(egl_display, config, EGL_RED_SIZE, &val);
+    pfd->cRedBits = val;
+    p_eglGetConfigAttrib(egl_display, config, EGL_GREEN_SIZE, &val);
+    pfd->cGreenBits = val;
+    p_eglGetConfigAttrib(egl_display, config, EGL_BLUE_SIZE, &val);
+    pfd->cBlueBits = val;
+    p_eglGetConfigAttrib(egl_display, config, EGL_ALPHA_SIZE, &val);
+    pfd->cAlphaBits = val;
+    p_eglGetConfigAttrib(egl_display, config, EGL_DEPTH_SIZE, &val);
+    pfd->cDepthBits = val;
+    p_eglGetConfigAttrib(egl_display, config, EGL_STENCIL_SIZE, &val);
+    pfd->cStencilBits = val;
+
+    pfd->cAlphaShift = 0;
+    pfd->cBlueShift = pfd->cAlphaShift + pfd->cAlphaBits;
+    pfd->cGreenShift = pfd->cBlueShift + pfd->cBlueBits;
+    pfd->cRedShift = pfd->cGreenShift + pfd->cGreenBits;
+
+    TRACE("fmt %u color %u %u/%u/%u/%u depth %u stencil %u\n",
+           fmt, pfd->cColorBits, pfd->cRedBits, pfd->cGreenBits, pfd->cBlueBits,
+           pfd->cAlphaBits, pfd->cDepthBits, pfd->cStencilBits);
+    return nb_onscreen_formats;
+}
+
 /***********************************************************************
  *		wayland_wglGetProcAddress
  */
@@ -513,6 +566,7 @@ static struct opengl_funcs egl_funcs =
 {
     .wgl =
     {
+        .p_wglDescribePixelFormat = wayland_wglDescribePixelFormat,
         .p_wglGetProcAddress = wayland_wglGetProcAddress,
     },
 #define USE_GL_FUNC(name) (void *)glstub_##name,
-- 
2.34.1


From d5a194866d35e8bbeb04774e14007b939068f7a4 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 13:19:52 +0300
Subject: [PATCH 077/147] winewayland.drv: Add infrastructure to associate an
 EGL surface with a window.

Introduce the internal wayland_gl_drawable object, which associates a
window (and its backing Wayland surface) with an EGL surface.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c     | 102 ++++++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h |   2 +
 dlls/winewayland.drv/window.c     |   4 +-
 3 files changed, 106 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 630bb2ae449..17fb3060307 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -36,6 +36,8 @@
 #include "wine/debug.h"
 #include "wine/heap.h"
 
+#include "winuser.h"
+
 #include <EGL/egl.h>
 #include <assert.h>
 #include <dlfcn.h>
@@ -47,6 +49,15 @@ struct wgl_pixel_format
     EGLConfig config;
 };
 
+struct wayland_gl_drawable
+{
+    struct wl_list  link;
+    HWND            hwnd;
+    int             format;
+    struct wayland_surface  *wayland_surface;
+    EGLSurface      surface;
+};
+
 static void *egl_handle;
 static void *opengl_handle;
 static EGLDisplay egl_display;
@@ -55,7 +66,21 @@ static struct opengl_funcs egl_funcs;
 static struct wgl_pixel_format *pixel_formats;
 static int nb_pixel_formats, nb_onscreen_formats;
 
+static struct wl_list gl_drawables = { &gl_drawables, &gl_drawables };
+
+/* Protects drawables and contexts. */
+static CRITICAL_SECTION drawable_section;
+static CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &drawable_section,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": drawable_section") }
+};
+static CRITICAL_SECTION drawable_section = { &critsect_debug, -1, 0, 0, 0, 0 };
+
 #define DECL_FUNCPTR(f) static __typeof__(f) * p_##f = NULL
+DECL_FUNCPTR(eglCreateWindowSurface);
+DECL_FUNCPTR(eglDestroySurface);
 DECL_FUNCPTR(eglGetConfigAttrib);
 DECL_FUNCPTR(eglGetConfigs);
 DECL_FUNCPTR(eglGetDisplay);
@@ -68,6 +93,81 @@ static inline BOOL is_onscreen_pixel_format(int format)
     return format > 0 && format <= nb_onscreen_formats;
 }
 
+static struct wayland_gl_drawable *wayland_gl_drawable_create(HWND hwnd, int format)
+{
+    struct wayland_gl_drawable *gl = heap_alloc(sizeof(*gl));
+    struct wayland_surface *wayland_surface = wayland_surface_for_hwnd_lock(hwnd);
+
+    TRACE("hwnd=%p wayland_surface=%p\n", hwnd, wayland_surface);
+
+    if (wayland_surface)
+    {
+        BOOL ref_gl = wayland_surface_create_or_ref_gl(wayland_surface);
+        wayland_surface_for_hwnd_unlock(wayland_surface);
+        if (!ref_gl) return NULL;
+    }
+
+    gl->hwnd   = hwnd;
+    gl->format = format;
+    gl->wayland_surface = wayland_surface;
+    gl->surface = 0;
+
+    EnterCriticalSection(&drawable_section);
+    wl_list_insert(&gl_drawables, &gl->link);
+    return gl;
+}
+
+static void wayland_destroy_gl_drawable(HWND hwnd)
+{
+    struct wayland_gl_drawable *gl;
+
+    EnterCriticalSection(&drawable_section);
+    wl_list_for_each(gl, &gl_drawables, link)
+    {
+        if (gl->hwnd != hwnd) continue;
+        wl_list_remove(&gl->link);
+        if (gl->surface) p_eglDestroySurface(egl_display, gl->surface);
+        if (gl->wayland_surface)
+            wayland_surface_unref_glvk(gl->wayland_surface);
+        heap_free(gl);
+        break;
+    }
+    LeaveCriticalSection(&drawable_section);
+}
+
+static struct wayland_gl_drawable *wayland_gl_drawable_get(HWND hwnd)
+{
+    struct wayland_gl_drawable *gl;
+
+    if (!hwnd) return NULL;
+
+    EnterCriticalSection(&drawable_section);
+    wl_list_for_each(gl, &gl_drawables, link)
+    {
+        if (gl->hwnd == hwnd) return gl;
+    }
+    LeaveCriticalSection(&drawable_section);
+    return NULL;
+}
+
+static void wayland_gl_drawable_release(struct wayland_gl_drawable *gl)
+{
+    if (gl) LeaveCriticalSection(&drawable_section);
+}
+
+static void wayland_gl_drawable_update(struct wayland_gl_drawable *gl)
+{
+    TRACE("hwnd=%p\n", gl->hwnd);
+
+    if (gl->surface || !gl->wayland_surface) goto out;
+
+    gl->surface = p_eglCreateWindowSurface(egl_display, pixel_formats[gl->format - 1].config,
+                                           gl->wayland_surface->glvk->wl_egl_window, NULL);
+
+out:
+    RedrawWindow(gl->hwnd, NULL, 0, RDW_INVALIDATE | RDW_ERASE);
+}
+
 /***********************************************************************
  *		wayland_wglDescribePixelFormat
  */
@@ -531,6 +631,8 @@ static BOOL egl_init(void)
         if (!(p_##func = dlsym(egl_handle, #func))) \
         { ERR("can't find symbol %s\n", #func); return FALSE; }    \
     } while(0)
+    LOAD_FUNCPTR(eglCreateWindowSurface);
+    LOAD_FUNCPTR(eglDestroySurface);
     LOAD_FUNCPTR(eglGetConfigAttrib);
     LOAD_FUNCPTR(eglGetConfigs);
     LOAD_FUNCPTR(eglGetDisplay);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index e417139f829..a8db536d3a4 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -347,6 +347,8 @@ void wayland_surface_reconfigure_glvk(struct wayland_surface *surface, int x, in
                                       int width, int height);
 void wayland_surface_unmap(struct wayland_surface *surface);
 void wayland_surface_ack_pending_configure(struct wayland_surface *surface);
+struct wayland_surface *wayland_surface_for_hwnd_lock(HWND hwnd);
+void wayland_surface_for_hwnd_unlock(struct wayland_surface *surface);
 void wayland_surface_coords_to_screen(struct wayland_surface *surface,
                                       double wayland_x, double wayland_y,
                                       int *screen_x, int *screen_y);
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index cadcfcbc531..ed232ee4231 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -179,7 +179,7 @@ static struct wayland_win_data *wayland_win_data_create(HWND hwnd)
  *
  *  Gets the wayland surface for HWND while locking the private window data.
  */
-static struct wayland_surface *wayland_surface_for_hwnd_lock(HWND hwnd)
+struct wayland_surface *wayland_surface_for_hwnd_lock(HWND hwnd)
 {
     struct wayland_win_data *data = wayland_win_data_get(hwnd);
 
@@ -194,7 +194,7 @@ static struct wayland_surface *wayland_surface_for_hwnd_lock(HWND hwnd)
 /***********************************************************************
  *           wayland_surface_for_hwnd_unlock
  */
-static void wayland_surface_for_hwnd_unlock(struct wayland_surface *surface)
+void wayland_surface_for_hwnd_unlock(struct wayland_surface *surface)
 {
     if (surface) LeaveCriticalSection(&win_data_section);
 }
-- 
2.34.1


From bf46c23357d6c849f54f1bdeec4507afea3c2247 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 13:20:22 +0300
Subject: [PATCH 078/147] winewayland.drv: Implement wglSetPixelFormat(WINE).

This is the call which signals that a window requires GL rendering, thus
kickstarting the creation (or update) of a wayland_gl_drawable to
manage GL content.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 74 +++++++++++++++++++++++++++++++++++
 1 file changed, 74 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 17fb3060307..e4b7491d71b 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -168,6 +168,55 @@ out:
     RedrawWindow(gl->hwnd, NULL, 0, RDW_INVALIDATE | RDW_ERASE);
 }
 
+static BOOL set_pixel_format(HDC hdc, int format, BOOL allow_change)
+{
+    struct wayland_gl_drawable *gl;
+    HWND hwnd = WindowFromDC(hdc);
+    int prev = 0;
+
+    if (!hwnd || hwnd == GetDesktopWindow())
+    {
+        WARN("not a proper window DC %p/%p\n", hdc, hwnd);
+        return FALSE;
+    }
+    if (!is_onscreen_pixel_format(format))
+    {
+        WARN("Invalid format %d\n", format);
+        return FALSE;
+    }
+    TRACE("%p/%p format %d\n", hdc, hwnd, format);
+
+    if ((gl = wayland_gl_drawable_get(hwnd)))
+    {
+        prev = gl->format;
+        /* If we are changing formats, destroy any existing EGL surface so that
+         * it can be recreated by wayland_gl_drawable_update. */
+        if (allow_change && gl->format != format)
+        {
+            gl->format = format;
+            if (gl->surface)
+            {
+                p_eglDestroySurface(egl_display, gl->surface);
+                gl->surface = EGL_NO_SURFACE;
+            }
+        }
+    }
+    else
+    {
+        gl = wayland_gl_drawable_create(hwnd, format);
+    }
+
+    if (gl) wayland_gl_drawable_update(gl);
+
+    wayland_gl_drawable_release(gl);
+
+    if (prev && prev != format && !allow_change) return FALSE;
+    if (__wine_set_pixel_format(hwnd, format)) return TRUE;
+
+    wayland_destroy_gl_drawable(hwnd);
+    return FALSE;
+}
+
 /***********************************************************************
  *		wayland_wglDescribePixelFormat
  */
@@ -228,6 +277,23 @@ static PROC WINAPI wayland_wglGetProcAddress(LPCSTR name)
     return ret;
 }
 
+/***********************************************************************
+ *		wayland_wglSetPixelFormat
+ */
+static BOOL WINAPI wayland_wglSetPixelFormat(HDC hdc, int format,
+                                             const PIXELFORMATDESCRIPTOR *pfd)
+{
+    return set_pixel_format(hdc, format, FALSE);
+}
+
+/***********************************************************************
+ *		wayland_wglSetPixelFormatWINE
+ */
+static BOOL wayland_wglSetPixelFormatWINE(HDC hdc, int format)
+{
+    return set_pixel_format(hdc, format, TRUE);
+}
+
 /***********************************************************************
  *		wayland_wglGetExtensionsStringARB
  */
@@ -263,6 +329,13 @@ static void init_extensions(void)
     register_extension("WGL_EXT_extensions_string");
     egl_funcs.ext.p_wglGetExtensionsStringEXT = wayland_wglGetExtensionsStringEXT;
 
+    /* In WineD3D we need the ability to set the pixel format more than once
+     * (e.g. after a device reset).  The default wglSetPixelFormat doesn't
+     * allow this, so add our own which allows it.
+     */
+    register_extension("WGL_WINE_pixel_format_passthrough");
+    egl_funcs.ext.p_wglSetPixelFormatWINE = wayland_wglSetPixelFormatWINE;
+
     /* load standard functions and extensions exported from the OpenGL library */
 
 #define USE_GL_FUNC(func) if ((ptr = dlsym(opengl_handle, #func))) egl_funcs.gl.p_##func = ptr;
@@ -670,6 +743,7 @@ static struct opengl_funcs egl_funcs =
     {
         .p_wglDescribePixelFormat = wayland_wglDescribePixelFormat,
         .p_wglGetProcAddress = wayland_wglGetProcAddress,
+        .p_wglSetPixelFormat = wayland_wglSetPixelFormat,
     },
 #define USE_GL_FUNC(name) (void *)glstub_##name,
     .gl = { ALL_WGL_FUNCS }
-- 
2.34.1


From 02083383656afca3c699b9c3306980402f15d454 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 13:44:37 +0300
Subject: [PATCH 079/147] winewayland.drv: Implement GL context creation.

Each WGL context is backed by an EGL context.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 87 +++++++++++++++++++++++++++++++++++
 1 file changed, 87 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index e4b7491d71b..5e7bf539230 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -58,6 +58,15 @@ struct wayland_gl_drawable
     EGLSurface      surface;
 };
 
+struct wgl_context
+{
+    struct wl_list link;
+    EGLConfig  config;
+    EGLContext context;
+    HWND       draw_hwnd;
+    HWND       read_hwnd;
+};
+
 static void *egl_handle;
 static void *opengl_handle;
 static EGLDisplay egl_display;
@@ -67,6 +76,7 @@ static struct wgl_pixel_format *pixel_formats;
 static int nb_pixel_formats, nb_onscreen_formats;
 
 static struct wl_list gl_drawables = { &gl_drawables, &gl_drawables };
+static struct wl_list gl_contexts = { &gl_contexts, &gl_contexts };
 
 /* Protects drawables and contexts. */
 static CRITICAL_SECTION drawable_section;
@@ -79,7 +89,10 @@ static CRITICAL_SECTION_DEBUG critsect_debug =
 static CRITICAL_SECTION drawable_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
 #define DECL_FUNCPTR(f) static __typeof__(f) * p_##f = NULL
+DECL_FUNCPTR(eglBindAPI);
+DECL_FUNCPTR(eglCreateContext);
 DECL_FUNCPTR(eglCreateWindowSurface);
+DECL_FUNCPTR(eglDestroyContext);
 DECL_FUNCPTR(eglDestroySurface);
 DECL_FUNCPTR(eglGetConfigAttrib);
 DECL_FUNCPTR(eglGetConfigs);
@@ -217,6 +230,74 @@ static BOOL set_pixel_format(HDC hdc, int format, BOOL allow_change)
     return FALSE;
 }
 
+static struct wgl_context *create_context(HDC hdc)
+{
+    struct wayland_gl_drawable *gl;
+    struct wgl_context *ctx;
+
+    if (!(gl = wayland_gl_drawable_get(WindowFromDC(hdc)))) return NULL;
+
+    ctx = heap_alloc(sizeof(*ctx));
+    if (!ctx)
+    {
+        ERR("Failed to allocate memory for GL context\n");
+        goto out;
+    }
+
+    ctx->config  = pixel_formats[gl->format - 1].config;
+    ctx->context = p_eglCreateContext(egl_display, ctx->config,
+                                      EGL_NO_CONTEXT,
+                                      NULL);
+    ctx->draw_hwnd = 0;
+    ctx->read_hwnd = 0;
+
+    /* The drawable critical section also guards access to gl_contexts, so it's
+     * safe to add the entry here. */
+    wl_list_insert(&gl_contexts, &ctx->link);
+
+out:
+    wayland_gl_drawable_release(gl);
+
+    TRACE("ctx=%p hdc=%p fmt=%d egl_ctx=%p\n",
+          ctx, hdc, gl->format, ctx ? ctx->context : NULL);
+
+    return ctx;
+}
+
+/***********************************************************************
+ *		wayland_wglCopyContext
+ */
+static BOOL WINAPI wayland_wglCopyContext(struct wgl_context *src,
+                                          struct wgl_context *dst, UINT mask)
+{
+    FIXME("%p -> %p mask %#x unsupported\n", src, dst, mask);
+    return FALSE;
+}
+
+/***********************************************************************
+ *		wayland_wglCreateContext
+ */
+static struct wgl_context * WINAPI wayland_wglCreateContext(HDC hdc)
+{
+    TRACE("hdc=%p\n", hdc);
+
+    p_eglBindAPI(EGL_OPENGL_API);
+
+    return create_context(hdc);
+}
+
+/***********************************************************************
+ *		wayland_wglDeleteContext
+ */
+static BOOL WINAPI wayland_wglDeleteContext(struct wgl_context *ctx)
+{
+    EnterCriticalSection(&drawable_section);
+    wl_list_remove(&ctx->link);
+    LeaveCriticalSection(&drawable_section);
+    p_eglDestroyContext(egl_display, ctx->context);
+    return HeapFree(GetProcessHeap(), 0, ctx);
+}
+
 /***********************************************************************
  *		wayland_wglDescribePixelFormat
  */
@@ -704,7 +785,10 @@ static BOOL egl_init(void)
         if (!(p_##func = dlsym(egl_handle, #func))) \
         { ERR("can't find symbol %s\n", #func); return FALSE; }    \
     } while(0)
+    LOAD_FUNCPTR(eglBindAPI);
+    LOAD_FUNCPTR(eglCreateContext);
     LOAD_FUNCPTR(eglCreateWindowSurface);
+    LOAD_FUNCPTR(eglDestroyContext);
     LOAD_FUNCPTR(eglDestroySurface);
     LOAD_FUNCPTR(eglGetConfigAttrib);
     LOAD_FUNCPTR(eglGetConfigs);
@@ -741,6 +825,9 @@ static struct opengl_funcs egl_funcs =
 {
     .wgl =
     {
+        .p_wglCopyContext = wayland_wglCopyContext,
+        .p_wglCreateContext = wayland_wglCreateContext,
+        .p_wglDeleteContext = wayland_wglDeleteContext,
         .p_wglDescribePixelFormat = wayland_wglDescribePixelFormat,
         .p_wglGetProcAddress = wayland_wglGetProcAddress,
         .p_wglSetPixelFormat = wayland_wglSetPixelFormat,
-- 
2.34.1


From f7bf12aba9cbfa98e211bfe6787a48aeb55dffcd Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 14:34:46 +0300
Subject: [PATCH 080/147] winewayland.drv: Implement wglMakeCurrent and
 wglMakeContextCurrentARB.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 82 +++++++++++++++++++++++++++++++++++
 1 file changed, 82 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 5e7bf539230..fea99664c4b 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -37,6 +37,7 @@
 #include "wine/heap.h"
 
 #include "winuser.h"
+#include "winternl.h"
 
 #include <EGL/egl.h>
 #include <assert.h>
@@ -99,6 +100,7 @@ DECL_FUNCPTR(eglGetConfigs);
 DECL_FUNCPTR(eglGetDisplay);
 DECL_FUNCPTR(eglGetProcAddress);
 DECL_FUNCPTR(eglInitialize);
+DECL_FUNCPTR(eglMakeCurrent);
 #undef DECL_FUNCPTR
 
 static inline BOOL is_onscreen_pixel_format(int format)
@@ -168,6 +170,36 @@ static void wayland_gl_drawable_release(struct wayland_gl_drawable *gl)
     if (gl) LeaveCriticalSection(&drawable_section);
 }
 
+static BOOL wgl_context_make_current(struct wgl_context *ctx, HWND draw_hwnd, HWND read_hwnd)
+{
+    BOOL ret;
+    struct wayland_gl_drawable *draw_gl = NULL, *read_gl = NULL;
+
+    draw_gl = wayland_gl_drawable_get(draw_hwnd);
+    read_gl = wayland_gl_drawable_get(read_hwnd);
+
+    TRACE("%p/%p context %p surface %p/%p\n",
+          draw_hwnd, read_hwnd, ctx->context,
+          draw_gl ? draw_gl->surface : NULL,
+          read_gl ? read_gl->surface : NULL);
+
+    ret = p_eglMakeCurrent(egl_display,
+                           draw_gl ? draw_gl->surface : NULL,
+                           read_gl ? read_gl->surface : NULL,
+                           ctx->context);
+    if (ret)
+    {
+        ctx->draw_hwnd = draw_hwnd;
+        ctx->read_hwnd = read_hwnd;
+        NtCurrentTeb()->glContext = ctx;
+    }
+
+    wayland_gl_drawable_release(read_gl);
+    wayland_gl_drawable_release(draw_gl);
+
+    return ret;
+}
+
 static void wayland_gl_drawable_update(struct wayland_gl_drawable *gl)
 {
     TRACE("hwnd=%p\n", gl->hwnd);
@@ -176,6 +208,19 @@ static void wayland_gl_drawable_update(struct wayland_gl_drawable *gl)
 
     gl->surface = p_eglCreateWindowSurface(egl_display, pixel_formats[gl->format - 1].config,
                                            gl->wayland_surface->glvk->wl_egl_window, NULL);
+    if (gl->surface)
+    {
+        struct wgl_context *ctx;
+
+        wl_list_for_each(ctx, &gl_contexts, link)
+        {
+            if (ctx->draw_hwnd != gl->hwnd && ctx->read_hwnd != gl->hwnd) continue;
+            TRACE("hwnd %p refreshing %p %scurrent\n",
+                  gl->hwnd, ctx, NtCurrentTeb()->glContext == ctx ? "" : "not ");
+            if (NtCurrentTeb()->glContext == ctx)
+                wgl_context_make_current(ctx, ctx->draw_hwnd, ctx->read_hwnd);
+        }
+    }
 
 out:
     RedrawWindow(gl->hwnd, NULL, 0, RDW_INVALIDATE | RDW_ERASE);
@@ -298,6 +343,37 @@ static BOOL WINAPI wayland_wglDeleteContext(struct wgl_context *ctx)
     return HeapFree(GetProcessHeap(), 0, ctx);
 }
 
+/***********************************************************************
+ *		wayland_wglMakeContextCurrentARB
+ */
+static BOOL wayland_wglMakeContextCurrentARB(HDC draw_hdc, HDC read_hdc,
+                                             struct wgl_context *ctx)
+{
+    BOOL ret = FALSE;
+
+    TRACE("draw_hdc=%p read_hdc=%p ctx=%p\n", draw_hdc, read_hdc, ctx);
+
+    if (!ctx)
+    {
+        p_eglMakeCurrent(egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+        NtCurrentTeb()->glContext = NULL;
+        return TRUE;
+    }
+
+    ret = wgl_context_make_current(ctx, WindowFromDC(draw_hdc), WindowFromDC(read_hdc));
+    if (!ret) SetLastError(ERROR_INVALID_HANDLE);
+
+    return ret;
+}
+
+/***********************************************************************
+ *		wayland_wglMakeCurrent
+ */
+static BOOL WINAPI wayland_wglMakeCurrent(HDC hdc, struct wgl_context *ctx)
+{
+    return wayland_wglMakeContextCurrentARB(hdc, hdc, ctx);
+}
+
 /***********************************************************************
  *		wayland_wglDescribePixelFormat
  */
@@ -417,6 +493,10 @@ static void init_extensions(void)
     register_extension("WGL_WINE_pixel_format_passthrough");
     egl_funcs.ext.p_wglSetPixelFormatWINE = wayland_wglSetPixelFormatWINE;
 
+    register_extension("WGL_ARB_make_current_read");
+    egl_funcs.ext.p_wglGetCurrentReadDCARB   = (void *)1;  /* never called */
+    egl_funcs.ext.p_wglMakeContextCurrentARB = wayland_wglMakeContextCurrentARB;
+
     /* load standard functions and extensions exported from the OpenGL library */
 
 #define USE_GL_FUNC(func) if ((ptr = dlsym(opengl_handle, #func))) egl_funcs.gl.p_##func = ptr;
@@ -795,6 +875,7 @@ static BOOL egl_init(void)
     LOAD_FUNCPTR(eglGetDisplay);
     LOAD_FUNCPTR(eglGetProcAddress);
     LOAD_FUNCPTR(eglInitialize);
+    LOAD_FUNCPTR(eglMakeCurrent);
 #undef LOAD_FUNCPTR
 
     egl_display = p_eglGetDisplay((EGLNativeDisplayType) process_wl_display);
@@ -830,6 +911,7 @@ static struct opengl_funcs egl_funcs =
         .p_wglDeleteContext = wayland_wglDeleteContext,
         .p_wglDescribePixelFormat = wayland_wglDescribePixelFormat,
         .p_wglGetProcAddress = wayland_wglGetProcAddress,
+        .p_wglMakeCurrent = wayland_wglMakeCurrent,
         .p_wglSetPixelFormat = wayland_wglSetPixelFormat,
     },
 #define USE_GL_FUNC(name) (void *)glstub_##name,
-- 
2.34.1


From ecf7cd92f172c425b53685a32c4f698ad57c5544 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 14:46:40 +0300
Subject: [PATCH 081/147] winewayland.drv: Implement wglGetPixelFormat.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 19 +++++++++++++++++++
 1 file changed, 19 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index fea99664c4b..07c6ab51b16 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -422,6 +422,24 @@ static int WINAPI wayland_wglDescribePixelFormat(HDC hdc, int fmt, UINT size,
     return nb_onscreen_formats;
 }
 
+/***********************************************************************
+ *		wayland_wglGetPixelFormat
+ */
+static int WINAPI wayland_wglGetPixelFormat(HDC hdc)
+{
+    struct wayland_gl_drawable *gl;
+    int ret = 0;
+
+    if ((gl = wayland_gl_drawable_get(WindowFromDC(hdc))))
+    {
+        ret = gl->format;
+        /* offscreen formats can't be used with traditional WGL calls */
+        if (!is_onscreen_pixel_format(ret)) ret = 1;
+        wayland_gl_drawable_release(gl);
+    }
+    return ret;
+}
+
 /***********************************************************************
  *		wayland_wglGetProcAddress
  */
@@ -910,6 +928,7 @@ static struct opengl_funcs egl_funcs =
         .p_wglCreateContext = wayland_wglCreateContext,
         .p_wglDeleteContext = wayland_wglDeleteContext,
         .p_wglDescribePixelFormat = wayland_wglDescribePixelFormat,
+        .p_wglGetPixelFormat = wayland_wglGetPixelFormat,
         .p_wglGetProcAddress = wayland_wglGetProcAddress,
         .p_wglMakeCurrent = wayland_wglMakeCurrent,
         .p_wglSetPixelFormat = wayland_wglSetPixelFormat,
-- 
2.34.1


From 02d89ea49d6f3c27f8a4d76c4876526a47dd272a Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 14:56:36 +0300
Subject: [PATCH 082/147] winewayland.drv: Implement
 wglCreateContextAttribsARB.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 142 +++++++++++++++++++++++++++++++++-
 1 file changed, 138 insertions(+), 4 deletions(-)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 07c6ab51b16..b9f27c0f2ba 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -66,6 +66,7 @@ struct wgl_context
     EGLContext context;
     HWND       draw_hwnd;
     HWND       read_hwnd;
+    int        *attribs;
 };
 
 static void *egl_handle;
@@ -275,7 +276,66 @@ static BOOL set_pixel_format(HDC hdc, int format, BOOL allow_change)
     return FALSE;
 }
 
-static struct wgl_context *create_context(HDC hdc)
+struct egl_attribs
+{
+    EGLint *data;
+    int count;
+};
+
+static void egl_attribs_init(struct egl_attribs *attribs)
+{
+    attribs->data = NULL;
+    attribs->count = 0;
+}
+
+static void egl_attribs_add(struct egl_attribs *attribs, EGLint name, EGLint value)
+{
+    EGLint *new_data = heap_realloc(attribs->data,
+                                    sizeof(*attribs->data) * (attribs->count + 2));
+    if (!new_data)
+    {
+        ERR("Could not allocate memory for EGL attributes!\n");
+        return;
+    }
+
+    attribs->data = new_data;
+    attribs->data[attribs->count] = name;
+    attribs->data[attribs->count + 1] = value;
+    attribs->count += 2;
+}
+
+static EGLint *egl_attribs_steal_finished_data(struct egl_attribs *attribs)
+{
+    EGLint *data = NULL;
+
+    if (attribs->data)
+    {
+        data = heap_realloc(attribs->data,
+                            sizeof(*attribs->data) * (attribs->count + 1));
+        if (!data)
+        {
+            ERR("Could not allocate memory for EGL attributes!\n");
+        }
+        else
+        {
+            data[attribs->count] = EGL_NONE;
+            attribs->data = NULL;
+            attribs->count = 0;
+        }
+    }
+
+    return data;
+}
+
+static void egl_attribs_deinit(struct egl_attribs *attribs)
+{
+    heap_free(attribs->data);
+    attribs->data = NULL;
+    attribs->count = 0;
+}
+
+static struct wgl_context *create_context(HDC hdc, struct wgl_context *share,
+                                          struct egl_attribs *attribs)
 {
     struct wayland_gl_drawable *gl;
     struct wgl_context *ctx;
@@ -290,9 +350,10 @@ static struct wgl_context *create_context(HDC hdc)
     }
 
     ctx->config  = pixel_formats[gl->format - 1].config;
+    ctx->attribs = attribs ? egl_attribs_steal_finished_data(attribs) : NULL;
     ctx->context = p_eglCreateContext(egl_display, ctx->config,
-                                      EGL_NO_CONTEXT,
-                                      NULL);
+                                      share ? share->context : EGL_NO_CONTEXT,
+                                      ctx->attribs);
     ctx->draw_hwnd = 0;
     ctx->read_hwnd = 0;
 
@@ -328,7 +389,75 @@ static struct wgl_context * WINAPI wayland_wglCreateContext(HDC hdc)
 
     p_eglBindAPI(EGL_OPENGL_API);
 
-    return create_context(hdc);
+    return create_context(hdc, NULL, NULL);
+}
+
+/***********************************************************************
+ *		wayland_wglCreateContextAttribsARB
+ */
+static struct wgl_context *wayland_wglCreateContextAttribsARB(HDC hdc,
+                                                              struct wgl_context *share,
+                                                              const int *attribs)
+{
+    struct egl_attribs egl_attribs = {0};
+    EGLenum api_type = EGL_OPENGL_API;
+    EGLenum profile_mask;
+    struct wgl_context *ctx;
+
+    egl_attribs_init(&egl_attribs);
+
+    TRACE("hdc=%p share=%p attribs=%p\n", hdc, share, attribs);
+
+    while (attribs && *attribs)
+    {
+        TRACE("%#x %#x\n", attribs[0], attribs[1]);
+        switch (*attribs)
+        {
+        case WGL_CONTEXT_PROFILE_MASK_ARB:
+            profile_mask = 0;
+            if (attribs[1] & WGL_CONTEXT_ES2_PROFILE_BIT_EXT)
+                api_type = EGL_OPENGL_ES_API;
+            if (attribs[1] & WGL_CONTEXT_CORE_PROFILE_BIT_ARB)
+                profile_mask |= EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT;
+            if (attribs[1] & WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB)
+                profile_mask |= EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT;
+            /* If the WGL profile mask doesn't have ES2 as the only set bit,
+             * pass the mask to EGL. Note that this will also pass empty
+             * WGL masks, in order to elicit the respective EGL error. */
+            if (attribs[1] != WGL_CONTEXT_ES2_PROFILE_BIT_EXT)
+            {
+                egl_attribs_add(&egl_attribs,
+                                EGL_CONTEXT_OPENGL_PROFILE_MASK, profile_mask);
+            }
+            break;
+        case WGL_CONTEXT_MAJOR_VERSION_ARB:
+            egl_attribs_add(&egl_attribs, EGL_CONTEXT_MAJOR_VERSION, attribs[1]);
+            break;
+        case WGL_CONTEXT_MINOR_VERSION_ARB:
+            egl_attribs_add(&egl_attribs, EGL_CONTEXT_MINOR_VERSION, attribs[1]);
+            break;
+        case WGL_CONTEXT_FLAGS_ARB:
+            egl_attribs_add(&egl_attribs, EGL_CONTEXT_OPENGL_DEBUG,
+                            (attribs[1] & WGL_CONTEXT_DEBUG_BIT_ARB) ?
+                                EGL_TRUE : EGL_FALSE);
+            egl_attribs_add(&egl_attribs,
+                            EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE,
+                            (attribs[1] & WGL_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB) ?
+                                EGL_TRUE : EGL_FALSE);
+            break;
+        default:
+            FIXME("Unhandled attributes: %#x %#x\n", attribs[0], attribs[1]);
+        }
+        attribs += 2;
+    }
+
+    p_eglBindAPI(api_type);
+
+    ctx = create_context(hdc, share, &egl_attribs);
+
+    egl_attribs_deinit(&egl_attribs);
+
+    return ctx;
 }
 
 /***********************************************************************
@@ -340,6 +469,7 @@ static BOOL WINAPI wayland_wglDeleteContext(struct wgl_context *ctx)
     wl_list_remove(&ctx->link);
     LeaveCriticalSection(&drawable_section);
     p_eglDestroyContext(egl_display, ctx->context);
+    heap_free(ctx->attribs);
     return HeapFree(GetProcessHeap(), 0, ctx);
 }
 
@@ -515,6 +645,10 @@ static void init_extensions(void)
     egl_funcs.ext.p_wglGetCurrentReadDCARB   = (void *)1;  /* never called */
     egl_funcs.ext.p_wglMakeContextCurrentARB = wayland_wglMakeContextCurrentARB;
 
+    register_extension("WGL_ARB_create_context");
+    register_extension("WGL_ARB_create_context_profile");
+    egl_funcs.ext.p_wglCreateContextAttribsARB = wayland_wglCreateContextAttribsARB;
+
     /* load standard functions and extensions exported from the OpenGL library */
 
 #define USE_GL_FUNC(func) if ((ptr = dlsym(opengl_handle, #func))) egl_funcs.gl.p_##func = ptr;
-- 
2.34.1


From fb61edf7443c691e35559ed7a7b82a021932231f Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 14:57:55 +0300
Subject: [PATCH 083/147] winewayland.drv: Implement wglShareLists.

Sharing of display lists works differently in EGL and WGL. In case of
EGL it is done at context creation time but in case of EGL it can also
be done using wglShareLists.

We handle this by creating an EGL context in wglCreateContext /
wglCreateContextAttribsARB and when a program requests sharing we
recreate the destination context if it hasn't been made current and it
hasn't shared display lists before.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 51 +++++++++++++++++++++++++++++++++++
 1 file changed, 51 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index b9f27c0f2ba..7304557f7fa 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -66,6 +66,8 @@ struct wgl_context
     EGLContext context;
     HWND       draw_hwnd;
     HWND       read_hwnd;
+    BOOL       has_been_current;
+    BOOL       sharing;
     int        *attribs;
 };
 
@@ -192,6 +194,7 @@ static BOOL wgl_context_make_current(struct wgl_context *ctx, HWND draw_hwnd, HW
     {
         ctx->draw_hwnd = draw_hwnd;
         ctx->read_hwnd = read_hwnd;
+        ctx->has_been_current = TRUE;
         NtCurrentTeb()->glContext = ctx;
     }
 
@@ -356,6 +359,8 @@ static struct wgl_context *create_context(HDC hdc, struct wgl_context *share,
                                       ctx->attribs);
     ctx->draw_hwnd = 0;
     ctx->read_hwnd = 0;
+    ctx->has_been_current = FALSE;
+    ctx->sharing = FALSE;
 
     /* The drawable critical section also guards access to gl_contexts, so it's
      * safe to add the entry here. */
@@ -599,6 +604,51 @@ static BOOL wayland_wglSetPixelFormatWINE(HDC hdc, int format)
     return set_pixel_format(hdc, format, TRUE);
 }
 
+/***********************************************************************
+ *		wayland_wglShareLists
+ */
+static BOOL WINAPI wayland_wglShareLists(struct wgl_context *org,
+                                         struct wgl_context *dest)
+{
+    TRACE("(%p, %p)\n", org, dest);
+
+    /* Sharing of display lists works differently in EGL and WGL. In case of
+     * EGL it is done at context creation time but in case of EGL it can also
+     * be done using wglShareLists.
+     *
+     * We handle this by creating an EGL context in wglCreateContext /
+     * wglCreateContextAttribsARB and when a program requests sharing we
+     * recreate the destination context if it hasn't been made current and
+     * it hasn't shared display lists before.
+     */
+
+    if (dest->has_been_current)
+    {
+        ERR("Could not share display lists, the hglrc2 context has been current already!\n");
+        return FALSE;
+    }
+    else if (dest->sharing)
+    {
+        ERR("Could not share display lists because hglrc2 has already shared lists before!\n");
+        return FALSE;
+    }
+    else
+    {
+        /* Re-create the EGL context and share display lists */
+        p_eglDestroyContext(egl_display, dest->context);
+        dest->context = p_eglCreateContext(egl_display, dest->config,
+                                           org->context, dest->attribs);
+        TRACE("re-created EGL context (%p) for WGL context %p (config: %p) "
+              "sharing lists with EGL context %p for WGL context %p (config: %p)\n",
+              dest->context, dest, dest->config, org->context, org, org->config);
+        org->sharing = TRUE;
+        dest->sharing = TRUE;
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
 /***********************************************************************
  *		wayland_wglGetExtensionsStringARB
  */
@@ -1066,6 +1116,7 @@ static struct opengl_funcs egl_funcs =
         .p_wglGetProcAddress = wayland_wglGetProcAddress,
         .p_wglMakeCurrent = wayland_wglMakeCurrent,
         .p_wglSetPixelFormat = wayland_wglSetPixelFormat,
+        .p_wglShareLists = wayland_wglShareLists,
     },
 #define USE_GL_FUNC(name) (void *)glstub_##name,
     .gl = { ALL_WGL_FUNCS }
-- 
2.34.1


From 5a36b82af8e5efc727660d40c5e6d8693a71d284 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 15:25:18 +0300
Subject: [PATCH 084/147] winewayland.drv: Add function to ensure a Wayland
 surface is mapped.

The contents of GL or Vulkan windows are rendered on subsurfaces with
the parent surface used for the decorations. Such GL/VK subsurfaces may
want to commit their contents before the parent surface has had a chance
to commit. In such cases the GL/VK commit will not be displayed, but,
more importantly, will not get a frame callback until the parent surface
is also committed. Depending on the presentation mode, a second GL/VK
buffer swap may indefinitely block waiting on the frame callback. By
calling this function before a GL/VK buffer swap we can avoid this
situation.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 77 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  1 +
 2 files changed, 78 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 084ef6834dc..54c92277c1f 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -1116,6 +1116,83 @@ void wayland_surface_find_wine_fullscreen_fit(struct wayland_surface *surface,
                                    wine_width, wine_height);
 }
 
+static void dummy_buffer_release(void *data, struct wl_buffer *buffer)
+{
+    struct wayland_shm_buffer *shm_buffer = data;
+
+    TRACE("shm_buffer=%p\n", shm_buffer);
+
+    wayland_shm_buffer_destroy(shm_buffer);
+}
+
+static const struct wl_buffer_listener dummy_buffer_listener = {
+    dummy_buffer_release
+};
+
+/**********************************************************************
+ *          wayland_surface_ensure_mapped
+ *
+ * Ensure that the wayland surface is mapped, by committing a dummy
+ * buffer if necessary.
+ *
+ * The contents of GL or Vulkan windows are rendered on subsurfaces
+ * with the parent surface used for the decorations. Such GL/VK
+ * subsurfaces may want to commit their contents before the parent
+ * surface has had a chance to commit. In such cases the GL/VK commit
+ * will not be displayed, but, more importantly, will not get a frame
+ * callback until the parent surface is also committed. Depending on
+ * the presentation mode, a second GL/VK buffer swap may indefinitely
+ * block waiting on the frame callback. By calling this function before a
+ * GL/VK buffer swap we can avoid this situation.
+ */
+void wayland_surface_ensure_mapped(struct wayland_surface *surface)
+{
+    EnterCriticalSection(&surface->crit);
+
+    TRACE("surface=%p hwnd=%p mapped=%d\n",
+          surface, surface->hwnd, surface->mapped);
+
+    if (!surface->mapped)
+    {
+        int width = surface->current.width;
+        int height = surface->current.height;
+        int flags = surface->current.configure_flags;
+        int wine_width, wine_height;
+        struct wayland_shm_buffer *dummy_shm_buffer;
+        HRGN damage;
+
+        /* Use a large enough width/height, so even when the target
+         * surface is scaled by the compositor, this will not end up
+         * being 0x0. */
+        if (width == 0) width = 32;
+        if (height == 0) height = 32;
+
+        if ((flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN) &&
+            !(flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
+        {
+            wayland_surface_find_wine_fullscreen_fit(surface, width, height,
+                                                     &wine_width, &wine_height);
+        }
+        else
+        {
+            wayland_surface_coords_to_wine(surface, width, height,
+                                           &wine_width, &wine_height);
+        }
+
+        dummy_shm_buffer = wayland_shm_buffer_create(surface->wayland,
+                                                     wine_width, wine_height,
+                                                     WL_SHM_FORMAT_ARGB8888);
+        wl_buffer_add_listener(dummy_shm_buffer->wl_buffer,
+                               &dummy_buffer_listener, dummy_shm_buffer);
+
+        damage = CreateRectRgn(0, 0, wine_width, wine_height);
+        wayland_surface_commit_buffer(surface, dummy_shm_buffer, damage);
+        DeleteObject(damage);
+    }
+
+    LeaveCriticalSection(&surface->crit);
+}
+
 /**********************************************************************
  *          wayland_surface_ref
  *
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index a8db536d3a4..5b989181907 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -364,6 +364,7 @@ void wayland_surface_coords_to_wine(struct wayland_surface *surface,
 void wayland_surface_find_wine_fullscreen_fit(struct wayland_surface *surface,
                                               int wayland_width, int wayland_height,
                                               int *wine_width, int *wine_height);
+void wayland_surface_ensure_mapped(struct wayland_surface *surface);
 struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface);
 void wayland_surface_unref(struct wayland_surface *surface);
 void wayland_surface_leave_output(struct wayland_surface *surface,
-- 
2.34.1


From 5a0f953210b8cab385bd4b3fa806fb595999a79c Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 15:26:32 +0300
Subject: [PATCH 085/147] winewayland.drv: Implement wglSwapBuffers.

Before swapping we check that the target Wayland surface allows drawing,
to avoid commits with incorrectly sized buffers during reconfigurations.
We also ensure that the parent (decoration) Wayland surface is mapped to
avoid blocking.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 59 +++++++++++++++++++++++++++++++++++
 1 file changed, 59 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 7304557f7fa..53dfc794d1d 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -66,6 +66,7 @@ struct wgl_context
     EGLContext context;
     HWND       draw_hwnd;
     HWND       read_hwnd;
+    BOOL       refresh;
     BOOL       has_been_current;
     BOOL       sharing;
     int        *attribs;
@@ -104,6 +105,7 @@ DECL_FUNCPTR(eglGetDisplay);
 DECL_FUNCPTR(eglGetProcAddress);
 DECL_FUNCPTR(eglInitialize);
 DECL_FUNCPTR(eglMakeCurrent);
+DECL_FUNCPTR(eglSwapBuffers);
 #undef DECL_FUNCPTR
 
 static inline BOOL is_onscreen_pixel_format(int format)
@@ -194,6 +196,7 @@ static BOOL wgl_context_make_current(struct wgl_context *ctx, HWND draw_hwnd, HW
     {
         ctx->draw_hwnd = draw_hwnd;
         ctx->read_hwnd = read_hwnd;
+        InterlockedExchange(&ctx->refresh, FALSE);
         ctx->has_been_current = TRUE;
         NtCurrentTeb()->glContext = ctx;
     }
@@ -223,6 +226,8 @@ static void wayland_gl_drawable_update(struct wayland_gl_drawable *gl)
                   gl->hwnd, ctx, NtCurrentTeb()->glContext == ctx ? "" : "not ");
             if (NtCurrentTeb()->glContext == ctx)
                 wgl_context_make_current(ctx, ctx->draw_hwnd, ctx->read_hwnd);
+            else
+                InterlockedExchange(&ctx->refresh, TRUE);
         }
     }
 
@@ -359,6 +364,7 @@ static struct wgl_context *create_context(HDC hdc, struct wgl_context *share,
                                       ctx->attribs);
     ctx->draw_hwnd = 0;
     ctx->read_hwnd = 0;
+    ctx->refresh = FALSE;
     ctx->has_been_current = FALSE;
     ctx->sharing = FALSE;
 
@@ -649,6 +655,57 @@ static BOOL WINAPI wayland_wglShareLists(struct wgl_context *org,
     return FALSE;
 }
 
+static BOOL wgl_context_refresh(struct wgl_context *ctx)
+{
+    BOOL ret = InterlockedExchange(&ctx->refresh, FALSE);
+
+    if (ret)
+    {
+        TRACE("refreshing context %p hwnd %p/%p\n",
+              ctx->context, ctx->draw_hwnd, ctx->read_hwnd);
+        wgl_context_make_current(ctx, ctx->draw_hwnd, ctx->read_hwnd);
+        RedrawWindow(ctx->draw_hwnd, NULL, 0, RDW_INVALIDATE | RDW_ERASE);
+    }
+    return ret;
+}
+
+/***********************************************************************
+ *		wayland_wglSwapBuffers
+ */
+static BOOL WINAPI wayland_wglSwapBuffers(HDC hdc)
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+    HWND hwnd = WindowFromDC(hdc);
+    struct wayland_gl_drawable *draw_gl;
+
+    TRACE("hdc %p hwnd %p ctx %p\n", hdc, hwnd, ctx);
+
+    if (ctx && wgl_context_refresh(ctx)) return TRUE;
+
+    draw_gl = wayland_gl_drawable_get(hwnd);
+    if (draw_gl && draw_gl->surface)
+    {
+        BOOL drawing_allowed = TRUE;
+        if (draw_gl->wayland_surface)
+        {
+            /* Lock the surface to ensure we don't swap buffers while
+             * reconfiguration is taking place, so we don't inadvertently
+             * commit an in-progress, incomplete configuration state. */
+            EnterCriticalSection(&draw_gl->wayland_surface->crit);
+            drawing_allowed = draw_gl->wayland_surface->drawing_allowed;
+            if (drawing_allowed)
+                wayland_surface_ensure_mapped(draw_gl->wayland_surface);
+        }
+        if (drawing_allowed) p_eglSwapBuffers(egl_display, draw_gl->surface);
+        if (draw_gl->wayland_surface)
+            LeaveCriticalSection(&draw_gl->wayland_surface->crit);
+    }
+
+    wayland_gl_drawable_release(draw_gl);
+
+    return TRUE;
+}
+
 /***********************************************************************
  *		wayland_wglGetExtensionsStringARB
  */
@@ -1078,6 +1135,7 @@ static BOOL egl_init(void)
     LOAD_FUNCPTR(eglGetProcAddress);
     LOAD_FUNCPTR(eglInitialize);
     LOAD_FUNCPTR(eglMakeCurrent);
+    LOAD_FUNCPTR(eglSwapBuffers);
 #undef LOAD_FUNCPTR
 
     egl_display = p_eglGetDisplay((EGLNativeDisplayType) process_wl_display);
@@ -1117,6 +1175,7 @@ static struct opengl_funcs egl_funcs =
         .p_wglMakeCurrent = wayland_wglMakeCurrent,
         .p_wglSetPixelFormat = wayland_wglSetPixelFormat,
         .p_wglShareLists = wayland_wglShareLists,
+        .p_wglSwapBuffers = wayland_wglSwapBuffers,
     },
 #define USE_GL_FUNC(name) (void *)glstub_##name,
     .gl = { ALL_WGL_FUNCS }
-- 
2.34.1


From 5411be02ab9fb447e1ab49d32a8f84473ae87695 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 15:31:10 +0300
Subject: [PATCH 086/147] winewayland.drv: Refresh the context on glFlush and
 glFinish.

Ensure that changes to the backing Wayland surface will be applied
properly.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 31 +++++++++++++++++++++++++++++++
 1 file changed, 31 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 53dfc794d1d..5a602ee8db0 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -108,6 +108,9 @@ DECL_FUNCPTR(eglMakeCurrent);
 DECL_FUNCPTR(eglSwapBuffers);
 #undef DECL_FUNCPTR
 
+static void (*p_glFinish)(void);
+static void (*p_glFlush)(void);
+
 static inline BOOL is_onscreen_pixel_format(int format)
 {
     return format > 0 && format <= nb_onscreen_formats;
@@ -706,6 +709,26 @@ static BOOL WINAPI wayland_wglSwapBuffers(HDC hdc)
     return TRUE;
 }
 
+static void wayland_glFinish(void)
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+
+    if (!ctx) return;
+    TRACE("hwnd %p egl_context %p\n", ctx->draw_hwnd, ctx->context);
+    wgl_context_refresh(ctx);
+    p_glFinish();
+}
+
+static void wayland_glFlush(void)
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+
+    if (!ctx) return;
+    TRACE("hwnd %p egl_context %p\n", ctx->draw_hwnd, ctx->context);
+    wgl_context_refresh(ctx);
+    p_glFlush();
+}
+
 /***********************************************************************
  *		wayland_wglGetExtensionsStringARB
  */
@@ -1037,6 +1060,14 @@ static void init_extensions(void)
     LOAD_FUNCPTR(glVertexBindingDivisor);
     LOAD_FUNCPTR(glWaitSync);
 #undef LOAD_FUNCPTR
+
+    /* Redirect some standard OpenGL functions. */
+
+#define REDIRECT(func) \
+    do { p_##func = egl_funcs.gl.p_##func; egl_funcs.gl.p_##func = wayland_##func; } while(0)
+    REDIRECT(glFinish);
+    REDIRECT(glFlush);
+#undef REDIRECT
 }
 
 static BOOL init_pixel_formats(void)
-- 
2.34.1


From 5f3d744b1ac33a43c8613ff13713e3d99066c747 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 29 Sep 2021 18:38:22 +0300
Subject: [PATCH 087/147] winewayland.drv: Advertise WGL_EXT_framebuffer_sRGB.

If our EGL version supports GL colorspaces, advertise WGL_EXT_framebuffer_sRGB
and create EGL window surfaces with an sRGB colorspace.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 45 ++++++++++++++++++++++++++++++++---
 1 file changed, 42 insertions(+), 3 deletions(-)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 5a602ee8db0..7d77d494734 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -45,6 +45,14 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+#ifndef EGL_GL_COLORSPACE
+#define EGL_GL_COLORSPACE 0x309D
+#endif
+
+#ifndef EGL_GL_COLORSPACE_SRGB
+#define EGL_GL_COLORSPACE_SRGB 0x3089
+#endif
+
 struct wgl_pixel_format
 {
     EGLConfig config;
@@ -79,6 +87,7 @@ static char wgl_extensions[4096];
 static struct opengl_funcs egl_funcs;
 static struct wgl_pixel_format *pixel_formats;
 static int nb_pixel_formats, nb_onscreen_formats;
+static BOOL has_gl_colorspace;
 
 static struct wl_list gl_drawables = { &gl_drawables, &gl_drawables };
 static struct wl_list gl_contexts = { &gl_contexts, &gl_contexts };
@@ -105,6 +114,7 @@ DECL_FUNCPTR(eglGetDisplay);
 DECL_FUNCPTR(eglGetProcAddress);
 DECL_FUNCPTR(eglInitialize);
 DECL_FUNCPTR(eglMakeCurrent);
+DECL_FUNCPTR(eglQueryString);
 DECL_FUNCPTR(eglSwapBuffers);
 #undef DECL_FUNCPTR
 
@@ -212,12 +222,15 @@ static BOOL wgl_context_make_current(struct wgl_context *ctx, HWND draw_hwnd, HW
 
 static void wayland_gl_drawable_update(struct wayland_gl_drawable *gl)
 {
+    EGLint attribs[] = { EGL_GL_COLORSPACE, EGL_GL_COLORSPACE_SRGB, EGL_NONE };
+
     TRACE("hwnd=%p\n", gl->hwnd);
 
     if (gl->surface || !gl->wayland_surface) goto out;
 
     gl->surface = p_eglCreateWindowSurface(egl_display, pixel_formats[gl->format - 1].config,
-                                           gl->wayland_surface->glvk->wl_egl_window, NULL);
+                                           gl->wayland_surface->glvk->wl_egl_window,
+                                           has_gl_colorspace ? attribs : NULL);
     if (gl->surface)
     {
         struct wgl_context *ctx;
@@ -754,9 +767,28 @@ static void register_extension(const char *ext)
     TRACE("%s\n", ext);
 }
 
-static void init_extensions(void)
+static BOOL has_extension(const char *list, const char *ext)
+{
+    size_t len = strlen(ext);
+    const char *cur = list;
+
+    if (!cur) return FALSE;
+
+    while ((cur = strstr(cur, ext)))
+    {
+        if ((!cur[len] || cur[len] == ' ') && (cur == list || cur[-1] == ' '))
+        {
+            return TRUE;
+        }
+    }
+
+    return FALSE;
+}
+
+static void init_extensions(int major, int minor)
 {
     void *ptr;
+    const char *egl_exts = p_eglQueryString(egl_display, EGL_EXTENSIONS);
 
     register_extension("WGL_ARB_extensions_string");
     egl_funcs.ext.p_wglGetExtensionsStringARB = wayland_wglGetExtensionsStringARB;
@@ -779,6 +811,12 @@ static void init_extensions(void)
     register_extension("WGL_ARB_create_context_profile");
     egl_funcs.ext.p_wglCreateContextAttribsARB = wayland_wglCreateContextAttribsARB;
 
+    if ((major == 1 && minor >= 5) || has_extension(egl_exts, "EGL_KHR_gl_colorspace"))
+    {
+        register_extension("WGL_EXT_framebuffer_sRGB");
+        has_gl_colorspace = TRUE;
+    }
+
     /* load standard functions and extensions exported from the OpenGL library */
 
 #define USE_GL_FUNC(func) if ((ptr = dlsym(opengl_handle, #func))) egl_funcs.gl.p_##func = ptr;
@@ -1166,6 +1204,7 @@ static BOOL egl_init(void)
     LOAD_FUNCPTR(eglGetProcAddress);
     LOAD_FUNCPTR(eglInitialize);
     LOAD_FUNCPTR(eglMakeCurrent);
+    LOAD_FUNCPTR(eglQueryString);
     LOAD_FUNCPTR(eglSwapBuffers);
 #undef LOAD_FUNCPTR
 
@@ -1175,7 +1214,7 @@ static BOOL egl_init(void)
 
     if (!init_pixel_formats()) return FALSE;
 
-    init_extensions();
+    init_extensions(major, minor);
     retval = 1;
     return TRUE;
 }
-- 
2.34.1


From 56a745ca446ed0ba521c2145f9becd3eae1eb352 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 30 Sep 2021 11:23:00 +0300
Subject: [PATCH 088/147] winewayland.drv: Update GL drawable on surface
 changes.

When the Wayland surface for a window changes, also update
any associated GL drawable.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c     | 29 +++++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h |  2 ++
 dlls/winewayland.drv/window.c     |  7 ++++++-
 3 files changed, 37 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 7d77d494734..ac0c4fb123a 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -1263,3 +1263,32 @@ struct opengl_funcs *wayland_get_wgl_driver(UINT version)
     if (!egl_init()) return NULL;
     return &egl_funcs;
 }
+
+/***********************************************************************
+ *		wayland_update_gl_drawable_surface
+ */
+void wayland_update_gl_drawable_surface(HWND hwnd,
+                                        struct wayland_surface *wayland_surface)
+{
+    struct wayland_gl_drawable *gl;
+
+    if ((gl = wayland_gl_drawable_get(hwnd)))
+    {
+        if (gl->surface)
+        {
+            p_eglDestroySurface(egl_display, gl->surface);
+            gl->surface = EGL_NO_SURFACE;
+        }
+
+        if (gl->wayland_surface)
+            wayland_surface_unref_glvk(gl->wayland_surface);
+
+        gl->wayland_surface = wayland_surface;
+        if (gl->wayland_surface)
+            wayland_surface_create_or_ref_gl(gl->wayland_surface);
+
+        wayland_gl_drawable_update(gl);
+
+        wayland_gl_drawable_release(gl);
+    }
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 5b989181907..9209e1a10b6 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -431,6 +431,8 @@ void wayland_set_cursor_if_current_invalid(HCURSOR hcursor);
  */
 
 struct opengl_funcs *wayland_get_wgl_driver(UINT version);
+void wayland_update_gl_drawable_surface(HWND hwnd,
+                                        struct wayland_surface *wayland_surface);
 
 /**********************************************************************
  *          XKB helpers
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index ed232ee4231..f29bdce8902 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -523,7 +523,10 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
             wl_list_for_each(child, &data->wayland_surface->child_list, link)
             {
                 struct wayland_win_data *child_data;
-                if ((child_data = wayland_win_data_get(child->hwnd)))
+                /* Don't handle glvk subsurfaces here, they are updated specially
+                 * below. */
+                if (child != data->wayland_surface->glvk &&
+                    (child_data = wayland_win_data_get(child->hwnd)))
                 {
                     child_data->wayland_surface_needs_update = TRUE;
                     wayland_win_data_release(child_data);
@@ -535,6 +538,8 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
         }
 
         data->wayland_surface = surface;
+
+        wayland_update_gl_drawable_surface(data->hwnd, data->wayland_surface);
     }
 }
 
-- 
2.34.1


From 2a9787b8f1dfa2c3c1ed0673bd293fe431c93c02 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 30 Sep 2021 11:24:36 +0300
Subject: [PATCH 089/147] winewayland.drv: Destroy GL drawable on window
 destruction.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c     | 2 +-
 dlls/winewayland.drv/waylanddrv.h | 1 +
 dlls/winewayland.drv/window.c     | 1 +
 3 files changed, 3 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index ac0c4fb123a..c1d2e9a633b 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -150,7 +150,7 @@ static struct wayland_gl_drawable *wayland_gl_drawable_create(HWND hwnd, int for
     return gl;
 }
 
-static void wayland_destroy_gl_drawable(HWND hwnd)
+void wayland_destroy_gl_drawable(HWND hwnd)
 {
     struct wayland_gl_drawable *gl;
 
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 9209e1a10b6..f50ab866ef9 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -433,6 +433,7 @@ void wayland_set_cursor_if_current_invalid(HCURSOR hcursor);
 struct opengl_funcs *wayland_get_wgl_driver(UINT version);
 void wayland_update_gl_drawable_surface(HWND hwnd,
                                         struct wayland_surface *wayland_surface);
+void wayland_destroy_gl_drawable(HWND hwnd);
 
 /**********************************************************************
  *          XKB helpers
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index f29bdce8902..9d849c087dc 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -896,6 +896,7 @@ void CDECL WAYLAND_DestroyWindow(HWND hwnd)
     TRACE("%p\n", hwnd);
 
     if (!(data = wayland_win_data_get(hwnd))) return;
+    wayland_destroy_gl_drawable(hwnd);
     wayland_win_data_destroy(data);
 }
 
-- 
2.34.1


From 5a6722840f7e15065230843cd292188f172c847a Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 30 Sep 2021 11:25:07 +0300
Subject: [PATCH 090/147] winewayland.drv: Enable OpenGL driver.

Expose the OpenGL driver through the corresponding function of the GDI
driver.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/gdi.c             | 16 ++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  1 +
 dlls/winewayland.drv/waylanddrv_main.c |  1 +
 3 files changed, 18 insertions(+)

diff --git a/dlls/winewayland.drv/gdi.c b/dlls/winewayland.drv/gdi.c
index 321884b437d..0c4afa7e7dc 100644
--- a/dlls/winewayland.drv/gdi.c
+++ b/dlls/winewayland.drv/gdi.c
@@ -82,3 +82,19 @@ BOOL CDECL WAYLAND_DeleteDC(PHYSDEV dev)
     HeapFree(GetProcessHeap(), 0, physDev);
     return TRUE;
 }
+
+/**********************************************************************
+ *           WAYLAND_wine_get_wgl_driver
+ */
+struct opengl_funcs * CDECL WAYLAND_wine_get_wgl_driver(PHYSDEV dev, UINT version)
+{
+    struct opengl_funcs *ret;
+
+    if (!(ret = wayland_get_wgl_driver(version)))
+    {
+        dev = GET_NEXT_PHYSDEV(dev, wine_get_wgl_driver);
+        ret = dev->funcs->wine_get_wgl_driver(dev, version);
+    }
+
+    return ret;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index f50ab866ef9..eaa6b5605a5 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -491,5 +491,6 @@ extern BOOL CDECL WAYLAND_CreateDC(PHYSDEV *pdev, LPCWSTR device,
 extern BOOL CDECL WAYLAND_CreateCompatibleDC(PHYSDEV orig, PHYSDEV *pdev) DECLSPEC_HIDDEN;
 extern BOOL CDECL WAYLAND_CreateCompatibleDC(PHYSDEV orig, PHYSDEV *pdev) DECLSPEC_HIDDEN;
 extern BOOL CDECL WAYLAND_DeleteDC(PHYSDEV dev) DECLSPEC_HIDDEN;
+extern struct opengl_funcs * CDECL WAYLAND_wine_get_wgl_driver(PHYSDEV dev, UINT version) DECLSPEC_HIDDEN;
 
 #endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 28902e02458..6cb3b715a6a 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -124,6 +124,7 @@ const struct user_driver_funcs waylanddrv_funcs =
     .dc_funcs.pCreateDC = WAYLAND_CreateDC,
     .dc_funcs.pCreateCompatibleDC = WAYLAND_CreateCompatibleDC,
     .dc_funcs.pDeleteDC = WAYLAND_DeleteDC,
+    .dc_funcs.wine_get_wgl_driver = WAYLAND_wine_get_wgl_driver,
     .dc_funcs.priority = GDI_PRIORITY_GRAPHICS_DRV,
 
     .pChangeDisplaySettingsEx = WAYLAND_ChangeDisplaySettingsEx,
-- 
2.34.1


From 74fe8b31d8da1656f9a9220c53da4c3741e8e27c Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 16:06:08 +0300
Subject: [PATCH 091/147] winewayland.drv: Support front buffer rendering in
 window_surface.

Implement a front buffer for window_surface, which, when enabled, is
used as a background image on which window surface contents are drawn
over.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h     |   7 ++
 dlls/winewayland.drv/window.c         |  39 +++++++++
 dlls/winewayland.drv/window_surface.c | 115 +++++++++++++++++++++++++-
 3 files changed, 157 insertions(+), 4 deletions(-)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index eaa6b5605a5..73e12e51351 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -57,6 +57,7 @@ enum wayland_window_message
     WM_WAYLAND_STATE_UPDATE = 0x80001004,
     WM_WAYLAND_SURFACE_OUTPUT_CHANGE = 0x80001005,
     WM_WAYLAND_MONITOR_CHANGE = 0x80001006,
+    WM_WAYLAND_WINDOW_SURFACE_FLUSH = 0x80001007,
 };
 
 enum wayland_surface_role
@@ -402,6 +403,9 @@ void wayland_window_surface_set_window_region(struct window_surface *window_surf
 void wayland_window_surface_update_layered(struct window_surface *window_surface,
                                            COLORREF color_key, BYTE alpha,
                                            BOOL src_alpha);
+void wayland_window_surface_update_front_buffer(struct window_surface *window_surface,
+                                                void (*read_pixels)(void *pixels_out,
+                                                                    int width, int height));
 
 /**********************************************************************
  *          Wayland Keyboard
@@ -434,6 +438,9 @@ struct opengl_funcs *wayland_get_wgl_driver(UINT version);
 void wayland_update_gl_drawable_surface(HWND hwnd,
                                         struct wayland_surface *wayland_surface);
 void wayland_destroy_gl_drawable(HWND hwnd);
+void wayland_update_front_buffer(HWND hwnd,
+                                 void (*read_pixels)(void *pixels_out,
+                                                     int width, int height));
 
 /**********************************************************************
  *          XKB helpers
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 9d849c087dc..f98a4d24e8f 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -1560,6 +1560,14 @@ LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
     case WM_WAYLAND_MONITOR_CHANGE:
         handle_wm_wayland_monitor_change(thread_wayland());
         break;
+    case WM_WAYLAND_WINDOW_SURFACE_FLUSH:
+        {
+            struct wayland_win_data *data = wayland_win_data_get(hwnd);
+            if (data && data->window_surface)
+                wayland_window_surface_flush(data->window_surface);
+            wayland_win_data_release(data);
+        }
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp);
     }
@@ -1589,3 +1597,34 @@ err:
     ERR("Failed to get client rect for hwnd %p", hwnd);
     SetRectEmpty(client_rect);
 }
+
+/***********************************************************************
+ *           wayland_update_front_buffer
+ *
+ * Update the front buffer we keep for windows that require it (i.e.,
+ * use front buffer rendering). The front buffer is populated by calling
+ * the supplied read_pixels function, which should store the pixels in
+ * the supplied pixels_out memory location. If read_pixels is NULL, the
+ * front buffer is disabled.
+ *
+ * Note that the stored pixels are expected to be in BGRA8888 form with line
+ * order flipped upside down, i.e., starting with the bottom line (this
+ * is the order used, e.g., by glReadPixels).
+ */
+void wayland_update_front_buffer(HWND hwnd,
+                                 void (*read_pixels)(void *pixels_out,
+                                                     int width, int height))
+{
+    struct wayland_win_data *data;
+
+    if ((data = wayland_win_data_get(hwnd)) && data->window_surface)
+    {
+        wayland_window_surface_update_front_buffer(data->window_surface,
+                                                   read_pixels);
+
+        /* Trigger a redraw to apply any front buffer changes. */
+        PostMessageW(hwnd, WM_WAYLAND_WINDOW_SURFACE_FLUSH, 0, 0);
+    }
+
+    wayland_win_data_release(data);
+}
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index b4061942104..ef17e711c56 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -51,6 +51,8 @@ struct wayland_window_surface
     void                 *bits;
     CRITICAL_SECTION      crit;
     BOOL                  last_flush_failed;
+    void                 *front_bits; /* Front buffer pixels, stored bottom to top */
+    BOOL                  front_bits_dirty;
     BITMAPINFO            info;
 };
 
@@ -278,6 +280,28 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
         }
     }
 
+    /* If we have a front buffer we always copy it to the buffer before copying
+     * the window surface contents, so the whole surface is considered damaged.
+     * We also damage the whole surface if we just cleared the front buffer
+     * (i.e., front_bits == NULL and front_bits_dirty == TRUE). */
+    if (wws->front_bits || wws->front_bits_dirty)
+    {
+        needs_flush |= wws->front_bits_dirty;
+        if (needs_flush)
+        {
+            if (surface_damage_region)
+            {
+                SetRectRgn(surface_damage_region,
+                           wws->header.rect.left, wws->header.rect.top,
+                           wws->header.rect.right, wws->header.rect.bottom);
+            }
+            else
+            {
+                surface_damage_region = CreateRectRgnIndirect(&wws->header.rect);
+            }
+        }
+    }
+
     if (needs_flush && (!wws->wayland_surface || !wws->wayland_buffer_queue))
     {
         TRACE("missing wayland surface=%p buffer_queue=%p, returning\n",
@@ -308,6 +332,30 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
     }
     buffer_damage = wayland_shm_buffer_get_damage_clipped(buffer, wws->total_region);
 
+    /* Copy the whole front buffer to wayland SHM buffer. */
+    if (wws->front_bits)
+    {
+        int width = min(wws->info.bmiHeader.biWidth, buffer->width);
+        int height = min(abs(wws->info.bmiHeader.biHeight), buffer->height);
+        int stride = width * 4;
+        unsigned char *src = wws->front_bits;
+        unsigned char *dst = buffer->map_data;
+        int src_stride = wws->info.bmiHeader.biWidth * 4;
+        int dst_stride = buffer->width * 4;
+        int i;
+
+        TRACE("front buffer %p -> %p %dx%d\n", src, dst, width, height);
+
+        /* Front buffer lines are stored bottom to top, so we need to flip
+         * when copying to our buffer. */
+        for (i = 0; i < height; i++)
+        {
+            memcpy(dst + (height - i - 1) * dst_stride,
+                   src + i * src_stride,
+                   stride);
+        }
+    }
+
     rgn_rect = (RECT *)buffer_damage->Buffer;
     rgn_rect_end = rgn_rect + buffer_damage->rdh.nCount;
 
@@ -399,7 +447,11 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
     heap_free(buffer_damage);
 
 done:
-    if (!wws->last_flush_failed) reset_bounds(&wws->bounds);
+    if (!wws->last_flush_failed)
+    {
+        reset_bounds(&wws->bounds);
+        wws->front_bits_dirty = FALSE;
+    }
     if (surface_damage_region) DeleteObject(surface_damage_region);
     window_surface->funcs->unlock(window_surface);
 }
@@ -421,6 +473,7 @@ static void CDECL wayland_window_surface_destroy(struct window_surface *window_s
     if (wws->wayland_buffer_queue)
         wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
     heap_free(wws->bits);
+    heap_free(wws->front_bits);
     heap_free(wws);
 }
 
@@ -467,6 +520,8 @@ struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect
     wws->color_key    = color_key;
     wws->alpha        = alpha;
     wws->src_alpha    = src_alpha;
+    wws->front_bits   = NULL;
+    wws->front_bits_dirty = FALSE;
     wayland_window_surface_set_window_region(&wws->header, (HRGN)1);
     reset_bounds(&wws->bounds);
 
@@ -515,10 +570,16 @@ void wayland_window_surface_update_wayland_surface(struct window_surface *window
                     wws->info.bmiHeader.biWidth, abs(wws->info.bmiHeader.biHeight),
                     get_preferred_format(wws));
     }
-    else if (!wws->wayland_surface && wws->wayland_buffer_queue)
+    else if (!wws->wayland_surface)
     {
-        wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
-        wws->wayland_buffer_queue = NULL;
+        if (wws->wayland_buffer_queue)
+        {
+            wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
+            wws->wayland_buffer_queue = NULL;
+        }
+        heap_free(wws->front_bits);
+        wws->front_bits = NULL;
+        wws->front_bits_dirty = FALSE;
     }
 
     window_surface->funcs->unlock(window_surface);
@@ -550,3 +611,49 @@ void wayland_window_surface_update_layered(struct window_surface *window_surface
 
     window_surface->funcs->unlock(window_surface);
 }
+
+/***********************************************************************
+ *           wayland_window_surface_update_front_buffer
+ */
+void wayland_window_surface_update_front_buffer(struct window_surface *window_surface,
+                                                void (*read_pixels)(void *pixels_out,
+                                                                    int width, int height))
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+
+    TRACE("hwnd=%p front_bits=%p read_pixels=%p size=%dx%d\n",
+          wws->hwnd, wws->front_bits, read_pixels,
+          wws->info.bmiHeader.biWidth, abs(wws->info.bmiHeader.biHeight));
+
+    window_surface->funcs->lock(window_surface);
+
+    if (!read_pixels)
+    {
+        if (wws->front_bits)
+        {
+            heap_free(wws->front_bits);
+            wws->front_bits = NULL;
+            /* When the front_bits are first invalidated, we mark them as dirty
+             * to force the next window_surface flush. */
+            wws->front_bits_dirty = TRUE;
+        }
+        goto out;
+    }
+
+    if (!wws->front_bits)
+        wws->front_bits = heap_alloc(wws->info.bmiHeader.biSizeImage);
+
+    if (wws->front_bits)
+    {
+        (*read_pixels)(wws->front_bits, wws->info.bmiHeader.biWidth,
+                       abs(wws->info.bmiHeader.biHeight));
+        wws->front_bits_dirty = TRUE;
+    }
+    else
+    {
+        WARN("Failed to allocate memory for front buffer pixels\n");
+    }
+
+out:
+    window_surface->funcs->unlock(window_surface);
+}
-- 
2.34.1


From 889e620d1d113a198a7bf6015102c5f4badaf530 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 16:34:39 +0300
Subject: [PATCH 092/147] winewayland.drv: Support front buffer rendering in
 OpenGL.

Mesa Wayland EGL, and Wayland in general, doesn't natively support front
buffer rendering. Emulate it by manually updating the window_surface
front buffer pixels, which are then used as a background during
window_surface flushes.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 86 +++++++++++++++++++++++++++++++++++
 1 file changed, 86 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index c1d2e9a633b..fa32e6a675f 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -78,6 +78,7 @@ struct wgl_context
     BOOL       has_been_current;
     BOOL       sharing;
     int        *attribs;
+    BOOL       is_draw_buffer_front;
 };
 
 static void *egl_handle;
@@ -120,6 +121,7 @@ DECL_FUNCPTR(eglSwapBuffers);
 
 static void (*p_glFinish)(void);
 static void (*p_glFlush)(void);
+static void (*p_glDrawBuffer)(GLenum);
 
 static inline BOOL is_onscreen_pixel_format(int format)
 {
@@ -383,6 +385,7 @@ static struct wgl_context *create_context(HDC hdc, struct wgl_context *share,
     ctx->refresh = FALSE;
     ctx->has_been_current = FALSE;
     ctx->sharing = FALSE;
+    ctx->is_draw_buffer_front = FALSE;
 
     /* The drawable critical section also guards access to gl_contexts, so it's
      * safe to add the entry here. */
@@ -722,6 +725,76 @@ static BOOL WINAPI wayland_wglSwapBuffers(HDC hdc)
     return TRUE;
 }
 
+static void wayland_glDrawBuffer(GLenum mode)
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+    GLint draw_fbo = -1;
+
+    if (!ctx) return;
+
+    egl_funcs.gl.p_glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &draw_fbo);
+
+    TRACE("hwnd %p egl_context %p mode 0x%x draw_fbo %d\n",
+          ctx->draw_hwnd, ctx->context, mode, draw_fbo);
+
+    if (draw_fbo == 0)
+    {
+        BOOL is_draw_buffer_front = (mode == GL_FRONT || mode == GL_FRONT_LEFT);
+        /* Disable the window front buffer if we have one and it's not needed
+         * any longer.  */
+        if (ctx->is_draw_buffer_front && !is_draw_buffer_front)
+            wayland_update_front_buffer(ctx->draw_hwnd, NULL);
+        ctx->is_draw_buffer_front = is_draw_buffer_front;
+    }
+
+    p_glDrawBuffer(mode);
+}
+
+static void read_front_buffer_pixels(void *pixels_out, int width, int height)
+{
+    GLenum prev_read_buffer;
+    GLint prev_read_framebuffer;
+    GLint prev_row_length;
+    GLint prev_image_height;
+    GLint prev_skip_rows;
+    GLint prev_skip_pixels;
+    GLint prev_skip_images;
+    GLint prev_alignment;
+
+    /* Store state we might change */
+    egl_funcs.gl.p_glGetIntegerv(GL_READ_BUFFER, (GLint*)&prev_read_buffer);
+    egl_funcs.gl.p_glGetIntegerv(GL_READ_FRAMEBUFFER_BINDING, &prev_read_framebuffer);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_ROW_LENGTH, &prev_row_length);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_IMAGE_HEIGHT, &prev_image_height);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_SKIP_ROWS, &prev_skip_rows);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_SKIP_PIXELS, &prev_skip_pixels);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_SKIP_IMAGES, &prev_skip_images);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_ALIGNMENT, &prev_alignment);
+
+    /* Set state we need for reading the pixels */
+    egl_funcs.ext.p_glBindFramebuffer(GL_READ_FRAMEBUFFER, 0);
+    egl_funcs.gl.p_glReadBuffer(GL_FRONT);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_ROW_LENGTH, 0);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_IMAGE_HEIGHT, 0);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_ROWS, 0);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_PIXELS, 0);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_IMAGES, 0);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_ALIGNMENT, 4);
+
+    egl_funcs.gl.p_glReadPixels(0, 0, width, height, GL_BGRA,  GL_UNSIGNED_BYTE,
+                                pixels_out);
+
+    /* Restore prev state */
+    egl_funcs.ext.p_glBindFramebuffer(GL_READ_FRAMEBUFFER, prev_read_framebuffer);
+    egl_funcs.gl.p_glReadBuffer(prev_read_buffer);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_ROW_LENGTH, prev_row_length);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_IMAGE_HEIGHT, prev_image_height);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_ROWS, prev_skip_rows);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_PIXELS, prev_skip_pixels);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_IMAGES, prev_skip_images);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_ALIGNMENT, prev_alignment);
+}
+
 static void wayland_glFinish(void)
 {
     struct wgl_context *ctx = NtCurrentTeb()->glContext;
@@ -730,6 +803,12 @@ static void wayland_glFinish(void)
     TRACE("hwnd %p egl_context %p\n", ctx->draw_hwnd, ctx->context);
     wgl_context_refresh(ctx);
     p_glFinish();
+
+    /* Mesa Wayland EGL doesn't currently support front buffer rendering.
+     * For now, emulate it by manually updating the window front buffer
+     * pixels, to be applied when the window surface contents are flushed. */
+    if (ctx->is_draw_buffer_front)
+        wayland_update_front_buffer(ctx->draw_hwnd, read_front_buffer_pixels);
 }
 
 static void wayland_glFlush(void)
@@ -740,6 +819,12 @@ static void wayland_glFlush(void)
     TRACE("hwnd %p egl_context %p\n", ctx->draw_hwnd, ctx->context);
     wgl_context_refresh(ctx);
     p_glFlush();
+
+    /* Mesa Wayland EGL doesn't currently support front buffer rendering.
+     * For now, emulate it by manually updating the window front buffer
+     * pixels, to be applied when the window surface contents are flushed. */
+    if (ctx->is_draw_buffer_front)
+        wayland_update_front_buffer(ctx->draw_hwnd, read_front_buffer_pixels);
 }
 
 /***********************************************************************
@@ -1103,6 +1188,7 @@ static void init_extensions(int major, int minor)
 
 #define REDIRECT(func) \
     do { p_##func = egl_funcs.gl.p_##func; egl_funcs.gl.p_##func = wayland_##func; } while(0)
+    REDIRECT(glDrawBuffer);
     REDIRECT(glFinish);
     REDIRECT(glFlush);
 #undef REDIRECT
-- 
2.34.1


From 647a58028803195aec855212da668dba04570a2f Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 15 Sep 2021 15:40:50 +0300
Subject: [PATCH 093/147] winewayland.drv: Support setting Wayland pointer to
 relative event mode.

Introduce a function to set the Wayland pointer event mode, emitting
either absolute coordinates (the default) or relative coordinates (i.e.,
just differences from previous positions). Relative mode requires and
uses the zwp_relative_pointer_manager_v1 Wayland extension.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |  1 +
 dlls/winewayland.drv/wayland.c         |  8 +++
 dlls/winewayland.drv/wayland_pointer.c | 80 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  4 ++
 4 files changed, 93 insertions(+)

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 7754eea8842..632c551ee6c 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -30,6 +30,7 @@ C_SRCS = \
 WAYLAND_PROTOCOL_SRCS = \
 	$(WAYLAND_PROTOCOLS_DATADIR)/stable/viewporter/viewporter.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/stable/xdg-shell/xdg-shell.xml \
+	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/relative-pointer/relative-pointer-unstable-v1.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/xdg-output/xdg-output-unstable-v1.xml \
 
 RC_SRCS = version.rc
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index c90397da9dc..c1d3f47369c 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -171,6 +171,11 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
     {
         wayland->wp_viewporter = wl_registry_bind(registry, id, &wp_viewporter_interface, 1);
     }
+    else if (strcmp(interface, "zwp_relative_pointer_manager_v1") == 0)
+    {
+        wayland->zwp_relative_pointer_manager_v1 =
+            wl_registry_bind(registry, id, &zwp_relative_pointer_manager_v1_interface, 1);
+    }
 }
 
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
@@ -327,6 +332,9 @@ void wayland_deinit(struct wayland *wayland)
     if (wayland->wl_seat)
         wl_seat_destroy(wayland->wl_seat);
 
+    if (wayland->zwp_relative_pointer_manager_v1)
+        zwp_relative_pointer_manager_v1_destroy(wayland->zwp_relative_pointer_manager_v1);
+
     if (wayland->wp_viewporter)
         wp_viewporter_destroy(wayland->wp_viewporter);
 
diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 87da2c10843..00def0eecf2 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -70,6 +70,12 @@ static void pointer_handle_motion_internal(void *data, struct wl_pointer *pointe
 static void pointer_handle_motion(void *data, struct wl_pointer *pointer,
                                   uint32_t time, wl_fixed_t sx, wl_fixed_t sy)
 {
+    struct wayland *wayland = data;
+
+    /* Don't handle absolute motion events if we are in relative mode. */
+    if (wayland->pointer.zwp_relative_pointer_v1)
+        return;
+
     pointer_handle_motion_internal(data, pointer, time, sx, sy);
 }
 
@@ -234,6 +240,47 @@ static const struct wl_pointer_listener pointer_listener = {
     pointer_handle_axis_discrete,
 };
 
+static void relative_pointer_handle_motion(void *data,
+                                           struct zwp_relative_pointer_v1 *rpointer,
+                                           uint32_t utime_hi,
+                                           uint32_t utime_lo,
+                                           wl_fixed_t dx,
+                                           wl_fixed_t dy,
+                                           wl_fixed_t dx_unaccel,
+                                           wl_fixed_t dy_unaccel)
+{
+    struct wayland *wayland = data;
+    HWND focused_hwnd = wayland->pointer.focused_surface ?
+                        wayland->pointer.focused_surface->hwnd : 0;
+    int wine_dx, wine_dy;
+    INPUT input = {0};
+
+    if (!focused_hwnd)
+        return;
+
+    wayland_surface_coords_to_wine(wayland->pointer.focused_surface,
+                                   wl_fixed_to_int(dx), wl_fixed_to_int(dy),
+                                   &wine_dx, &wine_dy);
+
+    TRACE("surface=%p hwnd=%p wayland_dxdy=%d,%d wine_dxdy=%d,%d\n",
+          wayland->pointer.focused_surface, focused_hwnd,
+          wl_fixed_to_int(dx), wl_fixed_to_int(dy), wine_dx, wine_dy);
+
+    input.type           = INPUT_MOUSE;
+    input.mi.dx          = wine_dx;
+    input.mi.dy          = wine_dy;
+    input.mi.dwFlags     = MOUSEEVENTF_MOVE;
+
+    wayland->last_dispatch_mask |= QS_MOUSEMOVE;
+    wayland->last_event_type = INPUT_MOUSE;
+
+    __wine_send_input(focused_hwnd, &input, NULL);
+}
+
+static const struct zwp_relative_pointer_v1_listener zwp_relative_pointer_v1_listener = {
+    relative_pointer_handle_motion,
+};
+
 void wayland_pointer_init(struct wayland_pointer *pointer, struct wayland *wayland,
                           struct wl_pointer *wl_pointer)
 {
@@ -242,10 +289,14 @@ void wayland_pointer_init(struct wayland_pointer *pointer, struct wayland *wayla
     wl_pointer_add_listener(wayland->pointer.wl_pointer, &pointer_listener, wayland);
     wayland->pointer.cursor_wl_surface =
         wl_compositor_create_surface(wayland->wl_compositor);
+    pointer->zwp_relative_pointer_v1 = NULL;
 }
 
 void wayland_pointer_deinit(struct wayland_pointer *pointer)
 {
+    if (pointer->zwp_relative_pointer_v1)
+        zwp_relative_pointer_v1_destroy(pointer->zwp_relative_pointer_v1);
+
     if (pointer->wl_pointer)
         wl_pointer_destroy(pointer->wl_pointer);
 
@@ -257,3 +308,32 @@ void wayland_pointer_deinit(struct wayland_pointer *pointer)
 
     memset(pointer, 0, sizeof(*pointer));
 }
+
+/**********************************************************************
+ *          wayland_pointer_set_relative
+ *
+ * Set whether the pointer emits relative (if able) or absolute motion events.
+ * The default is to emit absolute motion events.
+ */
+void wayland_pointer_set_relative(struct wayland_pointer *pointer, BOOL relative)
+{
+    if (!pointer->wayland->zwp_relative_pointer_manager_v1)
+        return;
+
+    if (!pointer->zwp_relative_pointer_v1 && relative)
+    {
+        pointer->zwp_relative_pointer_v1 =
+            zwp_relative_pointer_manager_v1_get_relative_pointer(
+                pointer->wayland->zwp_relative_pointer_manager_v1,
+                pointer->wl_pointer);
+
+        zwp_relative_pointer_v1_add_listener(pointer->zwp_relative_pointer_v1,
+                                             &zwp_relative_pointer_v1_listener,
+                                             pointer->wayland);
+    }
+    else if (pointer->zwp_relative_pointer_v1 && !relative)
+    {
+        zwp_relative_pointer_v1_destroy(pointer->zwp_relative_pointer_v1);
+        pointer->zwp_relative_pointer_v1 = NULL;
+    }
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 73e12e51351..15d4899dd90 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -30,6 +30,7 @@
 #include <wayland-egl.h>
 #include <xkbcommon/xkbcommon.h>
 #include <xkbcommon/xkbcommon-compose.h>
+#include "relative-pointer-unstable-v1-client-protocol.h"
 #include "viewporter-client-protocol.h"
 #include "xdg-output-unstable-v1-client-protocol.h"
 #include "xdg-shell-client-protocol.h"
@@ -113,6 +114,7 @@ struct wayland_pointer
     uint32_t enter_serial;
     struct wayland_cursor *cursor;
     HCURSOR hcursor;
+    struct zwp_relative_pointer_v1 *zwp_relative_pointer_v1;
 };
 
 struct wayland
@@ -130,6 +132,7 @@ struct wayland
     struct wl_shm *wl_shm;
     struct wl_seat *wl_seat;
     struct wp_viewporter *wp_viewporter;
+    struct zwp_relative_pointer_manager_v1 *zwp_relative_pointer_manager_v1;
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t next_fallback_output_id;
     struct wl_list output_list;
@@ -423,6 +426,7 @@ void wayland_keyboard_update_layout(struct wayland_keyboard *keyboard);
 void wayland_pointer_init(struct wayland_pointer *pointer, struct wayland *wayland,
                           struct wl_pointer *wl_pointer);
 void wayland_pointer_deinit(struct wayland_pointer *pointer);
+void wayland_pointer_set_relative(struct wayland_pointer *pointer, BOOL relative);
 void wayland_cursor_destroy(struct wayland_cursor *wayland_cursor);
 void wayland_pointer_update_cursor_from_win32(struct wayland_pointer *pointer,
                                               HCURSOR handle);
-- 
2.34.1


From 18617a7046131e1fed70645c7524723b30d752b2 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 15 Sep 2021 16:06:48 +0300
Subject: [PATCH 094/147] winewayland.drv: Introduce function to get Wayland
 surface coords from screen.

Introduce the wayland_surface_coords_from_screen function to transform
Wine screen coords to Wayland surfaces coords. This will be useful in an
upcoming commit which will need to set the pointer position hint when
leaving relative pointer event mode.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 28 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  3 +++
 2 files changed, 31 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 54c92277c1f..b46c16dac1e 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -996,6 +996,34 @@ void wayland_surface_coords_to_screen(struct wayland_surface *surface,
           *screen_x, *screen_y);
 }
 
+/**********************************************************************
+ *          wayland_surface_coords_from_screen
+ *
+ * Converts the Windows screen coordinates to surface-local coordinates.
+ */
+void wayland_surface_coords_from_screen(struct wayland_surface *surface,
+                                        int screen_x, int screen_y,
+                                        double *wayland_x, double *wayland_y)
+{
+    int wine_x, wine_y;
+    RECT window_rect = {0};
+
+    /* Screen to window */
+    GetWindowRect(surface->hwnd, &window_rect);
+    OffsetRect(&window_rect, surface->offset_x, surface->offset_y);
+
+    wine_x = screen_x - window_rect.left;
+    wine_y = screen_y - window_rect.top;
+
+    /* Window to wayland surface */
+    wayland_surface_coords_from_wine(surface, wine_x, wine_y,
+                                     wayland_x, wayland_y);
+
+    TRACE("hwnd=%p screen=%d,%d rect=%s => wayland=%.2f,%.2f\n",
+          surface->hwnd, screen_x, screen_y, wine_dbgstr_rect(&window_rect),
+          *wayland_x, *wayland_y);
+}
+
 /**********************************************************************
  *          wayland_surface_coords_from_wine
  *
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 15d4899dd90..fda12fa5718 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -356,6 +356,9 @@ void wayland_surface_for_hwnd_unlock(struct wayland_surface *surface);
 void wayland_surface_coords_to_screen(struct wayland_surface *surface,
                                       double wayland_x, double wayland_y,
                                       int *screen_x, int *screen_y);
+void wayland_surface_coords_from_screen(struct wayland_surface *surface,
+                                        int screen_x, int screen_y,
+                                        double *wayland_x, double *wayland_y);
 void wayland_surface_coords_from_wine(struct wayland_surface *surface,
                                       int wine_x, int wine_y,
                                       double *wayland_x, double *wayland_y);
-- 
2.34.1


From 825f546d2bf64aa9f9b40e78a8657cef350a6c0a Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 15 Sep 2021 16:18:20 +0300
Subject: [PATCH 095/147] winewayland.drv: Implement ClipCursor.

Implement cursor clipping by using the zwp_pointer_constraints_v1
and the zwp_relative_pointer_v1 Wayland protocols.

We use a set of heurestics to decide when to constraint the Wayland
pointer and which form of constraint to use for the focused surface:

1. If the cursor isn't visible (i.e., we don't have a current cursor)
   and we have an effective clip for a window, lock the pointer in
   the corresponding Wayland surface and emit relative events (typical
   case for first/third-person perspective 3D games).

2. If the cursor is visible, and we have an effective clip for a window,
   confine the cursor to the clipped area within the corresponding
   Wayland surface and emit absolute events.

3. Otherwise, don't constrain.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |   1 +
 dlls/winewayland.drv/wayland.c         |   8 ++
 dlls/winewayland.drv/wayland_cursor.c  |  28 ++++
 dlls/winewayland.drv/wayland_surface.c | 188 +++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  15 ++
 dlls/winewayland.drv/waylanddrv_main.c |   1 +
 dlls/winewayland.drv/window.c          |  23 +++
 7 files changed, 264 insertions(+)

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 632c551ee6c..267294e9383 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -30,6 +30,7 @@ C_SRCS = \
 WAYLAND_PROTOCOL_SRCS = \
 	$(WAYLAND_PROTOCOLS_DATADIR)/stable/viewporter/viewporter.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/stable/xdg-shell/xdg-shell.xml \
+	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/pointer-constraints/pointer-constraints-unstable-v1.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/relative-pointer/relative-pointer-unstable-v1.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/xdg-output/xdg-output-unstable-v1.xml \
 
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index c1d3f47369c..9adb1883669 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -29,6 +29,7 @@
 
 #include <errno.h>
 #include <fcntl.h>
+#include <limits.h>
 #include <poll.h>
 #include <unistd.h>
 
@@ -171,6 +172,11 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
     {
         wayland->wp_viewporter = wl_registry_bind(registry, id, &wp_viewporter_interface, 1);
     }
+    else if (strcmp(interface, "zwp_pointer_constraints_v1") == 0)
+    {
+        wayland->zwp_pointer_constraints_v1 =
+            wl_registry_bind(registry, id, &zwp_pointer_constraints_v1_interface, 1);
+    }
     else if (strcmp(interface, "zwp_relative_pointer_manager_v1") == 0)
     {
         wayland->zwp_relative_pointer_manager_v1 =
@@ -263,6 +269,8 @@ BOOL wayland_init(struct wayland *wayland)
     wl_list_init(&wayland->output_list);
     wl_list_init(&wayland->toplevel_list);
 
+    SetRect(&wayland->cursor_clip, INT_MIN, INT_MIN, INT_MAX, INT_MAX);
+
     /* Populate registry */
     wl_registry_add_listener(wayland->wl_registry, &registry_listener, wayland);
 
diff --git a/dlls/winewayland.drv/wayland_cursor.c b/dlls/winewayland.drv/wayland_cursor.c
index 06053cde139..78ff858fa45 100644
--- a/dlls/winewayland.drv/wayland_cursor.c
+++ b/dlls/winewayland.drv/wayland_cursor.c
@@ -340,6 +340,10 @@ static BOOL wayland_set_cursor(HCURSOR hcursor)
 
     SendMessageW(foreground, WM_WAYLAND_SET_CURSOR, 0, (LPARAM)hcursor);
 
+    /* Cursor visibility affects pointer confinement mode. */
+    SendMessageW(foreground, WM_WAYLAND_POINTER_CONFINEMENT_UPDATE,
+                 WAYLAND_POINTER_CONFINEMENT_RETAIN_CLIP, 0);
+
     return TRUE;
 }
 
@@ -375,3 +379,27 @@ void CDECL WAYLAND_SetCursor(HCURSOR hcursor)
         if (!wayland_set_cursor(hcursor)) wayland_invalidate_set_cursor();
     }
 }
+
+/***********************************************************************
+ *           WAYLAND_ClipCursor
+ */
+BOOL CDECL WAYLAND_ClipCursor(const RECT *clip)
+{
+    HWND foreground = NULL;
+    struct wayland *wayland = thread_wayland();
+    WPARAM confine = clip ? WAYLAND_POINTER_CONFINEMENT_SYSTEM_CLIP :
+                            WAYLAND_POINTER_CONFINEMENT_UNSET_CLIP;
+
+    if (wayland && wayland->pointer.focused_surface)
+        foreground = wayland->pointer.focused_surface->hwnd;
+
+    if (!foreground)
+        foreground = GetForegroundWindow();
+
+    if (!foreground)
+        return FALSE;
+
+    SendMessageW(foreground, WM_WAYLAND_POINTER_CONFINEMENT_UPDATE, confine, 0);
+
+    return TRUE;
+}
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index b46c16dac1e..9918d02d5dc 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -677,6 +677,18 @@ void wayland_surface_destroy(struct wayland_surface *surface)
         heap_free(ref);
     }
 
+    if (surface->zwp_locked_pointer_v1)
+    {
+        zwp_locked_pointer_v1_destroy(surface->zwp_locked_pointer_v1);
+        surface->zwp_locked_pointer_v1 = NULL;
+    }
+
+    if (surface->zwp_confined_pointer_v1)
+    {
+        zwp_confined_pointer_v1_destroy(surface->zwp_confined_pointer_v1);
+        surface->zwp_confined_pointer_v1 = NULL;
+    }
+
     if (surface->wl_egl_window)
     {
         wl_egl_window_destroy(surface->wl_egl_window);
@@ -1248,6 +1260,182 @@ void wayland_surface_unref(struct wayland_surface *surface)
         wayland_surface_destroy(surface);
 }
 
+/**********************************************************************
+ *          wayland_surface_update_pointer_confinement
+ *
+ * Update pointer confinement on the surface. Confinement mode depends
+ * on the current Windows cursor clip and cursor visibility.
+ */
+void wayland_surface_update_pointer_confinement(struct wayland_surface *surface)
+{
+    struct wayland *wayland = surface->wayland;
+    struct wayland_surface *glvk;
+    struct wl_region *region;
+    RECT vscreen_rect;
+    RECT clip_rect = wayland->cursor_clip;
+    RECT client_rect = {0};
+    RECT client_clip_rect;
+    BOOL needs_lock = FALSE;
+    BOOL needs_confine = FALSE;
+
+    if (!wayland->zwp_pointer_constraints_v1 || !wayland->pointer.wl_pointer)
+        return;
+
+    wayland_get_client_rect_in_win_coords(surface->hwnd, &client_rect);
+    MapWindowPoints(surface->hwnd, NULL, (POINT*)&client_rect, 2);
+
+    vscreen_rect.top = GetSystemMetrics(SM_YVIRTUALSCREEN);
+    vscreen_rect.left = GetSystemMetrics(SM_XVIRTUALSCREEN);
+    vscreen_rect.bottom = vscreen_rect.top + GetSystemMetrics(SM_CYVIRTUALSCREEN);
+    vscreen_rect.right = vscreen_rect.left + GetSystemMetrics(SM_CXVIRTUALSCREEN);
+
+    /* Get the effective clip area, if any. */
+    IntersectRect(&clip_rect, &clip_rect, &vscreen_rect);
+    IntersectRect(&client_clip_rect, &clip_rect, &client_rect);
+
+    TRACE("wayland=%p surface=%p (glvk=%p) clip_rect=%s client_clip_rect=%s "
+          "client=%s vscreen=%s hcursor=%p\n",
+          wayland, surface, surface->glvk,
+          wine_dbgstr_rect(&clip_rect), wine_dbgstr_rect(&client_clip_rect),
+          wine_dbgstr_rect(&client_rect),
+          wine_dbgstr_rect(&vscreen_rect),
+          wayland->pointer.hcursor);
+
+    /* If there is a GL/VK subsurface use that to apply the pointer constaints,
+     * since it's covering the whole client area. */
+    glvk = wayland_surface_ref_glvk(surface);
+    if (glvk)
+    {
+        if (surface->zwp_locked_pointer_v1)
+        {
+            zwp_locked_pointer_v1_destroy(surface->zwp_locked_pointer_v1);
+            surface->zwp_locked_pointer_v1 = NULL;
+        }
+        if (surface->zwp_confined_pointer_v1)
+        {
+            zwp_confined_pointer_v1_destroy(surface->zwp_confined_pointer_v1);
+            surface->zwp_confined_pointer_v1 = NULL;
+        }
+        surface = glvk;
+    }
+
+    /* Only confine or lock if the cursor is actually clipped within this window,
+     * or if the clip rect is empty. */
+    if (!IsRectEmpty(&client_clip_rect) || IsRectEmpty(&clip_rect))
+    {
+        /* If the cursor is not visible, and we have an effective clip (i.e.,
+         * clip is not the whole screen) lock the cursor. If the client rect is
+         * the whole screen (i.e., application is fullscreen), we can't
+         * differentiate between an explicit fullscreen clip and no effective
+         * clip (i.e., clip is the whole screen), so also lock. */
+        if (!wayland->pointer.hcursor &&
+            (!EqualRect(&clip_rect, &vscreen_rect) ||
+             EqualRect(&client_rect, &vscreen_rect)))
+        {
+            needs_lock = TRUE;
+        }
+        else if (wayland->pointer.hcursor &&
+                 !EqualRect(&clip_rect, &vscreen_rect))
+        {
+            needs_confine = TRUE;
+        }
+    }
+
+    /* Destroy unneeded interface objects. */
+    if (!needs_lock && surface->zwp_locked_pointer_v1)
+    {
+        POINT cursor_pos;
+
+        if (GetCursorPos(&cursor_pos) && PtInRect(&client_rect, cursor_pos))
+        {
+            double wayland_x, wayland_y;
+            wayland_surface_coords_from_screen(surface,
+                                               cursor_pos.x, cursor_pos.y,
+                                               &wayland_x, &wayland_y);
+
+            zwp_locked_pointer_v1_set_cursor_position_hint(
+                    surface->zwp_locked_pointer_v1,
+                    wl_fixed_from_double(wayland_x),
+                    wl_fixed_from_double(wayland_y));
+
+            wl_surface_commit(surface->wl_surface);
+        }
+
+        zwp_locked_pointer_v1_destroy(surface->zwp_locked_pointer_v1);
+        surface->zwp_locked_pointer_v1 = NULL;
+    }
+
+    if (!needs_confine && surface->zwp_confined_pointer_v1)
+    {
+        zwp_confined_pointer_v1_destroy(surface->zwp_confined_pointer_v1);
+        surface->zwp_confined_pointer_v1 = NULL;
+    }
+
+    /* Set up (or update) pointer confinement or lock. */
+    if (needs_confine)
+    {
+        double top, left, bottom, right;
+
+        wayland_surface_coords_from_screen(surface,
+                                           client_clip_rect.left,
+                                           client_clip_rect.top,
+                                           &left, &top);
+        wayland_surface_coords_from_screen(surface,
+                                           client_clip_rect.right,
+                                           client_clip_rect.bottom,
+                                           &right, &bottom);
+
+        region = wl_compositor_create_region(wayland->wl_compositor);
+        wl_region_add(region, round(left), round(top),
+                      round(right - left), round(bottom - top));
+
+        if (!surface->zwp_confined_pointer_v1)
+        {
+            surface->zwp_confined_pointer_v1 =
+                zwp_pointer_constraints_v1_confine_pointer(
+                    wayland->zwp_pointer_constraints_v1,
+                    surface->wl_surface,
+                    wayland->pointer.wl_pointer,
+                    region,
+                    ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_PERSISTENT);
+        }
+        else
+        {
+            zwp_confined_pointer_v1_set_region(surface->zwp_confined_pointer_v1,
+                                               region);
+        }
+
+        wl_region_destroy(region);
+    }
+    else if (needs_lock)
+    {
+        if (!surface->zwp_locked_pointer_v1)
+        {
+            surface->zwp_locked_pointer_v1 =
+                zwp_pointer_constraints_v1_lock_pointer(
+                    wayland->zwp_pointer_constraints_v1,
+                    surface->wl_surface,
+                    wayland->pointer.wl_pointer,
+                    NULL,
+                    ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_PERSISTENT);
+        }
+        else
+        {
+            zwp_locked_pointer_v1_set_region(surface->zwp_locked_pointer_v1,
+                                             NULL);
+        }
+    }
+
+    if (wayland->pointer.focused_surface == surface)
+        wayland_pointer_set_relative(&wayland->pointer, needs_lock);
+
+    if (needs_confine || needs_lock)
+        wl_surface_commit(surface->wl_surface);
+
+    if (glvk)
+        wayland_surface_unref_glvk(glvk->parent);
+}
+
 static void wayland_surface_tree_set_main_output_and_scale(struct wayland_surface *surface,
                                                            struct wayland_output *output,
                                                            int scale)
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index fda12fa5718..f1bb421692d 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -30,6 +30,7 @@
 #include <wayland-egl.h>
 #include <xkbcommon/xkbcommon.h>
 #include <xkbcommon/xkbcommon-compose.h>
+#include "pointer-constraints-unstable-v1-client-protocol.h"
 #include "relative-pointer-unstable-v1-client-protocol.h"
 #include "viewporter-client-protocol.h"
 #include "xdg-output-unstable-v1-client-protocol.h"
@@ -59,6 +60,7 @@ enum wayland_window_message
     WM_WAYLAND_SURFACE_OUTPUT_CHANGE = 0x80001005,
     WM_WAYLAND_MONITOR_CHANGE = 0x80001006,
     WM_WAYLAND_WINDOW_SURFACE_FLUSH = 0x80001007,
+    WM_WAYLAND_POINTER_CONFINEMENT_UPDATE = 0x80001008,
 };
 
 enum wayland_surface_role
@@ -76,6 +78,13 @@ enum wayland_configure_flags
     WAYLAND_CONFIGURE_FLAG_FULLSCREEN = (1 << 3),
 };
 
+enum wayland_pointer_confinement
+{
+    WAYLAND_POINTER_CONFINEMENT_RETAIN_CLIP,
+    WAYLAND_POINTER_CONFINEMENT_SYSTEM_CLIP,
+    WAYLAND_POINTER_CONFINEMENT_UNSET_CLIP,
+};
+
 /**********************************************************************
  *          Definitions for wayland types
  */
@@ -132,6 +141,7 @@ struct wayland
     struct wl_shm *wl_shm;
     struct wl_seat *wl_seat;
     struct wp_viewporter *wp_viewporter;
+    struct zwp_pointer_constraints_v1 *zwp_pointer_constraints_v1;
     struct zwp_relative_pointer_manager_v1 *zwp_relative_pointer_manager_v1;
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t next_fallback_output_id;
@@ -144,6 +154,7 @@ struct wayland
     DWORD last_event_type;
     int event_notification_pipe[2];
     struct wl_list thread_link;
+    RECT cursor_clip;
 };
 
 struct wayland_output_mode
@@ -205,6 +216,8 @@ struct wayland_surface
     struct wl_egl_window *wl_egl_window;
     struct wayland_surface *parent;
     struct wayland_surface *glvk;
+    struct zwp_confined_pointer_v1 *zwp_confined_pointer_v1;
+    struct zwp_locked_pointer_v1 *zwp_locked_pointer_v1;
     /* The offset of this surface relative to its owning win32 window */
     int offset_x, offset_y;
     HWND hwnd;
@@ -374,6 +387,7 @@ void wayland_surface_find_wine_fullscreen_fit(struct wayland_surface *surface,
 void wayland_surface_ensure_mapped(struct wayland_surface *surface);
 struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface);
 void wayland_surface_unref(struct wayland_surface *surface);
+void wayland_surface_update_pointer_confinement(struct wayland_surface *surface);
 void wayland_surface_leave_output(struct wayland_surface *surface,
                                   struct wayland_output *output);
 void wayland_surface_set_wine_output(struct wayland_surface *surface,
@@ -467,6 +481,7 @@ void wayland_get_client_rect_in_win_coords(HWND hwnd, RECT *client_rect);
 
 extern LONG CDECL WAYLAND_ChangeDisplaySettingsEx(LPCWSTR devname, LPDEVMODEW devmode,
                                                   HWND hwnd, DWORD flags, LPVOID lpvoid) DECLSPEC_HIDDEN;
+extern BOOL CDECL WAYLAND_ClipCursor(const RECT *clip) DECLSPEC_HIDDEN;
 extern BOOL CDECL WAYLAND_CreateWindow(HWND hwnd) DECLSPEC_HIDDEN;
 extern void CDECL WAYLAND_DestroyWindow(HWND hwnd) DECLSPEC_HIDDEN;
 extern BOOL CDECL WAYLAND_EnumDisplaySettingsEx(LPCWSTR name, DWORD n, LPDEVMODEW devmode, DWORD flags) DECLSPEC_HIDDEN;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 6cb3b715a6a..e6bf351aaa3 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -128,6 +128,7 @@ const struct user_driver_funcs waylanddrv_funcs =
     .dc_funcs.priority = GDI_PRIORITY_GRAPHICS_DRV,
 
     .pChangeDisplaySettingsEx = WAYLAND_ChangeDisplaySettingsEx,
+    .pClipCursor = WAYLAND_ClipCursor,
     .pCreateWindow = WAYLAND_CreateWindow,
     .pDestroyWindow = WAYLAND_DestroyWindow,
     .pEnumDisplaySettingsEx = WAYLAND_EnumDisplaySettingsEx,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index f98a4d24e8f..d009dacbbc3 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -30,6 +30,8 @@
 #include "wine/debug.h"
 #include "wine/heap.h"
 
+#include <limits.h>
+
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
 /* private window data */
@@ -837,6 +839,8 @@ static void wayland_win_data_update_wayland_surface_state(struct wayland_win_dat
         wsurface->drawing_allowed = TRUE;
 
     LeaveCriticalSection(&wsurface->crit);
+
+    wayland_surface_update_pointer_confinement(wsurface);
 }
 
 static void update_wayland_state(struct wayland_win_data *data)
@@ -1568,6 +1572,25 @@ LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
             wayland_win_data_release(data);
         }
         break;
+    case WM_WAYLAND_POINTER_CONFINEMENT_UPDATE:
+        {
+            struct wayland_surface *wayland_surface = wayland_surface_for_hwnd_lock(hwnd);
+            if (wayland_surface)
+            {
+                if (wp == WAYLAND_POINTER_CONFINEMENT_SYSTEM_CLIP)
+                {
+                    GetClipCursor(&wayland_surface->wayland->cursor_clip);
+                }
+                else if (wp == WAYLAND_POINTER_CONFINEMENT_UNSET_CLIP)
+                {
+                    SetRect(&wayland_surface->wayland->cursor_clip,
+                            INT_MIN, INT_MIN, INT_MAX, INT_MAX);
+                }
+                wayland_surface_update_pointer_confinement(wayland_surface);
+            }
+            wayland_surface_for_hwnd_unlock(wayland_surface);
+        }
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp);
     }
-- 
2.34.1


From 3957a570b80ad20b771a92df807643d27d9cb123 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 15 Sep 2021 17:16:49 +0300
Subject: [PATCH 096/147] winewayland.drv: Implement SetWindowText.

Inform the Wayland compositor of the window title for toplevel windows,
transforming the title to the expected UTF-8 encoding.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 25 +++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  2 ++
 dlls/winewayland.drv/waylanddrv_main.c |  1 +
 dlls/winewayland.drv/window.c          | 22 ++++++++++++++++++++++
 4 files changed, 50 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 9918d02d5dc..ff58c4370e4 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -23,6 +23,7 @@
 #include "waylanddrv.h"
 #include "wine/debug.h"
 #include "wine/heap.h"
+#include "wine/unicode.h"
 
 #include "winuser.h"
 
@@ -1567,3 +1568,27 @@ int wayland_surface_get_buffer_scale(struct wayland_surface *surface)
     TRACE("hwnd=%p (toplevel=%p) => scale=%d\n", surface->hwnd, toplevel->hwnd, scale);
     return scale;
 }
+
+/**********************************************************************
+ *          wayland_surface_set_title
+ */
+void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR text)
+{
+    int utf8_count;
+    char *utf8 = NULL;
+
+    if (!surface->xdg_toplevel)
+        return;
+
+    TRACE("surface=%p hwnd=%p text='%s'\n",
+          surface, surface->hwnd, wine_dbgstr_w(text));
+
+    utf8_count = WideCharToMultiByte(CP_UTF8, 0, text, -1, NULL, 0, NULL, NULL);
+    if (utf8_count && (utf8 = heap_alloc(utf8_count)) &&
+        WideCharToMultiByte(CP_UTF8, 0, text, -1, utf8, utf8_count, NULL, NULL))
+    {
+        xdg_toplevel_set_title(surface->xdg_toplevel, utf8);
+    }
+
+    heap_free(utf8);
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index f1bb421692d..99c72bd44c0 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -393,6 +393,7 @@ void wayland_surface_leave_output(struct wayland_surface *surface,
 void wayland_surface_set_wine_output(struct wayland_surface *surface,
                                      struct wayland_output *output);
 int wayland_surface_get_buffer_scale(struct wayland_surface *surface);
+void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR title);
 
 /**********************************************************************
  *          Wayland SHM buffer
@@ -493,6 +494,7 @@ extern void CDECL WAYLAND_SetCursor(HCURSOR hcursor) DECLSPEC_HIDDEN;
 extern void CDECL WAYLAND_SetLayeredWindowAttributes(HWND hwnd, COLORREF key, BYTE alpha, DWORD flags) DECLSPEC_HIDDEN;
 extern void CDECL WAYLAND_SetWindowRgn(HWND hwnd, HRGN hrgn, BOOL redraw) DECLSPEC_HIDDEN;
 extern void CDECL WAYLAND_SetWindowStyle(HWND hwnd, INT offset, STYLESTRUCT *style) DECLSPEC_HIDDEN;
+extern void CDECL WAYLAND_SetWindowText(HWND hwnd, LPCWSTR text) DECLSPEC_HIDDEN;
 extern UINT CDECL WAYLAND_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp) DECLSPEC_HIDDEN;
 extern LRESULT CDECL WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam) DECLSPEC_HIDDEN;
 extern INT CDECL WAYLAND_ToUnicodeEx(UINT virt, UINT scan, const BYTE *state,
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index e6bf351aaa3..d51376e25b4 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -139,6 +139,7 @@ const struct user_driver_funcs waylanddrv_funcs =
     .pSetLayeredWindowAttributes = WAYLAND_SetLayeredWindowAttributes,
     .pSetWindowRgn = WAYLAND_SetWindowRgn,
     .pSetWindowStyle = WAYLAND_SetWindowStyle,
+    .pSetWindowText = WAYLAND_SetWindowText,
     .pShowWindow = WAYLAND_ShowWindow,
     .pSysCommand = WAYLAND_SysCommand,
     .pToUnicodeEx = WAYLAND_ToUnicodeEx,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index d009dacbbc3..dc4cd8e3563 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -513,6 +513,13 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
                                           wayland, parent_surface);
     }
 
+    if (surface && surface->xdg_toplevel)
+    {
+        WCHAR text[1024];
+        if (!InternalGetWindowText(data->hwnd, text, ARRAY_SIZE(text))) text[0] = 0;
+        wayland_surface_set_title(data->wayland_surface, text);
+    }
+
     if (data->wayland_surface != surface)
     {
         if (data->wayland_surface)
@@ -1077,6 +1084,21 @@ void CDECL WAYLAND_SetWindowStyle(HWND hwnd, INT offset, STYLESTRUCT *style)
     wayland_win_data_release(data);
 }
 
+/*****************************************************************
+ *		WAYLAND_SetWindowText
+ */
+void CDECL WAYLAND_SetWindowText(HWND hwnd, LPCWSTR text)
+{
+    struct wayland_surface *wsurface = wayland_surface_for_hwnd_lock(hwnd);
+
+    TRACE("hwnd=%p text=%s\n", hwnd, wine_dbgstr_w(text));
+
+    if (wsurface && wsurface->xdg_toplevel)
+        wayland_surface_set_title(wsurface, text);
+
+    wayland_surface_for_hwnd_unlock(wsurface);
+}
+
 /***********************************************************************
  *	     WAYLAND_SetLayeredWindowAttributes
  */
-- 
2.34.1


From a24b86d0351562b41acf83c6822e678de304a667 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 15 Sep 2021 18:33:07 +0300
Subject: [PATCH 097/147] winewayland.drv: Add skeleton Vulkan driver.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in  |  1 +
 dlls/winewayland.drv/vulkan.c     | 79 +++++++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h |  6 +++
 3 files changed, 86 insertions(+)
 create mode 100644 dlls/winewayland.drv/vulkan.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 267294e9383..3c362c43b27 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -13,6 +13,7 @@ C_SRCS = \
 	display.c \
 	gdi.c \
 	opengl.c \
+	vulkan.c \
 	wayland.c \
 	wayland_output.c \
 	waylanddrv_main.c \
diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
new file mode 100644
index 00000000000..f6970b44ebc
--- /dev/null
+++ b/dlls/winewayland.drv/vulkan.c
@@ -0,0 +1,79 @@
+/* WAYLANDDRV Vulkan implementation
+ *
+ * Copyright 2017 Roderick Colenbrander
+ * Copyright 2021 Alexandros Frantzis
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#define VK_NO_PROTOTYPES
+#define WINE_VK_HOST
+
+#include "wine/vulkan.h"
+#include "wine/vulkan_driver.h"
+
+#include <dlfcn.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(vulkan);
+
+#ifdef SONAME_LIBVULKAN
+
+static void *vulkan_handle;
+
+static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
+{
+    if (!(vulkan_handle = dlopen(SONAME_LIBVULKAN, RTLD_NOW)))
+    {
+        ERR("Failed to load %s.\n", SONAME_LIBVULKAN);
+        return TRUE;
+    }
+
+    return TRUE;
+}
+
+static const struct vulkan_funcs vulkan_funcs;
+
+const struct vulkan_funcs *wayland_get_vulkan_driver(UINT version)
+{
+    static INIT_ONCE init_once = INIT_ONCE_STATIC_INIT;
+
+    if (version != WINE_VULKAN_DRIVER_VERSION)
+    {
+        ERR("version mismatch, vulkan wants %u but driver has %u\n", version, WINE_VULKAN_DRIVER_VERSION);
+        return NULL;
+    }
+
+    InitOnceExecuteOnce(&init_once, wine_vk_init, NULL, NULL);
+    if (vulkan_handle)
+        return &vulkan_funcs;
+
+    return NULL;
+}
+
+#else /* No vulkan */
+
+const struct vulkan_funcs *wayland_get_vulkan_driver(UINT version)
+{
+    ERR("Wine was built without Vulkan support.\n");
+    return NULL;
+}
+
+#endif /* SONAME_LIBVULKAN */
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 99c72bd44c0..c1b5923872d 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -464,6 +464,12 @@ void wayland_update_front_buffer(HWND hwnd,
                                  void (*read_pixels)(void *pixels_out,
                                                      int width, int height));
 
+/**********************************************************************
+ *          Vulkan support
+ */
+
+const struct vulkan_funcs *wayland_get_vulkan_driver(UINT version);
+
 /**********************************************************************
  *          XKB helpers
  */
-- 
2.34.1


From 84ef6d25a13842182d4cb61ef6187811c617572e Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 15 Sep 2021 18:41:32 +0300
Subject: [PATCH 098/147] winewayland.drv: Implement vkCreateInstance.

Create a Vulkan instance, ensuring we use the proper (Wayland)
SurfaceKHR extension when forwarding the request to the native Vulkan
platform.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 89 ++++++++++++++++++++++++++++++++++-
 1 file changed, 88 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index f6970b44ebc..3155ecf6428 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -23,6 +23,7 @@
 #include "waylanddrv.h"
 
 #include "wine/debug.h"
+#include "wine/heap.h"
 
 #define VK_NO_PROTOTYPES
 #define WINE_VK_HOST
@@ -36,8 +37,82 @@ WINE_DEFAULT_DEBUG_CHANNEL(vulkan);
 
 #ifdef SONAME_LIBVULKAN
 
+static VkResult (*pvkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
+
 static void *vulkan_handle;
 
+/* Helper function for converting between win32 and Wayland compatible VkInstanceCreateInfo.
+ * Caller is responsible for allocation and cleanup of 'dst'.
+ */
+static VkResult wine_vk_instance_convert_create_info(const VkInstanceCreateInfo *src,
+                                                     VkInstanceCreateInfo *dst)
+{
+    unsigned int i;
+    const char **enabled_extensions = NULL;
+
+    dst->sType = src->sType;
+    dst->flags = src->flags;
+    dst->pApplicationInfo = src->pApplicationInfo;
+    dst->pNext = src->pNext;
+    dst->enabledLayerCount = 0;
+    dst->ppEnabledLayerNames = NULL;
+    dst->enabledExtensionCount = 0;
+    dst->ppEnabledExtensionNames = NULL;
+
+    if (src->enabledExtensionCount > 0)
+    {
+        enabled_extensions = heap_calloc(src->enabledExtensionCount, sizeof(*src->ppEnabledExtensionNames));
+        if (!enabled_extensions)
+        {
+            ERR("Failed to allocate memory for enabled extensions\n");
+            return VK_ERROR_OUT_OF_HOST_MEMORY;
+        }
+
+        for (i = 0; i < src->enabledExtensionCount; i++)
+        {
+            /* Substitute extension with Wayland ones else copy. Long-term, when we
+             * support more extensions, we should store these in a list.
+             */
+            if (!strcmp(src->ppEnabledExtensionNames[i], "VK_KHR_win32_surface"))
+                enabled_extensions[i] = "VK_KHR_wayland_surface";
+            else
+                enabled_extensions[i] = src->ppEnabledExtensionNames[i];
+        }
+        dst->ppEnabledExtensionNames = enabled_extensions;
+        dst->enabledExtensionCount = src->enabledExtensionCount;
+    }
+
+    return VK_SUCCESS;
+}
+
+static VkResult wayland_vkCreateInstance(const VkInstanceCreateInfo *create_info,
+                                         const VkAllocationCallbacks *allocator,
+                                         VkInstance *instance)
+{
+    VkInstanceCreateInfo create_info_host;
+    VkResult res;
+    TRACE("create_info %p, allocator %p, instance %p\n", create_info, allocator, instance);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    /* Perform a second pass on converting VkInstanceCreateInfo. Winevulkan
+     * performed a first pass in which it handles everything except for WSI
+     * functionality such as VK_KHR_win32_surface. Handle this now.
+     */
+    res = wine_vk_instance_convert_create_info(create_info, &create_info_host);
+    if (res != VK_SUCCESS)
+    {
+        ERR("Failed to convert instance create info, res=%d\n", res);
+        return res;
+    }
+
+    res = pvkCreateInstance(&create_info_host, NULL /* allocator */, instance);
+
+    heap_free((void *)create_info_host.ppEnabledExtensionNames);
+    return res;
+}
+
 static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
 {
     if (!(vulkan_handle = dlopen(SONAME_LIBVULKAN, RTLD_NOW)))
@@ -46,10 +121,22 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
         return TRUE;
     }
 
+#define LOAD_FUNCPTR(f) if (!(p##f = dlsym(vulkan_handle, #f))) goto fail
+    LOAD_FUNCPTR(vkCreateInstance);
+#undef LOAD_FUNCPTR
+
+    return TRUE;
+
+fail:
+    dlclose(vulkan_handle);
+    vulkan_handle = NULL;
     return TRUE;
 }
 
-static const struct vulkan_funcs vulkan_funcs;
+static const struct vulkan_funcs vulkan_funcs =
+{
+    .p_vkCreateInstance = wayland_vkCreateInstance,
+};
 
 const struct vulkan_funcs *wayland_get_vulkan_driver(UINT version)
 {
-- 
2.34.1


From 0a8155543b9a489481120c049b421f1a3f40213b Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 15 Sep 2021 18:44:10 +0300
Subject: [PATCH 099/147] winewayland.drv: Implement vkDestroyInstance.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 3155ecf6428..08eb01a1d8b 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -38,6 +38,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(vulkan);
 #ifdef SONAME_LIBVULKAN
 
 static VkResult (*pvkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
+static void (*pvkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
 
 static void *vulkan_handle;
 
@@ -113,6 +114,16 @@ static VkResult wayland_vkCreateInstance(const VkInstanceCreateInfo *create_info
     return res;
 }
 
+static void wayland_vkDestroyInstance(VkInstance instance, const VkAllocationCallbacks *allocator)
+{
+    TRACE("%p %p\n", instance, allocator);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    pvkDestroyInstance(instance, NULL /* allocator */);
+}
+
 static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
 {
     if (!(vulkan_handle = dlopen(SONAME_LIBVULKAN, RTLD_NOW)))
@@ -123,6 +134,7 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
 
 #define LOAD_FUNCPTR(f) if (!(p##f = dlsym(vulkan_handle, #f))) goto fail
     LOAD_FUNCPTR(vkCreateInstance);
+    LOAD_FUNCPTR(vkDestroyInstance);
 #undef LOAD_FUNCPTR
 
     return TRUE;
@@ -136,6 +148,7 @@ fail:
 static const struct vulkan_funcs vulkan_funcs =
 {
     .p_vkCreateInstance = wayland_vkCreateInstance,
+    .p_vkDestroyInstance = wayland_vkDestroyInstance,
 };
 
 const struct vulkan_funcs *wayland_get_vulkan_driver(UINT version)
-- 
2.34.1


From 3503e4c5396538fb319e8a673233210c62e88ef3 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 15 Sep 2021 19:08:02 +0300
Subject: [PATCH 100/147] winewayland.drv: Prepare for supporting windows with
 Vulkan content.

Introduce function to create a Wayland subsurface as the target surface
for Vulkan rendering, similarly to how we deal with GL rendering.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 39 ++++++++++++++++++++------
 dlls/winewayland.drv/waylanddrv.h      |  1 +
 2 files changed, 31 insertions(+), 9 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index ff58c4370e4..6571b30167e 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -803,12 +803,10 @@ static struct wayland_surface *wayland_surface_ref_glvk(struct wayland_surface *
     return glvk;
 }
 
-/**********************************************************************
- *          wayland_surface_create_gl
- *
- * Creates a GL subsurface for this wayland surface.
- */
-BOOL wayland_surface_create_or_ref_gl(struct wayland_surface *surface)
+enum WAYLAND_GLVK { WAYLAND_GLVK_GL, WAYLAND_GLVK_VK };
+
+static BOOL wayland_surface_create_or_ref_glvk(struct wayland_surface *surface,
+                                               enum WAYLAND_GLVK wayland_glvk)
 {
     struct wayland_surface *glvk;
     RECT client_rect;
@@ -822,9 +820,12 @@ BOOL wayland_surface_create_or_ref_gl(struct wayland_surface *surface)
     if (!glvk)
         goto err;
 
-    glvk->wl_egl_window = wl_egl_window_create(glvk->wl_surface, 1, 1);
-    if (!glvk->wl_egl_window)
-        goto err;
+    if (wayland_glvk == WAYLAND_GLVK_GL)
+    {
+        glvk->wl_egl_window = wl_egl_window_create(glvk->wl_surface, 1, 1);
+        if (!glvk->wl_egl_window)
+            goto err;
+    }
 
     EnterCriticalSection(&surface->crit);
     surface->glvk = glvk;
@@ -849,6 +850,26 @@ err:
     return FALSE;
 }
 
+/**********************************************************************
+ *          wayland_surface_create_gl
+ *
+ * Creates a GL subsurface for this wayland surface.
+ */
+BOOL wayland_surface_create_or_ref_gl(struct wayland_surface *surface)
+{
+    return wayland_surface_create_or_ref_glvk(surface, WAYLAND_GLVK_GL);
+}
+
+/**********************************************************************
+ *          wayland_surface_create_or_ref_vk
+ *
+ * Creates a VK subsurface for this wayland surface.
+ */
+BOOL wayland_surface_create_or_ref_vk(struct wayland_surface *surface)
+{
+    return wayland_surface_create_or_ref_glvk(surface, WAYLAND_GLVK_VK);
+}
+
 /**********************************************************************
  *          wayland_surface_unref_glvk
  *
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index c1b5923872d..220712f687b 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -359,6 +359,7 @@ void wayland_surface_reconfigure_size(struct wayland_surface *surface,
                                       int width, int height);
 void wayland_surface_reconfigure_apply(struct wayland_surface *surface);
 BOOL wayland_surface_create_or_ref_gl(struct wayland_surface *surface);
+BOOL wayland_surface_create_or_ref_vk(struct wayland_surface *surface);
 void wayland_surface_unref_glvk(struct wayland_surface *surface);
 void wayland_surface_reconfigure_glvk(struct wayland_surface *surface, int x, int y,
                                       int width, int height);
-- 
2.34.1


From d1f77f3ebe85008ca3d3d1704506b686e77a5b1b Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 15 Sep 2021 19:08:53 +0300
Subject: [PATCH 101/147] winewayland.drv: Implement vkCreateWin32SurfaceKHR.

Create Win32 VkSurfaceKHR objects which are backed by native Wayland
VkSurfaceKHR objects. These native objects are associated with a
dedicated subsurface we use for Vulkan rendering (see
wayland_surface_create_or_ref_vk). We use the native VkSurfaceKHR handle
as the Win32 VkSurfaceKHR handle, to ensure transparent compatibility
with all extensions (current *and* future) that accept VkSurfaceKHR
handles.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 128 ++++++++++++++++++++++++++++++++++
 1 file changed, 128 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 08eb01a1d8b..525c91717da 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -25,6 +25,8 @@
 #include "wine/debug.h"
 #include "wine/heap.h"
 
+#include "winuser.h"
+
 #define VK_NO_PROTOTYPES
 #define WINE_VK_HOST
 
@@ -37,11 +39,66 @@ WINE_DEFAULT_DEBUG_CHANNEL(vulkan);
 
 #ifdef SONAME_LIBVULKAN
 
+#define VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR 1000006000
+
+typedef struct VkWaylandSurfaceCreateInfoKHR
+{
+    VkStructureType sType;
+    const void *pNext;
+    VkWaylandSurfaceCreateFlagsKHR flags;
+    struct wl_display *display;
+    struct wl_surface *surface;
+} VkWaylandSurfaceCreateInfoKHR;
+
 static VkResult (*pvkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
+static VkResult (*pvkCreateWaylandSurfaceKHR)(VkInstance, const VkWaylandSurfaceCreateInfoKHR *, const VkAllocationCallbacks *, VkSurfaceKHR *);
 static void (*pvkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
 
 static void *vulkan_handle;
 
+static CRITICAL_SECTION wine_vk_object_section;
+static CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &wine_vk_object_section,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": wine_vk_object_section") }
+};
+static CRITICAL_SECTION wine_vk_object_section = { &critsect_debug, -1, 0, 0, 0, 0 };
+
+static struct wl_list wine_vk_surface_list = { &wine_vk_surface_list, &wine_vk_surface_list };
+
+struct wine_vk_surface
+{
+    struct wl_list link;
+    HWND hwnd;
+    struct wayland_surface *wayland_surface;
+    VkSurfaceKHR native_vk_surface;
+};
+
+static inline void wine_vk_list_add(struct wl_list *list, struct wl_list *link)
+{
+    EnterCriticalSection(&wine_vk_object_section);
+    wl_list_insert(list, link);
+    LeaveCriticalSection(&wine_vk_object_section);
+}
+
+static inline void wine_vk_list_remove(struct wl_list *link)
+{
+    EnterCriticalSection(&wine_vk_object_section);
+    wl_list_remove(link);
+    LeaveCriticalSection(&wine_vk_object_section);
+}
+
+static void wine_vk_surface_destroy(struct wine_vk_surface *wine_vk_surface)
+{
+    wine_vk_list_remove(&wine_vk_surface->link);
+
+    if (wine_vk_surface->wayland_surface)
+        wayland_surface_unref_glvk(wine_vk_surface->wayland_surface);
+
+    heap_free(wine_vk_surface);
+}
+
 /* Helper function for converting between win32 and Wayland compatible VkInstanceCreateInfo.
  * Caller is responsible for allocation and cleanup of 'dst'.
  */
@@ -114,6 +171,75 @@ static VkResult wayland_vkCreateInstance(const VkInstanceCreateInfo *create_info
     return res;
 }
 
+static VkResult wayland_vkCreateWin32SurfaceKHR(VkInstance instance,
+                                                const VkWin32SurfaceCreateInfoKHR *create_info,
+                                                const VkAllocationCallbacks *allocator,
+                                                VkSurfaceKHR *vk_surface)
+{
+    VkResult res;
+    VkWaylandSurfaceCreateInfoKHR create_info_host;
+    struct wine_vk_surface *wine_vk_surface;
+    struct wayland_surface *wayland_surface;
+    BOOL ref_vk;
+
+    TRACE("%p %p %p %p\n", instance, create_info, allocator, vk_surface);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    wine_vk_surface = heap_alloc_zero(sizeof(*wine_vk_surface));
+    if (!wine_vk_surface)
+        return VK_ERROR_OUT_OF_HOST_MEMORY;
+
+    wl_list_init(&wine_vk_surface->link);
+
+    wayland_surface = wayland_surface_for_hwnd_lock(create_info->hwnd);
+    if (!wayland_surface)
+    {
+        ERR("Failed to find wayland surface for hwnd=%p\n", create_info->hwnd);
+        /* VK_KHR_win32_surface only allows out of host and device memory as errors. */
+        res = VK_ERROR_OUT_OF_HOST_MEMORY;
+        goto err;
+    }
+
+    ref_vk = wayland_surface_create_or_ref_vk(wayland_surface);
+    wayland_surface_for_hwnd_unlock(wayland_surface);
+    if (!ref_vk)
+    {
+        ERR("Failed to create or ref vulkan surface for hwnd=%p\n", create_info->hwnd);
+        /* VK_KHR_win32_surface only allows out of host and device memory as errors. */
+        res = VK_ERROR_OUT_OF_HOST_MEMORY;
+        goto err;
+    }
+
+    wine_vk_surface->wayland_surface = wayland_surface;
+
+    create_info_host.sType = VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR;
+    create_info_host.pNext = NULL;
+    create_info_host.flags = 0; /* reserved */
+    create_info_host.display = process_wl_display;
+    create_info_host.surface = wayland_surface->glvk->wl_surface;
+
+    res = pvkCreateWaylandSurfaceKHR(instance, &create_info_host, NULL /* allocator */, vk_surface);
+    if (res != VK_SUCCESS)
+    {
+        ERR("Failed to create vulkan wayland surface, res=%d\n", res);
+        goto err;
+    }
+
+    wine_vk_surface->hwnd = create_info->hwnd;
+    wine_vk_surface->native_vk_surface = *vk_surface;
+
+    wine_vk_list_add(&wine_vk_surface_list, &wine_vk_surface->link);
+
+    TRACE("Created surface=0x%s\n", wine_dbgstr_longlong(*vk_surface));
+    return VK_SUCCESS;
+
+err:
+    wine_vk_surface_destroy(wine_vk_surface);
+    return res;
+}
+
 static void wayland_vkDestroyInstance(VkInstance instance, const VkAllocationCallbacks *allocator)
 {
     TRACE("%p %p\n", instance, allocator);
@@ -134,6 +260,7 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
 
 #define LOAD_FUNCPTR(f) if (!(p##f = dlsym(vulkan_handle, #f))) goto fail
     LOAD_FUNCPTR(vkCreateInstance);
+    LOAD_FUNCPTR(vkCreateWaylandSurfaceKHR);
     LOAD_FUNCPTR(vkDestroyInstance);
 #undef LOAD_FUNCPTR
 
@@ -148,6 +275,7 @@ fail:
 static const struct vulkan_funcs vulkan_funcs =
 {
     .p_vkCreateInstance = wayland_vkCreateInstance,
+    .p_vkCreateWin32SurfaceKHR = wayland_vkCreateWin32SurfaceKHR,
     .p_vkDestroyInstance = wayland_vkDestroyInstance,
 };
 
-- 
2.34.1


From ed8519ca3d23de12f04ad8776a71fa5ea4d55ecc Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 17 Sep 2021 12:02:59 +0300
Subject: [PATCH 102/147] winewayland.drv: Implement vkDestroySurfaceKHR.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 37 +++++++++++++++++++++++++++++++++++
 1 file changed, 37 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 525c91717da..811b924f29a 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -53,6 +53,7 @@ typedef struct VkWaylandSurfaceCreateInfoKHR
 static VkResult (*pvkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
 static VkResult (*pvkCreateWaylandSurfaceKHR)(VkInstance, const VkWaylandSurfaceCreateInfoKHR *, const VkAllocationCallbacks *, VkSurfaceKHR *);
 static void (*pvkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
+static void (*pvkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocationCallbacks *);
 
 static void *vulkan_handle;
 
@@ -99,6 +100,22 @@ static void wine_vk_surface_destroy(struct wine_vk_surface *wine_vk_surface)
     heap_free(wine_vk_surface);
 }
 
+static struct wine_vk_surface *wine_vk_surface_from_handle(VkSurfaceKHR handle)
+{
+    struct wine_vk_surface *surf;
+
+    EnterCriticalSection(&wine_vk_object_section);
+
+    wl_list_for_each(surf, &wine_vk_surface_list, link)
+        if (surf->native_vk_surface == handle) goto out;
+
+    surf = NULL;
+
+out:
+    LeaveCriticalSection(&wine_vk_object_section);
+    return surf;
+}
+
 /* Helper function for converting between win32 and Wayland compatible VkInstanceCreateInfo.
  * Caller is responsible for allocation and cleanup of 'dst'.
  */
@@ -250,6 +267,24 @@ static void wayland_vkDestroyInstance(VkInstance instance, const VkAllocationCal
     pvkDestroyInstance(instance, NULL /* allocator */);
 }
 
+static void wayland_vkDestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface,
+                                        const VkAllocationCallbacks *allocator)
+{
+    struct wine_vk_surface *wine_vk_surface = wine_vk_surface_from_handle(surface);
+
+    TRACE("%p 0x%s %p\n", instance, wine_dbgstr_longlong(surface), allocator);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    if (wine_vk_surface)
+    {
+        pvkDestroySurfaceKHR(instance, wine_vk_surface->native_vk_surface,
+                             NULL /* allocator */);
+        wine_vk_surface_destroy(wine_vk_surface);
+    }
+}
+
 static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
 {
     if (!(vulkan_handle = dlopen(SONAME_LIBVULKAN, RTLD_NOW)))
@@ -262,6 +297,7 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
     LOAD_FUNCPTR(vkCreateInstance);
     LOAD_FUNCPTR(vkCreateWaylandSurfaceKHR);
     LOAD_FUNCPTR(vkDestroyInstance);
+    LOAD_FUNCPTR(vkDestroySurfaceKHR);
 #undef LOAD_FUNCPTR
 
     return TRUE;
@@ -277,6 +313,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkCreateInstance = wayland_vkCreateInstance,
     .p_vkCreateWin32SurfaceKHR = wayland_vkCreateWin32SurfaceKHR,
     .p_vkDestroyInstance = wayland_vkDestroyInstance,
+    .p_vkDestroySurfaceKHR = wayland_vkDestroySurfaceKHR,
 };
 
 const struct vulkan_funcs *wayland_get_vulkan_driver(UINT version)
-- 
2.34.1


From c791be5914511b32ca2947d5c2d8a780827950e8 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 17 Sep 2021 12:21:29 +0300
Subject: [PATCH 103/147] winewayland.drv: Implement vkCreateSwapchainKHR.

Create Win32 VkSwapchainKHR objects which are backed by native Wayland
VkSwapchainKHR objects. We use the native VkSwapchainKHR handle as the
Win32 VkSwapchainKHR handle, to ensure transparent compatibility with
all extensions (current *and* future) that accept VkSwapchainKHR
handles.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 79 +++++++++++++++++++++++++++++++++++
 1 file changed, 79 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 811b924f29a..7e208bf88b8 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -51,6 +51,7 @@ typedef struct VkWaylandSurfaceCreateInfoKHR
 } VkWaylandSurfaceCreateInfoKHR;
 
 static VkResult (*pvkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
+static VkResult (*pvkCreateSwapchainKHR)(VkDevice, const VkSwapchainCreateInfoKHR *, const VkAllocationCallbacks *, VkSwapchainKHR *);
 static VkResult (*pvkCreateWaylandSurfaceKHR)(VkInstance, const VkWaylandSurfaceCreateInfoKHR *, const VkAllocationCallbacks *, VkSurfaceKHR *);
 static void (*pvkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
 static void (*pvkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocationCallbacks *);
@@ -67,6 +68,7 @@ static CRITICAL_SECTION_DEBUG critsect_debug =
 static CRITICAL_SECTION wine_vk_object_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
 static struct wl_list wine_vk_surface_list = { &wine_vk_surface_list, &wine_vk_surface_list };
+static struct wl_list wine_vk_swapchain_list = { &wine_vk_swapchain_list, &wine_vk_swapchain_list };
 
 struct wine_vk_surface
 {
@@ -76,6 +78,14 @@ struct wine_vk_surface
     VkSurfaceKHR native_vk_surface;
 };
 
+struct wine_vk_swapchain
+{
+    struct wl_list link;
+    HWND hwnd;
+    struct wayland_surface *wayland_surface;
+    VkSwapchainKHR native_vk_swapchain;
+};
+
 static inline void wine_vk_list_add(struct wl_list *list, struct wl_list *link)
 {
     EnterCriticalSection(&wine_vk_object_section);
@@ -116,6 +126,16 @@ out:
     return surf;
 }
 
+static void wine_vk_swapchain_destroy(struct wine_vk_swapchain *wine_vk_swapchain)
+{
+    wine_vk_list_remove(&wine_vk_swapchain->link);
+
+    if (wine_vk_swapchain->wayland_surface)
+        wayland_surface_unref_glvk(wine_vk_swapchain->wayland_surface);
+
+    heap_free(wine_vk_swapchain);
+}
+
 /* Helper function for converting between win32 and Wayland compatible VkInstanceCreateInfo.
  * Caller is responsible for allocation and cleanup of 'dst'.
  */
@@ -160,6 +180,11 @@ static VkResult wine_vk_instance_convert_create_info(const VkInstanceCreateInfo
     return VK_SUCCESS;
 }
 
+#define RETURN_VK_ERROR_SURFACE_LOST_KHR { \
+    TRACE("VK_ERROR_SURFACE_LOST_KHR\n"); \
+    return VK_ERROR_SURFACE_LOST_KHR; \
+}
+
 static VkResult wayland_vkCreateInstance(const VkInstanceCreateInfo *create_info,
                                          const VkAllocationCallbacks *allocator,
                                          VkInstance *instance)
@@ -188,6 +213,58 @@ static VkResult wayland_vkCreateInstance(const VkInstanceCreateInfo *create_info
     return res;
 }
 
+static VkResult wayland_vkCreateSwapchainKHR(VkDevice device,
+                                             const VkSwapchainCreateInfoKHR *create_info,
+                                             const VkAllocationCallbacks *allocator,
+                                             VkSwapchainKHR *swapchain)
+{
+    VkResult res;
+    struct wine_vk_surface *wine_vk_surface;
+    struct wine_vk_swapchain *wine_vk_swapchain;
+    VkSwapchainCreateInfoKHR info = *create_info;
+
+    TRACE("%p %p %p %p\n", device, create_info, allocator, swapchain);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    /* Wayland can't deal with 0x0 swapchains, use the minimum 1x1. */
+    if (info.imageExtent.width == 0)
+        info.imageExtent.width = 1;
+    if (info.imageExtent.height == 0)
+        info.imageExtent.height = 1;
+
+    wine_vk_surface = wine_vk_surface_from_handle(info.surface);
+    if (!wine_vk_surface)
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    wine_vk_swapchain = heap_alloc_zero(sizeof(*wine_vk_swapchain));
+    if (!wine_vk_swapchain)
+        return VK_ERROR_OUT_OF_HOST_MEMORY;
+
+    wl_list_init(&wine_vk_swapchain->link);
+
+    res = pvkCreateSwapchainKHR(device, &info, NULL /* allocator */, swapchain);
+    if (res != VK_SUCCESS)
+        goto err;
+
+    wine_vk_swapchain->hwnd = wine_vk_surface->hwnd;
+    if (wine_vk_surface->wayland_surface)
+    {
+        wayland_surface_create_or_ref_vk(wine_vk_surface->wayland_surface);
+        wine_vk_swapchain->wayland_surface = wine_vk_surface->wayland_surface;
+    }
+    wine_vk_swapchain->native_vk_swapchain = *swapchain;
+
+    wine_vk_list_add(&wine_vk_swapchain_list, &wine_vk_swapchain->link);
+
+    return res;
+
+err:
+    wine_vk_swapchain_destroy(wine_vk_swapchain);
+    return res;
+}
+
 static VkResult wayland_vkCreateWin32SurfaceKHR(VkInstance instance,
                                                 const VkWin32SurfaceCreateInfoKHR *create_info,
                                                 const VkAllocationCallbacks *allocator,
@@ -295,6 +372,7 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
 
 #define LOAD_FUNCPTR(f) if (!(p##f = dlsym(vulkan_handle, #f))) goto fail
     LOAD_FUNCPTR(vkCreateInstance);
+    LOAD_FUNCPTR(vkCreateSwapchainKHR);
     LOAD_FUNCPTR(vkCreateWaylandSurfaceKHR);
     LOAD_FUNCPTR(vkDestroyInstance);
     LOAD_FUNCPTR(vkDestroySurfaceKHR);
@@ -311,6 +389,7 @@ fail:
 static const struct vulkan_funcs vulkan_funcs =
 {
     .p_vkCreateInstance = wayland_vkCreateInstance,
+    .p_vkCreateSwapchainKHR = wayland_vkCreateSwapchainKHR,
     .p_vkCreateWin32SurfaceKHR = wayland_vkCreateWin32SurfaceKHR,
     .p_vkDestroyInstance = wayland_vkDestroyInstance,
     .p_vkDestroySurfaceKHR = wayland_vkDestroySurfaceKHR,
-- 
2.34.1


From 6a4b3e243d1fb0428301355d78b9e660d9682e8b Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 17 Sep 2021 12:35:30 +0300
Subject: [PATCH 104/147] winewayland.drv: Implement vkDestroySwapchainKHR.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 38 +++++++++++++++++++++++++++++++++++
 1 file changed, 38 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 7e208bf88b8..23b931477d9 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -55,6 +55,7 @@ static VkResult (*pvkCreateSwapchainKHR)(VkDevice, const VkSwapchainCreateInfoKH
 static VkResult (*pvkCreateWaylandSurfaceKHR)(VkInstance, const VkWaylandSurfaceCreateInfoKHR *, const VkAllocationCallbacks *, VkSurfaceKHR *);
 static void (*pvkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
 static void (*pvkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocationCallbacks *);
+static void (*pvkDestroySwapchainKHR)(VkDevice, VkSwapchainKHR, const VkAllocationCallbacks *);
 
 static void *vulkan_handle;
 
@@ -136,6 +137,22 @@ static void wine_vk_swapchain_destroy(struct wine_vk_swapchain *wine_vk_swapchai
     heap_free(wine_vk_swapchain);
 }
 
+static struct wine_vk_swapchain *wine_vk_swapchain_from_handle(VkSurfaceKHR handle)
+{
+    struct wine_vk_swapchain *swap;
+
+    EnterCriticalSection(&wine_vk_object_section);
+
+    wl_list_for_each(swap, &wine_vk_swapchain_list, link)
+        if (swap->native_vk_swapchain == handle) goto out;
+
+    swap = NULL;
+
+out:
+    LeaveCriticalSection(&wine_vk_object_section);
+    return swap;
+}
+
 /* Helper function for converting between win32 and Wayland compatible VkInstanceCreateInfo.
  * Caller is responsible for allocation and cleanup of 'dst'.
  */
@@ -362,6 +379,25 @@ static void wayland_vkDestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surfac
     }
 }
 
+static void wayland_vkDestroySwapchainKHR(VkDevice device,
+                                          VkSwapchainKHR swapchain,
+                                          const VkAllocationCallbacks *allocator)
+{
+    struct wine_vk_swapchain *wine_vk_swapchain = wine_vk_swapchain_from_handle(swapchain);
+
+    TRACE("%p, 0x%s %p\n", device, wine_dbgstr_longlong(swapchain), allocator);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    if (wine_vk_swapchain)
+    {
+        pvkDestroySwapchainKHR(device, wine_vk_swapchain->native_vk_swapchain,
+                               NULL /* allocator */);
+        wine_vk_swapchain_destroy(wine_vk_swapchain);
+    }
+}
+
 static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
 {
     if (!(vulkan_handle = dlopen(SONAME_LIBVULKAN, RTLD_NOW)))
@@ -376,6 +412,7 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
     LOAD_FUNCPTR(vkCreateWaylandSurfaceKHR);
     LOAD_FUNCPTR(vkDestroyInstance);
     LOAD_FUNCPTR(vkDestroySurfaceKHR);
+    LOAD_FUNCPTR(vkDestroySwapchainKHR);
 #undef LOAD_FUNCPTR
 
     return TRUE;
@@ -393,6 +430,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkCreateWin32SurfaceKHR = wayland_vkCreateWin32SurfaceKHR,
     .p_vkDestroyInstance = wayland_vkDestroyInstance,
     .p_vkDestroySurfaceKHR = wayland_vkDestroySurfaceKHR,
+    .p_vkDestroySwapchainKHR = wayland_vkDestroySwapchainKHR,
 };
 
 const struct vulkan_funcs *wayland_get_vulkan_driver(UINT version)
-- 
2.34.1


From 4ec90ad73453bd45edb049b6c2d8598f84da1404 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 17 Sep 2021 13:22:11 +0300
Subject: [PATCH 105/147] winewayland.drv: Implement vkQueuePresentKHR.

Before presenting ensure that the parent Wayland surface of the
subsurface used for VK content has been mapped, otherwise the Vulkan
content won't be visible and will block any throttled/vsynced rendering
loops which rely on wl_frame events.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 86 +++++++++++++++++++++++++++++++++++
 1 file changed, 86 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 23b931477d9..7c7b2491d87 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -56,6 +56,7 @@ static VkResult (*pvkCreateWaylandSurfaceKHR)(VkInstance, const VkWaylandSurface
 static void (*pvkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
 static void (*pvkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocationCallbacks *);
 static void (*pvkDestroySwapchainKHR)(VkDevice, VkSwapchainKHR, const VkAllocationCallbacks *);
+static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
 
@@ -398,6 +399,89 @@ static void wayland_vkDestroySwapchainKHR(VkDevice device,
     }
 }
 
+static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
+{
+    uint32_t i;
+    VkResult res = VK_SUCCESS;
+
+    for (i = 0; i < present_info->swapchainCount; ++i)
+    {
+        const VkSwapchainKHR vk_swapchain = present_info->pSwapchains[i];
+        struct wine_vk_swapchain *wine_vk_swapchain =
+            wine_vk_swapchain_from_handle(vk_swapchain);
+        BOOL drawing_allowed =
+            (wine_vk_swapchain && wine_vk_swapchain->wayland_surface) ?
+            wine_vk_swapchain->wayland_surface->drawing_allowed : TRUE;
+
+        TRACE("swapchain[%d] vk=0x%s wine=%p wayland_surface=%p "
+               "drawing_allowed=%d\n",
+               i, wine_dbgstr_longlong(vk_swapchain), wine_vk_swapchain,
+               wine_vk_swapchain ? wine_vk_swapchain->wayland_surface : NULL,
+               drawing_allowed);
+
+        if (!wine_vk_swapchain)
+            res = VK_ERROR_SURFACE_LOST_KHR;
+        else if (!drawing_allowed)
+            if (res == VK_SUCCESS) res = VK_ERROR_OUT_OF_DATE_KHR;
+
+        /* Since Vulkan content is presented on a Wayland subsurface, we need
+         * to ensure the parent Wayland surface is mapped for the Vulkan
+         * content to be visible. */
+        if (wine_vk_swapchain->wayland_surface && drawing_allowed)
+            wayland_surface_ensure_mapped(wine_vk_swapchain->wayland_surface);
+    }
+
+    /* In case of error in any swapchain, we are not going to present at all,
+     * so mark all swapchains as failures. */
+    if (res != VK_SUCCESS && present_info->pResults)
+    {
+        for (i = 0; i < present_info->swapchainCount; ++i)
+            present_info->pResults[i] = res;
+    }
+
+    return res;
+}
+
+static void lock_swapchain_wayland_surfaces(const VkPresentInfoKHR *present_info,
+                                            BOOL lock)
+{
+    uint32_t i;
+
+    for (i = 0; i < present_info->swapchainCount; ++i)
+    {
+        const VkSwapchainKHR vk_swapchain = present_info->pSwapchains[i];
+        struct wine_vk_swapchain *wine_vk_swapchain =
+            wine_vk_swapchain_from_handle(vk_swapchain);
+
+        if (wine_vk_swapchain && wine_vk_swapchain->wayland_surface)
+        {
+            if (lock)
+                EnterCriticalSection(&wine_vk_swapchain->wayland_surface->crit);
+            else
+                LeaveCriticalSection(&wine_vk_swapchain->wayland_surface->crit);
+        }
+    }
+}
+
+static VkResult wayland_vkQueuePresentKHR(VkQueue queue, const VkPresentInfoKHR *present_info)
+{
+    VkResult res;
+
+    TRACE("%p, %p\n", queue, present_info);
+
+    /* Lock the surfaces to ensure we don't present while reconfiguration is
+     * taking place, so we don't inadvertently commit an in-progress,
+     * incomplete configuration state. */
+    lock_swapchain_wayland_surfaces(present_info, TRUE);
+
+    if ((res = validate_present_info(present_info)) == VK_SUCCESS)
+        res = pvkQueuePresentKHR(queue, present_info);
+
+    lock_swapchain_wayland_surfaces(present_info, FALSE);
+
+    return res;
+}
+
 static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
 {
     if (!(vulkan_handle = dlopen(SONAME_LIBVULKAN, RTLD_NOW)))
@@ -413,6 +497,7 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
     LOAD_FUNCPTR(vkDestroyInstance);
     LOAD_FUNCPTR(vkDestroySurfaceKHR);
     LOAD_FUNCPTR(vkDestroySwapchainKHR);
+    LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
 
     return TRUE;
@@ -431,6 +516,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkDestroyInstance = wayland_vkDestroyInstance,
     .p_vkDestroySurfaceKHR = wayland_vkDestroySurfaceKHR,
     .p_vkDestroySwapchainKHR = wayland_vkDestroySwapchainKHR,
+    .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
 const struct vulkan_funcs *wayland_get_vulkan_driver(UINT version)
-- 
2.34.1


From e0c6d13dad6b71cac4b12c630cb7ebe36d8945fa Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 17 Sep 2021 13:30:46 +0300
Subject: [PATCH 106/147] winewayland.drv: Handle window resizes under Vulkan.

Return the VK_ERROR_OUT_OF_DATE_KHR soft error to notify callers of
vkQueuePresent that the image(s) they are presenting don't match the
current window size.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 18 +++++++++++++++---
 1 file changed, 15 insertions(+), 3 deletions(-)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 7c7b2491d87..2e7267448f5 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -86,6 +86,7 @@ struct wine_vk_swapchain
     HWND hwnd;
     struct wayland_surface *wayland_surface;
     VkSwapchainKHR native_vk_swapchain;
+    VkExtent2D extent;
 };
 
 static inline void wine_vk_list_add(struct wl_list *list, struct wl_list *link)
@@ -273,6 +274,7 @@ static VkResult wayland_vkCreateSwapchainKHR(VkDevice device,
         wine_vk_swapchain->wayland_surface = wine_vk_surface->wayland_surface;
     }
     wine_vk_swapchain->native_vk_swapchain = *swapchain;
+    wine_vk_swapchain->extent = info.imageExtent;
 
     wine_vk_list_add(&wine_vk_swapchain_list, &wine_vk_swapchain->link);
 
@@ -412,17 +414,27 @@ static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
         BOOL drawing_allowed =
             (wine_vk_swapchain && wine_vk_swapchain->wayland_surface) ?
             wine_vk_swapchain->wayland_surface->drawing_allowed : TRUE;
+        RECT client;
 
-        TRACE("swapchain[%d] vk=0x%s wine=%p wayland_surface=%p "
+        TRACE("swapchain[%d] vk=0x%s wine=%p extent=%dx%d wayland_surface=%p "
                "drawing_allowed=%d\n",
                i, wine_dbgstr_longlong(vk_swapchain), wine_vk_swapchain,
+               wine_vk_swapchain ? wine_vk_swapchain->extent.width : 0,
+               wine_vk_swapchain ? wine_vk_swapchain->extent.height : 0,
                wine_vk_swapchain ? wine_vk_swapchain->wayland_surface : NULL,
                drawing_allowed);
 
-        if (!wine_vk_swapchain)
+        if (!wine_vk_swapchain ||
+            !GetClientRect(wine_vk_swapchain->hwnd, &client))
+        {
             res = VK_ERROR_SURFACE_LOST_KHR;
-        else if (!drawing_allowed)
+        }
+        else if (client.right != wine_vk_swapchain->extent.width ||
+                 client.bottom != wine_vk_swapchain->extent.height ||
+                 !drawing_allowed)
+        {
             if (res == VK_SUCCESS) res = VK_ERROR_OUT_OF_DATE_KHR;
+        }
 
         /* Since Vulkan content is presented on a Wayland subsurface, we need
          * to ensure the parent Wayland surface is mapped for the Vulkan
-- 
2.34.1


From 92a4de3fc984f819eb12a37cb89e47a530d72f1c Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 10:43:33 +0300
Subject: [PATCH 107/147] winewayland.drv: Add mechanism to invalidate Vulkan
 objects.

When the Wayland surface associated with a Vulkan surface or swapchain
is scheduled for destruction, we mark such Vulkan objects as invalidated
in the driver and callers are notified with the
VK_ERROR_SURFACE_LOST_KHR hard error when they try to use such objects.

Note that the Vulkan objects hold a reference to the associated Wayland
surface, so there is no danger of time-of-check to time-of-use (TOCTOU)
related bugs/races when checking for invalidation.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c     | 35 ++++++++++++++++++++++++++++++-
 dlls/winewayland.drv/waylanddrv.h |  1 +
 2 files changed, 35 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 2e7267448f5..1e1f5569d9e 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -78,6 +78,7 @@ struct wine_vk_surface
     HWND hwnd;
     struct wayland_surface *wayland_surface;
     VkSurfaceKHR native_vk_surface;
+    BOOL valid;
 };
 
 struct wine_vk_swapchain
@@ -87,6 +88,7 @@ struct wine_vk_swapchain
     struct wayland_surface *wayland_surface;
     VkSwapchainKHR native_vk_swapchain;
     VkExtent2D extent;
+    BOOL valid;
 };
 
 static inline void wine_vk_list_add(struct wl_list *list, struct wl_list *link)
@@ -254,7 +256,7 @@ static VkResult wayland_vkCreateSwapchainKHR(VkDevice device,
         info.imageExtent.height = 1;
 
     wine_vk_surface = wine_vk_surface_from_handle(info.surface);
-    if (!wine_vk_surface)
+    if (!wine_vk_surface || !__atomic_load_n(&wine_vk_surface->valid, __ATOMIC_SEQ_CST))
         RETURN_VK_ERROR_SURFACE_LOST_KHR;
 
     wine_vk_swapchain = heap_alloc_zero(sizeof(*wine_vk_swapchain));
@@ -275,6 +277,7 @@ static VkResult wayland_vkCreateSwapchainKHR(VkDevice device,
     }
     wine_vk_swapchain->native_vk_swapchain = *swapchain;
     wine_vk_swapchain->extent = info.imageExtent;
+    wine_vk_swapchain->valid = TRUE;
 
     wine_vk_list_add(&wine_vk_swapchain_list, &wine_vk_swapchain->link);
 
@@ -343,6 +346,7 @@ static VkResult wayland_vkCreateWin32SurfaceKHR(VkInstance instance,
 
     wine_vk_surface->hwnd = create_info->hwnd;
     wine_vk_surface->native_vk_surface = *vk_surface;
+    wine_vk_surface->valid = TRUE;
 
     wine_vk_list_add(&wine_vk_surface_list, &wine_vk_surface->link);
 
@@ -425,6 +429,7 @@ static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
                drawing_allowed);
 
         if (!wine_vk_swapchain ||
+            !__atomic_load_n(&wine_vk_swapchain->valid, __ATOMIC_SEQ_CST) ||
             !GetClientRect(wine_vk_swapchain->hwnd, &client))
         {
             res = VK_ERROR_SURFACE_LOST_KHR;
@@ -548,6 +553,30 @@ const struct vulkan_funcs *wayland_get_vulkan_driver(UINT version)
     return NULL;
 }
 
+void wayland_invalidate_vulkan_objects(HWND hwnd)
+{
+    struct wine_vk_swapchain *swap;
+    struct wine_vk_surface *surf;
+
+    TRACE("hwnd=%p\n", hwnd);
+
+    EnterCriticalSection(&wine_vk_object_section);
+
+    wl_list_for_each(swap, &wine_vk_swapchain_list, link)
+    {
+        if (swap->hwnd == hwnd)
+            __atomic_store_n(&swap->valid, FALSE, __ATOMIC_SEQ_CST);
+    }
+
+    wl_list_for_each(surf, &wine_vk_surface_list, link)
+    {
+        if (surf->hwnd == hwnd)
+            __atomic_store_n(&surf->valid, FALSE, __ATOMIC_SEQ_CST);
+    }
+
+    LeaveCriticalSection(&wine_vk_object_section);
+}
+
 #else /* No vulkan */
 
 const struct vulkan_funcs *wayland_get_vulkan_driver(UINT version)
@@ -556,4 +585,8 @@ const struct vulkan_funcs *wayland_get_vulkan_driver(UINT version)
     return NULL;
 }
 
+void wayland_invalidate_vulkan_objects(HWND hwnd)
+{
+}
+
 #endif /* SONAME_LIBVULKAN */
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 220712f687b..beb8df211eb 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -470,6 +470,7 @@ void wayland_update_front_buffer(HWND hwnd,
  */
 
 const struct vulkan_funcs *wayland_get_vulkan_driver(UINT version);
+void wayland_invalidate_vulkan_objects(HWND hwnd);
 
 /**********************************************************************
  *          XKB helpers
-- 
2.34.1


From ce3a9d6804b22b31fd2f25d39d646cbc3cd7d8a0 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 10:34:43 +0300
Subject: [PATCH 108/147] winewayland.drv: Implement
 vkEnumerateInstanceExtensionProperties.

Return the native instance extension properties, substituting
VK_KHR_wayland_surface for VK_KHR_win32_surface.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 45 +++++++++++++++++++++++++++++++++++
 1 file changed, 45 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 1e1f5569d9e..8ef327a7802 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -56,6 +56,7 @@ static VkResult (*pvkCreateWaylandSurfaceKHR)(VkInstance, const VkWaylandSurface
 static void (*pvkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
 static void (*pvkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocationCallbacks *);
 static void (*pvkDestroySwapchainKHR)(VkDevice, VkSwapchainKHR, const VkAllocationCallbacks *);
+static VkResult (*pvkEnumerateInstanceExtensionProperties)(const char *, uint32_t *, VkExtensionProperties *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
@@ -405,6 +406,48 @@ static void wayland_vkDestroySwapchainKHR(VkDevice device,
     }
 }
 
+static VkResult wayland_vkEnumerateInstanceExtensionProperties(const char *layer_name,
+                                                               uint32_t *count,
+                                                               VkExtensionProperties* properties)
+{
+    unsigned int i;
+    VkResult res;
+
+    TRACE("layer_name %s, count %p, properties %p\n", debugstr_a(layer_name), count, properties);
+
+    /* This shouldn't get called with layer_name set, the ICD loader prevents it. */
+    if (layer_name)
+    {
+        ERR("Layer enumeration not supported from ICD.\n");
+        return VK_ERROR_LAYER_NOT_PRESENT;
+    }
+
+    /* We will return the same number of instance extensions reported by the host back to
+     * winevulkan. Along the way we may replace xlib extensions with their win32 equivalents.
+     * Winevulkan will perform more detailed filtering as it knows whether it has thunks
+     * for a particular extension.
+     */
+    res = pvkEnumerateInstanceExtensionProperties(layer_name, count, properties);
+    if (!properties || res < 0)
+        return res;
+
+    for (i = 0; i < *count; i++)
+    {
+        /* For now the only wayland extension we need to fixup. Long-term we may need an array. */
+        if (!strcmp(properties[i].extensionName, "VK_KHR_wayland_surface"))
+        {
+            TRACE("Substituting VK_KHR_wayland_surface for VK_KHR_win32_surface\n");
+
+            snprintf(properties[i].extensionName, sizeof(properties[i].extensionName),
+                    VK_KHR_WIN32_SURFACE_EXTENSION_NAME);
+            properties[i].specVersion = VK_KHR_WIN32_SURFACE_SPEC_VERSION;
+        }
+    }
+
+    TRACE("Returning %u extensions.\n", *count);
+    return res;
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -514,6 +557,7 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
     LOAD_FUNCPTR(vkDestroyInstance);
     LOAD_FUNCPTR(vkDestroySurfaceKHR);
     LOAD_FUNCPTR(vkDestroySwapchainKHR);
+    LOAD_FUNCPTR(vkEnumerateInstanceExtensionProperties);
     LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
 
@@ -533,6 +577,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkDestroyInstance = wayland_vkDestroyInstance,
     .p_vkDestroySurfaceKHR = wayland_vkDestroySurfaceKHR,
     .p_vkDestroySwapchainKHR = wayland_vkDestroySwapchainKHR,
+    .p_vkEnumerateInstanceExtensionProperties = wayland_vkEnumerateInstanceExtensionProperties,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
-- 
2.34.1


From bbcef7be6b2bff86097a4f9c60f455e6608f4994 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 12:58:45 +0300
Subject: [PATCH 109/147] winewayland.drv: Implement
 vkGetDeviceGroupSurfacePresentModesKHR.

This is a simple passthrough implementation to the native Vulkan driver,
with the addition of a VkSurfaceKHR invalidation check.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 23 +++++++++++++++++++++++
 1 file changed, 23 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 8ef327a7802..5bc44592667 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -57,6 +57,7 @@ static void (*pvkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
 static void (*pvkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocationCallbacks *);
 static void (*pvkDestroySwapchainKHR)(VkDevice, VkSwapchainKHR, const VkAllocationCallbacks *);
 static VkResult (*pvkEnumerateInstanceExtensionProperties)(const char *, uint32_t *, VkExtensionProperties *);
+static VkResult (*pvkGetDeviceGroupSurfacePresentModesKHR)(VkDevice, VkSurfaceKHR, VkDeviceGroupPresentModeFlagsKHR *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
@@ -132,6 +133,12 @@ out:
     return surf;
 }
 
+static BOOL wine_vk_surface_handle_is_valid(VkSurfaceKHR handle)
+{
+    struct wine_vk_surface *wine_vk_surface = wine_vk_surface_from_handle(handle);
+    return wine_vk_surface && __atomic_load_n(&wine_vk_surface->valid, __ATOMIC_SEQ_CST);
+}
+
 static void wine_vk_swapchain_destroy(struct wine_vk_swapchain *wine_vk_swapchain)
 {
     wine_vk_list_remove(&wine_vk_swapchain->link);
@@ -448,6 +455,18 @@ static VkResult wayland_vkEnumerateInstanceExtensionProperties(const char *layer
     return res;
 }
 
+static VkResult wayland_vkGetDeviceGroupSurfacePresentModesKHR(VkDevice device,
+                                                               VkSurfaceKHR surface,
+                                                               VkDeviceGroupPresentModeFlagsKHR *flags)
+{
+    TRACE("%p, 0x%s, %p\n", device, wine_dbgstr_longlong(surface), flags);
+
+    if (!wine_vk_surface_handle_is_valid(surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    return pvkGetDeviceGroupSurfacePresentModesKHR(device, surface, flags);
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -551,6 +570,7 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
     }
 
 #define LOAD_FUNCPTR(f) if (!(p##f = dlsym(vulkan_handle, #f))) goto fail
+#define LOAD_OPTIONAL_FUNCPTR(f) p##f = dlsym(vulkan_handle, #f)
     LOAD_FUNCPTR(vkCreateInstance);
     LOAD_FUNCPTR(vkCreateSwapchainKHR);
     LOAD_FUNCPTR(vkCreateWaylandSurfaceKHR);
@@ -558,8 +578,10 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
     LOAD_FUNCPTR(vkDestroySurfaceKHR);
     LOAD_FUNCPTR(vkDestroySwapchainKHR);
     LOAD_FUNCPTR(vkEnumerateInstanceExtensionProperties);
+    LOAD_OPTIONAL_FUNCPTR(vkGetDeviceGroupSurfacePresentModesKHR);
     LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
+#undef LOAD_OPTIONAL_FUNCPTR
 
     return TRUE;
 
@@ -578,6 +600,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkDestroySurfaceKHR = wayland_vkDestroySurfaceKHR,
     .p_vkDestroySwapchainKHR = wayland_vkDestroySwapchainKHR,
     .p_vkEnumerateInstanceExtensionProperties = wayland_vkEnumerateInstanceExtensionProperties,
+    .p_vkGetDeviceGroupSurfacePresentModesKHR = wayland_vkGetDeviceGroupSurfacePresentModesKHR,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
-- 
2.34.1


From fe52400fb965e5ea7a8244b9667cb8e75cd8b20d Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 10:56:18 +0300
Subject: [PATCH 110/147] winewayland.drv: Implement vkGetDeviceProcAddr and
 vkGetInstanceProcAddr.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 32 ++++++++++++++++++++++++++++++++
 1 file changed, 32 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 5bc44592667..b3bec899b0c 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -58,6 +58,8 @@ static void (*pvkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocation
 static void (*pvkDestroySwapchainKHR)(VkDevice, VkSwapchainKHR, const VkAllocationCallbacks *);
 static VkResult (*pvkEnumerateInstanceExtensionProperties)(const char *, uint32_t *, VkExtensionProperties *);
 static VkResult (*pvkGetDeviceGroupSurfacePresentModesKHR)(VkDevice, VkSurfaceKHR, VkDeviceGroupPresentModeFlagsKHR *);
+static void * (*pvkGetDeviceProcAddr)(VkDevice, const char *);
+static void * (*pvkGetInstanceProcAddr)(VkInstance, const char *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
@@ -74,6 +76,8 @@ static CRITICAL_SECTION wine_vk_object_section = { &critsect_debug, -1, 0, 0, 0,
 static struct wl_list wine_vk_surface_list = { &wine_vk_surface_list, &wine_vk_surface_list };
 static struct wl_list wine_vk_swapchain_list = { &wine_vk_swapchain_list, &wine_vk_swapchain_list };
 
+static const struct vulkan_funcs vulkan_funcs;
+
 struct wine_vk_surface
 {
     struct wl_list link;
@@ -467,6 +471,30 @@ static VkResult wayland_vkGetDeviceGroupSurfacePresentModesKHR(VkDevice device,
     return pvkGetDeviceGroupSurfacePresentModesKHR(device, surface, flags);
 }
 
+static void *wayland_vkGetDeviceProcAddr(VkDevice device, const char *name)
+{
+    void *proc_addr;
+
+    TRACE("%p, %s\n", device, debugstr_a(name));
+
+    if ((proc_addr = get_vulkan_driver_device_proc_addr(&vulkan_funcs, name)))
+        return proc_addr;
+
+    return pvkGetDeviceProcAddr(device, name);
+}
+
+static void *wayland_vkGetInstanceProcAddr(VkInstance instance, const char *name)
+{
+    void *proc_addr;
+
+    TRACE("%p, %s\n", instance, debugstr_a(name));
+
+    if ((proc_addr = get_vulkan_driver_instance_proc_addr(&vulkan_funcs, instance, name)))
+        return proc_addr;
+
+    return pvkGetInstanceProcAddr(instance, name);
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -579,6 +607,8 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
     LOAD_FUNCPTR(vkDestroySwapchainKHR);
     LOAD_FUNCPTR(vkEnumerateInstanceExtensionProperties);
     LOAD_OPTIONAL_FUNCPTR(vkGetDeviceGroupSurfacePresentModesKHR);
+    LOAD_FUNCPTR(vkGetDeviceProcAddr);
+    LOAD_FUNCPTR(vkGetInstanceProcAddr);
     LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
 #undef LOAD_OPTIONAL_FUNCPTR
@@ -601,6 +631,8 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkDestroySwapchainKHR = wayland_vkDestroySwapchainKHR,
     .p_vkEnumerateInstanceExtensionProperties = wayland_vkEnumerateInstanceExtensionProperties,
     .p_vkGetDeviceGroupSurfacePresentModesKHR = wayland_vkGetDeviceGroupSurfacePresentModesKHR,
+    .p_vkGetDeviceProcAddr = wayland_vkGetDeviceProcAddr,
+    .p_vkGetInstanceProcAddr = wayland_vkGetInstanceProcAddr,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
-- 
2.34.1


From 44da430ae4ab5f16ac47ee4d45829ea47858fd88 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 11:04:58 +0300
Subject: [PATCH 111/147] winewayland.drv: Implement
 vkGetPhysicalDevicePresentRectanglesKHR.

This is a simple passthrough implementation to the native Vulkan driver.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index b3bec899b0c..3c1523e31e6 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -60,6 +60,7 @@ static VkResult (*pvkEnumerateInstanceExtensionProperties)(const char *, uint32_
 static VkResult (*pvkGetDeviceGroupSurfacePresentModesKHR)(VkDevice, VkSurfaceKHR, VkDeviceGroupPresentModeFlagsKHR *);
 static void * (*pvkGetDeviceProcAddr)(VkDevice, const char *);
 static void * (*pvkGetInstanceProcAddr)(VkInstance, const char *);
+static VkResult (*pvkGetPhysicalDevicePresentRectanglesKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkRect2D *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
@@ -495,6 +496,15 @@ static void *wayland_vkGetInstanceProcAddr(VkInstance instance, const char *name
     return pvkGetInstanceProcAddr(instance, name);
 }
 
+static VkResult wayland_vkGetPhysicalDevicePresentRectanglesKHR(VkPhysicalDevice phys_dev,
+                                                                VkSurfaceKHR surface,
+                                                                uint32_t *count, VkRect2D *rects)
+{
+    TRACE("%p, 0x%s, %p, %p\n", phys_dev, wine_dbgstr_longlong(surface), count, rects);
+
+    return pvkGetPhysicalDevicePresentRectanglesKHR(phys_dev, surface, count, rects);
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -609,6 +619,7 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
     LOAD_OPTIONAL_FUNCPTR(vkGetDeviceGroupSurfacePresentModesKHR);
     LOAD_FUNCPTR(vkGetDeviceProcAddr);
     LOAD_FUNCPTR(vkGetInstanceProcAddr);
+    LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDevicePresentRectanglesKHR);
     LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
 #undef LOAD_OPTIONAL_FUNCPTR
@@ -633,6 +644,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkGetDeviceGroupSurfacePresentModesKHR = wayland_vkGetDeviceGroupSurfacePresentModesKHR,
     .p_vkGetDeviceProcAddr = wayland_vkGetDeviceProcAddr,
     .p_vkGetInstanceProcAddr = wayland_vkGetInstanceProcAddr,
+    .p_vkGetPhysicalDevicePresentRectanglesKHR = wayland_vkGetPhysicalDevicePresentRectanglesKHR,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
-- 
2.34.1


From ab9d6b8b95608db9ac409c377f60f3d9a220d071 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 11:11:41 +0300
Subject: [PATCH 112/147] winewayland.drv: Implement
 vkGetPhysicalDeviceSurfaceCapabilities(2)KHR.

Passthrough implementations with three additions:

1. Checking for invalidated VkSurfaceKHR.
2. Try to emulate vkGetPhysicalDeviceSurfaceCapabilities2KHR with
   vkGetPhysicalDeviceSurfaceCapabilitiesKHR if needed.
3. Set the capabilities' image extent values to match what the Vulkan Win32 WSI
   typically provides.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 106 ++++++++++++++++++++++++++++++++++
 1 file changed, 106 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 3c1523e31e6..57ac6e6b239 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -61,6 +61,8 @@ static VkResult (*pvkGetDeviceGroupSurfacePresentModesKHR)(VkDevice, VkSurfaceKH
 static void * (*pvkGetDeviceProcAddr)(VkDevice, const char *);
 static void * (*pvkGetInstanceProcAddr)(VkInstance, const char *);
 static VkResult (*pvkGetPhysicalDevicePresentRectanglesKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkRect2D *);
+static VkResult (*pvkGetPhysicalDeviceSurfaceCapabilities2KHR)(VkPhysicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *, VkSurfaceCapabilities2KHR *);
+static VkResult (*pvkGetPhysicalDeviceSurfaceCapabilitiesKHR)(VkPhysicalDevice, VkSurfaceKHR, VkSurfaceCapabilitiesKHR *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
@@ -505,6 +507,106 @@ static VkResult wayland_vkGetPhysicalDevicePresentRectanglesKHR(VkPhysicalDevice
     return pvkGetPhysicalDevicePresentRectanglesKHR(phys_dev, surface, count, rects);
 }
 
+/* Set the image extent in the capabilities to match what Windows expects. */
+static void set_image_extent(VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR *caps)
+{
+    struct wine_vk_surface *wine_vk_surface = wine_vk_surface_from_handle(surface);
+    BOOL zero_extents = FALSE;
+
+    if (!wine_vk_surface || !wine_vk_surface->wayland_surface)
+        return;
+
+    EnterCriticalSection(&wine_vk_surface->wayland_surface->crit);
+    if (!wine_vk_surface->wayland_surface->drawing_allowed)
+        zero_extents = TRUE;
+    LeaveCriticalSection(&wine_vk_surface->wayland_surface->crit);
+
+    if (IsIconic(wine_vk_surface->hwnd))
+        zero_extents = TRUE;
+
+    if (zero_extents)
+    {
+        caps->minImageExtent.width = 0;
+        caps->minImageExtent.height = 0;
+        caps->maxImageExtent.width = 0;
+        caps->maxImageExtent.height = 0;
+        caps->currentExtent.width = 0;
+        caps->currentExtent.height = 0;
+    }
+    else
+    {
+        RECT client;
+        GetClientRect(wine_vk_surface->hwnd, &client);
+
+        caps->minImageExtent.width = client.right;
+        caps->minImageExtent.height = client.bottom;
+        caps->maxImageExtent.width = client.right;
+        caps->maxImageExtent.height = client.bottom;
+        caps->currentExtent.width = client.right;
+        caps->currentExtent.height = client.bottom;
+    }
+
+    TRACE("vk_surface=%s hwnd=%p wayland_surface=%p extent=%dx%d\n",
+          wine_dbgstr_longlong(surface), wine_vk_surface->hwnd,
+          wine_vk_surface->wayland_surface, caps->currentExtent.width,
+          caps->currentExtent.height);
+}
+
+static VkResult wayland_vkGetPhysicalDeviceSurfaceCapabilities2KHR(VkPhysicalDevice phys_dev,
+                                                                   const VkPhysicalDeviceSurfaceInfo2KHR *surface_info,
+                                                                   VkSurfaceCapabilities2KHR *capabilities)
+{
+    VkResult res;
+
+    TRACE("%p, %p, %p\n", phys_dev, surface_info, capabilities);
+
+    if (!wine_vk_surface_handle_is_valid(surface_info->surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    if (pvkGetPhysicalDeviceSurfaceCapabilities2KHR)
+    {
+        res = pvkGetPhysicalDeviceSurfaceCapabilities2KHR(phys_dev, surface_info,
+                                                          capabilities);
+        goto out;
+    }
+
+    /* Until the loader version exporting this function is common, emulate it
+     * using the older non-2 version. */
+    if (surface_info->pNext || capabilities->pNext)
+    {
+        FIXME("Emulating vkGetPhysicalDeviceSurfaceCapabilities2KHR with "
+              "vkGetPhysicalDeviceSurfaceCapabilitiesKHR, pNext is ignored.\n");
+    }
+
+    res = pvkGetPhysicalDeviceSurfaceCapabilitiesKHR(phys_dev, surface_info->surface,
+                                                     &capabilities->surfaceCapabilities);
+
+out:
+    if (res == VK_SUCCESS)
+        set_image_extent(surface_info->surface, &capabilities->surfaceCapabilities);
+
+    return res;
+}
+
+static VkResult wayland_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice phys_dev,
+                                                                  VkSurfaceKHR surface,
+                                                                  VkSurfaceCapabilitiesKHR *capabilities)
+{
+    VkResult res;
+
+    TRACE("%p, 0x%s, %p\n", phys_dev, wine_dbgstr_longlong(surface), capabilities);
+
+    if (!wine_vk_surface_handle_is_valid(surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    res = pvkGetPhysicalDeviceSurfaceCapabilitiesKHR(phys_dev, surface, capabilities);
+
+    if (res == VK_SUCCESS)
+        set_image_extent(surface, capabilities);
+
+    return res;
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -620,6 +722,8 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
     LOAD_FUNCPTR(vkGetDeviceProcAddr);
     LOAD_FUNCPTR(vkGetInstanceProcAddr);
     LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDevicePresentRectanglesKHR);
+    LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDeviceSurfaceCapabilities2KHR);
+    LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceCapabilitiesKHR);
     LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
 #undef LOAD_OPTIONAL_FUNCPTR
@@ -645,6 +749,8 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkGetDeviceProcAddr = wayland_vkGetDeviceProcAddr,
     .p_vkGetInstanceProcAddr = wayland_vkGetInstanceProcAddr,
     .p_vkGetPhysicalDevicePresentRectanglesKHR = wayland_vkGetPhysicalDevicePresentRectanglesKHR,
+    .p_vkGetPhysicalDeviceSurfaceCapabilities2KHR = wayland_vkGetPhysicalDeviceSurfaceCapabilities2KHR,
+    .p_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = wayland_vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
-- 
2.34.1


From a5adc3162ffc0bebcd8cb1f165a8bf42d68b41d6 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 12:27:03 +0300
Subject: [PATCH 113/147] winewayland.drv: Implement
 vkGetPhysicalDeviceSurfaceFormats(2)KHR.

Passthrough implementations with two additions:

1. Checking for invalidated VkSurfaceKHR.
2. Try to emulate vkGetPhysicalDeviceSurfaceFormats2KHR with
   vkGetPhysicalDeviceSurfaceFormatsKHR if needed.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 66 +++++++++++++++++++++++++++++++++++
 1 file changed, 66 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 57ac6e6b239..a4c680215cb 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -63,6 +63,8 @@ static void * (*pvkGetInstanceProcAddr)(VkInstance, const char *);
 static VkResult (*pvkGetPhysicalDevicePresentRectanglesKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkRect2D *);
 static VkResult (*pvkGetPhysicalDeviceSurfaceCapabilities2KHR)(VkPhysicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *, VkSurfaceCapabilities2KHR *);
 static VkResult (*pvkGetPhysicalDeviceSurfaceCapabilitiesKHR)(VkPhysicalDevice, VkSurfaceKHR, VkSurfaceCapabilitiesKHR *);
+static VkResult (*pvkGetPhysicalDeviceSurfaceFormats2KHR)(VkPhysicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *, uint32_t *, VkSurfaceFormat2KHR *);
+static VkResult (*pvkGetPhysicalDeviceSurfaceFormatsKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkSurfaceFormatKHR *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
@@ -607,6 +609,66 @@ static VkResult wayland_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevi
     return res;
 }
 
+static VkResult wayland_vkGetPhysicalDeviceSurfaceFormats2KHR(VkPhysicalDevice phys_dev,
+                                                              const VkPhysicalDeviceSurfaceInfo2KHR *surface_info,
+                                                              uint32_t *count,
+                                                              VkSurfaceFormat2KHR *formats)
+{
+    VkSurfaceFormatKHR *formats_host;
+    uint32_t i;
+    VkResult result;
+    TRACE("%p, %p, %p, %p\n", phys_dev, surface_info, count, formats);
+
+    if (!wine_vk_surface_handle_is_valid(surface_info->surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    if (pvkGetPhysicalDeviceSurfaceFormats2KHR)
+    {
+        return pvkGetPhysicalDeviceSurfaceFormats2KHR(phys_dev, surface_info,
+                                                      count, formats);
+    }
+
+    /* Until the loader version exporting this function is common, emulate it
+     * using the older non-2 version. */
+    if (surface_info->pNext)
+    {
+        FIXME("Emulating vkGetPhysicalDeviceSurfaceFormats2KHR with "
+              "vkGetPhysicalDeviceSurfaceFormatsKHR, pNext is ignored.\n");
+    }
+
+    if (!formats)
+    {
+        return pvkGetPhysicalDeviceSurfaceFormatsKHR(phys_dev, surface_info->surface,
+                                                     count, NULL);
+    }
+
+    formats_host = heap_calloc(*count, sizeof(*formats_host));
+    if (!formats_host) return VK_ERROR_OUT_OF_HOST_MEMORY;
+    result = pvkGetPhysicalDeviceSurfaceFormatsKHR(phys_dev, surface_info->surface,
+                                                   count, formats_host);
+    if (result == VK_SUCCESS || result == VK_INCOMPLETE)
+    {
+        for (i = 0; i < *count; i++)
+            formats[i].surfaceFormat = formats_host[i];
+    }
+
+    heap_free(formats_host);
+    return result;
+}
+
+static VkResult wayland_vkGetPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice phys_dev,
+                                                             VkSurfaceKHR surface,
+                                                             uint32_t *count,
+                                                             VkSurfaceFormatKHR *formats)
+{
+    TRACE("%p, 0x%s, %p, %p\n", phys_dev, wine_dbgstr_longlong(surface), count, formats);
+
+    if (!wine_vk_surface_handle_is_valid(surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    return pvkGetPhysicalDeviceSurfaceFormatsKHR(phys_dev, surface, count, formats);
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -724,6 +786,8 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
     LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDevicePresentRectanglesKHR);
     LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDeviceSurfaceCapabilities2KHR);
     LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceCapabilitiesKHR);
+    LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDeviceSurfaceFormats2KHR);
+    LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceFormatsKHR);
     LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
 #undef LOAD_OPTIONAL_FUNCPTR
@@ -751,6 +815,8 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkGetPhysicalDevicePresentRectanglesKHR = wayland_vkGetPhysicalDevicePresentRectanglesKHR,
     .p_vkGetPhysicalDeviceSurfaceCapabilities2KHR = wayland_vkGetPhysicalDeviceSurfaceCapabilities2KHR,
     .p_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = wayland_vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
+    .p_vkGetPhysicalDeviceSurfaceFormats2KHR = wayland_vkGetPhysicalDeviceSurfaceFormats2KHR,
+    .p_vkGetPhysicalDeviceSurfaceFormatsKHR = wayland_vkGetPhysicalDeviceSurfaceFormatsKHR,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
-- 
2.34.1


From d68e5f9c556910d7729c9ceadcbee44a7ba97831 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 12:40:48 +0300
Subject: [PATCH 114/147] winewayland.drv: Implement
 vkGetPhysicalDeviceSurfacePresentModesKHR

This is a simple passthrough implementation to the native Vulkan driver,
with the addition of a VkSurfaceKHR invalidation check.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index a4c680215cb..2bcaf4bcdec 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -65,6 +65,7 @@ static VkResult (*pvkGetPhysicalDeviceSurfaceCapabilities2KHR)(VkPhysicalDevice,
 static VkResult (*pvkGetPhysicalDeviceSurfaceCapabilitiesKHR)(VkPhysicalDevice, VkSurfaceKHR, VkSurfaceCapabilitiesKHR *);
 static VkResult (*pvkGetPhysicalDeviceSurfaceFormats2KHR)(VkPhysicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *, uint32_t *, VkSurfaceFormat2KHR *);
 static VkResult (*pvkGetPhysicalDeviceSurfaceFormatsKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkSurfaceFormatKHR *);
+static VkResult (*pvkGetPhysicalDeviceSurfacePresentModesKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkPresentModeKHR *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
@@ -669,6 +670,19 @@ static VkResult wayland_vkGetPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice ph
     return pvkGetPhysicalDeviceSurfaceFormatsKHR(phys_dev, surface, count, formats);
 }
 
+static VkResult wayland_vkGetPhysicalDeviceSurfacePresentModesKHR(VkPhysicalDevice phys_dev,
+                                                                  VkSurfaceKHR surface,
+                                                                  uint32_t *count,
+                                                                  VkPresentModeKHR *modes)
+{
+    TRACE("%p, 0x%s, %p, %p\n", phys_dev, wine_dbgstr_longlong(surface), count, modes);
+
+    if (!wine_vk_surface_handle_is_valid(surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    return pvkGetPhysicalDeviceSurfacePresentModesKHR(phys_dev, surface, count, modes);
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -788,6 +802,7 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
     LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceCapabilitiesKHR);
     LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDeviceSurfaceFormats2KHR);
     LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceFormatsKHR);
+    LOAD_FUNCPTR(vkGetPhysicalDeviceSurfacePresentModesKHR);
     LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
 #undef LOAD_OPTIONAL_FUNCPTR
@@ -817,6 +832,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = wayland_vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
     .p_vkGetPhysicalDeviceSurfaceFormats2KHR = wayland_vkGetPhysicalDeviceSurfaceFormats2KHR,
     .p_vkGetPhysicalDeviceSurfaceFormatsKHR = wayland_vkGetPhysicalDeviceSurfaceFormatsKHR,
+    .p_vkGetPhysicalDeviceSurfacePresentModesKHR = wayland_vkGetPhysicalDeviceSurfacePresentModesKHR,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
-- 
2.34.1


From 8b762a76e2436ee939818a8b0b2a508c25d4c054 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 12:42:03 +0300
Subject: [PATCH 115/147] winewayland.drv: Implement
 vkGetPhysicalDeviceSurfaceSupportKHR.

This is a simple passthrough implementation to the native Vulkan driver,
with the addition of a VkSurfaceKHR invalidation check.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 2bcaf4bcdec..3f045d6dbc8 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -66,6 +66,7 @@ static VkResult (*pvkGetPhysicalDeviceSurfaceCapabilitiesKHR)(VkPhysicalDevice,
 static VkResult (*pvkGetPhysicalDeviceSurfaceFormats2KHR)(VkPhysicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *, uint32_t *, VkSurfaceFormat2KHR *);
 static VkResult (*pvkGetPhysicalDeviceSurfaceFormatsKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkSurfaceFormatKHR *);
 static VkResult (*pvkGetPhysicalDeviceSurfacePresentModesKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkPresentModeKHR *);
+static VkResult (*pvkGetPhysicalDeviceSurfaceSupportKHR)(VkPhysicalDevice, uint32_t, VkSurfaceKHR, VkBool32 *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
@@ -683,6 +684,19 @@ static VkResult wayland_vkGetPhysicalDeviceSurfacePresentModesKHR(VkPhysicalDevi
     return pvkGetPhysicalDeviceSurfacePresentModesKHR(phys_dev, surface, count, modes);
 }
 
+static VkResult wayland_vkGetPhysicalDeviceSurfaceSupportKHR(VkPhysicalDevice phys_dev,
+                                                             uint32_t index,
+                                                             VkSurfaceKHR surface,
+                                                             VkBool32 *supported)
+{
+    TRACE("%p, %u, 0x%s, %p\n", phys_dev, index, wine_dbgstr_longlong(surface), supported);
+
+    if (!wine_vk_surface_handle_is_valid(surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    return pvkGetPhysicalDeviceSurfaceSupportKHR(phys_dev, index, surface, supported);
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -803,6 +817,7 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
     LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDeviceSurfaceFormats2KHR);
     LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceFormatsKHR);
     LOAD_FUNCPTR(vkGetPhysicalDeviceSurfacePresentModesKHR);
+    LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceSupportKHR);
     LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
 #undef LOAD_OPTIONAL_FUNCPTR
@@ -833,6 +848,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkGetPhysicalDeviceSurfaceFormats2KHR = wayland_vkGetPhysicalDeviceSurfaceFormats2KHR,
     .p_vkGetPhysicalDeviceSurfaceFormatsKHR = wayland_vkGetPhysicalDeviceSurfaceFormatsKHR,
     .p_vkGetPhysicalDeviceSurfacePresentModesKHR = wayland_vkGetPhysicalDeviceSurfacePresentModesKHR,
+    .p_vkGetPhysicalDeviceSurfaceSupportKHR = wayland_vkGetPhysicalDeviceSurfaceSupportKHR,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
-- 
2.34.1


From fe650c9ad98d5765183437587891181d0d0c2585 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 12:45:12 +0300
Subject: [PATCH 116/147] winewayland.drv: Implement
 vkGetPhysicalDeviceWin32PresentationSupportKHR.

This is a simple passthrough implementation to the corresponding Vulkan
Wayland extension.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 3f045d6dbc8..616c09f0167 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -67,6 +67,7 @@ static VkResult (*pvkGetPhysicalDeviceSurfaceFormats2KHR)(VkPhysicalDevice, cons
 static VkResult (*pvkGetPhysicalDeviceSurfaceFormatsKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkSurfaceFormatKHR *);
 static VkResult (*pvkGetPhysicalDeviceSurfacePresentModesKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkPresentModeKHR *);
 static VkResult (*pvkGetPhysicalDeviceSurfaceSupportKHR)(VkPhysicalDevice, uint32_t, VkSurfaceKHR, VkBool32 *);
+static VkBool32 (*pvkGetPhysicalDeviceWaylandPresentationSupportKHR)(VkPhysicalDevice, uint32_t, struct wl_display *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
@@ -697,6 +698,15 @@ static VkResult wayland_vkGetPhysicalDeviceSurfaceSupportKHR(VkPhysicalDevice ph
     return pvkGetPhysicalDeviceSurfaceSupportKHR(phys_dev, index, surface, supported);
 }
 
+static VkBool32 wayland_vkGetPhysicalDeviceWin32PresentationSupportKHR(VkPhysicalDevice phys_dev,
+                                                                       uint32_t index)
+{
+    TRACE("%p %u\n", phys_dev, index);
+
+    return pvkGetPhysicalDeviceWaylandPresentationSupportKHR(phys_dev, index,
+                                                             process_wl_display);
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -818,6 +828,7 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
     LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceFormatsKHR);
     LOAD_FUNCPTR(vkGetPhysicalDeviceSurfacePresentModesKHR);
     LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceSupportKHR);
+    LOAD_FUNCPTR(vkGetPhysicalDeviceWaylandPresentationSupportKHR);
     LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
 #undef LOAD_OPTIONAL_FUNCPTR
@@ -849,6 +860,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkGetPhysicalDeviceSurfaceFormatsKHR = wayland_vkGetPhysicalDeviceSurfaceFormatsKHR,
     .p_vkGetPhysicalDeviceSurfacePresentModesKHR = wayland_vkGetPhysicalDeviceSurfacePresentModesKHR,
     .p_vkGetPhysicalDeviceSurfaceSupportKHR = wayland_vkGetPhysicalDeviceSurfaceSupportKHR,
+    .p_vkGetPhysicalDeviceWin32PresentationSupportKHR = wayland_vkGetPhysicalDeviceWin32PresentationSupportKHR,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
-- 
2.34.1


From 299cb1822f54f6ec218d0431c9809f2d104992b4 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 12:59:01 +0300
Subject: [PATCH 117/147] winewayland.drv: Implement vkGetSwapchainImagesKHR.

This is a simple passthrough implementation to the native Vulkan driver.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 616c09f0167..5650dbbd6cb 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -68,6 +68,7 @@ static VkResult (*pvkGetPhysicalDeviceSurfaceFormatsKHR)(VkPhysicalDevice, VkSur
 static VkResult (*pvkGetPhysicalDeviceSurfacePresentModesKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkPresentModeKHR *);
 static VkResult (*pvkGetPhysicalDeviceSurfaceSupportKHR)(VkPhysicalDevice, uint32_t, VkSurfaceKHR, VkBool32 *);
 static VkBool32 (*pvkGetPhysicalDeviceWaylandPresentationSupportKHR)(VkPhysicalDevice, uint32_t, struct wl_display *);
+static VkResult (*pvkGetSwapchainImagesKHR)(VkDevice, VkSwapchainKHR, uint32_t *, VkImage *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
@@ -707,6 +708,14 @@ static VkBool32 wayland_vkGetPhysicalDeviceWin32PresentationSupportKHR(VkPhysica
                                                              process_wl_display);
 }
 
+static VkResult wayland_vkGetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapchain,
+                                                uint32_t *count, VkImage *images)
+{
+    TRACE("%p, 0x%s %p %p\n", device, wine_dbgstr_longlong(swapchain), count, images);
+
+    return pvkGetSwapchainImagesKHR(device, swapchain, count, images);
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -829,6 +838,7 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
     LOAD_FUNCPTR(vkGetPhysicalDeviceSurfacePresentModesKHR);
     LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceSupportKHR);
     LOAD_FUNCPTR(vkGetPhysicalDeviceWaylandPresentationSupportKHR);
+    LOAD_FUNCPTR(vkGetSwapchainImagesKHR);
     LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
 #undef LOAD_OPTIONAL_FUNCPTR
@@ -861,6 +871,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkGetPhysicalDeviceSurfacePresentModesKHR = wayland_vkGetPhysicalDeviceSurfacePresentModesKHR,
     .p_vkGetPhysicalDeviceSurfaceSupportKHR = wayland_vkGetPhysicalDeviceSurfaceSupportKHR,
     .p_vkGetPhysicalDeviceWin32PresentationSupportKHR = wayland_vkGetPhysicalDeviceWin32PresentationSupportKHR,
+    .p_vkGetSwapchainImagesKHR = wayland_vkGetSwapchainImagesKHR,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
-- 
2.34.1


From 40f596d2b23f01b74822e8366dd16109bb1b3e76 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 16:35:45 +0300
Subject: [PATCH 118/147] winewayland.drv: Implement wine_get_native_surface.

The VkSurfaceKHR we return in wayland_vkCreateWin32SurfaceKHR *is* the
native VkSurfaceKHR, so the implementation is trivial.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 5650dbbd6cb..aa998fe6d4c 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -810,6 +810,14 @@ static VkResult wayland_vkQueuePresentKHR(VkQueue queue, const VkPresentInfoKHR
     return res;
 }
 
+/* The VkSurfaceKHR we return in wayland_vkCreateWin32SurfaceKHR *is* the
+ * native surface. */
+static VkSurfaceKHR wayland_wine_get_native_surface(VkSurfaceKHR surface)
+{
+    TRACE("0x%s\n", wine_dbgstr_longlong(surface));
+    return surface;
+}
+
 static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
 {
     if (!(vulkan_handle = dlopen(SONAME_LIBVULKAN, RTLD_NOW)))
@@ -873,6 +881,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkGetPhysicalDeviceWin32PresentationSupportKHR = wayland_vkGetPhysicalDeviceWin32PresentationSupportKHR,
     .p_vkGetSwapchainImagesKHR = wayland_vkGetSwapchainImagesKHR,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
+    .p_wine_get_native_surface = wayland_wine_get_native_surface,
 };
 
 const struct vulkan_funcs *wayland_get_vulkan_driver(UINT version)
-- 
2.34.1


From 1adc09ac719eb6b1836f1ceac1758121971cc63a Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 4 Oct 2021 17:04:04 +0300
Subject: [PATCH 119/147] winewayland.drv: Invalidate Vulkan objects on Wayland
 surface update.

When the Wayland surface is updated (including when it changes to NULL,
i.e., when it is destroyed), we need to notify the application so that
it can deal with it accordingly.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/window.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index dc4cd8e3563..f3b40f7a028 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -549,6 +549,9 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
         data->wayland_surface = surface;
 
         wayland_update_gl_drawable_surface(data->hwnd, data->wayland_surface);
+        /* Force client to recreate any Vulkan objects so that we use the updated
+         * backing Wayland surface in our internal Vulkan representations. */
+        wayland_invalidate_vulkan_objects(data->hwnd);
     }
 }
 
@@ -908,6 +911,7 @@ void CDECL WAYLAND_DestroyWindow(HWND hwnd)
 
     if (!(data = wayland_win_data_get(hwnd))) return;
     wayland_destroy_gl_drawable(hwnd);
+    wayland_invalidate_vulkan_objects(hwnd);
     wayland_win_data_destroy(data);
 }
 
-- 
2.34.1


From c9e429ddb90bbfc9d55bb30cb2c58e863f7e53e6 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 4 Oct 2021 17:06:56 +0300
Subject: [PATCH 120/147] winewayland.drv: Enable Vulkan driver.

Expose the Vulkan driver through the corresponding function of the USER
driver.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c          | 8 ++++++++
 dlls/winewayland.drv/waylanddrv.h      | 1 +
 dlls/winewayland.drv/waylanddrv_main.c | 1 +
 3 files changed, 10 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index aa998fe6d4c..a6742549423 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -938,3 +938,11 @@ void wayland_invalidate_vulkan_objects(HWND hwnd)
 }
 
 #endif /* SONAME_LIBVULKAN */
+
+/**********************************************************************
+ *           WAYLAND_wine_get_vulkan_driver
+ */
+const struct vulkan_funcs * CDECL WAYLAND_wine_get_vulkan_driver(UINT version)
+{
+    return wayland_get_vulkan_driver(version);
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index beb8df211eb..fa17f8c1d6c 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -520,6 +520,7 @@ extern void CDECL WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT sw
 extern BOOL CDECL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flags,
                                             const RECT *window_rect, const RECT *client_rect,
                                             RECT *visible_rect, struct window_surface **surface) DECLSPEC_HIDDEN;
+extern const struct vulkan_funcs * CDECL WAYLAND_wine_get_vulkan_driver(UINT version) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          GDI driver functions
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index d51376e25b4..09949a7af14 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -150,6 +150,7 @@ const struct user_driver_funcs waylanddrv_funcs =
     .pWindowMessage = WAYLAND_WindowMessage,
     .pWindowPosChanged = WAYLAND_WindowPosChanged,
     .pWindowPosChanging = WAYLAND_WindowPosChanging,
+    .pwine_get_vulkan_driver = WAYLAND_wine_get_vulkan_driver,
 };
 
 /***********************************************************************
-- 
2.34.1


From d6bf2f80b8394aa51b48cc2724542dbf8afa5f02 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 10:59:51 +0300
Subject: [PATCH 121/147] winewayland.drv: Add skeleton Wayland data device
 support.

This will evolve to support clipboard and drag-and-drop operations in
upcoming commits.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in           |  1 +
 dlls/winewayland.drv/wayland.c             | 15 ++++
 dlls/winewayland.drv/wayland_data_device.c | 99 ++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h          | 16 ++++
 4 files changed, 131 insertions(+)
 create mode 100644 dlls/winewayland.drv/wayland_data_device.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 3c362c43b27..1e754f644d1 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -19,6 +19,7 @@ C_SRCS = \
 	waylanddrv_main.c \
 	wayland_buffer_queue.c \
 	wayland_cursor.c \
+	wayland_data_device.c \
 	wayland_keyboard.c \
 	wayland_keyboard_layout.c \
 	wayland_pointer.c \
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 9adb1883669..82d8d2da3b3 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -172,6 +172,12 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
     {
         wayland->wp_viewporter = wl_registry_bind(registry, id, &wp_viewporter_interface, 1);
     }
+    else if (strcmp(interface, "wl_data_device_manager") == 0)
+    {
+        wayland->wl_data_device_manager =
+            wl_registry_bind(registry, id, &wl_data_device_manager_interface,
+                             version < 3 ? version : 3);
+    }
     else if (strcmp(interface, "zwp_pointer_constraints_v1") == 0)
     {
         wayland->zwp_pointer_constraints_v1 =
@@ -283,6 +289,9 @@ BOOL wayland_init(struct wayland *wayland)
 
     if (!wayland_is_process(wayland))
     {
+        if (wayland->wl_data_device_manager && wayland->wl_seat)
+            wayland_data_device_init(&wayland->data_device, wayland);
+
         /* Thread wayland instances have notification pipes to inform them when
          * there might be new events in their queues. The read part of the pipe
          * is also used as the wine server queue fd. */
@@ -337,6 +346,12 @@ void wayland_deinit(struct wayland *wayland)
     if (wayland->keyboard.wl_keyboard)
         wayland_keyboard_deinit(&wayland->keyboard);
 
+    if (wayland->data_device.wl_data_device)
+        wayland_data_device_deinit(&wayland->data_device);
+
+    if (wayland->wl_data_device_manager)
+        wl_data_device_manager_destroy(wayland->wl_data_device_manager);
+
     if (wayland->wl_seat)
         wl_seat_destroy(wayland->wl_seat);
 
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
new file mode 100644
index 00000000000..93677398938
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -0,0 +1,99 @@
+/*
+ * Wayland data device (clipboard and DnD) handling
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/heap.h"
+
+/**********************************************************************
+ *          wl_data_device handling
+ */
+
+static void data_device_data_offer(void *data,
+                                   struct wl_data_device *wl_data_device,
+                                   struct wl_data_offer *wl_data_offer)
+{
+}
+
+static void data_device_enter(void *data, struct wl_data_device *wl_data_device,
+                              uint32_t serial, struct wl_surface *wl_surface,
+                              wl_fixed_t x_w, wl_fixed_t y_w,
+                              struct wl_data_offer *wl_data_offer)
+{
+}
+
+static void data_device_leave(void *data, struct wl_data_device *wl_data_device)
+{
+}
+
+static void data_device_motion(void *data, struct wl_data_device *wl_data_device,
+                               uint32_t time, wl_fixed_t x_w, wl_fixed_t y_w)
+{
+}
+
+static void data_device_drop(void *data, struct wl_data_device *wl_data_device)
+{
+}
+
+static void data_device_selection(void *data,
+                                  struct wl_data_device *wl_data_device,
+                                  struct wl_data_offer *wl_data_offer)
+{
+}
+
+static const struct wl_data_device_listener data_device_listener = {
+    data_device_data_offer,
+    data_device_enter,
+    data_device_leave,
+    data_device_motion,
+    data_device_drop,
+    data_device_selection
+};
+
+/**********************************************************************
+ *          wayland_data_device_init
+ *
+ * Initializes the data_device extension in order to support clipboard
+ * operations.
+ */
+void wayland_data_device_init(struct wayland_data_device *data_device,
+                              struct wayland *wayland)
+{
+    data_device->wayland = wayland;
+    data_device->wl_data_device =
+        wl_data_device_manager_get_data_device(wayland->wl_data_device_manager,
+                                               wayland->wl_seat);
+
+    wl_data_device_add_listener(data_device->wl_data_device, &data_device_listener,
+                                data_device);
+}
+
+/**********************************************************************
+ *          wayland_data_device_deinit
+ */
+void wayland_data_device_deinit(struct wayland_data_device *data_device)
+{
+    if (data_device->wl_data_device)
+        wl_data_device_destroy(data_device->wl_data_device);
+
+    memset(data_device, 0, sizeof(*data_device));
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index fa17f8c1d6c..c477f575159 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -126,6 +126,12 @@ struct wayland_pointer
     struct zwp_relative_pointer_v1 *zwp_relative_pointer_v1;
 };
 
+struct wayland_data_device
+{
+    struct wayland *wayland;
+    struct wl_data_device *wl_data_device;
+};
+
 struct wayland
 {
     BOOL initialized;
@@ -141,6 +147,7 @@ struct wayland
     struct wl_shm *wl_shm;
     struct wl_seat *wl_seat;
     struct wp_viewporter *wp_viewporter;
+    struct wl_data_device_manager *wl_data_device_manager;
     struct zwp_pointer_constraints_v1 *zwp_pointer_constraints_v1;
     struct zwp_relative_pointer_manager_v1 *zwp_relative_pointer_manager_v1;
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
@@ -149,6 +156,7 @@ struct wayland
     struct wl_list toplevel_list;
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
+    struct wayland_data_device data_device;
     DWORD last_dispatch_mask;
     uint32_t last_button_serial;
     DWORD last_event_type;
@@ -472,6 +480,14 @@ void wayland_update_front_buffer(HWND hwnd,
 const struct vulkan_funcs *wayland_get_vulkan_driver(UINT version);
 void wayland_invalidate_vulkan_objects(HWND hwnd);
 
+/**********************************************************************
+ *          Wayland data device
+ */
+
+void wayland_data_device_init(struct wayland_data_device *data_device,
+                              struct wayland *wayland);
+void wayland_data_device_deinit(struct wayland_data_device *data_device);
+
 /**********************************************************************
  *          XKB helpers
  */
-- 
2.34.1


From af11e74d0aeb9290399ba7a0286176ca28f2cad0 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 12:04:01 +0300
Subject: [PATCH 122/147] winewayland.drv: Basic tracking of Wayland data
 offers.

Keep track of the wl_data_offer objects sent by the Wayland compositor,
and their properties.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device.c | 156 +++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h          |   2 +
 2 files changed, 158 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 93677398938..d03a42bd22e 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -23,15 +23,153 @@
 #include "waylanddrv.h"
 
 #include "wine/heap.h"
+#include "wine/debug.h"
+
+#include <assert.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
+
+struct wayland_data_offer
+{
+    struct wayland *wayland;
+    struct wl_data_offer *wl_data_offer;
+    struct wl_array types;
+    uint32_t source_actions;
+    uint32_t action;
+};
+
+/* Normalize the mime type by skipping inconsequential characters, such as
+ * spaces and double quotes, and converting to lower case. */
+static char *normalize_mime_type(const char *mime)
+{
+    char *new_mime;
+    const char *cur_read;
+    char *cur_write;
+    size_t new_mime_len = 0;
+
+    cur_read = mime;
+    for (; *cur_read != '\0'; cur_read++)
+    {
+        if (*cur_read != ' ' && *cur_read != '"')
+            new_mime_len++;
+    }
+
+    new_mime = heap_alloc(new_mime_len + 1);
+    cur_read = mime;
+    cur_write = new_mime;
+
+    for (; *cur_read != '\0'; cur_read++)
+    {
+        if (*cur_read != ' ' && *cur_read != '"')
+            *cur_write++ = tolower(*cur_read);
+    }
+
+    *cur_write = '\0';
+
+    return new_mime;
+}
+
+/**********************************************************************
+ *          wl_data_offer handling
+ */
+
+static void data_offer_offer(void *data, struct wl_data_offer *wl_data_offer,
+                             const char *type)
+{
+    struct wayland_data_offer *data_offer = data;
+    char **p;
+
+    p = wl_array_add(&data_offer->types, sizeof *p);
+    *p = normalize_mime_type(type);
+}
+
+static void data_offer_source_actions(void *data,
+                                      struct wl_data_offer *wl_data_offer,
+                                      uint32_t source_actions)
+{
+    struct wayland_data_offer *data_offer = data;
+
+    data_offer->source_actions = source_actions;
+}
+
+static void data_offer_action(void *data, struct wl_data_offer *wl_data_offer,
+                              uint32_t dnd_action)
+{
+    struct wayland_data_offer *data_offer = data;
+
+    data_offer->action = dnd_action;
+}
+
+static const struct wl_data_offer_listener data_offer_listener = {
+    data_offer_offer,
+    data_offer_source_actions,
+    data_offer_action
+};
+
+static void wayland_data_offer_create(struct wayland *wayland,
+                                      struct wl_data_offer *wl_data_offer)
+{
+    struct wayland_data_offer *data_offer;
+
+    data_offer = heap_alloc_zero(sizeof(*data_offer));
+    if (!data_offer)
+    {
+        ERR("Failed to allocate memory for data offer\n");
+        return;
+    }
+
+    data_offer->wayland = wayland;
+    data_offer->wl_data_offer = wl_data_offer;
+    wl_array_init(&data_offer->types);
+    wl_data_offer_add_listener(data_offer->wl_data_offer,
+                               &data_offer_listener, data_offer);
+}
+
+static void wayland_data_offer_destroy(struct wayland_data_offer *data_offer)
+{
+    char **p;
+
+    wl_data_offer_destroy(data_offer->wl_data_offer);
+    wl_array_for_each(p, &data_offer->types)
+        heap_free(*p);
+    wl_array_release(&data_offer->types);
+
+    heap_free(data_offer);
+}
 
 /**********************************************************************
  *          wl_data_device handling
  */
 
+static void wayland_data_device_destroy_clipboard_data_offer(struct wayland_data_device *data_device)
+{
+    if (data_device->clipboard_wl_data_offer)
+    {
+        struct wayland_data_offer *data_offer =
+            wl_data_offer_get_user_data(data_device->clipboard_wl_data_offer);
+        wayland_data_offer_destroy(data_offer);
+        data_device->clipboard_wl_data_offer = NULL;
+    }
+}
+
+static void wayland_data_device_destroy_dnd_data_offer(struct wayland_data_device *data_device)
+{
+    if (data_device->dnd_wl_data_offer)
+    {
+        struct wayland_data_offer *data_offer =
+            wl_data_offer_get_user_data(data_device->dnd_wl_data_offer);
+        wayland_data_offer_destroy(data_offer);
+        data_device->dnd_wl_data_offer = NULL;
+    }
+}
+
 static void data_device_data_offer(void *data,
                                    struct wl_data_device *wl_data_device,
                                    struct wl_data_offer *wl_data_offer)
 {
+    struct wayland_data_device *data_device = data;
+
+    wayland_data_offer_create(data_device->wayland, wl_data_offer);
 }
 
 static void data_device_enter(void *data, struct wl_data_device *wl_data_device,
@@ -39,10 +177,19 @@ static void data_device_enter(void *data, struct wl_data_device *wl_data_device,
                               wl_fixed_t x_w, wl_fixed_t y_w,
                               struct wl_data_offer *wl_data_offer)
 {
+    struct wayland_data_device *data_device = data;
+
+    /* Any previous dnd offer should have been freed by a drop or leave event. */
+    assert(data_device->dnd_wl_data_offer == NULL);
+
+    data_device->dnd_wl_data_offer = wl_data_offer;
 }
 
 static void data_device_leave(void *data, struct wl_data_device *wl_data_device)
 {
+    struct wayland_data_device *data_device = data;
+
+    wayland_data_device_destroy_dnd_data_offer(data_device);
 }
 
 static void data_device_motion(void *data, struct wl_data_device *wl_data_device,
@@ -52,12 +199,21 @@ static void data_device_motion(void *data, struct wl_data_device *wl_data_device
 
 static void data_device_drop(void *data, struct wl_data_device *wl_data_device)
 {
+    struct wayland_data_device *data_device = data;
+
+    wayland_data_device_destroy_dnd_data_offer(data_device);
 }
 
 static void data_device_selection(void *data,
                                   struct wl_data_device *wl_data_device,
                                   struct wl_data_offer *wl_data_offer)
 {
+    struct wayland_data_device *data_device = data;
+
+    /* Destroy any previous data offer. */
+    wayland_data_device_destroy_clipboard_data_offer(data_device);
+
+    data_device->clipboard_wl_data_offer = wl_data_offer;
 }
 
 static const struct wl_data_device_listener data_device_listener = {
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index c477f575159..427f2964750 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -130,6 +130,8 @@ struct wayland_data_device
 {
     struct wayland *wayland;
     struct wl_data_device *wl_data_device;
+    struct wl_data_offer *clipboard_wl_data_offer;
+    struct wl_data_offer *dnd_wl_data_offer;
 };
 
 struct wayland
-- 
2.34.1


From e325fea7ef064f60decb3bc570a2761d28926168 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 12:35:18 +0300
Subject: [PATCH 123/147] winewayland.drv: Create dedicated window to handle
 clipboard messages.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device.c | 58 ++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h          |  3 ++
 dlls/winewayland.drv/waylanddrv_main.c     | 10 ++++
 dlls/winewayland.drv/window.c              |  3 ++
 4 files changed, 74 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index d03a42bd22e..c76b5a6c264 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -25,6 +25,8 @@
 #include "wine/heap.h"
 #include "wine/debug.h"
 
+#include "winuser.h"
+
 #include <assert.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
@@ -253,3 +255,59 @@ void wayland_data_device_deinit(struct wayland_data_device *data_device)
 
     memset(data_device, 0, sizeof(*data_device));
 }
+
+/**********************************************************************
+ *          clipboard window handling
+ */
+
+static LRESULT CALLBACK clipboard_wndproc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
+{
+    switch (msg)
+    {
+    case WM_NCCREATE:
+        return TRUE;
+    }
+    return DefWindowProcW( hwnd, msg, wp, lp );
+}
+
+static HWND wayland_data_device_create_clipboard_window(void)
+{
+    static const WCHAR clipboard_classname[] = {
+        '_','_','w','i','n','e','_','c','l','i','p','b','o','a','r','d',
+        '_','m','a','n','a','g','e','r',0
+    };
+    WNDCLASSW class;
+    HWND clipboard_hwnd;
+
+    memset(&class, 0, sizeof(class));
+    class.lpfnWndProc = clipboard_wndproc;
+    class.lpszClassName = clipboard_classname;
+
+    if (!RegisterClassW(&class) && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
+    {
+        ERR("could not register clipboard window class err %u\n", GetLastError());
+        return 0;
+    }
+
+    if (!(clipboard_hwnd = CreateWindowW(clipboard_classname, NULL, 0, 0, 0, 0, 0,
+                                         HWND_MESSAGE, 0, 0, NULL)))
+    {
+        ERR("failed to create clipboard window err %u\n", GetLastError());
+        return 0;
+    }
+
+    TRACE("clipboard_hwnd=%p\n", clipboard_hwnd);
+    return clipboard_hwnd;
+}
+
+/**********************************************************************
+ *          wayland_data_device_ensure_clipboard_window
+ *
+ * Creates (if not already created) the window which handles clipboard
+ * messages for the specified wayland instance.
+ */
+void wayland_data_device_ensure_clipboard_window(struct wayland *wayland)
+{
+    if (!wayland->clipboard_hwnd)
+        wayland->clipboard_hwnd = wayland_data_device_create_clipboard_window();
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 427f2964750..4e545cad55b 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -61,6 +61,7 @@ enum wayland_window_message
     WM_WAYLAND_MONITOR_CHANGE = 0x80001006,
     WM_WAYLAND_WINDOW_SURFACE_FLUSH = 0x80001007,
     WM_WAYLAND_POINTER_CONFINEMENT_UPDATE = 0x80001008,
+    WM_WAYLAND_CLIPBOARD_WINDOW_CREATE = 0x80001009,
 };
 
 enum wayland_surface_role
@@ -164,6 +165,7 @@ struct wayland
     DWORD last_event_type;
     int event_notification_pipe[2];
     struct wl_list thread_link;
+    HWND clipboard_hwnd;
     RECT cursor_clip;
 };
 
@@ -489,6 +491,7 @@ void wayland_invalidate_vulkan_objects(HWND hwnd);
 void wayland_data_device_init(struct wayland_data_device *data_device,
                               struct wayland *wayland);
 void wayland_data_device_deinit(struct wayland_data_device *data_device);
+void wayland_data_device_ensure_clipboard_window(struct wayland *wayland);
 
 /**********************************************************************
  *          XKB helpers
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 09949a7af14..e43c700b708 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -28,6 +28,8 @@
 #include "wine/heap.h"
 #include "wine/server.h"
 
+#include "winuser.h"
+
 #include <stdlib.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
@@ -100,6 +102,14 @@ struct wayland_thread_data *wayland_init_thread_data(void)
     set_queue_fd(&data->wayland);
     TlsSetValue(thread_data_tls_index, data);
 
+    /* Create the clipboard window outside of thread init. We delay window
+     * creation since the thread init function may be invoked from within the
+     * context of a user32 function which holds the internal Wine user32 lock.
+     * In such a case creating the clipboard window would cause an internal
+     * user32 lock error. */
+    PostThreadMessageA(data->wayland.thread_id,
+                       WM_WAYLAND_CLIPBOARD_WINDOW_CREATE, 0, 0);
+
     return data;
 }
 
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index f3b40f7a028..c73b0173d27 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -1617,6 +1617,9 @@ LRESULT CDECL WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
             wayland_surface_for_hwnd_unlock(wayland_surface);
         }
         break;
+    case WM_WAYLAND_CLIPBOARD_WINDOW_CREATE:
+        wayland_data_device_ensure_clipboard_window(thread_wayland());
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp);
     }
-- 
2.34.1


From b447b020db5507f9f55893309389a645d73ec9da Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 13:00:10 +0300
Subject: [PATCH 124/147] winewayland.drv: Add skeleton data device format
 infrastructure.

Introduce infrastructure to convert clipboard/drag-and-drop data
between what Wayland understands and what Wine understands.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in              |  1 +
 dlls/winewayland.drv/wayland_data_device.c    |  2 +
 .../wayland_data_device_format.c              | 72 +++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h             | 14 ++++
 4 files changed, 89 insertions(+)
 create mode 100644 dlls/winewayland.drv/wayland_data_device_format.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 1e754f644d1..84f18a0f04a 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -20,6 +20,7 @@ C_SRCS = \
 	wayland_buffer_queue.c \
 	wayland_cursor.c \
 	wayland_data_device.c \
+	wayland_data_device_format.c \
 	wayland_keyboard.c \
 	wayland_keyboard_layout.c \
 	wayland_pointer.c \
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index c76b5a6c264..c9b5572c890 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -296,6 +296,8 @@ static HWND wayland_data_device_create_clipboard_window(void)
         return 0;
     }
 
+    wayland_data_device_init_formats();
+
     TRACE("clipboard_hwnd=%p\n", clipboard_hwnd);
     return clipboard_hwnd;
 }
diff --git a/dlls/winewayland.drv/wayland_data_device_format.c b/dlls/winewayland.drv/wayland_data_device_format.c
new file mode 100644
index 00000000000..8491a48d64b
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_data_device_format.c
@@ -0,0 +1,72 @@
+/*
+ * Wayland data device format handling
+ *
+ * Copyright (c) 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "winuser.h"
+
+/* Order is important. When selecting a mime-type for a clipboard format we
+ * will choose the first entry that matches the specified clipboard format. */
+static struct wayland_data_device_format supported_formats[] =
+{
+    {NULL, 0, NULL, 0},
+};
+
+void wayland_data_device_init_formats(void)
+{
+    struct wayland_data_device_format *format = supported_formats;
+
+    while (format->mime_type)
+    {
+        if (format->clipboard_format == 0)
+            format->clipboard_format = RegisterClipboardFormatA(format->register_name);
+        format++;
+    }
+}
+
+struct wayland_data_device_format *wayland_data_device_format_for_mime_type(const char *mime)
+{
+    struct wayland_data_device_format *format = supported_formats;
+
+    while (format->mime_type)
+    {
+        if (!strcmp(mime, format->mime_type))
+            return format;
+        format++;
+    }
+
+    return NULL;
+}
+
+struct wayland_data_device_format *wayland_data_device_format_for_clipboard_format(UINT clipboard_format)
+{
+    struct wayland_data_device_format *format = supported_formats;
+
+    while (format->mime_type)
+    {
+        if (format->clipboard_format == clipboard_format)
+            return format;
+        format++;
+    }
+
+    return NULL;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 4e545cad55b..f1f7f4fa68d 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -135,6 +135,17 @@ struct wayland_data_device
     struct wl_data_offer *dnd_wl_data_offer;
 };
 
+struct wayland_data_device_format
+{
+    const char *mime_type;
+    UINT clipboard_format;
+    const char *register_name;
+    HGLOBAL (*import)(struct wayland_data_device_format *format,
+                      const void *data, size_t data_size);
+    void (*export)(struct wayland_data_device_format *format, int fd);
+    UINT_PTR extra;
+};
+
 struct wayland
 {
     BOOL initialized;
@@ -492,6 +503,9 @@ void wayland_data_device_init(struct wayland_data_device *data_device,
                               struct wayland *wayland);
 void wayland_data_device_deinit(struct wayland_data_device *data_device);
 void wayland_data_device_ensure_clipboard_window(struct wayland *wayland);
+void wayland_data_device_init_formats(void);
+struct wayland_data_device_format *wayland_data_device_format_for_mime_type(const char *mime);
+struct wayland_data_device_format *wayland_data_device_format_for_clipboard_format(UINT clipboard_format);
 
 /**********************************************************************
  *          XKB helpers
-- 
2.34.1


From 2ecb58f411fe2ff246b51dcaea98b151475267d9 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 5 Oct 2021 10:08:26 +0300
Subject: [PATCH 125/147] winewayland.drv: Add helper to write all data to a
 file descriptor.

Add a function that ensures that all data is written to a file
descriptor, resuming in case of interruptions or partial writes.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 .../wayland_data_device_format.c              | 27 +++++++++++++++++++
 1 file changed, 27 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device_format.c b/dlls/winewayland.drv/wayland_data_device_format.c
index 8491a48d64b..8a604e7bc6d 100644
--- a/dlls/winewayland.drv/wayland_data_device_format.c
+++ b/dlls/winewayland.drv/wayland_data_device_format.c
@@ -22,8 +22,35 @@
 
 #include "waylanddrv.h"
 
+#include "wine/debug.h"
+
 #include "winuser.h"
 
+#include <errno.h>
+#include <unistd.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
+
+static void write_all(int fd, const void *buf, size_t count)
+{
+    size_t nwritten = 0;
+
+    while (nwritten < count)
+    {
+        ssize_t ret = write(fd, (const char*)buf + nwritten, count - nwritten);
+        if (ret == -1 && errno != EINTR)
+        {
+            WARN("Failed to write all data, had %zu bytes, wrote %zu bytes (errno: %d)\n",
+                 count, nwritten, errno);
+            break;
+        }
+        else if (ret > 0)
+        {
+            nwritten += ret;
+        }
+    }
+}
+
 /* Order is important. When selecting a mime-type for a clipboard format we
  * will choose the first entry that matches the specified clipboard format. */
 static struct wayland_data_device_format supported_formats[] =
-- 
2.34.1


From 12fbee7611287f7df3919e600c5ea6642b79d1d0 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 13:04:39 +0300
Subject: [PATCH 126/147] winewayland.drv: Support text/plain data device
 formats.

Convert between CF_UNICODETEXT clipboard format and common
"text/plain" Wayland clipboard formats.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 .../wayland_data_device_format.c              | 57 +++++++++++++++++++
 1 file changed, 57 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device_format.c b/dlls/winewayland.drv/wayland_data_device_format.c
index 8a604e7bc6d..85489a8c4fa 100644
--- a/dlls/winewayland.drv/wayland_data_device_format.c
+++ b/dlls/winewayland.drv/wayland_data_device_format.c
@@ -23,6 +23,8 @@
 #include "waylanddrv.h"
 
 #include "wine/debug.h"
+#include "wine/heap.h"
+#include "wine/unicode.h"
 
 #include "winuser.h"
 
@@ -51,10 +53,65 @@ static void write_all(int fd, const void *buf, size_t count)
     }
 }
 
+static HGLOBAL import_text_as_unicode(struct wayland_data_device_format *format,
+                                      const void *data, size_t data_size)
+{
+    int wide_count;
+    HGLOBAL mem_handle;
+    void *mem;
+
+    wide_count = MultiByteToWideChar(format->extra, 0, data, data_size, NULL, 0);
+    mem_handle = GlobalAlloc(GMEM_MOVEABLE, wide_count * sizeof(WCHAR) + 1);
+    if (!mem_handle || !(mem = GlobalLock(mem_handle)))
+    {
+        if (mem_handle) GlobalFree(mem_handle);
+        return NULL;
+    }
+
+    MultiByteToWideChar(CP_UTF8, 0, data, data_size, mem, wide_count);
+    ((unsigned char*)mem)[wide_count * sizeof(WCHAR)] = 0;
+    GlobalUnlock(mem_handle);
+
+    return mem_handle;
+}
+
+static void export_text(struct wayland_data_device_format *format, int fd)
+{
+    HGLOBAL mem_handle;
+    void *mem;
+    int byte_count;
+    char *bytes;
+
+    if (!OpenClipboard(thread_wayland()->clipboard_hwnd))
+    {
+        WARN("failed to open clipboard for export\n");
+        return;
+    }
+
+    mem_handle = GetClipboardData(format->clipboard_format);
+    mem = GlobalLock(mem_handle);
+
+    byte_count = WideCharToMultiByte(format->extra, 0, mem, -1, NULL, 0, NULL, NULL);
+    bytes = heap_alloc(byte_count);
+    WideCharToMultiByte(format->extra, 0, mem, -1, bytes, byte_count, NULL, NULL);
+    write_all(fd, bytes, byte_count);
+
+    heap_free(bytes);
+
+    GlobalUnlock(mem_handle);
+
+    CloseClipboard();
+}
+
+#define CP_ASCII 20127
+
 /* Order is important. When selecting a mime-type for a clipboard format we
  * will choose the first entry that matches the specified clipboard format. */
 static struct wayland_data_device_format supported_formats[] =
 {
+    {"text/plain;charset=utf-8", CF_UNICODETEXT, NULL, import_text_as_unicode, export_text, CP_UTF8},
+    {"text/plain;charset=us-ascii", CF_UNICODETEXT, NULL, import_text_as_unicode, export_text, CP_ASCII},
+    {"text/plain", CF_UNICODETEXT, NULL, import_text_as_unicode, export_text, CP_ASCII},
     {NULL, 0, NULL, 0},
 };
 
-- 
2.34.1


From 0dd3e1a0ee776c6d6ff2fc574cbd4e5cf1c839ec Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 13:06:57 +0300
Subject: [PATCH 127/147] winewayland.drv: Support RTF data device format.

Import and export RTF clipboard/drag-and-drop data.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 .../wayland_data_device_format.c              | 42 +++++++++++++++++++
 1 file changed, 42 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device_format.c b/dlls/winewayland.drv/wayland_data_device_format.c
index 85489a8c4fa..96cfe5aa624 100644
--- a/dlls/winewayland.drv/wayland_data_device_format.c
+++ b/dlls/winewayland.drv/wayland_data_device_format.c
@@ -103,6 +103,46 @@ static void export_text(struct wayland_data_device_format *format, int fd)
     CloseClipboard();
 }
 
+static HGLOBAL import_data(struct wayland_data_device_format *format,
+                           const void *data, size_t data_size)
+{
+    HGLOBAL mem_handle;
+    void *mem;
+
+    mem_handle = GlobalAlloc(GMEM_MOVEABLE, data_size);
+    if (!mem_handle || !(mem = GlobalLock(mem_handle)))
+    {
+        if (mem_handle) GlobalFree(mem_handle);
+        return NULL;
+    }
+
+    memcpy(mem, data, data_size);
+    GlobalUnlock(mem_handle);
+
+    return mem_handle;
+}
+
+static void export_data(struct wayland_data_device_format *format, int fd)
+{
+    HGLOBAL mem_handle;
+    void *mem;
+
+    if (!OpenClipboard(thread_wayland()->clipboard_hwnd))
+    {
+        TRACE("failed to open clipboard for export\n");
+        return;
+    }
+
+    mem_handle = GetClipboardData(format->clipboard_format);
+    mem = GlobalLock(mem_handle);
+
+    write_all(fd, mem, GlobalSize(mem_handle));
+
+    GlobalUnlock(mem_handle);
+
+    CloseClipboard();
+}
+
 #define CP_ASCII 20127
 
 /* Order is important. When selecting a mime-type for a clipboard format we
@@ -112,6 +152,8 @@ static struct wayland_data_device_format supported_formats[] =
     {"text/plain;charset=utf-8", CF_UNICODETEXT, NULL, import_text_as_unicode, export_text, CP_UTF8},
     {"text/plain;charset=us-ascii", CF_UNICODETEXT, NULL, import_text_as_unicode, export_text, CP_ASCII},
     {"text/plain", CF_UNICODETEXT, NULL, import_text_as_unicode, export_text, CP_ASCII},
+    {"text/rtf", 0, "Rich Text Format", import_data, export_data, 0},
+    {"text/richtext", 0, "Rich Text Format", import_data, export_data, 0},
     {NULL, 0, NULL, 0},
 };
 
-- 
2.34.1


From f3c5136666f6fbba0071a49f94e379f61b176b2b Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 13:12:09 +0300
Subject: [PATCH 128/147] winewayland.drv: Support text/uri-list data device
 format.

Convert between CF_HDROP Windows clipboard format and "text/uri-list"
Wayland clipboard format.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 .../wayland_data_device_format.c              | 198 ++++++++++++++++++
 1 file changed, 198 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device_format.c b/dlls/winewayland.drv/wayland_data_device_format.c
index 96cfe5aa624..7c8418e2236 100644
--- a/dlls/winewayland.drv/wayland_data_device_format.c
+++ b/dlls/winewayland.drv/wayland_data_device_format.c
@@ -26,6 +26,7 @@
 #include "wine/heap.h"
 #include "wine/unicode.h"
 
+#include "shlobj.h"
 #include "winuser.h"
 
 #include <errno.h>
@@ -143,6 +144,202 @@ static void export_data(struct wayland_data_device_format *format, int fd)
     CloseClipboard();
 }
 
+/* Adapted from winex11.drv/clipboard.c */
+static char *decode_uri(const char *uri, size_t uri_length)
+{
+    char *decoded = heap_alloc_zero(uri_length + 1);
+    size_t uri_i = 0;
+    size_t decoded_i = 0;
+
+    if (decoded == NULL)
+        goto err;
+
+    while (uri_i < uri_length)
+    {
+        if (uri[uri_i] == '%')
+        {
+            unsigned long number;
+            char buffer[3];
+
+            if (uri_i + 1 == uri_length || uri_i + 2 == uri_length)
+                goto err;
+
+            buffer[0] = uri[uri_i + 1];
+            buffer[1] = uri[uri_i + 2];
+            buffer[2] = '\0';
+            errno = 0;
+            number = strtoul(buffer, NULL, 16);
+            if (errno != 0)
+                goto err;
+            decoded[decoded_i] = number;
+
+            uri_i += 3;
+            decoded_i++;
+        }
+        else
+        {
+            decoded[decoded_i++] = uri[uri_i++];
+        }
+    }
+
+    decoded[decoded_i] = '\0';
+
+    return decoded;
+
+err:
+    heap_free(decoded);
+    return NULL;
+}
+
+/* Adapted from winex11.drv/clipboard.c */
+static WCHAR* decoded_uri_to_dos(const char *uri)
+{
+    WCHAR *ret = NULL;
+
+    if (strncmp(uri, "file:/", 6))
+        return NULL;
+
+    if (uri[6] == '/')
+    {
+        if (uri[7] == '/')
+        {
+            /* file:///path/to/file (nautilus, thunar) */
+            ret = wine_get_dos_file_name(&uri[7]);
+        }
+        else if (uri[7])
+        {
+            /* file://hostname/path/to/file (X file drag spec) */
+            char hostname[256];
+            char *path = strchr(&uri[7], '/');
+            if (path)
+            {
+                *path = '\0';
+                if (strcmp(&uri[7], "localhost") == 0)
+                {
+                    *path = '/';
+                    ret = wine_get_dos_file_name(path);
+                }
+                else if (gethostname(hostname, sizeof(hostname)) == 0)
+                {
+                    if (strcmp(hostname, &uri[7]) == 0)
+                    {
+                        *path = '/';
+                        ret = wine_get_dos_file_name(path);
+                    }
+                }
+            }
+        }
+    }
+    else if (uri[6])
+    {
+        /* file:/path/to/file (konqueror) */
+        ret = wine_get_dos_file_name(&uri[5]);
+    }
+
+    return ret;
+}
+
+static HGLOBAL import_uri_list(struct wayland_data_device_format *format,
+                               const void *data, size_t data_size)
+{
+    HGLOBAL mem_handle = 0;
+    DROPFILES *drop_files;
+    const char *data_end = (const char *) data + data_size;
+    const char *line_start = data;
+    const char *line_end;
+    WCHAR **path;
+    struct wl_array paths;
+    size_t total_chars = 0;
+    WCHAR *dst;
+
+    TRACE("data=%p size=%lu\n", data, (unsigned long)data_size);
+
+    wl_array_init(&paths);
+
+    while (line_start < data_end)
+    {
+        line_end = strchr(line_start, '\r');
+        if (line_end == NULL || line_end == data_end - 1 || line_end[1] != '\n')
+        {
+            WARN("URI list line doesn't end in \\r\\n\n");
+            break;
+        }
+
+        if (line_start[0] != '#')
+        {
+            char *decoded_uri = decode_uri(line_start, line_end - line_start);
+            TRACE("decoded_uri=%s\n", decoded_uri);
+            path = wl_array_add(&paths, sizeof *path);
+            if (!path)
+                goto out;
+            *path = decoded_uri_to_dos(decoded_uri);
+            total_chars += strlenW(*path) + 1;
+            heap_free(decoded_uri);
+        }
+
+        line_start = line_end + 2;
+    }
+
+    /* DROPFILES points to an array of consecutive null terminated WCHAR strings,
+     * followed by a final 0 WCHAR to denote the end of the array. We place that
+     * array just after the DROPFILE struct itself. */
+    mem_handle = GlobalAlloc(GMEM_MOVEABLE, sizeof(DROPFILES) + (total_chars + 1) * sizeof(WCHAR));
+    if (!mem_handle || !(drop_files = GlobalLock(mem_handle)))
+    {
+        if (mem_handle)
+        {
+            GlobalFree(mem_handle);
+            mem_handle = NULL;
+        }
+        goto out;
+    }
+
+    drop_files->pFiles = sizeof(*drop_files);
+    drop_files->pt.x = 0;
+    drop_files->pt.y = 0;
+    drop_files->fNC = FALSE;
+    drop_files->fWide = TRUE;
+
+    dst = (WCHAR*)(drop_files + 1);
+    wl_array_for_each(path, &paths)
+    {
+        strcpyW(dst, *path);
+        dst += strlenW(*path) + 1;
+    }
+    *dst = 0;
+
+    GlobalUnlock(mem_handle);
+
+out:
+    wl_array_for_each(path, &paths)
+        heap_free(*path);
+
+    wl_array_release(&paths);
+
+    return mem_handle;
+}
+
+static void export_uri_list(struct wayland_data_device_format *format, int fd)
+{
+    HGLOBAL mem_handle;
+    void *mem;
+
+    if (!OpenClipboard(thread_wayland()->clipboard_hwnd))
+    {
+        TRACE("failed to open clipboard for export\n");
+        return;
+    }
+
+    mem_handle = GetClipboardData(format->clipboard_format);
+    mem = GlobalLock(mem_handle);
+
+    write_all(fd, mem, GlobalSize(mem_handle));
+
+    GlobalUnlock(mem_handle);
+
+    CloseClipboard();
+}
+
 #define CP_ASCII 20127
 
 /* Order is important. When selecting a mime-type for a clipboard format we
@@ -154,6 +351,7 @@ static struct wayland_data_device_format supported_formats[] =
     {"text/plain", CF_UNICODETEXT, NULL, import_text_as_unicode, export_text, CP_ASCII},
     {"text/rtf", 0, "Rich Text Format", import_data, export_data, 0},
     {"text/richtext", 0, "Rich Text Format", import_data, export_data, 0},
+    {"text/uri-list", CF_HDROP, NULL, import_uri_list, export_uri_list, 0},
     {NULL, 0, NULL, 0},
 };
 
-- 
2.34.1


From e02b3755e7c32834dc09e111384e88b7bf38d7e6 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 13:14:04 +0300
Subject: [PATCH 129/147] winewayland.drv: Support common image data device
 format.

Import and export TIFF, PNG, JPEG and GIF image formats.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device_format.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device_format.c b/dlls/winewayland.drv/wayland_data_device_format.c
index 7c8418e2236..aa1b324a38c 100644
--- a/dlls/winewayland.drv/wayland_data_device_format.c
+++ b/dlls/winewayland.drv/wayland_data_device_format.c
@@ -352,6 +352,10 @@ static struct wayland_data_device_format supported_formats[] =
     {"text/rtf", 0, "Rich Text Format", import_data, export_data, 0},
     {"text/richtext", 0, "Rich Text Format", import_data, export_data, 0},
     {"text/uri-list", CF_HDROP, NULL, import_uri_list, export_uri_list, 0},
+    {"image/tiff", CF_TIFF, 0, import_data, export_data, 0},
+    {"image/png", 0, "PNG", import_data, export_data, 0},
+    {"image/jpeg", 0, "JFIF", import_data, export_data, 0},
+    {"image/gif", 0, "GIF", import_data, export_data, 0},
     {NULL, 0, NULL, 0},
 };
 
-- 
2.34.1


From 6846894d8d08ed22d1d48dbae6c7b7f9b013ec65 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 13:22:00 +0300
Subject: [PATCH 130/147] winewayland.drv: Handle WM_CLIPBOARDUPDATE message.

When the Windows clipboard is updated, create a new Wayland data source
that exports the update clipboard data, and make it the current
Wayland data selection.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device.c | 111 +++++++++++++++++++++
 1 file changed, 111 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index c9b5572c890..295a050e41e 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -31,6 +31,8 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
 
+#define WINEWAYLAND_TAG_MIME_TYPE "application/x.winewayland.tag"
+
 struct wayland_data_offer
 {
     struct wayland *wayland;
@@ -256,16 +258,122 @@ void wayland_data_device_deinit(struct wayland_data_device *data_device)
     memset(data_device, 0, sizeof(*data_device));
 }
 
+/**********************************************************************
+ *          wl_data_source handling
+ */
+
+static void data_source_target(void *data, struct wl_data_source *source,
+                               const char *mime_type)
+{
+}
+
+static void data_source_send(void *data, struct wl_data_source *source,
+                             const char *mime_type, int32_t fd)
+{
+    struct wayland_data_device_format *format =
+        wayland_data_device_format_for_mime_type(mime_type);
+
+    TRACE("source=%p mime_type=%s\n", source, mime_type);
+
+    if (format) format->export(format, fd);
+
+    close(fd);
+}
+
+static void data_source_cancelled(void *data, struct wl_data_source *source)
+{
+    TRACE("source=%p\n", source);
+    wl_data_source_destroy(source);
+}
+
+static void data_source_dnd_drop_performed(void *data,
+                                           struct wl_data_source *source)
+{
+}
+
+static void data_source_dnd_finished(void *data, struct wl_data_source *source)
+{
+}
+
+static void data_source_action(void *data, struct wl_data_source *source,
+                               uint32_t dnd_action)
+{
+}
+
+static const struct wl_data_source_listener data_source_listener = {
+    data_source_target,
+    data_source_send,
+    data_source_cancelled,
+    data_source_dnd_drop_performed,
+    data_source_dnd_finished,
+    data_source_action,
+};
+
 /**********************************************************************
  *          clipboard window handling
  */
 
+static void clipboard_update(void)
+{
+    struct wayland *wayland = thread_wayland();
+    uint32_t enter_serial;
+    struct wl_data_source *source;
+    UINT clipboard_format = 0;
+
+    TRACE("WM_CLIPBOARDUPDATE wayland %p enter_serial=%d/%d\n",
+          wayland,
+          wayland ? wayland->keyboard.enter_serial : -1,
+          wayland ? wayland->pointer.enter_serial : -1);
+
+    if (!wayland)
+        return;
+
+    enter_serial = wayland->keyboard.enter_serial ? wayland->keyboard.enter_serial
+                                                  : wayland->pointer.enter_serial;
+
+    if (!enter_serial)
+        return;
+
+    if (!OpenClipboard(wayland->clipboard_hwnd))
+    {
+        TRACE("failed to open clipboard\n");
+        return;
+    }
+
+    source = wl_data_device_manager_create_data_source(wayland->wl_data_device_manager);
+
+    while ((clipboard_format = EnumClipboardFormats(clipboard_format)))
+    {
+        struct wayland_data_device_format *format =
+            wayland_data_device_format_for_clipboard_format(clipboard_format);
+        if (format)
+        {
+            TRACE("Offering source=%p mime=%s\n", source, format->mime_type);
+            wl_data_source_offer(source, format->mime_type);
+        }
+    }
+
+    /* Add a special entry so that we can detect when an offer is coming from us. */
+    wl_data_source_offer(source, WINEWAYLAND_TAG_MIME_TYPE);
+
+    wl_data_source_add_listener(source, &data_source_listener, NULL);
+    wl_data_device_set_selection(wayland->data_device.wl_data_device, source,
+                                 enter_serial);
+
+    CloseClipboard();
+}
+
 static LRESULT CALLBACK clipboard_wndproc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
 {
     switch (msg)
     {
     case WM_NCCREATE:
         return TRUE;
+    case WM_CLIPBOARDUPDATE:
+        TRACE("WM_CLIPBOARDUPDATE\n");
+        /* Ignore our own updates */
+        if (GetClipboardOwner() != hwnd) clipboard_update();
+        break;
     }
     return DefWindowProcW( hwnd, msg, wp, lp );
 }
@@ -298,6 +406,9 @@ static HWND wayland_data_device_create_clipboard_window(void)
 
     wayland_data_device_init_formats();
 
+    if (!AddClipboardFormatListener(clipboard_hwnd))
+        ERR("failed to set clipboard listener %u\n", GetLastError());
+
     TRACE("clipboard_hwnd=%p\n", clipboard_hwnd);
     return clipboard_hwnd;
 }
-- 
2.34.1


From f0b32f8a2cc39caaaf6d3cb7ae5ef48cb269bb22 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 13:33:25 +0300
Subject: [PATCH 131/147] winewayland.drv: Handle WM_RENDERFORMAT message.

Import into Windows clipboard data we got from other Wayland clients,
for a particular Windows clipboard format. This allow us to fetch
clipboard data and populate the Windows clipboard contents on demand.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device.c | 127 +++++++++++++++++++++
 1 file changed, 127 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 295a050e41e..984fd3e8e6e 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -28,6 +28,10 @@
 #include "winuser.h"
 
 #include <assert.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <poll.h>
+#include <unistd.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
 
@@ -141,6 +145,98 @@ static void wayland_data_offer_destroy(struct wayland_data_offer *data_offer)
     heap_free(data_offer);
 }
 
+static void *wayland_data_offer_receive_data(struct wayland_data_offer *data_offer,
+                                             const char *mime_type,
+                                             size_t *size_out)
+{
+    int data_pipe[2] = {-1, -1};
+    size_t buffer_size = 4096;
+    int total = 0;
+    unsigned char *buffer;
+    int nread;
+
+    buffer = heap_alloc(buffer_size);
+    if (buffer == NULL)
+        goto out;
+
+    if (pipe2(data_pipe, O_CLOEXEC) == -1)
+        goto out;
+
+    wl_data_offer_receive(data_offer->wl_data_offer, mime_type, data_pipe[1]);
+    close(data_pipe[1]);
+
+    /* Flush to ensure our receive request reaches the server. */
+    wl_display_flush(data_offer->wayland->wl_display);
+
+    do
+    {
+        struct pollfd pfd = { .fd = data_pipe[0], .events = POLLIN };
+        int ret;
+
+        /* Wait a limited amount of time for the data to arrive, since otherwise
+         * a misbehaving data source could block us indefinitely. */
+        while ((ret = poll(&pfd, 1, 3000)) == -1 && errno == EINTR) continue;
+        if (ret <= 0 || !(pfd.revents & (POLLIN | POLLHUP)))
+        {
+            TRACE("failed polling data offer pipe ret=%d errno=%d revents=0x%x\n",
+                  ret, ret == -1 ? errno : 0, pfd.revents);
+            total = 0;
+            goto out;
+        }
+
+        nread = read(data_pipe[0], buffer + total, buffer_size - total);
+        if (nread == -1 && errno != EINTR)
+        {
+            ERR("failed to read data offer pipe\n");
+            total = 0;
+            goto out;
+        }
+        else if (nread > 0)
+        {
+            total += nread;
+            if (total == buffer_size)
+            {
+                buffer_size += 4096;
+                buffer = heap_realloc(buffer, buffer_size);
+            }
+        }
+    } while (nread > 0);
+
+    TRACE("received %d bytes\n", total);
+
+out:
+    if (data_pipe[0] >= 0)
+        close(data_pipe[0]);
+
+    if (total == 0 && buffer != NULL)
+    {
+        heap_free(buffer);
+        buffer = NULL;
+    }
+
+    *size_out = total;
+
+    return buffer;
+}
+
+static HGLOBAL wayland_data_offer_import_format(struct wayland_data_offer *data_offer,
+                                                struct wayland_data_device_format *format)
+{
+    size_t data_size;
+    void *data;
+    HGLOBAL mem_handle;
+
+    data = wayland_data_offer_receive_data(data_offer, format->mime_type, &data_size);
+    if (!data)
+        return NULL;
+
+    mem_handle = format->import(format, data, data_size);
+
+    heap_free(data);
+
+    return mem_handle;
+}
+
 /**********************************************************************
  *          wl_data_device handling
  */
@@ -363,6 +459,33 @@ static void clipboard_update(void)
     CloseClipboard();
 }
 
+static void clipboard_render_format(UINT clipboard_format)
+{
+    struct wayland_data_device *data_device;
+    struct wayland_data_offer *data_offer;
+    char **p;
+
+    data_device = wl_data_device_get_user_data(thread_wayland()->data_device.wl_data_device);
+    if (!data_device->clipboard_wl_data_offer)
+        return;
+
+    data_offer = wl_data_offer_get_user_data(data_device->clipboard_wl_data_offer);
+    if (!data_offer)
+        return;
+
+    wl_array_for_each(p, &data_offer->types)
+    {
+        struct wayland_data_device_format *format =
+            wayland_data_device_format_for_mime_type(*p);
+        if (format && format->clipboard_format == clipboard_format)
+        {
+            HGLOBAL mem_handle = wayland_data_offer_import_format(data_offer, format);
+            SetClipboardData(format->clipboard_format, mem_handle);
+            break;
+        }
+    }
+}
+
 static LRESULT CALLBACK clipboard_wndproc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
 {
     switch (msg)
@@ -374,6 +497,10 @@ static LRESULT CALLBACK clipboard_wndproc(HWND hwnd, UINT msg, WPARAM wp, LPARAM
         /* Ignore our own updates */
         if (GetClipboardOwner() != hwnd) clipboard_update();
         break;
+    case WM_RENDERFORMAT:
+        TRACE("WM_RENDERFORMAT: %ld\n", wp);
+        clipboard_render_format(wp);
+        break;
     }
     return DefWindowProcW( hwnd, msg, wp, lp );
 }
-- 
2.34.1


From b6f0f803a8c42bcf621f7b5fcfa631945b222ba4 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 13:35:36 +0300
Subject: [PATCH 132/147] winewayland.drv: Handle WM_DESTROYCLIPBOARD message.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 984fd3e8e6e..f6d39c4c64c 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -486,6 +486,14 @@ static void clipboard_render_format(UINT clipboard_format)
     }
 }
 
+static void clipboard_destroy(void)
+{
+    struct wayland *wayland = thread_wayland();
+    struct wayland_data_device *data_device =
+        wl_data_device_get_user_data(wayland->data_device.wl_data_device);
+    wayland_data_device_destroy_clipboard_data_offer(data_device);
+}
+
 static LRESULT CALLBACK clipboard_wndproc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
 {
     switch (msg)
@@ -501,6 +509,10 @@ static LRESULT CALLBACK clipboard_wndproc(HWND hwnd, UINT msg, WPARAM wp, LPARAM
         TRACE("WM_RENDERFORMAT: %ld\n", wp);
         clipboard_render_format(wp);
         break;
+    case WM_DESTROYCLIPBOARD:
+        TRACE("WM_DESTROYCLIPBOARD: lost ownership clipboard_hwnd=%p\n", hwnd);
+        clipboard_destroy();
+        break;
     }
     return DefWindowProcW( hwnd, msg, wp, lp );
 }
-- 
2.34.1


From ce92f67f742b5dadae48999cb7158e6cc7fddac5 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 13:27:47 +0300
Subject: [PATCH 133/147] winewayland.drv: Handle Wayland data device selection
 event.

Handle the Wayland event which informs us of the new current clipboard
selection. We use the provided event information to update the available
formats in the Windows clipboard, without populating them with any
actual data. We populate the clipboard data on demand through the
handling of the WM_RENDERFORMAT message.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device.c | 66 ++++++++++++++++++++++
 1 file changed, 66 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index f6d39c4c64c..e62f9468411 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -309,11 +309,77 @@ static void data_device_selection(void *data,
                                   struct wl_data_offer *wl_data_offer)
 {
     struct wayland_data_device *data_device = data;
+    struct wayland *wayland = thread_wayland();
+    struct wayland_data_offer *data_offer;
+    char **p;
+
+    TRACE("wl_data_offer=%u\n",
+          wl_data_offer ? wl_proxy_get_id((struct wl_proxy*)wl_data_offer) : 0);
+
+    /* We may get a selection event before we have had a chance to create the
+     * clipboard window after thread init (see wayland_init_thread_data), so
+     * we need to ensure we have a valid window here. */
+    wayland_data_device_ensure_clipboard_window(wayland);
 
     /* Destroy any previous data offer. */
     wayland_data_device_destroy_clipboard_data_offer(data_device);
 
+    /* If we didn't get an offer and we are the clipboard owner, empty the
+     * clipboard. Otherwise ignore the empty offer completely. */
+    if (!wl_data_offer)
+    {
+        if (GetClipboardOwner() == wayland->clipboard_hwnd)
+        {
+            OpenClipboard(NULL);
+            EmptyClipboard();
+            CloseClipboard();
+        }
+        return;
+    }
+
+    data_offer = wl_data_offer_get_user_data(wl_data_offer);
+
+    /* If this offer contains the special winewayland tag mime-type, it was sent
+     * from us to notify external wayland clients about a wine clipboard update.
+     * The clipboard already contains all the required data, plus we need to ignore
+     * this in order to avoid an endless notification loop. */
+    wl_array_for_each(p, &data_offer->types)
+    {
+        if (!strcmp(*p, WINEWAYLAND_TAG_MIME_TYPE))
+        {
+            TRACE("ignoring offer produced by winewayland\n");
+            goto ignore_selection;
+        }
+    }
+
+    if (!OpenClipboard(data_offer->wayland->clipboard_hwnd))
+    {
+        WARN("failed to open clipboard for selection\n");
+        goto ignore_selection;
+    }
+
+    EmptyClipboard();
+
+    /* For each mime type, mark that we have available clipboard data. */
+    wl_array_for_each(p, &data_offer->types)
+    {
+        struct wayland_data_device_format *format =
+            wayland_data_device_format_for_mime_type(*p);
+        if (format)
+        {
+            TRACE("Avalaible clipboard format for %s => %u\n", *p, format->clipboard_format);
+            SetClipboardData(format->clipboard_format, 0);
+        }
+    }
+
+    CloseClipboard();
+
     data_device->clipboard_wl_data_offer = wl_data_offer;
+
+    return;
+
+ignore_selection:
+    wayland_data_offer_destroy(data_offer);
 }
 
 static const struct wl_data_device_listener data_device_listener = {
-- 
2.34.1


From ee326af049bd0e53cd3aa18b633eab92f2277080 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 17:27:13 +0300
Subject: [PATCH 134/147] winewayland.drv: Add skeleton IDataObject for data
 offers.

This IDataObject will be used to integrate with drag-and-drop
from other Wayland clients.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in           |   2 +-
 dlls/winewayland.drv/wayland_data_device.c | 134 +++++++++++++++++++++
 2 files changed, 135 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 84f18a0f04a..690650de369 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,5 +1,5 @@
 MODULE    = winewayland.drv
-IMPORTS   = advapi32 gdi32 user32 win32u
+IMPORTS   = advapi32 gdi32 user32 uuid win32u
 EXTRAINCL = $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_EGL_CFLAGS) $(XKBCOMMON_CFLAGS)
 EXTRALIBS = $(WAYLAND_CLIENT_LIBS) $(WAYLAND_EGL_LIBS) $(XKBCOMMON_LIBS)
 CFLAGS = -std=c11 -Wno-declaration-after-statement
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index e62f9468411..9b4d484a670 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -25,6 +25,8 @@
 #include "wine/heap.h"
 #include "wine/debug.h"
 
+#define COBJMACROS
+#include "objidl.h"
 #include "winuser.h"
 
 #include <assert.h>
@@ -37,6 +39,8 @@ WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
 
 #define WINEWAYLAND_TAG_MIME_TYPE "application/x.winewayland.tag"
 
+static IDataObjectVtbl dataOfferDataObjectVtbl;
+
 struct wayland_data_offer
 {
     struct wayland *wayland;
@@ -44,6 +48,7 @@ struct wayland_data_offer
     struct wl_array types;
     uint32_t source_actions;
     uint32_t action;
+    IDataObject data_object;
 };
 
 /* Normalize the mime type by skipping inconsequential characters, such as
@@ -129,6 +134,7 @@ static void wayland_data_offer_create(struct wayland *wayland,
     data_offer->wayland = wayland;
     data_offer->wl_data_offer = wl_data_offer;
     wl_array_init(&data_offer->types);
+    data_offer->data_object.lpVtbl = &dataOfferDataObjectVtbl;
     wl_data_offer_add_listener(data_offer->wl_data_offer,
                                &data_offer_listener, data_offer);
 }
@@ -629,3 +635,131 @@ void wayland_data_device_ensure_clipboard_window(struct wayland *wayland)
     if (!wayland->clipboard_hwnd)
         wayland->clipboard_hwnd = wayland_data_device_create_clipboard_window();
 }
+
+/*********************************************************
+ * Implementation of IDataObject for wayland data offers *
+ *********************************************************/
+
+static HRESULT WINAPI dataOfferDataObject_QueryInterface(IDataObject *data_object,
+                                                         REFIID riid, void **object)
+{
+    TRACE("(%p, %s, %p)\n", data_object, debugstr_guid(riid), object);
+    if (IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IDataObject))
+    {
+        *object = data_object;
+        IDataObject_AddRef(data_object);
+        return S_OK;
+    }
+    *object = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI dataOfferDataObject_AddRef(IDataObject *data_object)
+{
+    TRACE("(%p)\n", data_object);
+    /* Each data object is owned by the data_offer which contains it, and will
+     * be freed when the data_offer is destroyed, so we don't care about proper
+     * reference tracking. */
+    return 2;
+}
+
+static ULONG WINAPI dataOfferDataObject_Release(IDataObject *data_object)
+{
+    TRACE("(%p)\n", data_object);
+    /* Each data object is owned by the data_offer which contains it, and will
+     * be freed when, so we don't care about proper reference tracking. */
+    return 1;
+}
+
+static HRESULT WINAPI dataOfferDataObject_GetData(IDataObject *data_object,
+                                                  FORMATETC *format_etc,
+                                                  STGMEDIUM *medium)
+{
+    TRACE("(%p, %p, %p)\n", data_object, format_etc, medium);
+
+    return E_UNEXPECTED;
+}
+
+static HRESULT WINAPI dataOfferDataObject_GetDataHere(IDataObject *data_object,
+                                                      FORMATETC *format_etc,
+                                                      STGMEDIUM *medium)
+{
+    FIXME("(%p, %p, %p): stub\n", data_object, format_etc, medium);
+    return DATA_E_FORMATETC;
+}
+
+static HRESULT WINAPI dataOfferDataObject_QueryGetData(IDataObject *data_object,
+                                                       FORMATETC *format_etc)
+{
+    TRACE("(%p, %p={.tymed=0x%x, .dwAspect=%d, .cfFormat=%d}\n",
+          data_object, format_etc, format_etc->tymed, format_etc->dwAspect,
+          format_etc->cfFormat);
+
+    return DV_E_FORMATETC;
+}
+
+static HRESULT WINAPI dataOfferDataObject_GetCanonicalFormatEtc(IDataObject *data_object,
+                                                                FORMATETC *format_etc,
+                                                                FORMATETC *format_etc_out)
+{
+    FIXME("(%p, %p, %p): stub\n", data_object, format_etc, format_etc_out);
+    format_etc_out->ptd = NULL;
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dataOfferDataObject_SetData(IDataObject *data_object,
+                                                  FORMATETC *format_etc,
+                                                  STGMEDIUM *medium, BOOL release)
+{
+    FIXME("(%p, %p, %p, %s): stub\n", data_object, format_etc,
+          medium, release ? "TRUE" : "FALSE");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dataOfferDataObject_EnumFormatEtc(IDataObject *data_object,
+                                                        DWORD direction,
+                                                        IEnumFORMATETC **enum_format_etc)
+{
+    TRACE("(%p, %u, %p)\n", data_object, direction, enum_format_etc);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI dataOfferDataObject_DAdvise(IDataObject *data_object,
+                                                  FORMATETC *format_etc, DWORD advf,
+                                                  IAdviseSink *advise_sink,
+                                                  DWORD *connection)
+{
+    FIXME("(%p, %p, %u, %p, %p): stub\n", data_object, format_etc, advf,
+          advise_sink, connection);
+    return OLE_E_ADVISENOTSUPPORTED;
+}
+
+static HRESULT WINAPI dataOfferDataObject_DUnadvise(IDataObject *data_object,
+                                                    DWORD connection)
+{
+    FIXME("(%p, %u): stub\n", data_object, connection);
+    return OLE_E_ADVISENOTSUPPORTED;
+}
+
+static HRESULT WINAPI dataOfferDataObject_EnumDAdvise(IDataObject *data_object,
+                                                      IEnumSTATDATA **enum_advise)
+{
+    FIXME("(%p, %p): stub\n", data_object, enum_advise);
+    return OLE_E_ADVISENOTSUPPORTED;
+}
+
+static IDataObjectVtbl dataOfferDataObjectVtbl =
+{
+    dataOfferDataObject_QueryInterface,
+    dataOfferDataObject_AddRef,
+    dataOfferDataObject_Release,
+    dataOfferDataObject_GetData,
+    dataOfferDataObject_GetDataHere,
+    dataOfferDataObject_QueryGetData,
+    dataOfferDataObject_GetCanonicalFormatEtc,
+    dataOfferDataObject_SetData,
+    dataOfferDataObject_EnumFormatEtc,
+    dataOfferDataObject_DAdvise,
+    dataOfferDataObject_DUnadvise,
+    dataOfferDataObject_EnumDAdvise
+};
-- 
2.34.1


From 99b9fa05f9d177e8684f95583e33a43672a9d5e0 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 17:30:21 +0300
Subject: [PATCH 135/147] winewayland.drv: Implement IDataObject::QueryGetData
 for data offers.

Check if for any of the available mime types of the associated data
offer we support converting from that mime type to the requested Windows
clipboard format.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device.c | 28 ++++++++++++++++++++++
 1 file changed, 28 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 9b4d484a670..dbc100b41b9 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -243,6 +243,11 @@ static HGLOBAL wayland_data_offer_import_format(struct wayland_data_offer *data_
     return mem_handle;
 }
 
+static struct wayland_data_offer *wayland_data_offer_from_data_object(struct IDataObject *data_object)
+{
+    return CONTAINING_RECORD(data_object, struct wayland_data_offer, data_object);
+}
+
 /**********************************************************************
  *          wl_data_device handling
  */
@@ -691,10 +696,33 @@ static HRESULT WINAPI dataOfferDataObject_GetDataHere(IDataObject *data_object,
 static HRESULT WINAPI dataOfferDataObject_QueryGetData(IDataObject *data_object,
                                                        FORMATETC *format_etc)
 {
+    struct wayland_data_offer *data_offer;
+    char **p;
+
     TRACE("(%p, %p={.tymed=0x%x, .dwAspect=%d, .cfFormat=%d}\n",
           data_object, format_etc, format_etc->tymed, format_etc->dwAspect,
           format_etc->cfFormat);
 
+    if (format_etc->tymed && !(format_etc->tymed & TYMED_HGLOBAL))
+    {
+        FIXME("only HGLOBAL medium types supported right now\n");
+        return DV_E_TYMED;
+    }
+
+    data_offer = wayland_data_offer_from_data_object(data_object);
+
+    wl_array_for_each(p, &data_offer->types)
+    {
+        struct wayland_data_device_format *format =
+            wayland_data_device_format_for_mime_type(*p);
+        if (format && format->clipboard_format == format_etc->cfFormat)
+        {
+            TRACE("found offer %s for clipboard format %u\n", *p, format->clipboard_format);
+            return S_OK;
+        }
+    }
+
+    TRACE("didn't find offer for clipboard format %u\n", format_etc->cfFormat);
     return DV_E_FORMATETC;
 }
 
-- 
2.34.1


From 789f3a624ecfde049c33fedb407e6031e9cbdc7a Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 17:59:58 +0300
Subject: [PATCH 136/147] winewayland.drv: Implement IDataObject::GetData for
 data offers.

If the associated data offer has a mime type matching the requested
Windows clipboard format, import the data into a HGLOBAL memory object.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device.c | 28 ++++++++++++++++++++++
 1 file changed, 28 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index dbc100b41b9..ca64400f381 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -20,6 +20,8 @@
 
 #include "config.h"
 
+#define NONAMELESSUNION
+
 #include "waylanddrv.h"
 
 #include "wine/heap.h"
@@ -48,6 +50,7 @@ struct wayland_data_offer
     struct wl_array types;
     uint32_t source_actions;
     uint32_t action;
+    const char *accepted_mime_type;
     IDataObject data_object;
 };
 
@@ -680,8 +683,32 @@ static HRESULT WINAPI dataOfferDataObject_GetData(IDataObject *data_object,
                                                   FORMATETC *format_etc,
                                                   STGMEDIUM *medium)
 {
+    HRESULT hr;
+    struct wayland_data_offer *data_offer;
+    struct wayland_data_device_format *format;
+
     TRACE("(%p, %p, %p)\n", data_object, format_etc, medium);
 
+    hr = IDataObject_QueryGetData(data_object, format_etc);
+    if (!SUCCEEDED(hr))
+        return hr;
+
+    data_offer = wayland_data_offer_from_data_object(data_object);
+
+    /* A successful QueryGetData invocation sets a valid accepted_mime_type */
+    assert(data_offer->accepted_mime_type);
+
+    format = wayland_data_device_format_for_mime_type(data_offer->accepted_mime_type);
+    if (format)
+    {
+        medium->tymed = TYMED_HGLOBAL;
+        medium->u.hGlobal = wayland_data_offer_import_format(data_offer, format);
+        if (medium->u.hGlobal == NULL)
+            return E_OUTOFMEMORY;
+        medium->pUnkForRelease = 0;
+        return S_OK;
+    }
+
     return E_UNEXPECTED;
 }
 
@@ -718,6 +745,7 @@ static HRESULT WINAPI dataOfferDataObject_QueryGetData(IDataObject *data_object,
         if (format && format->clipboard_format == format_etc->cfFormat)
         {
             TRACE("found offer %s for clipboard format %u\n", *p, format->clipboard_format);
+            data_offer->accepted_mime_type = format->mime_type;
             return S_OK;
         }
     }
-- 
2.34.1


From d99b07e0ba02f7db89c884b6342f35a2706a9b0b Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 18:36:38 +0300
Subject: [PATCH 137/147] winewayland.drv: Implement IDataObject::EnumFormatEtc
 for data offers.

For each mime type of the associated data offer we provid a FORMATETC
entry with the matching Windows clipboard format. We ensure that there
are no duplicate FORMATETC entries.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in           |  1 +
 dlls/winewayland.drv/wayland_data_device.c | 61 +++++++++++++++++++++-
 2 files changed, 61 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 690650de369..9c3af98911d 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,5 +1,6 @@
 MODULE    = winewayland.drv
 IMPORTS   = advapi32 gdi32 user32 uuid win32u
+DELAYIMPORTS = shell32
 EXTRAINCL = $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_EGL_CFLAGS) $(XKBCOMMON_CFLAGS)
 EXTRALIBS = $(WAYLAND_CLIENT_LIBS) $(WAYLAND_EGL_LIBS) $(XKBCOMMON_LIBS)
 CFLAGS = -std=c11 -Wno-declaration-after-statement
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index ca64400f381..1d562430ea0 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -29,6 +29,7 @@
 
 #define COBJMACROS
 #include "objidl.h"
+#include "shlobj.h"
 #include "winuser.h"
 
 #include <assert.h>
@@ -772,12 +773,70 @@ static HRESULT WINAPI dataOfferDataObject_SetData(IDataObject *data_object,
     return E_NOTIMPL;
 }
 
+static BOOL formats_etc_contains_clipboard_format(FORMATETC *formats_etc,
+                                                  size_t formats_etc_count,
+                                                  UINT clipboard_format)
+{
+    size_t i;
+
+    for (i = 0; i < formats_etc_count; i++)
+    {
+        if (formats_etc[i].cfFormat == clipboard_format)
+            return TRUE;
+    }
+
+    return FALSE;
+}
+
 static HRESULT WINAPI dataOfferDataObject_EnumFormatEtc(IDataObject *data_object,
                                                         DWORD direction,
                                                         IEnumFORMATETC **enum_format_etc)
 {
+    HRESULT hr;
+    FORMATETC *formats_etc;
+    size_t formats_etc_count = 0;
+    struct wayland_data_offer *data_offer;
+    char **p;
+
     TRACE("(%p, %u, %p)\n", data_object, direction, enum_format_etc);
-    return E_NOTIMPL;
+
+    if (direction != DATADIR_GET)
+    {
+        FIXME("only the get direction is implemented\n");
+        return E_NOTIMPL;
+    }
+
+    data_offer = wayland_data_offer_from_data_object(data_object);
+
+    /* Allocate space for all offered mime types, although we may not use them all */
+    formats_etc = heap_alloc((data_offer->types.size / sizeof(char *)) * sizeof(FORMATETC));
+    if (!formats_etc)
+        return E_OUTOFMEMORY;
+
+    wl_array_for_each(p, &data_offer->types)
+    {
+        struct wayland_data_device_format *format =
+            wayland_data_device_format_for_mime_type(*p);
+        if (format &&
+            !formats_etc_contains_clipboard_format(formats_etc, formats_etc_count,
+                                                   format->clipboard_format))
+        {
+            FORMATETC *current= &formats_etc[formats_etc_count];
+
+            current->cfFormat = format->clipboard_format;
+            current->ptd = NULL;
+            current->dwAspect = DVASPECT_CONTENT;
+            current->lindex = -1;
+            current->tymed = TYMED_HGLOBAL;
+
+            formats_etc_count += 1;
+        }
+    }
+
+    hr = SHCreateStdEnumFmtEtc(formats_etc_count, formats_etc, enum_format_etc);
+    heap_free(formats_etc);
+
+    return hr;
 }
 
 static HRESULT WINAPI dataOfferDataObject_DAdvise(IDataObject *data_object,
-- 
2.34.1


From 71af1d618732496d97713e07e5a343c68332c68f Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 23 Sep 2021 12:43:19 +0300
Subject: [PATCH 138/147] winewayland.drv: Introduce functions for IDropTarget
 discovery.

Implement functions to find the IDropTarget for a particular point in a
window.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in           |   2 +-
 dlls/winewayland.drv/wayland_data_device.c | 100 +++++++++++++++++++++
 2 files changed, 101 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 9c3af98911d..903c74e6982 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,6 +1,6 @@
 MODULE    = winewayland.drv
 IMPORTS   = advapi32 gdi32 user32 uuid win32u
-DELAYIMPORTS = shell32
+DELAYIMPORTS = ole32 shell32
 EXTRAINCL = $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_EGL_CFLAGS) $(XKBCOMMON_CFLAGS)
 EXTRALIBS = $(WAYLAND_CLIENT_LIBS) $(WAYLAND_EGL_LIBS) $(XKBCOMMON_LIBS)
 CFLAGS = -std=c11 -Wno-declaration-after-statement
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 1d562430ea0..cd2748f05de 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -86,6 +86,106 @@ static char *normalize_mime_type(const char *mime)
     return new_mime;
 }
 
+/**********************************************************************
+ *          IDropTarget discovery
+ *
+ * Based on functions in dlls/ole32/ole2.c
+ */
+
+static HANDLE get_drop_target_local_handle(HWND hwnd)
+{
+    static const WCHAR prop_marshalleddrop_target[] =
+        {'W','i','n','e','M','a','r','s','h','a','l','l','e','d',
+         'D','r','o','p','T','a','r','g','e','t',0};
+    HANDLE handle;
+    HANDLE local_handle = 0;
+
+    handle = GetPropW(hwnd, prop_marshalleddrop_target);
+    if (handle)
+    {
+        DWORD pid;
+        HANDLE process;
+
+        GetWindowThreadProcessId(hwnd, &pid);
+        process = OpenProcess(PROCESS_DUP_HANDLE, FALSE, pid);
+        if (process)
+        {
+            DuplicateHandle(process, handle, GetCurrentProcess(), &local_handle,
+                            0, FALSE, DUPLICATE_SAME_ACCESS);
+            CloseHandle(process);
+        }
+    }
+    return local_handle;
+}
+
+static HRESULT create_stream_from_map(HANDLE map, IStream **stream)
+{
+    HRESULT hr = E_OUTOFMEMORY;
+    HGLOBAL hmem;
+    void *data;
+    MEMORY_BASIC_INFORMATION info;
+
+    data = MapViewOfFile(map, FILE_MAP_READ, 0, 0, 0);
+    if(!data) return hr;
+
+    VirtualQuery(data, &info, sizeof(info));
+
+    hmem = GlobalAlloc(GMEM_MOVEABLE, info.RegionSize);
+    if(hmem)
+    {
+        memcpy(GlobalLock(hmem), data, info.RegionSize);
+        GlobalUnlock(hmem);
+        hr = CreateStreamOnHGlobal(hmem, TRUE, stream);
+    }
+    UnmapViewOfFile(data);
+    return hr;
+}
+
+static IDropTarget* get_drop_target_pointer(HWND hwnd)
+{
+    IDropTarget *drop_target = NULL;
+    HANDLE map;
+    IStream *stream;
+
+    map = get_drop_target_local_handle(hwnd);
+    if(!map) return NULL;
+
+    if(SUCCEEDED(create_stream_from_map(map, &stream)))
+    {
+        CoUnmarshalInterface(stream, &IID_IDropTarget, (void**)&drop_target);
+        IStream_Release(stream);
+    }
+    CloseHandle(map);
+    return drop_target;
+}
+
+static IDropTarget *drop_target_from_window_point(HWND hwnd, POINT point)
+{
+    HWND child;
+    IDropTarget *drop_target;
+    HWND orig_hwnd = hwnd;
+    POINT orig_point = point;
+
+    /* Find the deepest child window. */
+    ScreenToClient(hwnd, &point);
+    while ((child = ChildWindowFromPointEx(hwnd, point, CWP_SKIPDISABLED | CWP_SKIPINVISIBLE)) &&
+            child != hwnd)
+    {
+        MapWindowPoints(hwnd, child, &point, 1);
+        hwnd = child;
+    }
+
+    /* Ascend the children hierarchy until we find one that accepts drops. */
+    do
+    {
+        drop_target = get_drop_target_pointer(hwnd);
+    } while (drop_target == NULL && (hwnd = GetParent(hwnd)) != NULL);
+
+    TRACE("hwnd=%p point=(%d,%d) => dnd_hwnd=%p drop_target=%p\n",
+          orig_hwnd, orig_point.x, orig_point.y, hwnd, drop_target);
+    return drop_target;
+}
+
 /**********************************************************************
  *          wl_data_offer handling
  */
-- 
2.34.1


From ff4c1abaae635e14f7f8e0a764145306414a6b27 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 23 Sep 2021 12:52:27 +0300
Subject: [PATCH 139/147] winewayland.drv: Handle the wl_data_device::enter
 event.

Relay the event to the IDropTarget at the enter position, and notify the
Wayland compositor of any accepted format/mime type and actions.

The accepted mime type is set indirectly through IDropTarget_DragEnter
eventually calling our IDataObject_(Query)GetData implementation for the
associated data offer.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device.c | 65 ++++++++++++++++++++++
 dlls/winewayland.drv/wayland_surface.c     |  4 ++
 dlls/winewayland.drv/waylanddrv.h          |  4 ++
 3 files changed, 73 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index cd2748f05de..5d78f3e6070 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -86,6 +86,20 @@ static char *normalize_mime_type(const char *mime)
     return new_mime;
 }
 
+static DWORD dnd_actions_to_drop_effect(uint32_t actions)
+{
+    DWORD drop_effect = 0;
+
+    if (actions & WL_DATA_DEVICE_MANAGER_DND_ACTION_COPY)
+        drop_effect |= DROPEFFECT_COPY;
+    if (actions & WL_DATA_DEVICE_MANAGER_DND_ACTION_MOVE)
+        drop_effect |= DROPEFFECT_MOVE;
+    if (actions & WL_DATA_DEVICE_MANAGER_DND_ACTION_ASK)
+        drop_effect |= DROPEFFECT_COPY | DROPEFFECT_MOVE;
+
+    return drop_effect;
+}
+
 /**********************************************************************
  *          IDropTarget discovery
  *
@@ -393,11 +407,62 @@ static void data_device_enter(void *data, struct wl_data_device *wl_data_device,
                               struct wl_data_offer *wl_data_offer)
 {
     struct wayland_data_device *data_device = data;
+    struct wayland_data_offer *data_offer;
+    struct wayland_surface *wayland_surface;
+    IDropTarget *drop_target;
+    POINT point;
+    DWORD drop_effect;
+    HRESULT hr;
 
     /* Any previous dnd offer should have been freed by a drop or leave event. */
     assert(data_device->dnd_wl_data_offer == NULL);
 
     data_device->dnd_wl_data_offer = wl_data_offer;
+
+    if (!wl_data_offer)
+        return;
+
+    data_offer = wl_data_offer_get_user_data(wl_data_offer);
+
+    wayland_surface = wl_surface_get_user_data(wl_surface);
+
+    if (!wayland_surface || !wayland_surface->hwnd)
+        return;
+
+    data_device->dnd_enter_serial = serial;
+    data_device->dnd_surface = wayland_surface;
+    data_device->dnd_x = wl_fixed_to_int(x_w);
+    data_device->dnd_y = wl_fixed_to_int(y_w);
+
+    wayland_surface_coords_to_screen(data_device->dnd_surface,
+                                     data_device->dnd_x, data_device->dnd_y,
+                                     &point.x, &point.y);
+
+    TRACE("surface=%p hwnd=%p source_actions=%x action=%x\n",
+          data_device->dnd_surface, data_device->dnd_surface->hwnd,
+          data_offer->source_actions, data_offer->action);
+
+    drop_target = drop_target_from_window_point(data_device->dnd_surface->hwnd,
+                                                point);
+    if (!drop_target)
+        return;
+
+    /* Clear accepted_mime_type here. It should be eventually set by
+     * IDropTarget_DragEnter, when it internally calls
+     * IDataObject::QueryGetData on our data offer's IDataObject. */
+    data_offer->accepted_mime_type = NULL;
+    drop_effect = dnd_actions_to_drop_effect(data_offer->source_actions);
+    hr = IDropTarget_DragEnter(drop_target, &data_offer->data_object, MK_LBUTTON,
+                               *(POINTL*)&point, &drop_effect);
+    IDropTarget_Release(drop_target);
+    if (FAILED(hr))
+        return;
+
+    wl_data_offer_set_actions(wl_data_offer, data_offer->source_actions,
+                              data_offer->action);
+    wl_data_offer_accept(wl_data_offer,
+                         data_device->dnd_enter_serial,
+                         data_offer->accepted_mime_type);
 }
 
 static void data_device_leave(void *data, struct wl_data_device *wl_data_device)
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 6571b30167e..00d889a2d12 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -647,6 +647,7 @@ void wayland_surface_destroy(struct wayland_surface *surface)
 {
     struct wayland_pointer *pointer = &surface->wayland->pointer;
     struct wayland_keyboard *keyboard = &surface->wayland->keyboard;
+    struct wayland_data_device *data_device = &surface->wayland->data_device;
     struct wayland_surface *child, *child_tmp;
     struct wayland_output_ref *ref, *ref_tmp;
 
@@ -658,6 +659,9 @@ void wayland_surface_destroy(struct wayland_surface *surface)
     if (keyboard->focused_surface == surface)
         keyboard->focused_surface = NULL;
 
+    if (data_device->dnd_surface == surface)
+        data_device->dnd_surface = NULL;
+
     /* There are children left only when we force a destruction during
      * thread deinitialization, otherwise the children hold a reference
      * to the parent and won't let it be destroyed. */
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index f1f7f4fa68d..1cafd853f2b 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -133,6 +133,10 @@ struct wayland_data_device
     struct wl_data_device *wl_data_device;
     struct wl_data_offer *clipboard_wl_data_offer;
     struct wl_data_offer *dnd_wl_data_offer;
+    uint32_t dnd_enter_serial;
+    struct wayland_surface *dnd_surface;
+    int dnd_x;
+    int dnd_y;
 };
 
 struct wayland_data_device_format
-- 
2.34.1


From b1c1ebc068c268836153880c9e1404c370df9931 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 23 Sep 2021 13:02:14 +0300
Subject: [PATCH 140/147] winewayland.drv: Handle the wl_data_device::leave
 event.

Relay the event to the IDropTarget at the current drag-and-drop
position.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device.c | 22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 5d78f3e6070..a5563180562 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -468,7 +468,29 @@ static void data_device_enter(void *data, struct wl_data_device *wl_data_device,
 static void data_device_leave(void *data, struct wl_data_device *wl_data_device)
 {
     struct wayland_data_device *data_device = data;
+    IDropTarget *drop_target;
+    POINT point;
+
+    TRACE("surface=%p hwnd=%p\n",
+          data_device->dnd_surface,
+          data_device->dnd_surface ? data_device->dnd_surface->hwnd : 0);
+
+    if (!data_device->dnd_wl_data_offer || !data_device->dnd_surface)
+        goto out;
 
+    wayland_surface_coords_to_screen(data_device->dnd_surface,
+                                     data_device->dnd_x, data_device->dnd_y,
+                                     &point.x, &point.y);
+
+    drop_target = drop_target_from_window_point(data_device->dnd_surface->hwnd,
+                                                point);
+    if (drop_target)
+    {
+        IDropTarget_DragLeave(drop_target);
+        IDropTarget_Release(drop_target);
+    }
+
+out:
     wayland_data_device_destroy_dnd_data_offer(data_device);
 }
 
-- 
2.34.1


From b80025f2c9a57939d0ed422d1c1243dec5324829 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 23 Sep 2021 13:03:47 +0300
Subject: [PATCH 141/147] winewayland.drv: Handle the wl_data_device::motion
 event.

Relay the event to the IDropTarget at the new drag-and-drop position,
and notify the Wayland compositor of any accepted format/mime type and
actions.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device.c | 40 ++++++++++++++++++++++
 1 file changed, 40 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index a5563180562..9a262b5a125 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -497,6 +497,46 @@ out:
 static void data_device_motion(void *data, struct wl_data_device *wl_data_device,
                                uint32_t time, wl_fixed_t x_w, wl_fixed_t y_w)
 {
+    struct wayland_data_device *data_device = data;
+    struct wayland_data_offer *data_offer;
+    IDropTarget *drop_target;
+    POINT point;
+    DWORD drop_effect;
+    HRESULT hr;
+
+    if (!data_device->dnd_wl_data_offer || !data_device->dnd_surface)
+        return;
+
+    data_offer = wl_data_offer_get_user_data(data_device->dnd_wl_data_offer);
+
+    data_device->dnd_x = wl_fixed_to_int(x_w);
+    data_device->dnd_y = wl_fixed_to_int(y_w);
+
+    wayland_surface_coords_to_screen(data_device->dnd_surface,
+                                     data_device->dnd_x, data_device->dnd_y,
+                                     &point.x, &point.y);
+
+    TRACE("surface=%p hwnd=%p source_actions=%x action=%x\n",
+          data_device->dnd_surface, data_device->dnd_surface->hwnd,
+          data_offer->source_actions, data_offer->action);
+
+    drop_target = drop_target_from_window_point(data_device->dnd_surface->hwnd,
+                                                point);
+    if (!drop_target)
+        return;
+
+    drop_effect = dnd_actions_to_drop_effect(data_offer->source_actions);
+    hr = IDropTarget_DragOver(drop_target, MK_LBUTTON, *(POINTL*)&point, &drop_effect);
+    IDropTarget_Release(drop_target);
+    if (FAILED(hr))
+        return;
+
+    wl_data_offer_set_actions(data_device->dnd_wl_data_offer,
+                              data_offer->source_actions,
+                              data_offer->action);
+    wl_data_offer_accept(data_device->dnd_wl_data_offer,
+                         data_device->dnd_enter_serial,
+                         data_offer->accepted_mime_type);
 }
 
 static void data_device_drop(void *data, struct wl_data_device *wl_data_device)
-- 
2.34.1


From 7b8ad4a82de5f85ff7f8408601984d9e303c4c0e Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 23 Sep 2021 13:05:09 +0300
Subject: [PATCH 142/147] winewayland.drv: Handle the wl_data_device::drop
 event.

Relay the event to the IDropTarget at the current drag-and-drop position,
which will then initiate a data transfer by using the IDataObject_GetData
implementation for the associated Wayland data offer.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_data_device.c | 31 ++++++++++++++++++++++
 1 file changed, 31 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 9a262b5a125..63c558e1f17 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -542,7 +542,38 @@ static void data_device_motion(void *data, struct wl_data_device *wl_data_device
 static void data_device_drop(void *data, struct wl_data_device *wl_data_device)
 {
     struct wayland_data_device *data_device = data;
+    struct wayland_data_offer *data_offer;
+    IDropTarget *drop_target;
+    POINT point;
+    DWORD drop_effect;
+    HRESULT hr;
+
+    if (!data_device->dnd_wl_data_offer || !data_device->dnd_surface)
+        goto out;
+
+    data_offer = wl_data_offer_get_user_data(data_device->dnd_wl_data_offer);
+
+    wayland_surface_coords_to_screen(data_device->dnd_surface,
+                                     data_device->dnd_x, data_device->dnd_y,
+                                     &point.x, &point.y);
 
+    TRACE("surface=%p hwnd=%p source_actions=%x action=%x\n",
+          data_device->dnd_surface, data_device->dnd_surface->hwnd,
+          data_offer->source_actions, data_offer->action);
+
+    drop_target = drop_target_from_window_point(data_device->dnd_surface->hwnd,
+                                                point);
+    if (drop_target)
+    {
+        drop_effect = dnd_actions_to_drop_effect(data_offer->action);
+        hr = IDropTarget_Drop(drop_target, &data_offer->data_object, MK_LBUTTON,
+                              *(POINTL*)&point, &drop_effect);
+        IDropTarget_Release(drop_target);
+        if (SUCCEEDED(hr) && drop_effect != DROPEFFECT_NONE)
+            wl_data_offer_finish(data_device->dnd_wl_data_offer);
+    }
+
+out:
     wayland_data_device_destroy_dnd_data_offer(data_device);
 }
 
-- 
2.34.1


From ccf5315aa154cf075a0f391ef44bbf5da47c6e47 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 24 Sep 2021 11:13:42 +0300
Subject: [PATCH 143/147] winewayland.drv: Support compositor-side scaling.

Introduce a mechanism to select whether we should use application-side
or composidor-side scaling.

With application-side scaling, which is the default, the application has
access to the full/native resolution of the outputs, and needs to manage
scaling manually (e.g., by using the Wine DPI options).

With compositor-side scaling, the application has access only to the
scaled resolution of the outputs, and the compositor automatically
scales the provided buffers.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c        |  2 ++
 dlls/winewayland.drv/wayland_output.c | 27 ++++++++++++++++++++++++++-
 dlls/winewayland.drv/waylanddrv.h     |  7 +++++++
 3 files changed, 35 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 82d8d2da3b3..1df7ae41b62 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -272,6 +272,8 @@ BOOL wayland_init(struct wayland *wayland)
     }
     wl_proxy_set_queue((struct wl_proxy *) wayland->wl_registry, wayland->wl_event_queue);
 
+    wayland->hidpi_scaling = WAYLAND_HIDPI_SCALING_APPLICATION;
+
     wl_list_init(&wayland->output_list);
     wl_list_init(&wayland->toplevel_list);
 
diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index 9e026a0d555..30923ba98de 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -234,6 +234,11 @@ static void wayland_output_update_physical_coords(struct wayland_output *output)
     output->x = output->logical_x;
     output->y = output->logical_y;
 
+    /* When compositor scaling is used, we treat logical coordinates as
+     * physical. */
+    if (output->wayland->hidpi_scaling == WAYLAND_HIDPI_SCALING_COMPOSITOR)
+        return;
+
     /* Update output->x,y based on other outputs that are to
      * to the left or above. */
     wl_list_for_each(o, &output->wayland->output_list, link)
@@ -293,6 +298,17 @@ static void wayland_output_done(struct wayland_output *output)
 
     TRACE("output->name=%s\n", output->name);
 
+    /* When compositor scaling is used, the current and only native mode
+     * corresponds to the logical width and height. */
+    if (output->wayland->hidpi_scaling == WAYLAND_HIDPI_SCALING_COMPOSITOR)
+    {
+        int32_t current_refresh =
+            output->current_mode ? output->current_mode->refresh : 60000;
+        wayland_output_clear_modes(output);
+        wayland_output_add_mode_all_bpp(output, output->logical_w, output->logical_h,
+                                        current_refresh, TRUE, TRUE);
+    }
+
     wayland_output_add_default_modes(output);
     wayland_output_update_physical_coords(output);
 
@@ -333,6 +349,12 @@ static void output_handle_mode(void *data, struct wl_output *wl_output,
 {
     struct wayland_output *output = data;
 
+    /* When compositor scaling is used, we don't use physical width/height
+     * for modes and the current mode will be set based on logical width
+     * and height (see wayland_output_handle()). */
+    if (output->wayland->hidpi_scaling == WAYLAND_HIDPI_SCALING_COMPOSITOR)
+        return;
+
     wayland_output_add_mode_all_bpp(output, width, height, refresh,
                                     (flags & WL_OUTPUT_MODE_CURRENT),
                                     TRUE);
@@ -353,7 +375,10 @@ static void output_handle_scale(void *data, struct wl_output *wl_output,
 {
     struct wayland_output *output = data;
     TRACE("output=%p scale=%d\n", output, scale);
-    output->scale = scale;
+    /* When compositor scaling is used, we ignore the output scale, to
+     * allow the the compositor to scale us. */
+    if (output->wayland->hidpi_scaling != WAYLAND_HIDPI_SCALING_COMPOSITOR)
+        output->scale = scale;
 }
 
 static const struct wl_output_listener output_listener = {
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 1cafd853f2b..7918a5df3ac 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -86,6 +86,12 @@ enum wayland_pointer_confinement
     WAYLAND_POINTER_CONFINEMENT_UNSET_CLIP,
 };
 
+enum wayland_hidpi_scaling
+{
+    WAYLAND_HIDPI_SCALING_APPLICATION,
+    WAYLAND_HIDPI_SCALING_COMPOSITOR,
+};
+
 /**********************************************************************
  *          Definitions for wayland types
  */
@@ -182,6 +188,7 @@ struct wayland
     struct wl_list thread_link;
     HWND clipboard_hwnd;
     RECT cursor_clip;
+    enum wayland_hidpi_scaling hidpi_scaling;
 };
 
 struct wayland_output_mode
-- 
2.34.1


From 355534b6f90efd5b84d8a0cffda8cfee04c29eaf Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 24 Sep 2021 11:22:32 +0300
Subject: [PATCH 144/147] winewayland.drv: Read HiDPI scaling mode from driver
 options in the registry.

Read the "HiDPIScaling" global or per-app driver option to determine the
scaling mode, either "Application" (the default) or "Compositor".

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in  |  1 +
 dlls/winewayland.drv/options.c    | 92 +++++++++++++++++++++++++++++++
 dlls/winewayland.drv/wayland.c    |  1 +
 dlls/winewayland.drv/waylanddrv.h |  1 +
 4 files changed, 95 insertions(+)
 create mode 100644 dlls/winewayland.drv/options.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 903c74e6982..479c5aa60d3 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -14,6 +14,7 @@ C_SRCS = \
 	display.c \
 	gdi.c \
 	opengl.c \
+	options.c \
 	vulkan.c \
 	wayland.c \
 	wayland_output.c \
diff --git a/dlls/winewayland.drv/options.c b/dlls/winewayland.drv/options.c
new file mode 100644
index 00000000000..a1f2a7f229f
--- /dev/null
+++ b/dlls/winewayland.drv/options.c
@@ -0,0 +1,92 @@
+/*
+ * winewayland.drv options
+ *
+ * Copyright 1998 Patrik Stridvall
+ * Copyright 2000 Alexandre Julliard
+ * Copyright 2021 Alexandros Frantzis
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+/* Code to read options from the registry, adapted from the X11 driver */
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/unicode.h"
+
+#include "winreg.h"
+#include "winuser.h"
+
+/***********************************************************************
+ *		get_config_key
+ *
+ * Get a config key from either the app-specific or the default config
+ */
+static inline DWORD get_config_key(HKEY defkey, HKEY appkey, const char *name,
+                                   DWORD flags, char *buffer, DWORD size)
+{
+    if (appkey && !RegGetValueA(appkey, NULL, name, flags, NULL, (LPBYTE)buffer, &size)) return 0;
+    if (defkey && !RegGetValueA(defkey, NULL, name, flags, NULL, (LPBYTE)buffer, &size)) return 0;
+    return ERROR_FILE_NOT_FOUND;
+}
+
+/***********************************************************************
+ *		wayland_read_options_from_registry
+ *
+ * Read the Wayland driver options from the registry.
+ */
+void wayland_read_options_from_registry(struct wayland *wayland)
+{
+    static const WCHAR waylanddriverW[] = {'\\','W','a','y','l','a','n','d',' ','D','r','i','v','e','r',0};
+    char buffer[64];
+    WCHAR bufferW[MAX_PATH + 16];
+    HKEY hkey, appkey = 0;
+    DWORD len;
+
+    /* @@ Wine registry key: HKCU\Software\Wine\Wayland Driver */
+    if (RegOpenKeyA(HKEY_CURRENT_USER, "Software\\Wine\\Wayland Driver", &hkey)) hkey = 0;
+
+    /* open the app-specific key */
+
+    len = GetModuleFileNameW(0, bufferW, MAX_PATH);
+    if (len && len < MAX_PATH)
+    {
+        HKEY tmpkey;
+        WCHAR *p, *appname = bufferW;
+        if ((p = strrchrW(appname, '/'))) appname = p + 1;
+        if ((p = strrchrW(appname, '\\'))) appname = p + 1;
+        CharLowerW(appname);
+        strcatW(appname, waylanddriverW);
+        /* @@ Wine registry key: HKCU\Software\Wine\AppDefaults\app.exe\Wayland Driver */
+        if (!RegOpenKeyA(HKEY_CURRENT_USER, "Software\\Wine\\AppDefaults", &tmpkey))
+        {
+            if (RegOpenKeyW(tmpkey, appname, &appkey)) appkey = 0;
+            RegCloseKey(tmpkey);
+        }
+    }
+
+    if (!get_config_key(hkey, appkey, "HiDPIScaling", RRF_RT_REG_SZ, buffer, sizeof(buffer)))
+    {
+        if (!strcasecmp(buffer, "Application"))
+            wayland->hidpi_scaling = WAYLAND_HIDPI_SCALING_APPLICATION;
+        else if (!strcasecmp(buffer, "Compositor"))
+            wayland->hidpi_scaling = WAYLAND_HIDPI_SCALING_COMPOSITOR;
+    }
+
+    if (appkey) RegCloseKey(appkey);
+    if (hkey) RegCloseKey(hkey);
+}
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 1df7ae41b62..f18c372b626 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -273,6 +273,7 @@ BOOL wayland_init(struct wayland *wayland)
     wl_proxy_set_queue((struct wl_proxy *) wayland->wl_registry, wayland->wl_event_queue);
 
     wayland->hidpi_scaling = WAYLAND_HIDPI_SCALING_APPLICATION;
+    wayland_read_options_from_registry(wayland);
 
     wl_list_init(&wayland->output_list);
     wl_list_init(&wayland->toplevel_list);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 7918a5df3ac..0014021b7e9 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -333,6 +333,7 @@ BOOL wayland_is_process(struct wayland *wayland);
 struct wayland *wayland_process_acquire(void);
 void wayland_process_release(void);
 void wayland_init_display_devices(void);
+void wayland_read_options_from_registry(struct wayland *wayland);
 
 /**********************************************************************
  *          Wayland output
-- 
2.34.1


From 80021a09cd78f0af6dccab4a6404c5f817335779 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 24 Sep 2021 13:36:40 +0300
Subject: [PATCH 145/147] winewayland.drv: Add debugging helpers for pixel
 buffer contents.

During development it's often useful to be able inspect the contents and
window or damage regions of the various buffers involved in software
rendering.

This commit adds helper functions to dump buffer contents to disk, and
uses them to dump the window buffer at flush time, the wayland SHM
buffers at commit time, and the front buffer at update/glFlush time.

These helpers are turned off by default and can be enabled by changing
the value of the corresponding preprocessor define.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |   1 +
 dlls/winewayland.drv/dump_pixels.c     | 171 +++++++++++++++++++++++++
 dlls/winewayland.drv/wayland_surface.c |  12 ++
 dlls/winewayland.drv/waylanddrv.h      |   2 +
 dlls/winewayland.drv/window_surface.c  |  25 ++++
 5 files changed, 211 insertions(+)
 create mode 100644 dlls/winewayland.drv/dump_pixels.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 479c5aa60d3..67671707963 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -12,6 +12,7 @@ EXTRADLLFLAGS = -mcygwin
 
 C_SRCS = \
 	display.c \
+	dump_pixels.c \
 	gdi.c \
 	opengl.c \
 	options.c \
diff --git a/dlls/winewayland.drv/dump_pixels.c b/dlls/winewayland.drv/dump_pixels.c
new file mode 100644
index 00000000000..f72f54e4938
--- /dev/null
+++ b/dlls/winewayland.drv/dump_pixels.c
@@ -0,0 +1,171 @@
+/*
+ * Debugging functions for pixel buffer contents
+ *
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+#include "wine/heap.h"
+
+#include "winuser.h"
+
+#include <assert.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+static RGNDATA *get_region_data(HRGN region)
+{
+    RGNDATA *data = NULL;
+    DWORD size;
+
+    if (!region)
+        return NULL;
+
+    if (!(size = GetRegionData(region, 0, NULL))) goto err;
+    if (!(data = heap_alloc(size))) goto err;
+
+    if (!GetRegionData(region, size, data)) goto err;
+
+    return data;
+
+err:
+    heap_free(data);
+    return NULL;
+}
+
+/* Dump the contents of a pixel buffer, along with the outlines of damage
+ * and window regions, to a netpbm .pam file. */
+void dump_pixels(const char *fpattern, int dbgid, unsigned int *pixels,
+                 int width, int height,
+                 BOOL alpha, HRGN damage, HRGN win_region)
+{
+    char fname[128] = {0};
+    RGNDATA *damage_data;
+    RGNDATA *win_region_data;
+    FILE *fp;
+    int x, y;
+
+    damage_data = get_region_data(damage);
+    win_region_data = get_region_data(win_region);
+
+    snprintf(fname, sizeof(fname), fpattern, dbgid);
+    TRACE("dumping pixels to %s\n", fname);
+
+    fp = fopen(fname, "w");
+    assert(fp && "Failed to open target file for dump pixels. Does the target directory exist?");
+
+    fprintf(fp, "P7\nWIDTH %d\nHEIGHT %d\nDEPTH 4\nMAXVAL 255\nTUPLTYPE RGB_ALPHA\nENDHDR\n",
+            width, height);
+
+    for (y = 0; y < height; ++y)
+    {
+        for (x = 0; x < width; ++x)
+        {
+            BOOL draw_damage = FALSE;
+            BOOL draw_win_region = FALSE;
+            RECT *rgn_rect;
+            RECT *end;
+
+            if (damage_data)
+            {
+                rgn_rect = (RECT *)damage_data->Buffer;
+                end = rgn_rect + damage_data->rdh.nCount;
+
+                /* Draw the outlines of damaged areas. */
+                for (;rgn_rect < end; rgn_rect++)
+                {
+                    if ((y == rgn_rect->top ||
+                         y == rgn_rect->bottom - 1) &&
+                        x >= rgn_rect->left &&
+                        x < (rgn_rect->right))
+                    {
+                        draw_damage = TRUE;
+                        break;
+                    }
+                    if ((x == rgn_rect->left ||
+                         x == rgn_rect->right - 1) &&
+                        y >= rgn_rect->top &&
+                        y < (rgn_rect->bottom))
+                    {
+                        draw_damage = TRUE;
+                        break;
+                    }
+                }
+            }
+
+            if (win_region_data)
+            {
+                /* Draw the outlines of window region areas. */
+                rgn_rect = (RECT *)win_region_data->Buffer;
+                end = rgn_rect + win_region_data->rdh.nCount;
+
+                for (;rgn_rect < end; rgn_rect++)
+                {
+                    if ((y == rgn_rect->top ||
+                         y == rgn_rect->bottom - 1) &&
+                        x >= rgn_rect->left &&
+                        x < (rgn_rect->right))
+                    {
+                        draw_win_region = TRUE;
+                        break;
+                    }
+                    if ((x == rgn_rect->left ||
+                         x == rgn_rect->right - 1) &&
+                        y >= rgn_rect->top &&
+                        y < (rgn_rect->bottom))
+                    {
+                        draw_win_region = TRUE;
+                        break;
+                    }
+                }
+            }
+
+            if (draw_damage || draw_win_region)
+            {
+                unsigned char rgba[4] = {
+                    draw_damage ? 0xff : 0x00,
+                    draw_win_region ? 0xff : 0x00,
+                    0x00, 0xff
+                };
+                fwrite(&rgba, sizeof(rgba), 1, fp);
+            }
+            else
+            {
+                unsigned int *pixel = (unsigned int *)((char *)pixels +
+                                                       width * 4 * y + 4 * x);
+                unsigned char rgba[4] = {
+                    (*pixel & 0x00ff0000) >> 16,
+                    (*pixel & 0x0000ff00) >> 8,
+                    (*pixel & 0xff),
+                    alpha ? (*pixel & 0xff000000) >> 24 : 0xff,
+                };
+
+                fwrite(&rgba, sizeof(rgba), 1, fp);
+            }
+        }
+    }
+
+    fflush(fp);
+    fclose(fp);
+
+    heap_free(damage_data);
+    heap_free(win_region_data);
+}
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 00d889a2d12..3581a094e78 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -29,6 +29,9 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+/* Change to 1 to dump committed buffer contents to disk */
+#define DEBUG_DUMP_COMMIT_BUFFER 0
+
 static void wayland_surface_set_main_output(struct wayland_surface *surface,
                                             struct wayland_output *output);
 
@@ -607,6 +610,15 @@ BOOL wayland_surface_commit_buffer(struct wayland_surface *surface,
         return FALSE;
     }
 
+    if (DEBUG_DUMP_COMMIT_BUFFER)
+    {
+        static int dbgid = 0;
+        dump_pixels("/tmp/winewaylanddbg/commit-%.4d.pam", dbgid++, shm_buffer->map_data,
+                    shm_buffer->width, shm_buffer->height,
+                    shm_buffer->format == WL_SHM_FORMAT_ARGB8888,
+                    shm_buffer->damage_region, NULL);
+    }
+
     wl_surface_attach(surface->wl_surface, shm_buffer->wl_buffer, 0, 0);
 
     /* Add surface damage, i.e., which parts of the surface have changed since
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 0014021b7e9..1ccb00a673b 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -530,6 +530,8 @@ int _xkb_keysyms_to_utf8(const xkb_keysym_t *syms, int nsyms, char *utf8, int ut
  */
 
 void wayland_get_client_rect_in_win_coords(HWND hwnd, RECT *client_rect);
+void dump_pixels(const char *fpattern, int dbgid, unsigned int *pixels, int width, int height,
+                 BOOL alpha, HRGN damage, HRGN win_region);
 
 /**********************************************************************
  *          USER driver functions
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index ef17e711c56..a3febfb6efd 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -36,6 +36,13 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+/* Change to 1 to dump flushed surface buffer contents to disk */
+#define DEBUG_DUMP_FLUSH_SURFACE_BUFFER 0
+
+/* Change to 1 to dump front buffer contents to disk when performing front
+ * buffer rendering. */
+#define DEBUG_DUMP_FRONT_BUFFER 0
+
 struct wayland_window_surface
 {
     struct window_surface header;
@@ -322,6 +329,15 @@ void CDECL wayland_window_surface_flush(struct window_surface *window_surface)
 
     assert(wws->wayland_buffer_queue);
 
+    if (DEBUG_DUMP_FLUSH_SURFACE_BUFFER)
+    {
+        static int dbgid = 0;
+        dump_pixels("/tmp/winewaylanddbg/flush-%.4d.pam", dbgid++, wws->bits,
+                    wws->info.bmiHeader.biWidth, abs(wws->info.bmiHeader.biHeight),
+                    wws->wayland_buffer_queue->format == WL_SHM_FORMAT_ARGB8888,
+                    surface_damage_region, wws->total_region);
+    }
+
     wayland_buffer_queue_add_damage(wws->wayland_buffer_queue, surface_damage_region);
     buffer = wayland_buffer_queue_acquire_buffer(wws->wayland_buffer_queue);
     if (!buffer)
@@ -654,6 +670,15 @@ void wayland_window_surface_update_front_buffer(struct window_surface *window_su
         WARN("Failed to allocate memory for front buffer pixels\n");
     }
 
+    if (DEBUG_DUMP_FRONT_BUFFER && wws->front_bits)
+    {
+        static int dbgid = 0;
+        dump_pixels("/tmp/winewaylanddbg/front-%.4d.pam", dbgid++,
+                    wws->front_bits, wws->info.bmiHeader.biWidth,
+                    abs(wws->info.bmiHeader.biHeight),
+                    FALSE, NULL, NULL);
+    }
+
 out:
     window_surface->funcs->unlock(window_surface);
 }
-- 
2.34.1


From 7953bb4ca3f1eccc3dac9d1e54df68316f175da7 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 10 Dec 2021 13:04:55 +0200
Subject: [PATCH 146/147] winewayland.drv: Experimental support for systray.

Use a standalone systray, adapted from winex11, to present icons for
applications.

Because the context menu on icons is drawn using global positioning
across process boundaries, we cannot currently anchor the menu window
properly to its effective parent (i.e., the icon), and we draw it as a
toplevel instead. Practically this has the effect that the menu window
will be placed at arbitrary locations on the screen by the Wayland
compositor.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in          |   3 +-
 dlls/winewayland.drv/options.c            |   8 +
 dlls/winewayland.drv/systray.c            | 751 ++++++++++++++++++++++
 dlls/winewayland.drv/winewayland.drv.spec |   2 +
 4 files changed, 763 insertions(+), 1 deletion(-)
 create mode 100644 dlls/winewayland.drv/systray.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 67671707963..a289de7ce2a 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,6 +1,6 @@
 MODULE    = winewayland.drv
 IMPORTS   = advapi32 gdi32 user32 uuid win32u
-DELAYIMPORTS = ole32 shell32
+DELAYIMPORTS = comctl32 ole32 shell32
 EXTRAINCL = $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_EGL_CFLAGS) $(XKBCOMMON_CFLAGS)
 EXTRALIBS = $(WAYLAND_CLIENT_LIBS) $(WAYLAND_EGL_LIBS) $(XKBCOMMON_LIBS)
 CFLAGS = -std=c11 -Wno-declaration-after-statement
@@ -16,6 +16,7 @@ C_SRCS = \
 	gdi.c \
 	opengl.c \
 	options.c \
+	systray.c \
 	vulkan.c \
 	wayland.c \
 	wayland_output.c \
diff --git a/dlls/winewayland.drv/options.c b/dlls/winewayland.drv/options.c
index a1f2a7f229f..9f209f813c4 100644
--- a/dlls/winewayland.drv/options.c
+++ b/dlls/winewayland.drv/options.c
@@ -31,6 +31,11 @@
 #include "winreg.h"
 #include "winuser.h"
 
+#define IS_OPTION_TRUE(ch) \
+    ((ch) == 'y' || (ch) == 'Y' || (ch) == 't' || (ch) == 'T' || (ch) == '1')
+
+extern BOOL show_systray;
+
 /***********************************************************************
  *		get_config_key
  *
@@ -87,6 +92,9 @@ void wayland_read_options_from_registry(struct wayland *wayland)
             wayland->hidpi_scaling = WAYLAND_HIDPI_SCALING_COMPOSITOR;
     }
 
+    if (!get_config_key(hkey, appkey, "ShowSystray", RRF_RT_REG_SZ, buffer, sizeof(buffer)))
+        show_systray = IS_OPTION_TRUE(buffer[0]);
+
     if (appkey) RegCloseKey(appkey);
     if (hkey) RegCloseKey(hkey);
 }
diff --git a/dlls/winewayland.drv/systray.c b/dlls/winewayland.drv/systray.c
new file mode 100644
index 00000000000..d65079911a9
--- /dev/null
+++ b/dlls/winewayland.drv/systray.c
@@ -0,0 +1,751 @@
+/*
+ * Wayland system tray management
+ *
+ * Copyright (C) 2004 Mike Hearn, for CodeWeavers
+ * Copyright (C) 2005 Robert Shearman
+ * Copyright (C) 2008 Alexandre Julliard
+ * Copyright (C) 2021 Alexandros Frantzis, for Collabora
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+/* Adapted from winex11.drv/systray.c */
+
+#include "config.h"
+
+#include <assert.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <stdio.h>
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+
+#define NONAMELESSUNION
+#include "windef.h"
+#include "winbase.h"
+#include "wingdi.h"
+#include "winuser.h"
+#include "commctrl.h"
+#include "shellapi.h"
+
+#include "waylanddrv.h"
+#include "wine/list.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(systray);
+
+BOOL show_systray = TRUE;
+
+/* an individual systray icon */
+struct tray_icon
+{
+    struct list    entry;
+    HICON          image;    /* the image to render */
+    HWND           owner;    /* the HWND passed in to the Shell_NotifyIcon call */
+    HWND           window;   /* the adaptor window */
+    BOOL           layered;  /* whether we are using a layered window */
+    HWND           tooltip;  /* Icon tooltip */
+    UINT           state;    /* state flags */
+    UINT           id;       /* the unique id given by the app */
+    UINT           callback_message;
+    int            display;  /* display index, or -1 if hidden */
+    WCHAR          tiptext[128];    /* tooltip text */
+    WCHAR          info_text[256];  /* info balloon text */
+    WCHAR          info_title[64];  /* info balloon title */
+    UINT           info_flags;      /* flags for info balloon */
+    UINT           info_timeout;    /* timeout for info balloon */
+    HICON          info_icon;       /* info balloon icon */
+    UINT           version;         /* notify icon api version */
+};
+
+static struct list icon_list = LIST_INIT( icon_list );
+
+static const WCHAR icon_classname[] = {'_','_','w','i','n','e','x','1','1','_','t','r','a','y','_','i','c','o','n',0};
+static const WCHAR tray_classname[] = {'_','_','w','i','n','e','x','1','1','_','s','t','a','n','d','a','l','o','n','e','_','t','r','a','y',0};
+
+static BOOL show_icon( struct tray_icon *icon );
+static BOOL hide_icon( struct tray_icon *icon );
+static BOOL delete_icon( struct tray_icon *icon );
+
+#define SYSTEM_TRAY_REQUEST_DOCK  0
+#define SYSTEM_TRAY_BEGIN_MESSAGE   1
+#define SYSTEM_TRAY_CANCEL_MESSAGE  2
+
+#define MIN_DISPLAYED 8
+#define ICON_BORDER 2
+
+#define BALLOON_CREATE_TIMER 1
+#define BALLOON_SHOW_TIMER   2
+
+#define BALLOON_CREATE_TIMEOUT   2000
+#define BALLOON_SHOW_MIN_TIMEOUT 10000
+#define BALLOON_SHOW_MAX_TIMEOUT 30000
+
+static struct tray_icon *balloon_icon;
+static HWND balloon_window;
+static POINT balloon_pos;
+
+/* stand-alone tray window */
+static HWND standalone_tray;
+static int icon_cx, icon_cy;
+static unsigned int nb_displayed;
+
+/* retrieves icon record by owner window and ID */
+static struct tray_icon *get_icon(HWND owner, UINT id)
+{
+    struct tray_icon *this;
+
+    LIST_FOR_EACH_ENTRY( this, &icon_list, struct tray_icon, entry )
+        if ((this->id == id) && (this->owner == owner)) return this;
+    return NULL;
+}
+
+static void init_common_controls(void)
+{
+    static BOOL initialized = FALSE;
+
+    if (!initialized)
+    {
+        INITCOMMONCONTROLSEX init_tooltip;
+
+        init_tooltip.dwSize = sizeof(INITCOMMONCONTROLSEX);
+        init_tooltip.dwICC = ICC_TAB_CLASSES;
+
+        InitCommonControlsEx(&init_tooltip);
+        initialized = TRUE;
+    }
+}
+
+/* create tooltip window for icon */
+static void create_tooltip(struct tray_icon *icon)
+{
+    init_common_controls();
+    icon->tooltip = CreateWindowExW( WS_EX_TOPMOST, TOOLTIPS_CLASSW, NULL,
+                                     WS_POPUP | TTS_ALWAYSTIP,
+                                     CW_USEDEFAULT, CW_USEDEFAULT,
+                                     CW_USEDEFAULT, CW_USEDEFAULT,
+                                     icon->window, NULL, NULL, NULL);
+    if (icon->tooltip)
+    {
+        TTTOOLINFOW ti;
+        ZeroMemory(&ti, sizeof(ti));
+        ti.cbSize = sizeof(TTTOOLINFOW);
+        ti.uFlags = TTF_SUBCLASS | TTF_IDISHWND;
+        ti.hwnd = icon->window;
+        ti.uId = (UINT_PTR)icon->window;
+        ti.lpszText = icon->tiptext;
+        SendMessageW(icon->tooltip, TTM_ADDTOOLW, 0, (LPARAM)&ti);
+    }
+}
+
+void update_systray_balloon_position(void)
+{
+    RECT rect;
+    POINT pos;
+
+    if (!balloon_icon) return;
+    GetWindowRect( balloon_icon->window, &rect );
+    pos.x = (rect.left + rect.right) / 2;
+    pos.y = (rect.top + rect.bottom) / 2;
+    if (pos.x == balloon_pos.x && pos.y == balloon_pos.y) return;  /* nothing changed */
+    balloon_pos = pos;
+    SendMessageW( balloon_window, TTM_TRACKPOSITION, 0, MAKELONG( pos.x, pos.y ));
+}
+
+static void balloon_create_timer( struct tray_icon *icon )
+{
+    TTTOOLINFOW ti;
+
+    init_common_controls();
+    balloon_window = CreateWindowExW( WS_EX_TOPMOST, TOOLTIPS_CLASSW, NULL,
+                                      WS_POPUP | TTS_ALWAYSTIP | TTS_NOPREFIX | TTS_BALLOON | TTS_CLOSE,
+                                      CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
+                                      icon->window, NULL, NULL, NULL);
+
+    memset( &ti, 0, sizeof(ti) );
+    ti.cbSize = sizeof(TTTOOLINFOW);
+    ti.hwnd = icon->window;
+    ti.uId = (UINT_PTR)icon->window;
+    ti.uFlags = TTF_TRACK | TTF_IDISHWND;
+    ti.lpszText = icon->info_text;
+    SendMessageW( balloon_window, TTM_ADDTOOLW, 0, (LPARAM)&ti );
+    if ((icon->info_flags & NIIF_ICONMASK) == NIIF_USER)
+        SendMessageW( balloon_window, TTM_SETTITLEW, (WPARAM)icon->info_icon, (LPARAM)icon->info_title );
+    else
+        SendMessageW( balloon_window, TTM_SETTITLEW, icon->info_flags, (LPARAM)icon->info_title );
+    balloon_icon = icon;
+    balloon_pos.x = balloon_pos.y = MAXLONG;
+    update_systray_balloon_position();
+    SendMessageW( balloon_window, TTM_TRACKACTIVATE, TRUE, (LPARAM)&ti );
+    KillTimer( icon->window, BALLOON_CREATE_TIMER );
+    SetTimer( icon->window, BALLOON_SHOW_TIMER, icon->info_timeout, NULL );
+}
+
+static BOOL show_balloon( struct tray_icon *icon )
+{
+    if (standalone_tray && !show_systray) return FALSE;  /* no systray window */
+    if (!icon->window) return FALSE;  /* not displayed */
+    if (!icon->info_text[0]) return FALSE;  /* no balloon */
+    balloon_icon = icon;
+    SetTimer( icon->window, BALLOON_CREATE_TIMER, BALLOON_CREATE_TIMEOUT, NULL );
+    return TRUE;
+}
+
+static void hide_balloon(void)
+{
+    if (!balloon_icon) return;
+    if (balloon_window)
+    {
+        KillTimer( balloon_icon->window, BALLOON_SHOW_TIMER );
+        DestroyWindow( balloon_window );
+        balloon_window = 0;
+    }
+    else KillTimer( balloon_icon->window, BALLOON_CREATE_TIMER );
+    balloon_icon = NULL;
+}
+
+static void show_next_balloon(void)
+{
+    struct tray_icon *icon;
+
+    LIST_FOR_EACH_ENTRY( icon, &icon_list, struct tray_icon, entry )
+        if (show_balloon( icon )) break;
+}
+
+static void update_balloon( struct tray_icon *icon )
+{
+    if (balloon_icon == icon)
+    {
+        hide_balloon();
+        show_balloon( icon );
+    }
+    else if (!balloon_icon)
+    {
+        if (!show_balloon( icon )) return;
+    }
+    if (!balloon_icon) show_next_balloon();
+}
+
+static void balloon_timer(void)
+{
+    if (balloon_icon) balloon_icon->info_text[0] = 0;  /* clear text now that balloon has been shown */
+    hide_balloon();
+    show_next_balloon();
+}
+
+/* synchronize tooltip text with tooltip window */
+static void update_tooltip_text(struct tray_icon *icon)
+{
+    TTTOOLINFOW ti;
+
+    ZeroMemory(&ti, sizeof(ti));
+    ti.cbSize = sizeof(TTTOOLINFOW);
+    ti.uFlags = TTF_SUBCLASS | TTF_IDISHWND;
+    ti.hwnd = icon->window;
+    ti.uId = (UINT_PTR)icon->window;
+    ti.lpszText = icon->tiptext;
+
+    SendMessageW(icon->tooltip, TTM_UPDATETIPTEXTW, 0, (LPARAM)&ti);
+}
+
+/* get the size of the stand-alone tray window */
+static SIZE get_window_size(void)
+{
+    SIZE size;
+    RECT rect;
+
+    rect.left = 0;
+    rect.top = 0;
+    rect.right = icon_cx * max( nb_displayed, MIN_DISPLAYED );
+    rect.bottom = icon_cy;
+    AdjustWindowRect( &rect, WS_CAPTION, FALSE );
+    size.cx = rect.right - rect.left;
+    size.cy = rect.bottom - rect.top;
+    return size;
+}
+
+/* get the position of an icon in the stand-alone tray */
+static POINT get_icon_pos( struct tray_icon *icon )
+{
+    POINT pos;
+
+    pos.x = icon_cx * icon->display;
+    pos.y = 0;
+    return pos;
+}
+
+/* window procedure for the standalone tray window */
+static LRESULT WINAPI standalone_tray_wndproc( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
+{
+    switch (msg)
+    {
+    case WM_MOVE:
+        update_systray_balloon_position();
+        break;
+    case WM_CLOSE:
+        ShowWindow( hwnd, SW_HIDE );
+        hide_balloon();
+        show_systray = FALSE;
+        return 0;
+    case WM_DESTROY:
+        standalone_tray = 0;
+        break;
+    }
+    return DefWindowProcW( hwnd, msg, wparam, lparam );
+}
+
+/* add an icon to the standalone tray window */
+static void add_to_standalone_tray( struct tray_icon *icon )
+{
+    SIZE size;
+    POINT pos;
+
+    if (!standalone_tray)
+    {
+        static const WCHAR winname[] = {'W','i','n','e',' ','S','y','s','t','e','m',' ','T','r','a','y',0};
+
+        size = get_window_size();
+        standalone_tray = CreateWindowExW( 0, tray_classname, winname, WS_CAPTION | WS_SYSMENU,
+                                           CW_USEDEFAULT, CW_USEDEFAULT, size.cx, size.cy, 0, 0, 0, 0 );
+        if (!standalone_tray) return;
+    }
+
+    icon->display = nb_displayed;
+    pos = get_icon_pos( icon );
+    icon->window = CreateWindowW( icon_classname, NULL, WS_CHILD | WS_VISIBLE,
+                                  pos.x, pos.y, icon_cx, icon_cy, standalone_tray, NULL, NULL, icon );
+    if (!icon->window)
+    {
+        icon->display = -1;
+        return;
+    }
+    create_tooltip( icon );
+
+    nb_displayed++;
+    size = get_window_size();
+    SetWindowPos( standalone_tray, 0, 0, 0, size.cx, size.cy, SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER );
+    if (nb_displayed == 1 && show_systray) ShowWindow( standalone_tray, SW_SHOWNA );
+    TRACE( "added %u now %d icons\n", icon->id, nb_displayed );
+}
+
+/* remove an icon from the stand-alone tray */
+static void remove_from_standalone_tray( struct tray_icon *icon )
+{
+    struct tray_icon *ptr;
+    POINT pos;
+
+    if (icon->display == -1) return;
+
+    LIST_FOR_EACH_ENTRY( ptr, &icon_list, struct tray_icon, entry )
+    {
+        if (ptr == icon) continue;
+        if (ptr->display < icon->display) continue;
+        ptr->display--;
+        pos = get_icon_pos( ptr );
+        SetWindowPos( ptr->window, 0, pos.x, pos.y, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER );
+    }
+    icon->display = -1;
+    if (!--nb_displayed) ShowWindow( standalone_tray, SW_HIDE );
+    TRACE( "removed %u now %d icons\n", icon->id, nb_displayed );
+}
+
+static void repaint_tray_icon( struct tray_icon *icon )
+{
+    BLENDFUNCTION blend = { AC_SRC_OVER, 0, 255, AC_SRC_ALPHA };
+    int width = GetSystemMetrics( SM_CXSMICON );
+    int height = GetSystemMetrics( SM_CYSMICON );
+    BITMAPINFO *info;
+    HBITMAP dib, mask;
+    HDC hdc;
+    RECT rc;
+    SIZE size;
+    POINT pos;
+    int i, x, y;
+    void *color_bits, *mask_bits;
+    DWORD *ptr;
+    BOOL has_alpha = FALSE;
+
+    GetWindowRect( icon->window, &rc );
+    size.cx = rc.right - rc.left;
+    size.cy = rc.bottom - rc.top;
+    pos.x = (size.cx - width) / 2;
+    pos.y = (size.cy - height) / 2;
+
+    info = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, FIELD_OFFSET( BITMAPINFO, bmiColors[2] ));
+    if (!info) return;
+    info->bmiHeader.biSize = sizeof(info->bmiHeader);
+    info->bmiHeader.biWidth = size.cx;
+    info->bmiHeader.biHeight = size.cy;
+    info->bmiHeader.biBitCount = 32;
+    info->bmiHeader.biPlanes = 1;
+    info->bmiHeader.biCompression = BI_RGB;
+
+    hdc = CreateCompatibleDC( 0 );
+    if (!(dib = CreateDIBSection( 0, info, DIB_RGB_COLORS, &color_bits, NULL, 0 ))) goto done;
+    SelectObject( hdc, dib );
+    DrawIconEx( hdc, pos.x, pos.y, icon->image, width, height, 0, 0, DI_DEFAULTSIZE | DI_NORMAL );
+
+    /* check if the icon was drawn with an alpha channel */
+    for (i = 0, ptr = color_bits; i < size.cx * size.cy; i++)
+        if ((has_alpha = (ptr[i] & 0xff000000) != 0)) break;
+
+    if (!has_alpha)
+    {
+        unsigned int width_bytes = (size.cx + 31) / 32 * 4;
+
+        info->bmiHeader.biBitCount = 1;
+        info->bmiColors[0].rgbRed      = 0;
+        info->bmiColors[0].rgbGreen    = 0;
+        info->bmiColors[0].rgbBlue     = 0;
+        info->bmiColors[0].rgbReserved = 0;
+        info->bmiColors[1].rgbRed      = 0xff;
+        info->bmiColors[1].rgbGreen    = 0xff;
+        info->bmiColors[1].rgbBlue     = 0xff;
+        info->bmiColors[1].rgbReserved = 0;
+
+        if (!(mask = CreateDIBSection( 0, info, DIB_RGB_COLORS, &mask_bits, NULL, 0 ))) goto done;
+        memset( mask_bits, 0xff, width_bytes * size.cy );
+        SelectObject( hdc, mask );
+        DrawIconEx( hdc, pos.x, pos.y, icon->image, width, height, 0, 0, DI_DEFAULTSIZE | DI_MASK );
+
+        for (y = 0, ptr = color_bits; y < size.cy; y++)
+            for (x = 0; x < size.cx; x++, ptr++)
+                if (!((((BYTE *)mask_bits)[y * width_bytes + x / 8] << (x % 8)) & 0x80))
+                    *ptr |= 0xff000000;
+
+        SelectObject( hdc, dib );
+        DeleteObject( mask );
+    }
+
+    UpdateLayeredWindow( icon->window, 0, NULL, NULL, hdc, NULL, 0, &blend, ULW_ALPHA );
+done:
+    HeapFree (GetProcessHeap(), 0, info);
+    if (hdc) DeleteDC( hdc );
+    if (dib) DeleteObject( dib );
+}
+
+static BOOL notify_owner( struct tray_icon *icon, UINT msg, LPARAM lparam )
+{
+    WPARAM wp = icon->id;
+    LPARAM lp = msg;
+
+    if (icon->version >= NOTIFYICON_VERSION_4)
+    {
+        POINT pt = { (short)LOWORD(lparam), (short)HIWORD(lparam) };
+
+        ClientToScreen( icon->window, &pt );
+        wp = MAKEWPARAM( pt.x, pt.y );
+        lp = MAKELPARAM( msg, icon->id );
+    }
+
+    TRACE( "relaying 0x%x\n", msg );
+    if (!SendNotifyMessageW( icon->owner, icon->callback_message, wp, lp ) &&
+        (GetLastError() == ERROR_INVALID_WINDOW_HANDLE))
+    {
+        WARN( "application window was destroyed, removing icon %u\n", icon->id );
+        delete_icon( icon );
+        return FALSE;
+    }
+    return TRUE;
+}
+
+/* window procedure for the individual tray icon window */
+static LRESULT WINAPI tray_icon_wndproc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
+{
+    struct tray_icon *icon = NULL;
+
+    TRACE("hwnd=%p, msg=0x%x\n", hwnd, msg);
+
+    /* set the icon data for the window from the data passed into CreateWindow */
+    if (msg == WM_NCCREATE)
+        SetWindowLongPtrW(hwnd, GWLP_USERDATA, (LPARAM)((const CREATESTRUCTW *)lparam)->lpCreateParams);
+
+    icon = (struct tray_icon *) GetWindowLongPtrW(hwnd, GWLP_USERDATA);
+
+    switch (msg)
+    {
+    case WM_SIZE:
+        if (icon->window && icon->layered) repaint_tray_icon( icon );
+        break;
+
+    case WM_PAINT:
+        if (!icon->layered)
+        {
+            PAINTSTRUCT ps;
+            RECT rc;
+            HDC hdc;
+            int cx = GetSystemMetrics( SM_CXSMICON );
+            int cy = GetSystemMetrics( SM_CYSMICON );
+
+            hdc = BeginPaint(hwnd, &ps);
+            GetClientRect(hwnd, &rc);
+            TRACE("painting rect %s\n", wine_dbgstr_rect(&rc));
+            DrawIconEx( hdc, (rc.left + rc.right - cx) / 2, (rc.top + rc.bottom - cy) / 2,
+                        icon->image, cx, cy, 0, 0, DI_DEFAULTSIZE|DI_NORMAL );
+            EndPaint(hwnd, &ps);
+            return 0;
+        }
+        break;
+
+    case WM_MOUSEMOVE:
+    case WM_LBUTTONDOWN:
+    case WM_RBUTTONDOWN:
+    case WM_MBUTTONDOWN:
+    case WM_MBUTTONUP:
+    case WM_LBUTTONDBLCLK:
+    case WM_RBUTTONDBLCLK:
+    case WM_MBUTTONDBLCLK:
+        notify_owner( icon, msg, lparam );
+        break;
+
+    case WM_LBUTTONUP:
+        if (!notify_owner( icon, msg, lparam )) break;
+        if (icon->version > 0) notify_owner( icon, NIN_SELECT, lparam );
+        break;
+
+    case WM_RBUTTONUP:
+        if (!notify_owner( icon, msg, lparam )) break;
+        if (icon->version > 0) notify_owner( icon, WM_CONTEXTMENU, lparam );
+        break;
+
+    case WM_WINDOWPOSCHANGED:
+        update_systray_balloon_position();
+        break;
+
+    case WM_TIMER:
+        switch (wparam)
+        {
+        case BALLOON_CREATE_TIMER:
+            balloon_create_timer( icon );
+            break;
+        case BALLOON_SHOW_TIMER:
+            balloon_timer();
+            break;
+        }
+        return 0;
+
+    case WM_CLOSE:
+        if (icon->display == -1)
+        {
+            TRACE( "icon %u no longer embedded\n", icon->id );
+            hide_icon( icon );
+            add_to_standalone_tray( icon );
+        }
+        return 0;
+    }
+    return DefWindowProcW( hwnd, msg, wparam, lparam );
+}
+
+static BOOL init_systray(void)
+{
+    static BOOL init_done;
+    WNDCLASSEXW class;
+
+    if (init_done) return TRUE;
+
+    icon_cx = GetSystemMetrics( SM_CXSMICON ) + 2 * ICON_BORDER;
+    icon_cy = GetSystemMetrics( SM_CYSMICON ) + 2 * ICON_BORDER;
+
+    memset( &class, 0, sizeof(class) );
+    class.cbSize        = sizeof(class);
+    class.lpfnWndProc   = tray_icon_wndproc;
+    class.hIcon         = LoadIconW(0, (LPCWSTR)IDI_WINLOGO);
+    class.hCursor       = LoadCursorW( 0, (LPCWSTR)IDC_ARROW );
+    class.lpszClassName = icon_classname;
+    class.style         = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
+
+    if (!RegisterClassExW( &class ) && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
+    {
+        ERR( "Could not register icon tray window class\n" );
+        return FALSE;
+    }
+
+    class.lpfnWndProc   = standalone_tray_wndproc;
+    class.hbrBackground = (HBRUSH)COLOR_WINDOW;
+    class.lpszClassName = tray_classname;
+    class.style         = CS_DBLCLKS;
+
+    if (!RegisterClassExW( &class ) && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
+    {
+        ERR( "Could not register standalone tray window class\n" );
+        return FALSE;
+    }
+
+    init_done = TRUE;
+    return TRUE;
+}
+
+/* hide a tray icon */
+static BOOL hide_icon( struct tray_icon *icon )
+{
+    TRACE( "id=0x%x, hwnd=%p\n", icon->id, icon->owner );
+
+    if (!icon->window) return TRUE;  /* already hidden */
+
+    DestroyWindow(icon->window);
+    DestroyWindow(icon->tooltip);
+    icon->window = 0;
+    icon->layered = FALSE;
+    icon->tooltip = 0;
+    remove_from_standalone_tray( icon );
+    update_balloon( icon );
+    return TRUE;
+}
+
+/* make the icon visible */
+static BOOL show_icon( struct tray_icon *icon )
+{
+    TRACE( "id=0x%x, hwnd=%p\n", icon->id, icon->owner );
+
+    if (icon->window) return TRUE;  /* already shown */
+
+    add_to_standalone_tray( icon );
+
+    update_balloon( icon );
+    return TRUE;
+}
+
+/* Modifies an existing icon record */
+static BOOL modify_icon( struct tray_icon *icon, NOTIFYICONDATAW *nid )
+{
+    TRACE( "id=0x%x hwnd=%p flags=%x\n", nid->uID, nid->hWnd, nid->uFlags );
+
+    if (nid->uFlags & NIF_STATE)
+    {
+        icon->state = (icon->state & ~nid->dwStateMask) | (nid->dwState & nid->dwStateMask);
+    }
+
+    if (nid->uFlags & NIF_ICON)
+    {
+        if (icon->image) DestroyIcon(icon->image);
+        icon->image = CopyIcon(nid->hIcon);
+        if (icon->window)
+        {
+            if (icon->display != -1) InvalidateRect( icon->window, NULL, TRUE );
+            else if (icon->layered) repaint_tray_icon( icon );
+        }
+    }
+
+    if (nid->uFlags & NIF_MESSAGE)
+    {
+        icon->callback_message = nid->uCallbackMessage;
+    }
+    if (nid->uFlags & NIF_TIP)
+    {
+        lstrcpynW(icon->tiptext, nid->szTip, ARRAY_SIZE( icon->tiptext ));
+        if (icon->tooltip) update_tooltip_text(icon);
+    }
+    if (nid->uFlags & NIF_INFO && nid->cbSize >= NOTIFYICONDATAA_V2_SIZE)
+    {
+        lstrcpynW( icon->info_text, nid->szInfo, ARRAY_SIZE( icon->info_text ));
+        lstrcpynW( icon->info_title, nid->szInfoTitle, ARRAY_SIZE( icon->info_title ));
+        icon->info_flags = nid->dwInfoFlags;
+        icon->info_timeout = max(min(nid->u.uTimeout, BALLOON_SHOW_MAX_TIMEOUT), BALLOON_SHOW_MIN_TIMEOUT);
+        icon->info_icon = nid->hBalloonIcon;
+        update_balloon( icon );
+    }
+    if (icon->state & NIS_HIDDEN) hide_icon( icon );
+    else show_icon( icon );
+    return TRUE;
+}
+
+/* Adds a new icon record to the list */
+static BOOL add_icon(NOTIFYICONDATAW *nid)
+{
+    struct tray_icon  *icon;
+
+    TRACE("id=0x%x, hwnd=%p\n", nid->uID, nid->hWnd);
+
+    if ((icon = get_icon(nid->hWnd, nid->uID)))
+    {
+        WARN("duplicate tray icon add, buggy app?\n");
+        return FALSE;
+    }
+
+    if (!(icon = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*icon))))
+    {
+        ERR("out of memory\n");
+        return FALSE;
+    }
+
+    ZeroMemory(icon, sizeof(struct tray_icon));
+    icon->id     = nid->uID;
+    icon->owner  = nid->hWnd;
+    icon->display = -1;
+
+    list_add_tail(&icon_list, &icon->entry);
+
+    return modify_icon( icon, nid );
+}
+
+/* delete tray icon window and icon structure */
+static BOOL delete_icon( struct tray_icon *icon )
+{
+    hide_icon( icon );
+    list_remove( &icon->entry );
+    DestroyIcon( icon->image );
+    HeapFree( GetProcessHeap(), 0, icon );
+    return TRUE;
+}
+
+/* cleanup all icons for a given window */
+static void cleanup_icons( HWND owner )
+{
+    struct tray_icon *this, *next;
+
+    LIST_FOR_EACH_ENTRY_SAFE( this, next, &icon_list, struct tray_icon, entry )
+        if (this->owner == owner) delete_icon( this );
+}
+
+
+/***********************************************************************
+ *              wine_notify_icon
+ *
+ * Driver-side implementation of Shell_NotifyIcon.
+ */
+int CDECL wine_notify_icon( DWORD msg, NOTIFYICONDATAW *data )
+{
+    BOOL ret = FALSE;
+    struct tray_icon *icon;
+
+    switch (msg)
+    {
+    case NIM_ADD:
+        if (!init_systray()) return -1;  /* fall back to default handling */
+        ret = add_icon( data );
+        break;
+    case NIM_DELETE:
+        if ((icon = get_icon( data->hWnd, data->uID ))) ret = delete_icon( icon );
+        break;
+    case NIM_MODIFY:
+        if ((icon = get_icon( data->hWnd, data->uID ))) ret = modify_icon( icon, data );
+        break;
+    case NIM_SETVERSION:
+        if ((icon = get_icon( data->hWnd, data->uID )))
+        {
+            icon->version = data->u.uVersion;
+            ret = TRUE;
+        }
+        break;
+    case 0xdead:  /* Wine extension: owner window has died */
+        cleanup_icons( data->hWnd );
+        break;
+    default:
+        FIXME( "unhandled tray message: %u\n", msg );
+        break;
+    }
+    return ret;
+}
diff --git a/dlls/winewayland.drv/winewayland.drv.spec b/dlls/winewayland.drv/winewayland.drv.spec
index e69de29bb2d..5f086f5c4e5 100644
--- a/dlls/winewayland.drv/winewayland.drv.spec
+++ b/dlls/winewayland.drv/winewayland.drv.spec
@@ -0,0 +1,2 @@
+# System tray
+@ cdecl wine_notify_icon(long ptr)
-- 
2.34.1


From 92fff3283a10337a1ab35871bd8c292832f8fbe8 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 8 Dec 2021 16:30:05 +0200
Subject: [PATCH 147/147] winewayland.drv: Input event compatibility with
 wine-staging

The rawinput patches in wine-staging require the drivers to send
INPUT_MOUSE and INPUT_KEYBOARD events with a non-NULL rawinput
parameter. Since the rawinput parameter is currently ignored in
upstream for such events, apply this change to maintain a unified
codebase across upstream and staging.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_keyboard.c |  3 ++-
 dlls/winewayland.drv/wayland_pointer.c  | 12 ++++++++----
 2 files changed, 10 insertions(+), 5 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index 4f634e319f5..aebfc05f59d 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -207,6 +207,7 @@ static inline xkb_keycode_t linux_input_keycode_to_xkb(uint32_t key)
 static void send_keyboard_input(HWND hwnd, WORD vkey, WORD scan, DWORD flags)
 {
     INPUT input;
+    RAWINPUT rawinput;
 
     input.type             = INPUT_KEYBOARD;
     input.u.ki.wVk         = vkey;
@@ -215,7 +216,7 @@ static void send_keyboard_input(HWND hwnd, WORD vkey, WORD scan, DWORD flags)
     input.u.ki.time        = 0;
     input.u.ki.dwExtraInfo = 0;
 
-    __wine_send_input(hwnd, &input, NULL);
+    __wine_send_input(hwnd, &input, &rawinput);
 }
 
 static WCHAR dead_xkb_keysym_to_wchar(xkb_keysym_t xkb_keysym)
diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 00def0eecf2..3c62c4a8d3b 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -42,6 +42,7 @@ static void pointer_handle_motion_internal(void *data, struct wl_pointer *pointe
                         wayland->pointer.focused_surface->hwnd : 0;
     INPUT input = {0};
     int screen_x, screen_y;
+    RAWINPUT rawinput;
 
     if (!focused_hwnd)
         return;
@@ -64,7 +65,7 @@ static void pointer_handle_motion_internal(void *data, struct wl_pointer *pointe
     wayland->last_dispatch_mask |= QS_MOUSEMOVE;
     wayland->last_event_type = INPUT_MOUSE;
 
-    __wine_send_input(focused_hwnd, &input, NULL);
+    __wine_send_input(focused_hwnd, &input, &rawinput);
 }
 
 static void pointer_handle_motion(void *data, struct wl_pointer *pointer,
@@ -145,6 +146,7 @@ static void pointer_handle_button(void *data, struct wl_pointer *wl_pointer,
     HWND focused_hwnd = wayland->pointer.focused_surface ?
                         wayland->pointer.focused_surface->hwnd : 0;
     INPUT input = {0};
+    RAWINPUT rawinput;
 
     if (!focused_hwnd)
         return;
@@ -172,7 +174,7 @@ static void pointer_handle_button(void *data, struct wl_pointer *wl_pointer,
     else
         wayland->last_button_serial = 0;
 
-    __wine_send_input(focused_hwnd, &input, NULL);
+    __wine_send_input(focused_hwnd, &input, &rawinput);
 }
 
 static void pointer_handle_axis(void *data, struct wl_pointer *wl_pointer,
@@ -201,6 +203,7 @@ static void pointer_handle_axis_discrete(void *data, struct wl_pointer *wl_point
     HWND focused_hwnd = wayland->pointer.focused_surface ?
                         wayland->pointer.focused_surface->hwnd : 0;
     INPUT input = {0};
+    RAWINPUT rawinput;
 
     if (!focused_hwnd)
         return;
@@ -225,7 +228,7 @@ static void pointer_handle_axis_discrete(void *data, struct wl_pointer *wl_point
     wayland->last_dispatch_mask |= QS_MOUSEBUTTON;
     wayland->last_event_type = INPUT_MOUSE;
 
-    __wine_send_input(focused_hwnd, &input, NULL);
+    __wine_send_input(focused_hwnd, &input, &rawinput);
 }
 
 static const struct wl_pointer_listener pointer_listener = {
@@ -254,6 +257,7 @@ static void relative_pointer_handle_motion(void *data,
                         wayland->pointer.focused_surface->hwnd : 0;
     int wine_dx, wine_dy;
     INPUT input = {0};
+    RAWINPUT rawinput;
 
     if (!focused_hwnd)
         return;
@@ -274,7 +278,7 @@ static void relative_pointer_handle_motion(void *data,
     wayland->last_dispatch_mask |= QS_MOUSEMOVE;
     wayland->last_event_type = INPUT_MOUSE;
 
-    __wine_send_input(focused_hwnd, &input, NULL);
+    __wine_send_input(focused_hwnd, &input, &rawinput);
 }
 
 static const struct zwp_relative_pointer_v1_listener zwp_relative_pointer_v1_listener = {
-- 
2.34.1


From db8d6a0d80512590dd601e4a16d8709210c7b055 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sun, 4 May 2025 14:13:08 -0400
Subject: [PATCH 001/159] use surfaceless for GST

---
 dlls/winegstreamer/unixlib.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/dlls/winegstreamer/unixlib.c b/dlls/winegstreamer/unixlib.c
index 0d1b3b6f65a..cd631535b50 100644
--- a/dlls/winegstreamer/unixlib.c
+++ b/dlls/winegstreamer/unixlib.c
@@ -278,7 +278,6 @@ NTSTATUS wg_init_gstreamer(void *arg)
     if (params->err_on)
         setenv("GST_DEBUG", "1", FALSE);
     setenv("GST_DEBUG_NO_COLOR", "1", FALSE);
-    setenv("GST_GL_WINDOW", "x11", 1);
 
     /* GStreamer installs a temporary SEGV handler when it loads plugins
      * to initialize its registry calling exit(-1) when any fault is caught.
@@ -322,7 +321,7 @@ NTSTATUS wg_init_gstreamer(void *arg)
     GST_INFO("GStreamer library version %s; wine built with %d.%d.%d.",
             gst_version_string(), GST_VERSION_MAJOR, GST_VERSION_MINOR, GST_VERSION_MICRO);
 
-    if (!(gl_display = gst_gl_display_new()))
+    if (!(gl_display = gst_gl_display_new_with_type(GST_GL_DISPLAY_TYPE_EGL_SURFACELESS)))
         GST_ERROR("Failed to create OpenGL display");
     else
     {
-- 
2.49.0

From 8e51718a91091d3fec0245a0951eff0a8ca9e353 Mon Sep 17 00:00:00 2001
From: Attila Fidan <dev@print0.net>
Date: Sun, 2 Feb 2025 07:53:36 +0000
Subject: [PATCH 002/159] winewayland: Enable/disable the zwp_text_input_v3
 object.

---
 dlls/winewayland.drv/Makefile.in              |   2 +
 .../text-input-unstable-v3.xml                | 457 ++++++++++++++++++
 dlls/winewayland.drv/wayland.c                |  12 +
 dlls/winewayland.drv/wayland_text_input.c     | 109 +++++
 dlls/winewayland.drv/waylanddrv.h             |  16 +
 5 files changed, 596 insertions(+)
 create mode 100644 dlls/winewayland.drv/text-input-unstable-v3.xml
 create mode 100644 dlls/winewayland.drv/wayland_text_input.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 9ad1ad6889d..9129a3f2839 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -9,6 +9,7 @@ SOURCES = \
 	opengl.c \
 	pointer-constraints-unstable-v1.xml \
 	relative-pointer-unstable-v1.xml \
+	text-input-unstable-v3.xml \
 	version.rc \
 	viewporter.xml \
 	vulkan.c \
@@ -17,6 +18,7 @@ SOURCES = \
 	wayland_output.c \
 	wayland_pointer.c \
 	wayland_surface.c \
+	wayland_text_input.c \
 	waylanddrv_main.c \
 	window.c \
 	window_surface.c \
diff --git a/dlls/winewayland.drv/text-input-unstable-v3.xml b/dlls/winewayland.drv/text-input-unstable-v3.xml
new file mode 100644
index 00000000000..1fae54d7ba7
--- /dev/null
+++ b/dlls/winewayland.drv/text-input-unstable-v3.xml
@@ -0,0 +1,457 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<protocol name="text_input_unstable_v3">
+  <copyright>
+    Copyright © 2012, 2013 Intel Corporation
+    Copyright © 2015, 2016 Jan Arne Petersen
+    Copyright © 2017, 2018 Red Hat, Inc.
+    Copyright © 2018       Purism SPC
+
+    Permission to use, copy, modify, distribute, and sell this
+    software and its documentation for any purpose is hereby granted
+    without fee, provided that the above copyright notice appear in
+    all copies and that both that copyright notice and this permission
+    notice appear in supporting documentation, and that the name of
+    the copyright holders not be used in advertising or publicity
+    pertaining to distribution of the software without specific,
+    written prior permission.  The copyright holders make no
+    representations about the suitability of this software for any
+    purpose.  It is provided "as is" without express or implied
+    warranty.
+
+    THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+    SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+    FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+    SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+    AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+    ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
+    THIS SOFTWARE.
+  </copyright>
+
+  <description summary="Protocol for composing text">
+    This protocol allows compositors to act as input methods and to send text
+    to applications. A text input object is used to manage state of what are
+    typically text entry fields in the application.
+
+    This document adheres to the RFC 2119 when using words like "must",
+    "should", "may", etc.
+
+    Warning! The protocol described in this file is experimental and
+    backward incompatible changes may be made. Backward compatible changes
+    may be added together with the corresponding interface version bump.
+    Backward incompatible changes are done by bumping the version number in
+    the protocol and interface names and resetting the interface version.
+    Once the protocol is to be declared stable, the 'z' prefix and the
+    version number in the protocol and interface names are removed and the
+    interface version number is reset.
+  </description>
+
+  <interface name="zwp_text_input_v3" version="1">
+    <description summary="text input">
+      The zwp_text_input_v3 interface represents text input and input methods
+      associated with a seat. It provides enter/leave events to follow the
+      text input focus for a seat.
+
+      Requests are used to enable/disable the text-input object and set
+      state information like surrounding and selected text or the content type.
+      The information about the entered text is sent to the text-input object
+      via the preedit_string and commit_string events.
+
+      Text is valid UTF-8 encoded, indices and lengths are in bytes. Indices
+      must not point to middle bytes inside a code point: they must either
+      point to the first byte of a code point or to the end of the buffer.
+      Lengths must be measured between two valid indices.
+
+      Focus moving throughout surfaces will result in the emission of
+      zwp_text_input_v3.enter and zwp_text_input_v3.leave events. The focused
+      surface must commit zwp_text_input_v3.enable and
+      zwp_text_input_v3.disable requests as the keyboard focus moves across
+      editable and non-editable elements of the UI. Those two requests are not
+      expected to be paired with each other, the compositor must be able to
+      handle consecutive series of the same request.
+
+      State is sent by the state requests (set_surrounding_text,
+      set_content_type and set_cursor_rectangle) and a commit request. After an
+      enter event or disable request all state information is invalidated and
+      needs to be resent by the client.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="Destroy the wp_text_input">
+        Destroy the wp_text_input object. Also disables all surfaces enabled
+        through this wp_text_input object.
+      </description>
+    </request>
+
+    <request name="enable">
+      <description summary="Request text input to be enabled">
+        Requests text input on the surface previously obtained from the enter
+        event.
+
+        This request must be issued every time the active text input changes
+        to a new one, including within the current surface. Use
+        zwp_text_input_v3.disable when there is no longer any input focus on
+        the current surface.
+
+        Clients must not enable more than one text input on the single seat
+        and should disable the current text input before enabling the new one.
+        At most one instance of text input may be in enabled state per instance,
+        Requests to enable the another text input when some text input is active
+        must be ignored by compositor.
+
+        This request resets all state associated with previous enable, disable,
+        set_surrounding_text, set_text_change_cause, set_content_type, and
+        set_cursor_rectangle requests, as well as the state associated with
+        preedit_string, commit_string, and delete_surrounding_text events.
+
+        The set_surrounding_text, set_content_type and set_cursor_rectangle
+        requests must follow if the text input supports the necessary
+        functionality.
+
+        State set with this request is double-buffered. It will get applied on
+        the next zwp_text_input_v3.commit request, and stay valid until the
+        next committed enable or disable request.
+
+        The changes must be applied by the compositor after issuing a
+        zwp_text_input_v3.commit request.
+      </description>
+    </request>
+
+    <request name="disable">
+      <description summary="Disable text input on a surface">
+        Explicitly disable text input on the current surface (typically when
+        there is no focus on any text entry inside the surface).
+
+        State set with this request is double-buffered. It will get applied on
+        the next zwp_text_input_v3.commit request.
+      </description>
+    </request>
+
+    <request name="set_surrounding_text">
+      <description summary="sets the surrounding text">
+        Sets the surrounding plain text around the input, excluding the preedit
+        text.
+
+        The client should notify the compositor of any changes in any of the
+        values carried with this request, including changes caused by handling
+        incoming text-input events as well as changes caused by other
+        mechanisms like keyboard typing.
+
+        If the client is unaware of the text around the cursor, it should not
+        issue this request, to signify lack of support to the compositor.
+
+        Text is UTF-8 encoded, and should include the cursor position, the
+        complete selection and additional characters before and after them.
+        There is a maximum length of wayland messages, so text can not be
+        longer than 4000 bytes.
+
+        Cursor is the byte offset of the cursor within text buffer.
+
+        Anchor is the byte offset of the selection anchor within text buffer.
+        If there is no selected text, anchor is the same as cursor.
+
+        If any preedit text is present, it is replaced with a cursor for the
+        purpose of this event.
+
+        Values set with this request are double-buffered. They will get applied
+        on the next zwp_text_input_v3.commit request, and stay valid until the
+        next committed enable or disable request.
+
+        The initial state for affected fields is empty, meaning that the text
+        input does not support sending surrounding text. If the empty values
+        get applied, subsequent attempts to change them may have no effect.
+      </description>
+      <arg name="text" type="string"/>
+      <arg name="cursor" type="int"/>
+      <arg name="anchor" type="int"/>
+    </request>
+
+    <enum name="change_cause">
+      <description summary="text change reason">
+        Reason for the change of surrounding text or cursor posision.
+      </description>
+      <entry name="input_method" value="0" summary="input method caused the change"/>
+      <entry name="other" value="1" summary="something else than the input method caused the change"/>
+    </enum>
+
+    <request name="set_text_change_cause">
+      <description summary="indicates the cause of surrounding text change">
+        Tells the compositor why the text surrounding the cursor changed.
+
+        Whenever the client detects an external change in text, cursor, or
+        anchor posision, it must issue this request to the compositor. This
+        request is intended to give the input method a chance to update the
+        preedit text in an appropriate way, e.g. by removing it when the user
+        starts typing with a keyboard.
+
+        cause describes the source of the change.
+
+        The value set with this request is double-buffered. It must be applied
+        and reset to initial at the next zwp_text_input_v3.commit request.
+
+        The initial value of cause is input_method.
+      </description>
+      <arg name="cause" type="uint" enum="change_cause"/>
+    </request>
+
+    <enum name="content_hint" bitfield="true">
+      <description summary="content hint">
+        Content hint is a bitmask to allow to modify the behavior of the text
+        input.
+      </description>
+      <entry name="none" value="0x0" summary="no special behavior"/>
+      <entry name="completion" value="0x1" summary="suggest word completions"/>
+      <entry name="spellcheck" value="0x2" summary="suggest word corrections"/>
+      <entry name="auto_capitalization" value="0x4" summary="switch to uppercase letters at the start of a sentence"/>
+      <entry name="lowercase" value="0x8" summary="prefer lowercase letters"/>
+      <entry name="uppercase" value="0x10" summary="prefer uppercase letters"/>
+      <entry name="titlecase" value="0x20" summary="prefer casing for titles and headings (can be language dependent)"/>
+      <entry name="hidden_text" value="0x40" summary="characters should be hidden"/>
+      <entry name="sensitive_data" value="0x80" summary="typed text should not be stored"/>
+      <entry name="latin" value="0x100" summary="just Latin characters should be entered"/>
+      <entry name="multiline" value="0x200" summary="the text input is multiline"/>
+    </enum>
+
+    <enum name="content_purpose">
+      <description summary="content purpose">
+        The content purpose allows to specify the primary purpose of a text
+        input.
+
+        This allows an input method to show special purpose input panels with
+        extra characters or to disallow some characters.
+      </description>
+      <entry name="normal" value="0" summary="default input, allowing all characters"/>
+      <entry name="alpha" value="1" summary="allow only alphabetic characters"/>
+      <entry name="digits" value="2" summary="allow only digits"/>
+      <entry name="number" value="3" summary="input a number (including decimal separator and sign)"/>
+      <entry name="phone" value="4" summary="input a phone number"/>
+      <entry name="url" value="5" summary="input an URL"/>
+      <entry name="email" value="6" summary="input an email address"/>
+      <entry name="name" value="7" summary="input a name of a person"/>
+      <entry name="password" value="8" summary="input a password (combine with sensitive_data hint)"/>
+      <entry name="pin" value="9" summary="input is a numeric password (combine with sensitive_data hint)"/>
+      <entry name="date" value="10" summary="input a date"/>
+      <entry name="time" value="11" summary="input a time"/>
+      <entry name="datetime" value="12" summary="input a date and time"/>
+      <entry name="terminal" value="13" summary="input for a terminal"/>
+    </enum>
+
+    <request name="set_content_type">
+      <description summary="set content purpose and hint">
+        Sets the content purpose and content hint. While the purpose is the
+        basic purpose of an input field, the hint flags allow to modify some of
+        the behavior.
+
+        Values set with this request are double-buffered. They will get applied
+        on the next zwp_text_input_v3.commit request.
+        Subsequent attempts to update them may have no effect. The values
+        remain valid until the next committed enable or disable request.
+
+        The initial value for hint is none, and the initial value for purpose
+        is normal.
+      </description>
+      <arg name="hint" type="uint" enum="content_hint"/>
+      <arg name="purpose" type="uint" enum="content_purpose"/>
+    </request>
+
+    <request name="set_cursor_rectangle">
+      <description summary="set cursor position">
+        Marks an area around the cursor as a x, y, width, height rectangle in
+        surface local coordinates.
+
+        Allows the compositor to put a window with word suggestions near the
+        cursor, without obstructing the text being input.
+
+        If the client is unaware of the position of edited text, it should not
+        issue this request, to signify lack of support to the compositor.
+
+        Values set with this request are double-buffered. They will get applied
+        on the next zwp_text_input_v3.commit request, and stay valid until the
+        next committed enable or disable request.
+
+        The initial values describing a cursor rectangle are empty. That means
+        the text input does not support describing the cursor area. If the
+        empty values get applied, subsequent attempts to change them may have
+        no effect.
+      </description>
+      <arg name="x" type="int"/>
+      <arg name="y" type="int"/>
+      <arg name="width" type="int"/>
+      <arg name="height" type="int"/>
+    </request>
+
+    <request name="commit">
+      <description summary="commit state">
+        Atomically applies state changes recently sent to the compositor.
+
+        The commit request establishes and updates the state of the client, and
+        must be issued after any changes to apply them.
+
+        Text input state (enabled status, content purpose, content hint,
+        surrounding text and change cause, cursor rectangle) is conceptually
+        double-buffered within the context of a text input, i.e. between a
+        committed enable request and the following committed enable or disable
+        request.
+
+        Protocol requests modify the pending state, as opposed to the current
+        state in use by the input method. A commit request atomically applies
+        all pending state, replacing the current state. After commit, the new
+        pending state is as documented for each related request.
+
+        Requests are applied in the order of arrival.
+
+        Neither current nor pending state are modified unless noted otherwise.
+
+        The compositor must count the number of commit requests coming from
+        each zwp_text_input_v3 object and use the count as the serial in done
+        events.
+      </description>
+    </request>
+
+    <event name="enter">
+      <description summary="enter event">
+        Notification that this seat's text-input focus is on a certain surface.
+
+        If client has created multiple text input objects, compositor must send
+        this event to all of them.
+
+        When the seat has the keyboard capability the text-input focus follows
+        the keyboard focus. This event sets the current surface for the
+        text-input object.
+      </description>
+      <arg name="surface" type="object" interface="wl_surface"/>
+    </event>
+
+    <event name="leave">
+      <description summary="leave event">
+        Notification that this seat's text-input focus is no longer on a
+        certain surface. The client should reset any preedit string previously
+        set.
+
+        The leave notification clears the current surface. It is sent before
+        the enter notification for the new focus. After leave event, compositor
+        must ignore requests from any text input instances until next enter
+        event.
+
+        When the seat has the keyboard capability the text-input focus follows
+        the keyboard focus.
+      </description>
+      <arg name="surface" type="object" interface="wl_surface"/>
+    </event>
+
+    <event name="preedit_string">
+      <description summary="pre-edit">
+        Notify when a new composing text (pre-edit) should be set at the
+        current cursor position. Any previously set composing text must be
+        removed. Any previously existing selected text must be removed.
+
+        The argument text contains the pre-edit string buffer.
+
+        The parameters cursor_begin and cursor_end are counted in bytes
+        relative to the beginning of the submitted text buffer. Cursor should
+        be hidden when both are equal to -1.
+
+        They could be represented by the client as a line if both values are
+        the same, or as a text highlight otherwise.
+
+        Values set with this event are double-buffered. They must be applied
+        and reset to initial on the next zwp_text_input_v3.done event.
+
+        The initial value of text is an empty string, and cursor_begin,
+        cursor_end and cursor_hidden are all 0.
+      </description>
+      <arg name="text" type="string" allow-null="true"/>
+      <arg name="cursor_begin" type="int"/>
+      <arg name="cursor_end" type="int"/>
+    </event>
+
+    <event name="commit_string">
+      <description summary="text commit">
+        Notify when text should be inserted into the editor widget. The text to
+        commit could be either just a single character after a key press or the
+        result of some composing (pre-edit).
+
+        Values set with this event are double-buffered. They must be applied
+        and reset to initial on the next zwp_text_input_v3.done event.
+
+        The initial value of text is an empty string.
+      </description>
+      <arg name="text" type="string" allow-null="true"/>
+    </event>
+
+    <event name="delete_surrounding_text">
+      <description summary="delete surrounding text">
+        Notify when the text around the current cursor position should be
+        deleted.
+
+        Before_length and after_length are the number of bytes before and after
+        the current cursor index (excluding the selection) to delete.
+
+        If a preedit text is present, in effect before_length is counted from
+        the beginning of it, and after_length from its end (see done event
+        sequence).
+
+        Values set with this event are double-buffered. They must be applied
+        and reset to initial on the next zwp_text_input_v3.done event.
+
+        The initial values of both before_length and after_length are 0.
+      </description>
+      <arg name="before_length" type="uint" summary="length of text before current cursor position"/>
+      <arg name="after_length" type="uint" summary="length of text after current cursor position"/>
+    </event>
+
+    <event name="done">
+      <description summary="apply changes">
+        Instruct the application to apply changes to state requested by the
+        preedit_string, commit_string and delete_surrounding_text events. The
+        state relating to these events is double-buffered, and each one
+        modifies the pending state. This event replaces the current state with
+        the pending state.
+
+        The application must proceed by evaluating the changes in the following
+        order:
+
+        1. Replace existing preedit string with the cursor.
+        2. Delete requested surrounding text.
+        3. Insert commit string with the cursor at its end.
+        4. Calculate surrounding text to send.
+        5. Insert new preedit text in cursor position.
+        6. Place cursor inside preedit text.
+
+        The serial number reflects the last state of the zwp_text_input_v3
+        object known to the compositor. The value of the serial argument must
+        be equal to the number of commit requests already issued on that object.
+
+        When the client receives a done event with a serial different than the
+        number of past commit requests, it must proceed with evaluating and
+        applying the changes as normal, except it should not change the current
+        state of the zwp_text_input_v3 object. All pending state requests
+        (set_surrounding_text, set_content_type and set_cursor_rectangle) on
+        the zwp_text_input_v3 object should be sent and committed after
+        receiving a zwp_text_input_v3.done event with a matching serial.
+      </description>
+      <arg name="serial" type="uint"/>
+    </event>
+  </interface>
+
+  <interface name="zwp_text_input_manager_v3" version="1">
+    <description summary="text input manager">
+      A factory for text-input objects. This object is a global singleton.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="Destroy the wp_text_input_manager">
+        Destroy the wp_text_input_manager object.
+      </description>
+    </request>
+
+    <request name="get_text_input">
+      <description summary="create a new text input object">
+        Creates a new text-input object for a given seat.
+      </description>
+      <arg name="id" type="new_id" interface="zwp_text_input_v3"/>
+      <arg name="seat" type="object" interface="wl_seat"/>
+    </request>
+  </interface>
+</protocol>
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 9432dc934c9..f4170f6dcc4 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -37,6 +37,7 @@ struct wayland process_wayland =
     .seat.mutex = PTHREAD_MUTEX_INITIALIZER,
     .keyboard.mutex = PTHREAD_MUTEX_INITIALIZER,
     .pointer.mutex = PTHREAD_MUTEX_INITIALIZER,
+    .text_input.mutex = PTHREAD_MUTEX_INITIALIZER,
     .output_list = {&process_wayland.output_list, &process_wayland.output_list},
     .output_mutex = PTHREAD_MUTEX_INITIALIZER
 };
@@ -143,6 +144,7 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         seat->global_id = id;
         wl_seat_add_listener(seat->wl_seat, &seat_listener, NULL);
         pthread_mutex_unlock(&seat->mutex);
+        if (process_wayland.zwp_text_input_manager_v3) wayland_text_input_init();
     }
     else if (strcmp(interface, "wp_viewporter") == 0)
     {
@@ -164,6 +166,12 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         process_wayland.zwp_relative_pointer_manager_v1 =
             wl_registry_bind(registry, id, &zwp_relative_pointer_manager_v1_interface, 1);
     }
+    else if (strcmp(interface, "zwp_text_input_manager_v3") == 0)
+    {
+        process_wayland.zwp_text_input_manager_v3 =
+            wl_registry_bind(registry, id, &zwp_text_input_manager_v3_interface, 1);
+        if (process_wayland.seat.wl_seat) wayland_text_input_init();
+    }
 }
 
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
@@ -189,6 +197,7 @@ static void registry_handle_global_remove(void *data, struct wl_registry *regist
     {
         TRACE("removing seat\n");
         if (process_wayland.pointer.wl_pointer) wayland_pointer_deinit();
+        if (process_wayland.text_input.zwp_text_input_v3) wayland_text_input_deinit();
         pthread_mutex_lock(&seat->mutex);
         wl_seat_release(seat->wl_seat);
         seat->wl_seat = NULL;
@@ -282,6 +291,9 @@ BOOL wayland_process_init(void)
     if (!process_wayland.zwp_relative_pointer_manager_v1)
         ERR("Wayland compositor doesn't support optional zwp_relative_pointer_manager_v1 (relative motion won't work)\n");
 
+    if (!process_wayland.zwp_text_input_manager_v3)
+        ERR("Wayland compositor doesn't support optional zwp_text_input_manager_v3 (host input methods won't work)\n");
+
     process_wayland.initialized = TRUE;
 
     return TRUE;
diff --git a/dlls/winewayland.drv/wayland_text_input.c b/dlls/winewayland.drv/wayland_text_input.c
new file mode 100644
index 00000000000..56c17cc3cc6
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_text_input.c
@@ -0,0 +1,109 @@
+/*
+ * Wayland text input handling
+ *
+ * Copyright 2025 Attila Fidan
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(imm);
+
+static void text_input_enter(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
+        struct wl_surface *surface)
+{
+    struct wayland_text_input *text_input = data;
+    TRACE("data %p, text_input %p, surface %p.\n", data, zwp_text_input_v3, surface);
+
+    pthread_mutex_lock(&text_input->mutex);
+    zwp_text_input_v3_enable(text_input->zwp_text_input_v3);
+    zwp_text_input_v3_set_content_type(text_input->zwp_text_input_v3,
+            ZWP_TEXT_INPUT_V3_CONTENT_HINT_NONE,
+            ZWP_TEXT_INPUT_V3_CONTENT_PURPOSE_NORMAL);
+    zwp_text_input_v3_set_cursor_rectangle(text_input->zwp_text_input_v3, 0, 0, 0, 0);
+    zwp_text_input_v3_commit(text_input->zwp_text_input_v3);
+    pthread_mutex_unlock(&text_input->mutex);
+}
+
+static void text_input_leave(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
+        struct wl_surface *surface)
+{
+    struct wayland_text_input *text_input = data;
+    TRACE("data %p, text_input %p, surface %p.\n", data, zwp_text_input_v3, surface);
+
+    pthread_mutex_lock(&text_input->mutex);
+    zwp_text_input_v3_disable(text_input->zwp_text_input_v3);
+    zwp_text_input_v3_commit(text_input->zwp_text_input_v3);
+    pthread_mutex_unlock(&text_input->mutex);
+}
+
+static void text_input_preedit_string(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
+        const char *text, int32_t cursor_begin, int32_t cursor_end)
+{
+}
+
+static void text_input_commit_string(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
+        const char *text)
+{
+}
+
+static void text_input_delete_surrounding_text(void *data,
+        struct zwp_text_input_v3 *zwp_text_input_v3, uint32_t before_length, uint32_t after_length)
+{
+}
+
+static void text_input_done(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
+        uint32_t serial)
+{
+}
+
+static const struct zwp_text_input_v3_listener text_input_listener =
+{
+    text_input_enter,
+    text_input_leave,
+    text_input_preedit_string,
+    text_input_commit_string,
+    text_input_delete_surrounding_text,
+    text_input_done,
+};
+
+void wayland_text_input_init(void)
+{
+    struct wayland_text_input *text_input = &process_wayland.text_input;
+
+    pthread_mutex_lock(&text_input->mutex);
+    text_input->zwp_text_input_v3 = zwp_text_input_manager_v3_get_text_input(
+            process_wayland.zwp_text_input_manager_v3, process_wayland.seat.wl_seat);
+    zwp_text_input_v3_add_listener(text_input->zwp_text_input_v3, &text_input_listener, text_input);
+    pthread_mutex_unlock(&text_input->mutex);
+};
+
+void wayland_text_input_deinit(void)
+{
+    struct wayland_text_input *text_input = &process_wayland.text_input;
+
+    pthread_mutex_lock(&text_input->mutex);
+    zwp_text_input_v3_destroy(text_input->zwp_text_input_v3);
+    text_input->zwp_text_input_v3 = NULL;
+    pthread_mutex_unlock(&text_input->mutex);
+};
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 72a37cb3ffb..c5dec335485 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -31,6 +31,7 @@
 #include <xkbcommon/xkbregistry.h>
 #include "pointer-constraints-unstable-v1-client-protocol.h"
 #include "relative-pointer-unstable-v1-client-protocol.h"
+#include "text-input-unstable-v3-client-protocol.h"
 #include "viewporter-client-protocol.h"
 #include "xdg-output-unstable-v1-client-protocol.h"
 #include "xdg-shell-client-protocol.h"
@@ -111,6 +112,12 @@ struct wayland_pointer
     pthread_mutex_t mutex;
 };
 
+struct wayland_text_input
+{
+    struct zwp_text_input_v3 *zwp_text_input_v3;
+    pthread_mutex_t mutex;
+};
+
 struct wayland_seat
 {
     struct wl_seat *wl_seat;
@@ -132,9 +139,11 @@ struct wayland
     struct wl_subcompositor *wl_subcompositor;
     struct zwp_pointer_constraints_v1 *zwp_pointer_constraints_v1;
     struct zwp_relative_pointer_manager_v1 *zwp_relative_pointer_manager_v1;
+    struct zwp_text_input_manager_v3 *zwp_text_input_manager_v3;
     struct wayland_seat seat;
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
+    struct wayland_text_input text_input;
     struct wl_list output_list;
     /* Protects the output_list and the wayland_output.current states. */
     pthread_mutex_t output_mutex;
@@ -340,6 +349,13 @@ void wayland_pointer_init(struct wl_pointer *wl_pointer);
 void wayland_pointer_deinit(void);
 void wayland_pointer_clear_constraint(void);
 
+/**********************************************************************
+ *          Wayland text input
+ */
+
+void wayland_text_input_init(void);
+void wayland_text_input_deinit(void);
+
 /**********************************************************************
  *          OpenGL
  */
-- 
2.49.0

From 337782c387d9078ce4b286c7df825232d876b3a9 Mon Sep 17 00:00:00 2001
From: Attila Fidan <dev@print0.net>
Date: Sun, 2 Feb 2025 08:07:41 +0000
Subject: [PATCH 003/159] winewayland: Post IME update for committed text.

---
 dlls/winewayland.drv/wayland_text_input.c | 50 +++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h         |  2 +
 2 files changed, 52 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_text_input.c b/dlls/winewayland.drv/wayland_text_input.c
index 56c17cc3cc6..91355c23a9c 100644
--- a/dlls/winewayland.drv/wayland_text_input.c
+++ b/dlls/winewayland.drv/wayland_text_input.c
@@ -24,11 +24,39 @@
 
 #include "config.h"
 
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+
 #include "waylanddrv.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(imm);
 
+static void post_ime_update(HWND hwnd, UINT cursor_pos, WCHAR *comp_str, WCHAR *result_str)
+{
+    NtUserMessageCall(hwnd, WINE_IME_POST_UPDATE, cursor_pos, (LPARAM)comp_str, result_str,
+            NtUserImeDriverCall, FALSE);
+}
+
+static WCHAR *strdupUtoW(const char *str)
+{
+    WCHAR *ret = NULL;
+    size_t len;
+    DWORD reslen;
+
+    if (!str) return ret;
+    len = strlen(str);
+    ret = malloc((len + 1) * sizeof(WCHAR));
+    if (ret)
+    {
+        RtlUTF8ToUnicodeN(ret, len * sizeof(WCHAR), &reslen, str, len);
+        reslen /= sizeof(WCHAR);
+        ret[reslen] = 0;
+    }
+    return ret;
+}
+
 static void text_input_enter(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
         struct wl_surface *surface)
 {
@@ -42,6 +70,7 @@ static void text_input_enter(void *data, struct zwp_text_input_v3 *zwp_text_inpu
             ZWP_TEXT_INPUT_V3_CONTENT_PURPOSE_NORMAL);
     zwp_text_input_v3_set_cursor_rectangle(text_input->zwp_text_input_v3, 0, 0, 0, 0);
     zwp_text_input_v3_commit(text_input->zwp_text_input_v3);
+    text_input->wl_surface = surface;
     pthread_mutex_unlock(&text_input->mutex);
 }
 
@@ -54,6 +83,7 @@ static void text_input_leave(void *data, struct zwp_text_input_v3 *zwp_text_inpu
     pthread_mutex_lock(&text_input->mutex);
     zwp_text_input_v3_disable(text_input->zwp_text_input_v3);
     zwp_text_input_v3_commit(text_input->zwp_text_input_v3);
+    text_input->wl_surface = NULL;
     pthread_mutex_unlock(&text_input->mutex);
 }
 
@@ -65,6 +95,12 @@ static void text_input_preedit_string(void *data, struct zwp_text_input_v3 *zwp_
 static void text_input_commit_string(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
         const char *text)
 {
+    struct wayland_text_input *text_input = data;
+    TRACE("data %p, text_input %p, text %s.\n", data, zwp_text_input_v3, debugstr_a(text));
+
+    pthread_mutex_lock(&text_input->mutex);
+    text_input->commit_string = strdupUtoW(text);
+    pthread_mutex_unlock(&text_input->mutex);
 }
 
 static void text_input_delete_surrounding_text(void *data,
@@ -75,6 +111,19 @@ static void text_input_delete_surrounding_text(void *data,
 static void text_input_done(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
         uint32_t serial)
 {
+    struct wayland_text_input *text_input = data;
+    HWND hwnd;
+    TRACE("data %p, text_input %p, serial %u.\n", data, zwp_text_input_v3, serial);
+
+    pthread_mutex_lock(&text_input->mutex);
+    assert(text_input->wl_surface);
+    hwnd = wl_surface_get_user_data(text_input->wl_surface);
+
+    post_ime_update(hwnd, 0, NULL, text_input->commit_string);
+
+    free(text_input->commit_string);
+    text_input->commit_string = NULL;
+    pthread_mutex_unlock(&text_input->mutex);
 }
 
 static const struct zwp_text_input_v3_listener text_input_listener =
@@ -105,5 +154,6 @@ void wayland_text_input_deinit(void)
     pthread_mutex_lock(&text_input->mutex);
     zwp_text_input_v3_destroy(text_input->zwp_text_input_v3);
     text_input->zwp_text_input_v3 = NULL;
+    text_input->wl_surface = NULL;
     pthread_mutex_unlock(&text_input->mutex);
 };
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index c5dec335485..60c345e6601 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -115,6 +115,8 @@ struct wayland_pointer
 struct wayland_text_input
 {
     struct zwp_text_input_v3 *zwp_text_input_v3;
+    WCHAR *commit_string;
+    struct wl_surface *wl_surface;
     pthread_mutex_t mutex;
 };
 
-- 
2.49.0

From 417ddcefa9b8fe1dfd8da4488ba024c779c7260b Mon Sep 17 00:00:00 2001
From: Attila Fidan <dev@print0.net>
Date: Sun, 2 Feb 2025 08:26:56 +0000
Subject: [PATCH 004/159] winewayland: Implement SetIMECompositionRect.

---
 dlls/winewayland.drv/wayland_text_input.c | 47 +++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h         |  1 +
 dlls/winewayland.drv/waylanddrv_main.c    |  1 +
 3 files changed, 49 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_text_input.c b/dlls/winewayland.drv/wayland_text_input.c
index 91355c23a9c..769862ecdea 100644
--- a/dlls/winewayland.drv/wayland_text_input.c
+++ b/dlls/winewayland.drv/wayland_text_input.c
@@ -157,3 +157,50 @@ void wayland_text_input_deinit(void)
     text_input->wl_surface = NULL;
     pthread_mutex_unlock(&text_input->mutex);
 };
+
+/***********************************************************************
+ *      SetIMECompositionRect (WAYLANDDRV.@)
+ */
+BOOL WAYLAND_SetIMECompositionRect(HWND hwnd, RECT rect)
+{
+    struct wayland_text_input *text_input = &process_wayland.text_input;
+    struct wayland_win_data *data;
+    struct wayland_surface *surface;
+    int cursor_x, cursor_y, cursor_width, cursor_height;
+    TRACE("hwnd %p, rect %s.\n", hwnd, wine_dbgstr_rect(&rect));
+
+    pthread_mutex_lock(&text_input->mutex);
+
+    if (!text_input->zwp_text_input_v3)
+        goto err;
+
+    if (!(data = wayland_win_data_get(hwnd)))
+        goto err;
+
+    if (!(surface = data->wayland_surface) || surface->wl_surface != text_input->wl_surface)
+    {
+        wayland_win_data_release(data);
+        goto err;
+    }
+
+    wayland_surface_coords_from_window(surface,
+            rect.left - surface->window.rect.left,
+            rect.top - surface->window.rect.top,
+            &cursor_x, &cursor_y);
+    wayland_surface_coords_from_window(surface,
+            rect.right - rect.left,
+            rect.bottom - rect.top,
+            &cursor_width, &cursor_height);
+    wayland_win_data_release(data);
+
+    zwp_text_input_v3_set_cursor_rectangle(text_input->zwp_text_input_v3,
+            cursor_x, cursor_y, cursor_width, cursor_height);
+    zwp_text_input_v3_commit(text_input->zwp_text_input_v3);
+
+    pthread_mutex_unlock(&text_input->mutex);
+    return TRUE;
+
+err:
+    pthread_mutex_unlock(&text_input->mutex);
+    return FALSE;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 60c345e6601..afc480e6652 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -392,6 +392,7 @@ RGNDATA *get_region_data(HRGN region);
 BOOL WAYLAND_ClipCursor(const RECT *clip, BOOL reset);
 LRESULT WAYLAND_DesktopWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
 void WAYLAND_DestroyWindow(HWND hwnd);
+BOOL WAYLAND_SetIMECompositionRect(HWND hwnd, RECT rect);
 void WAYLAND_SetCursor(HWND hwnd, HCURSOR hcursor);
 void WAYLAND_SetWindowText(HWND hwnd, LPCWSTR text);
 LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam, const POINT *pos);
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 47c1299dd01..633b2f4a043 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -38,6 +38,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pClipCursor = WAYLAND_ClipCursor,
     .pDesktopWindowProc = WAYLAND_DesktopWindowProc,
     .pDestroyWindow = WAYLAND_DestroyWindow,
+    .pSetIMECompositionRect = WAYLAND_SetIMECompositionRect,
     .pKbdLayerDescriptor = WAYLAND_KbdLayerDescriptor,
     .pReleaseKbdTables = WAYLAND_ReleaseKbdTables,
     .pSetCursor = WAYLAND_SetCursor,
-- 
2.49.0

From 036a6ee4c601f19aaf182be3e53402b8f1b834ec Mon Sep 17 00:00:00 2001
From: Attila Fidan <dev@print0.net>
Date: Sat, 8 Feb 2025 05:59:04 +0000
Subject: [PATCH 005/159] winewayland: Post IME update for preedit text.

---
 dlls/winewayland.drv/wayland_text_input.c | 21 ++++++++++++++++++++-
 dlls/winewayland.drv/waylanddrv.h         |  2 ++
 2 files changed, 22 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/wayland_text_input.c b/dlls/winewayland.drv/wayland_text_input.c
index 769862ecdea..17257634b2e 100644
--- a/dlls/winewayland.drv/wayland_text_input.c
+++ b/dlls/winewayland.drv/wayland_text_input.c
@@ -78,11 +78,15 @@ static void text_input_leave(void *data, struct zwp_text_input_v3 *zwp_text_inpu
         struct wl_surface *surface)
 {
     struct wayland_text_input *text_input = data;
+    HWND hwnd;
     TRACE("data %p, text_input %p, surface %p.\n", data, zwp_text_input_v3, surface);
 
     pthread_mutex_lock(&text_input->mutex);
     zwp_text_input_v3_disable(text_input->zwp_text_input_v3);
     zwp_text_input_v3_commit(text_input->zwp_text_input_v3);
+    assert(text_input->wl_surface);
+    hwnd = wl_surface_get_user_data(text_input->wl_surface);
+    post_ime_update(hwnd, 0, NULL, NULL);
     text_input->wl_surface = NULL;
     pthread_mutex_unlock(&text_input->mutex);
 }
@@ -90,6 +94,17 @@ static void text_input_leave(void *data, struct zwp_text_input_v3 *zwp_text_inpu
 static void text_input_preedit_string(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
         const char *text, int32_t cursor_begin, int32_t cursor_end)
 {
+    struct wayland_text_input *text_input = data;
+    TRACE("data %p, text_input %p, text %s, cursor_begin %d.\n", data, zwp_text_input_v3,
+            debugstr_a(text), cursor_begin);
+
+    pthread_mutex_lock(&text_input->mutex);
+    if ((text_input->preedit_string = strdupUtoW(text)) && cursor_begin > 0)
+    {
+        RtlUTF8ToUnicodeN(NULL, 0, &text_input->preedit_cursor_pos, text, cursor_begin);
+        text_input->preedit_cursor_pos /= sizeof(WCHAR);
+    }
+    pthread_mutex_unlock(&text_input->mutex);
 }
 
 static void text_input_commit_string(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
@@ -119,8 +134,12 @@ static void text_input_done(void *data, struct zwp_text_input_v3 *zwp_text_input
     assert(text_input->wl_surface);
     hwnd = wl_surface_get_user_data(text_input->wl_surface);
 
-    post_ime_update(hwnd, 0, NULL, text_input->commit_string);
+    post_ime_update(hwnd, text_input->preedit_cursor_pos, text_input->preedit_string,
+            text_input->commit_string);
 
+    free(text_input->preedit_string);
+    text_input->preedit_string = NULL;
+    text_input->preedit_cursor_pos = 0;
     free(text_input->commit_string);
     text_input->commit_string = NULL;
     pthread_mutex_unlock(&text_input->mutex);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index afc480e6652..5c5ce5bf130 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -115,6 +115,8 @@ struct wayland_pointer
 struct wayland_text_input
 {
     struct zwp_text_input_v3 *zwp_text_input_v3;
+    WCHAR *preedit_string;
+    DWORD preedit_cursor_pos;
     WCHAR *commit_string;
     struct wl_surface *wl_surface;
     pthread_mutex_t mutex;
-- 
2.49.0

From b2aa226cfd294e6017ebee23112a318696e3948a Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 6 Feb 2025 12:43:39 +0200
Subject: [PATCH 006/159] winewayland: Round the Wayland refresh rate to
 calculate the win32 display frequency.

Round the Wayland refresh rate instead of floor-ing it, to report a more
accurate win32 display frequency. This can slightly improve FPS values
in games that use the reported display frequency to drive their rendering.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=56542
---
 dlls/winewayland.drv/display.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index 5d65fd01c54..851c9638252 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -232,7 +232,8 @@ static void populate_devmode(struct wayland_output_mode *output_mode, DEVMODEW *
     mode->dmBitsPerPel = 32;
     mode->dmPelsWidth = output_mode->width;
     mode->dmPelsHeight = output_mode->height;
-    mode->dmDisplayFrequency = output_mode->refresh / 1000;
+    /* Round the refresh rate to calculate the win32 display frequency. */
+    mode->dmDisplayFrequency = (output_mode->refresh + 500) / 1000;
 }
 
 static void wayland_add_device_modes(const struct gdi_device_manager *device_manager,
-- 
2.49.0

From b9f0882d5a58d746e65599d83c4a391076a55082 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 7 Feb 2025 13:23:46 +0200
Subject: [PATCH 007/159] winewayland: Implement zwlr_data_control_device_v1
 initialization.

---
 dlls/winewayland.drv/Makefile.in              |   2 +
 dlls/winewayland.drv/wayland.c                |   8 +
 dlls/winewayland.drv/wayland_data_device.c    |  59 ++++
 dlls/winewayland.drv/waylanddrv.h             |  15 +
 dlls/winewayland.drv/waylanddrv_main.c        |   1 +
 .../wlr-data-control-unstable-v1.xml          | 278 ++++++++++++++++++
 6 files changed, 363 insertions(+)
 create mode 100644 dlls/winewayland.drv/wayland_data_device.c
 create mode 100644 dlls/winewayland.drv/wlr-data-control-unstable-v1.xml

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 9129a3f2839..142db22ba9e 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -14,6 +14,7 @@ SOURCES = \
 	viewporter.xml \
 	vulkan.c \
 	wayland.c \
+	wayland_data_device.c \
 	wayland_keyboard.c \
 	wayland_output.c \
 	wayland_pointer.c \
@@ -22,5 +23,6 @@ SOURCES = \
 	waylanddrv_main.c \
 	window.c \
 	window_surface.c \
+	wlr-data-control-unstable-v1.xml \
 	xdg-output-unstable-v1.xml \
 	xdg-shell.xml
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index f4170f6dcc4..2fb0edf8023 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -145,6 +145,9 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         wl_seat_add_listener(seat->wl_seat, &seat_listener, NULL);
         pthread_mutex_unlock(&seat->mutex);
         if (process_wayland.zwp_text_input_manager_v3) wayland_text_input_init();
+        /* Recreate the data device for the new seat. */
+        if (process_wayland.data_device.zwlr_data_control_device_v1)
+            wayland_data_device_init();
     }
     else if (strcmp(interface, "wp_viewporter") == 0)
     {
@@ -172,6 +175,11 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
             wl_registry_bind(registry, id, &zwp_text_input_manager_v3_interface, 1);
         if (process_wayland.seat.wl_seat) wayland_text_input_init();
     }
+    else if (strcmp(interface, "zwlr_data_control_manager_v1") == 0)
+    {
+        process_wayland.zwlr_data_control_manager_v1 =
+            wl_registry_bind(registry, id, &zwlr_data_control_manager_v1_interface, 1);
+    }
 }
 
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
new file mode 100644
index 00000000000..6e53ed4046b
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -0,0 +1,59 @@
+/*
+ * Wayland clipboard
+ *
+ * Copyright 2025 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
+
+void wayland_data_device_init(void)
+{
+    struct wayland_data_device *data_device = &process_wayland.data_device;
+
+    TRACE("\n");
+
+    if (data_device->zwlr_data_control_device_v1)
+        zwlr_data_control_device_v1_destroy(data_device->zwlr_data_control_device_v1);
+    data_device->zwlr_data_control_device_v1 =
+        zwlr_data_control_manager_v1_get_data_device(
+            process_wayland.zwlr_data_control_manager_v1,
+            process_wayland.seat.wl_seat);
+}
+
+LRESULT WAYLAND_ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
+{
+    switch (msg)
+    {
+    case WM_NCCREATE:
+        pthread_mutex_lock(&process_wayland.seat.mutex);
+        if (process_wayland.seat.wl_seat && process_wayland.zwlr_data_control_manager_v1)
+            wayland_data_device_init();
+        pthread_mutex_unlock(&process_wayland.seat.mutex);
+        return TRUE;
+    }
+
+    return NtUserMessageCall(hwnd, msg, wparam, lparam, NULL, NtUserDefWindowProc, FALSE);
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 5c5ce5bf130..12ac686fbd9 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -35,6 +35,7 @@
 #include "viewporter-client-protocol.h"
 #include "xdg-output-unstable-v1-client-protocol.h"
 #include "xdg-shell-client-protocol.h"
+#include "wlr-data-control-unstable-v1-client-protocol.h"
 
 #include "windef.h"
 #include "winbase.h"
@@ -129,6 +130,11 @@ struct wayland_seat
     pthread_mutex_t mutex;
 };
 
+struct wayland_data_device
+{
+    struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1;
+};
+
 struct wayland
 {
     BOOL initialized;
@@ -144,10 +150,12 @@ struct wayland
     struct zwp_pointer_constraints_v1 *zwp_pointer_constraints_v1;
     struct zwp_relative_pointer_manager_v1 *zwp_relative_pointer_manager_v1;
     struct zwp_text_input_manager_v3 *zwp_text_input_manager_v3;
+    struct zwlr_data_control_manager_v1 *zwlr_data_control_manager_v1;
     struct wayland_seat seat;
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
     struct wayland_text_input text_input;
+    struct wayland_data_device data_device;
     struct wl_list output_list;
     /* Protects the output_list and the wayland_output.current states. */
     pthread_mutex_t output_mutex;
@@ -360,6 +368,12 @@ void wayland_pointer_clear_constraint(void);
 void wayland_text_input_init(void);
 void wayland_text_input_deinit(void);
 
+/**********************************************************************
+ *          Wayland data device
+ */
+
+void wayland_data_device_init(void);
+
 /**********************************************************************
  *          OpenGL
  */
@@ -391,6 +405,7 @@ RGNDATA *get_region_data(HRGN region);
  *          USER driver functions
  */
 
+LRESULT WAYLAND_ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam);
 BOOL WAYLAND_ClipCursor(const RECT *clip, BOOL reset);
 LRESULT WAYLAND_DesktopWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
 void WAYLAND_DestroyWindow(HWND hwnd);
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 633b2f4a043..ca7ec47b674 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -35,6 +35,7 @@ char *process_name = NULL;
 
 static const struct user_driver_funcs waylanddrv_funcs =
 {
+    .pClipboardWindowProc = WAYLAND_ClipboardWindowProc,
     .pClipCursor = WAYLAND_ClipCursor,
     .pDesktopWindowProc = WAYLAND_DesktopWindowProc,
     .pDestroyWindow = WAYLAND_DestroyWindow,
diff --git a/dlls/winewayland.drv/wlr-data-control-unstable-v1.xml b/dlls/winewayland.drv/wlr-data-control-unstable-v1.xml
new file mode 100644
index 00000000000..75e8671b0de
--- /dev/null
+++ b/dlls/winewayland.drv/wlr-data-control-unstable-v1.xml
@@ -0,0 +1,278 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="wlr_data_control_unstable_v1">
+  <copyright>
+    Copyright © 2018 Simon Ser
+    Copyright © 2019 Ivan Molodetskikh
+
+    Permission to use, copy, modify, distribute, and sell this
+    software and its documentation for any purpose is hereby granted
+    without fee, provided that the above copyright notice appear in
+    all copies and that both that copyright notice and this permission
+    notice appear in supporting documentation, and that the name of
+    the copyright holders not be used in advertising or publicity
+    pertaining to distribution of the software without specific,
+    written prior permission.  The copyright holders make no
+    representations about the suitability of this software for any
+    purpose.  It is provided "as is" without express or implied
+    warranty.
+
+    THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+    SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+    FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+    SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+    AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+    ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
+    THIS SOFTWARE.
+  </copyright>
+
+  <description summary="control data devices">
+    This protocol allows a privileged client to control data devices. In
+    particular, the client will be able to manage the current selection and take
+    the role of a clipboard manager.
+
+    Warning! The protocol described in this file is experimental and
+    backward incompatible changes may be made. Backward compatible changes
+    may be added together with the corresponding interface version bump.
+    Backward incompatible changes are done by bumping the version number in
+    the protocol and interface names and resetting the interface version.
+    Once the protocol is to be declared stable, the 'z' prefix and the
+    version number in the protocol and interface names are removed and the
+    interface version number is reset.
+  </description>
+
+  <interface name="zwlr_data_control_manager_v1" version="2">
+    <description summary="manager to control data devices">
+      This interface is a manager that allows creating per-seat data device
+      controls.
+    </description>
+
+    <request name="create_data_source">
+      <description summary="create a new data source">
+        Create a new data source.
+      </description>
+      <arg name="id" type="new_id" interface="zwlr_data_control_source_v1"
+        summary="data source to create"/>
+    </request>
+
+    <request name="get_data_device">
+      <description summary="get a data device for a seat">
+        Create a data device that can be used to manage a seat's selection.
+      </description>
+      <arg name="id" type="new_id" interface="zwlr_data_control_device_v1"/>
+      <arg name="seat" type="object" interface="wl_seat"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the manager">
+        All objects created by the manager will still remain valid, until their
+        appropriate destroy request has been called.
+      </description>
+    </request>
+  </interface>
+
+  <interface name="zwlr_data_control_device_v1" version="2">
+    <description summary="manage a data device for a seat">
+      This interface allows a client to manage a seat's selection.
+
+      When the seat is destroyed, this object becomes inert.
+    </description>
+
+    <request name="set_selection">
+      <description summary="copy data to the selection">
+        This request asks the compositor to set the selection to the data from
+        the source on behalf of the client.
+
+        The given source may not be used in any further set_selection or
+        set_primary_selection requests. Attempting to use a previously used
+        source is a protocol error.
+
+        To unset the selection, set the source to NULL.
+      </description>
+      <arg name="source" type="object" interface="zwlr_data_control_source_v1"
+        allow-null="true"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy this data device">
+        Destroys the data device object.
+      </description>
+    </request>
+
+    <event name="data_offer">
+      <description summary="introduce a new wlr_data_control_offer">
+        The data_offer event introduces a new wlr_data_control_offer object,
+        which will subsequently be used in either the
+        wlr_data_control_device.selection event (for the regular clipboard
+        selections) or the wlr_data_control_device.primary_selection event (for
+        the primary clipboard selections). Immediately following the
+        wlr_data_control_device.data_offer event, the new data_offer object
+        will send out wlr_data_control_offer.offer events to describe the MIME
+        types it offers.
+      </description>
+      <arg name="id" type="new_id" interface="zwlr_data_control_offer_v1"/>
+    </event>
+
+    <event name="selection">
+      <description summary="advertise new selection">
+        The selection event is sent out to notify the client of a new
+        wlr_data_control_offer for the selection for this device. The
+        wlr_data_control_device.data_offer and the wlr_data_control_offer.offer
+        events are sent out immediately before this event to introduce the data
+        offer object. The selection event is sent to a client when a new
+        selection is set. The wlr_data_control_offer is valid until a new
+        wlr_data_control_offer or NULL is received. The client must destroy the
+        previous selection wlr_data_control_offer, if any, upon receiving this
+        event.
+
+        The first selection event is sent upon binding the
+        wlr_data_control_device object.
+      </description>
+      <arg name="id" type="object" interface="zwlr_data_control_offer_v1"
+        allow-null="true"/>
+    </event>
+
+    <event name="finished">
+      <description summary="this data control is no longer valid">
+        This data control object is no longer valid and should be destroyed by
+        the client.
+      </description>
+    </event>
+
+    <!-- Version 2 additions -->
+
+    <event name="primary_selection" since="2">
+      <description summary="advertise new primary selection">
+        The primary_selection event is sent out to notify the client of a new
+        wlr_data_control_offer for the primary selection for this device. The
+        wlr_data_control_device.data_offer and the wlr_data_control_offer.offer
+        events are sent out immediately before this event to introduce the data
+        offer object. The primary_selection event is sent to a client when a
+        new primary selection is set. The wlr_data_control_offer is valid until
+        a new wlr_data_control_offer or NULL is received. The client must
+        destroy the previous primary selection wlr_data_control_offer, if any,
+        upon receiving this event.
+
+        If the compositor supports primary selection, the first
+        primary_selection event is sent upon binding the
+        wlr_data_control_device object.
+      </description>
+      <arg name="id" type="object" interface="zwlr_data_control_offer_v1"
+        allow-null="true"/>
+    </event>
+
+    <request name="set_primary_selection" since="2">
+      <description summary="copy data to the primary selection">
+        This request asks the compositor to set the primary selection to the
+        data from the source on behalf of the client.
+
+        The given source may not be used in any further set_selection or
+        set_primary_selection requests. Attempting to use a previously used
+        source is a protocol error.
+
+        To unset the primary selection, set the source to NULL.
+
+        The compositor will ignore this request if it does not support primary
+        selection.
+      </description>
+      <arg name="source" type="object" interface="zwlr_data_control_source_v1"
+        allow-null="true"/>
+    </request>
+
+    <enum name="error" since="2">
+      <entry name="used_source" value="1"
+        summary="source given to set_selection or set_primary_selection was already used before"/>
+    </enum>
+  </interface>
+
+  <interface name="zwlr_data_control_source_v1" version="1">
+    <description summary="offer to transfer data">
+      The wlr_data_control_source object is the source side of a
+      wlr_data_control_offer. It is created by the source client in a data
+      transfer and provides a way to describe the offered data and a way to
+      respond to requests to transfer the data.
+    </description>
+
+    <enum name="error">
+      <entry name="invalid_offer" value="1"
+        summary="offer sent after wlr_data_control_device.set_selection"/>
+    </enum>
+
+    <request name="offer">
+      <description summary="add an offered MIME type">
+        This request adds a MIME type to the set of MIME types advertised to
+        targets. Can be called several times to offer multiple types.
+
+        Calling this after wlr_data_control_device.set_selection is a protocol
+        error.
+      </description>
+      <arg name="mime_type" type="string"
+        summary="MIME type offered by the data source"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy this source">
+        Destroys the data source object.
+      </description>
+    </request>
+
+    <event name="send">
+      <description summary="send the data">
+        Request for data from the client. Send the data as the specified MIME
+        type over the passed file descriptor, then close it.
+      </description>
+      <arg name="mime_type" type="string" summary="MIME type for the data"/>
+      <arg name="fd" type="fd" summary="file descriptor for the data"/>
+    </event>
+
+    <event name="cancelled">
+      <description summary="selection was cancelled">
+        This data source is no longer valid. The data source has been replaced
+        by another data source.
+
+        The client should clean up and destroy this data source.
+      </description>
+    </event>
+  </interface>
+
+  <interface name="zwlr_data_control_offer_v1" version="1">
+    <description summary="offer to transfer data">
+      A wlr_data_control_offer represents a piece of data offered for transfer
+      by another client (the source client). The offer describes the different
+      MIME types that the data can be converted to and provides the mechanism
+      for transferring the data directly from the source client.
+    </description>
+
+    <request name="receive">
+      <description summary="request that the data is transferred">
+        To transfer the offered data, the client issues this request and
+        indicates the MIME type it wants to receive. The transfer happens
+        through the passed file descriptor (typically created with the pipe
+        system call). The source client writes the data in the MIME type
+        representation requested and then closes the file descriptor.
+
+        The receiving client reads from the read end of the pipe until EOF and
+        then closes its end, at which point the transfer is complete.
+
+        This request may happen multiple times for different MIME types.
+      </description>
+      <arg name="mime_type" type="string"
+        summary="MIME type desired by receiver"/>
+      <arg name="fd" type="fd" summary="file descriptor for data transfer"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy this offer">
+        Destroys the data offer object.
+      </description>
+    </request>
+
+    <event name="offer">
+      <description summary="advertise offered MIME type">
+        Sent immediately after creating the wlr_data_control_offer object.
+        One event per offered MIME type.
+      </description>
+      <arg name="mime_type" type="string" summary="offered MIME type"/>
+    </event>
+  </interface>
+</protocol>
-- 
2.49.0

From 576b68e85244987306a9ffa022a86e638a832463 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 7 Feb 2025 14:33:53 +0200
Subject: [PATCH 008/159] winewayland: Support copying text from win32
 clipboard to native apps.

---
 dlls/winewayland.drv/wayland.c             |   1 +
 dlls/winewayland.drv/wayland_data_device.c | 173 +++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h          |   2 +
 3 files changed, 176 insertions(+)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 2fb0edf8023..ee162d8fe77 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -38,6 +38,7 @@ struct wayland process_wayland =
     .keyboard.mutex = PTHREAD_MUTEX_INITIALIZER,
     .pointer.mutex = PTHREAD_MUTEX_INITIALIZER,
     .text_input.mutex = PTHREAD_MUTEX_INITIALIZER,
+    .data_device.mutex = PTHREAD_MUTEX_INITIALIZER,
     .output_list = {&process_wayland.output_list, &process_wayland.output_list},
     .output_mutex = PTHREAD_MUTEX_INITIALIZER
 };
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 6e53ed4046b..b51f5b25ed4 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -24,23 +24,191 @@
 
 #include "config.h"
 
+#include <errno.h>
+#include <stdlib.h>
+#include <unistd.h>
+
 #include "waylanddrv.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
 
+static HWND clipboard_hwnd;
+
+static void write_all(int fd, const void *buf, size_t count)
+{
+    size_t nwritten = 0;
+    ssize_t ret;
+
+    while (nwritten < count)
+    {
+        ret = write(fd, (const char*)buf + nwritten, count - nwritten);
+        if (ret == -1 && errno != EINTR) break;
+        else if (ret > 0) nwritten += ret;
+    }
+
+    if (nwritten < count)
+    {
+        WARN("Failed to write all clipboard data, had %zu bytes, wrote %zu bytes\n",
+             count, nwritten);
+    }
+}
+
+static void *export_unicode_text(void *data, size_t size, size_t *ret_size)
+{
+    DWORD byte_count;
+    char *bytes;
+
+    /* Wayland apps expect strings to not be zero-terminated, so avoid
+     * zero-terminating the resulting converted string. */
+    if (size >= sizeof(WCHAR) && ((WCHAR *)data)[size / sizeof(WCHAR) - 1] == 0)
+        size -= sizeof(WCHAR);
+
+    RtlUnicodeToUTF8N(NULL, 0, &byte_count, data, size);
+    if (!(bytes = malloc(byte_count))) return NULL;
+    RtlUnicodeToUTF8N(bytes, byte_count, &byte_count, data, size);
+
+    *ret_size = byte_count;
+    return bytes;
+}
+
+/**********************************************************************
+ *          zwlr_data_control_source_v1 handling
+ */
+
+static void wayland_data_source_export(int32_t fd)
+{
+    struct get_clipboard_params params = { .data_only = TRUE, .size = 1024 };
+    void *exported = NULL;
+    size_t exported_size;
+
+    TRACE("\n");
+
+    if (!NtUserOpenClipboard(clipboard_hwnd, 0))
+    {
+        TRACE("failed to open clipboard for export\n");
+        return;
+    }
+
+    for (;;)
+    {
+        if (!(params.data = malloc(params.size))) break;
+        if (NtUserGetClipboardData(CF_UNICODETEXT, &params))
+        {
+            exported = export_unicode_text(params.data, params.size, &exported_size);
+            break;
+        }
+        if (!params.data_size) break;
+        free(params.data);
+        params.size = params.data_size;
+        params.data_size = 0;
+    }
+
+    NtUserCloseClipboard();
+    if (exported) write_all(fd, exported, exported_size);
+
+    free(exported);
+    free(params.data);
+}
+
+static void data_control_source_send(void *data,
+                                     struct zwlr_data_control_source_v1 *source,
+                                     const char *mime_type, int32_t fd)
+{
+    if (!strcmp(mime_type, "text/plain;charset=utf-8"))
+        wayland_data_source_export(fd);
+    close(fd);
+}
+
+static void data_control_source_cancelled(void *data,
+                                          struct zwlr_data_control_source_v1 *source)
+{
+    struct wayland_data_device *data_device = data;
+
+    pthread_mutex_lock(&data_device->mutex);
+    zwlr_data_control_source_v1_destroy(source);
+    if (source == data_device->zwlr_data_control_source_v1)
+        data_device->zwlr_data_control_source_v1 = NULL;
+    pthread_mutex_unlock(&data_device->mutex);
+}
+
+static const struct zwlr_data_control_source_v1_listener data_control_source_listener =
+{
+    data_control_source_send,
+    data_control_source_cancelled,
+};
+
 void wayland_data_device_init(void)
 {
     struct wayland_data_device *data_device = &process_wayland.data_device;
 
     TRACE("\n");
 
+    pthread_mutex_lock(&data_device->mutex);
     if (data_device->zwlr_data_control_device_v1)
         zwlr_data_control_device_v1_destroy(data_device->zwlr_data_control_device_v1);
     data_device->zwlr_data_control_device_v1 =
         zwlr_data_control_manager_v1_get_data_device(
             process_wayland.zwlr_data_control_manager_v1,
             process_wayland.seat.wl_seat);
+    pthread_mutex_unlock(&data_device->mutex);
+}
+
+static void clipboard_update(void)
+{
+    struct wayland_data_device *data_device = &process_wayland.data_device;
+    struct zwlr_data_control_source_v1 *source;
+    UINT *formats, formats_size = 256, i;
+
+    if (!process_wayland.zwlr_data_control_manager_v1) return;
+
+    TRACE("\n");
+
+    source = zwlr_data_control_manager_v1_create_data_source(
+        process_wayland.zwlr_data_control_manager_v1);
+    if (!source)
+    {
+        ERR("failed to create data source\n");
+        return;
+    }
+
+    for (;;)
+    {
+        if (!(formats = malloc(formats_size * sizeof(*formats)))) break;
+        if (NtUserGetUpdatedClipboardFormats(formats, formats_size, &formats_size)) break;
+        free(formats);
+        formats = NULL;
+        if (RtlGetLastWin32Error() != ERROR_INSUFFICIENT_BUFFER) break;
+    }
+
+    if (!formats && formats_size)
+    {
+        ERR("failed to get clipboard formats\n");
+        zwlr_data_control_source_v1_destroy(source);
+        return;
+    }
+
+    for (i = 0; i < formats_size; ++i)
+    {
+        if (formats[i] == CF_UNICODETEXT)
+            zwlr_data_control_source_v1_offer(source, "text/plain;charset=utf-8");
+    }
+
+    free(formats);
+
+    zwlr_data_control_source_v1_add_listener(source, &data_control_source_listener, data_device);
+
+    pthread_mutex_lock(&data_device->mutex);
+    if (data_device->zwlr_data_control_device_v1)
+        zwlr_data_control_device_v1_set_selection(data_device->zwlr_data_control_device_v1, source);
+    /* Destroy any previous source only after setting the new source, to
+     * avoid spurious 'selection(nil)' events. */
+    if (data_device->zwlr_data_control_source_v1)
+        zwlr_data_control_source_v1_destroy(data_device->zwlr_data_control_source_v1);
+    data_device->zwlr_data_control_source_v1 = source;
+    pthread_mutex_unlock(&data_device->mutex);
+
+    wl_display_flush(process_wayland.wl_display);
 }
 
 LRESULT WAYLAND_ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
@@ -48,11 +216,16 @@ LRESULT WAYLAND_ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM l
     switch (msg)
     {
     case WM_NCCREATE:
+        clipboard_hwnd = hwnd;
+        NtUserAddClipboardFormatListener(hwnd);
         pthread_mutex_lock(&process_wayland.seat.mutex);
         if (process_wayland.seat.wl_seat && process_wayland.zwlr_data_control_manager_v1)
             wayland_data_device_init();
         pthread_mutex_unlock(&process_wayland.seat.mutex);
         return TRUE;
+    case WM_CLIPBOARDUPDATE:
+        clipboard_update();
+        break;
     }
 
     return NtUserMessageCall(hwnd, msg, wparam, lparam, NULL, NtUserDefWindowProc, FALSE);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 12ac686fbd9..c8f0ede23ba 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -133,6 +133,8 @@ struct wayland_seat
 struct wayland_data_device
 {
     struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1;
+    struct zwlr_data_control_source_v1 *zwlr_data_control_source_v1;
+    pthread_mutex_t mutex;
 };
 
 struct wayland
-- 
2.49.0

From 753ac9928d7cb7d8b0925da8b70dbf1f4d8bbb63 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 28 Jan 2025 11:10:30 +0200
Subject: [PATCH 009/159] winewayland: Generalize support for exporting
 clipboard formats.

Introduce the infrastructure to export various clipboard formats in a
table-driven manner, similar to what's used by winex11.
---
 dlls/winewayland.drv/wayland_data_device.c | 62 +++++++++++++++++++---
 1 file changed, 54 insertions(+), 8 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index b51f5b25ed4..77b9f4f7af0 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -33,6 +33,13 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
 
+struct data_device_format
+{
+    const char *mime_type;
+    UINT clipboard_format;
+    void *(*export)(void *data, size_t size, size_t *ret_size);
+};
+
 static HWND clipboard_hwnd;
 
 static void write_all(int fd, const void *buf, size_t count)
@@ -72,17 +79,49 @@ static void *export_unicode_text(void *data, size_t size, size_t *ret_size)
     return bytes;
 }
 
+/* Order is important. When selecting a mime-type for a clipboard format we
+ * will choose the first entry that matches the specified clipboard format. */
+static struct data_device_format supported_formats[] =
+{
+    {"text/plain;charset=utf-8", CF_UNICODETEXT, export_unicode_text},
+    {NULL, 0, NULL},
+};
+
+static struct data_device_format *data_device_format_for_clipboard_format(UINT clipboard_format)
+{
+    struct data_device_format *format;
+
+    for (format = supported_formats; format->mime_type; ++format)
+    {
+        if (format->clipboard_format == clipboard_format) return format;
+    }
+
+    return NULL;
+}
+
+static struct data_device_format *data_device_format_for_mime_type(const char *mime)
+{
+    struct data_device_format *format;
+
+    for (format = supported_formats; format->mime_type; ++format)
+    {
+        if (!strcmp(mime, format->mime_type)) return format;
+    }
+
+    return NULL;
+}
+
 /**********************************************************************
  *          zwlr_data_control_source_v1 handling
  */
 
-static void wayland_data_source_export(int32_t fd)
+static void wayland_data_source_export(struct data_device_format *format, int fd)
 {
     struct get_clipboard_params params = { .data_only = TRUE, .size = 1024 };
     void *exported = NULL;
     size_t exported_size;
 
-    TRACE("\n");
+    TRACE("format=%u => mime=%s\n", format->clipboard_format, format->mime_type);
 
     if (!NtUserOpenClipboard(clipboard_hwnd, 0))
     {
@@ -93,9 +132,9 @@ static void wayland_data_source_export(int32_t fd)
     for (;;)
     {
         if (!(params.data = malloc(params.size))) break;
-        if (NtUserGetClipboardData(CF_UNICODETEXT, &params))
+        if (NtUserGetClipboardData(format->clipboard_format, &params))
         {
-            exported = export_unicode_text(params.data, params.size, &exported_size);
+            exported = format->export(params.data, params.size, &exported_size);
             break;
         }
         if (!params.data_size) break;
@@ -115,8 +154,10 @@ static void data_control_source_send(void *data,
                                      struct zwlr_data_control_source_v1 *source,
                                      const char *mime_type, int32_t fd)
 {
-    if (!strcmp(mime_type, "text/plain;charset=utf-8"))
-        wayland_data_source_export(fd);
+    struct data_device_format *format =
+        data_device_format_for_mime_type(mime_type);
+
+    if (format) wayland_data_source_export(format, fd);
     close(fd);
 }
 
@@ -190,8 +231,13 @@ static void clipboard_update(void)
 
     for (i = 0; i < formats_size; ++i)
     {
-        if (formats[i] == CF_UNICODETEXT)
-            zwlr_data_control_source_v1_offer(source, "text/plain;charset=utf-8");
+        struct data_device_format *format =
+            data_device_format_for_clipboard_format(formats[i]);
+        if (format)
+        {
+            TRACE("offering mime=%s for format=%u\n", format->mime_type, formats[i]);
+            zwlr_data_control_source_v1_offer(source, format->mime_type);
+        }
     }
 
     free(formats);
-- 
2.49.0

From a1cb700b7f90285eab9760c4b5d5ac9b6501c11d Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 28 Jan 2025 11:31:48 +0200
Subject: [PATCH 010/159] winewayland: Support exporting various clipboard
 formats.

Add support for some formats commonly used in applications and which
do not require special exporting: RTF, TIFF, PNG, JPEG, GIF, SVG, RIFF, WAV.
---
 dlls/winewayland.drv/wayland_data_device.c | 39 ++++++++++++++++++++--
 1 file changed, 37 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 77b9f4f7af0..1659e9bd6df 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -37,10 +37,16 @@ struct data_device_format
 {
     const char *mime_type;
     UINT clipboard_format;
+    const WCHAR *register_name;
     void *(*export)(void *data, size_t size, size_t *ret_size);
 };
 
 static HWND clipboard_hwnd;
+static const WCHAR rich_text_formatW[] = {'R','i','c','h',' ','T','e','x','t',' ','F','o','r','m','a','t',0};
+static const WCHAR pngW[] = {'P','N','G',0};
+static const WCHAR jfifW[] = {'J','F','I','F',0};
+static const WCHAR gifW[] = {'G','I','F',0};
+static const WCHAR image_svg_xmlW[] = {'i','m','a','g','e','/','s','v','g','+','x','m','l',0};
 
 static void write_all(int fd, const void *buf, size_t count)
 {
@@ -79,11 +85,26 @@ static void *export_unicode_text(void *data, size_t size, size_t *ret_size)
     return bytes;
 }
 
+static void *export_data(void *data, size_t size, size_t *ret_size)
+{
+    *ret_size = size;
+    return data;
+}
+
 /* Order is important. When selecting a mime-type for a clipboard format we
  * will choose the first entry that matches the specified clipboard format. */
 static struct data_device_format supported_formats[] =
 {
-    {"text/plain;charset=utf-8", CF_UNICODETEXT, export_unicode_text},
+    {"text/plain;charset=utf-8", CF_UNICODETEXT, NULL, export_unicode_text},
+    {"text/rtf", 0, rich_text_formatW, export_data},
+    {"image/tiff", CF_TIFF, NULL, export_data},
+    {"image/png", 0, pngW, export_data},
+    {"image/jpeg", 0, jfifW, export_data},
+    {"image/gif", 0, gifW, export_data},
+    {"image/svg+xml", 0, image_svg_xmlW, export_data},
+    {"application/x-riff", CF_RIFF, NULL, export_data},
+    {"audio/wav", CF_WAVE, NULL, export_data},
+    {"audio/x-wav", CF_WAVE, NULL, export_data},
     {NULL, 0, NULL},
 };
 
@@ -111,6 +132,13 @@ static struct data_device_format *data_device_format_for_mime_type(const char *m
     return NULL;
 }
 
+static ATOM register_clipboard_format(const WCHAR *name)
+{
+    ATOM atom;
+    if (NtAddAtom(name, lstrlenW(name) * sizeof(WCHAR), &atom)) return 0;
+    return atom;
+}
+
 /**********************************************************************
  *          zwlr_data_control_source_v1 handling
  */
@@ -146,7 +174,7 @@ static void wayland_data_source_export(struct data_device_format *format, int fd
     NtUserCloseClipboard();
     if (exported) write_all(fd, exported, exported_size);
 
-    free(exported);
+    if (exported != params.data) free(exported);
     free(params.data);
 }
 
@@ -182,6 +210,7 @@ static const struct zwlr_data_control_source_v1_listener data_control_source_lis
 void wayland_data_device_init(void)
 {
     struct wayland_data_device *data_device = &process_wayland.data_device;
+    struct data_device_format *format = supported_formats;
 
     TRACE("\n");
 
@@ -193,6 +222,12 @@ void wayland_data_device_init(void)
             process_wayland.zwlr_data_control_manager_v1,
             process_wayland.seat.wl_seat);
     pthread_mutex_unlock(&data_device->mutex);
+
+    for (; format->mime_type; ++format)
+    {
+        if (format->clipboard_format == 0)
+            format->clipboard_format = register_clipboard_format(format->register_name);
+    }
 }
 
 static void clipboard_update(void)
-- 
2.49.0

From c7acea6fef789cbc4b0843cb09715d6f5f2fdb18 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 29 Jan 2025 10:23:44 +0200
Subject: [PATCH 011/159] winewayland: Support copying data from native
 clipboard to win32 apps.

---
 dlls/winewayland.drv/wayland_data_device.c | 379 ++++++++++++++++++++-
 dlls/winewayland.drv/waylanddrv.h          |   1 +
 2 files changed, 367 insertions(+), 13 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 1659e9bd6df..4018386b97c 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -25,6 +25,7 @@
 #include "config.h"
 
 #include <errno.h>
+#include <fcntl.h>
 #include <stdlib.h>
 #include <unistd.h>
 
@@ -33,12 +34,23 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
 
+/* A special MIME type we mark our data offers with, so we can detect that
+ * they are coming from us. */
+#define WINEWAYLAND_TAG_MIME_TYPE "application/x.winewayland.tag"
+
 struct data_device_format
 {
     const char *mime_type;
     UINT clipboard_format;
     const WCHAR *register_name;
     void *(*export)(void *data, size_t size, size_t *ret_size);
+    void *(*import)(void *data, size_t size, size_t *ret_size);
+};
+
+struct wayland_data_offer
+{
+    struct zwlr_data_control_offer_v1 *zwlr_data_control_offer_v1;
+    struct wl_array types;
 };
 
 static HWND clipboard_hwnd;
@@ -67,6 +79,59 @@ static void write_all(int fd, const void *buf, size_t count)
     }
 }
 
+static void *read_all(int fd, size_t *size_out)
+{
+    size_t buffer_size = 4096;
+    int total = 0;
+    unsigned char *buffer;
+    int nread;
+
+    if (!(buffer = malloc(buffer_size)))
+    {
+        ERR("failed to allocate read buffer\n");
+        goto out;
+    }
+
+    do
+    {
+        nread = read(fd, buffer + total, buffer_size - total);
+        if (nread == -1 && errno != EINTR)
+        {
+            TRACE("failed to read from fd (errno: %d)\n", errno);
+            total = 0;
+            goto out;
+        }
+        else if (nread > 0)
+        {
+            total += nread;
+            if (total == buffer_size)
+            {
+                unsigned char *new_buffer;
+                buffer_size *= 2;
+                new_buffer = realloc(buffer, buffer_size);
+                if (!new_buffer)
+                {
+                    ERR("failed to reallocate read buffer\n");
+                    total = 0;
+                    goto out;
+                }
+                buffer = new_buffer;
+            }
+        }
+    } while (nread > 0);
+
+    TRACE("read %d bytes\n", total);
+
+out:
+    if (total == 0 && buffer != NULL)
+    {
+        free(buffer);
+        buffer = NULL;
+    }
+    *size_out = total;
+    return buffer;
+}
+
 static void *export_unicode_text(void *data, size_t size, size_t *ret_size)
 {
     DWORD byte_count;
@@ -91,30 +156,66 @@ static void *export_data(void *data, size_t size, size_t *ret_size)
     return data;
 }
 
+static void *import_unicode_text(void *data, size_t size, size_t *ret_size)
+{
+    DWORD wsize;
+    WCHAR *ret;
+
+    RtlUTF8ToUnicodeN(NULL, 0, &wsize, data, size);
+    if (!(ret = malloc(wsize + sizeof(WCHAR)))) return NULL;
+    RtlUTF8ToUnicodeN(ret, wsize, &wsize, data, size);
+    ret[wsize / sizeof(WCHAR)] = 0;
+
+    *ret_size = wsize + sizeof(WCHAR);
+
+    return ret;
+}
+
+static void *import_data(void *data, size_t size, size_t *ret_size)
+{
+    *ret_size = size;
+    return data;
+}
+
 /* Order is important. When selecting a mime-type for a clipboard format we
  * will choose the first entry that matches the specified clipboard format. */
 static struct data_device_format supported_formats[] =
 {
-    {"text/plain;charset=utf-8", CF_UNICODETEXT, NULL, export_unicode_text},
-    {"text/rtf", 0, rich_text_formatW, export_data},
-    {"image/tiff", CF_TIFF, NULL, export_data},
-    {"image/png", 0, pngW, export_data},
-    {"image/jpeg", 0, jfifW, export_data},
-    {"image/gif", 0, gifW, export_data},
-    {"image/svg+xml", 0, image_svg_xmlW, export_data},
-    {"application/x-riff", CF_RIFF, NULL, export_data},
-    {"audio/wav", CF_WAVE, NULL, export_data},
-    {"audio/x-wav", CF_WAVE, NULL, export_data},
+    {"text/plain;charset=utf-8", CF_UNICODETEXT, NULL, export_unicode_text, import_unicode_text},
+    {"text/rtf", 0, rich_text_formatW, export_data, import_data},
+    {"image/tiff", CF_TIFF, NULL, export_data, import_data},
+    {"image/png", 0, pngW, export_data, import_data},
+    {"image/jpeg", 0, jfifW, export_data, import_data},
+    {"image/gif", 0, gifW, export_data, import_data},
+    {"image/svg+xml", 0, image_svg_xmlW, export_data, import_data},
+    {"application/x-riff", CF_RIFF, NULL, export_data, import_data},
+    {"audio/wav", CF_WAVE, NULL, export_data, import_data},
+    {"audio/x-wav", CF_WAVE, NULL, export_data, import_data},
     {NULL, 0, NULL},
 };
 
-static struct data_device_format *data_device_format_for_clipboard_format(UINT clipboard_format)
+static BOOL string_array_contains(struct wl_array *array, const char *str)
+{
+    char **p;
+
+    wl_array_for_each(p, array)
+        if (!strcmp(*p, str)) return TRUE;
+
+    return FALSE;
+}
+
+static struct data_device_format *data_device_format_for_clipboard_format(UINT clipboard_format,
+                                                                          struct wl_array *types)
 {
     struct data_device_format *format;
 
     for (format = supported_formats; format->mime_type; ++format)
     {
-        if (format->clipboard_format == clipboard_format) return format;
+        if (format->clipboard_format == clipboard_format &&
+            (!types || string_array_contains(types, format->mime_type)))
+        {
+            return format;
+        }
     }
 
     return NULL;
@@ -207,6 +308,202 @@ static const struct zwlr_data_control_source_v1_listener data_control_source_lis
     data_control_source_cancelled,
 };
 
+/**********************************************************************
+ *          zwlr_data_control_offer_v1 handling
+ */
+
+static void data_control_offer_offer(void *data,
+                                     struct zwlr_data_control_offer_v1 *zwlr_data_control_offer_v1,
+                                     const char *type)
+{
+    struct wayland_data_offer *data_offer = data;
+    const char *type_copy;
+    const char **p;
+
+    if ((type_copy = strdup(type)) &&
+        (p = wl_array_add(&data_offer->types, sizeof *p)))
+    {
+        *p = type_copy;
+    }
+}
+
+static const struct zwlr_data_control_offer_v1_listener data_control_offer_listener =
+{
+    data_control_offer_offer,
+};
+
+static void wayland_data_offer_create(struct zwlr_data_control_offer_v1 *zwlr_data_control_offer_v1)
+{
+    struct wayland_data_offer *data_offer;
+
+    if (!(data_offer = calloc(1, sizeof(*data_offer))))
+    {
+        ERR("Failed to allocate memory for data offer\n");
+        return;
+    }
+
+    data_offer->zwlr_data_control_offer_v1 = zwlr_data_control_offer_v1;
+    wl_array_init(&data_offer->types);
+    zwlr_data_control_offer_v1_add_listener(data_offer->zwlr_data_control_offer_v1,
+                                            &data_control_offer_listener, data_offer);
+}
+
+static void wayland_data_offer_destroy(struct wayland_data_offer *data_offer)
+{
+    char **p;
+
+    zwlr_data_control_offer_v1_destroy(data_offer->zwlr_data_control_offer_v1);
+    wl_array_for_each(p, &data_offer->types)
+        free(*p);
+    wl_array_release(&data_offer->types);
+    free(data_offer);
+}
+
+static int wayland_data_offer_get_import_fd(struct wayland_data_offer *data_offer,
+                                            const char *mime_type)
+{
+    int data_pipe[2];
+
+#if HAVE_PIPE2
+    if (pipe2(data_pipe, O_CLOEXEC) == -1)
+#endif
+    {
+        if (pipe(data_pipe) == -1)
+        {
+            ERR("failed to create clipboard data pipe\n");
+            return -1;
+        }
+        fcntl(data_pipe[0], F_SETFD, FD_CLOEXEC);
+        fcntl(data_pipe[1], F_SETFD, FD_CLOEXEC);
+    }
+
+    zwlr_data_control_offer_v1_receive(data_offer->zwlr_data_control_offer_v1,
+                                       mime_type, data_pipe[1]);
+    close(data_pipe[1]);
+
+    /* Flush to ensure our receive request reaches the server. */
+    wl_display_flush(process_wayland.wl_display);
+
+    return data_pipe[0];
+}
+
+static void *import_format(int fd, struct data_device_format *format, size_t *ret_size)
+{
+    size_t size;
+    void *data, *ret;
+
+    if (!(data = read_all(fd, &size))) return NULL;
+    ret = format->import(data, size, ret_size);
+    if (ret != data) free(data);
+    return ret;
+}
+
+/**********************************************************************
+ *          zwlr_data_control_device_v1 handling
+ */
+
+static void wayland_data_device_destroy_clipboard_data_offer(struct wayland_data_device *data_device)
+{
+    if (data_device->clipboard_zwlr_data_control_offer_v1)
+    {
+        struct wayland_data_offer *data_offer =
+            zwlr_data_control_offer_v1_get_user_data(data_device->clipboard_zwlr_data_control_offer_v1);
+        if (data_offer) wayland_data_offer_destroy(data_offer);
+        data_device->clipboard_zwlr_data_control_offer_v1 = NULL;
+    }
+}
+
+static void data_control_device_data_offer(
+    void *data,
+    struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1,
+    struct zwlr_data_control_offer_v1 *zwlr_data_control_offer_v1)
+{
+    wayland_data_offer_create(zwlr_data_control_offer_v1);
+}
+
+static void clipboard_update(void);
+
+static void data_control_device_selection(
+    void *data,
+    struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1,
+    struct zwlr_data_control_offer_v1 *zwlr_data_control_offer_v1)
+{
+    struct wayland_data_device *data_device = data;
+    struct wayland_data_offer *data_offer = NULL;
+    char **p;
+
+    if (!zwlr_data_control_offer_v1 ||
+        !(data_offer = zwlr_data_control_offer_v1_get_user_data(zwlr_data_control_offer_v1)))
+    {
+        TRACE("empty offer, clearing clipboard\n");
+        if (NtUserOpenClipboard(clipboard_hwnd, 0))
+        {
+            NtUserEmptyClipboard();
+            NtUserCloseClipboard();
+        }
+        goto done;
+    }
+
+    TRACE("updating clipboard from wayland offer\n");
+
+    /* If this offer contains the special winewayland tag mime-type, it was sent
+     * by a winewayland process to notify external wayland clients about a Wine
+     * clipboard update. */
+    wl_array_for_each(p, &data_offer->types)
+    {
+        if (!strcmp(*p, WINEWAYLAND_TAG_MIME_TYPE))
+        {
+            TRACE("offer sent by winewayland, ignoring\n");
+            wayland_data_offer_destroy(data_offer);
+            data_offer = NULL;
+            goto done;
+        }
+    }
+
+    if (!NtUserOpenClipboard(clipboard_hwnd, 0))
+    {
+        TRACE("failed to open clipboard for selection\n");
+        wayland_data_offer_destroy(data_offer);
+        data_offer = NULL;
+        goto done;
+    }
+
+    NtUserEmptyClipboard();
+
+    /* For each mime type, mark that we have available clipboard data. */
+    wl_array_for_each(p, &data_offer->types)
+    {
+        struct data_device_format *format = data_device_format_for_mime_type(*p);
+        if (format)
+        {
+            struct set_clipboard_params params = {0};
+            TRACE("available clipboard format for %s => %u\n",
+                  *p, format->clipboard_format);
+            NtUserSetClipboardData(format->clipboard_format, 0, &params);
+        }
+    }
+
+    NtUserCloseClipboard();
+
+done:
+    pthread_mutex_lock(&data_device->mutex);
+    wayland_data_device_destroy_clipboard_data_offer(data_device);
+    if (data_offer) data_device->clipboard_zwlr_data_control_offer_v1 = zwlr_data_control_offer_v1;
+    pthread_mutex_unlock(&data_device->mutex);
+}
+
+static void data_control_device_finished(
+    void *data, struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1)
+{
+}
+
+static const struct zwlr_data_control_device_v1_listener data_control_device_listener =
+{
+    data_control_device_data_offer,
+    data_control_device_selection,
+    data_control_device_finished,
+};
+
 void wayland_data_device_init(void)
 {
     struct wayland_data_device *data_device = &process_wayland.data_device;
@@ -221,6 +518,12 @@ void wayland_data_device_init(void)
         zwlr_data_control_manager_v1_get_data_device(
             process_wayland.zwlr_data_control_manager_v1,
             process_wayland.seat.wl_seat);
+    if (data_device->zwlr_data_control_device_v1)
+    {
+        zwlr_data_control_device_v1_add_listener(
+            data_device->zwlr_data_control_device_v1, &data_control_device_listener,
+            data_device);
+    }
     pthread_mutex_unlock(&data_device->mutex);
 
     for (; format->mime_type; ++format)
@@ -267,7 +570,7 @@ static void clipboard_update(void)
     for (i = 0; i < formats_size; ++i)
     {
         struct data_device_format *format =
-            data_device_format_for_clipboard_format(formats[i]);
+            data_device_format_for_clipboard_format(formats[i], NULL);
         if (format)
         {
             TRACE("offering mime=%s for format=%u\n", format->mime_type, formats[i]);
@@ -277,6 +580,7 @@ static void clipboard_update(void)
 
     free(formats);
 
+    zwlr_data_control_source_v1_offer(source, WINEWAYLAND_TAG_MIME_TYPE);
     zwlr_data_control_source_v1_add_listener(source, &data_control_source_listener, data_device);
 
     pthread_mutex_lock(&data_device->mutex);
@@ -292,6 +596,48 @@ static void clipboard_update(void)
     wl_display_flush(process_wayland.wl_display);
 }
 
+static void render_format(UINT clipboard_format)
+{
+    struct wayland_data_device *data_device = &process_wayland.data_device;
+    struct wayland_data_offer *data_offer;
+    struct data_device_format *format;
+    int import_fd = -1;
+
+    TRACE("clipboard_format=%u\n", clipboard_format);
+
+    pthread_mutex_lock(&data_device->mutex);
+    if (data_device->clipboard_zwlr_data_control_offer_v1 &&
+        (data_offer = zwlr_data_control_offer_v1_get_user_data(data_device->clipboard_zwlr_data_control_offer_v1)) &&
+        (format = data_device_format_for_clipboard_format(clipboard_format,
+                                                          &data_offer->types)))
+    {
+        import_fd = wayland_data_offer_get_import_fd(data_offer, format->mime_type);
+    }
+    pthread_mutex_unlock(&data_device->mutex);
+
+    if (import_fd >= 0)
+    {
+        struct set_clipboard_params params = {0};
+        if ((params.data = import_format(import_fd, format, &params.size)))
+        {
+            NtUserSetClipboardData(format->clipboard_format, 0, &params);
+            free(params.data);
+        }
+        close(import_fd);
+    }
+}
+
+static void destroy_clipboard(void)
+{
+    struct wayland_data_device *data_device = &process_wayland.data_device;
+
+    TRACE("\n");
+
+    pthread_mutex_lock(&data_device->mutex);
+    wayland_data_device_destroy_clipboard_data_offer(data_device);
+    pthread_mutex_unlock(&data_device->mutex);
+}
+
 LRESULT WAYLAND_ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
 {
     switch (msg)
@@ -305,8 +651,15 @@ LRESULT WAYLAND_ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM l
         pthread_mutex_unlock(&process_wayland.seat.mutex);
         return TRUE;
     case WM_CLIPBOARDUPDATE:
+        if (NtUserGetClipboardOwner() == clipboard_hwnd) break;
         clipboard_update();
         break;
+    case WM_RENDERFORMAT:
+        render_format(wparam);
+        break;
+    case WM_DESTROYCLIPBOARD:
+        destroy_clipboard();
+        break;
     }
 
     return NtUserMessageCall(hwnd, msg, wparam, lparam, NULL, NtUserDefWindowProc, FALSE);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index c8f0ede23ba..c389167c3b7 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -134,6 +134,7 @@ struct wayland_data_device
 {
     struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1;
     struct zwlr_data_control_source_v1 *zwlr_data_control_source_v1;
+    struct zwlr_data_control_offer_v1 *clipboard_zwlr_data_control_offer_v1;
     pthread_mutex_t mutex;
 };
 
-- 
2.49.0

From 0fb8b7d490fd5a09e952812222446f4b1ebe60e6 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 29 Jan 2025 13:39:02 +0200
Subject: [PATCH 012/159] winewayland: Normalize received MIME type strings.

---
 dlls/winewayland.drv/wayland_data_device.c | 45 +++++++++++++++++++---
 1 file changed, 39 insertions(+), 6 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 4018386b97c..04872df4fcb 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -60,6 +60,35 @@ static const WCHAR jfifW[] = {'J','F','I','F',0};
 static const WCHAR gifW[] = {'G','I','F',0};
 static const WCHAR image_svg_xmlW[] = {'i','m','a','g','e','/','s','v','g','+','x','m','l',0};
 
+/* Normalize the MIME type string by skipping inconsequential characters,
+ * such as spaces and double quotes, and convert to lower case. */
+static const char *normalize_mime_type(const char *mime_type)
+{
+    char *new_mime_type;
+    const char *cur_read;
+    char *cur_write;
+    size_t new_mime_len = 0;
+
+    for (cur_read = mime_type; *cur_read != '\0'; ++cur_read)
+    {
+        if (*cur_read != ' ' && *cur_read != '"')
+            new_mime_len++;
+    }
+
+    new_mime_type = malloc(new_mime_len + 1);
+    if (!new_mime_type) return NULL;
+
+    for (cur_read = mime_type, cur_write = new_mime_type; *cur_read != '\0'; ++cur_read)
+    {
+        if (*cur_read != ' ' && *cur_read != '"')
+            *cur_write++ = tolower(*cur_read);
+    }
+
+    *cur_write = '\0';
+
+    return new_mime_type;
+}
+
 static void write_all(int fd, const void *buf, size_t count)
 {
     size_t nwritten = 0;
@@ -283,10 +312,14 @@ static void data_control_source_send(void *data,
                                      struct zwlr_data_control_source_v1 *source,
                                      const char *mime_type, int32_t fd)
 {
-    struct data_device_format *format =
-        data_device_format_for_mime_type(mime_type);
+    struct data_device_format *format;
+    const char *normalized;
 
-    if (format) wayland_data_source_export(format, fd);
+    if ((normalized = normalize_mime_type(mime_type)) &&
+        (format = data_device_format_for_mime_type(normalized)))
+    {
+        wayland_data_source_export(format, fd);
+    }
     close(fd);
 }
 
@@ -317,13 +350,13 @@ static void data_control_offer_offer(void *data,
                                      const char *type)
 {
     struct wayland_data_offer *data_offer = data;
-    const char *type_copy;
+    const char *normalized;
     const char **p;
 
-    if ((type_copy = strdup(type)) &&
+    if ((normalized = normalize_mime_type(type)) &&
         (p = wl_array_add(&data_offer->types, sizeof *p)))
     {
-        *p = type_copy;
+        *p = normalized;
     }
 }
 
-- 
2.49.0

From 2f76947576c5cb057562f134679f8ec043e29640 Mon Sep 17 00:00:00 2001
From: Attila Fidan <dev@print0.net>
Date: Mon, 17 Feb 2025 04:15:35 +0000
Subject: [PATCH 013/159] winewayland: Update locked pointer position hint.

This may be used by the compositor to warp the Wayland pointer to where
the win32 cursor is upon unlock, if it's within surface bounds.
---
 dlls/winewayland.drv/wayland_pointer.c | 30 ++++++++++++++++++++++++--
 1 file changed, 28 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index c20ba170285..52aaa337aac 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -885,27 +885,53 @@ void WAYLAND_SetCursor(HWND hwnd, HCURSOR hcursor)
 BOOL WAYLAND_ClipCursor(const RECT *clip, BOOL reset)
 {
     struct wayland_pointer *pointer = &process_wayland.pointer;
+    HWND hwnd;
     struct wl_surface *wl_surface = NULL;
     struct wayland_surface *surface = NULL;
     struct wayland_win_data *data;
     BOOL covers_vscreen = FALSE;
     RECT confine_rect;
+    POINT cursor_pos;
+    int warp_x, warp_y;
 
     TRACE("clip=%s reset=%d\n", wine_dbgstr_rect(clip), reset);
 
-    if (!(data = wayland_win_data_get(NtUserGetForegroundWindow()))) return FALSE;
+    NtUserGetCursorPos(&cursor_pos);
+    hwnd = NtUserGetForegroundWindow();
+
+    if (!(data = wayland_win_data_get(hwnd))) return FALSE;
     if ((surface = data->wayland_surface))
     {
         wl_surface = surface->wl_surface;
         if (clip) wayland_surface_calc_confine(surface, clip, &confine_rect);
         covers_vscreen = wayland_surface_client_covers_vscreen(surface);
+        wayland_surface_coords_from_window(surface,
+                cursor_pos.x - surface->window.rect.left,
+                cursor_pos.y - surface->window.rect.top,
+                &warp_x, &warp_y);
     }
     wayland_win_data_release(data);
 
+    pthread_mutex_lock(&pointer->mutex);
+    if (wl_surface && hwnd == pointer->constraint_hwnd && pointer->zwp_locked_pointer_v1)
+    {
+        zwp_locked_pointer_v1_set_cursor_position_hint(
+                pointer->zwp_locked_pointer_v1,
+                wl_fixed_from_int(warp_x),
+                wl_fixed_from_int(warp_y));
+        pthread_mutex_unlock(&pointer->mutex);
+
+        data = wayland_win_data_get(hwnd);
+        wl_surface_commit(wl_surface);
+        wayland_win_data_release(data);
+        TRACE("position hint hwnd=%p wayland_xy=%d,%d screen_xy=%d,%d\n",
+                hwnd, warp_x, warp_y, (int)cursor_pos.x, (int)cursor_pos.y);
+        pthread_mutex_lock(&pointer->mutex);
+    }
+
    /* Since we are running in the context of the foreground thread we know
     * that the wl_surface of the foreground HWND will not be invalidated,
     * so we can access it without having the win data lock. */
-    pthread_mutex_lock(&pointer->mutex);
     wayland_pointer_update_constraint(wl_surface,
                                       (clip && wl_surface) ? &confine_rect : NULL,
                                       covers_vscreen);
-- 
2.49.0

From 87028902e005ad1831e5f79c3e084c083f9c8789 Mon Sep 17 00:00:00 2001
From: Attila Fidan <dev@print0.net>
Date: Sun, 16 Feb 2025 10:00:41 +0000
Subject: [PATCH 014/159] winewayland: Implement SetCursorPos via pointer lock.

---
 dlls/winewayland.drv/wayland_pointer.c | 42 ++++++++++++++++++++++----
 dlls/winewayland.drv/waylanddrv.h      |  2 ++
 dlls/winewayland.drv/waylanddrv_main.c |  1 +
 3 files changed, 39 insertions(+), 6 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 52aaa337aac..e2b31e02011 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -745,7 +745,8 @@ static BOOL wayland_surface_client_covers_vscreen(struct wayland_surface *surfac
  */
 static void wayland_pointer_update_constraint(struct wl_surface *wl_surface,
                                               RECT *confine_rect,
-                                              BOOL covers_vscreen)
+                                              BOOL covers_vscreen,
+                                              BOOL force_lock)
 {
     struct wayland_pointer *pointer = &process_wayland.pointer;
     BOOL needs_relative, needs_lock, needs_confine;
@@ -758,9 +759,10 @@ static void wayland_pointer_update_constraint(struct wl_surface *wl_surface,
         return;
     }
 
-    needs_lock = wl_surface && (confine_rect || covers_vscreen) &&
-                 !pointer->cursor.wl_surface;
-    needs_confine = wl_surface && confine_rect && pointer->cursor.wl_surface;
+    needs_lock = wl_surface && (((confine_rect || covers_vscreen) &&
+                 !pointer->cursor.wl_surface) || force_lock);
+    needs_confine = wl_surface && confine_rect && pointer->cursor.wl_surface &&
+                 !force_lock;
 
     if (!needs_confine && pointer->zwp_confined_pointer_v1)
     {
@@ -866,7 +868,7 @@ static void wayland_pointer_update_constraint(struct wl_surface *wl_surface,
 
 void wayland_pointer_clear_constraint(void)
 {
-    wayland_pointer_update_constraint(NULL, NULL, FALSE);
+    wayland_pointer_update_constraint(NULL, NULL, FALSE, FALSE);
 }
 
 /***********************************************************************
@@ -879,6 +881,27 @@ void WAYLAND_SetCursor(HWND hwnd, HCURSOR hcursor)
     wayland_set_cursor(hwnd, hcursor, TRUE);
 }
 
+/***********************************************************************
+ *           WAYLAND_SetCursorPos
+ */
+BOOL WAYLAND_SetCursorPos(INT x, INT y)
+{
+    struct wayland_pointer *pointer = &process_wayland.pointer;
+
+    pthread_mutex_lock(&pointer->mutex);
+    if (pointer->zwp_relative_pointer_v1)
+    {
+        pthread_mutex_unlock(&pointer->mutex);
+        return FALSE;
+    }
+    pointer->pending_warp = TRUE;
+    pthread_mutex_unlock(&pointer->mutex);
+
+    TRACE("warping to %d,%d\n", x, y);
+    reapply_cursor_clipping();
+    return TRUE;
+}
+
 /***********************************************************************
  *	     WAYLAND_ClipCursor
  */
@@ -913,6 +936,12 @@ BOOL WAYLAND_ClipCursor(const RECT *clip, BOOL reset)
     wayland_win_data_release(data);
 
     pthread_mutex_lock(&pointer->mutex);
+    if (wl_surface && pointer->pending_warp)
+    {
+        wayland_pointer_update_constraint(wl_surface, NULL, FALSE, TRUE);
+        pointer->pending_warp = FALSE;
+    }
+
     if (wl_surface && hwnd == pointer->constraint_hwnd && pointer->zwp_locked_pointer_v1)
     {
         zwp_locked_pointer_v1_set_cursor_position_hint(
@@ -934,7 +963,8 @@ BOOL WAYLAND_ClipCursor(const RECT *clip, BOOL reset)
     * so we can access it without having the win data lock. */
     wayland_pointer_update_constraint(wl_surface,
                                       (clip && wl_surface) ? &confine_rect : NULL,
-                                      covers_vscreen);
+                                      covers_vscreen,
+                                      FALSE);
     pthread_mutex_unlock(&pointer->mutex);
 
     wl_display_flush(process_wayland.wl_display);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index c389167c3b7..ead2269b72c 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -107,6 +107,7 @@ struct wayland_pointer
     struct zwp_relative_pointer_v1 *zwp_relative_pointer_v1;
     HWND focused_hwnd;
     HWND constraint_hwnd;
+    BOOL pending_warp;
     uint32_t enter_serial;
     uint32_t button_serial;
     struct wayland_cursor cursor;
@@ -414,6 +415,7 @@ LRESULT WAYLAND_DesktopWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
 void WAYLAND_DestroyWindow(HWND hwnd);
 BOOL WAYLAND_SetIMECompositionRect(HWND hwnd, RECT rect);
 void WAYLAND_SetCursor(HWND hwnd, HCURSOR hcursor);
+BOOL WAYLAND_SetCursorPos(INT x, INT y);
 void WAYLAND_SetWindowText(HWND hwnd, LPCWSTR text);
 LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam, const POINT *pos);
 UINT WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager, void *param);
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index ca7ec47b674..1d4ddeb3425 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -43,6 +43,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pKbdLayerDescriptor = WAYLAND_KbdLayerDescriptor,
     .pReleaseKbdTables = WAYLAND_ReleaseKbdTables,
     .pSetCursor = WAYLAND_SetCursor,
+    .pSetCursorPos = WAYLAND_SetCursorPos,
     .pSetWindowText = WAYLAND_SetWindowText,
     .pSysCommand = WAYLAND_SysCommand,
     .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
-- 
2.49.0

From 4a088b9e0cc3f78faf25b5b8f81f55ba15e39ba9 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 18 Feb 2025 17:32:42 +0200
Subject: [PATCH 015/159] winewayland: Don't crash on text input done events
 without focus.

Some compositors (e.g., kwin) will send a done event for every commit,
regardless of the focus state of the text input. This behavior is
arguably out of spec, but otherwise harmless, so just ignore the new
state in such cases.
---
 dlls/winewayland.drv/wayland_text_input.c | 14 +++++++++-----
 1 file changed, 9 insertions(+), 5 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_text_input.c b/dlls/winewayland.drv/wayland_text_input.c
index 17257634b2e..e0181eb8240 100644
--- a/dlls/winewayland.drv/wayland_text_input.c
+++ b/dlls/winewayland.drv/wayland_text_input.c
@@ -131,11 +131,15 @@ static void text_input_done(void *data, struct zwp_text_input_v3 *zwp_text_input
     TRACE("data %p, text_input %p, serial %u.\n", data, zwp_text_input_v3, serial);
 
     pthread_mutex_lock(&text_input->mutex);
-    assert(text_input->wl_surface);
-    hwnd = wl_surface_get_user_data(text_input->wl_surface);
-
-    post_ime_update(hwnd, text_input->preedit_cursor_pos, text_input->preedit_string,
-            text_input->commit_string);
+    /* Some compositors will send a done event for every commit, regardless of
+     * the focus state of the text input. This behavior is arguably out of spec,
+     * but otherwise harmless, so just ignore the new state in such cases. */
+    if (text_input->wl_surface)
+    {
+        hwnd = wl_surface_get_user_data(text_input->wl_surface);
+        post_ime_update(hwnd, text_input->preedit_cursor_pos, text_input->preedit_string,
+                text_input->commit_string);
+    }
 
     free(text_input->preedit_string);
     text_input->preedit_string = NULL;
-- 
2.49.0

From cbcaeb3f9d28a99234b85f8564cef8faef954354 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 5 Mar 2025 12:15:44 +0200
Subject: [PATCH 016/159] winewayland: Present EGL surfaces opaquely.

Many applications request and use GL configs with alpha, but assume that
the windowing system will present their surfaces opaquely. Wayland
compositors normally respect the alpha channel, which leads to unwanted
translucency effects for such applications, so we use the
EGL_EXT_present_opaque extension to avoid this.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=57800
---
 dlls/winewayland.drv/opengl.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index b8b673f398a..d9a83d49b3e 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -194,6 +194,7 @@ static struct wayland_gl_drawable *wayland_gl_drawable_create(HWND hwnd, int for
     struct wayland_gl_drawable *gl;
     int client_width, client_height;
     RECT client_rect = {0};
+    const EGLint attribs[] = {EGL_PRESENT_OPAQUE_EXT, EGL_TRUE, EGL_NONE};
 
     TRACE("hwnd=%p format=%d\n", hwnd, format);
 
@@ -223,7 +224,7 @@ static struct wayland_gl_drawable *wayland_gl_drawable_create(HWND hwnd, int for
     }
 
     gl->surface = p_eglCreateWindowSurface(egl_display, egl_config_for_format(format),
-                                           gl->wl_egl_window, NULL);
+                                           gl->wl_egl_window, attribs);
     if (!gl->surface)
     {
         ERR("Failed to create EGL surface\n");
@@ -1397,6 +1398,7 @@ static void init_opengl(void)
     REQUIRE_EXT(EGL_KHR_create_context);
     REQUIRE_EXT(EGL_KHR_create_context_no_error);
     REQUIRE_EXT(EGL_KHR_no_config_context);
+    REQUIRE_EXT(EGL_EXT_present_opaque);
 #undef REQUIRE_EXT
 
     has_egl_ext_pixel_format_float = has_extension(egl_exts, "EGL_EXT_pixel_format_float");
-- 
2.49.0

From 1281ba088573215bbc2588fa51069e53031414b2 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 6 Mar 2025 17:09:58 +0200
Subject: [PATCH 017/159] winewayland: Treat fully transparent cursors as
 hidden.

SDL 2.0.18 and newer (including SDL 3) set a fully transparent cursor
object when hiding the cursor (instead of using a NULL cursor handle).
Detect this case and treat it as a request to hide the cursor, to make
our locking/relative-motion heuristics work.
---
 dlls/winewayland.drv/wayland_pointer.c | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index e2b31e02011..17139c47b13 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -494,6 +494,17 @@ static BOOL get_icon_info(HICON handle, ICONINFOEXW *ret)
     return TRUE;
 }
 
+static BOOL cursor_buffer_is_transparent(struct wayland_shm_buffer *shm_buffer)
+{
+    uint32_t *pixel = shm_buffer->map_data;
+    uint32_t *end = pixel + shm_buffer->map_size / WINEWAYLAND_BYTES_PER_PIXEL;
+
+    for (; pixel < end; ++pixel)
+        if ((*pixel & 0xff000000) != 0) return FALSE;
+
+    return TRUE;
+}
+
 static void wayland_pointer_update_cursor_buffer(HCURSOR hcursor, double scale)
 {
     struct wayland_cursor *cursor = &process_wayland.pointer.cursor;
@@ -538,6 +549,9 @@ static void wayland_pointer_update_cursor_buffer(HCURSOR hcursor, double scale)
         goto clear_cursor;
     }
 
+    if (cursor_buffer_is_transparent(cursor->shm_buffer))
+        goto clear_cursor;
+
     /* Make sure the hotspot is valid. */
     if (cursor->hotspot_x >= cursor->shm_buffer->width ||
         cursor->hotspot_y >= cursor->shm_buffer->height)
-- 
2.49.0

From 3e3453a0ba529fec74d89e03e84e05d50f649e76 Mon Sep 17 00:00:00 2001
From: Attila Fidan <dev@print0.net>
Date: Thu, 20 Mar 2025 11:45:41 +0000
Subject: [PATCH 018/159] win32u: Return 0 from NtUserGetKeyNameText if there
 is no translation.

---
 dlls/win32u/input.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/win32u/input.c b/dlls/win32u/input.c
index 97e651a7ce5..8b90b78f019 100644
--- a/dlls/win32u/input.c
+++ b/dlls/win32u/input.c
@@ -1283,7 +1283,7 @@ INT WINAPI NtUserGetKeyNameText( LONG lparam, WCHAR *buffer, INT size )
         HKL hkl = NtUserGetKeyboardLayout( 0 );
         vkey = NtUserMapVirtualKeyEx( code & 0xff, MAPVK_VSC_TO_VK, hkl );
         buffer[0] = NtUserMapVirtualKeyEx( vkey, MAPVK_VK_TO_CHAR, hkl );
-        len = 1;
+        len = buffer[0] ? 1 : 0;
     }
     buffer[len] = 0;
 
-- 
2.49.0

From 8777e8c7e0685d9caf18e207304f7dd29671cce4 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 7 Feb 2025 13:23:46 +0200
Subject: [PATCH 019/159] winewayland: Implement wl_data_device initialization.

The data device is initialized once for each process, from within a
dedicated thread and window that handles clipboard events.
---
 dlls/winewayland.drv/Makefile.in           |  1 +
 dlls/winewayland.drv/dllmain.c             | 61 ++++++++++++++++++++++
 dlls/winewayland.drv/unixlib.h             |  1 +
 dlls/winewayland.drv/wayland.c             | 10 +++-
 dlls/winewayland.drv/wayland_data_device.c | 55 ++++++++++++++-----
 dlls/winewayland.drv/waylanddrv.h          | 17 ++++--
 dlls/winewayland.drv/waylanddrv_main.c     | 11 ++++
 7 files changed, 140 insertions(+), 16 deletions(-)

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 142db22ba9e..4141e36c9a8 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -2,6 +2,7 @@ MODULE = winewayland.drv
 UNIXLIB = winewayland.so
 UNIX_CFLAGS = $(EGL_CFLAGS) $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_EGL_CFLAGS) $(XKBCOMMON_CFLAGS) $(XKBREGISTRY_CFLAGS)
 UNIX_LIBS = -lwin32u $(WAYLAND_CLIENT_LIBS) $(WAYLAND_EGL_LIBS) $(XKBCOMMON_LIBS) $(XKBREGISTRY_LIBS) $(PTHREAD_LIBS) -lm
+IMPORTS = user32 win32u
 
 SOURCES = \
 	display.c \
diff --git a/dlls/winewayland.drv/dllmain.c b/dlls/winewayland.drv/dllmain.c
index d040620957b..8055d883ee0 100644
--- a/dlls/winewayland.drv/dllmain.c
+++ b/dlls/winewayland.drv/dllmain.c
@@ -20,6 +20,9 @@
 
 #include "waylanddrv_dll.h"
 
+#include "ntuser.h"
+#include "winuser.h"
+
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
@@ -35,6 +38,61 @@ static DWORD WINAPI wayland_read_events_thread(void *arg)
     return 0;
 }
 
+static LRESULT CALLBACK clipboard_wndproc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
+{
+    switch (msg)
+    {
+    case WM_NCCREATE:
+    case WM_CLIPBOARDUPDATE:
+    case WM_RENDERFORMAT:
+    case WM_TIMER:
+    case WM_DESTROYCLIPBOARD:
+    case WM_USER:
+        return NtUserMessageCall(hwnd, msg, wp, lp, 0, NtUserClipboardWindowProc, FALSE);
+    }
+
+    return DefWindowProcW(hwnd, msg, wp, lp);
+}
+
+static DWORD WINAPI clipboard_thread(void *arg)
+{
+    static const WCHAR clipboard_classname[] = L"__winewayland_clipboard_manager";
+    WNDCLASSW class;
+    ATOM atom;
+    MSG msg;
+    HWND hwnd;
+
+    memset(&class, 0, sizeof(class));
+    class.lpfnWndProc = clipboard_wndproc;
+    class.lpszClassName = clipboard_classname;
+
+    if (!(atom = RegisterClassW(&class)) && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
+    {
+        ERR("could not register clipboard window class err %lu\n", GetLastError());
+        return 0;
+    }
+    /* The HWND_MESSAGE parent window may not have been created yet. It will be
+     * created eventually, so keep trying. */
+    while (!(hwnd = CreateWindowW(clipboard_classname, NULL, 0, 0, 0, 0, 0,
+                                  HWND_MESSAGE, 0, 0, NULL)) &&
+           GetLastError() == ERROR_INVALID_WINDOW_HANDLE)
+    {
+        SwitchToThread();
+    }
+
+    if (!hwnd)
+    {
+        TRACE("failed to create clipboard window err %lu\n", GetLastError());
+        UnregisterClassW(MAKEINTRESOURCEW(atom), NULL);
+        return 0;
+    }
+
+    TRACE("created per-process clipboard window hwnd=%p\n", hwnd);
+
+    while (GetMessageW(&msg, 0, 0, 0)) DispatchMessageW(&msg);
+    return 0;
+}
+
 BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
 {
     DWORD tid;
@@ -49,6 +107,9 @@ BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
 
     /* Read wayland events from a dedicated thread. */
     CloseHandle(CreateThread(NULL, 0, wayland_read_events_thread, NULL, 0, &tid));
+    /* Handle clipboard events in a dedicated thread, if needed. */
+    if (!WAYLANDDRV_UNIX_CALL(init_clipboard, NULL))
+        CloseHandle(CreateThread(NULL, 0, clipboard_thread, NULL, 0, &tid));
 
     return TRUE;
 }
diff --git a/dlls/winewayland.drv/unixlib.h b/dlls/winewayland.drv/unixlib.h
index dc3bfdf8893..d9378fe8248 100644
--- a/dlls/winewayland.drv/unixlib.h
+++ b/dlls/winewayland.drv/unixlib.h
@@ -27,6 +27,7 @@ enum waylanddrv_unix_func
 {
     waylanddrv_unix_func_init,
     waylanddrv_unix_func_read_events,
+    waylanddrv_unix_func_init_clipboard,
     waylanddrv_unix_func_count,
 };
 
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index ee162d8fe77..2a51222fd5f 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -147,8 +147,11 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         pthread_mutex_unlock(&seat->mutex);
         if (process_wayland.zwp_text_input_manager_v3) wayland_text_input_init();
         /* Recreate the data device for the new seat. */
-        if (process_wayland.data_device.zwlr_data_control_device_v1)
+        if (process_wayland.data_device.zwlr_data_control_device_v1 ||
+            process_wayland.data_device.wl_data_device)
+        {
             wayland_data_device_init();
+        }
     }
     else if (strcmp(interface, "wp_viewporter") == 0)
     {
@@ -181,6 +184,11 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         process_wayland.zwlr_data_control_manager_v1 =
             wl_registry_bind(registry, id, &zwlr_data_control_manager_v1_interface, 1);
     }
+    else if (strcmp(interface, "wl_data_device_manager") == 0)
+    {
+        process_wayland.wl_data_device_manager =
+            wl_registry_bind(registry, id, &wl_data_device_manager_interface, 2);
+    }
 }
 
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 04872df4fcb..472df0a2717 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -545,17 +545,29 @@ void wayland_data_device_init(void)
     TRACE("\n");
 
     pthread_mutex_lock(&data_device->mutex);
-    if (data_device->zwlr_data_control_device_v1)
-        zwlr_data_control_device_v1_destroy(data_device->zwlr_data_control_device_v1);
-    data_device->zwlr_data_control_device_v1 =
-        zwlr_data_control_manager_v1_get_data_device(
-            process_wayland.zwlr_data_control_manager_v1,
-            process_wayland.seat.wl_seat);
-    if (data_device->zwlr_data_control_device_v1)
+    if (process_wayland.zwlr_data_control_manager_v1)
+    {
+        if (data_device->zwlr_data_control_device_v1)
+            zwlr_data_control_device_v1_destroy(data_device->zwlr_data_control_device_v1);
+        data_device->zwlr_data_control_device_v1 =
+            zwlr_data_control_manager_v1_get_data_device(
+                process_wayland.zwlr_data_control_manager_v1,
+                process_wayland.seat.wl_seat);
+        if (data_device->zwlr_data_control_device_v1)
+        {
+            zwlr_data_control_device_v1_add_listener(
+                data_device->zwlr_data_control_device_v1, &data_control_device_listener,
+                data_device);
+        }
+    }
+    else if (process_wayland.wl_data_device_manager)
     {
-        zwlr_data_control_device_v1_add_listener(
-            data_device->zwlr_data_control_device_v1, &data_control_device_listener,
-            data_device);
+        if (data_device->wl_data_device)
+            wl_data_device_release(data_device->wl_data_device);
+        data_device->wl_data_device =
+            wl_data_device_manager_get_data_device(
+                process_wayland.wl_data_device_manager,
+                process_wayland.seat.wl_seat);
     }
     pthread_mutex_unlock(&data_device->mutex);
 
@@ -671,16 +683,35 @@ static void destroy_clipboard(void)
     pthread_mutex_unlock(&data_device->mutex);
 }
 
+static BOOL is_winewayland_clipboard_hwnd(HWND hwnd)
+{
+    static const WCHAR clipboard_classnameW[] = {
+        '_','_','w','i','n','e','w','a','y','l','a','n','d','_',
+        'c','l','i','p','b','o','a','r','d','_','m','a','n','a','g','e','r'};
+    WCHAR buffer[64];
+    UNICODE_STRING name = {.Buffer = buffer, .MaximumLength = sizeof(buffer)};
+
+    if (!NtUserGetClassName(hwnd, FALSE, &name)) return FALSE;
+    return !wcscmp(buffer, clipboard_classnameW);
+}
+
 LRESULT WAYLAND_ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
 {
     switch (msg)
     {
     case WM_NCCREATE:
+        /* Disable the default clipboard window in the desktop process if we are
+         * using the core wl_data_device protocol. */
+        if (!process_wayland.zwlr_data_control_manager_v1 &&
+            process_wayland.wl_data_device_manager &&
+            !is_winewayland_clipboard_hwnd(hwnd))
+        {
+            return FALSE;
+        }
         clipboard_hwnd = hwnd;
         NtUserAddClipboardFormatListener(hwnd);
         pthread_mutex_lock(&process_wayland.seat.mutex);
-        if (process_wayland.seat.wl_seat && process_wayland.zwlr_data_control_manager_v1)
-            wayland_data_device_init();
+        if (process_wayland.seat.wl_seat) wayland_data_device_init();
         pthread_mutex_unlock(&process_wayland.seat.mutex);
         return TRUE;
     case WM_CLIPBOARDUPDATE:
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index ead2269b72c..c2fb56dc9bf 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -133,9 +133,19 @@ struct wayland_seat
 
 struct wayland_data_device
 {
-    struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1;
-    struct zwlr_data_control_source_v1 *zwlr_data_control_source_v1;
-    struct zwlr_data_control_offer_v1 *clipboard_zwlr_data_control_offer_v1;
+    union
+    {
+        struct
+        {
+            struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1;
+            struct zwlr_data_control_source_v1 *zwlr_data_control_source_v1;
+            struct zwlr_data_control_offer_v1 *clipboard_zwlr_data_control_offer_v1;
+        };
+        struct
+        {
+            struct wl_data_device *wl_data_device;
+        };
+    };
     pthread_mutex_t mutex;
 };
 
@@ -155,6 +165,7 @@ struct wayland
     struct zwp_relative_pointer_manager_v1 *zwp_relative_pointer_manager_v1;
     struct zwp_text_input_manager_v3 *zwp_text_input_manager_v3;
     struct zwlr_data_control_manager_v1 *zwlr_data_control_manager_v1;
+    struct wl_data_device_manager *wl_data_device_manager;
     struct wayland_seat seat;
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 1d4ddeb3425..dba519b1df1 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -110,10 +110,20 @@ static NTSTATUS waylanddrv_unix_read_events(void *arg)
     return STATUS_UNSUCCESSFUL;
 }
 
+static NTSTATUS waylanddrv_unix_init_clipboard(void *arg)
+{
+    /* If the compositor supports zwlr_data_control_manager_v1, we don't need
+     * per-process clipboard window and handling, we can use the default clipboard
+     * window from the desktop process. */
+    if (process_wayland.zwlr_data_control_manager_v1) return STATUS_UNSUCCESSFUL;
+    return STATUS_SUCCESS;
+}
+
 const unixlib_entry_t __wine_unix_call_funcs[] =
 {
     waylanddrv_unix_init,
     waylanddrv_unix_read_events,
+    waylanddrv_unix_init_clipboard,
 };
 
 C_ASSERT(ARRAYSIZE(__wine_unix_call_funcs) == waylanddrv_unix_func_count);
@@ -124,6 +134,7 @@ const unixlib_entry_t __wine_unix_call_wow64_funcs[] =
 {
     waylanddrv_unix_init,
     waylanddrv_unix_read_events,
+    waylanddrv_unix_init_clipboard,
 };
 
 C_ASSERT(ARRAYSIZE(__wine_unix_call_wow64_funcs) == waylanddrv_unix_func_count);
-- 
2.49.0

From 3aeabfea321b40902066dfa182282fcc1baed090 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 14 Mar 2025 10:13:26 +0200
Subject: [PATCH 020/159] winewayland: Support wl_data_device for copies from
 win32 clipboard to native apps.

If the wlr-data-control-unstable-v1 extension is not available use
the core data device protocol.
---
 dlls/winewayland.drv/wayland_data_device.c | 124 ++++++++++++++++++---
 dlls/winewayland.drv/wayland_keyboard.c    |   8 ++
 dlls/winewayland.drv/wayland_pointer.c     |   6 +
 dlls/winewayland.drv/waylanddrv.h          |   2 +
 4 files changed, 126 insertions(+), 14 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 472df0a2717..c2d5b6e095c 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -537,6 +537,64 @@ static const struct zwlr_data_control_device_v1_listener data_control_device_lis
     data_control_device_finished,
 };
 
+/**********************************************************************
+ *          wl_data_source handling
+ */
+
+static void data_source_target(void *data, struct wl_data_source *source,
+                               const char *mime_type)
+{
+}
+
+static void data_source_send(void *data, struct wl_data_source *source,
+                             const char *mime_type, int32_t fd)
+{
+    struct data_device_format *format;
+    const char *normalized;
+
+    if ((normalized = normalize_mime_type(mime_type)) &&
+        (format = data_device_format_for_mime_type(normalized)))
+    {
+        wayland_data_source_export(format, fd);
+    }
+    close(fd);
+}
+
+static void data_source_cancelled(void *data, struct wl_data_source *source)
+{
+    struct wayland_data_device *data_device = data;
+
+    pthread_mutex_lock(&data_device->mutex);
+    wl_data_source_destroy(source);
+    if (source == data_device->wl_data_source)
+        data_device->wl_data_source = NULL;
+    pthread_mutex_unlock(&data_device->mutex);
+}
+
+static void data_source_dnd_drop_performed(void *data,
+                                           struct wl_data_source *source)
+{
+}
+
+static void data_source_dnd_finished(void *data, struct wl_data_source *source)
+{
+}
+
+static void data_source_action(void *data, struct wl_data_source *source,
+                               uint32_t dnd_action)
+{
+}
+
+static const struct wl_data_source_listener data_source_listener =
+{
+    data_source_target,
+    data_source_send,
+    data_source_cancelled,
+    data_source_dnd_drop_performed,
+    data_source_dnd_finished,
+    data_source_action,
+};
+
 void wayland_data_device_init(void)
 {
     struct wayland_data_device *data_device = &process_wayland.data_device;
@@ -581,16 +639,33 @@ void wayland_data_device_init(void)
 static void clipboard_update(void)
 {
     struct wayland_data_device *data_device = &process_wayland.data_device;
-    struct zwlr_data_control_source_v1 *source;
+    struct zwlr_data_control_source_v1 *zwlr_source = NULL;
+    struct wl_data_source *wl_source = NULL;
     UINT *formats, formats_size = 256, i;
+    uint32_t serial = 0;
 
-    if (!process_wayland.zwlr_data_control_manager_v1) return;
+    if (process_wayland.zwlr_data_control_manager_v1)
+    {
+        zwlr_source = zwlr_data_control_manager_v1_create_data_source(
+            process_wayland.zwlr_data_control_manager_v1);
+    }
+    else
+    {
+        serial = InterlockedCompareExchange(&process_wayland.input_serial, 0, 0);
+        pthread_mutex_lock(&process_wayland.keyboard.mutex);
+        if (!process_wayland.keyboard.focused_hwnd) serial = 0;
+        pthread_mutex_unlock(&process_wayland.keyboard.mutex);
+        if (process_wayland.wl_data_device_manager && serial)
+        {
+            wl_source = wl_data_device_manager_create_data_source(
+                process_wayland.wl_data_device_manager);
+        }
+        else return;
+    }
 
     TRACE("\n");
 
-    source = zwlr_data_control_manager_v1_create_data_source(
-        process_wayland.zwlr_data_control_manager_v1);
-    if (!source)
+    if (!zwlr_source && !wl_source)
     {
         ERR("failed to create data source\n");
         return;
@@ -608,7 +683,8 @@ static void clipboard_update(void)
     if (!formats && formats_size)
     {
         ERR("failed to get clipboard formats\n");
-        zwlr_data_control_source_v1_destroy(source);
+        if (wl_source) wl_data_source_destroy(wl_source);
+        else zwlr_data_control_source_v1_destroy(zwlr_source);
         return;
     }
 
@@ -619,23 +695,43 @@ static void clipboard_update(void)
         if (format)
         {
             TRACE("offering mime=%s for format=%u\n", format->mime_type, formats[i]);
-            zwlr_data_control_source_v1_offer(source, format->mime_type);
+            if (wl_source) wl_data_source_offer(wl_source, format->mime_type);
+            else zwlr_data_control_source_v1_offer(zwlr_source, format->mime_type);
         }
     }
 
     free(formats);
 
-    zwlr_data_control_source_v1_offer(source, WINEWAYLAND_TAG_MIME_TYPE);
-    zwlr_data_control_source_v1_add_listener(source, &data_control_source_listener, data_device);
+    if (wl_source)
+    {
+        wl_data_source_offer(wl_source, WINEWAYLAND_TAG_MIME_TYPE);
+        wl_data_source_add_listener(wl_source, &data_source_listener, data_device);
+    }
+    else
+    {
+        zwlr_data_control_source_v1_offer(zwlr_source, WINEWAYLAND_TAG_MIME_TYPE);
+        zwlr_data_control_source_v1_add_listener(zwlr_source, &data_control_source_listener, data_device);
+    }
 
     pthread_mutex_lock(&data_device->mutex);
-    if (data_device->zwlr_data_control_device_v1)
-        zwlr_data_control_device_v1_set_selection(data_device->zwlr_data_control_device_v1, source);
     /* Destroy any previous source only after setting the new source, to
      * avoid spurious 'selection(nil)' events. */
-    if (data_device->zwlr_data_control_source_v1)
-        zwlr_data_control_source_v1_destroy(data_device->zwlr_data_control_source_v1);
-    data_device->zwlr_data_control_source_v1 = source;
+    if (wl_source)
+    {
+        if (data_device->wl_data_device)
+            wl_data_device_set_selection(data_device->wl_data_device, wl_source, serial);
+        if (data_device->wl_data_source)
+            wl_data_source_destroy(data_device->wl_data_source);
+        data_device->wl_data_source = wl_source;
+    }
+    else
+    {
+        if (data_device->zwlr_data_control_device_v1)
+            zwlr_data_control_device_v1_set_selection(data_device->zwlr_data_control_device_v1, zwlr_source);
+        if (data_device->zwlr_data_control_source_v1)
+            zwlr_data_control_source_v1_destroy(data_device->zwlr_data_control_source_v1);
+        data_device->zwlr_data_control_source_v1 = zwlr_source;
+    }
     pthread_mutex_unlock(&data_device->mutex);
 
     wl_display_flush(process_wayland.wl_display);
diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index 8f7b6dce30f..39b42231b00 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -745,6 +745,8 @@ static void keyboard_handle_enter(void *private, struct wl_keyboard *wl_keyboard
     struct wayland_win_data *data;
     HWND hwnd;
 
+    InterlockedExchange(&process_wayland.input_serial, serial);
+
     if (!wl_surface) return;
 
     /* The wl_surface user data remains valid and immutable for the whole
@@ -780,6 +782,8 @@ static void keyboard_handle_leave(void *data, struct wl_keyboard *wl_keyboard,
     struct wayland_keyboard *keyboard = &process_wayland.keyboard;
     HWND hwnd;
 
+    InterlockedExchange(&process_wayland.input_serial, serial);
+
     if (!wl_surface) return;
 
     /* The wl_surface user data remains valid and immutable for the whole
@@ -817,6 +821,8 @@ static void keyboard_handle_key(void *data, struct wl_keyboard *wl_keyboard,
     INPUT input = {0};
     HWND hwnd;
 
+    InterlockedExchange(&process_wayland.input_serial, serial);
+
     if (!(hwnd = wayland_keyboard_get_focused_hwnd())) return;
 
     TRACE_(key)("serial=%u hwnd=%p key=%d scan=%#x state=%#x\n", serial, hwnd, key, scan, state);
@@ -840,6 +846,8 @@ static void keyboard_handle_modifiers(void *data, struct wl_keyboard *wl_keyboar
 {
     struct wayland_keyboard *keyboard = &process_wayland.keyboard;
 
+    InterlockedExchange(&process_wayland.input_serial, serial);
+
     if (!wayland_keyboard_get_focused_hwnd()) return;
 
     TRACE("serial=%u mods_depressed=%#x mods_latched=%#x mods_locked=%#x xkb_group=%d stub!\n",
diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 17139c47b13..457c3675cf1 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -112,6 +112,8 @@ static void pointer_handle_enter(void *data, struct wl_pointer *wl_pointer,
     struct wayland_pointer *pointer = &process_wayland.pointer;
     HWND hwnd;
 
+    InterlockedExchange(&process_wayland.input_serial, serial);
+
     if (!wl_surface) return;
     /* The wl_surface user data remains valid and immutable for the whole
      * lifetime of the object, so it's safe to access without locking. */
@@ -139,6 +141,8 @@ static void pointer_handle_leave(void *data, struct wl_pointer *wl_pointer,
 {
     struct wayland_pointer *pointer = &process_wayland.pointer;
 
+    InterlockedExchange(&process_wayland.input_serial, serial);
+
     if (!wl_surface) return;
 
     TRACE("hwnd=%p\n", wl_surface_get_user_data(wl_surface));
@@ -157,6 +161,8 @@ static void pointer_handle_button(void *data, struct wl_pointer *wl_pointer,
     INPUT input = {0};
     HWND hwnd;
 
+    InterlockedExchange(&process_wayland.input_serial, serial);
+
     if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
 
     input.type = INPUT_MOUSE;
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index c2fb56dc9bf..1649e0f84f3 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -144,6 +144,7 @@ struct wayland_data_device
         struct
         {
             struct wl_data_device *wl_data_device;
+            struct wl_data_source *wl_data_source;
         };
     };
     pthread_mutex_t mutex;
@@ -174,6 +175,7 @@ struct wayland
     struct wl_list output_list;
     /* Protects the output_list and the wayland_output.current states. */
     pthread_mutex_t output_mutex;
+    LONG input_serial;
 };
 
 struct wayland_output_mode
-- 
2.49.0

From 26fd5855a3b5b7414f459f8371a847cdcf5d00cf Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 17 Mar 2025 09:19:43 +0200
Subject: [PATCH 021/159] winewayland: Support wl_data_device for copies from
 native apps to win32 clipboard.

---
 dlls/winewayland.drv/wayland_data_device.c | 177 +++++++++++++++++----
 dlls/winewayland.drv/waylanddrv.h          |   1 +
 2 files changed, 148 insertions(+), 30 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index c2d5b6e095c..e36c0cc9229 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -49,7 +49,11 @@ struct data_device_format
 
 struct wayland_data_offer
 {
-    struct zwlr_data_control_offer_v1 *zwlr_data_control_offer_v1;
+    union
+    {
+        struct zwlr_data_control_offer_v1 *zwlr_data_control_offer_v1;
+        struct wl_data_offer *wl_data_offer;
+    };
     struct wl_array types;
 };
 
@@ -365,7 +369,17 @@ static const struct zwlr_data_control_offer_v1_listener data_control_offer_liste
     data_control_offer_offer,
 };
 
-static void wayland_data_offer_create(struct zwlr_data_control_offer_v1 *zwlr_data_control_offer_v1)
+static void data_offer_offer(void *data, struct wl_data_offer *wl_data_offer, const char *type)
+{
+    data_control_offer_offer(data, NULL, type);
+}
+
+static const struct wl_data_offer_listener data_offer_listener =
+{
+    data_offer_offer,
+};
+
+static void wayland_data_offer_create(void *offer_proxy)
 {
     struct wayland_data_offer *data_offer;
 
@@ -375,17 +389,30 @@ static void wayland_data_offer_create(struct zwlr_data_control_offer_v1 *zwlr_da
         return;
     }
 
-    data_offer->zwlr_data_control_offer_v1 = zwlr_data_control_offer_v1;
     wl_array_init(&data_offer->types);
-    zwlr_data_control_offer_v1_add_listener(data_offer->zwlr_data_control_offer_v1,
-                                            &data_control_offer_listener, data_offer);
+    if (process_wayland.zwlr_data_control_manager_v1)
+    {
+        data_offer->zwlr_data_control_offer_v1 = offer_proxy;
+        zwlr_data_control_offer_v1_add_listener(data_offer->zwlr_data_control_offer_v1,
+                                                &data_control_offer_listener, data_offer);
+    }
+    else
+    {
+        data_offer->wl_data_offer = offer_proxy;
+        wl_data_offer_add_listener(data_offer->wl_data_offer, &data_offer_listener,
+                                   data_offer);
+
+    }
 }
 
 static void wayland_data_offer_destroy(struct wayland_data_offer *data_offer)
 {
     char **p;
 
-    zwlr_data_control_offer_v1_destroy(data_offer->zwlr_data_control_offer_v1);
+    if (process_wayland.zwlr_data_control_manager_v1)
+        zwlr_data_control_offer_v1_destroy(data_offer->zwlr_data_control_offer_v1);
+    else
+        wl_data_offer_destroy(data_offer->wl_data_offer);
     wl_array_for_each(p, &data_offer->types)
         free(*p);
     wl_array_release(&data_offer->types);
@@ -410,8 +437,15 @@ static int wayland_data_offer_get_import_fd(struct wayland_data_offer *data_offe
         fcntl(data_pipe[1], F_SETFD, FD_CLOEXEC);
     }
 
-    zwlr_data_control_offer_v1_receive(data_offer->zwlr_data_control_offer_v1,
-                                       mime_type, data_pipe[1]);
+    if (process_wayland.zwlr_data_control_manager_v1)
+    {
+        zwlr_data_control_offer_v1_receive(data_offer->zwlr_data_control_offer_v1,
+                                           mime_type, data_pipe[1]);
+    }
+    else
+    {
+        wl_data_offer_receive(data_offer->wl_data_offer, mime_type, data_pipe[1]);
+    }
     close(data_pipe[1]);
 
     /* Flush to ensure our receive request reaches the server. */
@@ -431,21 +465,31 @@ static void *import_format(int fd, struct data_device_format *format, size_t *re
     return ret;
 }
 
-/**********************************************************************
- *          zwlr_data_control_device_v1 handling
- */
-
 static void wayland_data_device_destroy_clipboard_data_offer(struct wayland_data_device *data_device)
 {
-    if (data_device->clipboard_zwlr_data_control_offer_v1)
+    struct wayland_data_offer *data_offer = NULL;
+
+    if (process_wayland.zwlr_data_control_manager_v1 &&
+        data_device->clipboard_zwlr_data_control_offer_v1)
     {
-        struct wayland_data_offer *data_offer =
-            zwlr_data_control_offer_v1_get_user_data(data_device->clipboard_zwlr_data_control_offer_v1);
-        if (data_offer) wayland_data_offer_destroy(data_offer);
+        data_offer = zwlr_data_control_offer_v1_get_user_data(
+            data_device->clipboard_zwlr_data_control_offer_v1);
         data_device->clipboard_zwlr_data_control_offer_v1 = NULL;
     }
+    else if (!process_wayland.zwlr_data_control_manager_v1 &&
+             data_device->clipboard_wl_data_offer)
+    {
+        data_offer = wl_data_offer_get_user_data(data_device->clipboard_wl_data_offer);
+        data_device->clipboard_wl_data_offer = NULL;
+    }
+
+    if (data_offer) wayland_data_offer_destroy(data_offer);
 }
 
+/**********************************************************************
+ *          zwlr_data_control_device_v1 handling
+ */
+
 static void data_control_device_data_offer(
     void *data,
     struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1,
@@ -454,19 +498,12 @@ static void data_control_device_data_offer(
     wayland_data_offer_create(zwlr_data_control_offer_v1);
 }
 
-static void clipboard_update(void);
-
-static void data_control_device_selection(
-    void *data,
-    struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1,
-    struct zwlr_data_control_offer_v1 *zwlr_data_control_offer_v1)
+static void handle_selection(struct wayland_data_device *data_device,
+                             struct wayland_data_offer *data_offer)
 {
-    struct wayland_data_device *data_device = data;
-    struct wayland_data_offer *data_offer = NULL;
     char **p;
 
-    if (!zwlr_data_control_offer_v1 ||
-        !(data_offer = zwlr_data_control_offer_v1_get_user_data(zwlr_data_control_offer_v1)))
+    if (!data_offer)
     {
         TRACE("empty offer, clearing clipboard\n");
         if (NtUserOpenClipboard(clipboard_hwnd, 0))
@@ -521,8 +558,26 @@ static void data_control_device_selection(
 done:
     pthread_mutex_lock(&data_device->mutex);
     wayland_data_device_destroy_clipboard_data_offer(data_device);
-    if (data_offer) data_device->clipboard_zwlr_data_control_offer_v1 = zwlr_data_control_offer_v1;
+    if (data_offer)
+    {
+        if (process_wayland.zwlr_data_control_manager_v1)
+            data_device->clipboard_zwlr_data_control_offer_v1 = data_offer->zwlr_data_control_offer_v1;
+        else
+            data_device->clipboard_wl_data_offer = data_offer->wl_data_offer;
+    }
     pthread_mutex_unlock(&data_device->mutex);
+
+}
+
+static void data_control_device_selection(
+    void *data,
+    struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1,
+    struct zwlr_data_control_offer_v1 *zwlr_data_control_offer_v1)
+{
+    handle_selection(data,
+                     zwlr_data_control_offer_v1 ?
+                         zwlr_data_control_offer_v1_get_user_data(zwlr_data_control_offer_v1) :
+                         NULL);
 }
 
 static void data_control_device_finished(
@@ -595,6 +650,52 @@ static const struct wl_data_source_listener data_source_listener =
     data_source_action,
 };
 
+/**********************************************************************
+ *          wl_data_device handling
+ */
+
+static void data_device_data_offer(void *data, struct wl_data_device *wl_data_device,
+                                   struct wl_data_offer *wl_data_offer)
+{
+    wayland_data_offer_create(wl_data_offer);
+}
+
+static void data_device_enter(void *data, struct wl_data_device *wl_data_device,
+                              uint32_t serial, struct wl_surface *wl_surface,
+                              wl_fixed_t x_w, wl_fixed_t y_w,
+                              struct wl_data_offer *wl_data_offer)
+{
+}
+
+static void data_device_leave(void *data, struct wl_data_device *wl_data_device)
+{
+}
+
+static void data_device_motion(void *data, struct wl_data_device *wl_data_device,
+                               uint32_t time, wl_fixed_t x_w, wl_fixed_t y_w)
+{
+}
+
+static void data_device_drop(void *data, struct wl_data_device *wl_data_device)
+{
+}
+
+static void data_device_selection(void *data, struct wl_data_device *wl_data_device,
+                                  struct wl_data_offer *wl_data_offer)
+{
+    handle_selection(data, wl_data_offer ? wl_data_offer_get_user_data(wl_data_offer) : NULL);
+}
+
+static const struct wl_data_device_listener data_device_listener =
+{
+    data_device_data_offer,
+    data_device_enter,
+    data_device_leave,
+    data_device_motion,
+    data_device_drop,
+    data_device_selection,
+};
+
 void wayland_data_device_init(void)
 {
     struct wayland_data_device *data_device = &process_wayland.data_device;
@@ -626,6 +727,11 @@ void wayland_data_device_init(void)
             wl_data_device_manager_get_data_device(
                 process_wayland.wl_data_device_manager,
                 process_wayland.seat.wl_seat);
+        if (data_device->wl_data_device)
+        {
+            wl_data_device_add_listener(data_device->wl_data_device,
+                                        &data_device_listener, data_device);
+        }
     }
     pthread_mutex_unlock(&data_device->mutex);
 
@@ -740,15 +846,26 @@ static void clipboard_update(void)
 static void render_format(UINT clipboard_format)
 {
     struct wayland_data_device *data_device = &process_wayland.data_device;
-    struct wayland_data_offer *data_offer;
+    struct wayland_data_offer *data_offer = NULL;
     struct data_device_format *format;
     int import_fd = -1;
 
     TRACE("clipboard_format=%u\n", clipboard_format);
 
     pthread_mutex_lock(&data_device->mutex);
-    if (data_device->clipboard_zwlr_data_control_offer_v1 &&
-        (data_offer = zwlr_data_control_offer_v1_get_user_data(data_device->clipboard_zwlr_data_control_offer_v1)) &&
+    if (process_wayland.zwlr_data_control_manager_v1 &&
+        data_device->clipboard_zwlr_data_control_offer_v1)
+    {
+        data_offer = zwlr_data_control_offer_v1_get_user_data(
+            data_device->clipboard_zwlr_data_control_offer_v1);
+    }
+    else if (!process_wayland.zwlr_data_control_manager_v1 &&
+             data_device->clipboard_wl_data_offer)
+    {
+        data_offer = wl_data_offer_get_user_data(data_device->clipboard_wl_data_offer);
+    }
+
+    if (data_offer &&
         (format = data_device_format_for_clipboard_format(clipboard_format,
                                                           &data_offer->types)))
     {
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 1649e0f84f3..065d4d31873 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -145,6 +145,7 @@ struct wayland_data_device
         {
             struct wl_data_device *wl_data_device;
             struct wl_data_source *wl_data_source;
+            struct wl_data_offer *clipboard_wl_data_offer;
         };
     };
     pthread_mutex_t mutex;
-- 
2.49.0

From bae1ba66f1c65f0df76d5f9794297db6ca4a1ec1 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 17 Mar 2025 13:51:39 +0200
Subject: [PATCH 022/159] winewayland: Warn about missing clipboard
 functionality.

---
 dlls/winewayland.drv/wayland.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 2a51222fd5f..7caf33c872e 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -311,6 +311,14 @@ BOOL wayland_process_init(void)
     if (!process_wayland.zwp_text_input_manager_v3)
         ERR("Wayland compositor doesn't support optional zwp_text_input_manager_v3 (host input methods won't work)\n");
 
+    if (!process_wayland.zwlr_data_control_manager_v1)
+    {
+        if (!process_wayland.wl_data_device_manager)
+            ERR("Wayland compositor doesn't support optional wl_data_device_manager (clipboard won't work)\n");
+        else
+            ERR("Wayland compositor doesn't support optional zwlr_data_control_manager_v1 (clipboard functionality will be limited)\n");
+    }
+
     process_wayland.initialized = TRUE;
 
     return TRUE;
-- 
2.49.0

From 1859ba66d0e15461eb32e8762eba7e1d24ba99fc Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty <etaash.mathamsetty@gmail.com>
Date: Sun, 1 Dec 2024 13:36:40 -0500
Subject: [PATCH 023/159] winewayland.drv: Implement support for
 xdg-toplevel-icon.

---
 dlls/winewayland.drv/Makefile.in              |   3 +-
 dlls/winewayland.drv/wayland.c                |   8 +
 dlls/winewayland.drv/wayland_pointer.c        |  94 +-------
 dlls/winewayland.drv/wayland_surface.c        | 167 ++++++++++++++
 dlls/winewayland.drv/waylanddrv.h             |  33 ++-
 dlls/winewayland.drv/waylanddrv_main.c        |   1 +
 dlls/winewayland.drv/window.c                 |  69 +++++-
 dlls/winewayland.drv/xdg-toplevel-icon-v1.xml | 205 ++++++++++++++++++
 8 files changed, 473 insertions(+), 107 deletions(-)
 create mode 100644 dlls/winewayland.drv/xdg-toplevel-icon-v1.xml

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 4141e36c9a8..e7b1bfb90eb 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -26,4 +26,5 @@ SOURCES = \
 	window_surface.c \
 	wlr-data-control-unstable-v1.xml \
 	xdg-output-unstable-v1.xml \
-	xdg-shell.xml
+	xdg-shell.xml \
+	xdg-toplevel-icon-v1.xml
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 7caf33c872e..ba09d32ed89 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -189,6 +189,11 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         process_wayland.wl_data_device_manager =
             wl_registry_bind(registry, id, &wl_data_device_manager_interface, 2);
     }
+    else if (strcmp(interface, "xdg_toplevel_icon_manager_v1") == 0)
+    {
+        process_wayland.xdg_toplevel_icon_manager_v1 =
+            wl_registry_bind(registry, id, &xdg_toplevel_icon_manager_v1_interface, 1);
+    }
 }
 
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
@@ -319,6 +324,9 @@ BOOL wayland_process_init(void)
             ERR("Wayland compositor doesn't support optional zwlr_data_control_manager_v1 (clipboard functionality will be limited)\n");
     }
 
+    if (!process_wayland.xdg_toplevel_icon_manager_v1)
+        ERR("Wayland compositor doesn't support xdg_toplevel_icon_manager_v1 (window icons will not be supported)\n");
+
     process_wayland.initialized = TRUE;
 
     return TRUE;
diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 457c3675cf1..6c852292c1d 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -382,98 +382,6 @@ done:
     return shm_buffer;
 }
 
-/***********************************************************************
- *           create_color_cursor_buffer
- *
- * Create a wayland_shm_buffer for a color cursor bitmap.
- *
- * Adapted from wineandroid.drv code.
- */
-static struct wayland_shm_buffer *create_color_cursor_buffer(HDC hdc, HBITMAP color,
-                                                             HBITMAP mask)
-{
-    struct wayland_shm_buffer *shm_buffer = NULL;
-    char buffer[FIELD_OFFSET(BITMAPINFO, bmiColors[256])];
-    BITMAPINFO *info = (BITMAPINFO *)buffer;
-    BITMAP bm;
-    unsigned int *ptr, *bits = NULL;
-    unsigned char *mask_bits = NULL;
-    int i, j;
-    BOOL has_alpha = FALSE;
-
-    if (!NtGdiExtGetObjectW(color, sizeof(bm), &bm)) goto failed;
-
-    shm_buffer = wayland_shm_buffer_create(bm.bmWidth, bm.bmHeight,
-                                           WL_SHM_FORMAT_ARGB8888);
-    if (!shm_buffer) goto failed;
-    bits = shm_buffer->map_data;
-
-    info->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
-    info->bmiHeader.biWidth = bm.bmWidth;
-    info->bmiHeader.biHeight = -bm.bmHeight;
-    info->bmiHeader.biPlanes = 1;
-    info->bmiHeader.biBitCount = 32;
-    info->bmiHeader.biCompression = BI_RGB;
-    info->bmiHeader.biSizeImage = bm.bmWidth * bm.bmHeight * 4;
-    info->bmiHeader.biXPelsPerMeter = 0;
-    info->bmiHeader.biYPelsPerMeter = 0;
-    info->bmiHeader.biClrUsed = 0;
-    info->bmiHeader.biClrImportant = 0;
-
-    if (!NtGdiGetDIBitsInternal(hdc, color, 0, bm.bmHeight, bits, info,
-                                DIB_RGB_COLORS, 0, 0))
-        goto failed;
-
-    for (i = 0; i < bm.bmWidth * bm.bmHeight; i++)
-        if ((has_alpha = (bits[i] & 0xff000000) != 0)) break;
-
-    if (!has_alpha)
-    {
-        unsigned int width_bytes = (bm.bmWidth + 31) / 32 * 4;
-        /* generate alpha channel from the mask */
-        info->bmiHeader.biBitCount = 1;
-        info->bmiHeader.biSizeImage = width_bytes * bm.bmHeight;
-        if (!(mask_bits = malloc(info->bmiHeader.biSizeImage))) goto failed;
-        if (!NtGdiGetDIBitsInternal(hdc, mask, 0, bm.bmHeight, mask_bits,
-                                    info, DIB_RGB_COLORS, 0, 0))
-            goto failed;
-        ptr = bits;
-        for (i = 0; i < bm.bmHeight; i++)
-        {
-            for (j = 0; j < bm.bmWidth; j++, ptr++)
-            {
-                if (!((mask_bits[i * width_bytes + j / 8] << (j % 8)) & 0x80))
-                    *ptr |= 0xff000000;
-            }
-        }
-        free(mask_bits);
-    }
-
-    /* Wayland requires pre-multiplied alpha values */
-    for (ptr = bits, i = 0; i < bm.bmWidth * bm.bmHeight; ptr++, i++)
-    {
-        unsigned char alpha = *ptr >> 24;
-        if (alpha == 0)
-        {
-            *ptr = 0;
-        }
-        else if (alpha != 255)
-        {
-            *ptr = (alpha << 24) |
-                   (((BYTE)(*ptr >> 16) * alpha / 255) << 16) |
-                   (((BYTE)(*ptr >> 8) * alpha / 255) << 8) |
-                   (((BYTE)*ptr * alpha / 255));
-        }
-    }
-
-    return shm_buffer;
-
-failed:
-    if (shm_buffer) wayland_shm_buffer_unref(shm_buffer);
-    free(mask_bits);
-    return NULL;
-}
-
 /***********************************************************************
  *           get_icon_info
  *
@@ -535,7 +443,7 @@ static void wayland_pointer_update_cursor_buffer(HCURSOR hcursor, double scale)
     {
         HDC hdc = NtGdiCreateCompatibleDC(0);
         cursor->shm_buffer =
-            create_color_cursor_buffer(hdc, info.hbmColor, info.hbmMask);
+            wayland_shm_buffer_from_color_bitmaps(hdc, info.hbmColor, info.hbmMask);
         NtGdiDeleteObjectApp(hdc);
     }
     else
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 2178f5431cb..7b5c5eda335 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -324,6 +324,21 @@ void wayland_surface_clear_role(struct wayland_surface *surface)
         break;
 
     case WAYLAND_SURFACE_ROLE_TOPLEVEL:
+        if (surface->xdg_toplevel_icon)
+        {
+            xdg_toplevel_icon_manager_v1_set_icon(
+                process_wayland.xdg_toplevel_icon_manager_v1,
+                surface->xdg_toplevel, NULL);
+            xdg_toplevel_icon_v1_destroy(surface->xdg_toplevel_icon);
+            if (surface->big_icon_buffer)
+                wayland_shm_buffer_unref(surface->big_icon_buffer);
+            if (surface->small_icon_buffer)
+                wayland_shm_buffer_unref(surface->small_icon_buffer);
+            surface->big_icon_buffer = NULL;
+            surface->small_icon_buffer = NULL;
+            surface->xdg_toplevel_icon = NULL;
+        }
+
         if (surface->xdg_toplevel)
         {
             xdg_toplevel_destroy(surface->xdg_toplevel);
@@ -846,6 +861,98 @@ err:
     return NULL;
 }
 
+/***********************************************************************
+ *           wayland_shm_buffer_from_color_bitmaps
+ *
+ * Create a wayland_shm_buffer for a color bitmap.
+ *
+ * Adapted from wineandroid.drv code.
+ */
+struct wayland_shm_buffer *wayland_shm_buffer_from_color_bitmaps(HDC hdc, HBITMAP color,
+                                                                 HBITMAP mask)
+{
+    struct wayland_shm_buffer *shm_buffer = NULL;
+    char buffer[FIELD_OFFSET(BITMAPINFO, bmiColors[256])];
+    BITMAPINFO *info = (BITMAPINFO *)buffer;
+    BITMAP bm;
+    unsigned int *ptr, *bits = NULL;
+    unsigned char *mask_bits = NULL;
+    int i, j;
+    BOOL has_alpha = FALSE;
+
+    if (!NtGdiExtGetObjectW(color, sizeof(bm), &bm)) goto failed;
+
+    shm_buffer = wayland_shm_buffer_create(bm.bmWidth, bm.bmHeight,
+                                           WL_SHM_FORMAT_ARGB8888);
+    if (!shm_buffer) goto failed;
+    bits = shm_buffer->map_data;
+
+    info->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
+    info->bmiHeader.biWidth = bm.bmWidth;
+    info->bmiHeader.biHeight = -bm.bmHeight;
+    info->bmiHeader.biPlanes = 1;
+    info->bmiHeader.biBitCount = 32;
+    info->bmiHeader.biCompression = BI_RGB;
+    info->bmiHeader.biSizeImage = bm.bmWidth * bm.bmHeight * 4;
+    info->bmiHeader.biXPelsPerMeter = 0;
+    info->bmiHeader.biYPelsPerMeter = 0;
+    info->bmiHeader.biClrUsed = 0;
+    info->bmiHeader.biClrImportant = 0;
+
+    if (!NtGdiGetDIBitsInternal(hdc, color, 0, bm.bmHeight, bits, info,
+                                DIB_RGB_COLORS, 0, 0))
+        goto failed;
+
+    for (i = 0; i < bm.bmWidth * bm.bmHeight; i++)
+        if ((has_alpha = (bits[i] & 0xff000000) != 0)) break;
+
+    if (!has_alpha)
+    {
+        unsigned int width_bytes = (bm.bmWidth + 31) / 32 * 4;
+        /* generate alpha channel from the mask */
+        info->bmiHeader.biBitCount = 1;
+        info->bmiHeader.biSizeImage = width_bytes * bm.bmHeight;
+        if (!(mask_bits = malloc(info->bmiHeader.biSizeImage))) goto failed;
+        if (!NtGdiGetDIBitsInternal(hdc, mask, 0, bm.bmHeight, mask_bits,
+                                    info, DIB_RGB_COLORS, 0, 0))
+            goto failed;
+        ptr = bits;
+        for (i = 0; i < bm.bmHeight; i++)
+        {
+            for (j = 0; j < bm.bmWidth; j++, ptr++)
+            {
+                if (!((mask_bits[i * width_bytes + j / 8] << (j % 8)) & 0x80))
+                    *ptr |= 0xff000000;
+            }
+        }
+        free(mask_bits);
+    }
+
+    /* Wayland requires pre-multiplied alpha values */
+    for (ptr = bits, i = 0; i < bm.bmWidth * bm.bmHeight; ptr++, i++)
+    {
+        unsigned char alpha = *ptr >> 24;
+        if (alpha == 0)
+        {
+            *ptr = 0;
+        }
+        else if (alpha != 255)
+        {
+            *ptr = (alpha << 24) |
+                   (((BYTE)(*ptr >> 16) * alpha / 255) << 16) |
+                   (((BYTE)(*ptr >> 8) * alpha / 255) << 8) |
+                   (((BYTE)*ptr * alpha / 255));
+        }
+    }
+
+    return shm_buffer;
+
+failed:
+    if (shm_buffer) wayland_shm_buffer_unref(shm_buffer);
+    free(mask_bits);
+    return NULL;
+}
+
 /**********************************************************************
  *          wayland_surface_coords_from_window
  *
@@ -1076,3 +1183,63 @@ void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR text)
 
     free(utf8);
 }
+
+/**********************************************************************
+ *          wayland_surface_set_icon
+ */
+void wayland_surface_set_icon(struct wayland_surface *surface, UINT type, ICONINFO *ii)
+{
+    HDC hDC;
+    struct wayland_shm_buffer *icon_buf;
+
+    assert(ii);
+    assert(surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL && surface->xdg_toplevel);
+
+    hDC = NtGdiCreateCompatibleDC(0);
+    icon_buf = wayland_shm_buffer_from_color_bitmaps(hDC, ii->hbmColor, ii->hbmMask);
+    NtGdiDeleteObjectApp(hDC);
+
+    if (surface->xdg_toplevel_icon)
+    {
+        xdg_toplevel_icon_manager_v1_set_icon(process_wayland.xdg_toplevel_icon_manager_v1,
+                                              surface->xdg_toplevel, NULL);
+        xdg_toplevel_icon_v1_destroy(surface->xdg_toplevel_icon);
+        if (surface->big_icon_buffer && type == ICON_BIG)
+        {
+            wayland_shm_buffer_unref(surface->big_icon_buffer);
+            surface->big_icon_buffer = NULL;
+        }
+        else if (surface->small_icon_buffer && type != ICON_BIG)
+        {
+            wayland_shm_buffer_unref(surface->small_icon_buffer);
+            surface->small_icon_buffer = NULL;
+        }
+        surface->xdg_toplevel_icon = NULL;
+    }
+
+    if (icon_buf)
+    {
+        surface->xdg_toplevel_icon =
+            xdg_toplevel_icon_manager_v1_create_icon(process_wayland.xdg_toplevel_icon_manager_v1);
+
+        if (type == ICON_BIG) surface->big_icon_buffer = icon_buf;
+        else surface->small_icon_buffer = icon_buf;
+
+        /* FIXME: what to do with scale ? */
+        if (surface->big_icon_buffer)
+        {
+            xdg_toplevel_icon_v1_add_buffer(surface->xdg_toplevel_icon,
+                                            surface->big_icon_buffer->wl_buffer, 1);
+        }
+        if (surface->small_icon_buffer)
+        {
+            xdg_toplevel_icon_v1_add_buffer(surface->xdg_toplevel_icon,
+                                            surface->small_icon_buffer->wl_buffer, 1);
+        }
+
+        xdg_toplevel_icon_v1_set_name(surface->xdg_toplevel_icon, "");
+
+        xdg_toplevel_icon_manager_v1_set_icon(process_wayland.xdg_toplevel_icon_manager_v1,
+                                              surface->xdg_toplevel, surface->xdg_toplevel_icon);
+    }
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 065d4d31873..1ccadcb7647 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -36,6 +36,7 @@
 #include "xdg-output-unstable-v1-client-protocol.h"
 #include "xdg-shell-client-protocol.h"
 #include "wlr-data-control-unstable-v1-client-protocol.h"
+#include "xdg-toplevel-icon-v1-client-protocol.h"
 
 #include "windef.h"
 #include "winbase.h"
@@ -168,6 +169,7 @@ struct wayland
     struct zwp_text_input_manager_v3 *zwp_text_input_manager_v3;
     struct zwlr_data_control_manager_v1 *zwlr_data_control_manager_v1;
     struct wl_data_device_manager *wl_data_device_manager;
+    struct xdg_toplevel_icon_manager_v1 *xdg_toplevel_icon_manager_v1;
     struct wayland_seat seat;
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
@@ -237,6 +239,18 @@ struct wayland_client_surface
     struct wp_viewport *wp_viewport;
 };
 
+struct wayland_shm_buffer
+{
+    struct wl_list link;
+    struct wl_buffer *wl_buffer;
+    int width, height;
+    void *map_data;
+    size_t map_size;
+    BOOL busy;
+    LONG ref;
+    HRGN damage_region;
+};
+
 struct wayland_surface
 {
     HWND hwnd;
@@ -251,6 +265,9 @@ struct wayland_surface
         {
             struct xdg_surface *xdg_surface;
             struct xdg_toplevel *xdg_toplevel;
+            struct xdg_toplevel_icon_v1 *xdg_toplevel_icon;
+            struct wayland_shm_buffer *small_icon_buffer;
+            struct wayland_shm_buffer *big_icon_buffer;
         };
         struct
         {
@@ -266,18 +283,6 @@ struct wayland_surface
     HCURSOR hcursor;
 };
 
-struct wayland_shm_buffer
-{
-    struct wl_list link;
-    struct wl_buffer *wl_buffer;
-    int width, height;
-    void *map_data;
-    size_t map_size;
-    BOOL busy;
-    LONG ref;
-    HRGN damage_region;
-};
-
 /**********************************************************************
  *          Wayland initialization
  */
@@ -321,6 +326,7 @@ void wayland_client_surface_attach(struct wayland_client_surface *client, HWND t
 void wayland_client_surface_detach(struct wayland_client_surface *client);
 void wayland_surface_ensure_contents(struct wayland_surface *surface);
 void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR title);
+void wayland_surface_set_icon(struct wayland_surface *surface, UINT type, ICONINFO *ii);
 
 /**********************************************************************
  *          Wayland SHM buffer
@@ -328,6 +334,8 @@ void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR title);
 
 struct wayland_shm_buffer *wayland_shm_buffer_create(int width, int height,
                                                      enum wl_shm_format format);
+struct wayland_shm_buffer *wayland_shm_buffer_from_color_bitmaps(HDC hdc, HBITMAP color,
+                                                                 HBITMAP mask);
 void wayland_shm_buffer_ref(struct wayland_shm_buffer *shm_buffer);
 void wayland_shm_buffer_unref(struct wayland_shm_buffer *shm_buffer);
 
@@ -430,6 +438,7 @@ void WAYLAND_DestroyWindow(HWND hwnd);
 BOOL WAYLAND_SetIMECompositionRect(HWND hwnd, RECT rect);
 void WAYLAND_SetCursor(HWND hwnd, HCURSOR hcursor);
 BOOL WAYLAND_SetCursorPos(INT x, INT y);
+void WAYLAND_SetWindowIcon(HWND hwnd, UINT type, HICON icon);
 void WAYLAND_SetWindowText(HWND hwnd, LPCWSTR text);
 LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam, const POINT *pos);
 UINT WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager, void *param);
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index dba519b1df1..5486cc934ef 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -44,6 +44,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pReleaseKbdTables = WAYLAND_ReleaseKbdTables,
     .pSetCursor = WAYLAND_SetCursor,
     .pSetCursorPos = WAYLAND_SetCursorPos,
+    .pSetWindowIcon = WAYLAND_SetWindowIcon,
     .pSetWindowText = WAYLAND_SetWindowText,
     .pSysCommand = WAYLAND_SysCommand,
     .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index e80bebdc042..184d09c2ed4 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -422,6 +422,28 @@ BOOL WAYLAND_WindowPosChanging(HWND hwnd, UINT swp_flags, BOOL shaped, const str
     return TRUE;
 }
 
+static HICON get_icon_info(HICON icon, ICONINFO *ii)
+{
+    return icon && NtUserGetIconInfo(icon, ii, NULL, NULL, NULL, 0) ? icon : NULL;
+}
+
+static HICON get_window_icon(HWND hwnd, UINT type, HICON icon, ICONINFO *ret)
+{
+    icon = get_icon_info(icon, ret);
+    if (!icon)
+    {
+        icon = get_icon_info((HICON)send_message(hwnd, WM_GETICON, type, 0), ret);
+        if (!icon)
+            icon = get_icon_info((HICON)NtUserGetClassLongPtrW(hwnd, GCLP_HICON), ret);
+        if (!icon && type == ICON_BIG)
+        {
+            icon = LoadImageW(0, (const WCHAR *)IDI_WINLOGO, IMAGE_ICON, 0, 0,
+                              LR_SHARED | LR_DEFAULTSIZE);
+            icon = get_icon_info(icon, ret);
+        }
+    }
+    return icon;
+}
 
 /***********************************************************************
  *           WAYLAND_WindowPosChanged
@@ -433,7 +455,7 @@ void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, HWND owner_hint, UIN
     struct wayland_surface *toplevel_surface;
     struct wayland_client_surface *client;
     struct wayland_win_data *data, *toplevel_data;
-    BOOL managed;
+    BOOL managed, needs_icon;
 
     TRACE("hwnd %p new_rects %s after %p flags %08x\n", hwnd, debugstr_window_rects(new_rects), insert_after, swp_flags);
 
@@ -471,7 +493,28 @@ void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, HWND owner_hint, UIN
         wayland_win_data_update_wayland_state(data);
     }
 
+    needs_icon = data->wayland_surface && !data->wayland_surface->big_icon_buffer &&
+                 data->wayland_surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
+                 data->wayland_surface->xdg_toplevel &&
+                 process_wayland.xdg_toplevel_icon_manager_v1;
+
     wayland_win_data_release(data);
+
+    if (needs_icon)
+    {
+        HICON big, small;
+        ICONINFO ii, ii_small;
+        big = get_window_icon(hwnd, ICON_BIG, 0, &ii);
+        small = get_window_icon(hwnd, ICON_SMALL, 0, &ii_small);
+
+        if((data = wayland_win_data_get(hwnd)))
+        {
+            if (big) wayland_surface_set_icon(data->wayland_surface, ICON_BIG, &ii);
+            if (small) wayland_surface_set_icon(data->wayland_surface, ICON_SMALL, &ii_small);
+
+            wayland_win_data_release(data);
+        }
+    }
 }
 
 static void wayland_configure_window(HWND hwnd)
@@ -642,6 +685,30 @@ static enum xdg_toplevel_resize_edge hittest_to_resize_edge(WPARAM hittest)
     }
 }
 
+/*****************************************************************
+ *		WAYLAND_SetWindowIcon
+ */
+void WAYLAND_SetWindowIcon(HWND hwnd, UINT type, HICON icon)
+{
+    struct wayland_win_data *data;
+    ICONINFO ii;
+
+    TRACE("hwnd=%p type=%u icon=%p\n", hwnd, type, icon);
+
+    if (process_wayland.xdg_toplevel_icon_manager_v1)
+    {
+        icon = get_window_icon(hwnd, type, icon, &ii);
+        if (icon && (data = wayland_win_data_get(hwnd)))
+        {
+            if (data->wayland_surface &&
+                data->wayland_surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
+                data->wayland_surface->xdg_toplevel)
+                wayland_surface_set_icon(data->wayland_surface, type, &ii);
+            wayland_win_data_release(data);
+        }
+    }
+}
+
 /*****************************************************************
  *		WAYLAND_SetWindowText
  */
diff --git a/dlls/winewayland.drv/xdg-toplevel-icon-v1.xml b/dlls/winewayland.drv/xdg-toplevel-icon-v1.xml
new file mode 100644
index 00000000000..fc409fef7c6
--- /dev/null
+++ b/dlls/winewayland.drv/xdg-toplevel-icon-v1.xml
@@ -0,0 +1,205 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="xdg_toplevel_icon_v1">
+
+  <copyright>
+    Copyright © 2023-2024 Matthias Klumpp
+    Copyright ©      2024 David Edmundson
+
+    Permission is hereby granted, free of charge, to any person obtaining a
+    copy of this software and associated documentation files (the "Software"),
+    to deal in the Software without restriction, including without limitation
+    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+    and/or sell copies of the Software, and to permit persons to whom the
+    Software is furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice (including the next
+    paragraph) shall be included in all copies or substantial portions of the
+    Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+    DEALINGS IN THE SOFTWARE.
+  </copyright>
+
+  <description summary="protocol to assign icons to toplevels">
+    This protocol allows clients to set icons for their toplevel surfaces
+    either via the XDG icon stock (using an icon name), or from pixel data.
+
+    A toplevel icon represents the individual toplevel (unlike the application
+    or launcher icon, which represents the application as a whole), and may be
+    shown in window switchers, window overviews and taskbars that list
+    individual windows.
+
+    This document adheres to RFC 2119 when using words like "must",
+    "should", "may", etc.
+
+    Warning! The protocol described in this file is currently in the testing
+    phase. Backward compatible changes may be added together with the
+    corresponding interface version bump. Backward incompatible changes can
+    only be done by creating a new major version of the extension.
+  </description>
+
+  <interface name="xdg_toplevel_icon_manager_v1" version="1">
+    <description summary="interface to manage toplevel icons">
+      This interface allows clients to create toplevel window icons and set
+      them on toplevel windows to be displayed to the user.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the toplevel icon manager">
+        Destroy the toplevel icon manager.
+        This does not destroy objects created with the manager.
+      </description>
+    </request>
+
+    <request name="create_icon">
+      <description summary="create a new icon instance">
+        Creates a new icon object. This icon can then be attached to a
+        xdg_toplevel via the 'set_icon' request.
+      </description>
+      <arg name="id" type="new_id" interface="xdg_toplevel_icon_v1"/>
+    </request>
+
+    <request name="set_icon">
+      <description summary="set an icon on a toplevel window">
+        This request assigns the icon 'icon' to 'toplevel', or clears the
+        toplevel icon if 'icon' was null.
+        This state is double-buffered and is applied on the next
+        wl_surface.commit of the toplevel.
+
+        After making this call, the xdg_toplevel_icon_v1 provided as 'icon'
+        can be destroyed by the client without 'toplevel' losing its icon.
+        The xdg_toplevel_icon_v1 is immutable from this point, and any
+        future attempts to change it must raise the
+        'xdg_toplevel_icon_v1.immutable' protocol error.
+
+        The compositor must set the toplevel icon from either the pixel data
+        the icon provides, or by loading a stock icon using the icon name.
+        See the description of 'xdg_toplevel_icon_v1' for details.
+
+        If 'icon' is set to null, the icon of the respective toplevel is reset
+        to its default icon (usually the icon of the application, derived from
+        its desktop-entry file, or a placeholder icon).
+        If this request is passed an icon with no pixel buffers or icon name
+        assigned, the icon must be reset just like if 'icon' was null.
+      </description>
+      <arg name="toplevel" type="object" interface="xdg_toplevel" summary="the toplevel to act on"/>
+      <arg name="icon" type="object" interface="xdg_toplevel_icon_v1" allow-null="true"/>
+    </request>
+
+    <event name="icon_size">
+      <description summary="describes a supported &amp; preferred icon size">
+        This event indicates an icon size the compositor prefers to be
+        available if the client has scalable icons and can render to any size.
+
+        When the 'xdg_toplevel_icon_manager_v1' object is created, the
+        compositor may send one or more 'icon_size' events to describe the list
+        of preferred icon sizes. If the compositor has no size preference, it
+        may not send any 'icon_size' event, and it is up to the client to
+        decide a suitable icon size.
+
+        A sequence of 'icon_size' events must be finished with a 'done' event.
+        If the compositor has no size preferences, it must still send the
+        'done' event, without any preceding 'icon_size' events.
+      </description>
+      <arg name="size" type="int"
+	   summary="the edge size of the square icon in surface-local coordinates, e.g. 64"/>
+    </event>
+
+    <event name="done">
+      <description summary="all information has been sent">
+        This event is sent after all 'icon_size' events have been sent.
+      </description>
+    </event>
+  </interface>
+
+  <interface name="xdg_toplevel_icon_v1" version="1">
+    <description summary="a toplevel window icon">
+      This interface defines a toplevel icon.
+      An icon can have a name, and multiple buffers.
+      In order to be applied, the icon must have either a name, or at least
+      one buffer assigned. Applying an empty icon (with no buffer or name) to
+      a toplevel should reset its icon to the default icon.
+
+      It is up to compositor policy whether to prefer using a buffer or loading
+      an icon via its name. See 'set_name' and 'add_buffer' for details.
+    </description>
+
+    <enum name="error">
+      <entry name="invalid_buffer"
+             summary="the provided buffer does not satisfy requirements"
+	     value="1"/>
+      <entry name="immutable"
+             summary="the icon has already been assigned to a toplevel and must not be changed"
+	     value="2"/>
+      <entry name="no_buffer"
+             summary="the provided buffer has been destroyed before the toplevel icon"
+             value="3"/>
+    </enum>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the icon object">
+        Destroys the 'xdg_toplevel_icon_v1' object.
+        The icon must still remain set on every toplevel it was assigned to,
+        until the toplevel icon is reset explicitly.
+      </description>
+    </request>
+
+    <request name="set_name">
+      <description summary="set an icon name">
+        This request assigns an icon name to this icon.
+        Any previously set name is overridden.
+
+        The compositor must resolve 'icon_name' according to the lookup rules
+        described in the XDG icon theme specification[1] using the
+        environment's current icon theme.
+
+        If the compositor does not support icon names or cannot resolve
+        'icon_name' according to the XDG icon theme specification it must
+        fall back to using pixel buffer data instead.
+
+        If this request is made after the icon has been assigned to a toplevel
+        via 'set_icon', a 'immutable' error must be raised.
+
+        [1]: https://specifications.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html
+      </description>
+      <arg name="icon_name" type="string"/>
+    </request>
+
+    <request name="add_buffer">
+      <description summary="add icon data from a pixel buffer">
+        This request adds pixel data supplied as wl_buffer to the icon.
+
+        The client should add pixel data for all icon sizes and scales that
+        it can provide, or which are explicitly requested by the compositor
+        via 'icon_size' events on xdg_toplevel_icon_manager_v1.
+
+        The wl_buffer supplying pixel data as 'buffer' must be backed by wl_shm
+        and must be a square (width and height being equal).
+        If any of these buffer requirements are not fulfilled, a 'invalid_buffer'
+        error must be raised.
+
+        If this icon instance already has a buffer of the same size and scale
+        from a previous 'add_buffer' request, data from the last request
+        overrides the preexisting pixel data.
+
+        The wl_buffer must be kept alive for as long as the xdg_toplevel_icon
+        it is associated with is not destroyed, otherwise a 'no_buffer' error
+        is raised. The buffer contents must not be modified after it was
+        assigned to the icon. As a result, the region of the wl_shm_pool's
+        backing storage used for the wl_buffer must not be modified after this
+        request is sent. The wl_buffer.release event is unused.
+
+        If this request is made after the icon has been assigned to a toplevel
+        via 'set_icon', a 'immutable' error must be raised.
+      </description>
+      <arg name="buffer" type="object" interface="wl_buffer"/>
+      <arg name="scale" type="int"
+	   summary="the scaling factor of the icon, e.g. 1"/>
+    </request>
+  </interface>
+</protocol>
-- 
2.49.0

From cdb2d8345222d179e72b76d553c47604fbe7e6f3 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty <etaash.mathamsetty@gmail.com>
Date: Sun, 13 Apr 2025 21:21:17 -0400
Subject: [PATCH 024/159] winewayland: Implement relative motion accumulator.

---
 dlls/winewayland.drv/wayland_pointer.c | 43 ++++++++++++++++++++------
 dlls/winewayland.drv/waylanddrv.h      |  2 ++
 2 files changed, 35 insertions(+), 10 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 6c852292c1d..b2af6c0db4a 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -257,6 +257,19 @@ static const struct wl_pointer_listener pointer_listener =
     pointer_handle_axis_discrete
 };
 
+/**********************************************************************
+ *          wayland_motion_delta_to_window
+ *
+ * Converts the surface-local delta to window (logical) coordinate delta.
+ */
+static void wayland_motion_delta_to_window(struct wayland_surface *surface,
+                                           double surface_x, double surface_y,
+                                           double *window_x, double *window_y)
+{
+    *window_x = surface_x * surface->window.scale;
+    *window_y = surface_y * surface->window.scale;
+}
+
 static void relative_pointer_v1_relative_motion(void *private,
                                                 struct zwp_relative_pointer_v1 *zwp_relative_pointer_v1,
                                                 uint32_t utime_hi, uint32_t utime_lo,
@@ -265,28 +278,37 @@ static void relative_pointer_v1_relative_motion(void *private,
 {
     INPUT input = {0};
     HWND hwnd;
-    POINT screen;
     struct wayland_win_data *data;
+    double screen_x = 0.0, screen_y = 0.0;
+    struct wayland_pointer *pointer = &process_wayland.pointer;
 
     if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
     if (!(data = wayland_win_data_get(hwnd))) return;
 
-    wayland_surface_coords_to_window(data->wayland_surface,
-                                     wl_fixed_to_double(dx),
-                                     wl_fixed_to_double(dy),
-                                     (int *)&screen.x, (int *)&screen.y);
-
+    wayland_motion_delta_to_window(data->wayland_surface,
+                                   wl_fixed_to_double(dx),
+                                   wl_fixed_to_double(dy),
+                                   &screen_x, &screen_y);
     wayland_win_data_release(data);
 
+    pthread_mutex_lock(&pointer->mutex);
+
+    pointer->accum_x += screen_x;
+    pointer->accum_y += screen_y;
 
     input.type = INPUT_MOUSE;
-    input.mi.dx = screen.x;
-    input.mi.dy = screen.y;
+    input.mi.dx = round(pointer->accum_x);
+    input.mi.dy = round(pointer->accum_y);
     input.mi.dwFlags = MOUSEEVENTF_MOVE;
 
-    TRACE("hwnd=%p wayland_dxdy=%.2f,%.2f screen_dxdy=%d,%d\n",
+    pointer->accum_x -= input.mi.dx;
+    pointer->accum_y -= input.mi.dy;
+
+    pthread_mutex_unlock(&pointer->mutex);
+
+    TRACE("hwnd=%p wayland_dxdy=%.2f,%.2f accum_dxdy=%d,%d\n",
           hwnd, wl_fixed_to_double(dx), wl_fixed_to_double(dy),
-          (int)screen.x, (int)screen.y);
+          (int)input.mi.dx, (int)input.mi.dy);
 
     NtUserSendHardwareInput(hwnd, 0, &input, 0);
 }
@@ -778,6 +800,7 @@ static void wayland_pointer_update_constraint(struct wl_surface *wl_surface,
 
     if (needs_relative && !pointer->zwp_relative_pointer_v1)
     {
+        pointer->accum_x = pointer->accum_y = 0;
         pointer->zwp_relative_pointer_v1 =
             zwp_relative_pointer_manager_v1_get_relative_pointer(
                 process_wayland.zwp_relative_pointer_manager_v1,
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 1ccadcb7647..3c42272ccde 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -112,6 +112,8 @@ struct wayland_pointer
     uint32_t enter_serial;
     uint32_t button_serial;
     struct wayland_cursor cursor;
+    double accum_x;
+    double accum_y;
     pthread_mutex_t mutex;
 };
 
-- 
2.49.0

From 3c0b7a001b88bd3627ebf38e4370f61c8233d0c9 Mon Sep 17 00:00:00 2001
From: Attila Fidan <dev@print0.net>
Date: Sun, 20 Apr 2025 11:30:03 +0000
Subject: [PATCH 025/159] winewayland: Require wl_pointer for pointer
 constraints.

If ClipCursor is called while the seat doesn't have a pointer and the
call qualifies for locking the pointer, it would have tried to lock a
null wl_pointer.
---
 dlls/winewayland.drv/wayland_pointer.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index b2af6c0db4a..257735dc909 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -710,9 +710,10 @@ static void wayland_pointer_update_constraint(struct wl_surface *wl_surface,
     }
 
     needs_lock = wl_surface && (((confine_rect || covers_vscreen) &&
-                 !pointer->cursor.wl_surface) || force_lock);
+                 !pointer->cursor.wl_surface) || force_lock) &&
+                 pointer->wl_pointer;
     needs_confine = wl_surface && confine_rect && pointer->cursor.wl_surface &&
-                 !force_lock;
+                 !force_lock && pointer->wl_pointer;
 
     if (!needs_confine && pointer->zwp_confined_pointer_v1)
     {
-- 
2.49.0

From f8062ec353a6309aaa083bad69470e660d2c41ea Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Mon, 5 May 2025 22:08:25 -0400
Subject: [PATCH 026/159] support older EGL headers

---
 dlls/winewayland.drv/opengl.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index d9a83d49b3e..36989b9c745 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -43,6 +43,12 @@ WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 #include "wine/wgl.h"
 #include "wine/wgl_driver.h"
 
+/* Support building on systems with older EGL headers,
+    which may not include the EGL_EXT_present_opaque extension. */
+#ifndef EGL_PRESENT_OPAQUE_EXT
+#define EGL_PRESENT_OPAQUE_EXT 0x31DF
+#endif
+
 static void *egl_handle;
 static struct opengl_funcs opengl_funcs;
 static EGLDisplay egl_display;
-- 
2.49.0

From f5f1c209e07d58207834bd76d599e7d4ef560c04 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 24 Apr 2025 15:28:18 +0300
Subject: [PATCH 027/159] winewayland: Always check the role to determine
 whether a surface is a toplevel.

Since the role objects in the wayland_surface struct are part of a union, we
first need to check whether the surface has the right role before checking
the role objects themselves. Otherwise we risk using a subsurface as a toplevel
or vice-versa.
---
 dlls/winewayland.drv/wayland_surface.c | 10 +++++++---
 dlls/winewayland.drv/window.c          | 10 +++++++---
 2 files changed, 14 insertions(+), 6 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 7b5c5eda335..b7121d5ed96 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -48,7 +48,9 @@ static void xdg_surface_handle_configure(void *private, struct xdg_surface *xdg_
 
     /* Handle this event only if wayland_surface is still associated with
      * the target xdg_surface. */
-    if ((surface = data->wayland_surface) && surface->xdg_surface == xdg_surface)
+    if ((surface = data->wayland_surface) &&
+        surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
+        surface->xdg_surface == xdg_surface)
     {
         /* If we have a previously requested config, we have already sent a
          * WM_WAYLAND_CONFIGURE which hasn't been handled yet. In that case,
@@ -116,7 +118,9 @@ static void xdg_toplevel_handle_configure(void *private,
 
     if (!(data = wayland_win_data_get(hwnd))) return;
 
-    if ((surface = data->wayland_surface) && surface->xdg_toplevel == xdg_toplevel)
+    if ((surface = data->wayland_surface) &&
+        surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
+        surface->xdg_toplevel == xdg_toplevel)
     {
         surface->pending.width = width;
         surface->pending.height = height;
@@ -1167,7 +1171,7 @@ void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR text)
     DWORD utf8_count;
     char *utf8 = NULL;
 
-    assert(surface->xdg_toplevel);
+    assert(surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL && surface->xdg_toplevel);
 
     TRACE("surface=%p hwnd=%p text='%s'\n",
           surface, surface->hwnd, wine_dbgstr_w(text));
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 184d09c2ed4..03dff29a4cc 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -537,7 +537,7 @@ static void wayland_configure_window(HWND hwnd)
         return;
     }
 
-    if (!surface->xdg_toplevel)
+    if (surface->role != WAYLAND_SURFACE_ROLE_TOPLEVEL || !surface->xdg_toplevel)
     {
         TRACE("missing xdg_toplevel, returning\n");
         wayland_win_data_release(data);
@@ -721,7 +721,9 @@ void WAYLAND_SetWindowText(HWND hwnd, LPCWSTR text)
 
     if ((data = wayland_win_data_get(hwnd)))
     {
-        if ((surface = data->wayland_surface) && surface->xdg_toplevel)
+        if ((surface = data->wayland_surface) &&
+            surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
+            surface->xdg_toplevel)
             wayland_surface_set_title(surface, text);
         wayland_win_data_release(data);
     }
@@ -755,7 +757,9 @@ LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam, const POINT
         {
             pthread_mutex_lock(&process_wayland.seat.mutex);
             wl_seat = process_wayland.seat.wl_seat;
-            if (wl_seat && (surface = data->wayland_surface) && surface->xdg_toplevel && button_serial)
+            if (wl_seat && (surface = data->wayland_surface) &&
+                surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
+                surface->xdg_toplevel && button_serial)
             {
                 if (command == SC_MOVE)
                 {
-- 
2.49.0

From 0d265e4a6b3b4f062df82d461eec728f5af5f208 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 24 Apr 2025 15:46:33 +0300
Subject: [PATCH 028/159] winewayland: Introduce helper to check whether a
 surface is toplevel.

---
 dlls/winewayland.drv/wayland_surface.c | 11 ++++-------
 dlls/winewayland.drv/waylanddrv.h      |  5 +++++
 dlls/winewayland.drv/window.c          | 16 +++++-----------
 3 files changed, 14 insertions(+), 18 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index b7121d5ed96..4daf56d10b3 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -48,8 +48,7 @@ static void xdg_surface_handle_configure(void *private, struct xdg_surface *xdg_
 
     /* Handle this event only if wayland_surface is still associated with
      * the target xdg_surface. */
-    if ((surface = data->wayland_surface) &&
-        surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
+    if ((surface = data->wayland_surface) && wayland_surface_is_toplevel(surface) &&
         surface->xdg_surface == xdg_surface)
     {
         /* If we have a previously requested config, we have already sent a
@@ -118,9 +117,7 @@ static void xdg_toplevel_handle_configure(void *private,
 
     if (!(data = wayland_win_data_get(hwnd))) return;
 
-    if ((surface = data->wayland_surface) &&
-        surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
-        surface->xdg_toplevel == xdg_toplevel)
+    if ((surface = data->wayland_surface) && wayland_surface_is_toplevel(surface))
     {
         surface->pending.width = width;
         surface->pending.height = height;
@@ -1171,7 +1168,7 @@ void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR text)
     DWORD utf8_count;
     char *utf8 = NULL;
 
-    assert(surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL && surface->xdg_toplevel);
+    assert(wayland_surface_is_toplevel(surface));
 
     TRACE("surface=%p hwnd=%p text='%s'\n",
           surface, surface->hwnd, wine_dbgstr_w(text));
@@ -1197,7 +1194,7 @@ void wayland_surface_set_icon(struct wayland_surface *surface, UINT type, ICONIN
     struct wayland_shm_buffer *icon_buf;
 
     assert(ii);
-    assert(surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL && surface->xdg_toplevel);
+    assert(wayland_surface_is_toplevel(surface));
 
     hDC = NtGdiCreateCompatibleDC(0);
     icon_buf = wayland_shm_buffer_from_color_bitmaps(hDC, ii->hbmColor, ii->hbmMask);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 3c42272ccde..b3d3016174a 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -330,6 +330,11 @@ void wayland_surface_ensure_contents(struct wayland_surface *surface);
 void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR title);
 void wayland_surface_set_icon(struct wayland_surface *surface, UINT type, ICONINFO *ii);
 
+static inline BOOL wayland_surface_is_toplevel(struct wayland_surface *surface)
+{
+    return surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL && surface->xdg_toplevel;
+}
+
 /**********************************************************************
  *          Wayland SHM buffer
  */
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 03dff29a4cc..acc34a18218 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -494,8 +494,7 @@ void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, HWND owner_hint, UIN
     }
 
     needs_icon = data->wayland_surface && !data->wayland_surface->big_icon_buffer &&
-                 data->wayland_surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
-                 data->wayland_surface->xdg_toplevel &&
+                 wayland_surface_is_toplevel(data->wayland_surface) &&
                  process_wayland.xdg_toplevel_icon_manager_v1;
 
     wayland_win_data_release(data);
@@ -537,7 +536,7 @@ static void wayland_configure_window(HWND hwnd)
         return;
     }
 
-    if (surface->role != WAYLAND_SURFACE_ROLE_TOPLEVEL || !surface->xdg_toplevel)
+    if (!wayland_surface_is_toplevel(surface))
     {
         TRACE("missing xdg_toplevel, returning\n");
         wayland_win_data_release(data);
@@ -700,9 +699,7 @@ void WAYLAND_SetWindowIcon(HWND hwnd, UINT type, HICON icon)
         icon = get_window_icon(hwnd, type, icon, &ii);
         if (icon && (data = wayland_win_data_get(hwnd)))
         {
-            if (data->wayland_surface &&
-                data->wayland_surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
-                data->wayland_surface->xdg_toplevel)
+            if (data->wayland_surface && wayland_surface_is_toplevel(data->wayland_surface))
                 wayland_surface_set_icon(data->wayland_surface, type, &ii);
             wayland_win_data_release(data);
         }
@@ -721,9 +718,7 @@ void WAYLAND_SetWindowText(HWND hwnd, LPCWSTR text)
 
     if ((data = wayland_win_data_get(hwnd)))
     {
-        if ((surface = data->wayland_surface) &&
-            surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
-            surface->xdg_toplevel)
+        if ((surface = data->wayland_surface) && wayland_surface_is_toplevel(surface))
             wayland_surface_set_title(surface, text);
         wayland_win_data_release(data);
     }
@@ -758,8 +753,7 @@ LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam, const POINT
             pthread_mutex_lock(&process_wayland.seat.mutex);
             wl_seat = process_wayland.seat.wl_seat;
             if (wl_seat && (surface = data->wayland_surface) &&
-                surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
-                surface->xdg_toplevel && button_serial)
+                wayland_surface_is_toplevel(surface) && button_serial)
             {
                 if (command == SC_MOVE)
                 {
-- 
2.49.0

From e9ddd6b14690b45b9192c9dc08c0b0693db3728a Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Tue, 6 May 2025 09:06:03 -0400
Subject: [PATCH 029/159] hack: winewayland: handle fractional scaling

---
 dlls/winewayland.drv/Makefile.in             |   1 +
 dlls/winewayland.drv/fractional-scale-v1.xml | 102 +++++++++++++++++++
 dlls/winewayland.drv/wayland.c               |   8 ++
 dlls/winewayland.drv/wayland_surface.c       |  39 +++++++
 dlls/winewayland.drv/waylanddrv.h            |   5 +
 dlls/winewayland.drv/window.c                |   2 +-
 6 files changed, 156 insertions(+), 1 deletion(-)
 create mode 100644 dlls/winewayland.drv/fractional-scale-v1.xml

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index e7b1bfb90eb..f141c22ee36 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -7,6 +7,7 @@ IMPORTS = user32 win32u
 SOURCES = \
 	display.c \
 	dllmain.c \
+	fractional-scale-v1.xml \
 	opengl.c \
 	pointer-constraints-unstable-v1.xml \
 	relative-pointer-unstable-v1.xml \
diff --git a/dlls/winewayland.drv/fractional-scale-v1.xml b/dlls/winewayland.drv/fractional-scale-v1.xml
new file mode 100644
index 00000000000..350bfc01eaf
--- /dev/null
+++ b/dlls/winewayland.drv/fractional-scale-v1.xml
@@ -0,0 +1,102 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="fractional_scale_v1">
+  <copyright>
+    Copyright © 2022 Kenny Levinsen
+
+    Permission is hereby granted, free of charge, to any person obtaining a
+    copy of this software and associated documentation files (the "Software"),
+    to deal in the Software without restriction, including without limitation
+    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+    and/or sell copies of the Software, and to permit persons to whom the
+    Software is furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice (including the next
+    paragraph) shall be included in all copies or substantial portions of the
+    Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+    DEALINGS IN THE SOFTWARE.
+  </copyright>
+
+  <description summary="Protocol for requesting fractional surface scales">
+    This protocol allows a compositor to suggest for surfaces to render at
+    fractional scales.
+
+    A client can submit scaled content by utilizing wp_viewport. This is done by
+    creating a wp_viewport object for the surface and setting the destination
+    rectangle to the surface size before the scale factor is applied.
+
+    The buffer size is calculated by multiplying the surface size by the
+    intended scale.
+
+    The wl_surface buffer scale should remain set to 1.
+
+    If a surface has a surface-local size of 100 px by 50 px and wishes to
+    submit buffers with a scale of 1.5, then a buffer of 150px by 75 px should
+    be used and the wp_viewport destination rectangle should be 100 px by 50 px.
+
+    For toplevel surfaces, the size is rounded halfway away from zero. The
+    rounding algorithm for subsurface position and size is not defined.
+  </description>
+
+  <interface name="wp_fractional_scale_manager_v1" version="1">
+    <description summary="fractional surface scale information">
+      A global interface for requesting surfaces to use fractional scales.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="unbind the fractional surface scale interface">
+        Informs the server that the client will not be using this protocol
+        object anymore. This does not affect any other objects,
+        wp_fractional_scale_v1 objects included.
+      </description>
+    </request>
+
+    <enum name="error">
+      <entry name="fractional_scale_exists" value="0"
+        summary="the surface already has a fractional_scale object associated"/>
+    </enum>
+
+    <request name="get_fractional_scale">
+      <description summary="extend surface interface for scale information">
+        Create an add-on object for the the wl_surface to let the compositor
+        request fractional scales. If the given wl_surface already has a
+        wp_fractional_scale_v1 object associated, the fractional_scale_exists
+        protocol error is raised.
+      </description>
+      <arg name="id" type="new_id" interface="wp_fractional_scale_v1"
+           summary="the new surface scale info interface id"/>
+      <arg name="surface" type="object" interface="wl_surface"
+           summary="the surface"/>
+    </request>
+  </interface>
+
+  <interface name="wp_fractional_scale_v1" version="1">
+    <description summary="fractional scale interface to a wl_surface">
+      An additional interface to a wl_surface object which allows the compositor
+      to inform the client of the preferred scale.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="remove surface scale information for surface">
+        Destroy the fractional scale object. When this object is destroyed,
+        preferred_scale events will no longer be sent.
+      </description>
+    </request>
+
+    <event name="preferred_scale">
+      <description summary="notify of new preferred scale">
+        Notification of a new preferred scale for this surface that the
+        compositor suggests that the client should use.
+
+        The sent scale is the numerator of a fraction with a denominator of 120.
+      </description>
+      <arg name="scale" type="uint" summary="the new preferred scale"/>
+    </event>
+  </interface>
+</protocol>
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index ba09d32ed89..08cbb8c6979 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -194,6 +194,11 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         process_wayland.xdg_toplevel_icon_manager_v1 =
             wl_registry_bind(registry, id, &xdg_toplevel_icon_manager_v1_interface, 1);
     }
+    else if (strcmp(interface, "wp_fractional_scale_manager_v1") == 0)
+    {
+        process_wayland.wp_fractional_scale_manager_v1 =
+            wl_registry_bind(registry, id, &wp_fractional_scale_manager_v1_interface, 1);
+    }
 }
 
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
@@ -327,6 +332,9 @@ BOOL wayland_process_init(void)
     if (!process_wayland.xdg_toplevel_icon_manager_v1)
         ERR("Wayland compositor doesn't support xdg_toplevel_icon_manager_v1 (window icons will not be supported)\n");
 
+    if (!process_wayland.wp_fractional_scale_manager_v1)
+        ERR("Wayland compositor doesn't support wp_fractional_scale_manager_v1 (fractional scaling will be broken)\n");
+
     process_wayland.initialized = TRUE;
 
     return TRUE;
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 4daf56d10b3..76469a3bce4 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -138,6 +138,25 @@ static const struct xdg_toplevel_listener xdg_toplevel_listener =
     xdg_toplevel_handle_close
 };
 
+void wp_fractional_scale_handle_scale(void* data,
+        struct wp_fractional_scale_v1 *fractional_scale_v1, uint32_t scale)
+{
+    double *data_scale;
+
+    assert(data);
+    data_scale = data;
+
+    /* FIXME: handle locking! */
+    *data_scale = scale / 120.0;
+
+    TRACE("Got scale %lf\n", *data_scale);
+}
+
+static const struct wp_fractional_scale_v1_listener wp_fractional_scale_listener =
+{
+    wp_fractional_scale_handle_scale
+};
+
 /**********************************************************************
  *          wayland_surface_create
  *
@@ -174,8 +193,22 @@ struct wayland_surface *wayland_surface_create(HWND hwnd)
         goto err;
     }
 
+    /* in case we don't get notification */
+    surface->window.fractional_scale = 1.0;
     surface->window.scale = 1.0;
 
+    if (process_wayland.wp_fractional_scale_manager_v1)
+    {
+        surface->wp_fractional_scale_v1 =
+            wp_fractional_scale_manager_v1_get_fractional_scale(
+                process_wayland.wp_fractional_scale_manager_v1,
+                surface->wl_surface);
+        wp_fractional_scale_v1_add_listener(
+            surface->wp_fractional_scale_v1,
+            &wp_fractional_scale_listener,
+            &surface->window.fractional_scale);
+    }
+
     return surface;
 
 err:
@@ -207,6 +240,12 @@ void wayland_surface_destroy(struct wayland_surface *surface)
 
     wayland_surface_clear_role(surface);
 
+    if (surface->wp_fractional_scale_v1)
+    {
+        wp_fractional_scale_v1_destroy(surface->wp_fractional_scale_v1);
+        surface->wp_fractional_scale_v1 = NULL;
+    }
+
     if (surface->wp_viewport)
     {
         wp_viewport_destroy(surface->wp_viewport);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index b3d3016174a..5e04b410202 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -37,6 +37,7 @@
 #include "xdg-shell-client-protocol.h"
 #include "wlr-data-control-unstable-v1-client-protocol.h"
 #include "xdg-toplevel-icon-v1-client-protocol.h"
+#include "fractional-scale-v1-client-protocol.h"
 
 #include "windef.h"
 #include "winbase.h"
@@ -166,6 +167,7 @@ struct wayland
     struct wl_shm *wl_shm;
     struct wp_viewporter *wp_viewporter;
     struct wl_subcompositor *wl_subcompositor;
+    struct wp_fractional_scale_manager_v1 *wp_fractional_scale_manager_v1;
     struct zwp_pointer_constraints_v1 *zwp_pointer_constraints_v1;
     struct zwp_relative_pointer_manager_v1 *zwp_relative_pointer_manager_v1;
     struct zwp_text_input_manager_v3 *zwp_text_input_manager_v3;
@@ -225,6 +227,8 @@ struct wayland_window_config
     RECT rect;
     RECT client_rect;
     enum wayland_surface_config_state state;
+    /* The scaling reported by the compositor */
+    double fractional_scale;
     /* The scale (i.e., normalized dpi) the window is rendering at. */
     double scale;
     BOOL visible;
@@ -259,6 +263,7 @@ struct wayland_surface
 
     struct wl_surface *wl_surface;
     struct wp_viewport *wp_viewport;
+    struct wp_fractional_scale_v1 *wp_fractional_scale_v1;
 
     enum wayland_surface_role role;
     union
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index acc34a18218..648792616af 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -174,7 +174,7 @@ static void wayland_win_data_get_config(struct wayland_win_data *data,
     }
 
     conf->state = window_state;
-    conf->scale = NtUserGetSystemDpiForProcess(0) / 96.0;
+    conf->scale = conf->fractional_scale * NtUserGetSystemDpiForProcess(0) / 96.0;
     conf->visible = (style & WS_VISIBLE) == WS_VISIBLE;
     conf->managed = data->managed;
 }
-- 
2.49.0

From b32c3981b919b84c8a7cf9babdcca22aaaed778e Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Tue, 6 May 2025 21:09:38 -0400
Subject: [PATCH 030/159] cursor shape v1

Co-Authored-By: afrantzis <495575+afrantzis@users.noreply.github.com>
---
 dlls/winewayland.drv/Makefile.in         |    2 +
 dlls/winewayland.drv/cursor-shape-v1.xml |  162 +++
 dlls/winewayland.drv/tablet-v2.xml       | 1297 ++++++++++++++++++++++
 dlls/winewayland.drv/wayland.c           |    6 +
 dlls/winewayland.drv/wayland_pointer.c   |  219 +++-
 dlls/winewayland.drv/waylanddrv.h        |    5 +
 dlls/winewayland.drv/waylanddrv_main.c   |  146 +++
 7 files changed, 1809 insertions(+), 28 deletions(-)
 create mode 100644 dlls/winewayland.drv/cursor-shape-v1.xml
 create mode 100644 dlls/winewayland.drv/tablet-v2.xml

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index f141c22ee36..92db5349568 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -5,12 +5,14 @@ UNIX_LIBS = -lwin32u $(WAYLAND_CLIENT_LIBS) $(WAYLAND_EGL_LIBS) $(XKBCOMMON_LIBS
 IMPORTS = user32 win32u
 
 SOURCES = \
+	cursor-shape-v1.xml \
 	display.c \
 	dllmain.c \
 	fractional-scale-v1.xml \
 	opengl.c \
 	pointer-constraints-unstable-v1.xml \
 	relative-pointer-unstable-v1.xml \
+	tablet-v2.xml \
 	text-input-unstable-v3.xml \
 	version.rc \
 	viewporter.xml \
diff --git a/dlls/winewayland.drv/cursor-shape-v1.xml b/dlls/winewayland.drv/cursor-shape-v1.xml
new file mode 100644
index 00000000000..64b2f9b2c87
--- /dev/null
+++ b/dlls/winewayland.drv/cursor-shape-v1.xml
@@ -0,0 +1,162 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="cursor_shape_v1">
+  <copyright>
+    Copyright 2018 The Chromium Authors
+    Copyright 2023 Simon Ser
+
+    Permission is hereby granted, free of charge, to any person obtaining a
+    copy of this software and associated documentation files (the "Software"),
+    to deal in the Software without restriction, including without limitation
+    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+    and/or sell copies of the Software, and to permit persons to whom the
+    Software is furnished to do so, subject to the following conditions:
+    The above copyright notice and this permission notice (including the next
+    paragraph) shall be included in all copies or substantial portions of the
+    Software.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+    DEALINGS IN THE SOFTWARE.
+  </copyright>
+
+  <interface name="wp_cursor_shape_manager_v1" version="2">
+    <description summary="cursor shape manager">
+      This global offers an alternative, optional way to set cursor images. This
+      new way uses enumerated cursors instead of a wl_surface like
+      wl_pointer.set_cursor does.
+
+      Warning! The protocol described in this file is currently in the testing
+      phase. Backward compatible changes may be added together with the
+      corresponding interface version bump. Backward incompatible changes can
+      only be done by creating a new major version of the extension.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the manager">
+        Destroy the cursor shape manager.
+      </description>
+    </request>
+
+    <request name="get_pointer">
+      <description summary="manage the cursor shape of a pointer device">
+        Obtain a wp_cursor_shape_device_v1 for a wl_pointer object.
+
+        When the pointer capability is removed from the wl_seat, the
+        wp_cursor_shape_device_v1 object becomes inert.
+      </description>
+      <arg name="cursor_shape_device" type="new_id" interface="wp_cursor_shape_device_v1"/>
+      <arg name="pointer" type="object" interface="wl_pointer"/>
+    </request>
+
+    <request name="get_tablet_tool_v2">
+      <description summary="manage the cursor shape of a tablet tool device">
+        Obtain a wp_cursor_shape_device_v1 for a zwp_tablet_tool_v2 object.
+
+        When the zwp_tablet_tool_v2 is removed, the wp_cursor_shape_device_v1
+        object becomes inert.
+      </description>
+      <arg name="cursor_shape_device" type="new_id" interface="wp_cursor_shape_device_v1"/>
+      <arg name="tablet_tool" type="object" interface="zwp_tablet_tool_v2"/>
+    </request>
+  </interface>
+
+  <interface name="wp_cursor_shape_device_v1" version="2">
+    <description summary="cursor shape for a device">
+      This interface allows clients to set the cursor shape.
+    </description>
+
+    <enum name="shape">
+      <description summary="cursor shapes">
+        This enum describes cursor shapes.
+
+        The names are taken from the CSS W3C specification:
+        https://w3c.github.io/csswg-drafts/css-ui/#cursor
+        with a few additions.
+
+        Note that there are some groups of cursor shapes that are related:
+        The first group is drag-and-drop cursors which are used to indicate
+        the selected action during dnd operations. The second group is resize
+        cursors which are used to indicate resizing and moving possibilities
+        on window borders. It is recommended that the shapes in these groups
+        should use visually compatible images and metaphors.
+      </description>
+      <entry name="default" value="1" summary="default cursor"/>
+      <entry name="context_menu" value="2" summary="a context menu is available for the object under the cursor"/>
+      <entry name="help" value="3" summary="help is available for the object under the cursor"/>
+      <entry name="pointer" value="4" summary="pointer that indicates a link or another interactive element"/>
+      <entry name="progress" value="5" summary="progress indicator"/>
+      <entry name="wait" value="6" summary="program is busy, user should wait"/>
+      <entry name="cell" value="7" summary="a cell or set of cells may be selected"/>
+      <entry name="crosshair" value="8" summary="simple crosshair"/>
+      <entry name="text" value="9" summary="text may be selected"/>
+      <entry name="vertical_text" value="10" summary="vertical text may be selected"/>
+      <entry name="alias" value="11" summary="drag-and-drop: alias of/shortcut to something is to be created"/>
+      <entry name="copy" value="12" summary="drag-and-drop: something is to be copied"/>
+      <entry name="move" value="13" summary="drag-and-drop: something is to be moved"/>
+      <entry name="no_drop" value="14" summary="drag-and-drop: the dragged item cannot be dropped at the current cursor location"/>
+      <entry name="not_allowed" value="15" summary="drag-and-drop: the requested action will not be carried out"/>
+      <entry name="grab" value="16" summary="drag-and-drop: something can be grabbed"/>
+      <entry name="grabbing" value="17" summary="drag-and-drop: something is being grabbed"/>
+      <entry name="e_resize" value="18" summary="resizing: the east border is to be moved"/>
+      <entry name="n_resize" value="19" summary="resizing: the north border is to be moved"/>
+      <entry name="ne_resize" value="20" summary="resizing: the north-east corner is to be moved"/>
+      <entry name="nw_resize" value="21" summary="resizing: the north-west corner is to be moved"/>
+      <entry name="s_resize" value="22" summary="resizing: the south border is to be moved"/>
+      <entry name="se_resize" value="23" summary="resizing: the south-east corner is to be moved"/>
+      <entry name="sw_resize" value="24" summary="resizing: the south-west corner is to be moved"/>
+      <entry name="w_resize" value="25" summary="resizing: the west border is to be moved"/>
+      <entry name="ew_resize" value="26" summary="resizing: the east and west borders are to be moved"/>
+      <entry name="ns_resize" value="27" summary="resizing: the north and south borders are to be moved"/>
+      <entry name="nesw_resize" value="28" summary="resizing: the north-east and south-west corners are to be moved"/>
+      <entry name="nwse_resize" value="29" summary="resizing: the north-west and south-east corners are to be moved"/>
+      <entry name="col_resize" value="30" summary="resizing: that the item/column can be resized horizontally"/>
+      <entry name="row_resize" value="31" summary="resizing: that the item/row can be resized vertically"/>
+      <entry name="all_scroll" value="32" summary="something can be scrolled in any direction"/>
+      <entry name="zoom_in" value="33" summary="something can be zoomed in"/>
+      <entry name="zoom_out" value="34" summary="something can be zoomed out"/>
+      <entry name="dnd_ask" value="35" summary="drag-and-drop: the user will select which action will be carried out (non-css value)" since="2"/>
+      <entry name="all_resize" value="36" summary="resizing: something can be moved or resized in any direction (non-css value)" since="2"/>
+    </enum>
+
+    <enum name="error">
+      <entry name="invalid_shape" value="1"
+        summary="the specified shape value is invalid"/>
+    </enum>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the cursor shape device">
+        Destroy the cursor shape device.
+
+        The device cursor shape remains unchanged.
+      </description>
+    </request>
+
+    <request name="set_shape">
+      <description summary="set device cursor to the shape">
+        Sets the device cursor to the specified shape. The compositor will
+        change the cursor image based on the specified shape.
+
+        The cursor actually changes only if the input device focus is one of
+        the requesting client's surfaces. If any, the previous cursor image
+        (surface or shape) is replaced.
+
+        The "shape" argument must be a valid enum entry, otherwise the
+        invalid_shape protocol error is raised.
+
+        This is similar to the wl_pointer.set_cursor and
+        zwp_tablet_tool_v2.set_cursor requests, but this request accepts a
+        shape instead of contents in the form of a surface. Clients can mix
+        set_cursor and set_shape requests.
+
+        The serial parameter must match the latest wl_pointer.enter or
+        zwp_tablet_tool_v2.proximity_in serial number sent to the client.
+        Otherwise the request will be ignored.
+      </description>
+      <arg name="serial" type="uint" summary="serial number of the enter event"/>
+      <arg name="shape" type="uint" enum="shape"/>
+    </request>
+  </interface>
+</protocol>
diff --git a/dlls/winewayland.drv/tablet-v2.xml b/dlls/winewayland.drv/tablet-v2.xml
new file mode 100644
index 00000000000..e2550435c79
--- /dev/null
+++ b/dlls/winewayland.drv/tablet-v2.xml
@@ -0,0 +1,1297 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="tablet_v2">
+
+  <copyright>
+    Copyright 2014 © Stephen "Lyude" Chandler Paul
+    Copyright 2015-2024 © Red Hat, Inc.
+
+    Permission is hereby granted, free of charge, to any person
+    obtaining a copy of this software and associated documentation files
+    (the "Software"), to deal in the Software without restriction,
+    including without limitation the rights to use, copy, modify, merge,
+    publish, distribute, sublicense, and/or sell copies of the Software,
+    and to permit persons to whom the Software is furnished to do so,
+    subject to the following conditions:
+
+    The above copyright notice and this permission notice (including the
+    next paragraph) shall be included in all copies or substantial
+    portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE.
+  </copyright>
+
+  <description summary="Wayland protocol for graphics tablets">
+    This description provides a high-level overview of the interplay between
+    the interfaces defined this protocol. For details, see the protocol
+    specification.
+
+    More than one tablet may exist, and device-specifics matter. Tablets are
+    not represented by a single virtual device like wl_pointer. A client
+    binds to the tablet manager object which is just a proxy object. From
+    that, the client requests wp_tablet_manager.get_tablet_seat(wl_seat)
+    and that returns the actual interface that has all the tablets. With
+    this indirection, we can avoid merging wp_tablet into the actual Wayland
+    protocol, a long-term benefit.
+
+    The wp_tablet_seat sends a "tablet added" event for each tablet
+    connected. That event is followed by descriptive events about the
+    hardware; currently that includes events for name, vid/pid and
+    a wp_tablet.path event that describes a local path. This path can be
+    used to uniquely identify a tablet or get more information through
+    libwacom. Emulated or nested tablets can skip any of those, e.g. a
+    virtual tablet may not have a vid/pid. The sequence of descriptive
+    events is terminated by a wp_tablet.done event to signal that a client
+    may now finalize any initialization for that tablet.
+
+    Events from tablets require a tool in proximity. Tools are also managed
+    by the tablet seat; a "tool added" event is sent whenever a tool is new
+    to the compositor. That event is followed by a number of descriptive
+    events about the hardware; currently that includes capabilities,
+    hardware id and serial number, and tool type. Similar to the tablet
+    interface, a wp_tablet_tool.done event is sent to terminate that initial
+    sequence.
+
+    Any event from a tool happens on the wp_tablet_tool interface. When the
+    tool gets into proximity of the tablet, a proximity_in event is sent on
+    the wp_tablet_tool interface, listing the tablet and the surface. That
+    event is followed by a motion event with the coordinates. After that,
+    it's the usual motion, axis, button, etc. events. The protocol's
+    serialisation means events are grouped by wp_tablet_tool.frame events.
+
+    Two special events (that don't exist in X) are down and up. They signal
+    "tip touching the surface". For tablets without real proximity
+    detection, the sequence is: proximity_in, motion, down, frame.
+
+    When the tool leaves proximity, a proximity_out event is sent. If any
+    button is still down, a button release event is sent before this
+    proximity event. These button events are sent in the same frame as the
+    proximity event to signal to the client that the buttons were held when
+    the tool left proximity.
+
+    If the tool moves out of the surface but stays in proximity (i.e.
+    between windows), compositor-specific grab policies apply. This usually
+    means that the proximity-out is delayed until all buttons are released.
+
+    Moving a tool physically from one tablet to the other has no real effect
+    on the protocol, since we already have the tool object from the "tool
+    added" event. All the information is already there and the proximity
+    events on both tablets are all a client needs to reconstruct what
+    happened.
+
+    Some extra axes are normalized, i.e. the client knows the range as
+    specified in the protocol (e.g. [0, 65535]), the granularity however is
+    unknown. The current normalized axes are pressure, distance, and slider.
+
+    Other extra axes are in physical units as specified in the protocol.
+    The current extra axes with physical units are tilt, rotation and
+    wheel rotation.
+
+    Since tablets work independently of the pointer controlled by the mouse,
+    the focus handling is independent too and controlled by proximity.
+    The wp_tablet_tool.set_cursor request sets a tool-specific cursor.
+    This cursor surface may be the same as the mouse cursor, and it may be
+    the same across tools but it is possible to be more fine-grained. For
+    example, a client may set different cursors for the pen and eraser.
+
+    Tools are generally independent of tablets and it is
+    compositor-specific policy when a tool can be removed. Common approaches
+    will likely include some form of removing a tool when all tablets the
+    tool was used on are removed.
+  </description>
+
+  <interface name="zwp_tablet_manager_v2" version="2">
+    <description summary="controller object for graphic tablet devices">
+      An object that provides access to the graphics tablets available on this
+      system. All tablets are associated with a seat, to get access to the
+      actual tablets, use wp_tablet_manager.get_tablet_seat.
+    </description>
+
+    <request name="get_tablet_seat">
+      <description summary="get the tablet seat">
+	Get the wp_tablet_seat object for the given seat. This object
+	provides access to all graphics tablets in this seat.
+      </description>
+      <arg name="tablet_seat" type="new_id" interface="zwp_tablet_seat_v2"/>
+      <arg name="seat" type="object" interface="wl_seat" summary="The wl_seat object to retrieve the tablets for" />
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="release the memory for the tablet manager object">
+	Destroy the wp_tablet_manager object. Objects created from this
+	object are unaffected and should be destroyed separately.
+      </description>
+    </request>
+  </interface>
+
+  <interface name="zwp_tablet_seat_v2" version="2">
+    <description summary="controller object for graphic tablet devices of a seat">
+      An object that provides access to the graphics tablets available on this
+      seat. After binding to this interface, the compositor sends a set of
+      wp_tablet_seat.tablet_added and wp_tablet_seat.tool_added events.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="release the memory for the tablet seat object">
+	Destroy the wp_tablet_seat object. Objects created from this
+	object are unaffected and should be destroyed separately.
+      </description>
+    </request>
+
+    <event name="tablet_added">
+      <description summary="new device notification">
+	This event is sent whenever a new tablet becomes available on this
+	seat. This event only provides the object id of the tablet, any
+	static information about the tablet (device name, vid/pid, etc.) is
+	sent through the wp_tablet interface.
+      </description>
+      <arg name="id" type="new_id" interface="zwp_tablet_v2" summary="the newly added graphics tablet"/>
+    </event>
+
+    <event name="tool_added">
+      <description summary="a new tool has been used with a tablet">
+	This event is sent whenever a tool that has not previously been used
+	with a tablet comes into use. This event only provides the object id
+	of the tool; any static information about the tool (capabilities,
+	type, etc.) is sent through the wp_tablet_tool interface.
+      </description>
+      <arg name="id" type="new_id" interface="zwp_tablet_tool_v2" summary="the newly added tablet tool"/>
+    </event>
+
+    <event name="pad_added">
+      <description summary="new pad notification">
+	This event is sent whenever a new pad is known to the system. Typically,
+	pads are physically attached to tablets and a pad_added event is
+	sent immediately after the wp_tablet_seat.tablet_added.
+	However, some standalone pad devices logically attach to tablets at
+	runtime, and the client must wait for wp_tablet_pad.enter to know
+	the tablet a pad is attached to.
+
+	This event only provides the object id of the pad. All further
+	features (buttons, strips, rings) are sent through the wp_tablet_pad
+	interface.
+      </description>
+      <arg name="id" type="new_id" interface="zwp_tablet_pad_v2" summary="the newly added pad"/>
+    </event>
+  </interface>
+
+  <interface name="zwp_tablet_tool_v2" version="2">
+    <description summary="a physical tablet tool">
+      An object that represents a physical tool that has been, or is
+      currently in use with a tablet in this seat. Each wp_tablet_tool
+      object stays valid until the client destroys it; the compositor
+      reuses the wp_tablet_tool object to indicate that the object's
+      respective physical tool has come into proximity of a tablet again.
+
+      A wp_tablet_tool object's relation to a physical tool depends on the
+      tablet's ability to report serial numbers. If the tablet supports
+      this capability, then the object represents a specific physical tool
+      and can be identified even when used on multiple tablets.
+
+      A tablet tool has a number of static characteristics, e.g. tool type,
+      hardware_serial and capabilities. These capabilities are sent in an
+      event sequence after the wp_tablet_seat.tool_added event before any
+      actual events from this tool. This initial event sequence is
+      terminated by a wp_tablet_tool.done event.
+
+      Tablet tool events are grouped by wp_tablet_tool.frame events.
+      Any events received before a wp_tablet_tool.frame event should be
+      considered part of the same hardware state change.
+    </description>
+
+    <request name="set_cursor">
+      <description summary="set the tablet tool's surface">
+	Sets the surface of the cursor used for this tool on the given
+	tablet. This request only takes effect if the tool is in proximity
+	of one of the requesting client's surfaces or the surface parameter
+	is the current pointer surface. If there was a previous surface set
+	with this request it is replaced. If surface is NULL, the cursor
+	image is hidden.
+
+	The parameters hotspot_x and hotspot_y define the position of the
+	pointer surface relative to the pointer location. Its top-left corner
+	is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the
+	coordinates of the pointer location, in surface-local coordinates.
+
+	On surface.attach requests to the pointer surface, hotspot_x and
+	hotspot_y are decremented by the x and y parameters passed to the
+	request. Attach must be confirmed by wl_surface.commit as usual.
+
+	The hotspot can also be updated by passing the currently set pointer
+	surface to this request with new values for hotspot_x and hotspot_y.
+
+	The current and pending input regions of the wl_surface are cleared,
+	and wl_surface.set_input_region is ignored until the wl_surface is no
+	longer used as the cursor. When the use as a cursor ends, the current
+	and pending input regions become undefined, and the wl_surface is
+	unmapped.
+
+	This request gives the surface the role of a wp_tablet_tool cursor. A
+	surface may only ever be used as the cursor surface for one
+	wp_tablet_tool. If the surface already has another role or has
+	previously been used as cursor surface for a different tool, a
+	protocol error is raised.
+      </description>
+      <arg name="serial" type="uint" summary="serial of the proximity_in event"/>
+      <arg name="surface" type="object" interface="wl_surface" allow-null="true"/>
+      <arg name="hotspot_x" type="int" summary="surface-local x coordinate"/>
+      <arg name="hotspot_y" type="int" summary="surface-local y coordinate"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the tool object">
+	This destroys the client's resource for this tool object.
+      </description>
+    </request>
+
+    <enum name="type">
+      <description summary="a physical tool type">
+	Describes the physical type of a tool. The physical type of a tool
+	generally defines its base usage.
+
+	The mouse tool represents a mouse-shaped tool that is not a relative
+	device but bound to the tablet's surface, providing absolute
+	coordinates.
+
+	The lens tool is a mouse-shaped tool with an attached lens to
+	provide precision focus.
+      </description>
+      <entry name="pen" value="0x140" summary="Pen"/>
+      <entry name="eraser" value="0x141" summary="Eraser"/>
+      <entry name="brush" value="0x142" summary="Brush"/>
+      <entry name="pencil" value="0x143" summary="Pencil"/>
+      <entry name="airbrush" value="0x144" summary="Airbrush"/>
+      <entry name="finger" value="0x145" summary="Finger"/>
+      <entry name="mouse" value="0x146" summary="Mouse"/>
+      <entry name="lens" value="0x147" summary="Lens"/>
+    </enum>
+
+    <event name="type">
+      <description summary="tool type">
+	The tool type is the high-level type of the tool and usually decides
+	the interaction expected from this tool.
+
+	This event is sent in the initial burst of events before the
+	wp_tablet_tool.done event.
+      </description>
+      <arg name="tool_type" type="uint" enum="type" summary="the physical tool type"/>
+    </event>
+
+    <event name="hardware_serial">
+      <description summary="unique hardware serial number of the tool">
+	If the physical tool can be identified by a unique 64-bit serial
+	number, this event notifies the client of this serial number.
+
+	If multiple tablets are available in the same seat and the tool is
+	uniquely identifiable by the serial number, that tool may move
+	between tablets.
+
+	Otherwise, if the tool has no serial number and this event is
+	missing, the tool is tied to the tablet it first comes into
+	proximity with. Even if the physical tool is used on multiple
+	tablets, separate wp_tablet_tool objects will be created, one per
+	tablet.
+
+	This event is sent in the initial burst of events before the
+	wp_tablet_tool.done event.
+      </description>
+      <arg name="hardware_serial_hi" type="uint" summary="the unique serial number of the tool, most significant bits"/>
+      <arg name="hardware_serial_lo" type="uint" summary="the unique serial number of the tool, least significant bits"/>
+    </event>
+
+    <event name="hardware_id_wacom">
+      <description summary="hardware id notification in Wacom's format">
+	This event notifies the client of a hardware id available on this tool.
+
+	The hardware id is a device-specific 64-bit id that provides extra
+	information about the tool in use, beyond the wl_tool.type
+	enumeration. The format of the id is specific to tablets made by
+	Wacom Inc. For example, the hardware id of a Wacom Grip
+	Pen (a stylus) is 0x802.
+
+	This event is sent in the initial burst of events before the
+	wp_tablet_tool.done event.
+      </description>
+      <arg name="hardware_id_hi" type="uint" summary="the hardware id, most significant bits"/>
+      <arg name="hardware_id_lo" type="uint" summary="the hardware id, least significant bits"/>
+    </event>
+
+    <enum name="capability">
+      <description summary="capability flags for a tool">
+	Describes extra capabilities on a tablet.
+
+	Any tool must provide x and y values, extra axes are
+	device-specific.
+      </description>
+      <entry name="tilt" value="1" summary="Tilt axes"/>
+      <entry name="pressure" value="2" summary="Pressure axis"/>
+      <entry name="distance" value="3" summary="Distance axis"/>
+      <entry name="rotation" value="4" summary="Z-rotation axis"/>
+      <entry name="slider" value="5" summary="Slider axis"/>
+      <entry name="wheel" value="6" summary="Wheel axis"/>
+    </enum>
+
+    <event name="capability">
+      <description summary="tool capability notification">
+	This event notifies the client of any capabilities of this tool,
+	beyond the main set of x/y axes and tip up/down detection.
+
+	One event is sent for each extra capability available on this tool.
+
+	This event is sent in the initial burst of events before the
+	wp_tablet_tool.done event.
+      </description>
+      <arg name="capability" type="uint" enum="capability" summary="the capability"/>
+    </event>
+
+    <event name="done">
+      <description summary="tool description events sequence complete">
+	This event signals the end of the initial burst of descriptive
+	events. A client may consider the static description of the tool to
+	be complete and finalize initialization of the tool.
+      </description>
+    </event>
+
+    <event name="removed">
+      <description summary="tool removed">
+	This event is sent when the tool is removed from the system and will
+	send no further events. Should the physical tool come back into
+	proximity later, a new wp_tablet_tool object will be created.
+
+	It is compositor-dependent when a tool is removed. A compositor may
+	remove a tool on proximity out, tablet removal or any other reason.
+	A compositor may also keep a tool alive until shutdown.
+
+	If the tool is currently in proximity, a proximity_out event will be
+	sent before the removed event. See wp_tablet_tool.proximity_out for
+	the handling of any buttons logically down.
+
+	When this event is received, the client must wp_tablet_tool.destroy
+	the object.
+      </description>
+    </event>
+
+    <event name="proximity_in">
+      <description summary="proximity in event">
+	Notification that this tool is focused on a certain surface.
+
+	This event can be received when the tool has moved from one surface to
+	another, or when the tool has come back into proximity above the
+	surface.
+
+	If any button is logically down when the tool comes into proximity,
+	the respective button event is sent after the proximity_in event but
+	within the same frame as the proximity_in event.
+      </description>
+      <arg name="serial" type="uint"/>
+      <arg name="tablet" type="object" interface="zwp_tablet_v2" summary="The tablet the tool is in proximity of"/>
+      <arg name="surface" type="object" interface="wl_surface" summary="The current surface the tablet tool is over"/>
+    </event>
+
+    <event name="proximity_out">
+      <description summary="proximity out event">
+	Notification that this tool has either left proximity, or is no
+	longer focused on a certain surface.
+
+	When the tablet tool leaves proximity of the tablet, button release
+	events are sent for each button that was held down at the time of
+	leaving proximity. These events are sent before the proximity_out
+	event but within the same wp_tablet.frame.
+
+	If the tool stays within proximity of the tablet, but the focus
+	changes from one surface to another, a button release event may not
+	be sent until the button is actually released or the tool leaves the
+	proximity of the tablet.
+      </description>
+    </event>
+
+    <event name="down">
+      <description summary="tablet tool is making contact">
+	Sent whenever the tablet tool comes in contact with the surface of the
+	tablet.
+
+	If the tool is already in contact with the tablet when entering the
+	input region, the client owning said region will receive a
+	wp_tablet.proximity_in event, followed by a wp_tablet.down
+	event and a wp_tablet.frame event.
+
+	Note that this event describes logical contact, not physical
+	contact. On some devices, a compositor may not consider a tool in
+	logical contact until a minimum physical pressure threshold is
+	exceeded.
+      </description>
+      <arg name="serial" type="uint"/>
+    </event>
+
+    <event name="up">
+      <description summary="tablet tool is no longer making contact">
+	Sent whenever the tablet tool stops making contact with the surface of
+	the tablet, or when the tablet tool moves out of the input region
+	and the compositor grab (if any) is dismissed.
+
+	If the tablet tool moves out of the input region while in contact
+	with the surface of the tablet and the compositor does not have an
+	ongoing grab on the surface, the client owning said region will
+	receive a wp_tablet.up event, followed by a wp_tablet.proximity_out
+	event and a wp_tablet.frame event. If the compositor has an ongoing
+	grab on this device, this event sequence is sent whenever the grab
+	is dismissed in the future.
+
+	Note that this event describes logical contact, not physical
+	contact. On some devices, a compositor may not consider a tool out
+	of logical contact until physical pressure falls below a specific
+	threshold.
+      </description>
+    </event>
+
+    <event name="motion">
+      <description summary="motion event">
+	Sent whenever a tablet tool moves.
+      </description>
+      <arg name="x" type="fixed" summary="surface-local x coordinate"/>
+      <arg name="y" type="fixed" summary="surface-local y coordinate"/>
+    </event>
+
+    <event name="pressure">
+      <description summary="pressure change event">
+	Sent whenever the pressure axis on a tool changes. The value of this
+	event is normalized to a value between 0 and 65535.
+
+	Note that pressure may be nonzero even when a tool is not in logical
+	contact. See the down and up events for more details.
+      </description>
+      <arg name="pressure" type="uint" summary="The current pressure value"/>
+    </event>
+
+    <event name="distance">
+      <description summary="distance change event">
+	Sent whenever the distance axis on a tool changes. The value of this
+	event is normalized to a value between 0 and 65535.
+
+	Note that distance may be nonzero even when a tool is not in logical
+	contact. See the down and up events for more details.
+      </description>
+      <arg name="distance" type="uint" summary="The current distance value"/>
+    </event>
+
+    <event name="tilt">
+      <description summary="tilt change event">
+	Sent whenever one or both of the tilt axes on a tool change. Each tilt
+	value is in degrees, relative to the z-axis of the tablet.
+	The angle is positive when the top of a tool tilts along the
+	positive x or y axis.
+      </description>
+      <arg name="tilt_x" type="fixed" summary="The current value of the X tilt axis"/>
+      <arg name="tilt_y" type="fixed" summary="The current value of the Y tilt axis"/>
+    </event>
+
+    <event name="rotation">
+      <description summary="z-rotation change event">
+	Sent whenever the z-rotation axis on the tool changes. The
+	rotation value is in degrees clockwise from the tool's
+	logical neutral position.
+      </description>
+      <arg name="degrees" type="fixed" summary="The current rotation of the Z axis"/>
+    </event>
+
+    <event name="slider">
+      <description summary="Slider position change event">
+	Sent whenever the slider position on the tool changes. The
+	value is normalized between -65535 and 65535, with 0 as the logical
+	neutral position of the slider.
+
+	The slider is available on e.g. the Wacom Airbrush tool.
+      </description>
+      <arg name="position" type="int" summary="The current position of slider"/>
+    </event>
+
+    <event name="wheel">
+      <description summary="Wheel delta event">
+	Sent whenever the wheel on the tool emits an event. This event
+	contains two values for the same axis change. The degrees value is
+	in the same orientation as the wl_pointer.vertical_scroll axis. The
+	clicks value is in discrete logical clicks of the mouse wheel. This
+	value may be zero if the movement of the wheel was less
+	than one logical click.
+
+	Clients should choose either value and avoid mixing degrees and
+	clicks. The compositor may accumulate values smaller than a logical
+	click and emulate click events when a certain threshold is met.
+	Thus, wl_tablet_tool.wheel events with non-zero clicks values may
+	have different degrees values.
+      </description>
+      <arg name="degrees" type="fixed" summary="The wheel delta in degrees"/>
+      <arg name="clicks" type="int" summary="The wheel delta in discrete clicks"/>
+    </event>
+
+    <enum name="button_state">
+      <description summary="physical button state">
+	Describes the physical state of a button that produced the button event.
+      </description>
+      <entry name="released" value="0" summary="button is not pressed"/>
+      <entry name="pressed" value="1" summary="button is pressed"/>
+    </enum>
+
+    <event name="button">
+      <description summary="button event">
+	Sent whenever a button on the tool is pressed or released.
+
+	If a button is held down when the tool moves in or out of proximity,
+	button events are generated by the compositor. See
+	wp_tablet_tool.proximity_in and wp_tablet_tool.proximity_out for
+	details.
+      </description>
+      <arg name="serial" type="uint"/>
+      <arg name="button" type="uint" summary="The button whose state has changed"/>
+      <arg name="state" type="uint" enum="button_state" summary="Whether the button was pressed or released"/>
+    </event>
+
+    <event name="frame">
+      <description summary="frame event">
+	Marks the end of a series of axis and/or button updates from the
+	tablet. The Wayland protocol requires axis updates to be sent
+	sequentially, however all events within a frame should be considered
+	one hardware event.
+      </description>
+      <arg name="time" type="uint" summary="The time of the event with millisecond granularity"/>
+    </event>
+
+    <enum name="error">
+      <entry name="role" value="0" summary="given wl_surface has another role"/>
+    </enum>
+  </interface>
+
+  <interface name="zwp_tablet_v2" version="2">
+    <description summary="graphics tablet device">
+      The wp_tablet interface represents one graphics tablet device. The
+      tablet interface itself does not generate events; all events are
+      generated by wp_tablet_tool objects when in proximity above a tablet.
+
+      A tablet has a number of static characteristics, e.g. device name and
+      pid/vid. These capabilities are sent in an event sequence after the
+      wp_tablet_seat.tablet_added event. This initial event sequence is
+      terminated by a wp_tablet.done event.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the tablet object">
+	This destroys the client's resource for this tablet object.
+      </description>
+    </request>
+
+    <event name="name">
+      <description summary="tablet device name">
+        A descriptive name for the tablet device.
+
+	If the device has no descriptive name, this event is not sent.
+
+	This event is sent in the initial burst of events before the
+        wp_tablet.done event.
+      </description>
+      <arg name="name" type="string" summary="the device name"/>
+    </event>
+
+    <event name="id">
+      <description summary="tablet device vendor/product id">
+	The vendor and product IDs for the tablet device.
+
+	The interpretation of the id depends on the wp_tablet.bustype.
+	Prior to version v2 of this protocol, the id was implied to be a USB
+	vendor and product ID. If no wp_tablet.bustype is sent, the ID
+	is to be interpreted as USB vendor and product ID.
+
+	If the device has no vendor/product ID, this event is not sent.
+	This can happen for virtual devices or non-USB devices, for instance.
+
+	This event is sent in the initial burst of events before the
+	wp_tablet.done event.
+      </description>
+      <arg name="vid" type="uint" summary="vendor id"/>
+      <arg name="pid" type="uint" summary="product id"/>
+    </event>
+
+    <event name="path">
+      <description summary="path to the device">
+	A system-specific device path that indicates which device is behind
+	this wp_tablet. This information may be used to gather additional
+	information about the device, e.g. through libwacom.
+
+	A device may have more than one device path. If so, multiple
+	wp_tablet.path events are sent. A device may be emulated and not
+	have a device path, and in that case this event will not be sent.
+
+	The format of the path is unspecified, it may be a device node, a
+	sysfs path, or some other identifier. It is up to the client to
+	identify the string provided.
+
+	This event is sent in the initial burst of events before the
+	wp_tablet.done event.
+      </description>
+      <arg name="path" type="string" summary="path to local device"/>
+    </event>
+
+    <event name="done">
+      <description summary="tablet description events sequence complete">
+	This event is sent immediately to signal the end of the initial
+	burst of descriptive events. A client may consider the static
+	description of the tablet to be complete and finalize initialization
+	of the tablet.
+      </description>
+    </event>
+
+    <event name="removed">
+      <description summary="tablet removed event">
+	Sent when the tablet has been removed from the system. When a tablet
+	is removed, some tools may be removed.
+
+	When this event is received, the client must wp_tablet.destroy
+	the object.
+      </description>
+    </event>
+
+    <!-- Version 2 additions -->
+
+    <enum name="bustype" since="2">
+      <description summary="bus type ">
+	Describes the bus types this tablet is connected to.
+      </description>
+      <entry name="usb" value="3" summary="USB"/>
+      <entry name="bluetooth" value="5" summary="Bluetooth"/>
+      <entry name="virtual" value="6" summary="Virtual"/>
+      <entry name="serial" value="17" summary="Serial"/>
+      <entry name="i2c" value="24" summary="I2C"/>
+    </enum>
+
+    <event name="bustype" since="2">
+      <description summary="tablet device bus type">
+	The bustype argument is one of the BUS_ defines in the Linux kernel's
+	linux/input.h
+
+	If the device has no known bustype or the bustype cannot be
+	queried, this event is not sent.
+
+	This event is sent in the initial burst of events before the
+	wp_tablet.done event.
+      </description>
+      <arg name="bustype" type="uint" enum="bustype" summary="bus type"/>
+    </event>
+  </interface>
+
+  <interface name="zwp_tablet_pad_ring_v2" version="2">
+    <description summary="pad ring">
+      A circular interaction area, such as the touch ring on the Wacom Intuos
+      Pro series tablets.
+
+      Events on a ring are logically grouped by the wl_tablet_pad_ring.frame
+      event.
+    </description>
+
+    <request name="set_feedback">
+      <description summary="set compositor feedback">
+	Request that the compositor use the provided feedback string
+	associated with this ring. This request should be issued immediately
+	after a wp_tablet_pad_group.mode_switch event from the corresponding
+	group is received, or whenever the ring is mapped to a different
+	action. See wp_tablet_pad_group.mode_switch for more details.
+
+	Clients are encouraged to provide context-aware descriptions for
+	the actions associated with the ring; compositors may use this
+	information to offer visual feedback about the button layout
+	(eg. on-screen displays).
+
+	The provided string 'description' is a UTF-8 encoded string to be
+	associated with this ring, and is considered user-visible; general
+	internationalization rules apply.
+
+	The serial argument will be that of the last
+	wp_tablet_pad_group.mode_switch event received for the group of this
+	ring. Requests providing other serials than the most recent one will be
+	ignored.
+      </description>
+      <arg name="description" type="string" summary="ring description"/>
+      <arg name="serial" type="uint" summary="serial of the mode switch event"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the ring object">
+	This destroys the client's resource for this ring object.
+      </description>
+    </request>
+
+    <enum name="source">
+      <description summary="ring axis source">
+	Describes the source types for ring events. This indicates to the
+	client how a ring event was physically generated; a client may
+	adjust the user interface accordingly. For example, events
+	from a "finger" source may trigger kinetic scrolling.
+      </description>
+      <entry name="finger" value="1" summary="finger"/>
+    </enum>
+
+    <event name="source">
+      <description summary="ring event source">
+	Source information for ring events.
+
+	This event does not occur on its own. It is sent before a
+	wp_tablet_pad_ring.frame event and carries the source information
+	for all events within that frame.
+
+	The source specifies how this event was generated. If the source is
+	wp_tablet_pad_ring.source.finger, a wp_tablet_pad_ring.stop event
+	will be sent when the user lifts the finger off the device.
+
+	This event is optional. If the source is unknown for an interaction,
+	no event is sent.
+      </description>
+      <arg name="source" type="uint" enum="source" summary="the event source"/>
+    </event>
+
+    <event name="angle">
+      <description summary="angle changed">
+	Sent whenever the angle on a ring changes.
+
+	The angle is provided in degrees clockwise from the logical
+	north of the ring in the pad's current rotation.
+      </description>
+      <arg name="degrees" type="fixed" summary="the current angle in degrees"/>
+    </event>
+
+    <event name="stop">
+      <description summary="interaction stopped">
+	Stop notification for ring events.
+
+	For some wp_tablet_pad_ring.source types, a wp_tablet_pad_ring.stop
+	event is sent to notify a client that the interaction with the ring
+	has terminated. This enables the client to implement kinetic scrolling.
+	See the wp_tablet_pad_ring.source documentation for information on
+	when this event may be generated.
+
+	Any wp_tablet_pad_ring.angle events with the same source after this
+	event should be considered as the start of a new interaction.
+      </description>
+    </event>
+
+    <event name="frame">
+      <description summary="end of a ring event sequence">
+	Indicates the end of a set of ring events that logically belong
+	together. A client is expected to accumulate the data in all events
+	within the frame before proceeding.
+
+	All wp_tablet_pad_ring events before a wp_tablet_pad_ring.frame event belong
+	logically together. For example, on termination of a finger interaction
+	on a ring the compositor will send a wp_tablet_pad_ring.source event,
+	a wp_tablet_pad_ring.stop event and a wp_tablet_pad_ring.frame event.
+
+	A wp_tablet_pad_ring.frame event is sent for every logical event
+	group, even if the group only contains a single wp_tablet_pad_ring
+	event. Specifically, a client may get a sequence: angle, frame,
+	angle, frame, etc.
+      </description>
+      <arg name="time" type="uint" summary="timestamp with millisecond granularity"/>
+    </event>
+  </interface>
+
+  <interface name="zwp_tablet_pad_strip_v2" version="2">
+    <description summary="pad strip">
+      A linear interaction area, such as the strips found in Wacom Cintiq
+      models.
+
+      Events on a strip are logically grouped by the wl_tablet_pad_strip.frame
+      event.
+    </description>
+
+    <request name="set_feedback">
+      <description summary="set compositor feedback">
+	Requests the compositor to use the provided feedback string
+	associated with this strip. This request should be issued immediately
+	after a wp_tablet_pad_group.mode_switch event from the corresponding
+	group is received, or whenever the strip is mapped to a different
+	action. See wp_tablet_pad_group.mode_switch for more details.
+
+	Clients are encouraged to provide context-aware descriptions for
+	the actions associated with the strip, and compositors may use this
+	information to offer visual feedback about the button layout
+	(eg. on-screen displays).
+
+	The provided string 'description' is a UTF-8 encoded string to be
+	associated with this ring, and is considered user-visible; general
+	internationalization rules apply.
+
+	The serial argument will be that of the last
+	wp_tablet_pad_group.mode_switch event received for the group of this
+	strip. Requests providing other serials than the most recent one will be
+	ignored.
+      </description>
+      <arg name="description" type="string" summary="strip description"/>
+      <arg name="serial" type="uint" summary="serial of the mode switch event"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the strip object">
+	This destroys the client's resource for this strip object.
+      </description>
+    </request>
+
+    <enum name="source">
+      <description summary="strip axis source">
+	Describes the source types for strip events. This indicates to the
+	client how a strip event was physically generated; a client may
+	adjust the user interface accordingly. For example, events
+	from a "finger" source may trigger kinetic scrolling.
+      </description>
+      <entry name="finger" value="1" summary="finger"/>
+    </enum>
+
+    <event name="source">
+      <description summary="strip event source">
+	Source information for strip events.
+
+	This event does not occur on its own. It is sent before a
+	wp_tablet_pad_strip.frame event and carries the source information
+	for all events within that frame.
+
+	The source specifies how this event was generated. If the source is
+	wp_tablet_pad_strip.source.finger, a wp_tablet_pad_strip.stop event
+	will be sent when the user lifts their finger off the device.
+
+	This event is optional. If the source is unknown for an interaction,
+	no event is sent.
+      </description>
+      <arg name="source" type="uint" enum="source" summary="the event source"/>
+    </event>
+
+    <event name="position">
+      <description summary="position changed">
+	Sent whenever the position on a strip changes.
+
+	The position is normalized to a range of [0, 65535], the 0-value
+	represents the top-most and/or left-most position of the strip in
+	the pad's current rotation.
+      </description>
+      <arg name="position" type="uint" summary="the current position"/>
+    </event>
+
+    <event name="stop">
+      <description summary="interaction stopped">
+	Stop notification for strip events.
+
+	For some wp_tablet_pad_strip.source types, a wp_tablet_pad_strip.stop
+	event is sent to notify a client that the interaction with the strip
+	has terminated. This enables the client to implement kinetic
+	scrolling. See the wp_tablet_pad_strip.source documentation for
+	information on when this event may be generated.
+
+	Any wp_tablet_pad_strip.position events with the same source after this
+	event should be considered as the start of a new interaction.
+      </description>
+    </event>
+
+    <event name="frame">
+      <description summary="end of a strip event sequence">
+	Indicates the end of a set of events that represent one logical
+	hardware strip event. A client is expected to accumulate the data
+	in all events within the frame before proceeding.
+
+	All wp_tablet_pad_strip events before a wp_tablet_pad_strip.frame event belong
+	logically together. For example, on termination of a finger interaction
+	on a strip the compositor will send a wp_tablet_pad_strip.source event,
+	a wp_tablet_pad_strip.stop event and a wp_tablet_pad_strip.frame
+	event.
+
+	A wp_tablet_pad_strip.frame event is sent for every logical event
+	group, even if the group only contains a single wp_tablet_pad_strip
+	event. Specifically, a client may get a sequence: position, frame,
+	position, frame, etc.
+      </description>
+      <arg name="time" type="uint" summary="timestamp with millisecond granularity"/>
+    </event>
+  </interface>
+
+  <interface name="zwp_tablet_pad_group_v2" version="2">
+    <description summary="a set of buttons, rings and strips">
+      A pad group describes a distinct (sub)set of buttons, rings and strips
+      present in the tablet. The criteria of this grouping is usually positional,
+      eg. if a tablet has buttons on the left and right side, 2 groups will be
+      presented. The physical arrangement of groups is undisclosed and may
+      change on the fly.
+
+      Pad groups will announce their features during pad initialization. Between
+      the corresponding wp_tablet_pad.group event and wp_tablet_pad_group.done, the
+      pad group will announce the buttons, rings and strips contained in it,
+      plus the number of supported modes.
+
+      Modes are a mechanism to allow multiple groups of actions for every element
+      in the pad group. The number of groups and available modes in each is
+      persistent across device plugs. The current mode is user-switchable, it
+      will be announced through the wp_tablet_pad_group.mode_switch event both
+      whenever it is switched, and after wp_tablet_pad.enter.
+
+      The current mode logically applies to all elements in the pad group,
+      although it is at clients' discretion whether to actually perform different
+      actions, and/or issue the respective .set_feedback requests to notify the
+      compositor. See the wp_tablet_pad_group.mode_switch event for more details.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the pad object">
+	Destroy the wp_tablet_pad_group object. Objects created from this object
+	are unaffected and should be destroyed separately.
+      </description>
+    </request>
+
+    <event name="buttons">
+      <description summary="buttons announced">
+	Sent on wp_tablet_pad_group initialization to announce the available
+	buttons in the group. Button indices start at 0, a button may only be
+	in one group at a time.
+
+	This event is first sent in the initial burst of events before the
+	wp_tablet_pad_group.done event.
+
+	Some buttons are reserved by the compositor. These buttons may not be
+	assigned to any wp_tablet_pad_group. Compositors may broadcast this
+	event in the case of changes to the mapping of these reserved buttons.
+	If the compositor happens to reserve all buttons in a group, this event
+	will be sent with an empty array.
+      </description>
+      <arg name="buttons" type="array" summary="buttons in this group"/>
+    </event>
+
+    <event name="ring">
+      <description summary="ring announced">
+	Sent on wp_tablet_pad_group initialization to announce available rings.
+	One event is sent for each ring available on this pad group.
+
+	This event is sent in the initial burst of events before the
+	wp_tablet_pad_group.done event.
+      </description>
+      <arg name="ring" type="new_id" interface="zwp_tablet_pad_ring_v2"/>
+    </event>
+
+    <event name="strip">
+      <description summary="strip announced">
+	Sent on wp_tablet_pad initialization to announce available strips.
+	One event is sent for each strip available on this pad group.
+
+	This event is sent in the initial burst of events before the
+	wp_tablet_pad_group.done event.
+      </description>
+      <arg name="strip" type="new_id" interface="zwp_tablet_pad_strip_v2"/>
+    </event>
+
+    <event name="modes">
+      <description summary="mode-switch ability announced">
+	Sent on wp_tablet_pad_group initialization to announce that the pad
+	group may switch between modes. A client may use a mode to store a
+	specific configuration for buttons, rings and strips and use the
+	wl_tablet_pad_group.mode_switch event to toggle between these
+	configurations. Mode indices start at 0.
+
+	Switching modes is compositor-dependent. See the
+	wp_tablet_pad_group.mode_switch event for more details.
+
+	This event is sent in the initial burst of events before the
+	wp_tablet_pad_group.done event. This event is only sent when more than
+	more than one mode is available.
+      </description>
+      <arg name="modes" type="uint" summary="the number of modes"/>
+    </event>
+
+    <event name="done">
+      <description summary="tablet group description events sequence complete">
+	This event is sent immediately to signal the end of the initial
+	burst of descriptive events. A client may consider the static
+	description of the tablet to be complete and finalize initialization
+	of the tablet group.
+      </description>
+    </event>
+
+    <event name="mode_switch">
+      <description summary="mode switch event">
+	Notification that the mode was switched.
+
+	A mode applies to all buttons, rings, strips and dials in a group
+	simultaneously, but a client is not required to assign different actions
+	for each mode. For example, a client may have mode-specific button
+	mappings but map the ring to vertical scrolling in all modes. Mode
+	indices start at 0.
+
+	Switching modes is compositor-dependent. The compositor may provide
+	visual cues to the user about the mode, e.g. by toggling LEDs on
+	the tablet device. Mode-switching may be software-controlled or
+	controlled by one or more physical buttons. For example, on a Wacom
+	Intuos Pro, the button inside the ring may be assigned to switch
+	between modes.
+
+	The compositor will also send this event after wp_tablet_pad.enter on
+	each group in order to notify of the current mode. Groups that only
+	feature one mode will use mode=0 when emitting this event.
+
+	If a button action in the new mode differs from the action in the
+	previous mode, the client should immediately issue a
+	wp_tablet_pad.set_feedback request for each changed button.
+
+	If a ring, strip or dial action in the new mode differs from the action
+	in the previous mode, the client should immediately issue a
+	wp_tablet_ring.set_feedback, wp_tablet_strip.set_feedback or
+	wp_tablet_dial.set_feedback request for each changed ring, strip or dial.
+      </description>
+      <arg name="time" type="uint" summary="the time of the event with millisecond granularity"/>
+      <arg name="serial" type="uint"/>
+      <arg name="mode" type="uint" summary="the new mode of the pad"/>
+    </event>
+
+    <!-- Version 2 additions -->
+
+    <event name="dial" since="2">
+      <description summary="dial announced">
+	Sent on wp_tablet_pad initialization to announce available dials.
+	One event is sent for each dial available on this pad group.
+
+	This event is sent in the initial burst of events before the
+	wp_tablet_pad_group.done event.
+      </description>
+      <arg name="dial" type="new_id" interface="zwp_tablet_pad_dial_v2"/>
+    </event>
+  </interface>
+
+  <interface name="zwp_tablet_pad_v2" version="2">
+    <description summary="a set of buttons, rings, strips and dials">
+      A pad device is a set of buttons, rings, strips and dials
+      usually physically present on the tablet device itself. Some
+      exceptions exist where the pad device is physically detached, e.g. the
+      Wacom ExpressKey Remote.
+
+      Pad devices have no axes that control the cursor and are generally
+      auxiliary devices to the tool devices used on the tablet surface.
+
+      A pad device has a number of static characteristics, e.g. the number
+      of rings. These capabilities are sent in an event sequence after the
+      wp_tablet_seat.pad_added event before any actual events from this pad.
+      This initial event sequence is terminated by a wp_tablet_pad.done
+      event.
+
+      All pad features (buttons, rings, strips and dials) are logically divided into
+      groups and all pads have at least one group. The available groups are
+      notified through the wp_tablet_pad.group event; the compositor will
+      emit one event per group before emitting wp_tablet_pad.done.
+
+      Groups may have multiple modes. Modes allow clients to map multiple
+      actions to a single pad feature. Only one mode can be active per group,
+      although different groups may have different active modes.
+    </description>
+
+    <request name="set_feedback">
+      <description summary="set compositor feedback">
+	Requests the compositor to use the provided feedback string
+	associated with this button. This request should be issued immediately
+	after a wp_tablet_pad_group.mode_switch event from the corresponding
+	group is received, or whenever a button is mapped to a different
+	action. See wp_tablet_pad_group.mode_switch for more details.
+
+	Clients are encouraged to provide context-aware descriptions for
+	the actions associated with each button, and compositors may use
+	this information to offer visual feedback on the button layout
+	(e.g. on-screen displays).
+
+	Button indices start at 0. Setting the feedback string on a button
+	that is reserved by the compositor (i.e. not belonging to any
+	wp_tablet_pad_group) does not generate an error but the compositor
+	is free to ignore the request.
+
+	The provided string 'description' is a UTF-8 encoded string to be
+	associated with this ring, and is considered user-visible; general
+	internationalization rules apply.
+
+	The serial argument will be that of the last
+	wp_tablet_pad_group.mode_switch event received for the group of this
+	button. Requests providing other serials than the most recent one will
+	be ignored.
+      </description>
+      <arg name="button" type="uint" summary="button index"/>
+      <arg name="description" type="string" summary="button description"/>
+      <arg name="serial" type="uint" summary="serial of the mode switch event"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the pad object">
+	Destroy the wp_tablet_pad object. Objects created from this object
+	are unaffected and should be destroyed separately.
+      </description>
+    </request>
+
+    <event name="group">
+      <description summary="group announced">
+	Sent on wp_tablet_pad initialization to announce available groups.
+	One event is sent for each pad group available.
+
+	This event is sent in the initial burst of events before the
+	wp_tablet_pad.done event. At least one group will be announced.
+      </description>
+      <arg name="pad_group" type="new_id" interface="zwp_tablet_pad_group_v2"/>
+    </event>
+
+    <event name="path">
+      <description summary="path to the device">
+	A system-specific device path that indicates which device is behind
+	this wp_tablet_pad. This information may be used to gather additional
+	information about the device, e.g. through libwacom.
+
+	The format of the path is unspecified, it may be a device node, a
+	sysfs path, or some other identifier. It is up to the client to
+	identify the string provided.
+
+	This event is sent in the initial burst of events before the
+	wp_tablet_pad.done event.
+      </description>
+      <arg name="path" type="string" summary="path to local device"/>
+    </event>
+
+    <event name="buttons">
+      <description summary="buttons announced">
+	Sent on wp_tablet_pad initialization to announce the available
+	buttons.
+
+	This event is sent in the initial burst of events before the
+	wp_tablet_pad.done event. This event is only sent when at least one
+	button is available.
+      </description>
+      <arg name="buttons" type="uint" summary="the number of buttons"/>
+    </event>
+
+    <event name="done">
+      <description summary="pad description event sequence complete">
+	This event signals the end of the initial burst of descriptive
+	events. A client may consider the static description of the pad to
+	be complete and finalize initialization of the pad.
+      </description>
+    </event>
+
+    <enum name="button_state">
+      <description summary="physical button state">
+	Describes the physical state of a button that caused the button
+	event.
+      </description>
+      <entry name="released" value="0" summary="the button is not pressed"/>
+      <entry name="pressed" value="1" summary="the button is pressed"/>
+    </enum>
+
+    <event name="button">
+      <description summary="physical button state">
+	Sent whenever the physical state of a button changes.
+      </description>
+      <arg name="time" type="uint" summary="the time of the event with millisecond granularity"/>
+      <arg name="button" type="uint" summary="the index of the button that changed state"/>
+      <arg name="state" type="uint" enum="button_state"/>
+    </event>
+
+    <event name="enter">
+      <description summary="enter event">
+	Notification that this pad is focused on the specified surface.
+      </description>
+      <arg name="serial" type="uint" summary="serial number of the enter event"/>
+      <arg name="tablet" type="object" interface="zwp_tablet_v2" summary="the tablet the pad is attached to"/>
+      <arg name="surface" type="object" interface="wl_surface" summary="surface the pad is focused on"/>
+    </event>
+
+    <event name="leave">
+      <description summary="leave event">
+	Notification that this pad is no longer focused on the specified
+	surface.
+      </description>
+      <arg name="serial" type="uint" summary="serial number of the leave event"/>
+      <arg name="surface" type="object" interface="wl_surface" summary="surface the pad is no longer focused on"/>
+    </event>
+
+    <event name="removed">
+      <description summary="pad removed event">
+	Sent when the pad has been removed from the system. When a tablet
+	is removed its pad(s) will be removed too.
+
+	When this event is received, the client must destroy all rings, strips
+	and groups that were offered by this pad, and issue wp_tablet_pad.destroy
+	the pad itself.
+      </description>
+    </event>
+  </interface>
+
+  <interface name="zwp_tablet_pad_dial_v2" version="2">
+    <description summary="pad dial">
+      A rotary control, e.g. a dial or a wheel.
+
+      Events on a dial are logically grouped by the wl_tablet_pad_dial.frame
+      event.
+    </description>
+
+    <request name="set_feedback">
+      <description summary="set compositor feedback">
+	Requests the compositor to use the provided feedback string
+	associated with this dial. This request should be issued immediately
+	after a wp_tablet_pad_group.mode_switch event from the corresponding
+	group is received, or whenever the dial is mapped to a different
+	action. See wp_tablet_pad_group.mode_switch for more details.
+
+	Clients are encouraged to provide context-aware descriptions for
+	the actions associated with the dial, and compositors may use this
+	information to offer visual feedback about the button layout
+	(eg. on-screen displays).
+
+	The provided string 'description' is a UTF-8 encoded string to be
+	associated with this ring, and is considered user-visible; general
+	internationalization rules apply.
+
+	The serial argument will be that of the last
+	wp_tablet_pad_group.mode_switch event received for the group of this
+	dial. Requests providing other serials than the most recent one will be
+	ignored.
+      </description>
+      <arg name="description" type="string" summary="dial description"/>
+      <arg name="serial" type="uint" summary="serial of the mode switch event"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the dial object">
+	This destroys the client's resource for this dial object.
+      </description>
+    </request>
+
+    <event name="delta">
+      <description summary="delta movement">
+	Sent whenever the position on a dial changes.
+
+	This event carries the wheel delta as multiples or fractions
+	of 120 with each multiple of 120 representing one logical wheel detent.
+	For example, an axis_value120 of 30 is one quarter of
+	a logical wheel step in the positive direction, a value120 of
+	-240 are two logical wheel steps in the negative direction within the
+	same hardware event. See the wl_pointer.axis_value120 for more details.
+
+	The value120 must not be zero.
+      </description>
+      <arg name="value120" type="int" summary="rotation distance as fraction of 120"/>
+    </event>
+
+    <event name="frame">
+      <description summary="end of a dial event sequence">
+	Indicates the end of a set of events that represent one logical
+	hardware dial event. A client is expected to accumulate the data
+	in all events within the frame before proceeding.
+
+	All wp_tablet_pad_dial events before a wp_tablet_pad_dial.frame event belong
+	logically together.
+
+	A wp_tablet_pad_dial.frame event is sent for every logical event
+	group, even if the group only contains a single wp_tablet_pad_dial
+	event. Specifically, a client may get a sequence: delta, frame,
+	delta, frame, etc.
+      </description>
+      <arg name="time" type="uint" summary="timestamp with millisecond granularity"/>
+    </event>
+  </interface>
+</protocol>
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 08cbb8c6979..45c768f7917 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -199,6 +199,12 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         process_wayland.wp_fractional_scale_manager_v1 =
             wl_registry_bind(registry, id, &wp_fractional_scale_manager_v1_interface, 1);
     }
+    else if (strcmp(interface, "wp_cursor_shape_manager_v1") == 0)
+    {
+        process_wayland.wp_cursor_shape_manager_v1 =
+            wl_registry_bind(registry, id, &wp_cursor_shape_manager_v1_interface,
+                             version < 2 ? version : 2);
+    }
 }
 
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 257735dc909..ebd09d87b2a 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -29,11 +29,81 @@
 #include <math.h>
 #include <stdlib.h>
 
+#define OEMRESOURCE
+
 #include "waylanddrv.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+struct system_cursors
+{
+    WORD id;
+    enum wp_cursor_shape_device_v1_shape shape;
+};
+
+static const struct system_cursors user32_cursors[] =
+{
+    {OCR_NORMAL,      WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_DEFAULT},
+    {OCR_IBEAM,       WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_TEXT},
+    {OCR_WAIT,        WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_WAIT},
+    {OCR_CROSS,       WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_CROSSHAIR},
+    {OCR_SIZE,        WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ALL_RESIZE},
+    {OCR_SIZENWSE,    WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NWSE_RESIZE},
+    {OCR_SIZENESW,    WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NESW_RESIZE},
+    {OCR_SIZEWE,      WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_EW_RESIZE},
+    {OCR_SIZENS,      WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NS_RESIZE},
+    {OCR_SIZEALL,     WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ALL_RESIZE},
+    {OCR_NO,          WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NOT_ALLOWED},
+    {OCR_HAND,        WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_POINTER},
+    {OCR_APPSTARTING, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_PROGRESS},
+    {OCR_HELP,        WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_HELP},
+    {OCR_RDR2DIM,     WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ALL_SCROLL},
+    {0}
+};
+
+static const struct system_cursors comctl32_cursors[] =
+{
+    {102, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_MOVE},
+    {104, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_COPY},
+    {105, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_DEFAULT},
+    {106, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_COL_RESIZE},
+    {107, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_COL_RESIZE},
+    {108, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_POINTER},
+    {135, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ROW_RESIZE},
+    {0}
+};
+
+static const struct system_cursors ole32_cursors[] =
+{
+    {1, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NO_DROP},
+    {2, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_MOVE},
+    {3, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_COPY},
+    {4, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ALIAS},
+    {0}
+};
+
+static const struct system_cursors riched20_cursors[] =
+{
+    {105, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_POINTER},
+    {109, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_COPY},
+    {110, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_MOVE},
+    {111, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NO_DROP},
+    {0}
+};
+
+static const struct
+{
+    const struct system_cursors *cursors;
+    WCHAR name[16];
+} module_cursors[] =
+{
+    {user32_cursors, {'u','s','e','r','3','2','.','d','l','l',0}},
+    {comctl32_cursors, {'c','o','m','c','t','l','3','2','.','d','l','l',0}},
+    {ole32_cursors, {'o','l','e','3','2','.','d','l','l',0}},
+    {riched20_cursors, {'r','i','c','h','e','d','2','0','.','d','l','l',0}}
+};
+
 static HWND wayland_pointer_get_focused_hwnd(void)
 {
     struct wayland_pointer *pointer = &process_wayland.pointer;
@@ -350,6 +420,11 @@ void wayland_pointer_deinit(void)
         zwp_relative_pointer_v1_destroy(pointer->zwp_relative_pointer_v1);
         pointer->zwp_relative_pointer_v1 = NULL;
     }
+    if (pointer->wp_cursor_shape_device_v1)
+    {
+        wp_cursor_shape_device_v1_destroy(pointer->wp_cursor_shape_device_v1);
+        pointer->wp_cursor_shape_device_v1 = NULL;
+    }
     wl_pointer_release(pointer->wl_pointer);
     pointer->wl_pointer = NULL;
     pointer->focused_hwnd = NULL;
@@ -509,6 +584,27 @@ clear_cursor:
     }
 }
 
+static void wayland_pointer_clear_cursor_surface(void)
+{
+    struct wayland_cursor *cursor = &process_wayland.pointer.cursor;
+
+    if (cursor->wp_viewport)
+    {
+        wp_viewport_destroy(cursor->wp_viewport);
+        cursor->wp_viewport = NULL;
+    }
+    if (cursor->wl_surface)
+    {
+        wl_surface_destroy(cursor->wl_surface);
+        cursor->wl_surface = NULL;
+    }
+    if (cursor->shm_buffer)
+    {
+        wayland_shm_buffer_unref(cursor->shm_buffer);
+        cursor->shm_buffer = NULL;
+    }
+}
+
 static void wayland_pointer_update_cursor_surface(double scale)
 {
     struct wayland_cursor *cursor = &process_wayland.pointer.cursor;
@@ -557,21 +653,7 @@ static void wayland_pointer_update_cursor_surface(double scale)
     return;
 
 clear_cursor:
-    if (cursor->shm_buffer)
-    {
-        wayland_shm_buffer_unref(cursor->shm_buffer);
-        cursor->shm_buffer = NULL;
-    }
-    if (cursor->wp_viewport)
-    {
-        wp_viewport_destroy(cursor->wp_viewport);
-        cursor->wp_viewport = NULL;
-    }
-    if (cursor->wl_surface)
-    {
-        wl_surface_destroy(cursor->wl_surface);
-        cursor->wl_surface = NULL;
-    }
+    wayland_pointer_clear_cursor_surface();
 }
 
 static void reapply_cursor_clipping(void)
@@ -582,6 +664,77 @@ static void reapply_cursor_clipping(void)
     NtUserSetThreadDpiAwarenessContext(context);
 }
 
+static enum wp_cursor_shape_device_v1_shape cursor_shape_from_info(ICONINFOEXW *info,
+                                                                   uint32_t proto_version)
+{
+    const struct system_cursors *cursors;
+    const WCHAR *module;
+    unsigned int i;
+    enum wp_cursor_shape_device_v1_shape shape = 0;
+
+    if (!info->szModName[0]) return 0;
+    if ((module = wcsrchr(info->szModName, '\\'))) module++;
+    else module = info->szModName;
+    for (i = 0; i < ARRAY_SIZE(module_cursors); i++)
+        if (!wcsicmp(module, module_cursors[i].name)) break;
+    if (i == ARRAY_SIZE(module_cursors)) return 0;
+
+    cursors = module_cursors[i].cursors;
+    for (i = 0; cursors[i].id; i++)
+    {
+        if (cursors[i].id == info->wResID)
+        {
+            shape = cursors[i].shape;
+            break;
+        }
+    }
+
+    if (shape >= WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_DND_ASK && proto_version < 2)
+        shape = 0;
+
+    return shape;
+}
+
+static BOOL wayland_pointer_set_cursor_shape(HCURSOR hcursor)
+{
+    struct wayland_pointer *pointer = &process_wayland.pointer;
+    ICONINFOEXW info = {0};
+    enum wp_cursor_shape_device_v1_shape shape = 0;
+    uint32_t proto_version;
+
+    if (!option_use_system_cursors) return FALSE;
+    if (!process_wayland.wp_cursor_shape_manager_v1) return FALSE;
+    if (!hcursor) return FALSE;
+    if (!get_icon_info(hcursor, &info)) return FALSE;
+    proto_version = wp_cursor_shape_manager_v1_get_version(
+        process_wayland.wp_cursor_shape_manager_v1);
+    if (!(shape = cursor_shape_from_info(&info, proto_version))) return FALSE;
+
+    if (!pointer->wp_cursor_shape_device_v1)
+    {
+        pointer->wp_cursor_shape_device_v1 =
+            wp_cursor_shape_manager_v1_get_pointer(
+                process_wayland.wp_cursor_shape_manager_v1, pointer->wl_pointer);
+        if (!pointer->wp_cursor_shape_device_v1) return FALSE;
+    }
+
+    wp_cursor_shape_device_v1_set_shape(pointer->wp_cursor_shape_device_v1,
+                                        pointer->enter_serial, shape);
+
+    return TRUE;
+}
+
+static void wayland_pointer_clear_cursor_shape(void)
+{
+    struct wayland_pointer *pointer = &process_wayland.pointer;
+
+    if (pointer->wp_cursor_shape_device_v1)
+    {
+        wp_cursor_shape_device_v1_destroy(pointer->wp_cursor_shape_device_v1);
+        pointer->wp_cursor_shape_device_v1 = NULL;
+    }
+}
+
 static void wayland_set_cursor(HWND hwnd, HCURSOR hcursor, BOOL use_hcursor)
 {
     struct wayland_pointer *pointer = &process_wayland.pointer;
@@ -611,13 +764,22 @@ static void wayland_set_cursor(HWND hwnd, HCURSOR hcursor, BOOL use_hcursor)
     pthread_mutex_lock(&pointer->mutex);
     if (pointer->focused_hwnd == hwnd)
     {
-        if (use_hcursor) wayland_pointer_update_cursor_buffer(hcursor, scale);
-        wayland_pointer_update_cursor_surface(scale);
-        wl_pointer_set_cursor(pointer->wl_pointer,
-                              pointer->enter_serial,
-                              pointer->cursor.wl_surface,
-                              pointer->cursor.hotspot_x,
-                              pointer->cursor.hotspot_y);
+        if ((!use_hcursor && pointer->wp_cursor_shape_device_v1) ||
+            (use_hcursor && hcursor && wayland_pointer_set_cursor_shape(hcursor)))
+        {
+            wayland_pointer_clear_cursor_surface();
+        }
+        else
+        {
+            if (use_hcursor) wayland_pointer_update_cursor_buffer(hcursor, scale);
+            wayland_pointer_update_cursor_surface(scale);
+            wl_pointer_set_cursor(pointer->wl_pointer,
+                                  pointer->enter_serial,
+                                  pointer->cursor.wl_surface,
+                                  pointer->cursor.hotspot_x,
+                                  pointer->cursor.hotspot_y);
+            wayland_pointer_clear_cursor_shape();
+        }
         wl_display_flush(process_wayland.wl_display);
         reapply_clip = TRUE;
     }
@@ -700,6 +862,7 @@ static void wayland_pointer_update_constraint(struct wl_surface *wl_surface,
 {
     struct wayland_pointer *pointer = &process_wayland.pointer;
     BOOL needs_relative, needs_lock, needs_confine;
+    BOOL is_visible;
     static unsigned int once;
 
     if (!process_wayland.zwp_pointer_constraints_v1)
@@ -709,11 +872,12 @@ static void wayland_pointer_update_constraint(struct wl_surface *wl_surface,
         return;
     }
 
-    needs_lock = wl_surface && (((confine_rect || covers_vscreen) &&
-                 !pointer->cursor.wl_surface) || force_lock) &&
+    is_visible = pointer->cursor.wl_surface || pointer->wp_cursor_shape_device_v1;
+    needs_lock = wl_surface &&
+                 (((confine_rect || covers_vscreen) && !is_visible) || force_lock) &&
                  pointer->wl_pointer;
-    needs_confine = wl_surface && confine_rect && pointer->cursor.wl_surface &&
-                 !force_lock && pointer->wl_pointer;
+    needs_confine = wl_surface && confine_rect && is_visible && !force_lock &&
+                    pointer->wl_pointer;
 
     if (!needs_confine && pointer->zwp_confined_pointer_v1)
     {
@@ -795,8 +959,7 @@ static void wayland_pointer_update_constraint(struct wl_surface *wl_surface,
         return;
     }
 
-    needs_relative = !pointer->cursor.wl_surface &&
-                     pointer->constraint_hwnd &&
+    needs_relative = !is_visible && pointer->constraint_hwnd &&
                      pointer->constraint_hwnd == pointer->focused_hwnd;
 
     if (needs_relative && !pointer->zwp_relative_pointer_v1)
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 5e04b410202..0848d683ef7 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -38,6 +38,8 @@
 #include "wlr-data-control-unstable-v1-client-protocol.h"
 #include "xdg-toplevel-icon-v1-client-protocol.h"
 #include "fractional-scale-v1-client-protocol.h"
+#include "tablet-v2-client-protocol.h"
+#include "cursor-shape-v1-client-protocol.h"
 
 #include "windef.h"
 #include "winbase.h"
@@ -57,6 +59,7 @@
 
 extern char *process_name;
 extern struct wayland process_wayland;
+extern BOOL option_use_system_cursors;
 
 /**********************************************************************
  *          Definitions for wayland types
@@ -107,6 +110,7 @@ struct wayland_pointer
     struct zwp_confined_pointer_v1 *zwp_confined_pointer_v1;
     struct zwp_locked_pointer_v1 *zwp_locked_pointer_v1;
     struct zwp_relative_pointer_v1 *zwp_relative_pointer_v1;
+    struct wp_cursor_shape_device_v1 *wp_cursor_shape_device_v1;
     HWND focused_hwnd;
     HWND constraint_hwnd;
     BOOL pending_warp;
@@ -174,6 +178,7 @@ struct wayland
     struct zwlr_data_control_manager_v1 *zwlr_data_control_manager_v1;
     struct wl_data_device_manager *wl_data_device_manager;
     struct xdg_toplevel_icon_manager_v1 *xdg_toplevel_icon_manager_v1;
+    struct wp_cursor_shape_manager_v1 *wp_cursor_shape_manager_v1;
     struct wayland_seat seat;
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 5486cc934ef..60d2fc70ff9 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -31,7 +31,11 @@
 
 #include "waylanddrv.h"
 
+#define IS_OPTION_TRUE(ch) \
+    ((ch) == 'y' || (ch) == 'Y' || (ch) == 't' || (ch) == 'T' || (ch) == '1')
+
 char *process_name = NULL;
+BOOL option_use_system_cursors = TRUE;
 
 static const struct user_driver_funcs waylanddrv_funcs =
 {
@@ -56,6 +60,147 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pwine_get_wgl_driver = WAYLAND_wine_get_wgl_driver,
 };
 
+static inline void ascii_to_unicode(WCHAR *dst, const char *src, size_t len)
+{
+    while (len--) *dst++ = (unsigned char)*src++;
+}
+
+static inline UINT asciiz_to_unicode(WCHAR *dst, const char *src)
+{
+    WCHAR *p = dst;
+    while ((*p++ = *src++));
+    return (p - dst) * sizeof(WCHAR);
+}
+
+static HKEY reg_open_key(HKEY root, const WCHAR *name, ULONG name_len)
+{
+    UNICODE_STRING nameW = {name_len, name_len, (WCHAR *)name};
+    OBJECT_ATTRIBUTES attr;
+    HANDLE ret;
+
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = root;
+    attr.ObjectName = &nameW;
+    attr.Attributes = 0;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    return NtOpenKeyEx(&ret, MAXIMUM_ALLOWED, &attr, 0) ? 0 : ret;
+}
+
+static HKEY open_hkcu_key(const char *name)
+{
+    WCHAR bufferW[256];
+    static HKEY hkcu;
+
+    if (!hkcu)
+    {
+        char buffer[256];
+        DWORD_PTR sid_data[(sizeof(TOKEN_USER) + SECURITY_MAX_SID_SIZE) / sizeof(DWORD_PTR)];
+        DWORD i, len = sizeof(sid_data);
+        SID *sid;
+
+        if (NtQueryInformationToken(GetCurrentThreadEffectiveToken(), TokenUser, sid_data, len, &len))
+            return 0;
+
+        sid = ((TOKEN_USER *)sid_data)->User.Sid;
+        len = sprintf(buffer, "\\Registry\\User\\S-%u-%lu", sid->Revision,
+               (unsigned long) MAKELONG(MAKEWORD(sid->IdentifierAuthority.Value[5],
+                                        sid->IdentifierAuthority.Value[4]),
+                               MAKEWORD(sid->IdentifierAuthority.Value[3],
+                                        sid->IdentifierAuthority.Value[2])));
+        for (i = 0; i < sid->SubAuthorityCount; i++)
+            len += sprintf(buffer + len, "-%lu", (unsigned long)sid->SubAuthority[i]);
+
+        ascii_to_unicode(bufferW, buffer, len);
+        hkcu = reg_open_key(NULL, bufferW, len * sizeof(WCHAR));
+    }
+
+    return reg_open_key(hkcu, bufferW, asciiz_to_unicode(bufferW, name) - sizeof(WCHAR));
+}
+
+static ULONG query_reg_value(HKEY hkey, const WCHAR *name,
+                             KEY_VALUE_PARTIAL_INFORMATION *info, ULONG size)
+{
+    unsigned int name_size = name ? lstrlenW(name) * sizeof(WCHAR) : 0;
+    UNICODE_STRING nameW = {name_size, name_size, (WCHAR *)name};
+
+    if (NtQueryValueKey(hkey, &nameW, KeyValuePartialInformation,
+                        info, size, &size))
+        return 0;
+
+    return size - FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data);
+}
+
+static inline DWORD get_config_key(HKEY defkey, HKEY appkey, const char *name,
+                                   WCHAR *buffer, DWORD size)
+{
+    WCHAR nameW[128];
+    char buf[2048];
+    KEY_VALUE_PARTIAL_INFORMATION *info = (void *)buf;
+
+    asciiz_to_unicode(nameW, name);
+
+    if (appkey && query_reg_value(appkey, nameW, info, sizeof(buf)))
+    {
+        size = min(info->DataLength, size - sizeof(WCHAR));
+        memcpy(buffer, info->Data, size);
+        buffer[size / sizeof(WCHAR)] = 0;
+        return 0;
+    }
+
+    if (defkey && query_reg_value(defkey, nameW, info, sizeof(buf)))
+    {
+        size = min(info->DataLength, size - sizeof(WCHAR));
+        memcpy(buffer, info->Data, size);
+        buffer[size / sizeof(WCHAR)] = 0;
+        return 0;
+    }
+
+    return ERROR_FILE_NOT_FOUND;
+}
+
+static void wayland_init_options(void)
+{
+    static const WCHAR waylanddriverW[] = {'\\','W','a','y','l','a','n','d',' ','D','r','i','v','e','r',0};
+    WCHAR buffer[MAX_PATH+16], *p, *appname;
+    HKEY hkey, appkey = 0;
+    DWORD len;
+
+    /* @@ Wine registry key: HKCU\Software\Wine\Wayland Driver */
+    hkey = open_hkcu_key("Software\\Wine\\Wayland Driver");
+
+    /* open the app-specific key */
+    appname = NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer;
+    if ((p = wcsrchr(appname, '/'))) appname = p + 1;
+    if ((p = wcsrchr(appname, '\\'))) appname = p + 1;
+    len = lstrlenW(appname);
+
+    if (len && len < MAX_PATH)
+    {
+        HKEY tmpkey;
+        int i;
+        for (i = 0; appname[i]; i++) buffer[i] = RtlDowncaseUnicodeChar(appname[i]);
+        buffer[i] = 0;
+        appname = buffer;
+        if ((process_name = malloc(len * 3 + 1)))
+            ntdll_wcstoumbs(appname, len + 1, process_name, len * 3 + 1, FALSE);
+        memcpy(appname + i, waylanddriverW, sizeof(waylanddriverW));
+        /* @@ Wine registry key: HKCU\Software\Wine\AppDefaults\app.exe\Wayland Driver */
+        if ((tmpkey = open_hkcu_key("Software\\Wine\\AppDefaults")))
+        {
+            appkey = reg_open_key(tmpkey, appname, lstrlenW(appname) * sizeof(WCHAR));
+            NtClose(tmpkey);
+        }
+    }
+
+    if (!get_config_key(hkey, appkey, "UseSystemCursors", buffer, sizeof(buffer)))
+        option_use_system_cursors = IS_OPTION_TRUE(buffer[0]);
+
+    NtClose(appkey);
+    NtClose(hkey);
+}
+
 static void wayland_init_process_name(void)
 {
     WCHAR *p, *appname;
@@ -91,6 +236,7 @@ static NTSTATUS waylanddrv_unix_init(void *arg)
     __wine_set_user_driver(&waylanddrv_funcs, WINE_GDI_DRIVER_VERSION);
 
     wayland_init_process_name();
+    wayland_init_options();
 
     if (!wayland_process_init()) goto err;
 
-- 
2.49.0

From e076fb6ae5c0999bd18a75b9f097acd634f5bd11 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Wed, 7 May 2025 08:37:02 -0400
Subject: [PATCH 031/159] Avoid long types on the Unix side.

Co-Authored-By: Alexandre Julliard <1130500+julliard@users.noreply.github.com>
---
 dlls/ntdll/unix/signal_arm.c           | 10 +++++-----
 dlls/ntdll/unix/signal_i386.c          | 20 ++++++++++----------
 dlls/winewayland.drv/waylanddrv_main.c |  6 +++---
 include/basetsd.h                      |  4 ++--
 include/ntdef.h                        |  2 +-
 include/verrsrc.h                      |  2 +-
 include/windef.h                       |  4 ++--
 include/winerror.h                     |  2 +-
 include/winnt.h                        |  4 ++--
 9 files changed, 27 insertions(+), 27 deletions(-)

diff --git a/dlls/ntdll/unix/signal_arm.c b/dlls/ntdll/unix/signal_arm.c
index c8b67929aff..7fcd68d24d9 100644
--- a/dlls/ntdll/unix/signal_arm.c
+++ b/dlls/ntdll/unix/signal_arm.c
@@ -785,18 +785,18 @@ static BOOL handle_syscall_fault( ucontext_t *context, EXCEPTION_RECORD *rec )
 
     if (!is_inside_syscall( context )) return FALSE;
 
-    TRACE( "code=%lx flags=%lx addr=%p pc=%08lx\n",
+    TRACE( "code=%x flags=%x addr=%p pc=%08x\n",
            rec->ExceptionCode, rec->ExceptionFlags, rec->ExceptionAddress, (DWORD)PC_sig(context) );
     for (i = 0; i < rec->NumberParameters; i++)
         TRACE( " info[%d]=%08lx\n", i, rec->ExceptionInformation[i] );
 
-    TRACE( " r0=%08lx r1=%08lx r2=%08lx r3=%08lx r4=%08lx r5=%08lx\n",
+    TRACE( " r0=%08x r1=%08x r2=%08x r3=%08x r4=%08x r5=%08x\n",
            (DWORD)REGn_sig(0, context), (DWORD)REGn_sig(1, context), (DWORD)REGn_sig(2, context),
            (DWORD)REGn_sig(3, context), (DWORD)REGn_sig(4, context), (DWORD)REGn_sig(5, context) );
-    TRACE( " r6=%08lx r7=%08lx r8=%08lx r9=%08lx r10=%08lx r11=%08lx\n",
+    TRACE( " r6=%08x r7=%08x r8=%08x r9=%08x r10=%08x r11=%08x\n",
            (DWORD)REGn_sig(6, context), (DWORD)REGn_sig(7, context), (DWORD)REGn_sig(8, context),
            (DWORD)REGn_sig(9, context), (DWORD)REGn_sig(10, context), (DWORD)FP_sig(context) );
-    TRACE( " r12=%08lx sp=%08lx lr=%08lx pc=%08lx cpsr=%08lx\n",
+    TRACE( " r12=%08x sp=%08x lr=%08x pc=%08x cpsr=%08x\n",
            (DWORD)IP_sig(context), (DWORD)SP_sig(context), (DWORD)LR_sig(context),
            (DWORD)PC_sig(context), (DWORD)CPSR_sig(context) );
 
@@ -814,7 +814,7 @@ static BOOL handle_syscall_fault( ucontext_t *context, EXCEPTION_RECORD *rec )
     }
     else
     {
-        TRACE( "returning to user mode ip=%08x ret=%08lx\n", frame->pc, rec->ExceptionCode );
+        TRACE( "returning to user mode ip=%08x ret=%08x\n", frame->pc, rec->ExceptionCode );
         REGn_sig(0, context) = (DWORD)frame;
         REGn_sig(1, context) = rec->ExceptionCode;
         PC_sig(context)      = (DWORD)__wine_syscall_dispatcher_return;
diff --git a/dlls/ntdll/unix/signal_i386.c b/dlls/ntdll/unix/signal_i386.c
index 33958f76ee9..323e2654258 100644
--- a/dlls/ntdll/unix/signal_i386.c
+++ b/dlls/ntdll/unix/signal_i386.c
@@ -1178,16 +1178,16 @@ NTSTATUS WINAPI NtGetContextThread( HANDLE handle, CONTEXT *context )
     }
 
     if (context->ContextFlags & (CONTEXT_INTEGER & ~CONTEXT_i386))
-        TRACE( "%p: eax=%08lx ebx=%08lx ecx=%08lx edx=%08lx esi=%08lx edi=%08lx\n", handle,
+        TRACE( "%p: eax=%08x ebx=%08x ecx=%08x edx=%08x esi=%08x edi=%08x\n", handle,
                context->Eax, context->Ebx, context->Ecx, context->Edx, context->Esi, context->Edi );
     if (context->ContextFlags & (CONTEXT_CONTROL & ~CONTEXT_i386))
-        TRACE( "%p: ebp=%08lx esp=%08lx eip=%08lx cs=%04lx ss=%04lx flags=%08lx\n", handle,
+        TRACE( "%p: ebp=%08x esp=%08x eip=%08x cs=%04x ss=%04x flags=%08x\n", handle,
                context->Ebp, context->Esp, context->Eip, context->SegCs, context->SegSs, context->EFlags );
     if (context->ContextFlags & (CONTEXT_SEGMENTS & ~CONTEXT_i386))
-        TRACE( "%p: ds=%04lx es=%04lx fs=%04lx gs=%04lx\n", handle,
+        TRACE( "%p: ds=%04x es=%04x fs=%04x gs=%04x\n", handle,
                context->SegDs, context->SegEs, context->SegFs, context->SegGs );
     if (context->ContextFlags & (CONTEXT_DEBUG_REGISTERS & ~CONTEXT_i386))
-        TRACE( "%p: dr0=%08lx dr1=%08lx dr2=%08lx dr3=%08lx dr6=%08lx dr7=%08lx\n", handle,
+        TRACE( "%p: dr0=%08x dr1=%08x dr2=%08x dr3=%08x dr6=%08x dr7=%08x\n", handle,
                context->Dr0, context->Dr1, context->Dr2, context->Dr3, context->Dr6, context->Dr7 );
 
     return STATUS_SUCCESS;
@@ -1311,7 +1311,7 @@ static inline BOOL check_invalid_gs( ucontext_t *sigcontext, CONTEXT *context )
         instr++;
         continue;
     case 0x65:  /* %gs: */
-        TRACE( "%04lx/%04x at %p, fixing up\n", context->SegGs, system_gs, instr );
+        TRACE( "%04x/%04x at %p, fixing up\n", context->SegGs, system_gs, instr );
         GS_sig(sigcontext) = system_gs;
         return TRUE;
     default:
@@ -1829,14 +1829,14 @@ static BOOL handle_syscall_fault( ucontext_t *sigcontext, void *stack_ptr,
 
     if (!is_inside_syscall( sigcontext )) return FALSE;
 
-    TRACE( "code=%lx flags=%lx addr=%p ip=%08lx\n",
+    TRACE( "code=%x flags=%x addr=%p ip=%08x\n",
            rec->ExceptionCode, rec->ExceptionFlags, rec->ExceptionAddress, context->Eip );
     for (i = 0; i < rec->NumberParameters; i++)
         TRACE( " info[%d]=%08lx\n", i, rec->ExceptionInformation[i] );
-    TRACE(" eax=%08lx ebx=%08lx ecx=%08lx edx=%08lx esi=%08lx edi=%08lx\n",
+    TRACE(" eax=%08x ebx=%08x ecx=%08x edx=%08x esi=%08x edi=%08x\n",
           context->Eax, context->Ebx, context->Ecx,
           context->Edx, context->Esi, context->Edi );
-    TRACE(" ebp=%08lx esp=%08lx cs=%04lx ds=%04lx es=%04lx fs=%04lx gs=%04lx flags=%08lx\n",
+    TRACE(" ebp=%08x esp=%08x cs=%04x ds=%04x es=%04x fs=%04x gs=%04x flags=%08x\n",
           context->Ebp, context->Esp, context->SegCs, context->SegDs,
           context->SegEs, context->SegFs, context->SegGs, context->EFlags );
 
@@ -1858,10 +1858,10 @@ static BOOL handle_syscall_fault( ucontext_t *sigcontext, void *stack_ptr,
     }
     else
     {
-        WINE_BACKTRACE_LOG( "--- Exception %#lx at %s.\n", rec->ExceptionCode,
+        WINE_BACKTRACE_LOG( "--- Exception %#x at %s.\n", rec->ExceptionCode,
                             wine_debuginfostr_pc( rec->ExceptionAddress ));
 
-        TRACE( "returning to user mode ip=%08x ret=%08lx\n", frame->eip, rec->ExceptionCode );
+        TRACE( "returning to user mode ip=%08x ret=%08x\n", frame->eip, rec->ExceptionCode );
         stack = (UINT *)frame;
         *(--stack) = rec->ExceptionCode;
         *(--stack) = (UINT)frame;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 60d2fc70ff9..640a70be20e 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -104,13 +104,13 @@ static HKEY open_hkcu_key(const char *name)
             return 0;
 
         sid = ((TOKEN_USER *)sid_data)->User.Sid;
-        len = sprintf(buffer, "\\Registry\\User\\S-%u-%lu", sid->Revision,
-               (unsigned long) MAKELONG(MAKEWORD(sid->IdentifierAuthority.Value[5],
+        len = sprintf(buffer, "\\Registry\\User\\S-%u-%u", sid->Revision,
+                      MAKELONG(MAKEWORD(sid->IdentifierAuthority.Value[5],
                                         sid->IdentifierAuthority.Value[4]),
                                MAKEWORD(sid->IdentifierAuthority.Value[3],
                                         sid->IdentifierAuthority.Value[2])));
         for (i = 0; i < sid->SubAuthorityCount; i++)
-            len += sprintf(buffer + len, "-%lu", (unsigned long)sid->SubAuthority[i]);
+            len += sprintf(buffer + len, "-%u", sid->SubAuthority[i]);
 
         ascii_to_unicode(bufferW, buffer, len);
         hkcu = reg_open_key(NULL, bufferW, len * sizeof(WCHAR));
diff --git a/include/basetsd.h b/include/basetsd.h
index 3f1f8557aa4..6eb7656e605 100644
--- a/include/basetsd.h
+++ b/include/basetsd.h
@@ -160,7 +160,7 @@ typedef unsigned int UHALF_PTR, *PUHALF_PTR;
 
 #if !defined(__midl) && !defined(__WIDL__)
 
-#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES)
+#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES) && !defined(WINE_UNIX_LIB)
 
 static inline unsigned long HandleToULong(const void *h)
 {
@@ -206,7 +206,7 @@ static inline int PtrToLong(const void *p)
 }
 
 
-#endif /* !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES) */
+#endif /* !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES) && !defined(WINE_UNIX_LIB) */
 
 static inline void *ULongToHandle(ULONG32 ul)
 {
diff --git a/include/ntdef.h b/include/ntdef.h
index e840bd3f9fe..8f7e8fae826 100644
--- a/include/ntdef.h
+++ b/include/ntdef.h
@@ -55,7 +55,7 @@ typedef enum _WAIT_TYPE {
 #define BASETYPES
 typedef unsigned char UCHAR, *PUCHAR;
 typedef unsigned short USHORT, *PUSHORT;
-#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES)
+#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES) && !defined(WINE_UNIX_LIB)
 typedef unsigned long ULONG, *PULONG;
 #else
 typedef unsigned int ULONG, *PULONG;
diff --git a/include/verrsrc.h b/include/verrsrc.h
index e13165a7d2e..0b9897a5ed1 100644
--- a/include/verrsrc.h
+++ b/include/verrsrc.h
@@ -22,7 +22,7 @@
 
 /* Macro to deal with LP64 <=> LLP64 differences in numeric constants with 'l' modifier */
 #ifndef __MSABI_LONG
-#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES)
+#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES) && !defined(WINE_UNIX_LIB)
 #  define __MSABI_LONG(x)         x ## l
 # else
 #  define __MSABI_LONG(x)         x
diff --git a/include/windef.h b/include/windef.h
index 0a6d308b837..a88e43f5e3f 100644
--- a/include/windef.h
+++ b/include/windef.h
@@ -210,7 +210,7 @@ extern "C" {
 #define BASETYPES
 typedef unsigned char UCHAR, *PUCHAR;
 typedef unsigned short USHORT, *PUSHORT;
-#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES)
+#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES) && !defined(WINE_UNIX_LIB)
 typedef unsigned long ULONG, *PULONG;
 #else
 typedef unsigned int ULONG, *PULONG;
@@ -226,7 +226,7 @@ typedef int             INT,        *PINT,     *LPINT;
 typedef unsigned int    UINT,       *PUINT;
 typedef float           FLOAT,      *PFLOAT;
 typedef char                        *PSZ;
-#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES)
+#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES) && !defined(WINE_UNIX_LIB)
 typedef long                                   *LPLONG;
 typedef unsigned long   DWORD,      *PDWORD,   *LPDWORD;
 #else
diff --git a/include/winerror.h b/include/winerror.h
index 8ef582d2c69..57fede1ab6e 100644
--- a/include/winerror.h
+++ b/include/winerror.h
@@ -199,7 +199,7 @@
 #define __HRESULT_FROM_WIN32(x)   ((HRESULT)(x) > 0 ? ((HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000)) : (HRESULT)(x) )
 #ifndef _HRESULT_DEFINED
 #define _HRESULT_DEFINED
-#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES)
+#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES) && !defined(WINE_UNIX_LIB)
 typedef long HRESULT;
 #else
 typedef int HRESULT;
diff --git a/include/winnt.h b/include/winnt.h
index a361582045a..7e6f8fcc684 100644
--- a/include/winnt.h
+++ b/include/winnt.h
@@ -479,7 +479,7 @@ typedef VOID           *PVOID64;
 typedef BYTE            BOOLEAN,    *PBOOLEAN;
 typedef char            CHAR,       *PCHAR;
 typedef short           SHORT,      *PSHORT;
-#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES)
+#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES) && !defined(WINE_UNIX_LIB)
 typedef long            LONG,       *PLONG;
 #else
 typedef int             LONG,       *PLONG;
@@ -617,7 +617,7 @@ typedef DWORD FLONG;
 
 /* Macro to deal with LP64 <=> LLP64 differences in numeric constants with 'l' modifier */
 #ifndef __MSABI_LONG
-#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES)
+#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES) && !defined(WINE_UNIX_LIB)
 #  define __MSABI_LONG(x)         x ## l
 # else
 #  define __MSABI_LONG(x)         x
-- 
2.49.0

From 9abc3f732b35efb627e417444413bad15715ce90 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Fri, 9 May 2025 08:32:12 -0400
Subject: [PATCH 033/159] winewayland: ensure egl_display is not
 EGL_BAD_PARAMETER

---
 dlls/winewayland.drv/opengl.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 36989b9c745..0d7bf00ea0f 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -1383,7 +1383,7 @@ static void init_opengl(void)
     egl_display = p_eglGetPlatformDisplay(EGL_PLATFORM_WAYLAND_KHR,
                                           process_wayland.wl_display,
                                           NULL);
-    if (egl_display == EGL_NO_DISPLAY)
+    if (egl_display == EGL_NO_DISPLAY || egl_display == (void *)EGL_BAD_PARAMETER)
     {
         ERR("Failed to get EGLDisplay\n");
         goto err;
-- 
2.49.0

From a46d74a29df93f5bd732e3502966f76a548e8a21 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Fri, 9 May 2025 08:38:26 -0400
Subject: [PATCH 034/159] Add amdxc implementation

---
 .gitignore                        |   1 +
 configure.ac                      |   1 +
 dlls/amdxc64/Makefile.in          |  10 +
 dlls/amdxc64/amdxc64.spec         | 315 +++++++++++++++++++++++++++++
 dlls/amdxc64/amdxc_interfaces.idl |  96 +++++++++
 dlls/amdxc64/dxvk_interfaces.idl  | 153 ++++++++++++++
 dlls/amdxc64/main.c               | 317 ++++++++++++++++++++++++++++++
 7 files changed, 893 insertions(+)
 create mode 100644 dlls/amdxc64/Makefile.in
 create mode 100644 dlls/amdxc64/amdxc64.spec
 create mode 100644 dlls/amdxc64/amdxc_interfaces.idl
 create mode 100644 dlls/amdxc64/dxvk_interfaces.idl
 create mode 100644 dlls/amdxc64/main.c

diff --git a/.gitignore b/.gitignore
index 66d83f5f1d4..57c66ae4053 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,2 +1,3 @@
 .idea
 compile_commands.json
+.cache
diff --git a/configure.ac b/configure.ac
index 9acc7ce2845..dff8f27cedc 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2456,6 +2456,7 @@ WINE_CONFIG_MAKEFILE(dlls/advpack)
 WINE_CONFIG_MAKEFILE(dlls/advpack/tests)
 WINE_CONFIG_MAKEFILE(dlls/amsi)
 WINE_CONFIG_MAKEFILE(dlls/amd_ags_x64)
+WINE_CONFIG_MAKEFILE(dlls/amdxc64)
 WINE_CONFIG_MAKEFILE(dlls/amstream)
 WINE_CONFIG_MAKEFILE(dlls/amstream/tests)
 WINE_CONFIG_MAKEFILE(dlls/apisetschema)
diff --git a/dlls/amdxc64/Makefile.in b/dlls/amdxc64/Makefile.in
new file mode 100644
index 00000000000..999a7d043e1
--- /dev/null
+++ b/dlls/amdxc64/Makefile.in
@@ -0,0 +1,10 @@
+MODULE = amdxc64.dll
+IMPORTS = version vulkan-1 user32 gdi32
+IMPORTLIB = amdxc64
+
+EXTRADLLFLAGS = -mno-cygwin
+
+SOURCES = \
+	main.c \
+	dxvk_interfaces.idl \
+	amdxc_interfaces.idl \
diff --git a/dlls/amdxc64/amdxc64.spec b/dlls/amdxc64/amdxc64.spec
new file mode 100644
index 00000000000..2daa1ddbc94
--- /dev/null
+++ b/dlls/amdxc64/amdxc64.spec
@@ -0,0 +1,315 @@
+1 stub ??0?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_IR_MODE_SELECTOR@@@detail@archive@boost@@QEAA@XZ
+2 stub ??0?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_MINIMIZE_VGPRS_STRATEGY@@@detail@archive@boost@@QEAA@XZ
+3 stub ??0?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_NPI_DISABLE@@@detail@archive@boost@@QEAA@XZ
+4 stub ??0?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_THREAD_LATENCY_STRATEGY@@@detail@archive@boost@@QEAA@XZ
+5 stub ??0?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_USE_MORE_D16_SELECTOR@@@detail@archive@boost@@QEAA@XZ
+6 stub ??0?$oserializer@Vsc_xml_oarchive@@T_SC_COMPILE_FLAGS@@@detail@archive@boost@@QEAA@XZ
+7 stub ??0?$oserializer@Vsc_xml_oarchive@@T_SC_LAUNCH_MODE_FLAGS@@@detail@archive@boost@@QEAA@XZ
+8 stub ??0?$oserializer@Vsc_xml_oarchive@@T_SC_SI_GLC_CONTROL@@@detail@archive@boost@@QEAA@XZ
+9 stub ??0?$oserializer@Vsc_xml_oarchive@@T_SC_SI_SLC_CONTROL@@@detail@archive@boost@@QEAA@XZ
+10 stub ??0?$oserializer@Vsc_xml_oarchive@@USC_INPUT@@@detail@archive@boost@@QEAA@XZ
+11 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY@serialization@boost@@@detail@archive@boost@@QEAA@XZ
+12 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_ATOMIC@@@detail@archive@boost@@QEAA@XZ
+13 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_CONTROL@@@detail@archive@boost@@QEAA@XZ
+14 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_READ@@@detail@archive@boost@@QEAA@XZ
+15 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_WRITE@@@detail@archive@boost@@QEAA@XZ
+16 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_CBCONSTVALUES@@@detail@archive@boost@@QEAA@XZ
+17 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_CBRCONSTVALUES@@@detail@archive@boost@@QEAA@XZ
+18 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_CI_TRANSFORM_SHADER_DESC@@@detail@archive@boost@@QEAA@XZ
+19 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_CONSTANTUSAGE@@@detail@archive@boost@@QEAA@XZ
+20 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_CPS_CONFIG@@@detail@archive@boost@@QEAA@XZ
+21 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_FLOAT_CONST@@@detail@archive@boost@@QEAA@XZ
+22 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_INT_CONST@@@detail@archive@boost@@QEAA@XZ
+23 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_CB_OFFSET_LUT@@@detail@archive@boost@@QEAA@XZ
+24 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_CONTROL_FLAGS@@@detail@archive@boost@@QEAA@XZ
+25 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_VPORT_CONTROLS_LUT@@@detail@archive@boost@@QEAA@XZ
+26 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_PS_EXPORT_INFO@@@detail@archive@boost@@QEAA@XZ
+27 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SHADERSTATE@@@detail@archive@boost@@QEAA@XZ
+28 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SI_DATA_IN_OUT@@@detail@archive@boost@@QEAA@XZ
+29 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SI_DESCRIPTOR_VALUES@@@detail@archive@boost@@QEAA@XZ
+30 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SI_OPTIMIZATIONS@@@detail@archive@boost@@QEAA@XZ
+31 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SI_PSSHADERDCL_IN@@@detail@archive@boost@@QEAA@XZ
+32 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SI_PS_ATTR_CH_ENTRY@@@detail@archive@boost@@QEAA@XZ
+33 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@QEAA@XZ
+34 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SI_STREAMIODCL_OUT@@@detail@archive@boost@@QEAA@XZ
+35 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SI_USER_DATA_ELEMENT@@@detail@archive@boost@@QEAA@XZ
+36 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@QEAA@XZ
+37 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@QEAA@XZ
+38 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_TXCONSTVALUES@@@detail@archive@boost@@QEAA@XZ
+39 stub ??0?$oserializer@Vsc_xml_oarchive@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@detail@archive@boost@@QEAA@XZ
+40 stub ??0?$singleton@V?$extended_type_info_typeid@T_E_SC_SI_OPT_IR_MODE_SELECTOR@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+41 stub ??0?$singleton@V?$extended_type_info_typeid@T_E_SC_SI_OPT_MINIMIZE_VGPRS_STRATEGY@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+42 stub ??0?$singleton@V?$extended_type_info_typeid@T_E_SC_SI_OPT_NPI_DISABLE@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+43 stub ??0?$singleton@V?$extended_type_info_typeid@T_E_SC_SI_OPT_THREAD_LATENCY_STRATEGY@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+44 stub ??0?$singleton@V?$extended_type_info_typeid@T_E_SC_SI_OPT_USE_MORE_D16_SELECTOR@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+45 stub ??0?$singleton@V?$extended_type_info_typeid@T_SC_COMPILE_FLAGS@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+46 stub ??0?$singleton@V?$extended_type_info_typeid@T_SC_LAUNCH_MODE_FLAGS@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+47 stub ??0?$singleton@V?$extended_type_info_typeid@T_SC_SI_GLC_CONTROL@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+48 stub ??0?$singleton@V?$extended_type_info_typeid@T_SC_SI_SLC_CONTROL@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+49 stub ??0?$singleton@V?$extended_type_info_typeid@USC_INPUT@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+50 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_CACHE_POLICY@serialization@boost@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+51 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_CACHE_POLICY_ATOMIC@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+52 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_CACHE_POLICY_CONTROL@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+53 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_CACHE_POLICY_READ@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+54 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_CACHE_POLICY_WRITE@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+55 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_CBCONSTVALUES@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+56 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_CBRCONSTVALUES@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+57 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_CI_TRANSFORM_SHADER_DESC@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+58 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_CONSTANTUSAGE@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+59 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_CPS_CONFIG@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+60 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_FLOAT_CONST@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+61 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_INT_CONST@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+62 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_PRIMSHADER_CB_OFFSET_LUT@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+63 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_PRIMSHADER_CONTROL_FLAGS@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+64 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_PRIMSHADER_VPORT_CONTROLS_LUT@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+65 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_PS_EXPORT_INFO@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+66 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SHADERSTATE@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+67 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SI_DATA_IN_OUT@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+68 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SI_DESCRIPTOR_VALUES@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+69 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SI_OPTIMIZATIONS@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+70 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SI_PSSHADERDCL_IN@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+71 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SI_PS_ATTR_CH_ENTRY@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+72 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SI_SHADERSTATE@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+73 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SI_STREAMIODCL_OUT@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+74 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SI_USER_DATA_ELEMENT@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+75 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SRCSHADER@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+76 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SRC_PIPELINE@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+77 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_TXCONSTVALUES@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+78 stub ??0?$singleton@V?$extended_type_info_typeid@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+79 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@T_E_SC_SI_OPT_IR_MODE_SELECTOR@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@T_E_SC_SI_OPT_IR_MODE_SELECTOR@@@23@XZ
+80 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@T_E_SC_SI_OPT_MINIMIZE_VGPRS_STRATEGY@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@T_E_SC_SI_OPT_MINIMIZE_VGPRS_STRATEGY@@@23@XZ
+81 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@T_E_SC_SI_OPT_NPI_DISABLE@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@T_E_SC_SI_OPT_NPI_DISABLE@@@23@XZ
+82 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@T_E_SC_SI_OPT_THREAD_LATENCY_STRATEGY@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@T_E_SC_SI_OPT_THREAD_LATENCY_STRATEGY@@@23@XZ
+83 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@T_E_SC_SI_OPT_USE_MORE_D16_SELECTOR@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@T_E_SC_SI_OPT_USE_MORE_D16_SELECTOR@@@23@XZ
+84 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@T_SC_COMPILE_FLAGS@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@T_SC_COMPILE_FLAGS@@@23@XZ
+85 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@T_SC_LAUNCH_MODE_FLAGS@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@T_SC_LAUNCH_MODE_FLAGS@@@23@XZ
+86 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@T_SC_SI_GLC_CONTROL@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@T_SC_SI_GLC_CONTROL@@@23@XZ
+87 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@T_SC_SI_SLC_CONTROL@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@T_SC_SI_SLC_CONTROL@@@23@XZ
+88 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@USC_INPUT@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@USC_INPUT@@@23@XZ
+89 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_CACHE_POLICY@serialization@boost@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_CACHE_POLICY@serialization@boost@@@23@XZ
+90 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_CACHE_POLICY_ATOMIC@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_CACHE_POLICY_ATOMIC@@@23@XZ
+91 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_CACHE_POLICY_CONTROL@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_CACHE_POLICY_CONTROL@@@23@XZ
+92 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_CACHE_POLICY_READ@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_CACHE_POLICY_READ@@@23@XZ
+93 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_CACHE_POLICY_WRITE@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_CACHE_POLICY_WRITE@@@23@XZ
+94 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_CBCONSTVALUES@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_CBCONSTVALUES@@@23@XZ
+95 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_CBRCONSTVALUES@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_CBRCONSTVALUES@@@23@XZ
+96 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_CI_TRANSFORM_SHADER_DESC@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_CI_TRANSFORM_SHADER_DESC@@@23@XZ
+97 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_CONSTANTUSAGE@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_CONSTANTUSAGE@@@23@XZ
+98 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_CPS_CONFIG@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_CPS_CONFIG@@@23@XZ
+99 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_FLOAT_CONST@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_FLOAT_CONST@@@23@XZ
+100 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_INT_CONST@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_INT_CONST@@@23@XZ
+101 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_PRIMSHADER_CB_OFFSET_LUT@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_PRIMSHADER_CB_OFFSET_LUT@@@23@XZ
+102 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_PRIMSHADER_CONTROL_FLAGS@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_PRIMSHADER_CONTROL_FLAGS@@@23@XZ
+103 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_PRIMSHADER_VPORT_CONTROLS_LUT@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_PRIMSHADER_VPORT_CONTROLS_LUT@@@23@XZ
+104 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_PS_EXPORT_INFO@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_PS_EXPORT_INFO@@@23@XZ
+105 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SHADERSTATE@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SHADERSTATE@@@23@XZ
+106 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SI_DATA_IN_OUT@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SI_DATA_IN_OUT@@@23@XZ
+107 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SI_DESCRIPTOR_VALUES@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SI_DESCRIPTOR_VALUES@@@23@XZ
+108 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SI_OPTIMIZATIONS@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SI_OPTIMIZATIONS@@@23@XZ
+109 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SI_PSSHADERDCL_IN@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SI_PSSHADERDCL_IN@@@23@XZ
+110 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SI_PS_ATTR_CH_ENTRY@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SI_PS_ATTR_CH_ENTRY@@@23@XZ
+111 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SI_SHADERSTATE@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SI_SHADERSTATE@@@23@XZ
+112 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SI_STREAMIODCL_OUT@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SI_STREAMIODCL_OUT@@@23@XZ
+113 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SI_USER_DATA_ELEMENT@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SI_USER_DATA_ELEMENT@@@23@XZ
+114 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SRCSHADER@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SRCSHADER@@@23@XZ
+115 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SRC_PIPELINE@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SRC_PIPELINE@@@23@XZ
+116 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_TXCONSTVALUES@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_TXCONSTVALUES@@@23@XZ
+117 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@23@XZ
+118 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_IR_MODE_SELECTOR@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_IR_MODE_SELECTOR@@@detail@archive@3@XZ
+119 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_MINIMIZE_VGPRS_STRATEGY@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_MINIMIZE_VGPRS_STRATEGY@@@detail@archive@3@XZ
+120 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_NPI_DISABLE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_NPI_DISABLE@@@detail@archive@3@XZ
+121 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_THREAD_LATENCY_STRATEGY@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_THREAD_LATENCY_STRATEGY@@@detail@archive@3@XZ
+122 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_USE_MORE_D16_SELECTOR@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_USE_MORE_D16_SELECTOR@@@detail@archive@3@XZ
+123 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@T_SC_COMPILE_FLAGS@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@T_SC_COMPILE_FLAGS@@@detail@archive@3@XZ
+124 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@T_SC_LAUNCH_MODE_FLAGS@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@T_SC_LAUNCH_MODE_FLAGS@@@detail@archive@3@XZ
+125 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@T_SC_SI_GLC_CONTROL@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@T_SC_SI_GLC_CONTROL@@@detail@archive@3@XZ
+126 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@T_SC_SI_SLC_CONTROL@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@T_SC_SI_SLC_CONTROL@@@detail@archive@3@XZ
+127 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@USC_INPUT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@USC_INPUT@@@detail@archive@3@XZ
+128 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY@serialization@boost@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY@serialization@boost@@@detail@archive@3@XZ
+129 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_ATOMIC@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_ATOMIC@@@detail@archive@3@XZ
+130 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_CONTROL@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_CONTROL@@@detail@archive@3@XZ
+131 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_READ@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_READ@@@detail@archive@3@XZ
+132 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_WRITE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_WRITE@@@detail@archive@3@XZ
+133 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_CBCONSTVALUES@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_CBCONSTVALUES@@@detail@archive@3@XZ
+134 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_CBRCONSTVALUES@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_CBRCONSTVALUES@@@detail@archive@3@XZ
+135 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_CI_TRANSFORM_SHADER_DESC@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_CI_TRANSFORM_SHADER_DESC@@@detail@archive@3@XZ
+136 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_CONSTANTUSAGE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_CONSTANTUSAGE@@@detail@archive@3@XZ
+137 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_CPS_CONFIG@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_CPS_CONFIG@@@detail@archive@3@XZ
+138 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_FLOAT_CONST@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_FLOAT_CONST@@@detail@archive@3@XZ
+139 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_INT_CONST@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_INT_CONST@@@detail@archive@3@XZ
+140 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_PRIMSHADER_CB_OFFSET_LUT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_PRIMSHADER_CB_OFFSET_LUT@@@detail@archive@3@XZ
+141 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_PRIMSHADER_CONTROL_FLAGS@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_PRIMSHADER_CONTROL_FLAGS@@@detail@archive@3@XZ
+142 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_PRIMSHADER_VPORT_CONTROLS_LUT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_PRIMSHADER_VPORT_CONTROLS_LUT@@@detail@archive@3@XZ
+143 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_PS_EXPORT_INFO@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_PS_EXPORT_INFO@@@detail@archive@3@XZ
+144 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SHADERSTATE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SHADERSTATE@@@detail@archive@3@XZ
+145 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SI_DATA_IN_OUT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SI_DATA_IN_OUT@@@detail@archive@3@XZ
+146 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SI_DESCRIPTOR_VALUES@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SI_DESCRIPTOR_VALUES@@@detail@archive@3@XZ
+147 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SI_OPTIMIZATIONS@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SI_OPTIMIZATIONS@@@detail@archive@3@XZ
+148 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SI_PSSHADERDCL_IN@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SI_PSSHADERDCL_IN@@@detail@archive@3@XZ
+149 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SI_PS_ATTR_CH_ENTRY@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SI_PS_ATTR_CH_ENTRY@@@detail@archive@3@XZ
+150 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@3@XZ
+151 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SI_STREAMIODCL_OUT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SI_STREAMIODCL_OUT@@@detail@archive@3@XZ
+152 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SI_USER_DATA_ELEMENT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SI_USER_DATA_ELEMENT@@@detail@archive@3@XZ
+153 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SRCSHADER@@@detail@archive@3@XZ
+154 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SRC_PIPELINE@@@detail@archive@3@XZ
+155 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_TXCONSTVALUES@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_TXCONSTVALUES@@@detail@archive@3@XZ
+156 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@detail@archive@3@XZ
+157 stub ?get_const_instance@?$singleton@V?$map@Vsc_xml_iarchive@@@extra_detail@detail@archive@boost@@@serialization@boost@@SAAEBV?$map@Vsc_xml_iarchive@@@extra_detail@detail@archive@3@XZ
+158 stub ?get_const_instance@?$singleton@V?$multiset@PEBVextended_type_info@serialization@boost@@Ukey_compare@detail@23@V?$allocator@PEBVextended_type_info@serialization@boost@@@std@@@std@@@serialization@boost@@SAAEBV?$multiset@PEBVextended_type_info@serialization@boost@@Ukey_compare@detail@23@V?$allocator@PEBVextended_type_info@serialization@boost@@@std@@@std@@XZ
+159 stub ?get_const_instance@?$singleton@V?$multiset@PEBVextended_type_info_typeid_0@typeid_system@serialization@boost@@Utype_compare@234@V?$allocator@PEBVextended_type_info_typeid_0@typeid_system@serialization@boost@@@std@@@std@@@serialization@boost@@SAAEBV?$multiset@PEBVextended_type_info_typeid_0@typeid_system@serialization@boost@@Utype_compare@234@V?$allocator@PEBVextended_type_info_typeid_0@typeid_system@serialization@boost@@@std@@@std@@XZ
+160 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_IR_MODE_SELECTOR@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_IR_MODE_SELECTOR@@@detail@archive@3@XZ
+161 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_MINIMIZE_VGPRS_STRATEGY@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_MINIMIZE_VGPRS_STRATEGY@@@detail@archive@3@XZ
+162 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_NPI_DISABLE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_NPI_DISABLE@@@detail@archive@3@XZ
+163 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_THREAD_LATENCY_STRATEGY@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_THREAD_LATENCY_STRATEGY@@@detail@archive@3@XZ
+164 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_USE_MORE_D16_SELECTOR@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_USE_MORE_D16_SELECTOR@@@detail@archive@3@XZ
+165 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@T_SC_COMPILE_FLAGS@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@T_SC_COMPILE_FLAGS@@@detail@archive@3@XZ
+166 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@T_SC_LAUNCH_MODE_FLAGS@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@T_SC_LAUNCH_MODE_FLAGS@@@detail@archive@3@XZ
+167 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@T_SC_SI_GLC_CONTROL@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@T_SC_SI_GLC_CONTROL@@@detail@archive@3@XZ
+168 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@T_SC_SI_SLC_CONTROL@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@T_SC_SI_SLC_CONTROL@@@detail@archive@3@XZ
+169 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@USC_INPUT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@USC_INPUT@@@detail@archive@3@XZ
+170 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY@serialization@boost@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY@serialization@boost@@@detail@archive@3@XZ
+171 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_ATOMIC@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_ATOMIC@@@detail@archive@3@XZ
+172 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_CONTROL@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_CONTROL@@@detail@archive@3@XZ
+173 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_READ@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_READ@@@detail@archive@3@XZ
+174 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_WRITE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_WRITE@@@detail@archive@3@XZ
+175 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_CBCONSTVALUES@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_CBCONSTVALUES@@@detail@archive@3@XZ
+176 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_CBRCONSTVALUES@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_CBRCONSTVALUES@@@detail@archive@3@XZ
+177 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_CI_TRANSFORM_SHADER_DESC@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_CI_TRANSFORM_SHADER_DESC@@@detail@archive@3@XZ
+178 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_CONSTANTUSAGE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_CONSTANTUSAGE@@@detail@archive@3@XZ
+179 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_CPS_CONFIG@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_CPS_CONFIG@@@detail@archive@3@XZ
+180 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_FLOAT_CONST@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_FLOAT_CONST@@@detail@archive@3@XZ
+181 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_INT_CONST@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_INT_CONST@@@detail@archive@3@XZ
+182 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_CB_OFFSET_LUT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_CB_OFFSET_LUT@@@detail@archive@3@XZ
+183 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_CONTROL_FLAGS@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_CONTROL_FLAGS@@@detail@archive@3@XZ
+184 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_VPORT_CONTROLS_LUT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_VPORT_CONTROLS_LUT@@@detail@archive@3@XZ
+185 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_PS_EXPORT_INFO@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_PS_EXPORT_INFO@@@detail@archive@3@XZ
+186 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SHADERSTATE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SHADERSTATE@@@detail@archive@3@XZ
+187 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SI_DATA_IN_OUT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SI_DATA_IN_OUT@@@detail@archive@3@XZ
+188 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SI_DESCRIPTOR_VALUES@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SI_DESCRIPTOR_VALUES@@@detail@archive@3@XZ
+189 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SI_OPTIMIZATIONS@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SI_OPTIMIZATIONS@@@detail@archive@3@XZ
+190 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SI_PSSHADERDCL_IN@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SI_PSSHADERDCL_IN@@@detail@archive@3@XZ
+191 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SI_PS_ATTR_CH_ENTRY@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SI_PS_ATTR_CH_ENTRY@@@detail@archive@3@XZ
+192 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@3@XZ
+193 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SI_STREAMIODCL_OUT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SI_STREAMIODCL_OUT@@@detail@archive@3@XZ
+194 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SI_USER_DATA_ELEMENT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SI_USER_DATA_ELEMENT@@@detail@archive@3@XZ
+195 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SRCSHADER@@@detail@archive@3@XZ
+196 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SRC_PIPELINE@@@detail@archive@3@XZ
+197 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_TXCONSTVALUES@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_TXCONSTVALUES@@@detail@archive@3@XZ
+198 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@detail@archive@3@XZ
+199 stub ?get_const_instance@?$singleton@V?$pointer_iserializer@Vsc_xml_iarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$pointer_iserializer@Vsc_xml_iarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@3@XZ
+200 stub ?get_const_instance@?$singleton@V?$pointer_iserializer@Vsc_xml_iarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$pointer_iserializer@Vsc_xml_iarchive@@U_SC_SRCSHADER@@@detail@archive@3@XZ
+201 stub ?get_const_instance@?$singleton@V?$pointer_iserializer@Vsc_xml_iarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$pointer_iserializer@Vsc_xml_iarchive@@U_SC_SRC_PIPELINE@@@detail@archive@3@XZ
+202 stub ?get_const_instance@?$singleton@V?$pointer_oserializer@Vsc_xml_oarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$pointer_oserializer@Vsc_xml_oarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@3@XZ
+203 stub ?get_const_instance@?$singleton@V?$pointer_oserializer@Vsc_xml_oarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$pointer_oserializer@Vsc_xml_oarchive@@U_SC_SRCSHADER@@@detail@archive@3@XZ
+204 stub ?get_const_instance@?$singleton@V?$pointer_oserializer@Vsc_xml_oarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$pointer_oserializer@Vsc_xml_oarchive@@U_SC_SRC_PIPELINE@@@detail@archive@3@XZ
+205 stub ?get_const_instance@?$singleton@V?$set@PEBVvoid_caster@void_cast_detail@serialization@boost@@Uvoid_caster_compare@234@V?$allocator@PEBVvoid_caster@void_cast_detail@serialization@boost@@@std@@@std@@@serialization@boost@@SAAEBV?$set@PEBVvoid_caster@void_cast_detail@serialization@boost@@Uvoid_caster_compare@234@V?$allocator@PEBVvoid_caster@void_cast_detail@serialization@boost@@@std@@@std@@XZ
+206 stub ?get_lock@singleton_module@serialization@boost@@AEAAAEA_NXZ
+207 stub ?get_mutable_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@@serialization@boost@@SAAEAV?$iserializer@Vsc_xml_iarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@3@XZ
+208 stub ?get_mutable_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@@serialization@boost@@SAAEAV?$iserializer@Vsc_xml_iarchive@@U_SC_SRCSHADER@@@detail@archive@3@XZ
+209 stub ?get_mutable_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@@serialization@boost@@SAAEAV?$iserializer@Vsc_xml_iarchive@@U_SC_SRC_PIPELINE@@@detail@archive@3@XZ
+210 stub ?get_mutable_instance@?$singleton@V?$map@Vsc_xml_iarchive@@@extra_detail@detail@archive@boost@@@serialization@boost@@SAAEAV?$map@Vsc_xml_iarchive@@@extra_detail@detail@archive@3@XZ
+211 stub ?get_mutable_instance@?$singleton@V?$map@Vsc_xml_oarchive@@@extra_detail@detail@archive@boost@@@serialization@boost@@SAAEAV?$map@Vsc_xml_oarchive@@@extra_detail@detail@archive@3@XZ
+212 stub ?get_mutable_instance@?$singleton@V?$multiset@PEBVextended_type_info@serialization@boost@@Ukey_compare@detail@23@V?$allocator@PEBVextended_type_info@serialization@boost@@@std@@@std@@@serialization@boost@@SAAEAV?$multiset@PEBVextended_type_info@serialization@boost@@Ukey_compare@detail@23@V?$allocator@PEBVextended_type_info@serialization@boost@@@std@@@std@@XZ
+213 stub ?get_mutable_instance@?$singleton@V?$multiset@PEBVextended_type_info_typeid_0@typeid_system@serialization@boost@@Utype_compare@234@V?$allocator@PEBVextended_type_info_typeid_0@typeid_system@serialization@boost@@@std@@@std@@@serialization@boost@@SAAEAV?$multiset@PEBVextended_type_info_typeid_0@typeid_system@serialization@boost@@Utype_compare@234@V?$allocator@PEBVextended_type_info_typeid_0@typeid_system@serialization@boost@@@std@@@std@@XZ
+214 stub ?get_mutable_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@@serialization@boost@@SAAEAV?$oserializer@Vsc_xml_oarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@3@XZ
+215 stub ?get_mutable_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@@serialization@boost@@SAAEAV?$oserializer@Vsc_xml_oarchive@@U_SC_SRCSHADER@@@detail@archive@3@XZ
+216 stub ?get_mutable_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@@serialization@boost@@SAAEAV?$oserializer@Vsc_xml_oarchive@@U_SC_SRC_PIPELINE@@@detail@archive@3@XZ
+217 stub ?get_mutable_instance@?$singleton@V?$set@PEBVvoid_caster@void_cast_detail@serialization@boost@@Uvoid_caster_compare@234@V?$allocator@PEBVvoid_caster@void_cast_detail@serialization@boost@@@std@@@std@@@serialization@boost@@SAAEAV?$set@PEBVvoid_caster@void_cast_detail@serialization@boost@@Uvoid_caster_compare@234@V?$allocator@PEBVvoid_caster@void_cast_detail@serialization@boost@@@std@@@std@@XZ
+218 stub ?is_destroyed@?$singleton@V?$map@Vsc_xml_iarchive@@@extra_detail@detail@archive@boost@@@serialization@boost@@SA_NXZ
+219 stub ?is_destroyed@?$singleton@V?$map@Vsc_xml_oarchive@@@extra_detail@detail@archive@boost@@@serialization@boost@@SA_NXZ
+220 stub ?is_destroyed@?$singleton@V?$multiset@PEBVextended_type_info@serialization@boost@@Ukey_compare@detail@23@V?$allocator@PEBVextended_type_info@serialization@boost@@@std@@@std@@@serialization@boost@@SA_NXZ
+221 stub ?is_destroyed@?$singleton@V?$multiset@PEBVextended_type_info_typeid_0@typeid_system@serialization@boost@@Utype_compare@234@V?$allocator@PEBVextended_type_info_typeid_0@typeid_system@serialization@boost@@@std@@@std@@@serialization@boost@@SA_NXZ
+222 stub ?is_destroyed@?$singleton@V?$set@PEBVvoid_caster@void_cast_detail@serialization@boost@@Uvoid_caster_compare@234@V?$allocator@PEBVvoid_caster@void_cast_detail@serialization@boost@@@std@@@std@@@serialization@boost@@SA_NXZ
+223 stub ?is_locked@singleton_module@serialization@boost@@QEAA_NXZ
+224 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_IR_MODE_SELECTOR@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+225 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_MINIMIZE_VGPRS_STRATEGY@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+226 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_NPI_DISABLE@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+227 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_THREAD_LATENCY_STRATEGY@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+228 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_USE_MORE_D16_SELECTOR@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+229 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@T_SC_COMPILE_FLAGS@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+230 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@T_SC_LAUNCH_MODE_FLAGS@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+231 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@T_SC_SI_GLC_CONTROL@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+232 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@T_SC_SI_SLC_CONTROL@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+233 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@USC_INPUT@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+234 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY@serialization@boost@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+235 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_ATOMIC@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+236 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_CONTROL@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+237 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_READ@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+238 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_WRITE@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+239 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_CBCONSTVALUES@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+240 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_CBRCONSTVALUES@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+241 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_CI_TRANSFORM_SHADER_DESC@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+242 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_CONSTANTUSAGE@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+243 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_CPS_CONFIG@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+244 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_FLOAT_CONST@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+245 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_INT_CONST@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+246 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_PRIMSHADER_CB_OFFSET_LUT@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+247 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_PRIMSHADER_CONTROL_FLAGS@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+248 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_PRIMSHADER_VPORT_CONTROLS_LUT@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+249 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_PS_EXPORT_INFO@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+250 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SHADERSTATE@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+251 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SI_DATA_IN_OUT@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+252 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SI_DESCRIPTOR_VALUES@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+253 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SI_OPTIMIZATIONS@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+254 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SI_PSSHADERDCL_IN@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+255 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SI_PS_ATTR_CH_ENTRY@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+256 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+257 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SI_STREAMIODCL_OUT@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+258 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SI_USER_DATA_ELEMENT@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+259 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+260 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+261 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_TXCONSTVALUES@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+262 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+263 stub ?load_object_ptr@?$pointer_iserializer@Vsc_xml_iarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@EEBAXAEAVbasic_iarchive@234@PEAXI@Z
+264 stub ?load_object_ptr@?$pointer_iserializer@Vsc_xml_iarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@EEBAXAEAVbasic_iarchive@234@PEAXI@Z
+265 stub ?load_object_ptr@?$pointer_iserializer@Vsc_xml_iarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@EEBAXAEAVbasic_iarchive@234@PEAXI@Z
+266 stub ?lock@?1??get_lock@singleton_module@serialization@boost@@AEAAAEA_NXZ@4_NA
+267 stub ?lock@singleton_module@serialization@boost@@QEAAXXZ
+268 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_IR_MODE_SELECTOR@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+269 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_MINIMIZE_VGPRS_STRATEGY@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+270 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_NPI_DISABLE@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+271 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_THREAD_LATENCY_STRATEGY@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+272 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_USE_MORE_D16_SELECTOR@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+273 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@T_SC_COMPILE_FLAGS@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+274 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@T_SC_LAUNCH_MODE_FLAGS@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+275 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@T_SC_SI_GLC_CONTROL@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+276 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@T_SC_SI_SLC_CONTROL@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+277 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@USC_INPUT@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+278 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY@serialization@boost@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+279 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_ATOMIC@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+280 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_CONTROL@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+281 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_READ@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+282 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_WRITE@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+283 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_CBCONSTVALUES@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+284 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_CBRCONSTVALUES@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+285 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_CI_TRANSFORM_SHADER_DESC@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+286 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_CONSTANTUSAGE@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+287 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_CPS_CONFIG@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+288 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_FLOAT_CONST@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+289 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_INT_CONST@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+290 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_CB_OFFSET_LUT@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+291 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_CONTROL_FLAGS@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+292 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_VPORT_CONTROLS_LUT@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+293 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_PS_EXPORT_INFO@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+294 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SHADERSTATE@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+295 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SI_DATA_IN_OUT@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+296 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SI_DESCRIPTOR_VALUES@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+297 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SI_OPTIMIZATIONS@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+298 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SI_PSSHADERDCL_IN@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+299 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SI_PS_ATTR_CH_ENTRY@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+300 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+301 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SI_STREAMIODCL_OUT@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+302 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SI_USER_DATA_ELEMENT@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+303 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+304 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+305 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_TXCONSTVALUES@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+306 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+307 stub ?save_object_ptr@?$pointer_oserializer@Vsc_xml_oarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@EEBAXAEAVbasic_oarchive@234@PEBX@Z
+308 stub ?save_object_ptr@?$pointer_oserializer@Vsc_xml_oarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@EEBAXAEAVbasic_oarchive@234@PEBX@Z
+309 stub ?save_object_ptr@?$pointer_oserializer@Vsc_xml_oarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@EEBAXAEAVbasic_oarchive@234@PEBX@Z
+310 stub ?unlock@singleton_module@serialization@boost@@QEAAXXZ
+@ cdecl AmdExtD3DCreateInterface(ptr ptr ptr)
+@ stdcall AmdGetDxcModuleHandle()
+313 stub GetSettingsBlobsAll
+314 stub OpenAdapter12
+315 stub OpenShimInterface
diff --git a/dlls/amdxc64/amdxc_interfaces.idl b/dlls/amdxc64/amdxc_interfaces.idl
new file mode 100644
index 00000000000..2c2f568df37
--- /dev/null
+++ b/dlls/amdxc64/amdxc_interfaces.idl
@@ -0,0 +1,96 @@
+/*
+ * Copyright 2025 Etaash Mathamsetty
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+#pragma makedep register
+
+import "wtypes.idl";
+import "unknwn.idl";
+
+/* Structure version 1 for Anti-Lag 2.0: */
+struct APIData_v1
+{
+    unsigned int    uiSize;
+    unsigned int    uiVersion;
+    unsigned int    eMode;
+    const char*     sControlStr;
+    unsigned int    uiControlStrLength;
+    unsigned int    maxFPS;
+};
+
+/* Structure version 2 for Anti-Lag 2.0: */
+struct APIData_v2
+{
+    unsigned int    uiSize;
+    unsigned int    uiVersion;
+    struct Flags
+    {
+        unsigned int unused0               : 1;
+        unsigned int unused1               : 1;
+
+        unsigned int signalFgFrameType     : 1;
+        unsigned int isInterpolatedFrame   : 1;
+
+        unsigned int signalGetUserInputIdx : 1;
+        unsigned int signalEndOfFrameIdx   : 1;
+
+        unsigned int reserved              :26;
+    }               flags;
+    unsigned __int64    iiFrameIdx;
+    unsigned __int64    uiiReserved[19];
+};
+
+[
+    object,
+    uuid(b58d6601-7401-4234-8180-6febfc0e484c),
+    local
+]
+interface IAmdExtFfxApi : IUnknown
+{
+    HRESULT UpdateFfxApiProvider([in, out] void* pData, [in] unsigned int dataSizeInBytes);
+}
+
+[
+    object,
+    uuid(44085fbe-e839-40c5-bf38-0ebc5ab4d0a6),
+    local
+]
+interface IAmdExtAntiLagApi : IUnknown
+{
+    HRESULT UpdateAntiLagState([in, out] void* pData);
+}
+
+[
+    object,
+    uuid(014937ec-9288-446f-a9ac-d75a8e3a984f),
+    local
+]
+interface IAmdExtStub1 : IUnknown
+{
+    HRESULT QueryInterface2([in, out] void* unk, [in] REFIID iid, [in, out] void** out);
+}
+
+[
+    object,
+    uuid(ba019d53-ccab-4cbd-b56a-7230ed4330ad),
+    local
+]
+interface IAmdExtStub2 : IUnknown
+{
+    void stub();
+    void stub2([in] unsigned int unk);
+    void stub3();
+}
diff --git a/dlls/amdxc64/dxvk_interfaces.idl b/dlls/amdxc64/dxvk_interfaces.idl
new file mode 100644
index 00000000000..9e405a32a06
--- /dev/null
+++ b/dlls/amdxc64/dxvk_interfaces.idl
@@ -0,0 +1,153 @@
+/*
+ * Copyright 2023      Paul Gofman for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#pragma makedep register
+
+import "d3d11.idl";
+import "dxgi1_6.idl";
+
+typedef struct VkInstance_T *VkInstance;
+typedef void (__stdcall *PFN_vkVoidFunction)(void);
+typedef PFN_vkVoidFunction (__stdcall *PFN_vkGetInstanceProcAddr)(VkInstance instance, const char* pName);
+
+typedef enum D3D11_VK_EXTENSION
+{
+    D3D11_VK_EXT_MULTI_DRAW_INDIRECT,
+    D3D11_VK_EXT_MULTI_DRAW_INDIRECT_COUNT,
+    D3D11_VK_EXT_DEPTH_BOUNDS,
+    D3D11_VK_EXT_BARRIER_CONTROL,
+    D3D11_VK_NVX_BINARY_IMPORT,
+    D3D11_VK_NVX_IMAGE_VIEW_HANDLE,
+} D3D11_VK_EXTENSION;
+
+typedef enum D3D11_VK_BARRIER_CONTROL
+{
+    D3D11_VK_BARRIER_CONTROL_IGNORE_WRITE_AFTER_WRITE = 0x1,
+    D3D11_VK_BARRIER_CONTROL_IGNORE_GRAPHICS_UAV = 0x2,
+} D3D11_VK_BARRIER_CONTROL;
+
+[
+    object,
+    uuid(bb8a4fb9-3935-4762-b44b-35189a26414a),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtShader : IUnknown
+{
+    HRESULT GetSpirvCode([in, out] SIZE_T *code_size, [out] void *code);
+}
+
+[
+    object,
+    uuid(8a6e3c42-f74c-45b7-8265-a231b677ca17),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtDevice : IUnknown
+{
+    BOOL GetExtensionSupport([in] D3D11_VK_EXTENSION extension);
+}
+
+[
+    object,
+    uuid(cfcf64ef-9586-46d0-bca4-97cf2ca61b06),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtDevice1 : ID3D11VkExtDevice
+{
+    BOOL GetResourceHandleGPUVirtualAddressAndSizeNVX([in] void *object, [out] UINT64 *gpu_va_start,
+            [out] UINT64 *gpu_va_size);
+    BOOL CreateUnorderedAccessViewAndGetDriverHandleNVX([in] ID3D11Resource *resource,
+            [in] const D3D11_UNORDERED_ACCESS_VIEW_DESC *desc, [out] ID3D11UnorderedAccessView **uav,
+            UINT32 *driver_handle);
+    BOOL CreateShaderResourceViewAndGetDriverHandleNVX([in] ID3D11Resource *resource,
+            [in] const D3D11_SHADER_RESOURCE_VIEW_DESC* desc, [out] ID3D11ShaderResourceView **srv,
+            UINT32 *dirver_handle);
+    BOOL CreateSamplerStateAndGetDriverHandleNVX([in] const D3D11_SAMPLER_DESC *sample_desc,
+            [out] ID3D11SamplerState **sample_state, UINT32 *driver_handle);
+    BOOL CreateCubinComputeShaderWithNameNVX([in] const void *cubin, [in] UINT32 size, [in] UINT32 block_x,
+            [in] UINT32 block_y, [in] UINT32 block_z, [in] const char *shader_name, [out] IUnknown **shader);
+    BOOL GetCudaTextureObjectNVX([in] UINT32 srv_driver_hadnle, [in] UINT32 sample_driver_handle,
+            [out] UINT32 *cuda_texture_handle);
+}
+
+[
+    object,
+    uuid(fd0bca13-5cb6-4c3a-987e-4750de2ca791),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtContext : IUnknown
+{
+    void MultiDrawIndirect([in] UINT draw_count, [in] ID3D11Buffer *buffer_for_args, [in] UINT byte_offset_for_args,
+            [in] UINT byte_stride_for_args);
+    void MultiDrawIndexedIndirect([in] UINT draw_count, [in] ID3D11Buffer *buffer_for_args,
+            [in] UINT byte_offset_for_args, [in] UINT byte_stride_for_args);
+    void MultiDrawIndirectCount([in] UINT max_draw_count, [in] ID3D11Buffer *buffer_for_count,
+            [in] UINT byte_offset_for_count, [in] ID3D11Buffer *buffer_for_args,
+            [in] UINT byte_offset_for_args, [in] UINT byte_stride_for_args);
+    void MultiDrawIndexedIndirectCount([in] UINT max_draw_count, [in] ID3D11Buffer *buffer_for_count,
+            [in] UINT byte_offset_for_count, [in] ID3D11Buffer *buffer_for_args,
+            [in] UINT byte_offset_for_args, [in] UINT byte_stride_for_args);
+    void SetDepthBoundsTest([in] BOOL enable, [in] FLOAT min_depth_bounds, [in] FLOAT max_depth_bounds);
+    void SetBarrierControl([in] UINT control_flags);
+}
+
+[
+    object,
+    uuid(874b09b2-ae0b-41d8-8476-5f3b7a0e879d),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtContext1 : ID3D11VkExtContext
+{
+    BOOL LaunchCubinShaderNVX([in] IUnknown *shader,[in] UINT32 grid_x, [in] UINT32 grid_y, [in] UINT32 grid_z,
+            [in] const void *params, [in] UINT32 param_size, [in] void * const *read_resources,
+            [in] UINT32 read_resource_count, [in] void* const *write_resources, [in] UINT32 write_resources_count);
+}
+
+[
+    object,
+    uuid(4c5e1b0d-b0c8-4131-bfd8-9b2476f7f408),
+    local,
+    pointer_default(unique)
+]
+interface IDXGIVkInteropFactory : IUnknown
+{
+    void GetVulkanInstance(
+          [out] VkInstance *pInstance,
+          [out] PFN_vkGetInstanceProcAddr *ppfnVkGetInstanceProcAddr);
+}
+
+[
+    object,
+    uuid(2a289dbd-2d0a-4a51-89f7-f2adce465cd6),
+    local,
+    pointer_default(unique)
+]
+interface IDXGIVkInteropFactory1 : IDXGIVkInteropFactory
+{
+  HRESULT GetGlobalHDRState(
+          [out] DXGI_COLOR_SPACE_TYPE   *pOutColorSpace,
+          [out] DXGI_HDR_METADATA_HDR10 *ppOutMetadata) = 0;
+
+  HRESULT SetGlobalHDRState(
+          [in] DXGI_COLOR_SPACE_TYPE    ColorSpace,
+    [in] const DXGI_HDR_METADATA_HDR10 *pMetadata) = 0;
+}
diff --git a/dlls/amdxc64/main.c b/dlls/amdxc64/main.c
new file mode 100644
index 00000000000..754e22f914f
--- /dev/null
+++ b/dlls/amdxc64/main.c
@@ -0,0 +1,317 @@
+/*
+ * amdxc implementation
+ *
+ * Copyright 2023 Etaash Mathamsetty
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdarg.h>
+
+#include "ntstatus.h"
+#include "winerror.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winbase.h"
+#include "winternl.h"
+#include "wine/debug.h"
+#include "wine/heap.h"
+
+#include "wine/vulkan.h"
+#include "wine/asm.h"
+
+#define COBJMACROS
+#include "initguid.h"
+#include "d3d11.h"
+#include "d3d12.h"
+
+#include "dxgi1_6.h"
+
+#include "dxvk_interfaces.h"
+#include "amdxc_interfaces.h"
+
+#include <wingdi.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(amdxc);
+
+struct AMDFSR4FFX
+{
+    IAmdExtFfxApi IAmdExtFfxApi_iface;
+    LONG ref;
+};
+
+static struct AMDFSR4FFX* impl_from_IAmdExtFfxApi(IAmdExtFfxApi* iface)
+{
+    return CONTAINING_RECORD(iface, struct AMDFSR4FFX, IAmdExtFfxApi_iface);
+}
+
+ULONG STDMETHODCALLTYPE AMDFSR4FFX_AddRef(IAmdExtFfxApi *iface)
+{
+    struct AMDFSR4FFX* data = impl_from_IAmdExtFfxApi(iface);
+    return InterlockedIncrement(&data->ref);
+}
+
+ULONG STDMETHODCALLTYPE AMDFSR4FFX_Release(IAmdExtFfxApi *iface)
+{
+    struct AMDFSR4FFX* data = impl_from_IAmdExtFfxApi(iface);
+    ULONG ret = InterlockedDecrement(&data->ref);
+    if (!ret) free(data);
+    return ret;
+}
+
+HRESULT STDMETHODCALLTYPE AMDFSR4FFX_QueryInterface(IAmdExtFfxApi *iface, REFIID iid, void **obj)
+{
+    FIXME("%p %s %p", iface, debugstr_guid(iid), obj);
+
+    return E_NOINTERFACE;
+}
+
+typedef HRESULT (__stdcall *updateffxapi_pfn)(void*, unsigned int);
+
+HRESULT STDMETHODCALLTYPE AMDFSR4FFX_UpdateFfxApiProvider(IAmdExtFfxApi *iface, void* data, unsigned int size)
+{
+    updateffxapi_pfn pfn;
+    HMODULE amdffx = LoadLibraryA("amdxcffx64");
+
+    TRACE("%p %p %u\n", iface, data, size);
+
+    if (!amdffx)
+    {
+        ERR("Failed to load FSR4 dll (amdxcffx)!\n");
+        return E_NOINTERFACE;
+    }
+
+    pfn = (updateffxapi_pfn)GetProcAddress(amdffx, "UpdateFfxApiProvider");
+
+    if(pfn && getenv("FSR4_UPGRADE"))
+    {
+        FIXME("replaced fsr3 with fsr4!\n");
+        return pfn(data, size);
+    }
+
+    return E_NOINTERFACE;
+}
+
+static const struct IAmdExtFfxApiVtbl AMDFSR4FFX_vtable = {
+    AMDFSR4FFX_QueryInterface,
+    AMDFSR4FFX_AddRef,
+    AMDFSR4FFX_Release,
+    AMDFSR4FFX_UpdateFfxApiProvider
+};
+
+struct AMDAntiLag2
+{
+    IAmdExtAntiLagApi IAmdExtAntiLagApi_iface;
+    LONG ref;
+};
+
+static struct AMDAntiLag2* impl_from_IAmdExtAntiLagApi(IAmdExtAntiLagApi *iface)
+{
+    return CONTAINING_RECORD(iface, struct AMDAntiLag2, IAmdExtAntiLagApi_iface);
+}
+
+ULONG STDMETHODCALLTYPE AMDAntiLag2_AddRef(IAmdExtAntiLagApi *iface)
+{
+    struct AMDAntiLag2 *data = impl_from_IAmdExtAntiLagApi(iface);
+    return InterlockedIncrement(&data->ref);
+}
+
+ULONG STDMETHODCALLTYPE AMDAntiLag2_Release(IAmdExtAntiLagApi *iface)
+{
+    struct AMDAntiLag2 *data = impl_from_IAmdExtAntiLagApi(iface);
+    ULONG ret = InterlockedDecrement(&data->ref);
+    if (!ret) free(data);
+    return ret;
+}
+
+HRESULT STDMETHODCALLTYPE AMDAntiLag2_QueryInterface(IAmdExtAntiLagApi *iface, REFIID iid, void **out)
+{
+    FIXME("(%p %s %p) stub!\n", iface, debugstr_guid(iid), out);
+    return E_NOINTERFACE;
+}
+
+HRESULT STDMETHODCALLTYPE AMDAntiLag2_UpdateAntiLagState(IAmdExtAntiLagApi *iface, void* data)
+{
+    union {
+        struct APIData_v1 *v1;
+        struct APIData_v2 *v2;
+    } apidata = {data};
+    TRACE("(%p %p)!\n", iface, data);
+
+    if (!data) {
+        /* perform sleep */
+    } else if(apidata.v1->uiVersion == 1) {
+        /* access apidata v1 */
+        if(apidata.v1->uiSize != sizeof(struct APIData_v1)) return E_INVALIDARG;
+    } else if(apidata.v1->uiVersion == 2) {
+        /* access apidata v2 */
+        if(apidata.v2->uiSize != sizeof(struct APIData_v2)) return E_INVALIDARG;
+    }
+
+    return E_NOTIMPL;
+}
+
+static const struct IAmdExtAntiLagApiVtbl AMDANTILAG_vtable = {
+    AMDAntiLag2_QueryInterface,
+    AMDAntiLag2_AddRef,
+    AMDAntiLag2_Release,
+    AMDAntiLag2_UpdateAntiLagState
+};
+
+struct AMDExtStub2
+{
+    IAmdExtStub2 IAmdExtStub2_iface;
+    LONG ref;
+};
+
+struct AMDExtStub2* impl_from_IAMDExtStub2(IAmdExtStub2 *iface)
+{
+    return CONTAINING_RECORD(iface, struct AMDExtStub2, IAmdExtStub2_iface);
+}
+
+ULONG STDMETHODCALLTYPE AMDExtStub2_AddRef(IAmdExtStub2 *iface)
+{
+    struct AMDExtStub2 *this = impl_from_IAMDExtStub2(iface);
+    return InterlockedIncrement(&this->ref);
+}
+
+ULONG STDMETHODCALLTYPE AMDExtStub2_Release(IAmdExtStub2 *iface)
+{
+    struct AMDExtStub2 *this = impl_from_IAMDExtStub2(iface);
+    ULONG ret = InterlockedDecrement(&this->ref);
+    if (!ret) free(this);
+    return ret;
+}
+
+HRESULT STDMETHODCALLTYPE AMDExtStub2_QueryInterface(IAmdExtStub2 *iface, REFIID iid, void **out)
+{
+    FIXME("%p %s %p stub!\n", iface, debugstr_guid(iid), out);
+    return E_NOINTERFACE;
+}
+
+void STDMETHODCALLTYPE AMDExtStub2_stub1(IAmdExtStub2 *iface)
+{
+    FIXME("%p stub!\n", iface);
+}
+
+void STDMETHODCALLTYPE AMDExtStub2_stub2(IAmdExtStub2 *iface, unsigned int unk)
+{
+    FIXME("%p %u stub!\n", iface, unk);
+}
+
+void STDMETHODCALLTYPE AMDExtStub2_stub3(IAmdExtStub2 *iface)
+{
+    FIXME("%p stub!\n", iface);
+}
+
+const static struct IAmdExtStub2Vtbl AMDSTUB2_vtable = {
+    AMDExtStub2_QueryInterface,
+    AMDExtStub2_AddRef,
+    AMDExtStub2_Release,
+    AMDExtStub2_stub1,
+    AMDExtStub2_stub2,
+    AMDExtStub2_stub3
+};
+
+struct AMDExtStub1
+{
+    IAmdExtStub1 IAmdExtStub1_iface;
+    LONG ref;
+};
+
+struct AMDExtStub1* impl_from_IAMDExtStub1(IAmdExtStub1 *iface)
+{
+    return CONTAINING_RECORD(iface, struct AMDExtStub1, IAmdExtStub1_iface);
+}
+
+ULONG STDMETHODCALLTYPE AMDExtStub1_AddRef(IAmdExtStub1 *iface)
+{
+    struct AMDExtStub1 *this = impl_from_IAMDExtStub1(iface);
+    return InterlockedIncrement(&this->ref);
+}
+
+ULONG STDMETHODCALLTYPE AMDExtStub1_Release(IAmdExtStub1 *iface)
+{
+    struct AMDExtStub1 *this = impl_from_IAMDExtStub1(iface);
+    ULONG ret = InterlockedDecrement(&this->ref);
+    if (!ret) free(this);
+    return ret;
+}
+
+HRESULT STDMETHODCALLTYPE AmdExtStub1_QueryInterface2(IAmdExtStub1 *iface, void* unk, REFIID iid, void **out)
+{
+    TRACE("%p %p %s %p\n", iface, unk, debugstr_guid(iid), out);
+
+    if(IsEqualGUID(iid, &IID_IAmdExtStub2))
+    {
+        struct AMDExtStub2 *this = calloc(1, sizeof(struct AMDExtStub2));
+
+        this->IAmdExtStub2_iface.lpVtbl = &AMDSTUB2_vtable;
+        this->ref = 1;
+        *out = &this->IAmdExtStub2_iface;
+        return S_OK;
+    } else {
+        FIXME("unknown guid %s\n", debugstr_guid(iid));
+    }
+
+    return E_NOINTERFACE;
+}
+
+HRESULT STDMETHODCALLTYPE AmdExtStub1_QueryInterface(IAmdExtStub1 *iface, REFIID iid, void **out)
+{
+    return AmdExtStub1_QueryInterface2(iface, NULL, iid, out);
+}
+
+static const struct IAmdExtStub1Vtbl AMDSTUB1_vtable = {
+    AmdExtStub1_QueryInterface,
+    AMDExtStub1_AddRef,
+    AMDExtStub1_Release,
+    AmdExtStub1_QueryInterface2
+};
+
+HRESULT CDECL AmdExtD3DCreateInterface(IUnknown *outer, REFIID iid, void **obj)
+{
+    TRACE("outer %p, iid %s, obj %p\n", outer, debugstr_guid(iid), obj);
+
+    if (IsEqualGUID(iid, &IID_IAmdExtFfxApi))
+    {
+        struct AMDFSR4FFX* ffx = calloc(1, sizeof(struct AMDFSR4FFX));
+        ffx->IAmdExtFfxApi_iface.lpVtbl = &AMDFSR4FFX_vtable;
+        ffx->ref = 1;
+        *obj = &ffx->IAmdExtFfxApi_iface;
+        return S_OK;
+    } else if (IsEqualGUID(iid, &IID_IAmdExtAntiLagApi)) {
+        struct AMDAntiLag2 *out = calloc(1, sizeof(struct AMDAntiLag2));
+        out->IAmdExtAntiLagApi_iface.lpVtbl = &AMDANTILAG_vtable;
+        out->ref = 1;
+        *obj = &out->IAmdExtAntiLagApi_iface;
+        return S_OK;
+    } else if(IsEqualGUID(iid, &IID_IAmdExtStub1)) {
+        struct AMDExtStub1 *this = calloc(1, sizeof(struct AMDExtStub1));
+        this->IAmdExtStub1_iface.lpVtbl = &AMDSTUB1_vtable;
+        this->ref = 1;
+        *obj = &this->IAmdExtStub1_iface;
+        return S_OK;
+    } else {
+        FIXME("unknown guid: %s\n", debugstr_guid(iid));
+    }
+
+    return E_NOINTERFACE;
+}
+
+HMODULE WINAPI AmdGetDxcModuleHandle(void)
+{
+    return GetModuleHandleA(NULL);
+}
-- 
2.49.0

From 20a3cdf0e516b8f542e474145a301a9cfb281f69 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty <etaash.mathamsetty@gmail.com>
Date: Mon, 20 Jan 2025 15:40:46 -0500
Subject: [PATCH 035/159] wine.inf: Don't clobber UBR key.

---
 loader/wine.inf.in | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 4c5edde1d42..d22c6f8997f 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -2686,7 +2686,7 @@ HKLM,%CurrentVersionNT%,"CurrentMinorVersionNumber",0x10003,0
 HKLM,%CurrentVersionNT%,"CurrentBuild",2,"19045"
 HKLM,%CurrentVersionNT%,"CurrentBuildNumber",2,"19045"
 HKLM,%CurrentVersionNT%,"CurrentType",2,"Multiprocessor Free"
-HKLM,%CurrentVersionNT%,"UBR",0x10001,5796
+HKLM,%CurrentVersionNT%,"UBR",0x10003,5796
 HKLM,%CurrentVersionNT%,"DigitalProductId",2,00,00,00,00,00,00,00,00,00,00,00,\
 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,\
 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,\
-- 
2.49.0

From 1c4b98ebbcdde7372c76b0520cdccff8ab607e38 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty <etaash.mathamsetty@gmail.com>
Date: Wed, 29 Jan 2025 19:05:17 -0500
Subject: [PATCH 036/159] twinapi.appcore/tests: Fix broken registry query.

---
 dlls/twinapi.appcore/tests/twinapi.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/twinapi.appcore/tests/twinapi.c b/dlls/twinapi.appcore/tests/twinapi.c
index 5ee5c45fc91..e86281b895e 100644
--- a/dlls/twinapi.appcore/tests/twinapi.c
+++ b/dlls/twinapi.appcore/tests/twinapi.c
@@ -164,6 +164,7 @@ static void test_AnalyticsVersionInfo(void)
     WindowsDeleteString( str );
     WindowsDeleteString( expect_str );
 
+    size = sizeof(revision);
     if (RegGetValueW( HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows NT\\CurrentVersion", L"UBR",
                       RRF_RT_REG_DWORD, NULL, &revision, &size ))
         revision = 0;
-- 
2.49.0

From 5a880c5dfda1663c29a2d7d05d094854cc7a3e85 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sat, 10 May 2025 01:23:55 -0400
Subject: [PATCH 037/159] winecfg: Add support for UBR key.

---
 programs/winecfg/appdefaults.c | 47 +++++++++++++++++++---------------
 1 file changed, 27 insertions(+), 20 deletions(-)

diff --git a/programs/winecfg/appdefaults.c b/programs/winecfg/appdefaults.c
index cfb898b1d53..0acb964ef0a 100644
--- a/programs/winecfg/appdefaults.c
+++ b/programs/winecfg/appdefaults.c
@@ -40,6 +40,7 @@ struct win_version
     DWORD        dwMajorVersion;
     DWORD        dwMinorVersion;
     DWORD        dwBuildNumber;
+    DWORD        UBR;
     DWORD        dwPlatformId;
     const WCHAR *szCSDVersion;
     WORD         wServicePackMajor;
@@ -49,26 +50,26 @@ struct win_version
 
 static const struct win_version win_versions[] =
 {
-    { L"win11",     L"Windows 11",      L"6.3", 10,  0, 22000, VER_PLATFORM_WIN32_NT, L"", 0, 0, L"WinNT"},
-    { L"win10",     L"Windows 10",      L"6.3", 10,  0, 19045, VER_PLATFORM_WIN32_NT, L"", 0, 0, L"WinNT"},
-    { L"win81",     L"Windows 8.1",     NULL,    6,  3,  9600, VER_PLATFORM_WIN32_NT, L"", 0, 0, L"WinNT"},
-    { L"win8",      L"Windows 8",       NULL,    6,  2,  9200, VER_PLATFORM_WIN32_NT, L"", 0, 0, L"WinNT"},
-    { L"win2008r2", L"Windows 2008 R2", NULL,    6,  1,  7601, VER_PLATFORM_WIN32_NT, L"Service Pack 1", 1, 0, L"ServerNT"},
-    { L"win7",      L"Windows 7",       NULL,    6,  1,  7601, VER_PLATFORM_WIN32_NT, L"Service Pack 1", 1, 0, L"WinNT"},
-    { L"win2008",   L"Windows 2008",    NULL,    6,  0,  6002, VER_PLATFORM_WIN32_NT, L"Service Pack 2", 2, 0, L"ServerNT"},
-    { L"vista",     L"Windows Vista",   NULL,    6,  0,  6002, VER_PLATFORM_WIN32_NT, L"Service Pack 2", 2, 0, L"WinNT"},
-    { L"win2003",   L"Windows 2003",    NULL,    5,  2,  3790, VER_PLATFORM_WIN32_NT, L"Service Pack 2", 2, 0, L"ServerNT"},
-    { L"winxp64",   L"Windows XP 64",   NULL,    5,  2,  3790, VER_PLATFORM_WIN32_NT, L"Service Pack 2", 2, 0, L"WinNT"},
-    { L"winxp",     L"Windows XP",      NULL,    5,  1,  2600, VER_PLATFORM_WIN32_NT, L"Service Pack 3", 3, 0, L"WinNT"},
-    { L"win2k",     L"Windows 2000",    NULL,    5,  0,  2195, VER_PLATFORM_WIN32_NT, L"Service Pack 4", 4, 0, L"WinNT"},
-    { L"winme",     L"Windows ME",      NULL,    4, 90,  3000, VER_PLATFORM_WIN32_WINDOWS, L" ", 0, 0, L""},
-    { L"win98",     L"Windows 98",      NULL,    4, 10,  2222, VER_PLATFORM_WIN32_WINDOWS, L" A ", 0, 0, L""},
-    { L"win95",     L"Windows 95",      NULL,    4,  0,   950, VER_PLATFORM_WIN32_WINDOWS, L"", 0, 0, L""},
-    { L"nt40",      L"Windows NT 4.0",  NULL,    4,  0,  1381, VER_PLATFORM_WIN32_NT, L"Service Pack 6a", 6, 0, L"WinNT"},
-    { L"nt351",     L"Windows NT 3.51", NULL,    3, 51,  1057, VER_PLATFORM_WIN32_NT, L"Service Pack 5", 5, 0, L"WinNT"},
-    { L"win31",     L"Windows 3.1",     NULL,    3, 10,     0, VER_PLATFORM_WIN32s, L"Win32s 1.3", 0, 0, L""},
-    { L"win30",     L"Windows 3.0",     NULL,    3,  0,     0, VER_PLATFORM_WIN32s, L"Win32s 1.3", 0, 0, L""},
-    { L"win20",     L"Windows 2.0",     NULL,    2,  0,     0, VER_PLATFORM_WIN32s, L"Win32s 1.3", 0, 0, L""}
+    { L"win11",     L"Windows 11",      L"6.3", 10,  0, 22000,  588, VER_PLATFORM_WIN32_NT, L"", 0, 0, L"WinNT"},
+    { L"win10",     L"Windows 10",      L"6.3", 10,  0, 19045, 5796, VER_PLATFORM_WIN32_NT, L"", 0, 0, L"WinNT"},
+    { L"win81",     L"Windows 8.1",     NULL,    6,  3,  9600,    0, VER_PLATFORM_WIN32_NT, L"", 0, 0, L"WinNT"},
+    { L"win8",      L"Windows 8",       NULL,    6,  2,  9200,    0, VER_PLATFORM_WIN32_NT, L"", 0, 0, L"WinNT"},
+    { L"win2008r2", L"Windows 2008 R2", NULL,    6,  1,  7601,    0, VER_PLATFORM_WIN32_NT, L"Service Pack 1", 1, 0, L"ServerNT"},
+    { L"win7",      L"Windows 7",       NULL,    6,  1,  7601,    0, VER_PLATFORM_WIN32_NT, L"Service Pack 1", 1, 0, L"WinNT"},
+    { L"win2008",   L"Windows 2008",    NULL,    6,  0,  6002,    0, VER_PLATFORM_WIN32_NT, L"Service Pack 2", 2, 0, L"ServerNT"},
+    { L"vista",     L"Windows Vista",   NULL,    6,  0,  6002,    0, VER_PLATFORM_WIN32_NT, L"Service Pack 2", 2, 0, L"WinNT"},
+    { L"win2003",   L"Windows 2003",    NULL,    5,  2,  3790,    0, VER_PLATFORM_WIN32_NT, L"Service Pack 2", 2, 0, L"ServerNT"},
+    { L"winxp64",   L"Windows XP 64",   NULL,    5,  2,  3790,    0, VER_PLATFORM_WIN32_NT, L"Service Pack 2", 2, 0, L"WinNT"},
+    { L"winxp",     L"Windows XP",      NULL,    5,  1,  2600,    0, VER_PLATFORM_WIN32_NT, L"Service Pack 3", 3, 0, L"WinNT"},
+    { L"win2k",     L"Windows 2000",    NULL,    5,  0,  2195,    0, VER_PLATFORM_WIN32_NT, L"Service Pack 4", 4, 0, L"WinNT"},
+    { L"winme",     L"Windows ME",      NULL,    4, 90,  3000,    0, VER_PLATFORM_WIN32_WINDOWS, L" ", 0, 0, L""},
+    { L"win98",     L"Windows 98",      NULL,    4, 10,  2222,    0, VER_PLATFORM_WIN32_WINDOWS, L" A ", 0, 0, L""},
+    { L"win95",     L"Windows 95",      NULL,    4,  0,   950,    0, VER_PLATFORM_WIN32_WINDOWS, L"", 0, 0, L""},
+    { L"nt40",      L"Windows NT 4.0",  NULL,    4,  0,  1381,    0, VER_PLATFORM_WIN32_NT, L"Service Pack 6a", 6, 0, L"WinNT"},
+    { L"nt351",     L"Windows NT 3.51", NULL,    3, 51,  1057,    0, VER_PLATFORM_WIN32_NT, L"Service Pack 5", 5, 0, L"WinNT"},
+    { L"win31",     L"Windows 3.1",     NULL,    3, 10,     0,    0, VER_PLATFORM_WIN32s, L"Win32s 1.3", 0, 0, L""},
+    { L"win30",     L"Windows 3.0",     NULL,    3,  0,     0,    0, VER_PLATFORM_WIN32s, L"Win32s 1.3", 0, 0, L""},
+    { L"win20",     L"Windows 2.0",     NULL,    2,  0,     0,    0, VER_PLATFORM_WIN32s, L"Win32s 1.3", 0, 0, L""}
 };
 
 #define DEFAULT_WIN_VERSION   L"win10"
@@ -435,6 +436,7 @@ static void set_winver(const struct win_version *version)
             set_reg_key(HKEY_LOCAL_MACHINE, szKeyNT, L"CurrentBuild", NULL);
             set_reg_key(HKEY_LOCAL_MACHINE, szKeyNT, L"CurrentBuildNumber", NULL);
             set_reg_key(HKEY_LOCAL_MACHINE, szKeyNT, L"ProductName", NULL);
+            set_reg_key(HKEY_LOCAL_MACHINE, szKeyNT, L"UBR", NULL);
             set_reg_key(HKEY_LOCAL_MACHINE, szKeyProdNT, L"ProductType", NULL);
             set_reg_key(HKEY_LOCAL_MACHINE, szKeyWindNT, L"CSDVersion", NULL);
             set_reg_key(HKEY_LOCAL_MACHINE, szKeyEnvNT, L"OS", NULL);
@@ -449,6 +451,10 @@ static void set_winver(const struct win_version *version)
                 swprintf(buffer, ARRAY_SIZE(buffer), L"%d.%d", version->dwMajorVersion, version->dwMinorVersion);
                 set_reg_key(HKEY_LOCAL_MACHINE, szKeyNT, L"CurrentVersion", buffer);
             }
+            if (version->UBR)
+                set_reg_key_dword(HKEY_LOCAL_MACHINE, szKeyNT, L"UBR", version->UBR);
+            else
+                set_reg_key(HKEY_LOCAL_MACHINE, szKeyNT, L"UBR", NULL);
             set_reg_key_dword(HKEY_LOCAL_MACHINE, szKeyNT, L"CurrentMajorVersionNumber", version->dwMajorVersion);
             set_reg_key_dword(HKEY_LOCAL_MACHINE, szKeyNT, L"CurrentMinorVersionNumber", version->dwMinorVersion);
             set_reg_key(HKEY_LOCAL_MACHINE, szKeyNT, L"CSDVersion", version->szCSDVersion);
@@ -481,6 +487,7 @@ static void set_winver(const struct win_version *version)
             set_reg_key(HKEY_LOCAL_MACHINE, szKey9x, L"VersionNumber", NULL);
             set_reg_key(HKEY_LOCAL_MACHINE, szKey9x, L"SubVersionNumber", NULL);
             set_reg_key(HKEY_LOCAL_MACHINE, szKey9x, L"ProductName", NULL);
+            set_reg_key(HKEY_LOCAL_MACHINE, szKeyNT, L"UBR", NULL);
             set_reg_key(config_key, keypath(L""), L"Version", version->szVersion);
             break;
     }
-- 
2.49.0

From 7534c99a8ac3611deea70edefbe04f2fa11d9b83 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sat, 10 May 2025 01:54:58 -0400
Subject: [PATCH 038/159] winewayland: Don't use a destroyed surface in text
 input.

Co-Authored-By: Attila Fidan <dev@print0.net>
---
 dlls/winewayland.drv/wayland_surface.c    |  5 ++++
 dlls/winewayland.drv/wayland_text_input.c | 35 ++++++++++++-----------
 dlls/winewayland.drv/waylanddrv.h         |  2 +-
 3 files changed, 25 insertions(+), 17 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 76469a3bce4..24913df3234 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -238,6 +238,11 @@ void wayland_surface_destroy(struct wayland_surface *surface)
         process_wayland.keyboard.focused_hwnd = NULL;
     pthread_mutex_unlock(&process_wayland.keyboard.mutex);
 
+    pthread_mutex_lock(&process_wayland.text_input.mutex);
+    if (process_wayland.text_input.focused_hwnd == surface->hwnd)
+        process_wayland.text_input.focused_hwnd = NULL;
+    pthread_mutex_unlock(&process_wayland.text_input.mutex);
+
     wayland_surface_clear_role(surface);
 
     if (surface->wp_fractional_scale_v1)
diff --git a/dlls/winewayland.drv/wayland_text_input.c b/dlls/winewayland.drv/wayland_text_input.c
index e0181eb8240..f8df5fe09cb 100644
--- a/dlls/winewayland.drv/wayland_text_input.c
+++ b/dlls/winewayland.drv/wayland_text_input.c
@@ -61,16 +61,21 @@ static void text_input_enter(void *data, struct zwp_text_input_v3 *zwp_text_inpu
         struct wl_surface *surface)
 {
     struct wayland_text_input *text_input = data;
-    TRACE("data %p, text_input %p, surface %p.\n", data, zwp_text_input_v3, surface);
+    HWND hwnd;
+
+    if (!surface) return;
+
+    hwnd = wl_surface_get_user_data(surface);
+    TRACE("data %p, text_input %p, hwnd %p.\n", data, zwp_text_input_v3, hwnd);
 
     pthread_mutex_lock(&text_input->mutex);
+    text_input->focused_hwnd = hwnd;
     zwp_text_input_v3_enable(text_input->zwp_text_input_v3);
     zwp_text_input_v3_set_content_type(text_input->zwp_text_input_v3,
             ZWP_TEXT_INPUT_V3_CONTENT_HINT_NONE,
             ZWP_TEXT_INPUT_V3_CONTENT_PURPOSE_NORMAL);
     zwp_text_input_v3_set_cursor_rectangle(text_input->zwp_text_input_v3, 0, 0, 0, 0);
     zwp_text_input_v3_commit(text_input->zwp_text_input_v3);
-    text_input->wl_surface = surface;
     pthread_mutex_unlock(&text_input->mutex);
 }
 
@@ -78,16 +83,16 @@ static void text_input_leave(void *data, struct zwp_text_input_v3 *zwp_text_inpu
         struct wl_surface *surface)
 {
     struct wayland_text_input *text_input = data;
-    HWND hwnd;
-    TRACE("data %p, text_input %p, surface %p.\n", data, zwp_text_input_v3, surface);
+    TRACE("data %p, text_input %p.\n", data, zwp_text_input_v3);
 
     pthread_mutex_lock(&text_input->mutex);
     zwp_text_input_v3_disable(text_input->zwp_text_input_v3);
     zwp_text_input_v3_commit(text_input->zwp_text_input_v3);
-    assert(text_input->wl_surface);
-    hwnd = wl_surface_get_user_data(text_input->wl_surface);
-    post_ime_update(hwnd, 0, NULL, NULL);
-    text_input->wl_surface = NULL;
+    if (text_input->focused_hwnd)
+    {
+        post_ime_update(text_input->focused_hwnd, 0, NULL, NULL);
+        text_input->focused_hwnd = NULL;
+    }
     pthread_mutex_unlock(&text_input->mutex);
 }
 
@@ -127,18 +132,16 @@ static void text_input_done(void *data, struct zwp_text_input_v3 *zwp_text_input
         uint32_t serial)
 {
     struct wayland_text_input *text_input = data;
-    HWND hwnd;
     TRACE("data %p, text_input %p, serial %u.\n", data, zwp_text_input_v3, serial);
 
     pthread_mutex_lock(&text_input->mutex);
     /* Some compositors will send a done event for every commit, regardless of
      * the focus state of the text input. This behavior is arguably out of spec,
      * but otherwise harmless, so just ignore the new state in such cases. */
-    if (text_input->wl_surface)
+    if (text_input->focused_hwnd)
     {
-        hwnd = wl_surface_get_user_data(text_input->wl_surface);
-        post_ime_update(hwnd, text_input->preedit_cursor_pos, text_input->preedit_string,
-                text_input->commit_string);
+        post_ime_update(text_input->focused_hwnd, text_input->preedit_cursor_pos,
+                text_input->preedit_string, text_input->commit_string);
     }
 
     free(text_input->preedit_string);
@@ -177,7 +180,7 @@ void wayland_text_input_deinit(void)
     pthread_mutex_lock(&text_input->mutex);
     zwp_text_input_v3_destroy(text_input->zwp_text_input_v3);
     text_input->zwp_text_input_v3 = NULL;
-    text_input->wl_surface = NULL;
+    text_input->focused_hwnd = NULL;
     pthread_mutex_unlock(&text_input->mutex);
 };
 
@@ -194,13 +197,13 @@ BOOL WAYLAND_SetIMECompositionRect(HWND hwnd, RECT rect)
 
     pthread_mutex_lock(&text_input->mutex);
 
-    if (!text_input->zwp_text_input_v3)
+    if (!text_input->zwp_text_input_v3 || hwnd != text_input->focused_hwnd)
         goto err;
 
     if (!(data = wayland_win_data_get(hwnd)))
         goto err;
 
-    if (!(surface = data->wayland_surface) || surface->wl_surface != text_input->wl_surface)
+    if (!(surface = data->wayland_surface))
     {
         wayland_win_data_release(data);
         goto err;
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 0848d683ef7..1c2c29cc181 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -128,7 +128,7 @@ struct wayland_text_input
     WCHAR *preedit_string;
     DWORD preedit_cursor_pos;
     WCHAR *commit_string;
-    struct wl_surface *wl_surface;
+    HWND focused_hwnd;
     pthread_mutex_t mutex;
 };
 
-- 
2.49.0

From 0a45c2d9c978172567e9d13c40d113355db0a93c Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sat, 10 May 2025 12:22:40 -0400
Subject: [PATCH 039/159] hack: win32u: fix opengl applications on winewayland

---
 dlls/win32u/window.c                   | 3 ++-
 dlls/winewayland.drv/waylanddrv.h      | 1 +
 dlls/winewayland.drv/waylanddrv_main.c | 1 +
 dlls/winewayland.drv/window_surface.c  | 8 ++++++++
 4 files changed, 12 insertions(+), 1 deletion(-)

diff --git a/dlls/win32u/window.c b/dlls/win32u/window.c
index 614920f3c06..68fd577a390 100644
--- a/dlls/win32u/window.c
+++ b/dlls/win32u/window.c
@@ -2040,7 +2040,8 @@ static struct window_surface *get_window_surface( HWND hwnd, UINT swp_flags, BOO
     else if (create_layered || is_layered) needs_surface = TRUE;
 
     if (is_opengl && !is_layered && !create_layered
-        && !(!create_opaque && NtUserGetLayeredWindowAttributes( hwnd, NULL, NULL, &layered_flags ) && layered_flags & LWA_COLORKEY))
+        && !(!create_opaque && NtUserGetLayeredWindowAttributes( hwnd, NULL, NULL, &layered_flags ) && layered_flags & LWA_COLORKEY)
+        && !user_driver->pHasWindowManager("waylanddrv"))
     {
         if (new_surface) window_surface_release( new_surface );
         new_surface = NULL;
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 1c2c29cc181..dc069795d68 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -464,6 +464,7 @@ void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, HWND owner_hint, UIN
                               const struct window_rects *new_rects, struct window_surface *surface);
 BOOL WAYLAND_WindowPosChanging(HWND hwnd, UINT swp_flags, BOOL shaped, const struct window_rects *rects);
 BOOL WAYLAND_CreateWindowSurface(HWND hwnd, BOOL layered, const RECT *surface_rect, struct window_surface **surface);
+BOOL WAYLAND_HasWindowManager(const char *name);
 UINT WAYLAND_VulkanInit(UINT version, void *vulkan_handle, const struct vulkan_driver_funcs **driver_funcs);
 struct opengl_funcs *WAYLAND_wine_get_wgl_driver(UINT version);
 
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 640a70be20e..83a60848362 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -56,6 +56,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pWindowPosChanged = WAYLAND_WindowPosChanged,
     .pWindowPosChanging = WAYLAND_WindowPosChanging,
     .pCreateWindowSurface = WAYLAND_CreateWindowSurface,
+    .pHasWindowManager = WAYLAND_HasWindowManager,
     .pVulkanInit = WAYLAND_VulkanInit,
     .pwine_get_wgl_driver = WAYLAND_wine_get_wgl_driver,
 };
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index 36bbb2d4f67..094294fc40b 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -458,3 +458,11 @@ BOOL WAYLAND_CreateWindowSurface(HWND hwnd, BOOL layered, const RECT *surface_re
     wayland_win_data_release(data);
     return TRUE;
 }
+
+/***********************************************************************
+ *           WAYLAND_HasWindowManager
+ */
+BOOL WAYLAND_HasWindowManager(const char *name)
+{
+    return !strcmp("waylanddrv", name);
+}
-- 
2.49.0

From a7207aaa1815fe53ddeaeca9af40433d6edc4cb2 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sat, 10 May 2025 18:11:35 -0400
Subject: [PATCH 040/159] winewayland: register swap control tear

its up to compositor anyway, just no-op.
---
 dlls/winewayland.drv/opengl.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 0d7bf00ea0f..9d0aba68370 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -1244,6 +1244,7 @@ static BOOL init_opengl_funcs(void)
     opengl_funcs.ext.p_wglCreateContextAttribsARB = wayland_wglCreateContextAttribsARB;
 
     register_extension("WGL_EXT_swap_control");
+    register_extension("WGL_EXT_swap_control_tear");
     opengl_funcs.ext.p_wglGetSwapIntervalEXT = wayland_wglGetSwapIntervalEXT;
     opengl_funcs.ext.p_wglSwapIntervalEXT = wayland_wglSwapIntervalEXT;
 
-- 
2.49.0

From 2fc2c13f3d8223bb3f3ec0eb9d2fe04fa318e503 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sun, 11 May 2025 21:38:39 -0400
Subject: [PATCH 041/159] check if FSR4_UPGRADE env is nonzero

---
 dlls/amdxc64/main.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/dlls/amdxc64/main.c b/dlls/amdxc64/main.c
index 754e22f914f..d4dd071b0e0 100644
--- a/dlls/amdxc64/main.c
+++ b/dlls/amdxc64/main.c
@@ -82,6 +82,7 @@ typedef HRESULT (__stdcall *updateffxapi_pfn)(void*, unsigned int);
 
 HRESULT STDMETHODCALLTYPE AMDFSR4FFX_UpdateFfxApiProvider(IAmdExtFfxApi *iface, void* data, unsigned int size)
 {
+    const char *env;
     updateffxapi_pfn pfn;
     HMODULE amdffx = LoadLibraryA("amdxcffx64");
 
@@ -94,10 +95,11 @@ HRESULT STDMETHODCALLTYPE AMDFSR4FFX_UpdateFfxApiProvider(IAmdExtFfxApi *iface,
     }
 
     pfn = (updateffxapi_pfn)GetProcAddress(amdffx, "UpdateFfxApiProvider");
+    env = getenv("FSR4_UPGRADE");
 
-    if(pfn && getenv("FSR4_UPGRADE"))
+    if(pfn && env && env[0] != '0')
     {
-        FIXME("replaced fsr3 with fsr4!\n");
+        FIXME("Replaced FSR3 with FSR4!\n");
         return pfn(data, size);
     }
 
-- 
2.49.0

From 4dbbd8a4687dfd0fa9dad6f96e7f8003d53348a6 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sun, 11 May 2025 23:10:42 -0400
Subject: [PATCH 042/159] fixup! winewayland: handle locking with fractional
 scale notification

ruh roh I started using fixup lmao
---
 dlls/winewayland.drv/wayland_surface.c | 25 +++++++++++++++++--------
 1 file changed, 17 insertions(+), 8 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 24913df3234..589016cfb8b 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -138,18 +138,27 @@ static const struct xdg_toplevel_listener xdg_toplevel_listener =
     xdg_toplevel_handle_close
 };
 
-void wp_fractional_scale_handle_scale(void* data,
+void wp_fractional_scale_handle_scale(void* user_data,
         struct wp_fractional_scale_v1 *fractional_scale_v1, uint32_t scale)
 {
-    double *data_scale;
+    struct wayland_win_data *data;
+    struct wayland_surface *surface;
+    HWND hwnd = user_data;
+    assert(hwnd);
 
-    assert(data);
-    data_scale = data;
+    if ((data = wayland_win_data_get(hwnd)))
+    {
+        if((surface = data->wayland_surface))
+        {
+            surface->window.fractional_scale = scale / 120.0;
+            surface->window.scale =
+                surface->window.fractional_scale * NtUserGetSystemDpiForProcess(0) / 96.0;
 
-    /* FIXME: handle locking! */
-    *data_scale = scale / 120.0;
+            TRACE("Got scale %lf\n", surface->window.fractional_scale);
+        }
 
-    TRACE("Got scale %lf\n", *data_scale);
+        wayland_win_data_release(data);
+    }
 }
 
 static const struct wp_fractional_scale_v1_listener wp_fractional_scale_listener =
@@ -206,7 +215,7 @@ struct wayland_surface *wayland_surface_create(HWND hwnd)
         wp_fractional_scale_v1_add_listener(
             surface->wp_fractional_scale_v1,
             &wp_fractional_scale_listener,
-            &surface->window.fractional_scale);
+            hwnd);
     }
 
     return surface;
-- 
2.49.0

From 8248df50f91bb7abefd3b65fc6041512ee364d81 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 2 May 2025 16:59:04 +0300
Subject: [PATCH 043/159] winewayland: Use ARGB buffers for shaped windows.

When we detect a shaped window, switch to ARGB buffers in order to
be able to apply the shape (in a follow-up commit).
---
 dlls/winewayland.drv/wayland_surface.c |  1 +
 dlls/winewayland.drv/waylanddrv.h      |  1 +
 dlls/winewayland.drv/window_surface.c  | 66 +++++++++++++++++++-------
 3 files changed, 52 insertions(+), 16 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 589016cfb8b..5fce2b5aa1c 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -850,6 +850,7 @@ struct wayland_shm_buffer *wayland_shm_buffer_create(int width, int height,
     shm_buffer->ref = 1;
     shm_buffer->width = width;
     shm_buffer->height = height;
+    shm_buffer->format = format;
     shm_buffer->map_size = size;
 
     shm_buffer->damage_region = NtGdiCreateRectRgn(0, 0, width, height);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index dc069795d68..b68a217004c 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -255,6 +255,7 @@ struct wayland_shm_buffer
     struct wl_list link;
     struct wl_buffer *wl_buffer;
     int width, height;
+    uint32_t format;
     void *map_data;
     size_t map_size;
     BOOL busy;
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index 094294fc40b..1caff588680 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -38,6 +38,7 @@ struct wayland_buffer_queue
     struct wl_list buffer_list;
     int width;
     int height;
+    uint32_t format;
 };
 
 struct wayland_window_surface
@@ -101,7 +102,8 @@ static void wayland_buffer_queue_destroy(struct wayland_buffer_queue *queue)
  *
  * Creates a buffer queue containing buffers with the specified width and height.
  */
-static struct wayland_buffer_queue *wayland_buffer_queue_create(int width, int height)
+static struct wayland_buffer_queue *wayland_buffer_queue_create(int width, int height,
+                                                                uint32_t format)
 {
     struct wayland_buffer_queue *queue;
 
@@ -112,6 +114,7 @@ static struct wayland_buffer_queue *wayland_buffer_queue_create(int width, int h
     if (!queue->wl_event_queue) goto err;
     queue->width = width;
     queue->height = height;
+    queue->format = format;
 
     wl_list_init(&queue->buffer_list);
 
@@ -153,7 +156,7 @@ static struct wayland_shm_buffer *wayland_buffer_queue_get_free_buffer(struct wa
         if (nbuffers < 3)
         {
             shm_buffer = wayland_shm_buffer_create(queue->width, queue->height,
-                                                   WL_SHM_FORMAT_XRGB8888);
+                                                   queue->format);
             if (shm_buffer)
             {
                 /* Buffer events go to their own queue so that we can dispatch
@@ -241,7 +244,7 @@ RGNDATA *get_region_data(HRGN region)
  */
 static void copy_pixel_region(const char *src_pixels, RECT *src_rect,
                               char *dst_pixels, RECT *dst_rect,
-                              HRGN region)
+                              HRGN region, BOOL force_opaque)
 {
     static const int bpp = WINEWAYLAND_BYTES_PER_PIXEL;
     RGNDATA *rgndata = get_region_data(region);
@@ -261,7 +264,7 @@ static void copy_pixel_region(const char *src_pixels, RECT *src_rect,
     {
         const char *src;
         char *dst;
-        int y, width_bytes, height;
+        int x, y, width, height;
         RECT rc;
 
         TRACE("rect %s\n", wine_dbgstr_rect(rgn_rect));
@@ -271,21 +274,39 @@ static void copy_pixel_region(const char *src_pixels, RECT *src_rect,
 
         src = src_pixels + (rc.top - src_rect->top) * src_stride + (rc.left - src_rect->left) * bpp;
         dst = dst_pixels + (rc.top - dst_rect->top) * dst_stride + (rc.left - dst_rect->left) * bpp;
-        width_bytes = (rc.right - rc.left) * bpp;
+        width = rc.right - rc.left;
         height = rc.bottom - rc.top;
 
         /* Fast path for full width rectangles. */
-        if (width_bytes == src_stride && width_bytes == dst_stride)
+        if (width * bpp == src_stride && src_stride == dst_stride)
         {
-            memcpy(dst, src, height * width_bytes);
+            if (force_opaque)
+            {
+                for (x = 0; x < height * width; ++x)
+                    ((UINT32 *)dst)[x] = ((UINT32 *)src)[x] | 0xff000000;
+            }
+            else memcpy(dst, src, height * width * 4);
             continue;
         }
 
-        for (y = 0; y < height; y++)
+        if (force_opaque)
         {
-            memcpy(dst, src, width_bytes);
-            src += src_stride;
-            dst += dst_stride;
+            for (y = 0; y < height; y++)
+            {
+                for (x = 0; x < width; ++x)
+                    ((UINT32 *)dst)[x] = ((UINT32 *)src)[x] | 0xff000000;
+                src += src_stride;
+                dst += dst_stride;
+            }
+        }
+        else
+        {
+            for (y = 0; y < height; y++)
+            {
+                memcpy(dst, src, width * 4);
+                src += src_stride;
+                dst += dst_stride;
+            }
         }
     }
 
@@ -297,11 +318,11 @@ static void copy_pixel_region(const char *src_pixels, RECT *src_rect,
  */
 static void wayland_shm_buffer_copy_data(struct wayland_shm_buffer *buffer,
                                          const char *bits, RECT *rect,
-                                         HRGN region)
+                                         HRGN region, BOOL force_opaque)
 {
     RECT buffer_rect = {0, 0, buffer->width, buffer->height};
     TRACE("buffer=%p bits=%p rect=%s\n", buffer, bits, wine_dbgstr_rect(rect));
-    copy_pixel_region(bits, rect, buffer->map_data, &buffer_rect, region);
+    copy_pixel_region(bits, rect, buffer->map_data, &buffer_rect, region, force_opaque);
 }
 
 static void wayland_shm_buffer_copy(struct wayland_shm_buffer *src,
@@ -311,7 +332,8 @@ static void wayland_shm_buffer_copy(struct wayland_shm_buffer *src,
     RECT src_rect = {0, 0, src->width, src->height};
     RECT dst_rect = {0, 0, dst->width, dst->height};
     TRACE("src=%p dst=%p\n", src, dst);
-    copy_pixel_region(src->map_data, &src_rect, dst->map_data, &dst_rect, region);
+    copy_pixel_region(src->map_data, &src_rect, dst->map_data, &dst_rect, region,
+                      src->format == WL_SHM_FORMAT_XRGB8888 && dst->format == WL_SHM_FORMAT_ARGB8888);
 }
 
 /***********************************************************************
@@ -327,6 +349,7 @@ static BOOL wayland_window_surface_flush(struct window_surface *window_surface,
     BOOL flushed = FALSE;
     HRGN surface_damage_region = NULL;
     HRGN copy_from_window_region;
+    uint32_t buffer_format;
 
     surface_damage_region = NtGdiCreateRectRgn(rect->left + dirty->left, rect->top + dirty->top,
                                                rect->left + dirty->right, rect->top + dirty->bottom);
@@ -336,6 +359,16 @@ static BOOL wayland_window_surface_flush(struct window_surface *window_surface,
         goto done;
     }
 
+    buffer_format = shape_bits ? WL_SHM_FORMAT_ARGB8888 : WL_SHM_FORMAT_XRGB8888;
+    if (wws->wayland_buffer_queue->format != buffer_format)
+    {
+        int width = wws->wayland_buffer_queue->width;
+        int height = wws->wayland_buffer_queue->height;
+        TRACE("recreating buffer queue with format %d\n", buffer_format);
+        wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
+        wws->wayland_buffer_queue = wayland_buffer_queue_create(width, height, buffer_format);
+    }
+
     wayland_buffer_queue_add_damage(wws->wayland_buffer_queue, surface_damage_region);
 
     shm_buffer = wayland_buffer_queue_get_free_buffer(wws->wayland_buffer_queue);
@@ -377,7 +410,8 @@ static BOOL wayland_window_surface_flush(struct window_surface *window_surface,
         copy_from_window_region = shm_buffer->damage_region;
     }
 
-    wayland_shm_buffer_copy_data(shm_buffer, color_bits, &surface_rect, copy_from_window_region);
+    wayland_shm_buffer_copy_data(shm_buffer, color_bits, &surface_rect, copy_from_window_region,
+                                 !!shape_bits);
     NtGdiSetRectRgn(shm_buffer->damage_region, 0, 0, 0, 0);
 
     flushed = set_window_surface_contents(window_surface->hwnd, shm_buffer, surface_damage_region);
@@ -433,7 +467,7 @@ static struct window_surface *wayland_window_surface_create(HWND hwnd, const REC
     if ((window_surface = window_surface_create(sizeof(*wws), &wayland_window_surface_funcs, hwnd, rect, info, 0)))
     {
         struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
-        wws->wayland_buffer_queue = wayland_buffer_queue_create(width, height);
+        wws->wayland_buffer_queue = wayland_buffer_queue_create(width, height, WL_SHM_FORMAT_XRGB8888);
     }
 
     return window_surface;
-- 
2.49.0

From 7fbacd38434235d6113e06457544382a079ddf1a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 28 Jun 2024 20:23:44 +0200
Subject: [PATCH 044/159] winewayland: Implement window surface shape and color
 keying.

---
 dlls/winewayland.drv/window_surface.c | 30 +++++++++++++++++++++++++++
 1 file changed, 30 insertions(+)

diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index 1caff588680..408f52f3f77 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -336,6 +336,34 @@ static void wayland_shm_buffer_copy(struct wayland_shm_buffer *src,
                       src->format == WL_SHM_FORMAT_XRGB8888 && dst->format == WL_SHM_FORMAT_ARGB8888);
 }
 
+/**********************************************************************
+ *          wayland_shm_buffer_copy_shape
+ */
+static void wayland_shm_buffer_copy_shape(struct wayland_shm_buffer *buffer, const RECT *dirty,
+                                          const BITMAPINFO *shape_info, const void *shape_bits)
+{
+    RECT dst_rect = {0, 0, buffer->width, buffer->height};
+    UINT32 *color, shape_stride, color_stride, x, y;
+    const BYTE *shape;
+    RECT rect;
+
+    shape_stride = shape_info->bmiHeader.biSizeImage / abs(shape_info->bmiHeader.biHeight);
+    color_stride = dst_rect.right - dst_rect.left;
+
+    if (!intersect_rect(&rect, &dst_rect, dirty)) return;
+
+    color = (UINT32 *)buffer->map_data + rect.top * color_stride;
+    shape = (const BYTE *)shape_bits + rect.top * shape_stride;
+
+    for (y = rect.top; y < rect.bottom; y++, color += color_stride, shape += shape_stride)
+    {
+        for (x = rect.left; x < rect.right; x++)
+        {
+            if (!(shape[x / 8] & (1 << (7 - (x & 7))))) color[x] = 0;
+        }
+    }
+}
+
 /***********************************************************************
  *           wayland_window_surface_flush
  */
@@ -412,6 +440,8 @@ static BOOL wayland_window_surface_flush(struct window_surface *window_surface,
 
     wayland_shm_buffer_copy_data(shm_buffer, color_bits, &surface_rect, copy_from_window_region,
                                  !!shape_bits);
+    if (shape_bits) wayland_shm_buffer_copy_shape(shm_buffer, rect, shape_info, shape_bits);
+
     NtGdiSetRectRgn(shm_buffer->damage_region, 0, 0, 0, 0);
 
     flushed = set_window_surface_contents(window_surface->hwnd, shm_buffer, surface_damage_region);
-- 
2.49.0

From 4d0831368ed078aa5bec9ac180e4e37af930abf2 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Mon, 12 May 2025 08:52:18 -0400
Subject: [PATCH 045/159] minor formatting fix

---
 dlls/winewayland.drv/wayland_surface.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 5fce2b5aa1c..bbf307b982f 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -138,7 +138,7 @@ static const struct xdg_toplevel_listener xdg_toplevel_listener =
     xdg_toplevel_handle_close
 };
 
-void wp_fractional_scale_handle_scale(void* user_data,
+void wp_fractional_scale_handle_scale(void *user_data,
         struct wp_fractional_scale_v1 *fractional_scale_v1, uint32_t scale)
 {
     struct wayland_win_data *data;
-- 
2.49.0

From f4e474622f5040e1a8a95d08011dfd99820256b2 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Tue, 13 May 2025 16:29:55 -0400
Subject: [PATCH 046/159] ntdll: remove outdated workaround for rainbow six
 extraction

---
 dlls/ntdll/unix/loader.c | 7 -------
 1 file changed, 7 deletions(-)

diff --git a/dlls/ntdll/unix/loader.c b/dlls/ntdll/unix/loader.c
index f339dc64f9b..0232d34e560 100644
--- a/dlls/ntdll/unix/loader.c
+++ b/dlls/ntdll/unix/loader.c
@@ -2259,13 +2259,6 @@ static void hacks_init(void)
         ERR("HACK: setting LIBGL_ALWAYS_SOFTWARE.\n");
         setenv("LIBGL_ALWAYS_SOFTWARE", "1", 0);
     }
-
-    if (sgi && !strcmp(sgi, "2379390"))
-    {
-        ERR("HACK: setting vk_x11_override_min_image_count, vk_x11_strict_image_count.\n");
-        setenv("vk_x11_override_min_image_count", "2", 0);
-        setenv("vk_x11_strict_image_count", "true", 0);
-    }
 }
 
 /***********************************************************************
-- 
2.49.0

From cb7832de64d1ec83ce398845c64e4998255cad83 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Thu, 15 May 2025 10:12:42 -0400
Subject: [PATCH 047/159] HACK: kernelbase: Add Wayland specific workarounds.

---
 dlls/kernelbase/process.c | 38 ++++++++++++++++++++++++++++++++------
 1 file changed, 32 insertions(+), 6 deletions(-)

diff --git a/dlls/kernelbase/process.c b/dlls/kernelbase/process.c
index 7a51dfd231d..78b45e9fca8 100644
--- a/dlls/kernelbase/process.c
+++ b/dlls/kernelbase/process.c
@@ -584,13 +584,14 @@ static int battleye_launcher_redirect_hack( const WCHAR *app_name, WCHAR *new_na
 
 static const WCHAR *hack_append_command_line( const WCHAR *cmd )
 {
-    static const struct
+    struct option
     {
         const WCHAR *exe_name;
         const WCHAR *append;
         const char *steamgameid;
-    }
-    options[] =
+    };
+
+    static const struct option options[] =
     {
         {L"Click&Fight.exe", L" --disable_direct_composition=1"},
         {L"Willful.exe", L" --disable_direct_composition=1"},
@@ -620,8 +621,17 @@ static const WCHAR *hack_append_command_line( const WCHAR *cmd )
         {L"UnrealCEFSubProcess.exe", L" --use-angle=d3d9", "2684500"},
         {L"\\EACefSubProcess.exe", L" --use-angle=vulkan"},
     };
+
+    /* Generally just workarounds for winewayland not supporting cross process rendering (yet) */
+    static const struct option wayland_options[] = {
+        { L"launcher_epic.exe", L" --in-process-gpu"} /* ZZZ EGS */
+    };
+
     unsigned int i;
-    char sgi[64];
+    char sgi[64] = {0};
+    char wayland_hack_enabled[64] = {0};
+
+    GetEnvironmentVariableA("SteamGameId", sgi, sizeof(sgi));
 
     if (!cmd) return NULL;
 
@@ -629,13 +639,29 @@ static const WCHAR *hack_append_command_line( const WCHAR *cmd )
     {
         if (wcsstr( cmd, options[i].exe_name ))
         {
-            if (options[i].steamgameid && !(GetEnvironmentVariableA( "SteamGameId", sgi, sizeof(sgi) )
-                && !strcmp( sgi, options[i].steamgameid )))
+            if (options[i].steamgameid && strcmp( sgi, options[i].steamgameid ))
                 continue;
             FIXME( "HACK: appending %s to command line.\n", debugstr_w(options[i].append) );
             return options[i].append;
         }
     }
+
+    GetEnvironmentVariableA("WINE_WAYLAND_HACKS",
+            wayland_hack_enabled, sizeof(wayland_hack_enabled));
+
+    if (wayland_hack_enabled[0] != '1') return NULL;
+
+    for (i = 0; i < ARRAY_SIZE(wayland_options); ++i)
+    {
+        if (wcsstr( cmd, wayland_options[i].exe_name ))
+        {
+            if (wayland_options[i].steamgameid && strcmp( sgi, wayland_options[i].steamgameid ))
+                continue;
+            FIXME( "HACK: appending %s to command line.\n", debugstr_w(wayland_options[i].append) );
+            return wayland_options[i].append;
+        }
+    }
+
     return NULL;
 }
 
-- 
2.49.0

From c53e075939fbe8288de490310e20d4eb009161b1 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Thu, 15 May 2025 10:17:06 -0400
Subject: [PATCH 048/159] fixup! kernelbase: Check for wayland hacks first

---
 dlls/kernelbase/process.c | 33 +++++++++++++++++----------------
 1 file changed, 17 insertions(+), 16 deletions(-)

diff --git a/dlls/kernelbase/process.c b/dlls/kernelbase/process.c
index 78b45e9fca8..2c4cc1e5b83 100644
--- a/dlls/kernelbase/process.c
+++ b/dlls/kernelbase/process.c
@@ -635,30 +635,31 @@ static const WCHAR *hack_append_command_line( const WCHAR *cmd )
 
     if (!cmd) return NULL;
 
-    for (i = 0; i < ARRAY_SIZE(options); ++i)
+    GetEnvironmentVariableA("WINE_WAYLAND_HACKS",
+        wayland_hack_enabled, sizeof(wayland_hack_enabled));
+
+    if (wayland_hack_enabled[0] == '1')
     {
-        if (wcsstr( cmd, options[i].exe_name ))
+        for (i = 0; i < ARRAY_SIZE(wayland_options); ++i)
         {
-            if (options[i].steamgameid && strcmp( sgi, options[i].steamgameid ))
-                continue;
-            FIXME( "HACK: appending %s to command line.\n", debugstr_w(options[i].append) );
-            return options[i].append;
+            if (wcsstr( cmd, wayland_options[i].exe_name ))
+            {
+                if (wayland_options[i].steamgameid && strcmp( sgi, wayland_options[i].steamgameid ))
+                    continue;
+                FIXME( "HACK: appending %s to command line.\n", debugstr_w(wayland_options[i].append) );
+                return wayland_options[i].append;
+            }
         }
     }
 
-    GetEnvironmentVariableA("WINE_WAYLAND_HACKS",
-            wayland_hack_enabled, sizeof(wayland_hack_enabled));
-
-    if (wayland_hack_enabled[0] != '1') return NULL;
-
-    for (i = 0; i < ARRAY_SIZE(wayland_options); ++i)
+    for (i = 0; i < ARRAY_SIZE(options); ++i)
     {
-        if (wcsstr( cmd, wayland_options[i].exe_name ))
+        if (wcsstr( cmd, options[i].exe_name ))
         {
-            if (wayland_options[i].steamgameid && strcmp( sgi, wayland_options[i].steamgameid ))
+            if (options[i].steamgameid && strcmp( sgi, options[i].steamgameid ))
                 continue;
-            FIXME( "HACK: appending %s to command line.\n", debugstr_w(wayland_options[i].append) );
-            return wayland_options[i].append;
+            FIXME( "HACK: appending %s to command line.\n", debugstr_w(options[i].append) );
+            return options[i].append;
         }
     }
 
-- 
2.49.0

From b974221c3a39cc15b72ea08beca9cbe8a9d10d90 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Thu, 15 May 2025 11:19:18 -0400
Subject: [PATCH 049/159] formatting fix

---
 dlls/kernelbase/process.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/kernelbase/process.c b/dlls/kernelbase/process.c
index 2c4cc1e5b83..2f609cbba8d 100644
--- a/dlls/kernelbase/process.c
+++ b/dlls/kernelbase/process.c
@@ -624,7 +624,7 @@ static const WCHAR *hack_append_command_line( const WCHAR *cmd )
 
     /* Generally just workarounds for winewayland not supporting cross process rendering (yet) */
     static const struct option wayland_options[] = {
-        { L"launcher_epic.exe", L" --in-process-gpu"} /* ZZZ EGS */
+        {L"launcher_epic.exe", L" --in-process-gpu"}, /* ZZZ EGS */
     };
 
     unsigned int i;
-- 
2.49.0

From 2779490d5c2b7c40d66dd656144ab4ef7fe52bdb Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Thu, 15 May 2025 13:47:59 -0400
Subject: [PATCH 050/159] kernelbase: Enable in-process-gpu for battle.net

---
 dlls/kernelbase/process.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/kernelbase/process.c b/dlls/kernelbase/process.c
index 2f609cbba8d..f0534eff8c0 100644
--- a/dlls/kernelbase/process.c
+++ b/dlls/kernelbase/process.c
@@ -625,16 +625,16 @@ static const WCHAR *hack_append_command_line( const WCHAR *cmd )
     /* Generally just workarounds for winewayland not supporting cross process rendering (yet) */
     static const struct option wayland_options[] = {
         {L"launcher_epic.exe", L" --in-process-gpu"}, /* ZZZ EGS */
+        {L"Battle.net.exe", L" --in-process-gpu"},
     };
 
     unsigned int i;
     char sgi[64] = {0};
     char wayland_hack_enabled[64] = {0};
 
-    GetEnvironmentVariableA("SteamGameId", sgi, sizeof(sgi));
-
     if (!cmd) return NULL;
 
+    GetEnvironmentVariableA("SteamGameId", sgi, sizeof(sgi));
     GetEnvironmentVariableA("WINE_WAYLAND_HACKS",
         wayland_hack_enabled, sizeof(wayland_hack_enabled));
 
-- 
2.49.0

From bed967536f48bdd044c189e7f3f1a708a628e21a Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Thu, 15 May 2025 16:11:24 -0400
Subject: [PATCH 051/159] kernelbase: Add in-process-gpu for RSI launcher

---
 dlls/kernelbase/process.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/kernelbase/process.c b/dlls/kernelbase/process.c
index f0534eff8c0..4797d30dc8f 100644
--- a/dlls/kernelbase/process.c
+++ b/dlls/kernelbase/process.c
@@ -626,6 +626,7 @@ static const WCHAR *hack_append_command_line( const WCHAR *cmd )
     static const struct option wayland_options[] = {
         {L"launcher_epic.exe", L" --in-process-gpu"}, /* ZZZ EGS */
         {L"Battle.net.exe", L" --in-process-gpu"},
+        {L"RSI Launcher.exe", L" --in-process-gpu"}
     };
 
     unsigned int i;
-- 
2.49.0

From 59dd8f3066a723ccd7d1235ce2dacce6b28114a7 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Thu, 15 May 2025 16:14:54 -0400
Subject: [PATCH 052/159] winewayland: Implement touchpad scrolling support.

I hate this so much, but it's the best we can do I think
---
 dlls/winewayland.drv/wayland_pointer.c | 74 ++++++++++++++++++--------
 dlls/winewayland.drv/waylanddrv.h      |  2 +
 2 files changed, 53 insertions(+), 23 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index ebd09d87b2a..86443e3fd75 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -270,6 +270,57 @@ static void pointer_handle_button(void *data, struct wl_pointer *wl_pointer,
 static void pointer_handle_axis(void *data, struct wl_pointer *wl_pointer,
                                 uint32_t time, uint32_t axis, wl_fixed_t value)
 {
+    HWND hwnd;
+    INPUT input = {0};
+    /*
+        We are given a distance in the surface local coordinate system.
+        However, we need to convert that into a WHEEL_DELTA which represents
+        physical mouse wheel motion. Using default settings on KDE Plasma,
+        I obtained a value of 15 for one mouse wheel click. So that is the
+        value I have chosen for now. However, what do other compositors default to?
+        Additionally, the system's scroll sensitivity now affects winewayland,
+        is that going to cause issues?
+
+        So many unknowns for such a seemingly trivial task :(
+        just because we are trying to support touchpads...
+    */
+    double scroll_value = (wl_fixed_to_double(value) / 15.0) * WHEEL_DELTA;
+    struct wayland_pointer *pointer = &process_wayland.pointer;
+
+    if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
+
+    input.type = INPUT_MOUSE;
+
+    /*
+        Truncation makes the most sense:
+        Imagine a infinite resolution scroll wheel
+        Assume that input axis value is some fraction of a tick
+        Accumulate input axis value * WHEEL_DELTA
+        Truncate to WHEEL_DELTA precision
+        Do subtraction on original value
+        Leftover accumulation is just leftover rotation on the wheel
+    */
+    switch (axis)
+    {
+        case WL_POINTER_AXIS_VERTICAL_SCROLL:
+            input.mi.dwFlags = MOUSEEVENTF_WHEEL;
+            pointer->accum_wheel += -scroll_value;
+            input.mi.mouseData = trunc(pointer->accum_wheel / WHEEL_DELTA) * WHEEL_DELTA;
+            pointer->accum_wheel -= (int)input.mi.mouseData;
+            break;
+        case WL_POINTER_AXIS_HORIZONTAL_SCROLL:
+            input.mi.dwFlags = MOUSEEVENTF_HWHEEL;
+            pointer->accum_wheelH += scroll_value;
+            input.mi.mouseData = trunc(pointer->accum_wheelH / WHEEL_DELTA) * WHEEL_DELTA;
+            pointer->accum_wheelH -= (int)input.mi.mouseData;
+            break;
+        default: break;
+    }
+
+    TRACE("hwnd=%p axis=%u value=%lf out=%d\n", hwnd, axis, scroll_value, (int)input.mi.mouseData);
+
+    if (input.mi.mouseData)
+        NtUserSendHardwareInput(hwnd, 0, &input, 0);
 }
 
 static void pointer_handle_frame(void *data, struct wl_pointer *wl_pointer)
@@ -289,29 +340,6 @@ static void pointer_handle_axis_stop(void *data, struct wl_pointer *wl_pointer,
 static void pointer_handle_axis_discrete(void *data, struct wl_pointer *wl_pointer,
                                          uint32_t axis, int32_t discrete)
 {
-    INPUT input = {0};
-    HWND hwnd;
-
-    if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
-
-    input.type = INPUT_MOUSE;
-
-    switch (axis)
-    {
-    case WL_POINTER_AXIS_VERTICAL_SCROLL:
-        input.mi.dwFlags = MOUSEEVENTF_WHEEL;
-        input.mi.mouseData = -WHEEL_DELTA * discrete;
-        break;
-    case WL_POINTER_AXIS_HORIZONTAL_SCROLL:
-        input.mi.dwFlags = MOUSEEVENTF_HWHEEL;
-        input.mi.mouseData = WHEEL_DELTA * discrete;
-        break;
-    default: break;
-    }
-
-    TRACE("hwnd=%p axis=%u discrete=%d\n", hwnd, axis, discrete);
-
-    NtUserSendHardwareInput(hwnd, 0, &input, 0);
 }
 
 static const struct wl_pointer_listener pointer_listener =
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index b68a217004c..7a800c607ed 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -119,6 +119,8 @@ struct wayland_pointer
     struct wayland_cursor cursor;
     double accum_x;
     double accum_y;
+    double accum_wheel;
+    double accum_wheelH;
     pthread_mutex_t mutex;
 };
 
-- 
2.49.0

From c1c59d3eb67e72d9b403ff47ad9b1b247811eb08 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Thu, 15 May 2025 19:22:47 -0400
Subject: [PATCH 053/159] winewayland: Use unaccelerated relative motion.

---
 dlls/winewayland.drv/wayland_pointer.c | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 86443e3fd75..f3e4c51a576 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -383,9 +383,10 @@ static void relative_pointer_v1_relative_motion(void *private,
     if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
     if (!(data = wayland_win_data_get(hwnd))) return;
 
+    /* Use "raw" input by default. However, it's not nessessarily raw */
     wayland_motion_delta_to_window(data->wayland_surface,
-                                   wl_fixed_to_double(dx),
-                                   wl_fixed_to_double(dy),
+                                   wl_fixed_to_double(dx_unaccel),
+                                   wl_fixed_to_double(dy_unaccel),
                                    &screen_x, &screen_y);
     wayland_win_data_release(data);
 
@@ -405,7 +406,7 @@ static void relative_pointer_v1_relative_motion(void *private,
     pthread_mutex_unlock(&pointer->mutex);
 
     TRACE("hwnd=%p wayland_dxdy=%.2f,%.2f accum_dxdy=%d,%d\n",
-          hwnd, wl_fixed_to_double(dx), wl_fixed_to_double(dy),
+          hwnd, wl_fixed_to_double(dx_unaccel), wl_fixed_to_double(dy_unaccel),
           (int)input.mi.dx, (int)input.mi.dy);
 
     NtUserSendHardwareInput(hwnd, 0, &input, 0);
-- 
2.49.0

From ac5cd6589959eaff4d5d29ff9551fc84fccbdb31 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Thu, 15 May 2025 19:55:01 -0400
Subject: [PATCH 054/159] winewayland: Use discrete event when possible.

---
 dlls/winewayland.drv/wayland_pointer.c | 30 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  1 +
 2 files changed, 31 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index f3e4c51a576..cc1941cece2 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -281,6 +281,9 @@ static void pointer_handle_axis(void *data, struct wl_pointer *wl_pointer,
         Additionally, the system's scroll sensitivity now affects winewayland,
         is that going to cause issues?
 
+        We can alleviate these issues for physical scroll wheels using the discrete
+        event at least.
+
         So many unknowns for such a seemingly trivial task :(
         just because we are trying to support touchpads...
     */
@@ -288,6 +291,7 @@ static void pointer_handle_axis(void *data, struct wl_pointer *wl_pointer,
     struct wayland_pointer *pointer = &process_wayland.pointer;
 
     if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
+    if (InterlockedCompareExchange(&pointer->discrete_event_handled, FALSE, TRUE)) return;
 
     input.type = INPUT_MOUSE;
 
@@ -340,6 +344,32 @@ static void pointer_handle_axis_stop(void *data, struct wl_pointer *wl_pointer,
 static void pointer_handle_axis_discrete(void *data, struct wl_pointer *wl_pointer,
                                          uint32_t axis, int32_t discrete)
 {
+    INPUT input = {0};
+    HWND hwnd;
+    struct wayland_pointer *pointer = &process_wayland.pointer;
+
+    if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
+
+    InterlockedExchange(&pointer->discrete_event_handled, TRUE);
+
+    input.type = INPUT_MOUSE;
+
+    switch (axis)
+    {
+        case WL_POINTER_AXIS_VERTICAL_SCROLL:
+            input.mi.dwFlags = MOUSEEVENTF_WHEEL;
+            input.mi.mouseData = -WHEEL_DELTA * discrete;
+            break;
+        case WL_POINTER_AXIS_HORIZONTAL_SCROLL:
+            input.mi.dwFlags = MOUSEEVENTF_HWHEEL;
+            input.mi.mouseData = WHEEL_DELTA * discrete;
+            break;
+        default: break;
+    }
+
+    TRACE("hwnd=%p axis=%u discrete=%d\n", hwnd, axis, discrete);
+
+    NtUserSendHardwareInput(hwnd, 0, &input, 0);
 }
 
 static const struct wl_pointer_listener pointer_listener =
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 7a800c607ed..26208dae23c 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -121,6 +121,7 @@ struct wayland_pointer
     double accum_y;
     double accum_wheel;
     double accum_wheelH;
+    LONG discrete_event_handled;
     pthread_mutex_t mutex;
 };
 
-- 
2.49.0

From 62b703056571d1ebe26d8830a5cdaee4bf4551b4 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sat, 17 May 2025 15:08:08 -0400
Subject: [PATCH 055/159] winewayland: Handle rotated screens.

Some win32u issues with vertical monitors? But works exactly the same as winex11 so I think this is a win
---
 dlls/winewayland.drv/wayland_output.c | 19 +++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h     |  1 +
 2 files changed, 20 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index f76881a1770..ce388d02f21 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -39,6 +39,7 @@ static uint32_t next_output_id = 0;
 #define WAYLAND_OUTPUT_CHANGED_NAME       0x02
 #define WAYLAND_OUTPUT_CHANGED_LOGICAL_XY 0x04
 #define WAYLAND_OUTPUT_CHANGED_LOGICAL_WH 0x08
+#define WAYLAND_OUTPUT_CHANGED_TRANSFORM  0x10
 
 /**********************************************************************
  *          Output handling
@@ -139,6 +140,14 @@ static void wayland_output_done(struct wayland_output *output)
     {
         RB_FOR_EACH_ENTRY(mode, &output->pending.modes, struct wayland_output_mode, entry)
         {
+            /* Need to flip w,h when the output is transformed by 90 or 270 degrees */
+            if (output->pending.transform == WL_OUTPUT_TRANSFORM_270 ||
+                output->pending.transform == WL_OUTPUT_TRANSFORM_90)
+            {
+                const int32_t temp = mode->width;
+                mode->width = mode->height;
+                mode->height = temp;
+            }
             wayland_output_state_add_mode(&output->current,
                                           mode->width, mode->height, mode->refresh,
                                           mode == output->pending.current_mode);
@@ -167,6 +176,11 @@ static void wayland_output_done(struct wayland_output *output)
         output->current.logical_h = output->pending.logical_h;
     }
 
+    if (output->pending_flags & WAYLAND_OUTPUT_CHANGED_TRANSFORM)
+    {
+        output->current.transform = output->pending.transform;
+    }
+
     output->pending_flags = 0;
 
     /* Ensure the logical dimensions have sane values. */
@@ -200,6 +214,11 @@ static void output_handle_geometry(void *data, struct wl_output *wl_output,
                                    const char *make, const char *model,
                                    int32_t output_transform)
 {
+    struct wayland_output *output = data;
+
+    output->pending.transform = output_transform;
+
+    output->pending_flags |= WAYLAND_OUTPUT_CHANGED_TRANSFORM;
 }
 
 static void output_handle_mode(void *data, struct wl_output *wl_output,
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 26208dae23c..b4afe72e1a7 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -209,6 +209,7 @@ struct wayland_output_state
     char *name;
     int logical_x, logical_y;
     int logical_w, logical_h;
+    int transform;
 };
 
 struct wayland_output
-- 
2.49.0

From 710c5ffa097fa325f802111d103bdd0e76dc26d8 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Wed, 21 May 2025 19:43:39 -0400
Subject: [PATCH 056/159] fixup! winewayland: Handle rotated screens.

---
 dlls/winewayland.drv/wayland_output.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index ce388d02f21..dbd51fbc8dc 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -141,8 +141,7 @@ static void wayland_output_done(struct wayland_output *output)
         RB_FOR_EACH_ENTRY(mode, &output->pending.modes, struct wayland_output_mode, entry)
         {
             /* Need to flip w,h when the output is transformed by 90 or 270 degrees */
-            if (output->pending.transform == WL_OUTPUT_TRANSFORM_270 ||
-                output->pending.transform == WL_OUTPUT_TRANSFORM_90)
+            if (output->pending.transform & WL_OUTPUT_TRANSFORM_90)
             {
                 const int32_t temp = mode->width;
                 mode->width = mode->height;
-- 
2.49.0

From 70dc5256ac901067a1985f76351300dc53a48079 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Thu, 22 May 2025 21:50:42 -0400
Subject: [PATCH 057/159] winewayland: make wp_fractional_scale_handle_scale
 static

---
 dlls/winewayland.drv/wayland_surface.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index bbf307b982f..f07f995a39e 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -138,7 +138,7 @@ static const struct xdg_toplevel_listener xdg_toplevel_listener =
     xdg_toplevel_handle_close
 };
 
-void wp_fractional_scale_handle_scale(void *user_data,
+static void wp_fractional_scale_handle_scale(void *user_data,
         struct wp_fractional_scale_v1 *fractional_scale_v1, uint32_t scale)
 {
     struct wayland_win_data *data;
-- 
2.49.0

From 3cd4b1647b00cf50cd79deb327a15b6d246cbd2e Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Thu, 22 May 2025 21:51:13 -0400
Subject: [PATCH 058/159] winewayland: Place fullscreen windows on associated
 output.

---
 dlls/winewayland.drv/display.c    |  7 ++++++
 dlls/winewayland.drv/waylanddrv.h |  6 +++++
 dlls/winewayland.drv/window.c     | 41 ++++++++++++++++++++++++++++++-
 3 files changed, 53 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index 851c9638252..c5d599efb54 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -180,6 +180,13 @@ static void output_info_array_arrange_physical_coords(struct wl_array *output_in
            ++steps < num_outputs)
         continue;
 
+    /* Initialize resolved coordinates with updated coordinates */
+    wl_array_for_each(info, output_info_array)
+    {
+        info->output->resolved_x = info->x;
+        info->output->resolved_y = info->y;
+    }
+
     /* Now that we have our physical pixel coordinates, sort from physical left
      * to right, but ensure the primary output is first. */
     qsort(output_info_array->data, num_outputs, sizeof(struct output_info),
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index b4afe72e1a7..52a4f1b160c 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -207,6 +207,7 @@ struct wayland_output_state
     struct rb_tree modes;
     struct wayland_output_mode *current_mode;
     char *name;
+    int resolved_x, resolved_y; /* store positions post overlap correction */
     int logical_x, logical_y;
     int logical_w, logical_h;
     int transform;
@@ -442,6 +443,11 @@ static inline BOOL intersect_rect(RECT *dst, const RECT *src1, const RECT *src2)
     return !IsRectEmpty(dst);
 }
 
+static inline LONG area_rect(const RECT *rect)
+{
+    return (rect->bottom - rect->top) * (rect->right - rect->left);
+}
+
 static inline LRESULT send_message(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
 {
     return NtUserMessageCall(hwnd, msg, wparam, lparam, NULL, NtUserSendMessage, FALSE);
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 648792616af..70b3c2080c0 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -239,6 +239,42 @@ static BOOL wayland_win_data_create_wayland_surface(struct wayland_win_data *dat
     return TRUE;
 }
 
+static struct wl_output *wayland_surface_get_best_output(struct wayland_surface *surface)
+{
+    struct wayland_output *output;
+    struct wl_output *best = NULL;
+    RECT output_rect, temp, intersect = {0};
+    const RECT *window_rect = &surface->window.rect;
+
+    wl_list_for_each(output, &process_wayland.output_list, link)
+    {
+        SetRect(&output_rect, 0, 0,
+                output->current.current_mode->width,
+                output->current.current_mode->height);
+        OffsetRect(&output_rect,
+                output->current.resolved_x,
+                output->current.resolved_y);
+
+        TRACE("output %s, %s window %s\n",
+              output->current.name,
+              wine_dbgstr_rect(&output_rect),
+              wine_dbgstr_rect(window_rect));
+
+        if (intersect_rect(&temp, window_rect, &output_rect) &&
+                area_rect(&temp) > area_rect(&intersect))
+        {
+            intersect = temp;
+            best = output->wl_output;
+        }
+    }
+
+    if (!best)
+        WARN("Could not find associated wl_output for rect %s!\n",
+             wine_dbgstr_rect(window_rect));
+
+    return best;
+}
+
 static void wayland_surface_update_state_toplevel(struct wayland_surface *surface)
 {
     BOOL processing_config = surface->processing.serial &&
@@ -274,7 +310,10 @@ static void wayland_surface_update_state_toplevel(struct wayland_surface *surfac
         if ((surface->window.state & WAYLAND_SURFACE_CONFIG_STATE_FULLSCREEN) &&
            !(surface->current.state & WAYLAND_SURFACE_CONFIG_STATE_FULLSCREEN))
         {
-            xdg_toplevel_set_fullscreen(surface->xdg_toplevel, NULL);
+            pthread_mutex_lock(&process_wayland.output_mutex);
+            xdg_toplevel_set_fullscreen(surface->xdg_toplevel,
+                        wayland_surface_get_best_output(surface));
+            pthread_mutex_unlock(&process_wayland.output_mutex);
         }
     }
     else
-- 
2.49.0

From f6558fe8713d0dbf134cc9442634fac07044f8bb Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Fri, 23 May 2025 14:02:30 -0400
Subject: [PATCH 059/159] HACK: ntdll: Ignore SDL_VIDEODRIVER env

---
 dlls/ntdll/unix/env.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/ntdll/unix/env.c b/dlls/ntdll/unix/env.c
index 3c18484f417..98389c75ca6 100644
--- a/dlls/ntdll/unix/env.c
+++ b/dlls/ntdll/unix/env.c
@@ -347,6 +347,7 @@ static BOOL is_special_env_var( const char *var )
             STARTS_WITH( var, "TMP=" ) ||
             STARTS_WITH( var, "QT_" ) ||
             STARTS_WITH( var, "SDL_AUDIODRIVER=" ) ||
+            STARTS_WITH( var, "SDL_VIDEODRIVER=" ) || /* the only allowed video driver on windows is windows */
             STARTS_WITH( var, "VK_" ) ||
             STARTS_WITH( var, "XR_" ) ||
             STARTS_WITH( var, "XDG_SESSION_TYPE=" ));
-- 
2.49.0

From dcda0cef8ab96d352f06e85d43fe5898ad403488 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Fri, 23 May 2025 14:09:14 -0400
Subject: [PATCH 060/159] fixup! winewayland: Place fullscreen windows on
 associated output.

---
 dlls/winewayland.drv/wayland_output.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index dbd51fbc8dc..73b0b8332c5 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -167,6 +167,8 @@ static void wayland_output_done(struct wayland_output *output)
     {
         output->current.logical_x = output->pending.logical_x;
         output->current.logical_y = output->pending.logical_y;
+        output->current.resolved_x = output->current.logical_x;
+        output->current.resolved_y = output->current.logical_y;
     }
 
     if (output->pending_flags & WAYLAND_OUTPUT_CHANGED_LOGICAL_WH)
-- 
2.49.0

From 6c24f161de0c2966ed78a7947e862a66706b4208 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Fri, 23 May 2025 17:45:55 -0400
Subject: [PATCH 061/159] HACK: winewayland: Support output switching

---
 dlls/winewayland.drv/wayland_surface.c | 114 +++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |   2 +
 dlls/winewayland.drv/window.c          |  36 --------
 3 files changed, 116 insertions(+), 36 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index f07f995a39e..3de12a1afe2 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -166,6 +166,66 @@ static const struct wp_fractional_scale_v1_listener wp_fractional_scale_listener
     wp_fractional_scale_handle_scale
 };
 
+static void wl_surface_handle_enter(void *user_data, struct wl_surface *wl_surface, struct wl_output *wl_output)
+{
+    struct wayland_win_data *data;
+    struct wayland_output *output;
+    HWND hwnd = user_data;
+
+    if ((data = wayland_win_data_get(hwnd)))
+    {
+        if (data->wayland_surface)
+        {
+            pthread_mutex_lock(&process_wayland.output_mutex);
+            wl_list_for_each(output, &process_wayland.output_list, link)
+            {
+                if (output->wl_output == wl_output)
+                {
+                    TRACE("Setting output %p for surface %p\n", wl_output, data->wayland_surface);
+                    data->wayland_surface->wl_output = wl_output;
+                    break;
+                }
+            }
+            pthread_mutex_unlock(&process_wayland.output_mutex);
+        }
+
+        wayland_win_data_release(data);
+    }
+}
+
+static void wl_surface_handle_leave(void *user_data, struct wl_surface *surface, struct wl_output *wl_output)
+{
+    struct wayland_win_data *data;
+    struct wayland_output *output;
+    HWND hwnd = user_data;
+
+    if ((data = wayland_win_data_get(hwnd)))
+    {
+        if (data->wayland_surface)
+        {
+            pthread_mutex_lock(&process_wayland.output_mutex);
+            wl_list_for_each(output, &process_wayland.output_list, link)
+            {
+                if (output->wl_output == wl_output)
+                {
+                    TRACE("Clearing output %p for surface %p\n", wl_output, data->wayland_surface);
+                    data->wayland_surface->wl_output = NULL;
+                    break;
+                }
+            }
+            pthread_mutex_unlock(&process_wayland.output_mutex);
+        }
+
+        wayland_win_data_release(data);
+    }
+}
+
+static const struct wl_surface_listener wl_surface_listener =
+{
+    wl_surface_handle_enter,
+    wl_surface_handle_leave
+};
+
 /**********************************************************************
  *          wayland_surface_create
  *
@@ -191,6 +251,7 @@ struct wayland_surface *wayland_surface_create(HWND hwnd)
         ERR("Failed to create wl_surface Wayland surface\n");
         goto err;
     }
+    wl_surface_add_listener(surface->wl_surface, &wl_surface_listener, hwnd);
     wl_surface_set_user_data(surface->wl_surface, hwnd);
 
     surface->wp_viewport =
@@ -550,6 +611,42 @@ static void wayland_surface_get_rect_in_monitor(struct wayland_surface *surface,
     OffsetRect(rect, -surface->window.rect.left, -surface->window.rect.top);
 }
 
+struct wl_output *wayland_surface_get_best_output(struct wayland_surface *surface)
+{
+    struct wayland_output *output;
+    struct wl_output *best = NULL;
+    RECT output_rect, temp, intersect = {0};
+    const RECT *window_rect = &surface->window.rect;
+
+    wl_list_for_each(output, &process_wayland.output_list, link)
+    {
+        SetRect(&output_rect, 0, 0,
+                output->current.current_mode->width,
+                output->current.current_mode->height);
+        OffsetRect(&output_rect,
+                output->current.resolved_x,
+                output->current.resolved_y);
+
+        TRACE("output %s: %s, window %s\n",
+              output->current.name,
+              wine_dbgstr_rect(&output_rect),
+              wine_dbgstr_rect(window_rect));
+
+        if (intersect_rect(&temp, window_rect, &output_rect) &&
+                area_rect(&temp) > area_rect(&intersect))
+        {
+            intersect = temp;
+            best = output->wl_output;
+        }
+    }
+
+    if (!best)
+        WARN("Could not find associated wl_output for rect %s!\n",
+             wine_dbgstr_rect(window_rect));
+
+    return best;
+}
+
 /**********************************************************************
  *          wayland_surface_reconfigure_geometry
  *
@@ -601,6 +698,23 @@ static void wayland_surface_reconfigure_geometry(struct wayland_surface *surface
                                         rect.left, rect.top,
                                         rect.right - rect.left,
                                         rect.bottom - rect.top);
+        /* HACK: reset fullscreen state to ensure surface is on correct output */
+        if (surface->current.state & WAYLAND_SURFACE_CONFIG_STATE_FULLSCREEN
+            && wayland_surface_is_toplevel(surface))
+        {
+            struct wl_output *output;
+            pthread_mutex_lock(&process_wayland.output_mutex);
+            output = wayland_surface_get_best_output(surface);
+            if (output != surface->wl_output)
+            {
+                TRACE("Resetting fullscreen state: output %p surface output %p\n",
+                      output, surface->wl_output);
+                xdg_toplevel_unset_fullscreen(surface->xdg_toplevel);
+                wl_display_flush(process_wayland.wl_display);
+                xdg_toplevel_set_fullscreen(surface->xdg_toplevel, output);
+            }
+            pthread_mutex_unlock(&process_wayland.output_mutex);
+        }
     }
 }
 
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 52a4f1b160c..4537c934077 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -273,6 +273,7 @@ struct wayland_surface
     HWND hwnd;
 
     struct wl_surface *wl_surface;
+    struct wl_output *wl_output;
     struct wp_viewport *wp_viewport;
     struct wp_fractional_scale_v1 *wp_fractional_scale_v1;
 
@@ -345,6 +346,7 @@ void wayland_client_surface_detach(struct wayland_client_surface *client);
 void wayland_surface_ensure_contents(struct wayland_surface *surface);
 void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR title);
 void wayland_surface_set_icon(struct wayland_surface *surface, UINT type, ICONINFO *ii);
+struct wl_output *wayland_surface_get_best_output(struct wayland_surface *surface);
 
 static inline BOOL wayland_surface_is_toplevel(struct wayland_surface *surface)
 {
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 70b3c2080c0..99769dce0b5 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -239,42 +239,6 @@ static BOOL wayland_win_data_create_wayland_surface(struct wayland_win_data *dat
     return TRUE;
 }
 
-static struct wl_output *wayland_surface_get_best_output(struct wayland_surface *surface)
-{
-    struct wayland_output *output;
-    struct wl_output *best = NULL;
-    RECT output_rect, temp, intersect = {0};
-    const RECT *window_rect = &surface->window.rect;
-
-    wl_list_for_each(output, &process_wayland.output_list, link)
-    {
-        SetRect(&output_rect, 0, 0,
-                output->current.current_mode->width,
-                output->current.current_mode->height);
-        OffsetRect(&output_rect,
-                output->current.resolved_x,
-                output->current.resolved_y);
-
-        TRACE("output %s, %s window %s\n",
-              output->current.name,
-              wine_dbgstr_rect(&output_rect),
-              wine_dbgstr_rect(window_rect));
-
-        if (intersect_rect(&temp, window_rect, &output_rect) &&
-                area_rect(&temp) > area_rect(&intersect))
-        {
-            intersect = temp;
-            best = output->wl_output;
-        }
-    }
-
-    if (!best)
-        WARN("Could not find associated wl_output for rect %s!\n",
-             wine_dbgstr_rect(window_rect));
-
-    return best;
-}
-
 static void wayland_surface_update_state_toplevel(struct wayland_surface *surface)
 {
     BOOL processing_config = surface->processing.serial &&
-- 
2.49.0

From ea85dad7c4b6d707c1f5f22b2a41111d78144b8a Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sat, 24 May 2025 11:09:03 -0400
Subject: [PATCH 062/159] WIP: winewayland: emulate some edid data.

---
 dlls/winewayland.drv/display.c | 57 ++++++++++++++++++++++++++++++++++
 1 file changed, 57 insertions(+)

diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index c5d599efb54..d85d56f06c2 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -212,6 +212,62 @@ static void wayland_add_device_source(const struct gdi_device_manager *device_ma
     device_manager->add_source(output_info->output->name, state_flags, dpi, param);
 }
 
+/* emulate some edid data */
+static UINT get_edid(const struct output_info *output_info, unsigned char **data_out)
+{
+    unsigned char *data, *p;
+    unsigned int i, mwidth, mheight;
+    unsigned char c;
+    struct wayland_output_mode *mode = output_info->output->current_mode;
+
+    /* assume ~150 dpi */
+    mwidth = mode->width / 60;
+    mheight = mode->height / 60;
+
+    *data_out = calloc( 1, 128 );
+    data = *data_out;
+
+    if (!data) return 0;
+
+    *(uint64_t*)data = 0x00ffffffffffff00;
+    data[18] = 1;
+    data[19] = 4;
+    data[20] = 0xa0; /* FIXME */
+    data[21] = mwidth;
+    data[22] = mheight;
+    data[24] = 0x6;
+
+    p = data + 54;
+
+    *(uint16_t*)&p[0] = 0x0; /* reserved */
+
+    /* assume blanking time is 0 */
+    p[2] = mode->width;
+    p[4] = (((mode->width >> 8) & 0xf) << 4);
+    p[5] = mode->height;
+    p[7] = (((mode->height >> 8) & 0xf) << 4);
+    p[12] = mwidth;
+    p[13] = mheight;
+    p[14] = (((mwidth >> 8) & 0xf) << 4) | ((mheight >> 8) & 0xf);
+
+    p += 18;
+    p[3] = 0xfc;
+    memcpy((char *)p + 5, output_info->output->name,
+             min(strlen(output_info->output->name), 12));
+
+    p += 18;
+    p[3] = 0x10;
+    p += 18;
+    p[3] = 0x10;
+
+    c = 0;
+    for (i = 0; i < 127; ++i)
+        c += data[i];
+    data[127] = 256 - c;
+
+    return 128;
+}
+
 static void wayland_add_device_monitor(const struct gdi_device_manager *device_manager,
                                        void *param, struct output_info *output_info)
 {
@@ -223,6 +279,7 @@ static void wayland_add_device_monitor(const struct gdi_device_manager *device_m
 
     /* We don't have a direct way to get the work area in Wayland. */
     monitor.rc_work = monitor.rc_monitor;
+    monitor.edid_len = get_edid(output_info, &monitor.edid);
 
     TRACE("name=%s rc_monitor=rc_work=%s\n",
           output_info->output->name, wine_dbgstr_rect(&monitor.rc_monitor));
-- 
2.49.0

From 5efd78065b0c99c592902439121d5e5cba046208 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sat, 24 May 2025 13:26:50 -0400
Subject: [PATCH 063/159] winedmo: Fix double free

---
 dlls/winedmo/unix_demuxer.c           | 4 ++--
 dlls/winedmo/unix_demuxer_mediaconv.c | 3 +++
 2 files changed, 5 insertions(+), 2 deletions(-)

diff --git a/dlls/winedmo/unix_demuxer.c b/dlls/winedmo/unix_demuxer.c
index 24681e2d5df..cceda4d7112 100644
--- a/dlls/winedmo/unix_demuxer.c
+++ b/dlls/winedmo/unix_demuxer.c
@@ -248,10 +248,10 @@ NTSTATUS demuxer_create( void *arg )
     if (!(demuxer->ctx->pb = avio_alloc_context( NULL, 0, 0, params->context, unix_read_callback, NULL, unix_seek_callback ))) goto failed;
 
     if ((ret = avformat_open_input( &demuxer->ctx, NULL, NULL, NULL )) < 0)
-        WARN( "Failed to open input, error %s.\n", debugstr_averr(ret) );
+        ERR( "Failed to open input using avformat, error %s.\n", debugstr_averr(ret) );
     if ((ret = mediaconv_demuxer_open( &demuxer->ctx, params->context ) < 0))
     {
-        ERR( "Failed to open input, error %s.\n", debugstr_averr(ret) );
+        ERR( "Failed to open input using mediaconv, error %s.\n", debugstr_averr(ret) );
         goto failed;
     }
     format = demuxer->ctx->iformat;
diff --git a/dlls/winedmo/unix_demuxer_mediaconv.c b/dlls/winedmo/unix_demuxer_mediaconv.c
index 478df6f2a34..90a629402c4 100644
--- a/dlls/winedmo/unix_demuxer_mediaconv.c
+++ b/dlls/winedmo/unix_demuxer_mediaconv.c
@@ -209,6 +209,7 @@ int mediaconv_demuxer_open( AVFormatContext **ctx, struct stream_context *contex
         WARN( "Failed to find decoder for stream %u, codec %#x %s\n", i, par->codec_id, avcodec_get_name(par->codec_id) );
         avio_context_free( &(*ctx)->pb );
         avformat_free_context( *ctx );
+        *ctx = NULL;
     }
 
     if (!(buffer = calloc( 1, HASH_CHUNK_SIZE ))) return AVERROR(ENOMEM);
@@ -258,6 +259,7 @@ int mediaconv_demuxer_open( AVFormatContext **ctx, struct stream_context *contex
                                                NULL, mediaconv_demuxer_seek_callback )))
         {
             avformat_free_context( *ctx );
+            *ctx = NULL;
             return AVERROR(ENOMEM);
         }
     }
@@ -273,6 +275,7 @@ int mediaconv_demuxer_open( AVFormatContext **ctx, struct stream_context *contex
         if ((ret = avio_open( &(*ctx)->pb, blank_path, AVIO_FLAG_READ )) < 0)
         {
             avformat_free_context( *ctx );
+            *ctx = NULL;
             return ret;
         }
     }
-- 
2.49.0

From 44b906e66f24245be8e97254c2724d10b38a62f8 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sun, 25 May 2025 20:00:10 -0400
Subject: [PATCH 064/159] winewayland: Set edid chromaticity values

---
 dlls/winewayland.drv/Makefile.in             |    1 +
 dlls/winewayland.drv/color-management-v1.xml | 1631 ++++++++++++++++++
 dlls/winewayland.drv/display.c               |   15 +-
 dlls/winewayland.drv/wayland.c               |    5 +
 dlls/winewayland.drv/wayland_output.c        |  188 ++
 dlls/winewayland.drv/waylanddrv.h            |   20 +
 6 files changed, 1859 insertions(+), 1 deletion(-)
 create mode 100644 dlls/winewayland.drv/color-management-v1.xml

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 92db5349568..fba6b916cee 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -5,6 +5,7 @@ UNIX_LIBS = -lwin32u $(WAYLAND_CLIENT_LIBS) $(WAYLAND_EGL_LIBS) $(XKBCOMMON_LIBS
 IMPORTS = user32 win32u
 
 SOURCES = \
+	color-management-v1.xml \
 	cursor-shape-v1.xml \
 	display.c \
 	dllmain.c \
diff --git a/dlls/winewayland.drv/color-management-v1.xml b/dlls/winewayland.drv/color-management-v1.xml
new file mode 100644
index 00000000000..ee482c5af1a
--- /dev/null
+++ b/dlls/winewayland.drv/color-management-v1.xml
@@ -0,0 +1,1631 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="color_management_v1">
+  <copyright>
+    Copyright 2019 Sebastian Wick
+    Copyright 2019 Erwin Burema
+    Copyright 2020 AMD
+    Copyright 2020-2024 Collabora, Ltd.
+    Copyright 2024 Xaver Hugl
+    Copyright 2022-2025 Red Hat, Inc.
+
+    Permission is hereby granted, free of charge, to any person obtaining a
+    copy of this software and associated documentation files (the "Software"),
+    to deal in the Software without restriction, including without limitation
+    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+    and/or sell copies of the Software, and to permit persons to whom the
+    Software is furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice (including the next
+    paragraph) shall be included in all copies or substantial portions of the
+    Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+    DEALINGS IN THE SOFTWARE.
+  </copyright>
+
+  <description summary="color management protocol">
+    The aim of the color management extension is to allow clients to know
+    the color properties of outputs, and to tell the compositor about the color
+    properties of their content on surfaces. Doing this enables a compositor
+    to perform automatic color management of content for different outputs
+    according to how content is intended to look like.
+
+    The color properties are represented as an image description object which
+    is immutable after it has been created. A wl_output always has an
+    associated image description that clients can observe. A wl_surface
+    always has an associated preferred image description as a hint chosen by
+    the compositor that clients can also observe. Clients can set an image
+    description on a wl_surface to denote the color characteristics of the
+    surface contents.
+
+    An image description includes SDR and HDR colorimetry and encoding, HDR
+    metadata, and viewing environment parameters. An image description does
+    not include the properties set through color-representation extension.
+    It is expected that the color-representation extension is used in
+    conjunction with the color management extension when necessary,
+    particularly with the YUV family of pixel formats.
+
+    Recommendation ITU-T H.273
+    "Coding-independent code points for video signal type identification"
+    shall be referred to as simply H.273 here.
+
+    The color-and-hdr repository
+    (https://gitlab.freedesktop.org/pq/color-and-hdr) contains
+    background information on the protocol design and legacy color management.
+    It also contains a glossary, learning resources for digital color, tools,
+    samples and more.
+
+    The terminology used in this protocol is based on common color science and
+    color encoding terminology where possible. The glossary in the color-and-hdr
+    repository shall be the authority on the definition of terms in this
+    protocol.
+
+    Warning! The protocol described in this file is currently in the testing
+    phase. Backward compatible changes may be added together with the
+    corresponding interface version bump. Backward incompatible changes can
+    only be done by creating a new major version of the extension.
+  </description>
+
+  <interface name="wp_color_manager_v1" version="1">
+    <description summary="color manager singleton">
+      A singleton global interface used for getting color management extensions
+      for wl_surface and wl_output objects, and for creating client defined
+      image description objects. The extension interfaces allow
+      getting the image description of outputs and setting the image
+      description of surfaces.
+
+      Compositors should never remove this global.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the color manager">
+        Destroy the wp_color_manager_v1 object. This does not affect any other
+        objects in any way.
+      </description>
+    </request>
+
+    <enum name="error">
+      <entry name="unsupported_feature" value="0"
+             summary="request not supported"/>
+      <entry name="surface_exists" value="1"
+             summary="color management surface exists already"/>
+    </enum>
+
+    <enum name="render_intent">
+      <description summary="rendering intents">
+        See the ICC.1:2022 specification from the International Color Consortium
+        for more details about rendering intents.
+
+        The principles of ICC defined rendering intents apply with all types of
+        image descriptions, not only those with ICC file profiles.
+
+        Compositors must support the perceptual rendering intent. Other
+        rendering intents are optional.
+      </description>
+
+      <entry name="perceptual" value="0"
+             summary="perceptual"/>
+      <entry name="relative" value="1"
+             summary="media-relative colorimetric"/>
+      <entry name="saturation" value="2"
+             summary="saturation"/>
+      <entry name="absolute" value="3"
+             summary="ICC-absolute colorimetric"/>
+      <entry name="relative_bpc" value="4"
+             summary="media-relative colorimetric + black point compensation"/>
+    </enum>
+
+    <enum name="feature">
+      <description summary="compositor supported features"/>
+
+      <entry name="icc_v2_v4" value="0"
+             summary="create_icc_creator request"/>
+      <entry name="parametric" value="1"
+             summary="create_parametric_creator request"/>
+      <entry name="set_primaries" value="2"
+             summary="parametric set_primaries request"/>
+      <entry name="set_tf_power" value="3"
+             summary="parametric set_tf_power request"/>
+      <entry name="set_luminances" value="4"
+             summary="parametric set_luminances request"/>
+      <entry name="set_mastering_display_primaries" value="5">
+        <description summary="parametric set_mastering_display_primaries request">
+          The compositor supports set_mastering_display_primaries request with a
+          target color volume fully contained inside the primary color volume.
+        </description>
+      </entry>
+      <entry name="extended_target_volume" value="6">
+        <description summary="parametric target exceeds primary color volume">
+          The compositor additionally supports target color volumes that
+          extend outside of the primary color volume.
+
+          This can only be advertised if feature set_mastering_display_primaries
+          is supported as well.
+        </description>
+      </entry>
+      <entry name="windows_scrgb" value="7"
+             summary="create_windows_scrgb request"/>
+    </enum>
+
+    <enum name="primaries">
+      <description summary="named color primaries">
+        Named color primaries used to encode well-known sets of primaries. H.273
+        is the authority, when it comes to the exact values of primaries and
+        authoritative specifications, where an equivalent code point exists.
+
+        A value of 0 is invalid and will never be present in the list of enums.
+
+        Descriptions do list the specifications for convenience.
+      </description>
+
+      <entry name="srgb" value="1">
+        <description summary="Color primaries for the sRGB color space as defined by the BT.709 standard">
+          Color primaries as defined by
+          - Rec. ITU-R BT.709-6
+          - Rec. ITU-R BT.1361-0 conventional colour gamut system and extended
+            colour gamut system (historical)
+          - IEC 61966-2-1 sRGB or sYCC
+          - IEC 61966-2-4
+          - Society of Motion Picture and Television Engineers (SMPTE) RP 177
+            (1993) Annex B
+          Equivalent to H.273 ColourPrimaries code point 1.
+        </description>
+      </entry>
+      <entry name="pal_m" value="2">
+        <description summary="Color primaries for PAL-M as defined by the BT.470 standard">
+          Color primaries as defined by
+          - Rec. ITU-R BT.470-6 System M (historical)
+          - United States National Television System Committee 1953
+            Recommendation for transmission standards for color television
+          - United States Federal Communications Commission (2003) Title 47 Code
+            of Federal Regulations 73.682 (a)(20)
+          Equivalent to H.273 ColourPrimaries code point 4.
+        </description>
+      </entry>
+      <entry name="pal" value="3">
+        <description summary="Color primaries for PAL as defined by the BT.601 standard">
+          Color primaries as defined by
+          - Rec. ITU-R BT.470-6 System B, G (historical)
+          - Rec. ITU-R BT.601-7 625
+          - Rec. ITU-R BT.1358-0 625 (historical)
+          - Rec. ITU-R BT.1700-0 625 PAL and 625 SECAM
+          Equivalent to H.273 ColourPrimaries code point 5.
+        </description>
+      </entry>
+      <entry name="ntsc" value="4">
+        <description summary="Color primaries for NTSC as defined by the BT.601 standard">
+          Color primaries as defined by
+          - Rec. ITU-R BT.601-7 525
+          - Rec. ITU-R BT.1358-1 525 or 625 (historical)
+          - Rec. ITU-R BT.1700-0 NTSC
+          - SMPTE 170M (2004)
+          - SMPTE 240M (1999) (historical)
+          Equivalent to H.273 ColourPrimaries code point 6 and 7.
+        </description>
+      </entry>
+      <entry name="generic_film" value="5">
+        <description summary="Generic film with colour filters using Illuminant C">
+          Color primaries as defined by H.273 for generic film.
+          Equivalent to H.273 ColourPrimaries code point 8.
+        </description>
+      </entry>
+      <entry name="bt2020" value="6">
+        <description summary="Color primaries as defined by the BT.2020 and BT.2100 standard">
+          Color primaries as defined by
+          - Rec. ITU-R BT.2020-2
+          - Rec. ITU-R BT.2100-0
+          Equivalent to H.273 ColourPrimaries code point 9.
+        </description>
+      </entry>
+      <entry name="cie1931_xyz" value="7">
+        <description summary="Color primaries of the full CIE 1931 XYZ color space">
+          Color primaries as defined as the maximum of the CIE 1931 XYZ color
+          space by
+          - SMPTE ST 428-1
+          - (CIE 1931 XYZ as in ISO 11664-1)
+          Equivalent to H.273 ColourPrimaries code point 10.
+        </description>
+      </entry>
+      <entry name="dci_p3" value="8">
+        <description summary="Color primaries of the DCI P3 color space as defined by the SMPTE RP 431 standard">
+          Color primaries as defined by Digital Cinema System and published in
+          SMPTE RP 431-2 (2011). Equivalent to H.273 ColourPrimaries code point
+          11.
+        </description>
+      </entry>
+      <entry name="display_p3" value="9">
+        <description summary="Color primaries of Display P3 variant of the DCI-P3 color space as defined by the SMPTE EG 432 standard">
+          Color primaries as defined by Digital Cinema System and published in
+          SMPTE EG 432-1 (2010).
+          Equivalent to H.273 ColourPrimaries code point 12.
+        </description>
+      </entry>
+      <entry name="adobe_rgb" value="10">
+        <description summary="Color primaries of the Adobe RGB color space as defined by the ISO 12640 standard">
+          Color primaries as defined by Adobe as "Adobe RGB" and later published
+          by ISO 12640-4 (2011).
+        </description>
+      </entry>
+    </enum>
+
+    <enum name="transfer_function">
+      <description summary="named transfer functions">
+        Named transfer functions used to represent well-known transfer
+        characteristics. H.273 is the authority, when it comes to the exact
+        formulas and authoritative specifications, where an equivalent code
+        point exists.
+
+        A value of 0 is invalid and will never be present in the list of enums.
+
+        Descriptions do list the specifications for convenience.
+      </description>
+
+      <entry name="bt1886" value="1">
+        <description summary="BT.1886 display transfer characteristic">
+          Rec. ITU-R BT.1886 is the display transfer characteristic assumed by
+          - Rec. ITU-R BT.601-7 525 and 625
+          - Rec. ITU-R BT.709-6
+          - Rec. ITU-R BT.2020-2
+          These recommendations are referred to by H.273 TransferCharacteristics
+          code points 1, 6, 14, and 15, which are all equivalent.
+
+          This TF implies these default luminances from Rec. ITU-R BT.2035:
+          - primary color volume minimum: 0.01 cd/m²
+          - primary color volume maximum: 100 cd/m²
+          - reference white: 100 cd/m²
+        </description>
+      </entry>
+      <entry name="gamma22" value="2">
+        <description summary="Assumed display gamma 2.2 transfer function">
+          Transfer characteristics as defined by
+          - Rec. ITU-R BT.470-6 System M (historical)
+          - United States National Television System Committee 1953
+            Recommendation for transmission standards for color television
+          - United States Federal Communications Commission (2003) Title 47 Code
+            of Federal Regulations 73.682 (a) (20)
+          - Rec. ITU-R BT.1700-0 625 PAL and 625 SECAM
+          Equivalent to H.273 TransferCharacteristics code point 4.
+        </description>
+      </entry>
+      <entry name="gamma28" value="3">
+        <description summary="Assumed display gamma 2.8 transfer function">
+          Transfer characteristics as defined by
+          - Rec. ITU-R BT.470-6 System B, G (historical)
+          Equivalent to H.273 TransferCharacteristics code point 5.
+        </description>
+      </entry>
+      <entry name="st240" value="4">
+        <description summary="SMPTE ST 240 transfer function">
+          Transfer characteristics as defined by
+          - SMPTE ST 240 (1999)
+          Equivalent to H.273 TransferCharacteristics code point 7.
+        </description>
+      </entry>
+      <entry name="ext_linear" value="5">
+        <description summary="extended linear transfer function">
+          Linear transfer function defined over all real numbers.
+          Normalised electrical values are equal the normalised optical values.
+
+          The differences to H.273 TransferCharacteristics code point 8 are
+          the definition over all real numbers.
+        </description>
+      </entry>
+      <entry name="log_100" value="6">
+        <description summary="logarithmic 100:1 transfer function">
+          Logarithmic transfer characteristic (100:1 range).
+          Equivalent to H.273 TransferCharacteristics code point 9.
+        </description>
+      </entry>
+      <entry name="log_316" value="7">
+        <description summary="logarithmic (100*Sqrt(10) : 1) transfer function">
+          Logarithmic transfer characteristic (100 * Sqrt(10) : 1 range).
+          Equivalent to H.273 TransferCharacteristics code point 10.
+        </description>
+      </entry>
+      <entry name="xvycc" value="8">
+        <description summary="IEC 61966-2-4 transfer function">
+          Transfer characteristics as defined by
+          - IEC 61966-2-4
+          Equivalent to H.273 TransferCharacteristics code point 11.
+        </description>
+      </entry>
+      <entry name="srgb" value="9">
+        <description summary="sRGB piece-wise transfer function">
+          Transfer characteristics as defined by
+          - IEC 61966-2-1 sRGB
+          Equivalent to H.273 TransferCharacteristics code point 13 with
+          MatrixCoefficients set to 0.
+        </description>
+      </entry>
+      <entry name="ext_srgb" value="10">
+        <description summary="Extended sRGB piece-wise transfer function">
+          Transfer characteristics as defined by
+          - IEC 61966-2-1 sYCC
+          Equivalent to H.273 TransferCharacteristics code point 13 with
+          MatrixCoefficients set to anything but 0.
+        </description>
+      </entry>
+      <entry name="st2084_pq" value="11">
+        <description summary="perceptual quantizer transfer function">
+          Transfer characteristics as defined by
+          - SMPTE ST 2084 (2014) for 10-, 12-, 14- and 16-bit systems
+          - Rec. ITU-R BT.2100-2 perceptual quantization (PQ) system
+          Equivalent to H.273 TransferCharacteristics code point 16.
+
+          This TF implies these default luminances
+          - primary color volume minimum: 0.005 cd/m²
+          - primary color volume maximum: 10000 cd/m²
+          - reference white: 203 cd/m²
+
+          The difference between the primary color volume minimum and maximum
+          must be approximately 10000 cd/m² as that is the swing of the EOTF
+          defined by ST 2084 and BT.2100. The default value for the
+          reference white is a protocol addition: it is suggested by
+          Report ITU-R BT.2408-7 and is not part of ST 2084 or BT.2100.
+        </description>
+      </entry>
+      <entry name="st428" value="12">
+        <description summary="SMPTE ST 428 transfer function">
+          Transfer characteristics as defined by
+          - SMPTE ST 428-1 (2019)
+          Equivalent to H.273 TransferCharacteristics code point 17.
+        </description>
+      </entry>
+      <entry name="hlg" value="13">
+        <description summary="hybrid log-gamma transfer function">
+          Transfer characteristics as defined by
+          - ARIB STD-B67 (2015)
+          - Rec. ITU-R BT.2100-2 hybrid log-gamma (HLG) system
+          Equivalent to H.273 TransferCharacteristics code point 18.
+
+          This TF implies these default luminances
+          - primary color volume minimum: 0.005 cd/m²
+          - primary color volume maximum: 1000 cd/m²
+          - reference white: 203 cd/m²
+
+          HLG is a relative display-referred signal with a specified
+          non-linear mapping to the display peak luminance (the HLG OOTF).
+          All absolute luminance values used here for HLG assume a 1000 cd/m²
+          peak display.
+
+          The default value for the reference white is a protocol addition:
+          it is suggested by Report ITU-R BT.2408-7 and is not part of
+          ARIB STD-B67 or BT.2100.
+        </description>
+      </entry>
+    </enum>
+
+    <request name="get_output">
+      <description summary="create a color management interface for a wl_output">
+        This creates a new wp_color_management_output_v1 object for the
+        given wl_output.
+
+        See the wp_color_management_output_v1 interface for more details.
+      </description>
+
+      <arg name="id" type="new_id" interface="wp_color_management_output_v1"/>
+      <arg name="output" type="object" interface="wl_output"/>
+    </request>
+
+    <request name="get_surface">
+      <description summary="create a color management interface for a wl_surface">
+        If a wp_color_management_surface_v1 object already exists for the given
+        wl_surface, the protocol error surface_exists is raised.
+
+        This creates a new color wp_color_management_surface_v1 object for the
+        given wl_surface.
+
+        See the wp_color_management_surface_v1 interface for more details.
+      </description>
+
+      <arg name="id" type="new_id" interface="wp_color_management_surface_v1"/>
+      <arg name="surface" type="object" interface="wl_surface"/>
+    </request>
+
+    <request name="get_surface_feedback">
+      <description summary="create a color management feedback interface">
+        This creates a new color wp_color_management_surface_feedback_v1 object
+        for the given wl_surface.
+
+        See the wp_color_management_surface_feedback_v1 interface for more
+        details.
+      </description>
+
+      <arg name="id" type="new_id"
+           interface="wp_color_management_surface_feedback_v1"/>
+      <arg name="surface" type="object" interface="wl_surface"/>
+    </request>
+
+    <request name="create_icc_creator">
+      <description summary="make a new ICC-based image description creator object">
+        Makes a new ICC-based image description creator object with all
+        properties initially unset. The client can then use the object's
+        interface to define all the required properties for an image description
+        and finally create a wp_image_description_v1 object.
+
+        This request can be used when the compositor advertises
+        wp_color_manager_v1.feature.icc_v2_v4.
+        Otherwise this request raises the protocol error unsupported_feature.
+      </description>
+
+      <arg name="obj"
+           type="new_id" interface="wp_image_description_creator_icc_v1"
+           summary="the new creator object"/>
+    </request>
+
+    <request name="create_parametric_creator">
+      <description summary="make a new parametric image description creator object">
+        Makes a new parametric image description creator object with all
+        properties initially unset. The client can then use the object's
+        interface to define all the required properties for an image description
+        and finally create a wp_image_description_v1 object.
+
+        This request can be used when the compositor advertises
+        wp_color_manager_v1.feature.parametric.
+        Otherwise this request raises the protocol error unsupported_feature.
+      </description>
+
+      <arg name="obj"
+           type="new_id" interface="wp_image_description_creator_params_v1"
+           summary="the new creator object"/>
+    </request>
+
+    <request name="create_windows_scrgb">
+      <description summary="create Windows-scRGB image description object">
+        This creates a pre-defined image description for the so-called
+        Windows-scRGB stimulus encoding. This comes from the Windows 10 handling
+        of its own definition of an scRGB color space for an HDR screen
+        driven in BT.2100/PQ signalling mode.
+
+        Windows-scRGB uses sRGB (BT.709) color primaries and white point.
+        The transfer characteristic is extended linear.
+
+        The nominal color channel value range is extended, meaning it includes
+        negative and greater than 1.0 values. Negative values are used to
+        escape the sRGB color gamut boundaries. To make use of the extended
+        range, the client needs to use a pixel format that can represent those
+        values, e.g. floating-point 16 bits per channel.
+
+        Nominal color value R=G=B=0.0 corresponds to BT.2100/PQ system
+        0 cd/m², and R=G=B=1.0 corresponds to BT.2100/PQ system 80 cd/m².
+        The maximum is R=G=B=125.0 corresponding to 10k cd/m².
+
+        Windows-scRGB is displayed by Windows 10 by converting it to
+        BT.2100/PQ, maintaining the CIE 1931 chromaticity and mapping the
+        luminance as above. No adjustment is made to the signal to account
+        for the viewing conditions.
+
+        The reference white level of Windows-scRGB is unknown. If a
+        reference white level must be assumed for compositor processing, it
+        should be R=G=B=2.5375 corresponding to 203 cd/m² of Report ITU-R
+        BT.2408-7.
+
+        The target color volume of Windows-scRGB is unknown. The color gamut
+        may be anything between sRGB and BT.2100.
+
+        Note: EGL_EXT_gl_colorspace_scrgb_linear definition differs from
+        Windows-scRGB by using R=G=B=1.0 as the reference white level, while
+        Windows-scRGB reference white level is unknown or varies. However,
+        it seems probable that Windows implements both
+        EGL_EXT_gl_colorspace_scrgb_linear and Vulkan
+        VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT as Windows-scRGB.
+
+        This request can be used when the compositor advertises
+        wp_color_manager_v1.feature.windows_scrgb.
+        Otherwise this request raises the protocol error unsupported_feature.
+
+        The resulting image description object does not allow get_information
+        request. The wp_image_description_v1.ready event shall be sent.
+      </description>
+
+      <arg name="image_description"
+           type="new_id" interface="wp_image_description_v1"/>
+    </request>
+
+    <event name="supported_intent">
+      <description summary="supported rendering intent">
+        When this object is created, it shall immediately send this event once
+        for each rendering intent the compositor supports.
+      </description>
+
+      <arg name="render_intent" type="uint" enum="render_intent"
+           summary="rendering intent"/>
+    </event>
+
+    <event name="supported_feature">
+      <description summary="supported features">
+        When this object is created, it shall immediately send this event once
+        for each compositor supported feature listed in the enumeration.
+      </description>
+
+      <arg name="feature" type="uint" enum="feature"
+           summary="supported feature"/>
+    </event>
+
+    <event name="supported_tf_named">
+      <description summary="supported named transfer characteristic">
+        When this object is created, it shall immediately send this event once
+        for each named transfer function the compositor supports with the
+        parametric image description creator.
+      </description>
+
+      <arg name="tf" type="uint" enum="transfer_function"
+           summary="Named transfer function"/>
+    </event>
+
+    <event name="supported_primaries_named">
+      <description summary="supported named primaries">
+        When this object is created, it shall immediately send this event once
+        for each named set of primaries the compositor supports with the
+        parametric image description creator.
+      </description>
+
+      <arg name="primaries" type="uint" enum="primaries"
+           summary="Named color primaries"/>
+    </event>
+
+    <event name="done">
+      <description summary="all features have been sent">
+        This event is sent when all supported rendering intents, features,
+        transfer functions and named primaries have been sent.
+      </description>
+    </event>
+  </interface>
+
+  <interface name="wp_color_management_output_v1" version="1">
+    <description summary="output color properties">
+      A wp_color_management_output_v1 describes the color properties of an
+      output.
+
+      The wp_color_management_output_v1 is associated with the wl_output global
+      underlying the wl_output object. Therefore the client destroying the
+      wl_output object has no impact, but the compositor removing the output
+      global makes the wp_color_management_output_v1 object inert.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the color management output">
+        Destroy the color wp_color_management_output_v1 object. This does not
+        affect any remaining protocol objects.
+      </description>
+    </request>
+
+    <event name="image_description_changed">
+      <description summary="image description changed">
+        This event is sent whenever the image description of the output changed,
+        followed by one wl_output.done event common to output events across all
+        extensions.
+
+        If the client wants to use the updated image description, it needs to do
+        get_image_description again, because image description objects are
+        immutable.
+      </description>
+    </event>
+
+    <request name="get_image_description">
+      <description summary="get the image description of the output">
+        This creates a new wp_image_description_v1 object for the current image
+        description of the output. There always is exactly one image description
+        active for an output so the client should destroy the image description
+        created by earlier invocations of this request. This request is usually
+        sent as a reaction to the image_description_changed event or when
+        creating a wp_color_management_output_v1 object.
+
+        The image description of an output represents the color encoding the
+        output expects. There might be performance and power advantages, as well
+        as improved color reproduction, if a content update matches the image
+        description of the output it is being shown on. If a content update is
+        shown on any other output than the one it matches the image description
+        of, then the color reproduction on those outputs might be considerably
+        worse.
+
+        The created wp_image_description_v1 object preserves the image
+        description of the output from the time the object was created.
+
+        The resulting image description object allows get_information request.
+
+        If this protocol object is inert, the resulting image description object
+        shall immediately deliver the wp_image_description_v1.failed event with
+        the no_output cause.
+
+        If the interface version is inadequate for the output's image
+        description, meaning that the client does not support all the events
+        needed to deliver the crucial information, the resulting image
+        description object shall immediately deliver the
+        wp_image_description_v1.failed event with the low_version cause.
+
+        Otherwise the object shall immediately deliver the ready event.
+      </description>
+
+      <arg name="image_description"
+           type="new_id" interface="wp_image_description_v1"/>
+    </request>
+  </interface>
+
+  <interface name="wp_color_management_surface_v1" version="1">
+    <description summary="color management extension to a surface">
+        A wp_color_management_surface_v1 allows the client to set the color
+        space and HDR properties of a surface.
+
+        If the wl_surface associated with the wp_color_management_surface_v1 is
+        destroyed, the wp_color_management_surface_v1 object becomes inert.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the color management interface for a surface">
+        Destroy the wp_color_management_surface_v1 object and do the same as
+        unset_image_description.
+      </description>
+    </request>
+
+    <enum name="error">
+      <description summary="protocol errors"/>
+      <entry name="render_intent" value="0"
+             summary="unsupported rendering intent"/>
+      <entry name="image_description" value="1"
+             summary="invalid image description"/>
+      <entry name="inert" value="2"
+             summary="forbidden request on inert object"/>
+    </enum>
+
+    <request name="set_image_description">
+      <description summary="set the surface image description">
+        If this protocol object is inert, the protocol error inert is raised.
+
+        Set the image description of the underlying surface. The image
+        description and rendering intent are double-buffered state, see
+        wl_surface.commit.
+
+        It is the client's responsibility to understand the image description
+        it sets on a surface, and to provide content that matches that image
+        description. Compositors might convert images to match their own or any
+        other image descriptions.
+
+        Image descriptions which are not ready (see wp_image_description_v1)
+        are forbidden in this request, and in such case the protocol error
+        image_description is raised.
+
+        All image descriptions which are ready (see wp_image_description_v1)
+        are allowed and must always be accepted by the compositor.
+
+        A rendering intent provides the client's preference on how content
+        colors should be mapped to each output. The render_intent value must
+        be one advertised by the compositor with
+        wp_color_manager_v1.render_intent event, otherwise the protocol error
+        render_intent is raised.
+
+        When an image description is set on a surface, the Transfer
+        Characteristics of the image description defines the valid range of
+        the nominal (real-valued) color channel values. The processing of
+        out-of-range color channel values is undefined, but compositors are
+        recommended to clamp the values to the valid range when possible.
+
+        By default, a surface does not have an associated image description
+        nor a rendering intent. The handling of color on such surfaces is
+        compositor implementation defined. Compositors should handle such
+        surfaces as sRGB, but may handle them differently if they have specific
+        requirements.
+
+        Setting the image description has copy semantics; after this request,
+        the image description can be immediately destroyed without affecting
+        the pending state of the surface.
+      </description>
+
+      <arg name="image_description"
+           type="object" interface="wp_image_description_v1"/>
+      <arg name="render_intent"
+           type="uint" enum="wp_color_manager_v1.render_intent"
+           summary="rendering intent"/>
+    </request>
+
+    <request name="unset_image_description">
+      <description summary="remove the surface image description">
+        If this protocol object is inert, the protocol error inert is raised.
+
+        This request removes any image description from the surface. See
+        set_image_description for how a compositor handles a surface without
+        an image description. This is double-buffered state, see
+        wl_surface.commit.
+      </description>
+    </request>
+  </interface>
+
+  <interface name="wp_color_management_surface_feedback_v1" version="1">
+    <description summary="color management extension to a surface">
+        A wp_color_management_surface_feedback_v1 allows the client to get the
+        preferred image description of a surface.
+
+        If the wl_surface associated with this object is destroyed, the
+        wp_color_management_surface_feedback_v1 object becomes inert.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the color management interface for a surface">
+        Destroy the wp_color_management_surface_feedback_v1 object.
+      </description>
+    </request>
+
+    <enum name="error">
+      <description summary="protocol errors"/>
+      <entry name="inert" value="0"
+             summary="forbidden request on inert object"/>
+      <entry name="unsupported_feature" value="1"
+             summary="attempted to use an unsupported feature"/>
+    </enum>
+
+    <event name="preferred_changed">
+      <description summary="the preferred image description changed">
+        The preferred image description is the one which likely has the most
+        performance and/or quality benefits for the compositor if used by the
+        client for its wl_surface contents. This event is sent whenever the
+        compositor changes the wl_surface's preferred image description.
+
+        This event sends the identity of the new preferred state as the argument,
+        so clients who are aware of the image description already can reuse it.
+        Otherwise, if the client client wants to know what the preferred image
+        description is, it shall use the get_preferred request.
+
+        The preferred image description is not automatically used for anything.
+        It is only a hint, and clients may set any valid image description with
+        set_image_description, but there might be performance and color accuracy
+        improvements by providing the wl_surface contents in the preferred
+        image description. Therefore clients that can, should render according
+        to the preferred image description
+      </description>
+
+      <arg name="identity" type="uint" summary="image description id number"/>
+    </event>
+
+    <request name="get_preferred">
+      <description summary="get the preferred image description">
+        If this protocol object is inert, the protocol error inert is raised.
+
+        The preferred image description represents the compositor's preferred
+        color encoding for this wl_surface at the current time. There might be
+        performance and power advantages, as well as improved color
+        reproduction, if the image description of a content update matches the
+        preferred image description.
+
+        This creates a new wp_image_description_v1 object for the currently
+        preferred image description for the wl_surface. The client should
+        stop using and destroy the image descriptions created by earlier
+        invocations of this request for the associated wl_surface.
+        This request is usually sent as a reaction to the preferred_changed
+        event or when creating a wp_color_management_surface_feedback_v1 object
+        if the client is capable of adapting to image descriptions.
+
+        The created wp_image_description_v1 object preserves the preferred image
+        description of the wl_surface from the time the object was created.
+
+        The resulting image description object allows get_information request.
+
+        If the image description is parametric, the client should set it on its
+        wl_surface only if the image description is an exact match with the
+        client content. Particularly if everything else matches, but the target
+        color volume is greater than what the client needs, the client should
+        create its own parameric image description with its exact parameters.
+
+        If the interface version is inadequate for the preferred image
+        description, meaning that the client does not support all the
+        events needed to deliver the crucial information, the resulting image
+        description object shall immediately deliver the
+        wp_image_description_v1.failed event with the low_version cause,
+        otherwise the object shall immediately deliver the ready event.
+      </description>
+
+      <arg name="image_description"
+           type="new_id" interface="wp_image_description_v1"/>
+    </request>
+
+    <request name="get_preferred_parametric">
+      <description summary="get the preferred image description">
+        The same description as for get_preferred applies, except the returned
+        image description is guaranteed to be parametric. This is meant for
+        clients that can only deal with parametric image descriptions.
+
+        If the compositor doesn't support parametric image descriptions, the
+        unsupported_feature error is emitted.
+      </description>
+
+      <arg name="image_description"
+           type="new_id" interface="wp_image_description_v1"/>
+    </request>
+  </interface>
+
+  <interface name="wp_image_description_creator_icc_v1" version="1">
+    <description summary="holder of image description ICC information">
+      This type of object is used for collecting all the information required
+      to create a wp_image_description_v1 object from an ICC file. A complete
+      set of required parameters consists of these properties:
+      - ICC file
+
+      Each required property must be set exactly once if the client is to create
+      an image description. The set requests verify that a property was not
+      already set. The create request verifies that all required properties are
+      set. There may be several alternative requests for setting each property,
+      and in that case the client must choose one of them.
+
+      Once all properties have been set, the create request must be used to
+      create the image description object, destroying the creator in the
+      process.
+    </description>
+
+    <enum name="error">
+      <description summary="protocol errors"/>
+
+      <entry name="incomplete_set" value="0"
+             summary="incomplete parameter set"/>
+      <entry name="already_set" value="1"
+             summary="property already set"/>
+      <entry name="bad_fd" value="2"
+             summary="fd not seekable and readable"/>
+      <entry name="bad_size" value="3"
+             summary="no or too much data"/>
+      <entry name="out_of_file" value="4"
+             summary="offset + length exceeds file size"/>
+    </enum>
+
+    <request name="create" type="destructor">
+      <description summary="Create the image description object from ICC data">
+        Create an image description object based on the ICC information
+        previously set on this object. A compositor must parse the ICC data in
+        some undefined but finite amount of time.
+
+        The completeness of the parameter set is verified. If the set is not
+        complete, the protocol error incomplete_set is raised. For the
+        definition of a complete set, see the description of this interface.
+
+        If the particular combination of the information is not supported
+        by the compositor, the resulting image description object shall
+        immediately deliver the wp_image_description_v1.failed event with the
+        'unsupported' cause. If a valid image description was created from the
+        information, the wp_image_description_v1.ready event will eventually
+        be sent instead.
+
+        This request destroys the wp_image_description_creator_icc_v1 object.
+
+        The resulting image description object does not allow get_information
+        request.
+      </description>
+
+      <arg name="image_description"
+           type="new_id" interface="wp_image_description_v1"/>
+    </request>
+
+    <request name="set_icc_file">
+      <description summary="set the ICC profile file">
+        Sets the ICC profile file to be used as the basis of the image
+        description.
+
+        The data shall be found through the given fd at the given offset, having
+        the given length. The fd must be seekable and readable. Violating these
+        requirements raises the bad_fd protocol error.
+
+        If reading the data fails due to an error independent of the client, the
+        compositor shall send the wp_image_description_v1.failed event on the
+        created wp_image_description_v1 with the 'operating_system' cause.
+
+        The maximum size of the ICC profile is 32 MB. If length is greater than
+        that or zero, the protocol error bad_size is raised. If offset + length
+        exceeds the file size, the protocol error out_of_file is raised.
+
+        A compositor may read the file at any time starting from this request
+        and only until whichever happens first:
+        - If create request was issued, the wp_image_description_v1 object
+          delivers either failed or ready event; or
+        - if create request was not issued, this
+          wp_image_description_creator_icc_v1 object is destroyed.
+
+        A compositor shall not modify the contents of the file, and the fd may
+        be sealed for writes and size changes. The client must ensure to its
+        best ability that the data does not change while the compositor is
+        reading it.
+
+        The data must represent a valid ICC profile. The ICC profile version
+        must be 2 or 4, it must be a 3 channel profile and the class must be
+        Display or ColorSpace. Violating these requirements will not result in a
+        protocol error, but will eventually send the
+        wp_image_description_v1.failed event on the created
+        wp_image_description_v1 with the 'unsupported' cause.
+
+        See the International Color Consortium specification ICC.1:2022 for more
+        details about ICC profiles.
+
+        If ICC file has already been set on this object, the protocol error
+        already_set is raised.
+      </description>
+
+      <arg name="icc_profile" type="fd"
+           summary="ICC profile"/>
+      <arg name="offset" type="uint"
+           summary="byte offset in fd to start of ICC data"/>
+      <arg name="length" type="uint"
+           summary="length of ICC data in bytes"/>
+    </request>
+  </interface>
+
+  <interface name="wp_image_description_creator_params_v1" version="1">
+    <description summary="holder of image description parameters">
+      This type of object is used for collecting all the parameters required
+      to create a wp_image_description_v1 object. A complete set of required
+      parameters consists of these properties:
+      - transfer characteristic function (tf)
+      - chromaticities of primaries and white point (primary color volume)
+
+      The following properties are optional and have a well-defined default
+      if not explicitly set:
+      - primary color volume luminance range
+      - reference white luminance level
+      - mastering display primaries and white point (target color volume)
+      - mastering luminance range
+
+      The following properties are optional and will be ignored
+      if not explicitly set:
+      - maximum content light level
+      - maximum frame-average light level
+
+      Each required property must be set exactly once if the client is to create
+      an image description. The set requests verify that a property was not
+      already set. The create request verifies that all required properties are
+      set. There may be several alternative requests for setting each property,
+      and in that case the client must choose one of them.
+
+      Once all properties have been set, the create request must be used to
+      create the image description object, destroying the creator in the
+      process.
+    </description>
+
+    <enum name="error">
+      <description summary="protocol errors"/>
+
+      <entry name="incomplete_set" value="0"
+             summary="incomplete parameter set"/>
+      <entry name="already_set" value="1"
+             summary="property already set"/>
+      <entry name="unsupported_feature" value="2"
+             summary="request not supported"/>
+      <entry name="invalid_tf" value="3"
+             summary="invalid transfer characteristic"/>
+      <entry name="invalid_primaries_named" value="4"
+             summary="invalid primaries named"/>
+      <entry name="invalid_luminance" value="5"
+             summary="invalid luminance value or range"/>
+    </enum>
+
+    <request name="create" type="destructor">
+      <description summary="Create the image description object using params">
+        Create an image description object based on the parameters previously
+        set on this object.
+
+        The completeness of the parameter set is verified. If the set is not
+        complete, the protocol error incomplete_set is raised. For the
+        definition of a complete set, see the description of this interface.
+
+        The protocol error invalid_luminance is raised if any of the following
+        requirements is not met:
+        - When max_cll is set, it must be greater than min L and less or equal
+          to max L of the mastering luminance range.
+        - When max_fall is set, it must be greater than min L and less or equal
+          to max L of the mastering luminance range.
+        - When both max_cll and max_fall are set, max_fall must be less or equal
+          to max_cll.
+
+        If the particular combination of the parameter set is not supported
+        by the compositor, the resulting image description object shall
+        immediately deliver the wp_image_description_v1.failed event with the
+        'unsupported' cause. If a valid image description was created from the
+        parameter set, the wp_image_description_v1.ready event will eventually
+        be sent instead.
+
+        This request destroys the wp_image_description_creator_params_v1
+        object.
+
+        The resulting image description object does not allow get_information
+        request.
+      </description>
+
+      <arg name="image_description"
+           type="new_id" interface="wp_image_description_v1"/>
+    </request>
+
+    <request name="set_tf_named">
+      <description summary="named transfer characteristic">
+        Sets the transfer characteristic using explicitly enumerated named
+        functions.
+
+        When the resulting image description is attached to an image, the
+        content should be encoded and decoded according to the industry standard
+        practices for the transfer characteristic.
+
+        Only names advertised with wp_color_manager_v1 event supported_tf_named
+        are allowed. Other values shall raise the protocol error invalid_tf.
+
+        If transfer characteristic has already been set on this object, the
+        protocol error already_set is raised.
+      </description>
+
+      <arg name="tf" type="uint" enum="wp_color_manager_v1.transfer_function"
+           summary="named transfer function"/>
+    </request>
+
+    <request name="set_tf_power">
+      <description summary="transfer characteristic as a power curve">
+        Sets the color component transfer characteristic to a power curve with
+        the given exponent. Negative values are handled by mirroring the
+        positive half of the curve through the origin. The valid domain and
+        range of the curve are all finite real numbers. This curve represents
+        the conversion from electrical to optical color channel values.
+
+        When the resulting image description is attached to an image, the
+        content should be encoded with the inverse of the power curve.
+
+        The curve exponent shall be multiplied by 10000 to get the argument eexp
+        value to carry the precision of 4 decimals.
+
+        The curve exponent must be at least 1.0 and at most 10.0. Otherwise the
+        protocol error invalid_tf is raised.
+
+        If transfer characteristic has already been set on this object, the
+        protocol error already_set is raised.
+
+        This request can be used when the compositor advertises
+        wp_color_manager_v1.feature.set_tf_power. Otherwise this request raises
+        the protocol error unsupported_feature.
+      </description>
+
+      <arg name="eexp" type="uint" summary="the exponent * 10000"/>
+    </request>
+
+    <request name="set_primaries_named">
+      <description summary="named primaries">
+        Sets the color primaries and white point using explicitly named sets.
+        This describes the primary color volume which is the basis for color
+        value encoding.
+
+        Only names advertised with wp_color_manager_v1 event
+        supported_primaries_named are allowed. Other values shall raise the
+        protocol error invalid_primaries_named.
+
+        If primaries have already been set on this object, the protocol error
+        already_set is raised.
+      </description>
+
+      <arg name="primaries" type="uint" enum="wp_color_manager_v1.primaries"
+           summary="named primaries"/>
+    </request>
+
+    <request name="set_primaries">
+      <description summary="primaries as chromaticity coordinates">
+        Sets the color primaries and white point using CIE 1931 xy chromaticity
+        coordinates. This describes the primary color volume which is the basis
+        for color value encoding.
+
+        Each coordinate value is multiplied by 1 million to get the argument
+        value to carry precision of 6 decimals.
+
+        If primaries have already been set on this object, the protocol error
+        already_set is raised.
+
+        This request can be used if the compositor advertises
+        wp_color_manager_v1.feature.set_primaries. Otherwise this request raises
+        the protocol error unsupported_feature.
+      </description>
+
+      <arg name="r_x" type="int" summary="Red x * 1M"/>
+      <arg name="r_y" type="int" summary="Red y * 1M"/>
+      <arg name="g_x" type="int" summary="Green x * 1M"/>
+      <arg name="g_y" type="int" summary="Green y * 1M"/>
+      <arg name="b_x" type="int" summary="Blue x * 1M"/>
+      <arg name="b_y" type="int" summary="Blue y * 1M"/>
+      <arg name="w_x" type="int" summary="White x * 1M"/>
+      <arg name="w_y" type="int" summary="White y * 1M"/>
+    </request>
+
+    <request name="set_luminances">
+      <description summary="primary color volume luminance range and reference white">
+        Sets the primary color volume luminance range and the reference white
+        luminance level. These values include the minimum display emission
+        and ambient flare luminances, assumed to be optically additive and have
+        the chromaticity of the primary color volume white point.
+
+        The default luminances from
+        https://www.color.org/chardata/rgb/srgb.xalter are
+        - primary color volume minimum: 0.2 cd/m²
+        - primary color volume maximum: 80 cd/m²
+        - reference white: 80 cd/m²
+
+        Setting a named transfer characteristic can imply other default
+        luminances.
+
+        The default luminances get overwritten when this request is used.
+        With transfer_function.st2084_pq the given 'max_lum' value is ignored,
+        and 'max_lum' is taken as 'min_lum' + 10000 cd/m².
+
+        'min_lum' and 'max_lum' specify the minimum and maximum luminances of
+        the primary color volume as reproduced by the targeted display.
+
+        'reference_lum' specifies the luminance of the reference white as
+        reproduced by the targeted display, and reflects the targeted viewing
+        environment.
+
+        Compositors should make sure that all content is anchored, meaning that
+        an input signal level of 'reference_lum' on one image description and
+        another input signal level of 'reference_lum' on another image
+        description should produce the same output level, even though the
+        'reference_lum' on both image representations can be different.
+
+        'reference_lum' may be higher than 'max_lum'. In that case reaching
+        the reference white output level in image content requires the
+        'extended_target_volume' feature support.
+
+        If 'max_lum' or 'reference_lum' are less than or equal to 'min_lum',
+        the protocol error invalid_luminance is raised.
+
+        The minimum luminance is multiplied by 10000 to get the argument
+        'min_lum' value and carries precision of 4 decimals. The maximum
+        luminance and reference white luminance values are unscaled.
+
+        If the primary color volume luminance range and the reference white
+        luminance level have already been set on this object, the protocol error
+        already_set is raised.
+
+        This request can be used if the compositor advertises
+        wp_color_manager_v1.feature.set_luminances. Otherwise this request
+        raises the protocol error unsupported_feature.
+      </description>
+
+      <arg name="min_lum" type="uint"
+           summary="minimum luminance (cd/m²) * 10000"/>
+      <arg name="max_lum" type="uint"
+           summary="maximum luminance (cd/m²)"/>
+      <arg name="reference_lum" type="uint"
+           summary="reference white luminance (cd/m²)"/>
+    </request>
+
+    <request name="set_mastering_display_primaries">
+      <description summary="mastering display primaries as chromaticity coordinates">
+        Provides the color primaries and white point of the mastering display
+        using CIE 1931 xy chromaticity coordinates. This is compatible with the
+        SMPTE ST 2086 definition of HDR static metadata.
+
+        The mastering display primaries and mastering display luminances define
+        the target color volume.
+
+        If mastering display primaries are not explicitly set, the target color
+        volume is assumed to have the same primaries as the primary color volume.
+
+        The target color volume is defined by all tristimulus values between 0.0
+        and 1.0 (inclusive) of the color space defined by the given mastering
+        display primaries and white point. The colorimetry is identical between
+        the container color space and the mastering display color space,
+        including that no chromatic adaptation is applied even if the white
+        points differ.
+
+        The target color volume can exceed the primary color volume to allow for
+        a greater color volume with an existing color space definition (for
+        example scRGB). It can be smaller than the primary color volume to
+        minimize gamut and tone mapping distances for big color spaces (HDR
+        metadata).
+
+        To make use of the entire target color volume a suitable pixel format
+        has to be chosen (e.g. floating point to exceed the primary color
+        volume, or abusing limited quantization range as with xvYCC).
+
+        Each coordinate value is multiplied by 1 million to get the argument
+        value to carry precision of 6 decimals.
+
+        If mastering display primaries have already been set on this object, the
+        protocol error already_set is raised.
+
+        This request can be used if the compositor advertises
+        wp_color_manager_v1.feature.set_mastering_display_primaries. Otherwise
+        this request raises the protocol error unsupported_feature. The
+        advertisement implies support only for target color volumes fully
+        contained within the primary color volume.
+
+        If a compositor additionally supports target color volume exceeding the
+        primary color volume, it must advertise
+        wp_color_manager_v1.feature.extended_target_volume. If a client uses
+        target color volume exceeding the primary color volume and the
+        compositor does not support it, the result is implementation defined.
+        Compositors are recommended to detect this case and fail the image
+        description gracefully, but it may as well result in color artifacts.
+      </description>
+
+      <arg name="r_x" type="int" summary="Red x * 1M"/>
+      <arg name="r_y" type="int" summary="Red y * 1M"/>
+      <arg name="g_x" type="int" summary="Green x * 1M"/>
+      <arg name="g_y" type="int" summary="Green y * 1M"/>
+      <arg name="b_x" type="int" summary="Blue x * 1M"/>
+      <arg name="b_y" type="int" summary="Blue y * 1M"/>
+      <arg name="w_x" type="int" summary="White x * 1M"/>
+      <arg name="w_y" type="int" summary="White y * 1M"/>
+    </request>
+
+    <request name="set_mastering_luminance">
+      <description summary="display mastering luminance range">
+        Sets the luminance range that was used during the content mastering
+        process as the minimum and maximum absolute luminance L. These values
+        include the minimum display emission and ambient flare luminances,
+        assumed to be optically additive and have the chromaticity of the
+        primary color volume white point. This should be
+        compatible with the SMPTE ST 2086 definition of HDR static metadata.
+
+        The mastering display primaries and mastering display luminances define
+        the target color volume.
+
+        If mastering luminances are not explicitly set, the target color volume
+        is assumed to have the same min and max luminances as the primary color
+        volume.
+
+        If max L is less than or equal to min L, the protocol error
+        invalid_luminance is raised.
+
+        Min L value is multiplied by 10000 to get the argument min_lum value
+        and carry precision of 4 decimals. Max L value is unscaled for max_lum.
+
+        This request can be used if the compositor advertises
+        wp_color_manager_v1.feature.set_mastering_display_primaries. Otherwise
+        this request raises the protocol error unsupported_feature. The
+        advertisement implies support only for target color volumes fully
+        contained within the primary color volume.
+
+        If a compositor additionally supports target color volume exceeding the
+        primary color volume, it must advertise
+        wp_color_manager_v1.feature.extended_target_volume. If a client uses
+        target color volume exceeding the primary color volume and the
+        compositor does not support it, the result is implementation defined.
+        Compositors are recommended to detect this case and fail the image
+        description gracefully, but it may as well result in color artifacts.
+      </description>
+
+      <arg name="min_lum" type="uint" summary="min L (cd/m²) * 10000"/>
+      <arg name="max_lum" type="uint" summary="max L (cd/m²)"/>
+    </request>
+
+    <request name="set_max_cll">
+      <description summary="maximum content light level">
+        Sets the maximum content light level (max_cll) as defined by CTA-861-H.
+
+        max_cll is undefined by default.
+      </description>
+
+      <arg name="max_cll" type="uint" summary="Maximum content light level (cd/m²)"/>
+    </request>
+
+    <request name="set_max_fall">
+      <description summary="maximum frame-average light level">
+        Sets the maximum frame-average light level (max_fall) as defined by
+        CTA-861-H.
+
+        max_fall is undefined by default.
+      </description>
+
+      <arg name="max_fall" type="uint" summary="Maximum frame-average light level (cd/m²)"/>
+    </request>
+  </interface>
+
+  <interface name="wp_image_description_v1" version="1">
+    <description summary="Colorimetric image description">
+      An image description carries information about the color encoding used on
+      a surface when attached to a wl_surface via
+      wp_color_management_surface_v1.set_image_description. A compositor can use
+      this information to decode pixel values into colorimetrically meaningful
+      quantities.
+
+      Note, that the wp_image_description_v1 object is not ready to be used
+      immediately after creation. The object eventually delivers either the
+      'ready' or the 'failed' event, specified in all requests creating it. The
+      object is deemed "ready" after receiving the 'ready' event.
+
+      An object which is not ready is illegal to use, it can only be destroyed.
+      Any other request in this interface shall result in the 'not_ready'
+      protocol error. Attempts to use an object which is not ready through other
+      interfaces shall raise protocol errors defined there.
+
+      Once created and regardless of how it was created, a
+      wp_image_description_v1 object always refers to one fixed image
+      description. It cannot change after creation.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the image description">
+        Destroy this object. It is safe to destroy an object which is not ready.
+
+        Destroying a wp_image_description_v1 object has no side-effects, not
+        even if a wp_color_management_surface_v1.set_image_description has not
+        yet been followed by a wl_surface.commit.
+      </description>
+    </request>
+
+    <enum name="error">
+      <description summary="protocol errors"/>
+
+      <entry name="not_ready" value="0"
+             summary="attempted to use an object which is not ready"/>
+      <entry name="no_information" value="1"
+             summary="get_information not allowed"/>
+    </enum>
+
+    <enum name="cause">
+      <description summary="generic reason for failure"/>
+
+      <entry name="low_version" value="0"
+             summary="interface version too low"/>
+      <entry name="unsupported" value="1"
+             summary="unsupported image description data"/>
+      <entry name="operating_system" value="2"
+             summary="error independent of the client"/>
+      <entry name="no_output" value="3"
+             summary="the relevant output no longer exists"/>
+    </enum>
+
+    <event name="failed">
+      <description summary="graceful error on creating the image description">
+        If creating a wp_image_description_v1 object fails for a reason that is
+        not defined as a protocol error, this event is sent.
+
+        The requests that create image description objects define whether and
+        when this can occur. Only such creation requests can trigger this event.
+        This event cannot be triggered after the image description was
+        successfully formed.
+
+        Once this event has been sent, the wp_image_description_v1 object will
+        never become ready and it can only be destroyed.
+      </description>
+
+      <arg name="cause" type="uint" enum="cause"
+           summary="generic reason"/>
+      <arg name="msg" type="string"
+           summary="ad hoc human-readable explanation"/>
+    </event>
+
+    <event name="ready">
+      <description summary="indication that the object is ready to be used">
+        Once this event has been sent, the wp_image_description_v1 object is
+        deemed "ready". Ready objects can be used to send requests and can be
+        used through other interfaces.
+
+        Every ready wp_image_description_v1 protocol object refers to an
+        underlying image description record in the compositor. Multiple protocol
+        objects may end up referring to the same record. Clients may identify
+        these "copies" by comparing their id numbers: if the numbers from two
+        protocol objects are identical, the protocol objects refer to the same
+        image description record. Two different image description records
+        cannot have the same id number simultaneously. The id number does not
+        change during the lifetime of the image description record.
+
+        The id number is valid only as long as the protocol object is alive. If
+        all protocol objects referring to the same image description record are
+        destroyed, the id number may be recycled for a different image
+        description record.
+
+        Image description id number is not a protocol object id. Zero is
+        reserved as an invalid id number. It shall not be possible for a client
+        to refer to an image description by its id number in protocol. The id
+        numbers might not be portable between Wayland connections. A compositor
+        shall not send an invalid id number.
+
+        This identity allows clients to de-duplicate image description records
+        and avoid get_information request if they already have the image
+        description information.
+      </description>
+
+      <arg name="identity" type="uint" summary="image description id number"/>
+    </event>
+
+    <request name="get_information">
+      <description summary="get information about the image description">
+        Creates a wp_image_description_info_v1 object which delivers the
+        information that makes up the image description.
+
+        Not all image description protocol objects allow get_information
+        request. Whether it is allowed or not is defined by the request that
+        created the object. If get_information is not allowed, the protocol
+        error no_information is raised.
+      </description>
+
+      <arg name="information"
+           type="new_id" interface="wp_image_description_info_v1"/>
+    </request>
+  </interface>
+
+  <interface name="wp_image_description_info_v1" version="1">
+    <description summary="Colorimetric image description information">
+      Sends all matching events describing an image description object exactly
+      once and finally sends the 'done' event.
+
+      This means
+      - if the image description is parametric, it must send
+        - primaries
+        - named_primaries, if applicable
+        - at least one of tf_power and tf_named, as applicable
+        - luminances
+        - target_primaries
+        - target_luminance
+      - if the image description is parametric, it may send, if applicable,
+        - target_max_cll
+        - target_max_fall
+      - if the image description contains an ICC profile, it must send the
+        icc_file event
+
+      Once a wp_image_description_info_v1 object has delivered a 'done' event it
+      is automatically destroyed.
+
+      Every wp_image_description_info_v1 created from the same
+      wp_image_description_v1 shall always return the exact same data.
+    </description>
+
+    <event name="done" type="destructor">
+      <description summary="end of information">
+        Signals the end of information events and destroys the object.
+      </description>
+    </event>
+
+    <event name="icc_file">
+      <description summary="ICC profile matching the image description">
+        The icc argument provides a file descriptor to the client which may be
+        memory-mapped to provide the ICC profile matching the image description.
+        The fd is read-only, and if mapped then it must be mapped with
+        MAP_PRIVATE by the client.
+
+        The ICC profile version and other details are determined by the
+        compositor. There is no provision for a client to ask for a specific
+        kind of a profile.
+      </description>
+
+      <arg name="icc" type="fd" summary="ICC profile file descriptor"/>
+      <arg name="icc_size" type="uint" summary="ICC profile size, in bytes"/>
+      <!-- Offset always 0, compositor must not expose unnecessary data. -->
+    </event>
+
+    <event name="primaries">
+      <description summary="primaries as chromaticity coordinates">
+        Delivers the primary color volume primaries and white point using CIE
+        1931 xy chromaticity coordinates.
+
+        Each coordinate value is multiplied by 1 million to get the argument
+        value to carry precision of 6 decimals.
+      </description>
+
+      <arg name="r_x" type="int" summary="Red x * 1M"/>
+      <arg name="r_y" type="int" summary="Red y * 1M"/>
+      <arg name="g_x" type="int" summary="Green x * 1M"/>
+      <arg name="g_y" type="int" summary="Green y * 1M"/>
+      <arg name="b_x" type="int" summary="Blue x * 1M"/>
+      <arg name="b_y" type="int" summary="Blue y * 1M"/>
+      <arg name="w_x" type="int" summary="White x * 1M"/>
+      <arg name="w_y" type="int" summary="White y * 1M"/>
+    </event>
+
+    <event name="primaries_named">
+      <description summary="named primaries">
+        Delivers the primary color volume primaries and white point using an
+        explicitly enumerated named set.
+      </description>
+
+      <arg name="primaries" type="uint" enum="wp_color_manager_v1.primaries"
+           summary="named primaries"/>
+    </event>
+
+    <event name="tf_power">
+      <description summary="transfer characteristic as a power curve">
+        The color component transfer characteristic of this image description is
+        a pure power curve. This event provides the exponent of the power
+        function. This curve represents the conversion from electrical to
+        optical pixel or color values.
+
+        The curve exponent has been multiplied by 10000 to get the argument eexp
+        value to carry the precision of 4 decimals.
+      </description>
+
+      <arg name="eexp" type="uint" summary="the exponent * 10000"/>
+    </event>
+
+    <event name="tf_named">
+      <description summary="named transfer characteristic">
+        Delivers the transfer characteristic using an explicitly enumerated
+        named function.
+      </description>
+
+      <arg name="tf" type="uint" enum="wp_color_manager_v1.transfer_function"
+           summary="named transfer function"/>
+    </event>
+
+    <event name="luminances">
+      <description summary="primary color volume luminance range and reference white">
+        Delivers the primary color volume luminance range and the reference
+        white luminance level. These values include the minimum display emission
+        and ambient flare luminances, assumed to be optically additive and have
+        the chromaticity of the primary color volume white point.
+
+        The minimum luminance is multiplied by 10000 to get the argument
+        'min_lum' value and carries precision of 4 decimals. The maximum
+        luminance and reference white luminance values are unscaled.
+      </description>
+
+      <arg name="min_lum" type="uint"
+           summary="minimum luminance (cd/m²) * 10000"/>
+      <arg name="max_lum" type="uint"
+           summary="maximum luminance (cd/m²)"/>
+      <arg name="reference_lum" type="uint"
+           summary="reference white luminance (cd/m²)"/>
+    </event>
+
+    <event name="target_primaries">
+      <description summary="target primaries as chromaticity coordinates">
+        Provides the color primaries and white point of the target color volume
+        using CIE 1931 xy chromaticity coordinates. This is compatible with the
+        SMPTE ST 2086 definition of HDR static metadata for mastering displays.
+
+        While primary color volume is about how color is encoded, the target
+        color volume is the actually displayable color volume. If target color
+        volume is equal to the primary color volume, then this event is not
+        sent.
+
+        Each coordinate value is multiplied by 1 million to get the argument
+        value to carry precision of 6 decimals.
+      </description>
+
+      <arg name="r_x" type="int" summary="Red x * 1M"/>
+      <arg name="r_y" type="int" summary="Red y * 1M"/>
+      <arg name="g_x" type="int" summary="Green x * 1M"/>
+      <arg name="g_y" type="int" summary="Green y * 1M"/>
+      <arg name="b_x" type="int" summary="Blue x * 1M"/>
+      <arg name="b_y" type="int" summary="Blue y * 1M"/>
+      <arg name="w_x" type="int" summary="White x * 1M"/>
+      <arg name="w_y" type="int" summary="White y * 1M"/>
+    </event>
+
+    <event name="target_luminance">
+      <description summary="target luminance range">
+        Provides the luminance range that the image description is targeting as
+        the minimum and maximum absolute luminance L. These values include the
+        minimum display emission and ambient flare luminances, assumed to be
+        optically additive and have the chromaticity of the primary color
+        volume white point. This should be compatible with the SMPTE ST 2086
+        definition of HDR static metadata.
+
+        This luminance range is only theoretical and may not correspond to the
+        luminance of light emitted on an actual display.
+
+        Min L value is multiplied by 10000 to get the argument min_lum value and
+        carry precision of 4 decimals. Max L value is unscaled for max_lum.
+      </description>
+
+      <arg name="min_lum" type="uint" summary="min L (cd/m²) * 10000"/>
+      <arg name="max_lum" type="uint" summary="max L (cd/m²)"/>
+    </event>
+
+    <event name="target_max_cll">
+      <description summary="target maximum content light level">
+        Provides the targeted max_cll of the image description. max_cll is
+        defined by CTA-861-H.
+
+        This luminance is only theoretical and may not correspond to the
+        luminance of light emitted on an actual display.
+      </description>
+
+      <arg name="max_cll" type="uint"
+           summary="Maximum content light-level (cd/m²)"/>
+    </event>
+
+    <event name="target_max_fall">
+      <description summary="target maximum frame-average light level">
+        Provides the targeted max_fall of the image description. max_fall is
+        defined by CTA-861-H.
+
+        This luminance is only theoretical and may not correspond to the
+        luminance of light emitted on an actual display.
+      </description>
+
+      <arg name="max_fall" type="uint"
+           summary="Maximum frame-average light level (cd/m²)"/>
+    </event>
+  </interface>
+</protocol>
diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index d85d56f06c2..cc2cc9283e8 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -219,6 +219,7 @@ static UINT get_edid(const struct output_info *output_info, unsigned char **data
     unsigned int i, mwidth, mheight;
     unsigned char c;
     struct wayland_output_mode *mode = output_info->output->current_mode;
+    const struct wayland_primaries *primaries = &output_info->output->primaries;
 
     /* assume ~150 dpi */
     mwidth = mode->width / 60;
@@ -236,10 +237,22 @@ static UINT get_edid(const struct output_info *output_info, unsigned char **data
     data[21] = mwidth;
     data[22] = mheight;
     data[24] = 0x6;
+    data[25] = ((primaries->r_x & 0x3) << 6) | ((primaries->r_y & 0x3) << 4) |
+               ((primaries->g_x & 0x3) << 2) | (primaries->g_y & 0x3);
+    data[26] = ((primaries->b_x & 0x3) << 6) | ((primaries->b_y & 0x3) << 4) |
+               ((primaries->w_x & 0x3) << 2) | (primaries->w_y & 0x3);
+    data[27] = (primaries->r_x & 0x3fc) >> 2;
+    data[28] = (primaries->r_y & 0x3fc) >> 2;
+    data[29] = (primaries->g_x & 0x3fc) >> 2;
+    data[30] = (primaries->g_y & 0x3fc) >> 2;
+    data[31] = (primaries->b_x & 0x3fc) >> 2;
+    data[32] = (primaries->b_y & 0x3fc) >> 2;
+    data[33] = (primaries->w_x & 0x3fc) >> 2;
+    data[34] = (primaries->w_y & 0x3fc) >> 2;
 
     p = data + 54;
 
-    *(uint16_t*)&p[0] = 0x0; /* reserved */
+    *(uint16_t*)&p[0] = 0x0; /* 0 = reserved */
 
     /* assume blanking time is 0 */
     p[2] = mode->width;
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 45c768f7917..fc0665309a5 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -205,6 +205,11 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
             wl_registry_bind(registry, id, &wp_cursor_shape_manager_v1_interface,
                              version < 2 ? version : 2);
     }
+    else if (strcmp(interface, "wp_color_manager_v1") == 0)
+    {
+        process_wayland.wp_color_manager_v1 =
+            wl_registry_bind(registry, id, &wp_color_manager_v1_interface, 1);
+    }
 }
 
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index 73b0b8332c5..9f414d7540e 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -40,6 +40,8 @@ static uint32_t next_output_id = 0;
 #define WAYLAND_OUTPUT_CHANGED_LOGICAL_XY 0x04
 #define WAYLAND_OUTPUT_CHANGED_LOGICAL_WH 0x08
 #define WAYLAND_OUTPUT_CHANGED_TRANSFORM  0x10
+#define WAYLAND_OUTPUT_CHANGED_PRIMARIES  0x20
+#define WAYLAND_OUTPUT_CHANGED_LUMINANCE  0x40
 
 /**********************************************************************
  *          Output handling
@@ -182,6 +184,19 @@ static void wayland_output_done(struct wayland_output *output)
         output->current.transform = output->pending.transform;
     }
 
+    if (output->pending_flags & WAYLAND_OUTPUT_CHANGED_PRIMARIES)
+    {
+        /* Copy here as well in case this gets called first */
+        output->current.primaries = output->pending.primaries;
+    }
+
+    if (output->pending_flags & WAYLAND_OUTPUT_CHANGED_LUMINANCE)
+    {
+        output->current.max_luminance = output->pending.max_luminance;
+        output->current.min_luminance = output->pending.min_luminance;
+
+    }
+
     output->pending_flags = 0;
 
     /* Ensure the logical dimensions have sane values. */
@@ -319,6 +334,155 @@ static const struct zxdg_output_v1_listener zxdg_output_v1_listener = {
     zxdg_output_v1_handle_description,
 };
 
+static void wp_image_description_info_v1_done(void *data,
+                                              struct wp_image_description_info_v1 *info)
+{
+    struct wayland_output *output = data;
+    pthread_mutex_lock(&process_wayland.output_mutex);
+
+    if (output->pending_flags & WAYLAND_OUTPUT_CHANGED_PRIMARIES)
+    {
+        output->current.primaries = output->pending.primaries;
+        output->pending_flags &= ~WAYLAND_OUTPUT_CHANGED_PRIMARIES;
+    }
+
+    if (output->pending_flags & WAYLAND_OUTPUT_CHANGED_LUMINANCE)
+    {
+        output->current.max_luminance = output->pending.max_luminance;
+        output->current.min_luminance = output->pending.min_luminance;
+        output->pending_flags &= ~WAYLAND_OUTPUT_CHANGED_LUMINANCE;
+    }
+
+    TRACE("%p\n", output);
+
+    pthread_mutex_unlock(&process_wayland.output_mutex);
+
+    maybe_init_display_devices();
+}
+
+static void wp_image_description_info_v1_icc_file(void *data,
+                                                  struct wp_image_description_info_v1 *info,
+                                                  int32_t icc, uint32_t icc_size)
+{
+
+}
+
+static void wp_image_description_info_v1_primaries(void *data,
+                                                   struct wp_image_description_info_v1 *info,
+                                                   int32_t r_x, int32_t r_y, int32_t g_x,
+			                                       int32_t g_y, int32_t b_x, int32_t b_y,
+                                                   int32_t w_x, int32_t w_y)
+{
+    struct wayland_output *output = data;
+
+    pthread_mutex_lock(&process_wayland.output_mutex);
+
+#define COPY(name) output->pending.primaries.name = round((name * 1e-6) * 1024)
+    COPY(r_x);
+    COPY(r_y);
+    COPY(g_x);
+    COPY(g_y);
+    COPY(b_x);
+    COPY(b_y);
+    COPY(w_x);
+    COPY(w_y);
+#undef COPY
+
+    TRACE("primaries: {%lf, %lf, %lf, %lf, %lf, %lf, %lf, %lf}\n",
+        r_x * 1e-6, r_y * 1e-6, g_x * 1e-6, g_y * 1e-6, b_x * 1e-6, b_y * 1e-6, w_x * 1e-6, w_y * 1e-6);
+
+    output->pending_flags |= WAYLAND_OUTPUT_CHANGED_PRIMARIES;
+
+    pthread_mutex_unlock(&process_wayland.output_mutex);
+}
+
+static void wayland_image_description_info_v1_primaries_named(void *data,
+				            struct wp_image_description_info_v1 *info,
+				            uint32_t primaries)
+{
+
+}
+
+static void wayland_image_description_info_v1_tfpower(void *data,
+				            struct wp_image_description_info_v1 *info,
+				            uint32_t power)
+{
+
+}
+
+static void wayland_image_description_info_v1_tfnamed(void *data,
+				            struct wp_image_description_info_v1 *info,
+				            uint32_t named)
+{
+
+}
+
+static void wayland_image_description_info_v1_luminance(void *data,
+                            struct wp_image_description_info_v1 *info,
+                            uint32_t min, uint32_t max, uint32_t ref)
+{
+    struct wayland_output *output = data;
+    pthread_mutex_lock(&process_wayland.output_mutex);
+
+    output->pending.max_luminance = max;
+    output->pending.min_luminance = min;
+    output->pending_flags |= WAYLAND_OUTPUT_CHANGED_LUMINANCE;
+
+    TRACE("min %lf max %u ref %u\n", min * 1e-4, max, ref);
+
+    pthread_mutex_unlock(&process_wayland.output_mutex);
+
+}
+
+static void wayland_image_description_info_v1_target_primaries(void *data,
+				 struct wp_image_description_info_v1 *info,
+				 int32_t r_x,
+				 int32_t r_y,
+				 int32_t g_x,
+				 int32_t g_y,
+				 int32_t b_x,
+				 int32_t b_y,
+				 int32_t w_x,
+				 int32_t w_y)
+{
+
+}
+
+static void wayland_image_description_info_v1_target_luminance(void *data,
+                            struct wp_image_description_info_v1 *info,
+                            uint32_t min, uint32_t max)
+{
+
+}
+
+static void wayland_image_description_info_v1_target_max_cll(void *data,
+				            struct wp_image_description_info_v1 *info,
+				            uint32_t max)
+{
+
+}
+
+static void wayland_image_description_info_v1_target_max_fall(void *data,
+				            struct wp_image_description_info_v1 *info,
+				            uint32_t max)
+{
+
+}
+
+static const struct wp_image_description_info_v1_listener image_description_info_listener = {
+    wp_image_description_info_v1_done,
+    wp_image_description_info_v1_icc_file,
+    wp_image_description_info_v1_primaries,
+    wayland_image_description_info_v1_primaries_named,
+    wayland_image_description_info_v1_tfpower,
+    wayland_image_description_info_v1_tfnamed,
+    wayland_image_description_info_v1_luminance,
+    wayland_image_description_info_v1_target_primaries,
+    wayland_image_description_info_v1_target_luminance,
+    wayland_image_description_info_v1_target_max_cll,
+    wayland_image_description_info_v1_target_max_fall
+};
+
 /**********************************************************************
  *          wayland_output_create
  *
@@ -362,6 +526,24 @@ BOOL wayland_output_create(uint32_t id, uint32_t version)
 
     if (process_wayland.zxdg_output_manager_v1)
         wayland_output_use_xdg_extension(output);
+    if (process_wayland.wp_color_manager_v1)
+    {
+        output->wp_color_management_output_v1 =
+            wp_color_manager_v1_get_output(
+                        process_wayland.wp_color_manager_v1,
+                                     output->wl_output);
+        output->wp_image_description_v1 =
+            wp_color_management_output_v1_get_image_description(
+                output->wp_color_management_output_v1
+            );
+        output->wp_image_description_info_v1 =
+            wp_image_description_v1_get_information(
+                output->wp_image_description_v1
+            );
+        wp_image_description_info_v1_add_listener(
+            output->wp_image_description_info_v1,
+            &image_description_info_listener, output);
+    }
 
     pthread_mutex_lock(&process_wayland.output_mutex);
     wl_list_insert(process_wayland.output_list.prev, &output->link);
@@ -395,6 +577,12 @@ void wayland_output_destroy(struct wayland_output *output)
     wayland_output_state_deinit(&output->current);
     if (output->zxdg_output_v1)
         zxdg_output_v1_destroy(output->zxdg_output_v1);
+    if (output->wp_color_management_output_v1)
+        wp_color_management_output_v1_destroy(output->wp_color_management_output_v1);
+    if (output->wp_image_description_v1)
+        wp_image_description_v1_destroy(output->wp_image_description_v1);
+    if (output->wp_image_description_info_v1)
+        wp_image_description_info_v1_destroy(output->wp_image_description_info_v1);
     wl_output_destroy(output->wl_output);
     free(output);
 
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 4537c934077..33864f6eab1 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -40,6 +40,7 @@
 #include "fractional-scale-v1-client-protocol.h"
 #include "tablet-v2-client-protocol.h"
 #include "cursor-shape-v1-client-protocol.h"
+#include "color-management-v1-client-protocol.h"
 
 #include "windef.h"
 #include "winbase.h"
@@ -182,6 +183,7 @@ struct wayland
     struct wl_data_device_manager *wl_data_device_manager;
     struct xdg_toplevel_icon_manager_v1 *xdg_toplevel_icon_manager_v1;
     struct wp_cursor_shape_manager_v1 *wp_cursor_shape_manager_v1;
+    struct wp_color_manager_v1 *wp_color_manager_v1;
     struct wayland_seat seat;
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
@@ -201,11 +203,26 @@ struct wayland_output_mode
     int32_t refresh;
 };
 
+struct wayland_primaries
+{
+    int32_t r_x;
+    int32_t r_y;
+    int32_t g_x;
+    int32_t g_y;
+    int32_t b_x;
+    int32_t b_y;
+    int32_t w_x;
+    int32_t w_y;
+};
+
 struct wayland_output_state
 {
     int modes_count;
     struct rb_tree modes;
     struct wayland_output_mode *current_mode;
+    struct wayland_primaries primaries;
+    uint32_t max_luminance;
+    uint32_t min_luminance;
     char *name;
     int resolved_x, resolved_y; /* store positions post overlap correction */
     int logical_x, logical_y;
@@ -218,6 +235,9 @@ struct wayland_output
     struct wl_list link;
     struct wl_output *wl_output;
     struct zxdg_output_v1 *zxdg_output_v1;
+    struct wp_color_management_output_v1 *wp_color_management_output_v1;
+    struct wp_image_description_v1 *wp_image_description_v1;
+    struct wp_image_description_info_v1 *wp_image_description_info_v1;
     uint32_t global_id;
     unsigned int pending_flags;
     struct wayland_output_state pending;
-- 
2.49.0

From 452b37c271efb9860eef99ca9c3e569782e8ded3 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sun, 25 May 2025 21:37:54 -0400
Subject: [PATCH 065/159] fixup! winewayland: Support output switching.

---
 dlls/winewayland.drv/wayland_surface.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 3de12a1afe2..ea314dea032 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -712,6 +712,10 @@ static void wayland_surface_reconfigure_geometry(struct wayland_surface *surface
                 xdg_toplevel_unset_fullscreen(surface->xdg_toplevel);
                 wl_display_flush(process_wayland.wl_display);
                 xdg_toplevel_set_fullscreen(surface->xdg_toplevel, output);
+                /* In case we don't get enter event from compositor
+                   happens on sway for instance
+                */
+                surface->wl_output = output;
             }
             pthread_mutex_unlock(&process_wayland.output_mutex);
         }
-- 
2.49.0

From 9777ee774aca27f6a53419ac12dcf1d7c5a1321d Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sun, 25 May 2025 22:07:01 -0400
Subject: [PATCH 066/159] HACK: winewayland: Add option to offset monitor
 positions.

---
 dlls/winewayland.drv/wayland_output.c | 22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index 9f414d7540e..84eee57714b 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -131,6 +131,27 @@ static void wayland_output_mode_free_rb(struct rb_entry *entry, void *ctx)
     free(RB_ENTRY_VALUE(entry, struct wayland_output_mode, entry));
 }
 
+/* Check environment variables to look for coordinate offset */
+static void apply_user_coord_offset(int *x, int *y)
+{
+    const char *env;
+    int offset;
+
+    env = getenv("WAYLANDDRV_XOFFSET");
+    if (env && sscanf(env, "%d", &offset) == 1)
+    {
+        *x -= offset;
+        TRACE("x offset %d\n", offset);
+    }
+
+    env = getenv("WAYLANDDRV_YOFFSET");
+    if (env && sscanf(env, "%d", &offset) == 1)
+    {
+        *y -= offset;
+        TRACE("y offset %d\n", offset);
+    }
+}
+
 static void wayland_output_done(struct wayland_output *output)
 {
     struct wayland_output_mode *mode;
@@ -169,6 +190,7 @@ static void wayland_output_done(struct wayland_output *output)
     {
         output->current.logical_x = output->pending.logical_x;
         output->current.logical_y = output->pending.logical_y;
+        apply_user_coord_offset(&output->current.logical_x, &output->current.logical_y);
         output->current.resolved_x = output->current.logical_x;
         output->current.resolved_y = output->current.logical_y;
     }
-- 
2.49.0

From 7c82a495ea86b8c2d8eaa4a00d469ec40703230a Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sun, 25 May 2025 22:22:17 -0400
Subject: [PATCH 067/159] winewayland: Add error message when
 wp_color_manager_v1 is missing.

---
 dlls/winewayland.drv/wayland.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index fc0665309a5..29f3e48645e 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -346,6 +346,9 @@ BOOL wayland_process_init(void)
     if (!process_wayland.wp_fractional_scale_manager_v1)
         ERR("Wayland compositor doesn't support wp_fractional_scale_manager_v1 (fractional scaling will be broken)\n");
 
+    if (!process_wayland.wp_color_manager_v1)
+        ERR("Wayland compositor doesn't support wp_color_manager_v1 (HDR will not be supported)\n");
+
     process_wayland.initialized = TRUE;
 
     return TRUE;
-- 
2.49.0

From 625fea5be234290a5ae9a8e0e230d118cfe06359 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Mon, 26 May 2025 23:39:19 -0400
Subject: [PATCH 068/159] amdxc: Only load amdxcffx when FSR4 upgrade is
 enabled.

---
 dlls/amdxc64/main.c | 27 ++++++++++++++++-----------
 1 file changed, 16 insertions(+), 11 deletions(-)

diff --git a/dlls/amdxc64/main.c b/dlls/amdxc64/main.c
index d4dd071b0e0..2cc11a811fc 100644
--- a/dlls/amdxc64/main.c
+++ b/dlls/amdxc64/main.c
@@ -84,23 +84,28 @@ HRESULT STDMETHODCALLTYPE AMDFSR4FFX_UpdateFfxApiProvider(IAmdExtFfxApi *iface,
 {
     const char *env;
     updateffxapi_pfn pfn;
-    HMODULE amdffx = LoadLibraryA("amdxcffx64");
+    HMODULE amdffx;
 
     TRACE("%p %p %u\n", iface, data, size);
 
-    if (!amdffx)
-    {
-        ERR("Failed to load FSR4 dll (amdxcffx)!\n");
-        return E_NOINTERFACE;
-    }
-
-    pfn = (updateffxapi_pfn)GetProcAddress(amdffx, "UpdateFfxApiProvider");
     env = getenv("FSR4_UPGRADE");
 
-    if(pfn && env && env[0] != '0')
+    if(env && env[0] != '0')
     {
-        FIXME("Replaced FSR3 with FSR4!\n");
-        return pfn(data, size);
+        amdffx = LoadLibraryA("amdxcffx64");
+        if (!amdffx)
+        {
+            ERR("Failed to load FSR4 dll (amdxcffx)!\n");
+            return E_NOINTERFACE;
+        }
+
+        pfn = (updateffxapi_pfn)GetProcAddress(amdffx, "UpdateFfxApiProvider");
+
+        if(pfn)
+        {
+            FIXME("Replaced FSR3 with FSR4!\n");
+            return pfn(data, size);
+        }
     }
 
     return E_NOINTERFACE;
-- 
2.49.0

From cc1181adbd8bf3ef672401ab7a139b545b05a4f5 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Tue, 27 May 2025 00:08:02 -0400
Subject: [PATCH 069/159] winebus: Ignore steam input virtual controller when
 PROTON_PREFER_SDL is set.

---
 dlls/winebus.sys/bus_udev.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/dlls/winebus.sys/bus_udev.c b/dlls/winebus.sys/bus_udev.c
index ceff0b675ad..d1c3109c13e 100644
--- a/dlls/winebus.sys/bus_udev.c
+++ b/dlls/winebus.sys/bus_udev.c
@@ -1646,6 +1646,13 @@ static void udev_add_device(struct udev_device *dev, int fd)
 
     if (desc.vid == 0x28de && desc.pid == 0x11ff && !strcmp(subsystem, "input"))
     {
+        char *env = getenv("PROTON_PREFER_SDL");
+        if (env && !strcmp(env, "1"))
+        {
+            TRACE("evdev %s: gnoring steam input virtual controller\n", debugstr_a(devnode));
+            close(fd);
+            return;
+        }
         TRACE("evdev %s: detected steam input virtual controller\n", debugstr_a(devnode));
         desc.is_gamepad = TRUE;
         desc.version = 0; /* keep version fixed as 0 so we can hardcode it in ntdll rawinput pipe redirection */
-- 
2.49.0

From da72e9070578aa071f10b4b235d2c8e0a92962b6 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Wed, 28 May 2025 16:04:21 -0400
Subject: [PATCH 070/159] winewayland: Refactor output selection

---
 dlls/winewayland.drv/display.c         | 64 +++++++++++++++++++++++---
 dlls/winewayland.drv/wayland_output.c  |  2 -
 dlls/winewayland.drv/wayland_surface.c | 38 +--------------
 dlls/winewayland.drv/waylanddrv.h      |  3 +-
 dlls/winewayland.drv/window.c          |  6 ++-
 5 files changed, 63 insertions(+), 50 deletions(-)

diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index cc2cc9283e8..f1eb6be8e46 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -40,6 +40,7 @@ struct output_info
 {
     int x, y;
     struct wayland_output_state *output;
+    struct wl_output *wl_output; /* FIXME: find a better place to store this */
 };
 
 static int output_info_cmp_primary_x_y(const void *va, const void *vb)
@@ -180,13 +181,6 @@ static void output_info_array_arrange_physical_coords(struct wl_array *output_in
            ++steps < num_outputs)
         continue;
 
-    /* Initialize resolved coordinates with updated coordinates */
-    wl_array_for_each(info, output_info_array)
-    {
-        info->output->resolved_x = info->x;
-        info->output->resolved_y = info->y;
-    }
-
     /* Now that we have our physical pixel coordinates, sort from physical left
      * to right, but ensure the primary output is first. */
     qsort(output_info_array->data, num_outputs, sizeof(struct output_info),
@@ -340,6 +334,62 @@ static void wayland_add_device_modes(const struct gdi_device_manager *device_man
     free(modes);
 }
 
+/* Locking is done externally to ensure wl_output remains valid */
+struct wl_output *wayland_get_best_output_for_rect(const RECT *window_rect)
+{
+    struct wayland_output *output;
+    struct wl_output *best = NULL;
+    RECT output_rect, temp, intersect = {0};
+    struct wl_array output_info_array;
+    struct output_info *output_info;
+
+    wl_array_init(&output_info_array);
+
+    wl_list_for_each(output, &process_wayland.output_list, link)
+    {
+        if (!output->current.current_mode) continue;
+        output_info = wl_array_add(&output_info_array, sizeof(*output_info));
+        if (output_info)
+        {
+            output_info->output = &output->current;
+            output_info->wl_output = output->wl_output;
+        }
+        else ERR("Failed to allocate space for output_info\n");
+    }
+
+    output_info_array_arrange_physical_coords(&output_info_array);
+
+    wl_array_for_each(output_info, &output_info_array)
+    {
+        SetRect(&output_rect, 0, 0,
+                output_info->output->current_mode->width,
+                output_info->output->current_mode->height);
+        OffsetRect(&output_rect,
+                output_info->x,
+                output_info->y);
+
+        TRACE("output %s: %s, window %s\n",
+              debugstr_a(output_info->output->name),
+              wine_dbgstr_rect(&output_rect),
+              wine_dbgstr_rect(window_rect));
+
+        if (intersect_rect(&temp, window_rect, &output_rect) &&
+                area_rect(&temp) > area_rect(&intersect))
+        {
+            intersect = temp;
+            best = output_info->wl_output;
+        }
+    }
+
+    wl_array_release(&output_info_array);
+
+    if (!best)
+        WARN("Could not find associated wl_output for rect %s!\n",
+             wine_dbgstr_rect(window_rect));
+
+    return best;
+}
+
 /***********************************************************************
  *      UpdateDisplayDevices (WAYLAND.@)
  */
diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index 84eee57714b..7c1bc4bb264 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -191,8 +191,6 @@ static void wayland_output_done(struct wayland_output *output)
         output->current.logical_x = output->pending.logical_x;
         output->current.logical_y = output->pending.logical_y;
         apply_user_coord_offset(&output->current.logical_x, &output->current.logical_y);
-        output->current.resolved_x = output->current.logical_x;
-        output->current.resolved_y = output->current.logical_y;
     }
 
     if (output->pending_flags & WAYLAND_OUTPUT_CHANGED_LOGICAL_WH)
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index ea314dea032..e0d89ba7cf6 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -611,42 +611,6 @@ static void wayland_surface_get_rect_in_monitor(struct wayland_surface *surface,
     OffsetRect(rect, -surface->window.rect.left, -surface->window.rect.top);
 }
 
-struct wl_output *wayland_surface_get_best_output(struct wayland_surface *surface)
-{
-    struct wayland_output *output;
-    struct wl_output *best = NULL;
-    RECT output_rect, temp, intersect = {0};
-    const RECT *window_rect = &surface->window.rect;
-
-    wl_list_for_each(output, &process_wayland.output_list, link)
-    {
-        SetRect(&output_rect, 0, 0,
-                output->current.current_mode->width,
-                output->current.current_mode->height);
-        OffsetRect(&output_rect,
-                output->current.resolved_x,
-                output->current.resolved_y);
-
-        TRACE("output %s: %s, window %s\n",
-              output->current.name,
-              wine_dbgstr_rect(&output_rect),
-              wine_dbgstr_rect(window_rect));
-
-        if (intersect_rect(&temp, window_rect, &output_rect) &&
-                area_rect(&temp) > area_rect(&intersect))
-        {
-            intersect = temp;
-            best = output->wl_output;
-        }
-    }
-
-    if (!best)
-        WARN("Could not find associated wl_output for rect %s!\n",
-             wine_dbgstr_rect(window_rect));
-
-    return best;
-}
-
 /**********************************************************************
  *          wayland_surface_reconfigure_geometry
  *
@@ -704,7 +668,7 @@ static void wayland_surface_reconfigure_geometry(struct wayland_surface *surface
         {
             struct wl_output *output;
             pthread_mutex_lock(&process_wayland.output_mutex);
-            output = wayland_surface_get_best_output(surface);
+            output = wayland_get_best_output_for_rect(&surface->window.rect);
             if (output != surface->wl_output)
             {
                 TRACE("Resetting fullscreen state: output %p surface output %p\n",
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 33864f6eab1..a8e9d35ba02 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -224,7 +224,6 @@ struct wayland_output_state
     uint32_t max_luminance;
     uint32_t min_luminance;
     char *name;
-    int resolved_x, resolved_y; /* store positions post overlap correction */
     int logical_x, logical_y;
     int logical_w, logical_h;
     int transform;
@@ -335,6 +334,7 @@ BOOL wayland_process_init(void);
 BOOL wayland_output_create(uint32_t id, uint32_t version);
 void wayland_output_destroy(struct wayland_output *output);
 void wayland_output_use_xdg_extension(struct wayland_output *output);
+struct wl_output *wayland_get_best_output_for_rect(const RECT *window_rect);
 
 /**********************************************************************
  *          Wayland surface
@@ -366,7 +366,6 @@ void wayland_client_surface_detach(struct wayland_client_surface *client);
 void wayland_surface_ensure_contents(struct wayland_surface *surface);
 void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR title);
 void wayland_surface_set_icon(struct wayland_surface *surface, UINT type, ICONINFO *ii);
-struct wl_output *wayland_surface_get_best_output(struct wayland_surface *surface);
 
 static inline BOOL wayland_surface_is_toplevel(struct wayland_surface *surface)
 {
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 99769dce0b5..2752ad2a469 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -274,9 +274,11 @@ static void wayland_surface_update_state_toplevel(struct wayland_surface *surfac
         if ((surface->window.state & WAYLAND_SURFACE_CONFIG_STATE_FULLSCREEN) &&
            !(surface->current.state & WAYLAND_SURFACE_CONFIG_STATE_FULLSCREEN))
         {
+            struct wl_output *output;
             pthread_mutex_lock(&process_wayland.output_mutex);
-            xdg_toplevel_set_fullscreen(surface->xdg_toplevel,
-                        wayland_surface_get_best_output(surface));
+            output = wayland_get_best_output_for_rect(&surface->window.rect);
+            xdg_toplevel_set_fullscreen(surface->xdg_toplevel, output);
+            surface->wl_output = output;
             pthread_mutex_unlock(&process_wayland.output_mutex);
         }
     }
-- 
2.49.0

From d6e91f2586d1f3a81f032f9388483e4d83a428a3 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Wed, 28 May 2025 16:43:23 -0400
Subject: [PATCH 071/159] winebus: PROTON_PREFER_SDL -> PROTON_USE_SDL

More accurately name the env
---
 dlls/winebus.sys/bus_udev.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winebus.sys/bus_udev.c b/dlls/winebus.sys/bus_udev.c
index d1c3109c13e..9c992d84a64 100644
--- a/dlls/winebus.sys/bus_udev.c
+++ b/dlls/winebus.sys/bus_udev.c
@@ -1646,7 +1646,7 @@ static void udev_add_device(struct udev_device *dev, int fd)
 
     if (desc.vid == 0x28de && desc.pid == 0x11ff && !strcmp(subsystem, "input"))
     {
-        char *env = getenv("PROTON_PREFER_SDL");
+        char *env = getenv("PROTON_USE_SDL");
         if (env && !strcmp(env, "1"))
         {
             TRACE("evdev %s: gnoring steam input virtual controller\n", debugstr_a(devnode));
-- 
2.49.0

From f90fd12e15c3216f144d84ed2fbd39c785648b7b Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Wed, 28 May 2025 22:20:47 -0400
Subject: [PATCH 072/159] HACK: winewayland: Send relative event with absolute
 event.

---
 dlls/winewayland.drv/wayland_pointer.c | 22 ++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  3 +++
 2 files changed, 25 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index cc1941cece2..a306facf287 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -124,6 +124,7 @@ static void pointer_handle_motion_internal(wl_fixed_t sx, wl_fixed_t sy)
     POINT screen;
     struct wayland_surface *surface;
     struct wayland_win_data *data;
+    struct wayland_pointer *pointer = &process_wayland.pointer;
 
     if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
     if (!(data = wayland_win_data_get(hwnd))) return;
@@ -159,6 +160,25 @@ static void pointer_handle_motion_internal(wl_fixed_t sx, wl_fixed_t sy)
           hwnd, wl_fixed_to_double(sx), wl_fixed_to_double(sy),
           (int)screen.x, (int)screen.y);
 
+    if (InterlockedCompareExchange(&pointer->confinement_updated, FALSE, TRUE))
+    {
+        TRACE("Ignoring, confinement was updated recently!\n");
+        pointer->last_x = screen.x;
+        pointer->last_y = screen.y;
+        return;
+    }
+
+    NtUserSendHardwareInput(hwnd, 0, &input, 0);
+
+    input.mi.dx -= pointer->last_x;
+    input.mi.dy -= pointer->last_y;
+    input.mi.dwFlags = MOUSEEVENTF_MOVE;
+
+    TRACE("relative=%d,%d\n", input.mi.dx, input.mi.dy);
+
+    pointer->last_x = screen.x;
+    pointer->last_y = screen.y;
+
     NtUserSendHardwareInput(hwnd, 0, &input, 0);
 }
 
@@ -1038,6 +1058,8 @@ static void wayland_pointer_update_constraint(struct wl_surface *wl_surface,
         pointer->zwp_relative_pointer_v1 = NULL;
         TRACE("Disabling relative motion\n");
     }
+
+    InterlockedExchange(&pointer->confinement_updated, TRUE);
 }
 
 void wayland_pointer_clear_constraint(void)
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index a8e9d35ba02..30de87faf20 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -115,8 +115,11 @@ struct wayland_pointer
     HWND focused_hwnd;
     HWND constraint_hwnd;
     BOOL pending_warp;
+    BOOL confinement_updated;
     uint32_t enter_serial;
     uint32_t button_serial;
+    LONG last_x;
+    LONG last_y;
     struct wayland_cursor cursor;
     double accum_x;
     double accum_y;
-- 
2.49.0

From bdf8f19f3da08d2dd9c8d95b341bf8a631849fca Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Fri, 30 May 2025 11:17:38 -0400
Subject: [PATCH 073/159] winewayland: Update min/max window based on window
 resizability

---
 dlls/winewayland.drv/wayland_surface.c | 70 +++++++++++++++++++-------
 1 file changed, 53 insertions(+), 17 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index e0d89ba7cf6..3d30c37e58a 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -611,6 +611,15 @@ static void wayland_surface_get_rect_in_monitor(struct wayland_surface *surface,
     OffsetRect(rect, -surface->window.rect.left, -surface->window.rect.top);
 }
 
+static BOOL is_window_resizable(struct wayland_surface *surface)
+{
+    DWORD style = NtUserGetWindowLongW(surface->hwnd, GWL_STYLE);
+
+    if (style & WS_THICKFRAME) return TRUE;
+
+    return surface->current.state & WAYLAND_SURFACE_CONFIG_STATE_FULLSCREEN;
+}
+
 /**********************************************************************
  *          wayland_surface_reconfigure_geometry
  *
@@ -662,26 +671,53 @@ static void wayland_surface_reconfigure_geometry(struct wayland_surface *surface
                                         rect.left, rect.top,
                                         rect.right - rect.left,
                                         rect.bottom - rect.top);
-        /* HACK: reset fullscreen state to ensure surface is on correct output */
-        if (surface->current.state & WAYLAND_SURFACE_CONFIG_STATE_FULLSCREEN
-            && wayland_surface_is_toplevel(surface))
+        if (wayland_surface_is_toplevel(surface))
         {
-            struct wl_output *output;
-            pthread_mutex_lock(&process_wayland.output_mutex);
-            output = wayland_get_best_output_for_rect(&surface->window.rect);
-            if (output != surface->wl_output)
+            /* HACK: update min/max size depending on if the window is resizable */
+            if (!is_window_resizable(surface))
             {
-                TRACE("Resetting fullscreen state: output %p surface output %p\n",
-                      output, surface->wl_output);
-                xdg_toplevel_unset_fullscreen(surface->xdg_toplevel);
-                wl_display_flush(process_wayland.wl_display);
-                xdg_toplevel_set_fullscreen(surface->xdg_toplevel, output);
-                /* In case we don't get enter event from compositor
-                   happens on sway for instance
-                */
-                surface->wl_output = output;
+                xdg_toplevel_set_min_size(
+                    surface->xdg_toplevel,
+                    rect.right - rect.left,
+                    rect.bottom - rect.top);
+                xdg_toplevel_set_max_size(
+                    surface->xdg_toplevel,
+                    rect.right - rect.left,
+                    rect.bottom - rect.top
+                );
+            }
+            else
+            {
+                xdg_toplevel_set_min_size(
+                    surface->xdg_toplevel,
+                    0, 0
+                );
+                xdg_toplevel_set_max_size(
+                    surface->xdg_toplevel,
+                    0, 0
+                );
+            }
+
+            /* HACK: reset fullscreen state to ensure surface is on correct output */
+            if (surface->current.state & WAYLAND_SURFACE_CONFIG_STATE_FULLSCREEN)
+            {
+                struct wl_output *output;
+                pthread_mutex_lock(&process_wayland.output_mutex);
+                output = wayland_get_best_output_for_rect(&surface->window.rect);
+                if (output != surface->wl_output)
+                {
+                    TRACE("Resetting fullscreen state: output %p surface output %p\n",
+                        output, surface->wl_output);
+                    xdg_toplevel_unset_fullscreen(surface->xdg_toplevel);
+                    wl_display_flush(process_wayland.wl_display);
+                    xdg_toplevel_set_fullscreen(surface->xdg_toplevel, output);
+                    /* In case we don't get enter event from compositor
+                    happens on sway for instance
+                    */
+                    surface->wl_output = output;
+                }
+                pthread_mutex_unlock(&process_wayland.output_mutex);
             }
-            pthread_mutex_unlock(&process_wayland.output_mutex);
         }
     }
 }
-- 
2.49.0

From b5541c0cb5455df8be19beb8bd1c5995222b1d82 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sun, 1 Jun 2025 09:45:29 -0400
Subject: [PATCH 074/159] winewayland: add opcode 3 of
 zwlr_data_control_device_v1_listener.

---
 dlls/winewayland.drv/wayland_data_device.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index e36c0cc9229..429baa2f2f8 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -585,11 +585,19 @@ static void data_control_device_finished(
 {
 }
 
+static void data_control_device_primary_selection(
+    void *data, struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1,
+    struct zwlr_data_control_offer_v1 *id
+)
+{
+}
+
 static const struct zwlr_data_control_device_v1_listener data_control_device_listener =
 {
     data_control_device_data_offer,
     data_control_device_selection,
     data_control_device_finished,
+    data_control_device_primary_selection
 };
 
 /**********************************************************************
-- 
2.49.0

From 2c47e7ed523cf611b1ac28be324deadd3baee204 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sun, 1 Jun 2025 18:57:16 -0400
Subject: [PATCH 075/159] winewayland: systray skeleton

---
 dlls/winewayland.drv/Makefile.in       |   3 +-
 dlls/winewayland.drv/wayland_tray.c    | 101 +++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |   4 +
 dlls/winewayland.drv/waylanddrv_main.c |   4 +
 4 files changed, 111 insertions(+), 1 deletion(-)
 create mode 100644 dlls/winewayland.drv/wayland_tray.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index fba6b916cee..ca313b8f7e6 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,6 +1,6 @@
 MODULE = winewayland.drv
 UNIXLIB = winewayland.so
-UNIX_CFLAGS = $(EGL_CFLAGS) $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_EGL_CFLAGS) $(XKBCOMMON_CFLAGS) $(XKBREGISTRY_CFLAGS)
+UNIX_CFLAGS = $(EGL_CFLAGS) $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_EGL_CFLAGS) $(XKBCOMMON_CFLAGS) $(XKBREGISTRY_CFLAGS) $(DBUS_CFLAGS)
 UNIX_LIBS = -lwin32u $(WAYLAND_CLIENT_LIBS) $(WAYLAND_EGL_LIBS) $(XKBCOMMON_LIBS) $(XKBREGISTRY_LIBS) $(PTHREAD_LIBS) -lm
 IMPORTS = user32 win32u
 
@@ -25,6 +25,7 @@ SOURCES = \
 	wayland_pointer.c \
 	wayland_surface.c \
 	wayland_text_input.c \
+	wayland_tray.c \
 	waylanddrv_main.c \
 	window.c \
 	window_surface.c \
diff --git a/dlls/winewayland.drv/wayland_tray.c b/dlls/winewayland.drv/wayland_tray.c
new file mode 100644
index 00000000000..93e737c6949
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_tray.c
@@ -0,0 +1,101 @@
+/*
+ * Wayland system tray
+ *
+ * Copyright 2025 Etaash Mathamsetty
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+
+#ifdef SONAME_LIBDBUS_1
+#include <dbus/dbus.h>
+#endif
+
+WINE_DEFAULT_DEBUG_CHANNEL(systray);
+
+
+#ifdef SONAME_LIBDBUS_1
+
+
+void WAYLAND_SystrayDockInit(HWND hwnd)
+{
+    TRACE("hwnd %p\n", hwnd);
+}
+
+void WAYLAND_SystrayDockClear(HWND hwnd)
+{
+    TRACE("hwnd %p\n", hwnd);
+}
+
+BOOL WAYLAND_SystrayDockInsert(HWND hwnd, UINT cx, UINT cy, void *icon)
+{
+    TRACE("hwnd %p (cx, cy)=(%u, %u) icon %p\n", hwnd, cx, cy, icon);
+
+    return FALSE;
+}
+
+BOOL WAYLAND_SystrayDockRemove(HWND hwnd)
+{
+    TRACE("hwnd %p\n", hwnd);
+
+    return FALSE;
+}
+
+#else
+
+static int once;
+
+void WAYLAND_SystrayDockInit(HWND hwnd)
+{
+    if (!once++)
+        ERR("dbus support was not compiled in!\n");
+}
+
+void WAYLAND_SystrayDockClear(HWND hwnd)
+{
+    if (!once++)
+        ERR("dbus support was not compiled in!\n");
+}
+
+BOOL WAYLAND_SystrayDockRemove(HWND hwnd)
+{
+    if (!once++)
+        ERR("dbus support was not compiled in!\n");
+
+    return FALSE;
+}
+
+BOOL WAYLAND_SystrayDockInsert(HWND hwnd, UINT cx, UINT cy, void *icon)
+{
+    if (!once++)
+        ERR("dbus support was not compiled in!\n");
+
+    return FALSE;
+}
+
+#endif
+
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 30de87faf20..29f692a891e 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -500,6 +500,10 @@ void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, HWND owner_hint, UIN
 BOOL WAYLAND_WindowPosChanging(HWND hwnd, UINT swp_flags, BOOL shaped, const struct window_rects *rects);
 BOOL WAYLAND_CreateWindowSurface(HWND hwnd, BOOL layered, const RECT *surface_rect, struct window_surface **surface);
 BOOL WAYLAND_HasWindowManager(const char *name);
+void WAYLAND_SystrayDockInit(HWND hwnd);
+void WAYLAND_SystrayDockClear(HWND hwnd);
+BOOL WAYLAND_SystrayDockRemove(HWND hwnd);
+BOOL WAYLAND_SystrayDockInsert(HWND hwnd, UINT cx, UINT cy, void *icon);
 UINT WAYLAND_VulkanInit(UINT version, void *vulkan_handle, const struct vulkan_driver_funcs **driver_funcs);
 struct opengl_funcs *WAYLAND_wine_get_wgl_driver(UINT version);
 
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 83a60848362..9da551d13b1 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -57,6 +57,10 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pWindowPosChanging = WAYLAND_WindowPosChanging,
     .pCreateWindowSurface = WAYLAND_CreateWindowSurface,
     .pHasWindowManager = WAYLAND_HasWindowManager,
+    .pSystrayDockInit = WAYLAND_SystrayDockInit,
+    .pSystrayDockInsert = WAYLAND_SystrayDockInsert,
+    .pSystrayDockClear = WAYLAND_SystrayDockClear,
+    .pSystrayDockRemove = WAYLAND_SystrayDockRemove,
     .pVulkanInit = WAYLAND_VulkanInit,
     .pwine_get_wgl_driver = WAYLAND_wine_get_wgl_driver,
 };
-- 
2.49.0

From 65b05b7e00b6a049714efebc10131cb1b9ef7365 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sun, 1 Jun 2025 20:42:27 -0400
Subject: [PATCH 076/159] fixup! HACK: winewayland: Send relative event with
 absolute event.

---
 dlls/winewayland.drv/wayland_pointer.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index a306facf287..4dd1fab1c31 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -179,7 +179,7 @@ static void pointer_handle_motion_internal(wl_fixed_t sx, wl_fixed_t sy)
     pointer->last_x = screen.x;
     pointer->last_y = screen.y;
 
-    NtUserSendHardwareInput(hwnd, 0, &input, 0);
+    NtUserSendHardwareInput(hwnd, SEND_HWMSG_NO_MSG, &input, 0);
 }
 
 static void pointer_handle_motion(void *data, struct wl_pointer *wl_pointer,
-- 
2.49.0

From e9ae71bc4dcc4cf3e0165149bfa6d8c6d5b025c8 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Mon, 2 Jun 2025 15:53:52 -0400
Subject: [PATCH 077/159] winewayland: ensure flush when setting fullscreen
 state.

---
 dlls/winewayland.drv/wayland_surface.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 3d30c37e58a..28087412446 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -711,6 +711,7 @@ static void wayland_surface_reconfigure_geometry(struct wayland_surface *surface
                     xdg_toplevel_unset_fullscreen(surface->xdg_toplevel);
                     wl_display_flush(process_wayland.wl_display);
                     xdg_toplevel_set_fullscreen(surface->xdg_toplevel, output);
+                    wl_display_flush(process_wayland.wl_display);
                     /* In case we don't get enter event from compositor
                     happens on sway for instance
                     */
-- 
2.49.0

From 76fc3bd1758af936089123f88cf32d348e517b67 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Mon, 2 Jun 2025 17:45:42 -0400
Subject: [PATCH 078/159] winewayland: Don't scale raw input values.

---
 dlls/winewayland.drv/wayland_pointer.c | 21 +++++++++++++--------
 1 file changed, 13 insertions(+), 8 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 4dd1fab1c31..2d70881982b 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -116,7 +116,7 @@ static HWND wayland_pointer_get_focused_hwnd(void)
     return hwnd;
 }
 
-static void pointer_handle_motion_internal(wl_fixed_t sx, wl_fixed_t sy)
+static void pointer_handle_motion_internal(wl_fixed_t sx, wl_fixed_t sy, uint32_t time)
 {
     INPUT input = {0};
     RECT *window_rect;
@@ -152,6 +152,7 @@ static void pointer_handle_motion_internal(wl_fixed_t sx, wl_fixed_t sy)
     wayland_win_data_release(data);
 
     input.type = INPUT_MOUSE;
+    input.mi.time = time;
     input.mi.dx = screen.x;
     input.mi.dy = screen.y;
     input.mi.dwFlags = MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE;
@@ -190,7 +191,7 @@ static void pointer_handle_motion(void *data, struct wl_pointer *wl_pointer,
     /* Ignore absolute motion events if in relative mode. */
     if (pointer->zwp_relative_pointer_v1) return;
 
-    pointer_handle_motion_internal(sx, sy);
+    pointer_handle_motion_internal(sx, sy, time);
 }
 
 static void wayland_set_cursor(HWND hwnd, HCURSOR hcursor, BOOL use_hcursor);
@@ -223,7 +224,7 @@ static void pointer_handle_enter(void *data, struct wl_pointer *wl_pointer,
     /* Handle the enter as a motion, to account for cases where the
      * window first appears beneath the pointer and won't get a separate
      * motion event. */
-    pointer_handle_motion_internal(sx, sy);
+    pointer_handle_motion_internal(sx, sy, 0);
 }
 
 static void pointer_handle_leave(void *data, struct wl_pointer *wl_pointer,
@@ -410,6 +411,7 @@ static const struct wl_pointer_listener pointer_listener =
  *
  * Converts the surface-local delta to window (logical) coordinate delta.
  */
+/*
 static void wayland_motion_delta_to_window(struct wayland_surface *surface,
                                            double surface_x, double surface_y,
                                            double *window_x, double *window_y)
@@ -417,6 +419,7 @@ static void wayland_motion_delta_to_window(struct wayland_surface *surface,
     *window_x = surface_x * surface->window.scale;
     *window_y = surface_y * surface->window.scale;
 }
+*/
 
 static void relative_pointer_v1_relative_motion(void *private,
                                                 struct zwp_relative_pointer_v1 *zwp_relative_pointer_v1,
@@ -429,15 +432,16 @@ static void relative_pointer_v1_relative_motion(void *private,
     struct wayland_win_data *data;
     double screen_x = 0.0, screen_y = 0.0;
     struct wayland_pointer *pointer = &process_wayland.pointer;
+    ULONG64 time_us = ((ULONG64)utime_hi << 32) | utime_lo;
 
     if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
     if (!(data = wayland_win_data_get(hwnd))) return;
 
-    /* Use "raw" input by default. However, it's not nessessarily raw */
-    wayland_motion_delta_to_window(data->wayland_surface,
-                                   wl_fixed_to_double(dx_unaccel),
-                                   wl_fixed_to_double(dy_unaccel),
-                                   &screen_x, &screen_y);
+    /* Use "raw" input by default. However, it's not nessessarily raw.
+       Additionally, we don't need to scale this value
+    */
+    screen_x = wl_fixed_to_double(dx_unaccel);
+    screen_y = wl_fixed_to_double(dy_unaccel);
     wayland_win_data_release(data);
 
     pthread_mutex_lock(&pointer->mutex);
@@ -446,6 +450,7 @@ static void relative_pointer_v1_relative_motion(void *private,
     pointer->accum_y += screen_y;
 
     input.type = INPUT_MOUSE;
+    input.mi.time = time_us / 1000;
     input.mi.dx = round(pointer->accum_x);
     input.mi.dy = round(pointer->accum_y);
     input.mi.dwFlags = MOUSEEVENTF_MOVE;
-- 
2.49.0

From 274f243f797df4cd0d15ba2b995bc6eaa55133a6 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Mon, 2 Jun 2025 17:45:59 -0400
Subject: [PATCH 079/159] HACK: winewayland: add support for picking primary
 monitor name.

---
 dlls/winewayland.drv/display.c | 29 +++++++++++++++++++++++++++++
 1 file changed, 29 insertions(+)

diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index f1eb6be8e46..bb8f0e03d26 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -162,11 +162,32 @@ static BOOL output_info_array_resolve_overlaps(struct wl_array *output_info_arra
     return found_overlap;
 }
 
+/* Grab offset based on the user specified monitor name */
+static void get_user_named_offset(int* x, int *y, struct wl_array* output_info_array)
+{
+    struct output_info *info = NULL;
+    char *env = getenv("WAYLANDDRV_PRIMARY_MONITOR");
+    *x = *y = 0;
+
+    if (!env) return;
+
+    wl_array_for_each(info, output_info_array)
+    {
+        if (!strcmp(info->output->name, env))
+        {
+            *x = info->x;
+            *y = info->y;
+            break;
+        }
+    }
+}
+
 static void output_info_array_arrange_physical_coords(struct wl_array *output_info_array)
 {
     struct output_info *info;
     size_t num_outputs = output_info_array->size / sizeof(struct output_info);
     int steps = 0;
+    int x_offset, y_offset;
 
     /* Set the initial physical pixel coordinates. */
     wl_array_for_each(info, output_info_array)
@@ -181,6 +202,14 @@ static void output_info_array_arrange_physical_coords(struct wl_array *output_in
            ++steps < num_outputs)
         continue;
 
+    get_user_named_offset(&x_offset, &y_offset, output_info_array);
+
+    wl_array_for_each(info, output_info_array)
+    {
+        info->x -= x_offset;
+        info->y -= y_offset;
+    }
+
     /* Now that we have our physical pixel coordinates, sort from physical left
      * to right, but ensure the primary output is first. */
     qsort(output_info_array->data, num_outputs, sizeof(struct output_info),
-- 
2.49.0

From e2b78c7b567dba9898805cb5c1299aac0199d7a3 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Mon, 2 Jun 2025 20:52:50 -0400
Subject: [PATCH 080/159] fixup! winewayland: emulate edid data.

---
 dlls/winewayland.drv/display.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index bb8f0e03d26..a3ec54a2a6a 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -273,6 +273,8 @@ static UINT get_edid(const struct output_info *output_info, unsigned char **data
     data[33] = (primaries->w_x & 0x3fc) >> 2;
     data[34] = (primaries->w_y & 0x3fc) >> 2;
 
+    for (i = 0; i < 16; ++i) data[38 + i] = 1;
+
     p = data + 54;
 
     *(uint16_t*)&p[0] = 0x0; /* 0 = reserved */
-- 
2.49.0

From b165b36ce9b1c06c8a38eaec29c53d882b6fcc29 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Tue, 3 Jun 2025 18:49:14 -0400
Subject: [PATCH 081/159] winewayland: round relative pointer timestamp

---
 dlls/winewayland.drv/wayland_pointer.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 2d70881982b..7668e74439a 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -450,7 +450,7 @@ static void relative_pointer_v1_relative_motion(void *private,
     pointer->accum_y += screen_y;
 
     input.type = INPUT_MOUSE;
-    input.mi.time = time_us / 1000;
+    input.mi.time = round(time_us / 1000.0);
     input.mi.dx = round(pointer->accum_x);
     input.mi.dy = round(pointer->accum_y);
     input.mi.dwFlags = MOUSEEVENTF_MOVE;
-- 
2.49.0

From be0a20666d21580041c895281a35be429cb787dc Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Tue, 3 Jun 2025 18:53:52 -0400
Subject: [PATCH 082/159] winebus: Allow disabling steam input seperately

---
 dlls/winebus.sys/bus_udev.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winebus.sys/bus_udev.c b/dlls/winebus.sys/bus_udev.c
index 9c992d84a64..41d91d12eac 100644
--- a/dlls/winebus.sys/bus_udev.c
+++ b/dlls/winebus.sys/bus_udev.c
@@ -1646,7 +1646,7 @@ static void udev_add_device(struct udev_device *dev, int fd)
 
     if (desc.vid == 0x28de && desc.pid == 0x11ff && !strcmp(subsystem, "input"))
     {
-        char *env = getenv("PROTON_USE_SDL");
+        char *env = getenv("PROTON_NO_STEAMINPUT");
         if (env && !strcmp(env, "1"))
         {
             TRACE("evdev %s: gnoring steam input virtual controller\n", debugstr_a(devnode));
-- 
2.49.0

From 4aab70aa256f537d1eda539dd4779d0305276c97 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Wed, 4 Jun 2025 11:22:31 -0400
Subject: [PATCH 083/159] winegstreamer: disable media converter

---
 dlls/winegstreamer/unixlib.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/dlls/winegstreamer/unixlib.c b/dlls/winegstreamer/unixlib.c
index cd631535b50..45db94778aa 100644
--- a/dlls/winegstreamer/unixlib.c
+++ b/dlls/winegstreamer/unixlib.c
@@ -343,11 +343,14 @@ NTSTATUS wg_init_gstreamer(void *arg)
         }
     }
 
+/*
+ *  don't enable media converter in these builds since we enable all codecs
     if (!media_converter_init())
     {
         GST_ERROR("Failed to init media converter.");
         return STATUS_UNSUCCESSFUL;
     }
+*/
 
     if (!GST_ELEMENT_REGISTER(winegstreamerstepper, NULL))
         GST_ERROR("Failed to register the stepper element");
-- 
2.49.0

From 4488a5c9a6f66e9b7ea305493e8d75f9419fdce8 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Wed, 4 Jun 2025 21:55:27 -0400
Subject: [PATCH 084/159] winegstreamer: Add env to enable media converter.

---
 dlls/winegstreamer/unixlib.c | 11 ++++++-----
 1 file changed, 6 insertions(+), 5 deletions(-)

diff --git a/dlls/winegstreamer/unixlib.c b/dlls/winegstreamer/unixlib.c
index 45db94778aa..cedd411eef0 100644
--- a/dlls/winegstreamer/unixlib.c
+++ b/dlls/winegstreamer/unixlib.c
@@ -267,7 +267,7 @@ NTSTATUS wg_init_gstreamer(void *arg)
     char *args[] = {arg0, arg1, NULL};
     int argc = ARRAY_SIZE(args) - 1;
     char **argv = args;
-    const char *e;
+    const char *e, *env;
     GError *err;
     DWORD_PTR process_mask;
 
@@ -343,14 +343,15 @@ NTSTATUS wg_init_gstreamer(void *arg)
         }
     }
 
-/*
- *  don't enable media converter in these builds since we enable all codecs
-    if (!media_converter_init())
+    env = getenv("PROTON_ENABLE_MEDIACONV");
+
+    /*  don't enable media converter by default since we enable all codecs */
+    if (env && !strcmp(env, "1") && !media_converter_init())
     {
         GST_ERROR("Failed to init media converter.");
         return STATUS_UNSUCCESSFUL;
     }
-*/
+
 
     if (!GST_ELEMENT_REGISTER(winegstreamerstepper, NULL))
         GST_ERROR("Failed to register the stepper element");
-- 
2.49.0

From d79d0be511f2bccd119acfff91df031a8f9eb313 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Thu, 5 Jun 2025 20:38:17 -0400
Subject: [PATCH 085/159] winewayland: Send no raw with normal pointer events.

matches winex11 behavior
---
 dlls/winewayland.drv/wayland_pointer.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 7668e74439a..900b3f1708a 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -169,7 +169,7 @@ static void pointer_handle_motion_internal(wl_fixed_t sx, wl_fixed_t sy, uint32_
         return;
     }
 
-    NtUserSendHardwareInput(hwnd, 0, &input, 0);
+    NtUserSendHardwareInput(hwnd, SEND_HWMSG_NO_RAW, &input, 0);
 
     input.mi.dx -= pointer->last_x;
     input.mi.dy -= pointer->last_y;
-- 
2.49.0

From f34580cc591afc0e643c451a5239862e4bf35b09 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sat, 7 Jun 2025 22:49:21 -0400
Subject: [PATCH 086/159] winewayland: Allow disabling rawinput through env

---
 dlls/winewayland.drv/wayland_pointer.c | 36 ++++++++++++++++++++++----
 1 file changed, 31 insertions(+), 5 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 900b3f1708a..0df5e2dcd7c 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -411,7 +411,6 @@ static const struct wl_pointer_listener pointer_listener =
  *
  * Converts the surface-local delta to window (logical) coordinate delta.
  */
-/*
 static void wayland_motion_delta_to_window(struct wayland_surface *surface,
                                            double surface_x, double surface_y,
                                            double *window_x, double *window_y)
@@ -419,7 +418,25 @@ static void wayland_motion_delta_to_window(struct wayland_surface *surface,
     *window_x = surface_x * surface->window.scale;
     *window_y = surface_y * surface->window.scale;
 }
-*/
+
+/* Some compositors seem to have broken rawinput so allow users to disable */
+static BOOL is_rawinput_disabled(void)
+{
+    static int cached;
+    const char *env;
+
+    if (cached) return cached - 1;
+
+    env = getenv("WAYLANDDRV_RAWINPUT");
+    cached = 1;
+
+    if (env && !strcmp(env, "0"))
+    {
+        cached = 2;
+    }
+
+    return cached - 1;
+}
 
 static void relative_pointer_v1_relative_motion(void *private,
                                                 struct zwp_relative_pointer_v1 *zwp_relative_pointer_v1,
@@ -440,8 +457,17 @@ static void relative_pointer_v1_relative_motion(void *private,
     /* Use "raw" input by default. However, it's not nessessarily raw.
        Additionally, we don't need to scale this value
     */
-    screen_x = wl_fixed_to_double(dx_unaccel);
-    screen_y = wl_fixed_to_double(dy_unaccel);
+    if (!is_rawinput_disabled())
+    {
+        screen_x = wl_fixed_to_double(dx_unaccel);
+        screen_y = wl_fixed_to_double(dy_unaccel);
+    } else {
+        wayland_motion_delta_to_window(data->wayland_surface,
+                                       wl_fixed_to_double(dx),
+                                       wl_fixed_to_double(dy),
+                                       &screen_x, &screen_y);
+    }
+
     wayland_win_data_release(data);
 
     pthread_mutex_lock(&pointer->mutex);
@@ -461,7 +487,7 @@ static void relative_pointer_v1_relative_motion(void *private,
     pthread_mutex_unlock(&pointer->mutex);
 
     TRACE("hwnd=%p wayland_dxdy=%.2f,%.2f accum_dxdy=%d,%d\n",
-          hwnd, wl_fixed_to_double(dx_unaccel), wl_fixed_to_double(dy_unaccel),
+          hwnd, screen_x, screen_y,
           (int)input.mi.dx, (int)input.mi.dy);
 
     NtUserSendHardwareInput(hwnd, 0, &input, 0);
-- 
2.49.0

From 105db7f9aad2e6c114797f91f40b7508a46f7b2c Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sat, 7 Jun 2025 22:52:48 -0400
Subject: [PATCH 087/159] fixup! winebus: Allow disabling steam input
 seperately

---
 dlls/winebus.sys/bus_udev.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winebus.sys/bus_udev.c b/dlls/winebus.sys/bus_udev.c
index 41d91d12eac..4a763f72da2 100644
--- a/dlls/winebus.sys/bus_udev.c
+++ b/dlls/winebus.sys/bus_udev.c
@@ -1649,7 +1649,7 @@ static void udev_add_device(struct udev_device *dev, int fd)
         char *env = getenv("PROTON_NO_STEAMINPUT");
         if (env && !strcmp(env, "1"))
         {
-            TRACE("evdev %s: gnoring steam input virtual controller\n", debugstr_a(devnode));
+            TRACE("evdev %s: ignoring steam input virtual controller\n", debugstr_a(devnode));
             close(fd);
             return;
         }
-- 
2.49.0

From 8c0155490c3b928aaca47d5b006060cd2ef6793a Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sat, 7 Jun 2025 22:55:02 -0400
Subject: [PATCH 088/159] fixup! HACK: winewayland: add support for picking
 primary monitor name.

---
 dlls/winewayland.drv/display.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index a3ec54a2a6a..60768fd620b 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -163,7 +163,7 @@ static BOOL output_info_array_resolve_overlaps(struct wl_array *output_info_arra
 }
 
 /* Grab offset based on the user specified monitor name */
-static void get_user_named_offset(int* x, int *y, struct wl_array* output_info_array)
+static void get_user_named_offset(struct wl_array *output_info_array, int *x, int *y)
 {
     struct output_info *info = NULL;
     char *env = getenv("WAYLANDDRV_PRIMARY_MONITOR");
@@ -202,7 +202,7 @@ static void output_info_array_arrange_physical_coords(struct wl_array *output_in
            ++steps < num_outputs)
         continue;
 
-    get_user_named_offset(&x_offset, &y_offset, output_info_array);
+    get_user_named_offset(output_info_array, &x_offset, &y_offset);
 
     wl_array_for_each(info, output_info_array)
     {
-- 
2.49.0

From 38134a23182d82a945052ca6c2e14c9906d10fd2 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sat, 7 Jun 2025 23:32:42 -0400
Subject: [PATCH 089/159] fixup! winewayland: add missing locking to pointer
 updates

will be needed soon... i think
---
 dlls/winewayland.drv/wayland_pointer.c | 26 ++++++++++++++++++++++----
 1 file changed, 22 insertions(+), 4 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 0df5e2dcd7c..09cc289e8f8 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -161,24 +161,30 @@ static void pointer_handle_motion_internal(wl_fixed_t sx, wl_fixed_t sy, uint32_
           hwnd, wl_fixed_to_double(sx), wl_fixed_to_double(sy),
           (int)screen.x, (int)screen.y);
 
-    if (InterlockedCompareExchange(&pointer->confinement_updated, FALSE, TRUE))
+    /* ignore when time = 0 since we need to store the initial position upon enter */
+    if (InterlockedCompareExchange(&pointer->confinement_updated, FALSE, TRUE) || !time)
     {
-        TRACE("Ignoring, confinement was updated recently!\n");
+        if (time) TRACE("Ignoring, confinement was updated recently!\n");
+        else NtUserSendHardwareInput(hwnd, SEND_HWMSG_NO_RAW, &input, 0);
+        pthread_mutex_lock(&pointer->mutex);
         pointer->last_x = screen.x;
         pointer->last_y = screen.y;
+        pthread_mutex_unlock(&pointer->mutex);
         return;
     }
 
     NtUserSendHardwareInput(hwnd, SEND_HWMSG_NO_RAW, &input, 0);
 
+    pthread_mutex_lock(&pointer->mutex);
     input.mi.dx -= pointer->last_x;
     input.mi.dy -= pointer->last_y;
     input.mi.dwFlags = MOUSEEVENTF_MOVE;
 
-    TRACE("relative=%d,%d\n", input.mi.dx, input.mi.dy);
-
     pointer->last_x = screen.x;
     pointer->last_y = screen.y;
+    pthread_mutex_unlock(&pointer->mutex);
+
+    TRACE("relative=%d,%d\n", input.mi.dx, input.mi.dy);
 
     NtUserSendHardwareInput(hwnd, SEND_HWMSG_NO_MSG, &input, 0);
 }
@@ -316,6 +322,8 @@ static void pointer_handle_axis(void *data, struct wl_pointer *wl_pointer,
 
     input.type = INPUT_MOUSE;
 
+    pthread_mutex_lock(&pointer->mutex);
+
     /*
         Truncation makes the most sense:
         Imagine a infinite resolution scroll wheel
@@ -342,14 +350,24 @@ static void pointer_handle_axis(void *data, struct wl_pointer *wl_pointer,
         default: break;
     }
 
+    pthread_mutex_unlock(&pointer->mutex);
+
     TRACE("hwnd=%p axis=%u value=%lf out=%d\n", hwnd, axis, scroll_value, (int)input.mi.mouseData);
 
     if (input.mi.mouseData)
         NtUserSendHardwareInput(hwnd, 0, &input, 0);
 }
 
+/* TODO: move hardware input logic into the pointer frame (only for pointers)
+         maybe for future upstream implementation we can move everything?
+*/
 static void pointer_handle_frame(void *data, struct wl_pointer *wl_pointer)
 {
+    HWND hwnd;
+
+    if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
+
+    TRACE("hwnd=%p\n", hwnd);
 }
 
 static void pointer_handle_axis_source(void *data, struct wl_pointer *wl_pointer,
-- 
2.49.0

From 901de6d5c33767760e0fb546439099614e7338cb Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sun, 8 Jun 2025 13:14:24 -0400
Subject: [PATCH 090/159] winewayland: Rewrite wayland pointer implementation.

---
 dlls/winewayland.drv/wayland_pointer.c | 287 +++++++++++++++----------
 dlls/winewayland.drv/waylanddrv.h      |  32 ++-
 2 files changed, 203 insertions(+), 116 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 09cc289e8f8..b67da1c4fa2 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -116,9 +116,8 @@ static HWND wayland_pointer_get_focused_hwnd(void)
     return hwnd;
 }
 
-static void pointer_handle_motion_internal(wl_fixed_t sx, wl_fixed_t sy, uint32_t time)
+static void pointer_handle_motion_internal(wl_fixed_t sx, wl_fixed_t sy)
 {
-    INPUT input = {0};
     RECT *window_rect;
     HWND hwnd;
     POINT screen;
@@ -151,42 +150,18 @@ static void pointer_handle_motion_internal(wl_fixed_t sx, wl_fixed_t sy, uint32_
 
     wayland_win_data_release(data);
 
-    input.type = INPUT_MOUSE;
-    input.mi.time = time;
-    input.mi.dx = screen.x;
-    input.mi.dy = screen.y;
-    input.mi.dwFlags = MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE;
+    pthread_mutex_lock(&pointer->mutex);
 
-    TRACE("hwnd=%p wayland_xy=%.2f,%.2f screen_xy=%d,%d\n",
-          hwnd, wl_fixed_to_double(sx), wl_fixed_to_double(sy),
-          (int)screen.x, (int)screen.y);
+    pointer->pointer_frame.x = screen.x;
+    pointer->pointer_frame.y = screen.y;
 
-    /* ignore when time = 0 since we need to store the initial position upon enter */
-    if (InterlockedCompareExchange(&pointer->confinement_updated, FALSE, TRUE) || !time)
-    {
-        if (time) TRACE("Ignoring, confinement was updated recently!\n");
-        else NtUserSendHardwareInput(hwnd, SEND_HWMSG_NO_RAW, &input, 0);
-        pthread_mutex_lock(&pointer->mutex);
-        pointer->last_x = screen.x;
-        pointer->last_y = screen.y;
-        pthread_mutex_unlock(&pointer->mutex);
-        return;
-    }
+    pointer->pointer_frame.flags |= WAYLAND_POINTER_FRAME_ABS;
 
-    NtUserSendHardwareInput(hwnd, SEND_HWMSG_NO_RAW, &input, 0);
-
-    pthread_mutex_lock(&pointer->mutex);
-    input.mi.dx -= pointer->last_x;
-    input.mi.dy -= pointer->last_y;
-    input.mi.dwFlags = MOUSEEVENTF_MOVE;
-
-    pointer->last_x = screen.x;
-    pointer->last_y = screen.y;
     pthread_mutex_unlock(&pointer->mutex);
 
-    TRACE("relative=%d,%d\n", input.mi.dx, input.mi.dy);
-
-    NtUserSendHardwareInput(hwnd, SEND_HWMSG_NO_MSG, &input, 0);
+    TRACE("hwnd=%p wayland_xy=%.2f,%.2f screen_xy=%d,%d\n",
+                 hwnd, wl_fixed_to_double(sx), wl_fixed_to_double(sy),
+                 (int)screen.x, (int)screen.y);
 }
 
 static void pointer_handle_motion(void *data, struct wl_pointer *wl_pointer,
@@ -195,9 +170,9 @@ static void pointer_handle_motion(void *data, struct wl_pointer *wl_pointer,
     struct wayland_pointer *pointer = &process_wayland.pointer;
 
     /* Ignore absolute motion events if in relative mode. */
-    if (pointer->zwp_relative_pointer_v1) return;
+    if (pointer->relative_only) return;
 
-    pointer_handle_motion_internal(sx, sy, time);
+    pointer_handle_motion_internal(sx, sy);
 }
 
 static void wayland_set_cursor(HWND hwnd, HCURSOR hcursor, BOOL use_hcursor);
@@ -221,6 +196,13 @@ static void pointer_handle_enter(void *data, struct wl_pointer *wl_pointer,
     pthread_mutex_lock(&pointer->mutex);
     pointer->focused_hwnd = hwnd;
     pointer->enter_serial = serial;
+    /* reset all accumulators */
+    pointer->pointer_frame.dx = 0;
+    pointer->pointer_frame.dy = 0;
+    pointer->pointer_frame.dx_unaccel = 0;
+    pointer->pointer_frame.dy_unaccel = 0;
+    pointer->pointer_frame.wheel = 0;
+    pointer->pointer_frame.wheelH = 0;
     pthread_mutex_unlock(&pointer->mutex);
 
     /* The cursor is undefined at every enter, so we set it again with
@@ -230,7 +212,7 @@ static void pointer_handle_enter(void *data, struct wl_pointer *wl_pointer,
     /* Handle the enter as a motion, to account for cases where the
      * window first appears beneath the pointer and won't get a separate
      * motion event. */
-    pointer_handle_motion_internal(sx, sy, 0);
+    pointer_handle_motion_internal(sx, sy);
 }
 
 static void pointer_handle_leave(void *data, struct wl_pointer *wl_pointer,
@@ -298,7 +280,6 @@ static void pointer_handle_axis(void *data, struct wl_pointer *wl_pointer,
                                 uint32_t time, uint32_t axis, wl_fixed_t value)
 {
     HWND hwnd;
-    INPUT input = {0};
     /*
         We are given a distance in the surface local coordinate system.
         However, we need to convert that into a WHEEL_DELTA which represents
@@ -318,9 +299,7 @@ static void pointer_handle_axis(void *data, struct wl_pointer *wl_pointer,
     struct wayland_pointer *pointer = &process_wayland.pointer;
 
     if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
-    if (InterlockedCompareExchange(&pointer->discrete_event_handled, FALSE, TRUE)) return;
-
-    input.type = INPUT_MOUSE;
+    if (InterlockedCompareExchange(&pointer->pointer_frame.discrete_event_handled, FALSE, TRUE)) return;
 
     pthread_mutex_lock(&pointer->mutex);
 
@@ -336,38 +315,108 @@ static void pointer_handle_axis(void *data, struct wl_pointer *wl_pointer,
     switch (axis)
     {
         case WL_POINTER_AXIS_VERTICAL_SCROLL:
-            input.mi.dwFlags = MOUSEEVENTF_WHEEL;
-            pointer->accum_wheel += -scroll_value;
-            input.mi.mouseData = trunc(pointer->accum_wheel / WHEEL_DELTA) * WHEEL_DELTA;
-            pointer->accum_wheel -= (int)input.mi.mouseData;
+            pointer->pointer_frame.wheel -= scroll_value;
+            pointer->pointer_frame.flags |= WAYLAND_POINTER_FRAME_WHEEL;
             break;
         case WL_POINTER_AXIS_HORIZONTAL_SCROLL:
-            input.mi.dwFlags = MOUSEEVENTF_HWHEEL;
-            pointer->accum_wheelH += scroll_value;
-            input.mi.mouseData = trunc(pointer->accum_wheelH / WHEEL_DELTA) * WHEEL_DELTA;
-            pointer->accum_wheelH -= (int)input.mi.mouseData;
+            pointer->pointer_frame.wheel += scroll_value;
+            pointer->pointer_frame.flags |= WAYLAND_POINTER_FRAME_WHEELH;
             break;
         default: break;
     }
 
     pthread_mutex_unlock(&pointer->mutex);
 
-    TRACE("hwnd=%p axis=%u value=%lf out=%d\n", hwnd, axis, scroll_value, (int)input.mi.mouseData);
-
-    if (input.mi.mouseData)
-        NtUserSendHardwareInput(hwnd, 0, &input, 0);
+    TRACE("hwnd=%p axis=%u value=%.2f\n", hwnd, axis, scroll_value);
 }
 
-/* TODO: move hardware input logic into the pointer frame (only for pointers)
-         maybe for future upstream implementation we can move everything?
-*/
+/* FIXME: do we want to handle buttons here? */
 static void pointer_handle_frame(void *data, struct wl_pointer *wl_pointer)
 {
     HWND hwnd;
+    INPUT input = {0};
+    struct wayland_pointer *pointer = &process_wayland.pointer;
 
     if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
+    /* Drop the frame if the confinement was updated recently */
+    if (InterlockedCompareExchange(&pointer->confinement_updated, FALSE, TRUE))
+    {
+        TRACE("confinement updated! dropping pointer frame!\n");
+        return;
+    }
 
     TRACE("hwnd=%p\n", hwnd);
+
+    pthread_mutex_lock(&pointer->mutex);
+
+    input.type = INPUT_MOUSE;
+
+    if (pointer->pointer_frame.flags & WAYLAND_POINTER_FRAME_ABS)
+    {
+        input.mi.dx = pointer->pointer_frame.x;
+        input.mi.dy = pointer->pointer_frame.y;
+        input.mi.dwFlags = MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE;
+        NtUserSendHardwareInput(hwnd, SEND_HWMSG_NO_RAW, &input, 0);
+
+        if (pointer->pointer_frame.flags & WAYLAND_POINTER_FRAME_REL)
+        {
+            input.mi.dx = round(pointer->pointer_frame.dx);
+            input.mi.dy = round(pointer->pointer_frame.dy);
+            pointer->pointer_frame.dx -= input.mi.dx;
+            pointer->pointer_frame.dy -= input.mi.dy;
+            pointer->pointer_frame.dx_unaccel
+                -= round(pointer->pointer_frame.dx_unaccel);
+            pointer->pointer_frame.dy_unaccel
+                -= round(pointer->pointer_frame.dy_unaccel);
+            input.mi.dwFlags = MOUSEEVENTF_MOVE;
+            NtUserSendHardwareInput(hwnd, SEND_HWMSG_NO_MSG, &input, 0);
+        }
+    } else if (pointer->pointer_frame.flags & WAYLAND_POINTER_FRAME_REL) {
+        /* HACK: use raw input when there is only relative motion */
+        input.mi.dx = round(pointer->pointer_frame.dx_unaccel);
+        input.mi.dy = round(pointer->pointer_frame.dy_unaccel);
+        pointer->pointer_frame.dx_unaccel -= input.mi.dx;
+        pointer->pointer_frame.dy_unaccel -= input.mi.dy;
+        pointer->pointer_frame.dx -= round(pointer->pointer_frame.dx);
+        pointer->pointer_frame.dy -= round(pointer->pointer_frame.dy);
+        input.mi.dwFlags = MOUSEEVENTF_MOVE;
+        NtUserSendHardwareInput(hwnd, 0, &input, 0); /* FIXME: flags ? */
+    }
+
+    /* zero these values just in case */
+    input.mi.dx = 0;
+    input.mi.dy = 0;
+
+    if (pointer->pointer_frame.flags & WAYLAND_POINTER_FRAME_WHEEL)
+    {
+        input.mi.mouseData = trunc(pointer->pointer_frame.wheel / WHEEL_DELTA) * WHEEL_DELTA;
+        pointer->pointer_frame.wheel -= (int)input.mi.mouseData;
+        input.mi.dwFlags = MOUSEEVENTF_WHEEL;
+        if (input.mi.mouseData)
+            NtUserSendHardwareInput(hwnd, 0, &input, 0);
+    }
+
+    if (pointer->pointer_frame.flags & WAYLAND_POINTER_FRAME_WHEELH)
+    {
+        input.mi.mouseData = trunc(pointer->pointer_frame.wheelH / WHEEL_DELTA) * WHEEL_DELTA;
+        pointer->pointer_frame.wheelH -= (int)input.mi.mouseData;
+        input.mi.dwFlags = MOUSEEVENTF_HWHEEL;
+        if (input.mi.mouseData)
+            NtUserSendHardwareInput(hwnd, 0, &input, 0);
+    }
+
+    /* reset accumulators when scroll event ends */
+    if (pointer->pointer_frame.axis_stop & WAYLAND_POINTER_AXIS_STOP_VERTICAL)
+        pointer->pointer_frame.wheel = 0;
+    if (pointer->pointer_frame.axis_stop & WAYLAND_POINTER_AXIS_STOP_HORIZONTAL)
+        pointer->pointer_frame.wheelH = 0;
+
+    /* reset flags */
+    pointer->pointer_frame.flags = 0;
+    pointer->pointer_frame.axis_stop = 0;
+    InterlockedExchange(&pointer->pointer_frame.discrete_event_handled, FALSE);
+
+    pthread_mutex_unlock(&pointer->mutex);
 }
 
 static void pointer_handle_axis_source(void *data, struct wl_pointer *wl_pointer,
@@ -378,37 +427,51 @@ static void pointer_handle_axis_source(void *data, struct wl_pointer *wl_pointer
 static void pointer_handle_axis_stop(void *data, struct wl_pointer *wl_pointer,
                                      uint32_t time, uint32_t axis)
 {
+    HWND hwnd;
+    struct wayland_pointer *pointer = &process_wayland.pointer;
+
+    if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
+
+    pthread_mutex_lock(&pointer->mutex);
+
+    if (axis == WL_POINTER_AXIS_VERTICAL_SCROLL)
+        pointer->pointer_frame.axis_stop |= WAYLAND_POINTER_AXIS_STOP_VERTICAL;
+    if (axis == WL_POINTER_AXIS_HORIZONTAL_SCROLL)
+        pointer->pointer_frame.axis_stop |= WAYLAND_POINTER_AXIS_STOP_HORIZONTAL;
+
+    pthread_mutex_unlock(&pointer->mutex);
+
+    TRACE("hwnd=%p axis=%u\n", hwnd, axis);
 }
 
 static void pointer_handle_axis_discrete(void *data, struct wl_pointer *wl_pointer,
                                          uint32_t axis, int32_t discrete)
 {
-    INPUT input = {0};
     HWND hwnd;
     struct wayland_pointer *pointer = &process_wayland.pointer;
 
     if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
 
-    InterlockedExchange(&pointer->discrete_event_handled, TRUE);
+    InterlockedExchange(&pointer->pointer_frame.discrete_event_handled, TRUE);
 
-    input.type = INPUT_MOUSE;
+    pthread_mutex_lock(&pointer->mutex);
 
     switch (axis)
     {
         case WL_POINTER_AXIS_VERTICAL_SCROLL:
-            input.mi.dwFlags = MOUSEEVENTF_WHEEL;
-            input.mi.mouseData = -WHEEL_DELTA * discrete;
+            pointer->pointer_frame.wheel = -WHEEL_DELTA * discrete;
+            pointer->pointer_frame.flags |= WAYLAND_POINTER_FRAME_WHEEL;
             break;
         case WL_POINTER_AXIS_HORIZONTAL_SCROLL:
-            input.mi.dwFlags = MOUSEEVENTF_HWHEEL;
-            input.mi.mouseData = WHEEL_DELTA * discrete;
+            pointer->pointer_frame.wheelH = WHEEL_DELTA * discrete;
+            pointer->pointer_frame.flags |= WAYLAND_POINTER_FRAME_WHEELH;
             break;
         default: break;
     }
 
-    TRACE("hwnd=%p axis=%u discrete=%d\n", hwnd, axis, discrete);
+    pthread_mutex_unlock(&pointer->mutex);
 
-    NtUserSendHardwareInput(hwnd, 0, &input, 0);
+    TRACE("hwnd=%p axis=%u discrete=%d\n", hwnd, axis, discrete);
 }
 
 static const struct wl_pointer_listener pointer_listener =
@@ -462,53 +525,46 @@ static void relative_pointer_v1_relative_motion(void *private,
                                                 wl_fixed_t dx, wl_fixed_t dy,
                                                 wl_fixed_t dx_unaccel, wl_fixed_t dy_unaccel)
 {
-    INPUT input = {0};
     HWND hwnd;
     struct wayland_win_data *data;
-    double screen_x = 0.0, screen_y = 0.0;
+    double f_dx = 0.0, f_dy = 0.0, f_dxu = 0.0, f_dyu = 0.0;
     struct wayland_pointer *pointer = &process_wayland.pointer;
-    ULONG64 time_us = ((ULONG64)utime_hi << 32) | utime_lo;
 
     if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
     if (!(data = wayland_win_data_get(hwnd))) return;
 
-    /* Use "raw" input by default. However, it's not nessessarily raw.
-       Additionally, we don't need to scale this value
-    */
-    if (!is_rawinput_disabled())
-    {
-        screen_x = wl_fixed_to_double(dx_unaccel);
-        screen_y = wl_fixed_to_double(dy_unaccel);
-    } else {
-        wayland_motion_delta_to_window(data->wayland_surface,
-                                       wl_fixed_to_double(dx),
-                                       wl_fixed_to_double(dy),
-                                       &screen_x, &screen_y);
-    }
+    f_dxu = wl_fixed_to_double(dx_unaccel);
+    f_dyu = wl_fixed_to_double(dy_unaccel);
+    wayland_motion_delta_to_window(data->wayland_surface,
+                                   wl_fixed_to_double(dx),
+                                   wl_fixed_to_double(dy),
+                                   &f_dx, &f_dy);
 
     wayland_win_data_release(data);
 
     pthread_mutex_lock(&pointer->mutex);
 
-    pointer->accum_x += screen_x;
-    pointer->accum_y += screen_y;
+    pointer->pointer_frame.dx_unaccel += f_dxu;
+    pointer->pointer_frame.dy_unaccel += f_dyu;
+    pointer->pointer_frame.dx += f_dx;
+    pointer->pointer_frame.dy += f_dy;
 
-    input.type = INPUT_MOUSE;
-    input.mi.time = round(time_us / 1000.0);
-    input.mi.dx = round(pointer->accum_x);
-    input.mi.dy = round(pointer->accum_y);
-    input.mi.dwFlags = MOUSEEVENTF_MOVE;
-
-    pointer->accum_x -= input.mi.dx;
-    pointer->accum_y -= input.mi.dy;
+    if (is_rawinput_disabled())
+    {
+        pointer->pointer_frame.dx_unaccel = pointer->pointer_frame.dx;
+        pointer->pointer_frame.dy_unaccel = pointer->pointer_frame.dy;
+    }
 
-    pthread_mutex_unlock(&pointer->mutex);
+    pointer->pointer_frame.flags |= WAYLAND_POINTER_FRAME_REL;
 
-    TRACE("hwnd=%p wayland_dxdy=%.2f,%.2f accum_dxdy=%d,%d\n",
-          hwnd, screen_x, screen_y,
-          (int)input.mi.dx, (int)input.mi.dy);
+    TRACE("hwnd=%p dxdy=%.2f,%.2f dxdy_raw=%.2f,%.2f\n",
+          hwnd,
+          pointer->pointer_frame.dx,
+          pointer->pointer_frame.dy,
+          pointer->pointer_frame.dx_unaccel,
+          pointer->pointer_frame.dy_unaccel);
 
-    NtUserSendHardwareInput(hwnd, 0, &input, 0);
+    pthread_mutex_unlock(&pointer->mutex);
 }
 
 static const struct zwp_relative_pointer_v1_listener relative_pointer_v1_listener =
@@ -524,8 +580,24 @@ void wayland_pointer_init(struct wl_pointer *wl_pointer)
     pointer->wl_pointer = wl_pointer;
     pointer->focused_hwnd = NULL;
     pointer->enter_serial = 0;
+    memset(&pointer->pointer_frame, 0, sizeof(pointer->pointer_frame));
     pthread_mutex_unlock(&pointer->mutex);
     wl_pointer_add_listener(pointer->wl_pointer, &pointer_listener, NULL);
+
+    /* Always enable relative pointer */
+    if (process_wayland.zwp_relative_pointer_manager_v1)
+    {
+        pointer->zwp_relative_pointer_v1 =
+            zwp_relative_pointer_manager_v1_get_relative_pointer(
+            process_wayland.zwp_relative_pointer_manager_v1,
+            pointer->wl_pointer);
+
+            zwp_relative_pointer_v1_add_listener(
+            pointer->zwp_relative_pointer_v1,
+            &relative_pointer_v1_listener,
+            NULL
+        );
+    }
 }
 
 void wayland_pointer_deinit(void)
@@ -1090,24 +1162,21 @@ static void wayland_pointer_update_constraint(struct wl_surface *wl_surface,
     needs_relative = !is_visible && pointer->constraint_hwnd &&
                      pointer->constraint_hwnd == pointer->focused_hwnd;
 
-    if (needs_relative && !pointer->zwp_relative_pointer_v1)
+    if (needs_relative && !pointer->relative_only)
     {
-        pointer->accum_x = pointer->accum_y = 0;
-        pointer->zwp_relative_pointer_v1 =
-            zwp_relative_pointer_manager_v1_get_relative_pointer(
-                process_wayland.zwp_relative_pointer_manager_v1,
-                pointer->wl_pointer);
-        zwp_relative_pointer_v1_add_listener(pointer->zwp_relative_pointer_v1,
-                                             &relative_pointer_v1_listener, NULL);
-        TRACE("Enabling relative motion\n");
+        pointer->pointer_frame.dx = 0;
+        pointer->pointer_frame.dy = 0;
+        pointer->pointer_frame.dx_unaccel = 0;
+        pointer->pointer_frame.dy_unaccel = 0;
+        TRACE("Enabling relative only motion\n");
     }
-    else if (!needs_relative && pointer->zwp_relative_pointer_v1)
+    else if (!needs_relative && pointer->relative_only)
     {
-        zwp_relative_pointer_v1_destroy(pointer->zwp_relative_pointer_v1);
-        pointer->zwp_relative_pointer_v1 = NULL;
-        TRACE("Disabling relative motion\n");
+        TRACE("Disabling relative only motion\n");
     }
 
+    pointer->relative_only = needs_relative;
+
     InterlockedExchange(&pointer->confinement_updated, TRUE);
 }
 
@@ -1134,7 +1203,7 @@ BOOL WAYLAND_SetCursorPos(INT x, INT y)
     struct wayland_pointer *pointer = &process_wayland.pointer;
 
     pthread_mutex_lock(&pointer->mutex);
-    if (pointer->zwp_relative_pointer_v1)
+    if (pointer->relative_only)
     {
         pthread_mutex_unlock(&pointer->mutex);
         return FALSE;
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 29f692a891e..81af253d215 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -88,6 +88,20 @@ enum wayland_surface_role
     WAYLAND_SURFACE_ROLE_SUBSURFACE,
 };
 
+enum wayland_pointer_frame_flags
+{
+    WAYLAND_POINTER_FRAME_ABS = (1 << 0),
+    WAYLAND_POINTER_FRAME_REL = (1 << 1),
+    WAYLAND_POINTER_FRAME_WHEEL = (1 << 2),
+    WAYLAND_POINTER_FRAME_WHEELH = (1 << 3)
+};
+
+enum wayland_pointer_axis_stop_flags
+{
+    WAYLAND_POINTER_AXIS_STOP_VERTICAL = (1 << 0),
+    WAYLAND_POINTER_AXIS_STOP_HORIZONTAL = (1 << 1)
+};
+
 struct wayland_keyboard
 {
     struct wl_keyboard *wl_keyboard;
@@ -116,16 +130,20 @@ struct wayland_pointer
     HWND constraint_hwnd;
     BOOL pending_warp;
     BOOL confinement_updated;
+    BOOL relative_only;
     uint32_t enter_serial;
     uint32_t button_serial;
-    LONG last_x;
-    LONG last_y;
     struct wayland_cursor cursor;
-    double accum_x;
-    double accum_y;
-    double accum_wheel;
-    double accum_wheelH;
-    LONG discrete_event_handled;
+    struct
+    {
+        LONG discrete_event_handled;
+        int x, y;
+        double dx, dy;
+        double dx_unaccel, dy_unaccel;
+        double wheel, wheelH;
+        unsigned int flags;
+        unsigned int axis_stop;
+    } pointer_frame;
     pthread_mutex_t mutex;
 };
 
-- 
2.49.0

From 4379f9c192fa29bc3a1d9b00c4bf841675534ad6 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sun, 8 Jun 2025 13:46:36 -0400
Subject: [PATCH 091/159] winewayland: Always use rawinput.

---
 dlls/winewayland.drv/wayland_pointer.c | 55 +++++++++-----------------
 dlls/winewayland.drv/waylanddrv.h      |  1 -
 2 files changed, 19 insertions(+), 37 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index b67da1c4fa2..f90086f2df4 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -199,8 +199,6 @@ static void pointer_handle_enter(void *data, struct wl_pointer *wl_pointer,
     /* reset all accumulators */
     pointer->pointer_frame.dx = 0;
     pointer->pointer_frame.dy = 0;
-    pointer->pointer_frame.dx_unaccel = 0;
-    pointer->pointer_frame.dy_unaccel = 0;
     pointer->pointer_frame.wheel = 0;
     pointer->pointer_frame.wheelH = 0;
     pthread_mutex_unlock(&pointer->mutex);
@@ -357,30 +355,20 @@ static void pointer_handle_frame(void *data, struct wl_pointer *wl_pointer)
         input.mi.dy = pointer->pointer_frame.y;
         input.mi.dwFlags = MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE;
         NtUserSendHardwareInput(hwnd, SEND_HWMSG_NO_RAW, &input, 0);
+    }
 
-        if (pointer->pointer_frame.flags & WAYLAND_POINTER_FRAME_REL)
-        {
-            input.mi.dx = round(pointer->pointer_frame.dx);
-            input.mi.dy = round(pointer->pointer_frame.dy);
-            pointer->pointer_frame.dx -= input.mi.dx;
-            pointer->pointer_frame.dy -= input.mi.dy;
-            pointer->pointer_frame.dx_unaccel
-                -= round(pointer->pointer_frame.dx_unaccel);
-            pointer->pointer_frame.dy_unaccel
-                -= round(pointer->pointer_frame.dy_unaccel);
-            input.mi.dwFlags = MOUSEEVENTF_MOVE;
-            NtUserSendHardwareInput(hwnd, SEND_HWMSG_NO_MSG, &input, 0);
-        }
-    } else if (pointer->pointer_frame.flags & WAYLAND_POINTER_FRAME_REL) {
-        /* HACK: use raw input when there is only relative motion */
-        input.mi.dx = round(pointer->pointer_frame.dx_unaccel);
-        input.mi.dy = round(pointer->pointer_frame.dy_unaccel);
-        pointer->pointer_frame.dx_unaccel -= input.mi.dx;
-        pointer->pointer_frame.dy_unaccel -= input.mi.dy;
-        pointer->pointer_frame.dx -= round(pointer->pointer_frame.dx);
-        pointer->pointer_frame.dy -= round(pointer->pointer_frame.dy);
+    /*
+     * Always send raw input
+     * FIXME: is this correct behavior?
+    */
+    if (pointer->pointer_frame.flags & WAYLAND_POINTER_FRAME_REL) {
+        input.mi.dx = round(pointer->pointer_frame.dx);
+        input.mi.dy = round(pointer->pointer_frame.dy);
+        pointer->pointer_frame.dx -= input.mi.dx;
+        pointer->pointer_frame.dy -= input.mi.dy;
         input.mi.dwFlags = MOUSEEVENTF_MOVE;
-        NtUserSendHardwareInput(hwnd, 0, &input, 0); /* FIXME: flags ? */
+        if (input.mi.dx != 0 || input.mi.dy != 0)
+            NtUserSendHardwareInput(hwnd, SEND_HWMSG_NO_MSG, &input, 0);
     }
 
     /* zero these values just in case */
@@ -544,25 +532,22 @@ static void relative_pointer_v1_relative_motion(void *private,
 
     pthread_mutex_lock(&pointer->mutex);
 
-    pointer->pointer_frame.dx_unaccel += f_dxu;
-    pointer->pointer_frame.dy_unaccel += f_dyu;
-    pointer->pointer_frame.dx += f_dx;
-    pointer->pointer_frame.dy += f_dy;
 
     if (is_rawinput_disabled())
     {
-        pointer->pointer_frame.dx_unaccel = pointer->pointer_frame.dx;
-        pointer->pointer_frame.dy_unaccel = pointer->pointer_frame.dy;
+        pointer->pointer_frame.dx += f_dx;
+        pointer->pointer_frame.dy += f_dy;
+    } else {
+        pointer->pointer_frame.dx += f_dxu;
+        pointer->pointer_frame.dy += f_dyu;
     }
 
     pointer->pointer_frame.flags |= WAYLAND_POINTER_FRAME_REL;
 
-    TRACE("hwnd=%p dxdy=%.2f,%.2f dxdy_raw=%.2f,%.2f\n",
+    TRACE("hwnd=%p dxdy=%.2f,%.2f\n",
           hwnd,
           pointer->pointer_frame.dx,
-          pointer->pointer_frame.dy,
-          pointer->pointer_frame.dx_unaccel,
-          pointer->pointer_frame.dy_unaccel);
+          pointer->pointer_frame.dy);
 
     pthread_mutex_unlock(&pointer->mutex);
 }
@@ -1166,8 +1151,6 @@ static void wayland_pointer_update_constraint(struct wl_surface *wl_surface,
     {
         pointer->pointer_frame.dx = 0;
         pointer->pointer_frame.dy = 0;
-        pointer->pointer_frame.dx_unaccel = 0;
-        pointer->pointer_frame.dy_unaccel = 0;
         TRACE("Enabling relative only motion\n");
     }
     else if (!needs_relative && pointer->relative_only)
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 81af253d215..aa440e499b4 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -139,7 +139,6 @@ struct wayland_pointer
         LONG discrete_event_handled;
         int x, y;
         double dx, dy;
-        double dx_unaccel, dy_unaccel;
         double wheel, wheelH;
         unsigned int flags;
         unsigned int axis_stop;
-- 
2.49.0

From 87251f0e5c8aa2bd2e3414ae6b942fd060740bc6 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Mon, 9 Jun 2025 08:05:26 -0400
Subject: [PATCH 092/159] winewayland: immediately send input when entering.

---
 dlls/winewayland.drv/wayland_pointer.c | 28 ++++++++++++++++++--------
 1 file changed, 20 insertions(+), 8 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index f90086f2df4..af527264732 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -116,7 +116,7 @@ static HWND wayland_pointer_get_focused_hwnd(void)
     return hwnd;
 }
 
-static void pointer_handle_motion_internal(wl_fixed_t sx, wl_fixed_t sy)
+static void pointer_handle_motion_internal(wl_fixed_t sx, wl_fixed_t sy, BOOL send_input)
 {
     RECT *window_rect;
     HWND hwnd;
@@ -150,14 +150,26 @@ static void pointer_handle_motion_internal(wl_fixed_t sx, wl_fixed_t sy)
 
     wayland_win_data_release(data);
 
-    pthread_mutex_lock(&pointer->mutex);
+    if (!send_input)
+    {
+        pthread_mutex_lock(&pointer->mutex);
 
-    pointer->pointer_frame.x = screen.x;
-    pointer->pointer_frame.y = screen.y;
+        pointer->pointer_frame.x = screen.x;
+        pointer->pointer_frame.y = screen.y;
 
-    pointer->pointer_frame.flags |= WAYLAND_POINTER_FRAME_ABS;
+        pointer->pointer_frame.flags |= WAYLAND_POINTER_FRAME_ABS;
 
-    pthread_mutex_unlock(&pointer->mutex);
+        pthread_mutex_unlock(&pointer->mutex);
+    } else {
+        INPUT input = {0};
+
+        input.type = INPUT_MOUSE;
+        input.mi.dx = screen.x;
+        input.mi.dy = screen.y;
+        input.mi.dwFlags = MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE;
+
+        NtUserSendHardwareInput(hwnd, SEND_HWMSG_NO_RAW, &input, 0);
+    }
 
     TRACE("hwnd=%p wayland_xy=%.2f,%.2f screen_xy=%d,%d\n",
                  hwnd, wl_fixed_to_double(sx), wl_fixed_to_double(sy),
@@ -172,7 +184,7 @@ static void pointer_handle_motion(void *data, struct wl_pointer *wl_pointer,
     /* Ignore absolute motion events if in relative mode. */
     if (pointer->relative_only) return;
 
-    pointer_handle_motion_internal(sx, sy);
+    pointer_handle_motion_internal(sx, sy, FALSE);
 }
 
 static void wayland_set_cursor(HWND hwnd, HCURSOR hcursor, BOOL use_hcursor);
@@ -210,7 +222,7 @@ static void pointer_handle_enter(void *data, struct wl_pointer *wl_pointer,
     /* Handle the enter as a motion, to account for cases where the
      * window first appears beneath the pointer and won't get a separate
      * motion event. */
-    pointer_handle_motion_internal(sx, sy);
+    pointer_handle_motion_internal(sx, sy, TRUE);
 }
 
 static void pointer_handle_leave(void *data, struct wl_pointer *wl_pointer,
-- 
2.49.0

From 7e44c0073f1d97dc7a5804d8b99b09ebe6a1b27b Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Fri, 23 May 2025 22:09:55 -0400
Subject: [PATCH 093/159] winewayland: Implement xdg-system-bell-v1

some troll shit bro
---
 dlls/winewayland.drv/Makefile.in            |  1 +
 dlls/winewayland.drv/wayland.c              |  9 ++++
 dlls/winewayland.drv/waylanddrv.h           |  4 +-
 dlls/winewayland.drv/waylanddrv_main.c      |  1 +
 dlls/winewayland.drv/window.c               | 13 +++++
 dlls/winewayland.drv/xdg-system-bell-v1.xml | 58 +++++++++++++++++++++
 6 files changed, 85 insertions(+), 1 deletion(-)
 create mode 100644 dlls/winewayland.drv/xdg-system-bell-v1.xml

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index ca313b8f7e6..b023770a858 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -32,4 +32,5 @@ SOURCES = \
 	wlr-data-control-unstable-v1.xml \
 	xdg-output-unstable-v1.xml \
 	xdg-shell.xml \
+	xdg-system-bell-v1.xml \
 	xdg-toplevel-icon-v1.xml
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 29f3e48645e..f63e0f5908c 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -210,6 +210,12 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         process_wayland.wp_color_manager_v1 =
             wl_registry_bind(registry, id, &wp_color_manager_v1_interface, 1);
     }
+    else if (strcmp(interface, "xdg_system_bell_v1") == 0)
+    {
+        process_wayland.xdg_system_bell_v1 =
+            wl_registry_bind(registry, id, &xdg_system_bell_v1_interface,
+                             1);
+    }
 }
 
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
@@ -349,6 +355,9 @@ BOOL wayland_process_init(void)
     if (!process_wayland.wp_color_manager_v1)
         ERR("Wayland compositor doesn't support wp_color_manager_v1 (HDR will not be supported)\n");
 
+    if (!process_wayland.xdg_system_bell_v1)
+        ERR("Wayland compositor doesn't xdg_system_bell_v1! (Beep will not be supported)\n");
+
     process_wayland.initialized = TRUE;
 
     return TRUE;
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index aa440e499b4..30e9321e496 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -41,6 +41,7 @@
 #include "tablet-v2-client-protocol.h"
 #include "cursor-shape-v1-client-protocol.h"
 #include "color-management-v1-client-protocol.h"
+#include "xdg-system-bell-v1-client-protocol.h"
 
 #include "windef.h"
 #include "winbase.h"
@@ -204,6 +205,7 @@ struct wayland
     struct xdg_toplevel_icon_manager_v1 *xdg_toplevel_icon_manager_v1;
     struct wp_cursor_shape_manager_v1 *wp_cursor_shape_manager_v1;
     struct wp_color_manager_v1 *wp_color_manager_v1;
+    struct xdg_system_bell_v1 *xdg_system_bell_v1;
     struct wayland_seat seat;
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
@@ -499,7 +501,7 @@ RGNDATA *get_region_data(HRGN region);
 /**********************************************************************
  *          USER driver functions
  */
-
+void WAYLAND_Beep(void);
 LRESULT WAYLAND_ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam);
 BOOL WAYLAND_ClipCursor(const RECT *clip, BOOL reset);
 LRESULT WAYLAND_DesktopWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 9da551d13b1..0624c6d019f 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -39,6 +39,7 @@ BOOL option_use_system_cursors = TRUE;
 
 static const struct user_driver_funcs waylanddrv_funcs =
 {
+    .pBeep = WAYLAND_Beep,
     .pClipboardWindowProc = WAYLAND_ClipboardWindowProc,
     .pClipCursor = WAYLAND_ClipCursor,
     .pDesktopWindowProc = WAYLAND_DesktopWindowProc,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 2752ad2a469..0f15506b20c 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -780,6 +780,19 @@ LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam, const POINT
     return ret;
 }
 
+/**********************************************************************
+ *          WAYLAND_Beep
+ */
+void WAYLAND_Beep(void)
+{
+    if (!process_wayland.xdg_system_bell_v1) return;
+
+    TRACE("\n");
+
+    xdg_system_bell_v1_ring(process_wayland.xdg_system_bell_v1, NULL);
+    wl_display_flush(process_wayland.wl_display);
+}
+
 /**********************************************************************
  *          get_client_surface
  */
diff --git a/dlls/winewayland.drv/xdg-system-bell-v1.xml b/dlls/winewayland.drv/xdg-system-bell-v1.xml
new file mode 100644
index 00000000000..f00508de850
--- /dev/null
+++ b/dlls/winewayland.drv/xdg-system-bell-v1.xml
@@ -0,0 +1,58 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="xdg_system_bell_v1">
+  <copyright>
+    Copyright © 2016, 2023 Red Hat
+
+    Permission is hereby granted, free of charge, to any person obtaining a
+    copy of this software and associated documentation files (the "Software"),
+    to deal in the Software without restriction, including without limitation
+    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+    and/or sell copies of the Software, and to permit persons to whom the
+    Software is furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice (including the next
+    paragraph) shall be included in all copies or substantial portions of the
+    Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+    DEALINGS IN THE SOFTWARE.
+  </copyright>
+
+  <interface name="xdg_system_bell_v1" version="1">
+    <description summary="system bell">
+      This global interface enables clients to ring the system bell.
+
+      Warning! The protocol described in this file is currently in the testing
+      phase. Backward compatible changes may be added together with the
+      corresponding interface version bump. Backward incompatible changes can
+      only be done by creating a new major version of the extension.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the system bell object">
+	Notify that the object will no longer be used.
+      </description>
+    </request>
+
+    <request name="ring">
+      <description summary="ring the system bell">
+	This requests rings the system bell on behalf of a client. How ringing
+	the bell is implemented is up to the compositor. It may be an audible
+	sound, a visual feedback of some kind, or any other thing including
+	nothing.
+
+        The passed surface should correspond to a toplevel like surface role,
+        or be null, meaning the client doesn't have a particular toplevel it
+        wants to associate the bell ringing with. See the xdg-shell protocol
+        extension for a toplevel like surface role.
+      </description>
+      <arg name="surface" type="object" interface="wl_surface"
+	   allow-null="true" summary="associated surface"/>
+    </request>
+  </interface>
+</protocol>
-- 
2.49.0

From c34723b11f73eebcc2031d555c1009c60f53041b Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Mon, 9 Jun 2025 09:07:33 -0400
Subject: [PATCH 094/159] winewayland: Add support for xdg-activation-v1

---
 dlls/winewayland.drv/Makefile.in           |   1 +
 dlls/winewayland.drv/wayland.c             |  11 +-
 dlls/winewayland.drv/wayland_surface.c     |  60 +++++++
 dlls/winewayland.drv/waylanddrv.h          |   6 +
 dlls/winewayland.drv/waylanddrv_main.c     |   1 +
 dlls/winewayland.drv/window.c              |  17 ++
 dlls/winewayland.drv/xdg-activation-v1.xml | 200 +++++++++++++++++++++
 7 files changed, 294 insertions(+), 2 deletions(-)
 create mode 100644 dlls/winewayland.drv/xdg-activation-v1.xml

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index b023770a858..6b151f3d398 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -30,6 +30,7 @@ SOURCES = \
 	window.c \
 	window_surface.c \
 	wlr-data-control-unstable-v1.xml \
+	xdg-activation-v1.xml \
 	xdg-output-unstable-v1.xml \
 	xdg-shell.xml \
 	xdg-system-bell-v1.xml \
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index f63e0f5908c..f6cadedf37d 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -213,8 +213,12 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
     else if (strcmp(interface, "xdg_system_bell_v1") == 0)
     {
         process_wayland.xdg_system_bell_v1 =
-            wl_registry_bind(registry, id, &xdg_system_bell_v1_interface,
-                             1);
+            wl_registry_bind(registry, id, &xdg_system_bell_v1_interface, 1);
+    }
+    else if (strcmp(interface, "xdg_activation_v1") == 0)
+    {
+        process_wayland.xdg_activation_v1 =
+            wl_registry_bind(registry, id, &xdg_activation_v1_interface, 1);
     }
 }
 
@@ -358,6 +362,9 @@ BOOL wayland_process_init(void)
     if (!process_wayland.xdg_system_bell_v1)
         ERR("Wayland compositor doesn't xdg_system_bell_v1! (Beep will not be supported)\n");
 
+    if (!process_wayland.xdg_activation_v1)
+        ERR("Wayland compositor doesn't support xdg_activation_v1! (Flash Window will not be supported)\n");
+
     process_wayland.initialized = TRUE;
 
     return TRUE;
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 28087412446..4571c0a0ab3 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -315,6 +315,12 @@ void wayland_surface_destroy(struct wayland_surface *surface)
 
     wayland_surface_clear_role(surface);
 
+    if (surface->xdg_activation_token_v1)
+    {
+        xdg_activation_token_v1_destroy(surface->xdg_activation_token_v1);
+        surface->xdg_activation_token_v1 = NULL;
+    }
+
     if (surface->wp_fractional_scale_v1)
     {
         wp_fractional_scale_v1_destroy(surface->wp_fractional_scale_v1);
@@ -1417,3 +1423,57 @@ void wayland_surface_set_icon(struct wayland_surface *surface, UINT type, ICONIN
                                               surface->xdg_toplevel, surface->xdg_toplevel_icon);
     }
 }
+
+static void xdg_activation_token_handle_done(void *user_data,
+                                             struct xdg_activation_token_v1 *xdg_activation_token_v1,
+                                             const char *token)
+{
+    HWND hwnd = user_data;
+    struct wayland_win_data *data;
+    struct wayland_surface *surface;
+
+
+    if ((data = wayland_win_data_get(hwnd)))
+    {
+        if ((surface = data->wayland_surface))
+        {
+            xdg_activation_v1_activate(process_wayland.xdg_activation_v1, token, surface->wl_surface);
+            xdg_activation_token_v1_destroy(surface->xdg_activation_token_v1);
+            surface->xdg_activation_token_v1 = NULL;
+        }
+        wayland_win_data_release(data);
+    }
+}
+
+const static struct xdg_activation_token_v1_listener xdg_activation_listener = {
+    xdg_activation_token_handle_done
+};
+
+void wayland_surface_set_activation(struct wayland_surface *surface, BOOL activate)
+{
+    assert(surface);
+
+    if (!activate && surface->xdg_activation_token_v1)
+    {
+        xdg_activation_token_v1_destroy(surface->xdg_activation_token_v1);
+        surface->xdg_activation_token_v1 = NULL;
+        return;
+    }
+
+    if (activate && !surface->xdg_activation_token_v1 && process_wayland.xdg_activation_v1)
+    {
+        surface->xdg_activation_token_v1 =
+            xdg_activation_v1_get_activation_token(process_wayland.xdg_activation_v1);
+
+        if (!surface->xdg_activation_token_v1)
+        {
+            ERR("Failed to create activation token!\n");
+            return;
+        }
+
+        xdg_activation_token_v1_add_listener(surface->xdg_activation_token_v1,
+                                             &xdg_activation_listener, surface->hwnd);
+        xdg_activation_token_v1_set_surface(surface->xdg_activation_token_v1, surface->wl_surface);
+        xdg_activation_token_v1_commit(surface->xdg_activation_token_v1);
+    }
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 30e9321e496..189beef37d4 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -42,6 +42,7 @@
 #include "cursor-shape-v1-client-protocol.h"
 #include "color-management-v1-client-protocol.h"
 #include "xdg-system-bell-v1-client-protocol.h"
+#include "xdg-activation-v1-client-protocol.h"
 
 #include "windef.h"
 #include "winbase.h"
@@ -206,6 +207,7 @@ struct wayland
     struct wp_cursor_shape_manager_v1 *wp_cursor_shape_manager_v1;
     struct wp_color_manager_v1 *wp_color_manager_v1;
     struct xdg_system_bell_v1 *xdg_system_bell_v1;
+    struct xdg_activation_v1 *xdg_activation_v1;
     struct wayland_seat seat;
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
@@ -317,6 +319,8 @@ struct wayland_surface
     struct wl_output *wl_output;
     struct wp_viewport *wp_viewport;
     struct wp_fractional_scale_v1 *wp_fractional_scale_v1;
+    /* FIXME: should this be moved? */
+    struct xdg_activation_token_v1 *xdg_activation_token_v1;
 
     enum wayland_surface_role role;
     union
@@ -388,6 +392,7 @@ void wayland_client_surface_detach(struct wayland_client_surface *client);
 void wayland_surface_ensure_contents(struct wayland_surface *surface);
 void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR title);
 void wayland_surface_set_icon(struct wayland_surface *surface, UINT type, ICONINFO *ii);
+void wayland_surface_set_activation(struct wayland_surface *surface, BOOL activation);
 
 static inline BOOL wayland_surface_is_toplevel(struct wayland_surface *surface)
 {
@@ -506,6 +511,7 @@ LRESULT WAYLAND_ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM l
 BOOL WAYLAND_ClipCursor(const RECT *clip, BOOL reset);
 LRESULT WAYLAND_DesktopWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
 void WAYLAND_DestroyWindow(HWND hwnd);
+void WAYLAND_FlashWindowEx(FLASHWINFO *info);
 BOOL WAYLAND_SetIMECompositionRect(HWND hwnd, RECT rect);
 void WAYLAND_SetCursor(HWND hwnd, HCURSOR hcursor);
 BOOL WAYLAND_SetCursorPos(INT x, INT y);
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 0624c6d019f..f9533618d47 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -44,6 +44,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pClipCursor = WAYLAND_ClipCursor,
     .pDesktopWindowProc = WAYLAND_DesktopWindowProc,
     .pDestroyWindow = WAYLAND_DestroyWindow,
+    .pFlashWindowEx = WAYLAND_FlashWindowEx,
     .pSetIMECompositionRect = WAYLAND_SetIMECompositionRect,
     .pKbdLayerDescriptor = WAYLAND_KbdLayerDescriptor,
     .pReleaseKbdTables = WAYLAND_ReleaseKbdTables,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 0f15506b20c..7fbae85e37c 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -793,6 +793,23 @@ void WAYLAND_Beep(void)
     wl_display_flush(process_wayland.wl_display);
 }
 
+/**********************************************************************
+ *          WAYLAND_FlashWindowEx
+ */
+void WAYLAND_FlashWindowEx(FLASHWINFO *info)
+{
+    struct wayland_win_data *data;
+
+    TRACE("%p\n", info);
+
+    if ((data = wayland_win_data_get(info->hwnd)))
+    {
+        if (data->wayland_surface)
+            wayland_surface_set_activation(data->wayland_surface, info->dwFlags);
+        wayland_win_data_release(data);
+    }
+}
+
 /**********************************************************************
  *          get_client_surface
  */
diff --git a/dlls/winewayland.drv/xdg-activation-v1.xml b/dlls/winewayland.drv/xdg-activation-v1.xml
new file mode 100644
index 00000000000..9adcc274ef1
--- /dev/null
+++ b/dlls/winewayland.drv/xdg-activation-v1.xml
@@ -0,0 +1,200 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="xdg_activation_v1">
+
+  <copyright>
+    Copyright © 2020 Aleix Pol Gonzalez &lt;aleixpol@kde.org&gt;
+    Copyright © 2020 Carlos Garnacho &lt;carlosg@gnome.org&gt;
+
+    Permission is hereby granted, free of charge, to any person obtaining a
+    copy of this software and associated documentation files (the "Software"),
+    to deal in the Software without restriction, including without limitation
+    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+    and/or sell copies of the Software, and to permit persons to whom the
+    Software is furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice (including the next
+    paragraph) shall be included in all copies or substantial portions of the
+    Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+    DEALINGS IN THE SOFTWARE.
+  </copyright>
+
+  <description summary="Protocol for requesting activation of surfaces">
+    The way for a client to pass focus to another toplevel is as follows.
+
+    The client that intends to activate another toplevel uses the
+    xdg_activation_v1.get_activation_token request to get an activation token.
+    This token is then forwarded to the client, which is supposed to activate
+    one of its surfaces, through a separate band of communication.
+
+    One established way of doing this is through the XDG_ACTIVATION_TOKEN
+    environment variable of a newly launched child process. The child process
+    should unset the environment variable again right after reading it out in
+    order to avoid propagating it to other child processes.
+
+    Another established way exists for Applications implementing the D-Bus
+    interface org.freedesktop.Application, which should get their token under
+    activation-token on their platform_data.
+
+    In general activation tokens may be transferred across clients through
+    means not described in this protocol.
+
+    The client to be activated will then pass the token
+    it received to the xdg_activation_v1.activate request. The compositor can
+    then use this token to decide how to react to the activation request.
+
+    The token the activating client gets may be ineffective either already at
+    the time it receives it, for example if it was not focused, for focus
+    stealing prevention. The activating client will have no way to discover
+    the validity of the token, and may still forward it to the to be activated
+    client.
+
+    The created activation token may optionally get information attached to it
+    that can be used by the compositor to identify the application that we
+    intend to activate. This can for example be used to display a visual hint
+    about what application is being started.
+
+    Warning! The protocol described in this file is currently in the testing
+    phase. Backward compatible changes may be added together with the
+    corresponding interface version bump. Backward incompatible changes can
+    only be done by creating a new major version of the extension.
+  </description>
+
+  <interface name="xdg_activation_v1" version="1">
+    <description summary="interface for activating surfaces">
+      A global interface used for informing the compositor about applications
+      being activated or started, or for applications to request to be
+      activated.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the xdg_activation object">
+        Notify the compositor that the xdg_activation object will no longer be
+        used.
+
+        The child objects created via this interface are unaffected and should
+        be destroyed separately.
+      </description>
+    </request>
+
+    <request name="get_activation_token">
+      <description summary="requests a token">
+        Creates an xdg_activation_token_v1 object that will provide
+        the initiating client with a unique token for this activation. This
+        token should be offered to the clients to be activated.
+      </description>
+
+      <arg name="id" type="new_id" interface="xdg_activation_token_v1"/>
+    </request>
+
+    <request name="activate">
+      <description summary="notify new interaction being available">
+        Requests surface activation. It's up to the compositor to display
+        this information as desired, for example by placing the surface above
+        the rest.
+
+        The compositor may know who requested this by checking the activation
+        token and might decide not to follow through with the activation if it's
+        considered unwanted.
+
+        Compositors can ignore unknown activation tokens when an invalid
+        token is passed.
+      </description>
+      <arg name="token" type="string" summary="the activation token of the initiating client"/>
+      <arg name="surface" type="object" interface="wl_surface"
+	   summary="the wl_surface to activate"/>
+    </request>
+  </interface>
+
+  <interface name="xdg_activation_token_v1" version="1">
+    <description summary="an exported activation handle">
+      An object for setting up a token and receiving a token handle that can
+      be passed as an activation token to another client.
+
+      The object is created using the xdg_activation_v1.get_activation_token
+      request. This object should then be populated with the app_id, surface
+      and serial information and committed. The compositor shall then issue a
+      done event with the token. In case the request's parameters are invalid,
+      the compositor will provide an invalid token.
+    </description>
+
+    <enum name="error">
+      <entry name="already_used" value="0"
+             summary="The token has already been used previously"/>
+    </enum>
+
+    <request name="set_serial">
+      <description summary="specifies the seat and serial of the activating event">
+        Provides information about the seat and serial event that requested the
+        token.
+
+        The serial can come from an input or focus event. For instance, if a
+        click triggers the launch of a third-party client, the launcher client
+        should send a set_serial request with the serial and seat from the
+        wl_pointer.button event.
+
+        Some compositors might refuse to activate toplevels when the token
+        doesn't have a valid and recent enough event serial.
+
+        Must be sent before commit. This information is optional.
+      </description>
+      <arg name="serial" type="uint"
+           summary="the serial of the event that triggered the activation"/>
+      <arg name="seat" type="object" interface="wl_seat"
+           summary="the wl_seat of the event"/>
+    </request>
+
+    <request name="set_app_id">
+      <description summary="specifies the application being activated">
+        The requesting client can specify an app_id to associate the token
+        being created with it.
+
+        Must be sent before commit. This information is optional.
+      </description>
+      <arg name="app_id" type="string"
+           summary="the application id of the client being activated."/>
+    </request>
+
+    <request name="set_surface">
+      <description summary="specifies the surface requesting activation">
+        This request sets the surface requesting the activation. Note, this is
+        different from the surface that will be activated.
+
+        Some compositors might refuse to activate toplevels when the token
+        doesn't have a requesting surface.
+
+        Must be sent before commit. This information is optional.
+      </description>
+      <arg name="surface" type="object" interface="wl_surface"
+	   summary="the requesting surface"/>
+    </request>
+
+    <request name="commit">
+      <description summary="issues the token request">
+        Requests an activation token based on the different parameters that
+        have been offered through set_serial, set_surface and set_app_id.
+      </description>
+    </request>
+
+    <event name="done">
+      <description summary="the exported activation token">
+        The 'done' event contains the unique token of this activation request
+        and notifies that the provider is done.
+      </description>
+      <arg name="token" type="string" summary="the exported activation token"/>
+    </event>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the xdg_activation_token_v1 object">
+        Notify the compositor that the xdg_activation_token_v1 object will no
+        longer be used. The received token stays valid.
+      </description>
+    </request>
+  </interface>
+</protocol>
-- 
2.49.0

From 18d3a18f42e403b9dae0ed51fa1a1c42e84655ef Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty <etaash.mathamsetty@gmail.com>
Date: Tue, 10 Jun 2025 17:51:30 -0400
Subject: [PATCH 095/159] fixup! winewayland: Rewrite wayland pointer
 implementation.

---
 dlls/winewayland.drv/wayland_pointer.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index af527264732..de13e50deb8 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -380,7 +380,7 @@ static void pointer_handle_frame(void *data, struct wl_pointer *wl_pointer)
         pointer->pointer_frame.dy -= input.mi.dy;
         input.mi.dwFlags = MOUSEEVENTF_MOVE;
         if (input.mi.dx != 0 || input.mi.dy != 0)
-            NtUserSendHardwareInput(hwnd, SEND_HWMSG_NO_MSG, &input, 0);
+            NtUserSendHardwareInput(hwnd, pointer->relative_only ? 0 : SEND_HWMSG_NO_MSG, &input, 0);
     }
 
     /* zero these values just in case */
-- 
2.49.0

From e2ad36422355b4709dd8812fae90873fcbad365d Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Tue, 10 Jun 2025 22:11:41 -0400
Subject: [PATCH 096/159] winewayland: Implement HasWindowManager fully

---
 dlls/winewayland.drv/window_surface.c | 10 +++++++++-
 1 file changed, 9 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index 408f52f3f77..65464efc334 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -528,5 +528,13 @@ BOOL WAYLAND_CreateWindowSurface(HWND hwnd, BOOL layered, const RECT *surface_re
  */
 BOOL WAYLAND_HasWindowManager(const char *name)
 {
-    return !strcmp("waylanddrv", name);
+    const char *env;
+    if (!strcmp("waylanddrv", name)) return TRUE;
+
+    env = getenv("XDG_CURRENT_DESKTOP");
+    TRACE("DE: %s\n", debugstr_a(env));
+
+    if (env && !strcmp(env, name)) return TRUE;
+
+    return FALSE;
 }
-- 
2.49.0

From 0873f73e3eb7a6d4a52797f95e3b08468554dee0 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty <etaash.mathamsetty@gmail.com>
Date: Tue, 10 Jun 2025 22:19:55 -0400
Subject: [PATCH 097/159] HACK: winewayland: confine to parent surface on kwin.

---
 dlls/winewayland.drv/wayland_pointer.c | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index de13e50deb8..d5328f33ace 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -1231,6 +1231,15 @@ BOOL WAYLAND_ClipCursor(const RECT *clip, BOOL reset)
     NtUserGetCursorPos(&cursor_pos);
     hwnd = NtUserGetForegroundWindow();
 
+    /* HACK: confine to parent surface on KWin */
+    if (WAYLAND_HasWindowManager("KDE"))
+    {
+        HWND old = hwnd;
+        hwnd = NtUserGetAncestor(hwnd, GA_ROOT);
+        if (old != hwnd)
+            WARN("Confining to parent surface!\n");
+    }
+
     if (!(data = wayland_win_data_get(hwnd))) return FALSE;
     if ((surface = data->wayland_surface))
     {
-- 
2.49.0

From 9cee47bdebb2929374cc5e44a112ce1b6e0ba56f Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Wed, 11 Jun 2025 13:19:49 -0400
Subject: [PATCH 098/159] amdxc: minor code cleanups

---
 dlls/amdxc64/main.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/dlls/amdxc64/main.c b/dlls/amdxc64/main.c
index 2cc11a811fc..e02e6525aea 100644
--- a/dlls/amdxc64/main.c
+++ b/dlls/amdxc64/main.c
@@ -82,6 +82,7 @@ typedef HRESULT (__stdcall *updateffxapi_pfn)(void*, unsigned int);
 
 HRESULT STDMETHODCALLTYPE AMDFSR4FFX_UpdateFfxApiProvider(IAmdExtFfxApi *iface, void* data, unsigned int size)
 {
+    static int once;
     const char *env;
     updateffxapi_pfn pfn;
     HMODULE amdffx;
@@ -90,7 +91,7 @@ HRESULT STDMETHODCALLTYPE AMDFSR4FFX_UpdateFfxApiProvider(IAmdExtFfxApi *iface,
 
     env = getenv("FSR4_UPGRADE");
 
-    if(env && env[0] != '0')
+    if(env && !strcmp(env, "1"))
     {
         amdffx = LoadLibraryA("amdxcffx64");
         if (!amdffx)
@@ -103,7 +104,8 @@ HRESULT STDMETHODCALLTYPE AMDFSR4FFX_UpdateFfxApiProvider(IAmdExtFfxApi *iface,
 
         if(pfn)
         {
-            FIXME("Replaced FSR3 with FSR4!\n");
+            if (!once++)
+                FIXME("Replaced FSR3 with FSR4!\n");
             return pfn(data, size);
         }
     }
-- 
2.49.0

From 0c3983e987649a952951b85ea481ac08743ea945 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Thu, 12 Jun 2025 17:30:25 -0400
Subject: [PATCH 099/159] winewayland: small cleanups

---
 dlls/winewayland.drv/window.c         | 4 ++--
 dlls/winewayland.drv/window_surface.c | 9 +++++----
 2 files changed, 7 insertions(+), 6 deletions(-)

diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 7fbae85e37c..32b1a00f6cd 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -800,7 +800,7 @@ void WAYLAND_FlashWindowEx(FLASHWINFO *info)
 {
     struct wayland_win_data *data;
 
-    TRACE("%p\n", info);
+    TRACE("hwnd=%p\n", info->hwnd);
 
     if ((data = wayland_win_data_get(info->hwnd)))
     {
@@ -815,9 +815,9 @@ void WAYLAND_FlashWindowEx(FLASHWINFO *info)
  */
 struct wayland_client_surface *get_client_surface(HWND hwnd)
 {
-    HWND toplevel = NtUserGetAncestor(hwnd, GA_ROOT);
     struct wayland_client_surface *client;
     struct wayland_win_data *data;
+    HWND toplevel = NtUserGetAncestor(hwnd, GA_ROOT);
 
     if ((data = wayland_win_data_get(hwnd)))
     {
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index 65464efc334..be2888cb827 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -528,12 +528,13 @@ BOOL WAYLAND_CreateWindowSurface(HWND hwnd, BOOL layered, const RECT *surface_re
  */
 BOOL WAYLAND_HasWindowManager(const char *name)
 {
-    const char *env;
-    if (!strcmp("waylanddrv", name)) return TRUE;
+    static int once;
+    const char *env = getenv("XDG_CURRENT_DESKTOP");
 
-    env = getenv("XDG_CURRENT_DESKTOP");
-    TRACE("DE: %s\n", debugstr_a(env));
+    if (!once++)
+        TRACE("DE: %s\n", debugstr_a(env));
 
+    if (!strcmp("waylanddrv", name)) return TRUE;
     if (env && !strcmp(env, name)) return TRUE;
 
     return FALSE;
-- 
2.49.0

From 480f97cb377bab828aa2e24a89f14b82774a207b Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Fri, 13 Jun 2025 08:46:44 -0400
Subject: [PATCH 100/159] winewayland: Set process name for xdg-toplevel-icon.

---
 dlls/winewayland.drv/wayland_surface.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 4571c0a0ab3..c52f9055b21 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -1417,7 +1417,7 @@ void wayland_surface_set_icon(struct wayland_surface *surface, UINT type, ICONIN
                                             surface->small_icon_buffer->wl_buffer, 1);
         }
 
-        xdg_toplevel_icon_v1_set_name(surface->xdg_toplevel_icon, "");
+        xdg_toplevel_icon_v1_set_name(surface->xdg_toplevel_icon, process_name ? process_name : "");
 
         xdg_toplevel_icon_manager_v1_set_icon(process_wayland.xdg_toplevel_icon_manager_v1,
                                               surface->xdg_toplevel, surface->xdg_toplevel_icon);
-- 
2.49.0

From 9572d84fdc92ef4a1d1ad667ed3a2dcf6e0f901d Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Fri, 13 Jun 2025 14:46:40 -0400
Subject: [PATCH 101/159] Import WIP atiadlxx and atidxx implementations

---
 configure.ac                              |    1 +
 dlls/atiadlxx/Makefile.in                 |   11 +-
 dlls/atiadlxx/amdheaders/adl_defines.h    | 2596 +++++++++++++
 dlls/atiadlxx/amdheaders/adl_sdk.h        |   46 +
 dlls/atiadlxx/amdheaders/adl_structures.h | 4289 +++++++++++++++++++++
 dlls/atiadlxx/atiadlxx.spec               |  157 +-
 dlls/atiadlxx/atiadlxx_main.c             | 1441 +++++--
 dlls/atiadlxx/dxvk_interfaces.idl         |  153 +
 dlls/atiadlxx/unixlib.c                   |  285 ++
 dlls/atiadlxx/unixlib.h                   |   61 +
 dlls/atidxx64/Makefile.in                 |    9 +
 dlls/atidxx64/atidxx.h                    |  137 +
 dlls/atidxx64/atidxx64.spec               |   17 +
 dlls/atidxx64/dxvk_interfaces.idl         |  153 +
 dlls/atidxx64/main.c                      |  677 ++++
 loader/wine.inf.in                        |    1 +
 16 files changed, 9657 insertions(+), 377 deletions(-)
 create mode 100644 dlls/atiadlxx/amdheaders/adl_defines.h
 create mode 100644 dlls/atiadlxx/amdheaders/adl_sdk.h
 create mode 100644 dlls/atiadlxx/amdheaders/adl_structures.h
 create mode 100644 dlls/atiadlxx/dxvk_interfaces.idl
 create mode 100644 dlls/atiadlxx/unixlib.c
 create mode 100644 dlls/atiadlxx/unixlib.h
 create mode 100644 dlls/atidxx64/Makefile.in
 create mode 100644 dlls/atidxx64/atidxx.h
 create mode 100644 dlls/atidxx64/atidxx64.spec
 create mode 100644 dlls/atidxx64/dxvk_interfaces.idl
 create mode 100644 dlls/atidxx64/main.c

diff --git a/configure.ac b/configure.ac
index dff8f27cedc..67da3de58aa 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2465,6 +2465,7 @@ WINE_CONFIG_MAKEFILE(dlls/apphelp/tests)
 WINE_CONFIG_MAKEFILE(dlls/appwiz.cpl)
 WINE_CONFIG_MAKEFILE(dlls/appxdeploymentclient)
 WINE_CONFIG_MAKEFILE(dlls/atiadlxx)
+WINE_CONFIG_MAKEFILE(dlls/atidxx64)
 WINE_CONFIG_MAKEFILE(dlls/atl)
 WINE_CONFIG_MAKEFILE(dlls/atl/tests)
 WINE_CONFIG_MAKEFILE(dlls/atl100)
diff --git a/dlls/atiadlxx/Makefile.in b/dlls/atiadlxx/Makefile.in
index cc6b51bf2bc..8cd80f90414 100644
--- a/dlls/atiadlxx/Makefile.in
+++ b/dlls/atiadlxx/Makefile.in
@@ -1,8 +1,13 @@
-EXTRADEFS = -DWINE_NO_LONG_TYPES
 MODULE = atiadlxx.dll
-IMPORTS = dxgi
+UNIXLIB   = atiadlxx.so
+UNIX_CFLAGS = $(DRM_CFLAGS)
+UNIX_LIBS = $(DRM_LIBS) $(DRMAMDGPU_LIBS)
+IMPORTS = version vulkan-1 user32 gdi32
+IMPORTLIB = atiadlxx
 
 EXTRADLLFLAGS = -mno-cygwin -Wb,--prefer-native
 
 SOURCES = \
-	atiadlxx_main.c
+	atiadlxx_main.c \
+	unixlib.c \
+	dxvk_interfaces.idl
diff --git a/dlls/atiadlxx/amdheaders/adl_defines.h b/dlls/atiadlxx/amdheaders/adl_defines.h
new file mode 100644
index 00000000000..20ec62b70a0
--- /dev/null
+++ b/dlls/atiadlxx/amdheaders/adl_defines.h
@@ -0,0 +1,2596 @@
+//
+// Copyright (c) 2016 - 2022 Advanced Micro Devices, Inc. All rights reserved.
+//
+// MIT LICENSE:
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+/// \file adl_defines.h
+/// \brief Contains all definitions exposed by ADL for \ALL platforms.\n <b>Included in ADL SDK</b>
+///
+/// This file contains all definitions used by ADL.
+/// The ADL definitions include the following:
+/// \li ADL error codes
+/// \li Enumerations for the ADLDisplayInfo structure
+/// \li Maximum limits
+///
+
+#ifndef ADL_DEFINES_H_
+#define ADL_DEFINES_H_
+
+/// \defgroup DEFINES Constants and Definitions
+/// @{
+
+/// \defgroup define_misc Miscellaneous Constant Definitions
+/// @{
+
+/// \name General Definitions
+/// @{
+
+/// Defines ADL_TRUE
+#define ADL_TRUE    1
+/// Defines ADL_FALSE
+#define ADL_FALSE        0
+
+/// Defines the maximum string length
+#define ADL_MAX_CHAR                                    4096
+/// Defines the maximum string length
+#define ADL_MAX_PATH                                    256
+/// Defines the maximum number of supported adapters
+#define ADL_MAX_ADAPTERS                               250
+/// Defines the maxumum number of supported displays
+#define ADL_MAX_DISPLAYS                                150
+/// Defines the maxumum string length for device name
+#define ADL_MAX_DEVICENAME                                32
+/// Defines for all adapters
+#define ADL_ADAPTER_INDEX_ALL                            -1
+///    Defines APIs with iOption none
+#define ADL_MAIN_API_OPTION_NONE                        0
+/// @}
+
+/// \name Definitions for iOption parameter used by
+/// ADL_Display_DDCBlockAccess_Get()
+/// @{
+
+/// Switch to DDC line 2 before sending the command to the display.
+#define ADL_DDC_OPTION_SWITCHDDC2              0x00000001
+/// Save command in the registry under a unique key, corresponding to parameter \b iCommandIndex
+#define ADL_DDC_OPTION_RESTORECOMMAND 0x00000002
+/// Combine write-read DDC block access command.
+#define ADL_DDC_OPTION_COMBOWRITEREAD 0x00000010
+/// Direct DDC access to the immediate device connected to graphics card.
+/// MST with this option set: DDC command is sent to first branch.
+/// MST with this option not set: DDC command is sent to the end node sink device.
+#define ADL_DDC_OPTION_SENDTOIMMEDIATEDEVICE 0x00000020
+/// @}
+
+/// \name Values for
+/// ADLI2C.iAction used with ADL_Display_WriteAndReadI2C()
+/// @{
+
+#define ADL_DL_I2C_ACTIONREAD								0x00000001
+#define ADL_DL_I2C_ACTIONWRITE								0x00000002
+#define ADL_DL_I2C_ACTIONREAD_REPEATEDSTART    				0x00000003
+#define ADL_DL_I2C_ACTIONIS_PRESENT							0x00000004
+/// @}
+
+
+/// @}        //Misc
+
+/// \defgroup define_adl_results Result Codes
+/// This group of definitions are the various results returned by all ADL functions \n
+/// @{
+/// All OK, but need to wait
+#define ADL_OK_WAIT                4
+/// All OK, but need restart
+#define ADL_OK_RESTART                3
+/// All OK but need mode change
+#define ADL_OK_MODE_CHANGE            2
+/// All OK, but with warning
+#define ADL_OK_WARNING                1
+/// ADL function completed successfully
+#define ADL_OK                    0
+/// Generic Error. Most likely one or more of the Escape calls to the driver failed!
+#define ADL_ERR                    -1
+/// ADL not initialized
+#define ADL_ERR_NOT_INIT            -2
+/// One of the parameter passed is invalid
+#define ADL_ERR_INVALID_PARAM            -3
+/// One of the parameter size is invalid
+#define ADL_ERR_INVALID_PARAM_SIZE        -4
+/// Invalid ADL index passed
+#define ADL_ERR_INVALID_ADL_IDX            -5
+/// Invalid controller index passed
+#define ADL_ERR_INVALID_CONTROLLER_IDX        -6
+/// Invalid display index passed
+#define ADL_ERR_INVALID_DIPLAY_IDX        -7
+/// Function  not supported by the driver
+#define ADL_ERR_NOT_SUPPORTED            -8
+/// Null Pointer error
+#define ADL_ERR_NULL_POINTER            -9
+/// Call can't be made due to disabled adapter
+#define ADL_ERR_DISABLED_ADAPTER        -10
+/// Invalid Callback
+#define ADL_ERR_INVALID_CALLBACK            -11
+/// Display Resource conflict
+#define ADL_ERR_RESOURCE_CONFLICT                -12
+//Failed to update some of the values. Can be returned by set request that include multiple values if not all values were successfully committed.
+#define ADL_ERR_SET_INCOMPLETE                 -20
+/// There's no Linux XDisplay in Linux Console environment
+#define ADL_ERR_NO_XDISPLAY                    -21
+/// escape call failed becuse of incompatiable driver found in driver store
+#define ADL_ERR_CALL_TO_INCOMPATIABLE_DRIVER            -22
+/// not running as administrator
+#define ADL_ERR_NO_ADMINISTRATOR_PRIVILEGES            -23
+/// Feature Sync Start api is not called yet
+#define ADL_ERR_FEATURESYNC_NOT_STARTED            -24
+/// Adapter is in an invalid power state
+#define ADL_ERR_INVALID_POWER_STATE             -25
+
+/// @}
+/// </A>
+
+/// \defgroup define_display_type Display Type
+/// Define Monitor/CRT display type
+/// @{
+/// Define Monitor display type
+#define ADL_DT_MONITOR                  0
+/// Define TV display type
+#define ADL_DT_TELEVISION                    1
+/// Define LCD display type
+#define ADL_DT_LCD_PANEL                       2
+/// Define DFP display type
+#define ADL_DT_DIGITAL_FLAT_PANEL        3
+/// Define Componment Video display type
+#define ADL_DT_COMPONENT_VIDEO               4
+/// Define Projector display type
+#define ADL_DT_PROJECTOR                       5
+/// @}
+
+/// \defgroup define_display_connection_type Display Connection Type
+/// @{
+/// Define unknown display output type
+#define ADL_DOT_UNKNOWN                0
+/// Define composite display output type
+#define ADL_DOT_COMPOSITE            1
+/// Define SVideo display output type
+#define ADL_DOT_SVIDEO                2
+/// Define analog display output type
+#define ADL_DOT_ANALOG                3
+/// Define digital display output type
+#define ADL_DOT_DIGITAL                4
+/// @}
+
+/// \defgroup define_color_type Display Color Type and Source
+/// Define  Display Color Type and Source
+/// @{
+#define ADL_DISPLAY_COLOR_BRIGHTNESS    (1 << 0)
+#define ADL_DISPLAY_COLOR_CONTRAST    (1 << 1)
+#define ADL_DISPLAY_COLOR_SATURATION    (1 << 2)
+#define ADL_DISPLAY_COLOR_HUE        (1 << 3)
+#define ADL_DISPLAY_COLOR_TEMPERATURE    (1 << 4)
+
+/// Color Temperature Source is EDID
+#define ADL_DISPLAY_COLOR_TEMPERATURE_SOURCE_EDID    (1 << 5)
+/// Color Temperature Source is User
+#define ADL_DISPLAY_COLOR_TEMPERATURE_SOURCE_USER    (1 << 6)
+/// @}
+
+/// \defgroup define_adjustment_capabilities Display Adjustment Capabilities
+/// Display adjustment capabilities values.  Returned by ADL_Display_AdjustCaps_Get
+/// @{
+#define ADL_DISPLAY_ADJUST_OVERSCAN        (1 << 0)
+#define ADL_DISPLAY_ADJUST_VERT_POS        (1 << 1)
+#define ADL_DISPLAY_ADJUST_HOR_POS        (1 << 2)
+#define ADL_DISPLAY_ADJUST_VERT_SIZE        (1 << 3)
+#define ADL_DISPLAY_ADJUST_HOR_SIZE        (1 << 4)
+#define ADL_DISPLAY_ADJUST_SIZEPOS        (ADL_DISPLAY_ADJUST_VERT_POS | ADL_DISPLAY_ADJUST_HOR_POS | ADL_DISPLAY_ADJUST_VERT_SIZE | ADL_DISPLAY_ADJUST_HOR_SIZE)
+#define ADL_DISPLAY_CUSTOMMODES            (1<<5)
+#define ADL_DISPLAY_ADJUST_UNDERSCAN        (1<<6)
+/// @}
+
+///Down-scale support
+#define ADL_DISPLAY_CAPS_DOWNSCALE        (1 << 0)
+
+/// Sharpness support
+#define ADL_DISPLAY_CAPS_SHARPNESS      (1 << 0)
+
+/// \defgroup define_desktop_config Desktop Configuration Flags
+/// These flags are used by ADL_DesktopConfig_xxx
+/// \deprecated This API has been deprecated because it was only used for RandR 1.1 (Red Hat 5.x) distributions which is now not supported.
+/// @{
+#define ADL_DESKTOPCONFIG_UNKNOWN    0          /* UNKNOWN desktop config   */
+#define ADL_DESKTOPCONFIG_SINGLE     (1 <<  0)    /* Single                   */
+#define ADL_DESKTOPCONFIG_CLONE      (1 <<  2)    /* Clone                    */
+#define ADL_DESKTOPCONFIG_BIGDESK_H  (1 <<  4)    /* Big Desktop Horizontal   */
+#define ADL_DESKTOPCONFIG_BIGDESK_V  (1 <<  5)    /* Big Desktop Vertical     */
+#define ADL_DESKTOPCONFIG_BIGDESK_HR (1 <<  6)    /* Big Desktop Reverse Horz */
+#define ADL_DESKTOPCONFIG_BIGDESK_VR (1 <<  7)    /* Big Desktop Reverse Vert */
+#define ADL_DESKTOPCONFIG_RANDR12    (1 <<  8)    /* RandR 1.2 Multi-display */
+/// @}
+
+/// needed for ADLDDCInfo structure
+#define ADL_MAX_DISPLAY_NAME                                256
+
+/// \defgroup define_edid_flags Values for ulDDCInfoFlag
+/// defines for ulDDCInfoFlag EDID flag
+/// @{
+#define ADL_DISPLAYDDCINFOEX_FLAG_PROJECTORDEVICE       (1 << 0)
+#define ADL_DISPLAYDDCINFOEX_FLAG_EDIDEXTENSION         (1 << 1)
+#define ADL_DISPLAYDDCINFOEX_FLAG_DIGITALDEVICE         (1 << 2)
+#define ADL_DISPLAYDDCINFOEX_FLAG_HDMIAUDIODEVICE       (1 << 3)
+#define ADL_DISPLAYDDCINFOEX_FLAG_SUPPORTS_AI           (1 << 4)
+#define ADL_DISPLAYDDCINFOEX_FLAG_SUPPORT_xvYCC601      (1 << 5)
+#define ADL_DISPLAYDDCINFOEX_FLAG_SUPPORT_xvYCC709      (1 << 6)
+/// @}
+
+/// \defgroup define_displayinfo_connector Display Connector Type
+/// defines for ADLDisplayInfo.iDisplayConnector
+/// @{
+#define ADL_DISPLAY_CONTYPE_UNKNOWN                 0
+#define ADL_DISPLAY_CONTYPE_VGA                     1
+#define ADL_DISPLAY_CONTYPE_DVI_D                   2
+#define ADL_DISPLAY_CONTYPE_DVI_I                   3
+#define ADL_DISPLAY_CONTYPE_ATICVDONGLE_NTSC        4
+#define ADL_DISPLAY_CONTYPE_ATICVDONGLE_JPN         5
+#define ADL_DISPLAY_CONTYPE_ATICVDONGLE_NONI2C_JPN  6
+#define ADL_DISPLAY_CONTYPE_ATICVDONGLE_NONI2C_NTSC 7
+#define ADL_DISPLAY_CONTYPE_PROPRIETARY                8
+#define ADL_DISPLAY_CONTYPE_HDMI_TYPE_A             10
+#define ADL_DISPLAY_CONTYPE_HDMI_TYPE_B             11
+#define ADL_DISPLAY_CONTYPE_SVIDEO                   12
+#define ADL_DISPLAY_CONTYPE_COMPOSITE               13
+#define ADL_DISPLAY_CONTYPE_RCA_3COMPONENT          14
+#define ADL_DISPLAY_CONTYPE_DISPLAYPORT             15
+#define ADL_DISPLAY_CONTYPE_EDP                     16
+#define ADL_DISPLAY_CONTYPE_WIRELESSDISPLAY         17
+#define ADL_DISPLAY_CONTYPE_USB_TYPE_C              18
+/// @}
+
+/// TV Capabilities and Standards
+/// \defgroup define_tv_caps TV Capabilities and Standards
+/// \deprecated Dropping support for TV displays
+/// @{
+#define ADL_TV_STANDARDS            (1 << 0)
+#define ADL_TV_SCART                (1 << 1)
+
+/// TV Standards Definitions
+#define ADL_STANDARD_NTSC_M        (1 << 0)
+#define ADL_STANDARD_NTSC_JPN        (1 << 1)
+#define ADL_STANDARD_NTSC_N        (1 << 2)
+#define ADL_STANDARD_PAL_B        (1 << 3)
+#define ADL_STANDARD_PAL_COMB_N        (1 << 4)
+#define ADL_STANDARD_PAL_D        (1 << 5)
+#define ADL_STANDARD_PAL_G        (1 << 6)
+#define ADL_STANDARD_PAL_H        (1 << 7)
+#define ADL_STANDARD_PAL_I        (1 << 8)
+#define ADL_STANDARD_PAL_K        (1 << 9)
+#define ADL_STANDARD_PAL_K1        (1 << 10)
+#define ADL_STANDARD_PAL_L        (1 << 11)
+#define ADL_STANDARD_PAL_M        (1 << 12)
+#define ADL_STANDARD_PAL_N        (1 << 13)
+#define ADL_STANDARD_PAL_SECAM_D    (1 << 14)
+#define ADL_STANDARD_PAL_SECAM_K    (1 << 15)
+#define ADL_STANDARD_PAL_SECAM_K1    (1 << 16)
+#define ADL_STANDARD_PAL_SECAM_L    (1 << 17)
+/// @}
+
+
+/// \defgroup define_video_custom_mode Video Custom Mode flags
+/// Component Video Custom Mode flags.  This is used by the iFlags parameter in ADLCustomMode
+/// @{
+#define ADL_CUSTOMIZEDMODEFLAG_MODESUPPORTED    (1 << 0)
+#define ADL_CUSTOMIZEDMODEFLAG_NOTDELETETABLE    (1 << 1)
+#define ADL_CUSTOMIZEDMODEFLAG_INSERTBYDRIVER    (1 << 2)
+#define ADL_CUSTOMIZEDMODEFLAG_INTERLACED    (1 << 3)
+#define ADL_CUSTOMIZEDMODEFLAG_BASEMODE        (1 << 4)
+/// @}
+
+/// \defgroup define_ddcinfoflag Values used for DDCInfoFlag
+/// ulDDCInfoFlag field values used by the ADLDDCInfo structure
+/// @{
+#define ADL_DISPLAYDDCINFOEX_FLAG_PROJECTORDEVICE    (1 << 0)
+#define ADL_DISPLAYDDCINFOEX_FLAG_EDIDEXTENSION        (1 << 1)
+#define ADL_DISPLAYDDCINFOEX_FLAG_DIGITALDEVICE        (1 << 2)
+#define ADL_DISPLAYDDCINFOEX_FLAG_HDMIAUDIODEVICE    (1 << 3)
+#define ADL_DISPLAYDDCINFOEX_FLAG_SUPPORTS_AI        (1 << 4)
+#define ADL_DISPLAYDDCINFOEX_FLAG_SUPPORT_xvYCC601    (1 << 5)
+#define ADL_DISPLAYDDCINFOEX_FLAG_SUPPORT_xvYCC709    (1 << 6)
+/// @}
+
+/// \defgroup define_cv_dongle Values used by ADL_CV_DongleSettings_xxx
+/// The following is applicable to ADL_DISPLAY_CONTYPE_ATICVDONGLE_JP and ADL_DISPLAY_CONTYPE_ATICVDONGLE_NONI2C_D only
+/// \deprecated Dropping support for Component Video displays
+/// @{
+#define ADL_DISPLAY_CV_DONGLE_D1          (1 << 0)
+#define ADL_DISPLAY_CV_DONGLE_D2          (1 << 1)
+#define ADL_DISPLAY_CV_DONGLE_D3          (1 << 2)
+#define ADL_DISPLAY_CV_DONGLE_D4          (1 << 3)
+#define ADL_DISPLAY_CV_DONGLE_D5          (1 << 4)
+
+/// The following is applicable to ADL_DISPLAY_CONTYPE_ATICVDONGLE_NA and ADL_DISPLAY_CONTYPE_ATICVDONGLE_NONI2C only
+
+#define ADL_DISPLAY_CV_DONGLE_480I        (1 << 0)
+#define ADL_DISPLAY_CV_DONGLE_480P        (1 << 1)
+#define ADL_DISPLAY_CV_DONGLE_540P        (1 << 2)
+#define ADL_DISPLAY_CV_DONGLE_720P        (1 << 3)
+#define ADL_DISPLAY_CV_DONGLE_1080I       (1 << 4)
+#define ADL_DISPLAY_CV_DONGLE_1080P       (1 << 5)
+#define ADL_DISPLAY_CV_DONGLE_16_9        (1 << 6)
+#define ADL_DISPLAY_CV_DONGLE_720P50      (1 << 7)
+#define ADL_DISPLAY_CV_DONGLE_1080I25     (1 << 8)
+#define ADL_DISPLAY_CV_DONGLE_576I25      (1 << 9)
+#define ADL_DISPLAY_CV_DONGLE_576P50      (1 << 10)
+#define ADL_DISPLAY_CV_DONGLE_1080P24      (1 << 11)
+#define ADL_DISPLAY_CV_DONGLE_1080P25      (1 << 12)
+#define ADL_DISPLAY_CV_DONGLE_1080P30      (1 << 13)
+#define ADL_DISPLAY_CV_DONGLE_1080P50      (1 << 14)
+/// @}
+
+/// \defgroup define_formats_ovr    Formats Override Settings
+/// Display force modes flags
+/// @{
+///
+#define ADL_DISPLAY_FORMAT_FORCE_720P        0x00000001
+#define ADL_DISPLAY_FORMAT_FORCE_1080I        0x00000002
+#define ADL_DISPLAY_FORMAT_FORCE_1080P        0x00000004
+#define ADL_DISPLAY_FORMAT_FORCE_720P50        0x00000008
+#define ADL_DISPLAY_FORMAT_FORCE_1080I25    0x00000010
+#define ADL_DISPLAY_FORMAT_FORCE_576I25        0x00000020
+#define ADL_DISPLAY_FORMAT_FORCE_576P50        0x00000040
+#define ADL_DISPLAY_FORMAT_FORCE_1080P24    0x00000080
+#define ADL_DISPLAY_FORMAT_FORCE_1080P25    0x00000100
+#define ADL_DISPLAY_FORMAT_FORCE_1080P30    0x00000200
+#define ADL_DISPLAY_FORMAT_FORCE_1080P50    0x00000400
+
+///< Below are \b EXTENDED display mode flags
+
+#define ADL_DISPLAY_FORMAT_CVDONGLEOVERIDE  0x00000001
+#define ADL_DISPLAY_FORMAT_CVMODEUNDERSCAN  0x00000002
+#define ADL_DISPLAY_FORMAT_FORCECONNECT_SUPPORTED  0x00000004
+#define ADL_DISPLAY_FORMAT_RESTRICT_FORMAT_SELECTION 0x00000008
+#define ADL_DISPLAY_FORMAT_SETASPECRATIO 0x00000010
+#define ADL_DISPLAY_FORMAT_FORCEMODES    0x00000020
+#define ADL_DISPLAY_FORMAT_LCDRTCCOEFF   0x00000040
+/// @}
+
+/// Defines used by OD5
+#define ADL_PM_PARAM_DONT_CHANGE    0
+
+/// The following defines Bus types
+/// @{
+#define ADL_BUSTYPE_PCI           0       /* PCI bus                          */
+#define ADL_BUSTYPE_AGP           1       /* AGP bus                          */
+#define ADL_BUSTYPE_PCIE          2       /* PCI Express bus                  */
+#define ADL_BUSTYPE_PCIE_GEN2     3       /* PCI Express 2nd generation bus   */
+#define ADL_BUSTYPE_PCIE_GEN3     4       /* PCI Express 3rd generation bus   */
+#define ADL_BUSTYPE_PCIE_GEN4     5       /* PCI Express 4th generation bus   */
+/// @}
+
+/// \defgroup define_ws_caps    Workstation Capabilities
+/// Workstation values
+/// @{
+
+/// This value indicates that the workstation card supports active stereo though stereo output connector
+#define ADL_STEREO_SUPPORTED        (1 << 2)
+/// This value indicates that the workstation card supports active stereo via "blue-line"
+#define ADL_STEREO_BLUE_LINE        (1 << 3)
+/// This value is used to turn off stereo mode.
+#define ADL_STEREO_OFF                0
+/// This value indicates that the workstation card supports active stereo.  This is also used to set the stereo mode to active though the stereo output connector
+#define ADL_STEREO_ACTIVE             (1 << 1)
+/// This value indicates that the workstation card supports auto-stereo monitors with horizontal interleave. This is also used to set the stereo mode to use the auto-stereo monitor with horizontal interleave
+#define ADL_STEREO_AUTO_HORIZONTAL    (1 << 30)
+/// This value indicates that the workstation card supports auto-stereo monitors with vertical interleave. This is also used to set the stereo mode to use the auto-stereo monitor with vertical interleave
+#define ADL_STEREO_AUTO_VERTICAL    (1 << 31)
+/// This value indicates that the workstation card supports passive stereo, ie. non stereo sync
+#define ADL_STEREO_PASSIVE              (1 << 6)
+/// This value indicates that the workstation card supports auto-stereo monitors with vertical interleave. This is also used to set the stereo mode to use the auto-stereo monitor with vertical interleave
+#define ADL_STEREO_PASSIVE_HORIZ        (1 << 7)
+/// This value indicates that the workstation card supports auto-stereo monitors with vertical interleave. This is also used to set the stereo mode to use the auto-stereo monitor with vertical interleave
+#define ADL_STEREO_PASSIVE_VERT         (1 << 8)
+/// This value indicates that the workstation card supports auto-stereo monitors with Samsung.
+#define ADL_STEREO_AUTO_SAMSUNG        (1 << 11)
+/// This value indicates that the workstation card supports auto-stereo monitors with Tridility.
+#define ADL_STEREO_AUTO_TSL         (1 << 12)
+/// This value indicates that the workstation card supports DeepBitDepth (10 bpp)
+#define ADL_DEEPBITDEPTH_10BPP_SUPPORTED   (1 << 5)
+
+/// This value indicates that the workstation supports 8-Bit Grayscale
+#define ADL_8BIT_GREYSCALE_SUPPORTED   (1 << 9)
+/// This value indicates that the workstation supports CUSTOM TIMING
+#define ADL_CUSTOM_TIMING_SUPPORTED   (1 << 10)
+
+/// Load balancing is supported.
+#define ADL_WORKSTATION_LOADBALANCING_SUPPORTED         0x00000001
+/// Load balancing is available.
+#define ADL_WORKSTATION_LOADBALANCING_AVAILABLE         0x00000002
+
+/// Load balancing is disabled.
+#define ADL_WORKSTATION_LOADBALANCING_DISABLED          0x00000000
+/// Load balancing is Enabled.
+#define ADL_WORKSTATION_LOADBALANCING_ENABLED           0x00000001
+
+
+
+/// @}
+
+/// \defgroup define_adapterspeed speed setting from the adapter
+/// @{
+#define ADL_CONTEXT_SPEED_UNFORCED        0        /* default asic running speed */
+#define ADL_CONTEXT_SPEED_FORCEHIGH        1        /* asic running speed is forced to high */
+#define ADL_CONTEXT_SPEED_FORCELOW        2        /* asic running speed is forced to low */
+
+#define ADL_ADAPTER_SPEEDCAPS_SUPPORTED        (1 << 0)    /* change asic running speed setting is supported */
+/// @}
+
+/// \defgroup define_glsync Genlock related values
+/// GL-Sync port types (unique values)
+/// @{
+/// Unknown port of GL-Sync module
+#define ADL_GLSYNC_PORT_UNKNOWN        0
+/// BNC port of of GL-Sync module
+#define ADL_GLSYNC_PORT_BNC            1
+/// RJ45(1) port of of GL-Sync module
+#define ADL_GLSYNC_PORT_RJ45PORT1    2
+/// RJ45(2) port of of GL-Sync module
+#define ADL_GLSYNC_PORT_RJ45PORT2    3
+
+// GL-Sync Genlock settings mask (bit-vector)
+
+/// None of the ADLGLSyncGenlockConfig members are valid
+#define ADL_GLSYNC_CONFIGMASK_NONE                0
+/// The ADLGLSyncGenlockConfig.lSignalSource member is valid
+#define ADL_GLSYNC_CONFIGMASK_SIGNALSOURCE        (1 << 0)
+/// The ADLGLSyncGenlockConfig.iSyncField member is valid
+#define ADL_GLSYNC_CONFIGMASK_SYNCFIELD            (1 << 1)
+/// The ADLGLSyncGenlockConfig.iSampleRate member is valid
+#define ADL_GLSYNC_CONFIGMASK_SAMPLERATE        (1 << 2)
+/// The ADLGLSyncGenlockConfig.lSyncDelay member is valid
+#define ADL_GLSYNC_CONFIGMASK_SYNCDELAY            (1 << 3)
+/// The ADLGLSyncGenlockConfig.iTriggerEdge member is valid
+#define ADL_GLSYNC_CONFIGMASK_TRIGGEREDGE        (1 << 4)
+/// The ADLGLSyncGenlockConfig.iScanRateCoeff member is valid
+#define ADL_GLSYNC_CONFIGMASK_SCANRATECOEFF        (1 << 5)
+/// The ADLGLSyncGenlockConfig.lFramelockCntlVector member is valid
+#define ADL_GLSYNC_CONFIGMASK_FRAMELOCKCNTL        (1 << 6)
+
+
+// GL-Sync Framelock control mask (bit-vector)
+
+/// Framelock is disabled
+#define ADL_GLSYNC_FRAMELOCKCNTL_NONE            0
+/// Framelock is enabled
+#define ADL_GLSYNC_FRAMELOCKCNTL_ENABLE            ( 1 << 0)
+
+#define ADL_GLSYNC_FRAMELOCKCNTL_DISABLE        ( 1 << 1)
+#define ADL_GLSYNC_FRAMELOCKCNTL_SWAP_COUNTER_RESET    ( 1 << 2)
+#define ADL_GLSYNC_FRAMELOCKCNTL_SWAP_COUNTER_ACK    ( 1 << 3)
+#define ADL_GLSYNC_FRAMELOCKCNTL_VERSION_KMD    (1 << 4)
+
+#define ADL_GLSYNC_FRAMELOCKCNTL_STATE_ENABLE        ( 1 << 0)
+#define ADL_GLSYNC_FRAMELOCKCNTL_STATE_KMD        (1 << 4)
+
+// GL-Sync Framelock counters mask (bit-vector)
+#define ADL_GLSYNC_COUNTER_SWAP                ( 1 << 0 )
+
+// GL-Sync Signal Sources (unique values)
+
+/// GL-Sync signal source is undefined
+#define ADL_GLSYNC_SIGNALSOURCE_UNDEFINED    0x00000100
+/// GL-Sync signal source is Free Run
+#define ADL_GLSYNC_SIGNALSOURCE_FREERUN      0x00000101
+/// GL-Sync signal source is the BNC GL-Sync port
+#define ADL_GLSYNC_SIGNALSOURCE_BNCPORT      0x00000102
+/// GL-Sync signal source is the RJ45(1) GL-Sync port
+#define ADL_GLSYNC_SIGNALSOURCE_RJ45PORT1    0x00000103
+/// GL-Sync signal source is the RJ45(2) GL-Sync port
+#define ADL_GLSYNC_SIGNALSOURCE_RJ45PORT2    0x00000104
+
+
+// GL-Sync Signal Types (unique values)
+
+/// GL-Sync signal type is unknown
+#define ADL_GLSYNC_SIGNALTYPE_UNDEFINED      0
+/// GL-Sync signal type is 480I
+#define ADL_GLSYNC_SIGNALTYPE_480I           1
+/// GL-Sync signal type is 576I
+#define ADL_GLSYNC_SIGNALTYPE_576I           2
+/// GL-Sync signal type is 480P
+#define ADL_GLSYNC_SIGNALTYPE_480P           3
+/// GL-Sync signal type is 576P
+#define ADL_GLSYNC_SIGNALTYPE_576P           4
+/// GL-Sync signal type is 720P
+#define ADL_GLSYNC_SIGNALTYPE_720P           5
+/// GL-Sync signal type is 1080P
+#define ADL_GLSYNC_SIGNALTYPE_1080P          6
+/// GL-Sync signal type is 1080I
+#define ADL_GLSYNC_SIGNALTYPE_1080I          7
+/// GL-Sync signal type is SDI
+#define ADL_GLSYNC_SIGNALTYPE_SDI            8
+/// GL-Sync signal type is TTL
+#define ADL_GLSYNC_SIGNALTYPE_TTL            9
+/// GL_Sync signal type is Analog
+#define ADL_GLSYNC_SIGNALTYPE_ANALOG        10
+
+// GL-Sync Sync Field options (unique values)
+
+///GL-Sync sync field option is undefined
+#define ADL_GLSYNC_SYNCFIELD_UNDEFINED        0
+///GL-Sync sync field option is Sync to Field 1 (used for Interlaced signal types)
+#define ADL_GLSYNC_SYNCFIELD_BOTH            1
+///GL-Sync sync field option is Sync to Both fields (used for Interlaced signal types)
+#define ADL_GLSYNC_SYNCFIELD_1                2
+
+
+// GL-Sync trigger edge options (unique values)
+
+/// GL-Sync trigger edge is undefined
+#define ADL_GLSYNC_TRIGGEREDGE_UNDEFINED     0
+/// GL-Sync trigger edge is the rising edge
+#define ADL_GLSYNC_TRIGGEREDGE_RISING        1
+/// GL-Sync trigger edge is the falling edge
+#define ADL_GLSYNC_TRIGGEREDGE_FALLING       2
+/// GL-Sync trigger edge is both the rising and the falling edge
+#define ADL_GLSYNC_TRIGGEREDGE_BOTH          3
+
+
+// GL-Sync scan rate coefficient/multiplier options (unique values)
+
+/// GL-Sync scan rate coefficient/multiplier is undefined
+#define ADL_GLSYNC_SCANRATECOEFF_UNDEFINED   0
+/// GL-Sync scan rate coefficient/multiplier is 5
+#define ADL_GLSYNC_SCANRATECOEFF_x5          1
+/// GL-Sync scan rate coefficient/multiplier is 4
+#define ADL_GLSYNC_SCANRATECOEFF_x4          2
+/// GL-Sync scan rate coefficient/multiplier is 3
+#define ADL_GLSYNC_SCANRATECOEFF_x3          3
+/// GL-Sync scan rate coefficient/multiplier is 5:2 (SMPTE)
+#define ADL_GLSYNC_SCANRATECOEFF_x5_DIV_2    4
+/// GL-Sync scan rate coefficient/multiplier is 2
+#define ADL_GLSYNC_SCANRATECOEFF_x2          5
+/// GL-Sync scan rate coefficient/multiplier is 3 : 2
+#define ADL_GLSYNC_SCANRATECOEFF_x3_DIV_2    6
+/// GL-Sync scan rate coefficient/multiplier is 5 : 4
+#define ADL_GLSYNC_SCANRATECOEFF_x5_DIV_4    7
+/// GL-Sync scan rate coefficient/multiplier is 1 (default)
+#define ADL_GLSYNC_SCANRATECOEFF_x1          8
+/// GL-Sync scan rate coefficient/multiplier is 4 : 5
+#define ADL_GLSYNC_SCANRATECOEFF_x4_DIV_5    9
+/// GL-Sync scan rate coefficient/multiplier is 2 : 3
+#define ADL_GLSYNC_SCANRATECOEFF_x2_DIV_3    10
+/// GL-Sync scan rate coefficient/multiplier is 1 : 2
+#define ADL_GLSYNC_SCANRATECOEFF_x1_DIV_2    11
+/// GL-Sync scan rate coefficient/multiplier is 2 : 5 (SMPTE)
+#define ADL_GLSYNC_SCANRATECOEFF_x2_DIV_5    12
+/// GL-Sync scan rate coefficient/multiplier is 1 : 3
+#define ADL_GLSYNC_SCANRATECOEFF_x1_DIV_3    13
+/// GL-Sync scan rate coefficient/multiplier is 1 : 4
+#define ADL_GLSYNC_SCANRATECOEFF_x1_DIV_4    14
+/// GL-Sync scan rate coefficient/multiplier is 1 : 5
+#define ADL_GLSYNC_SCANRATECOEFF_x1_DIV_5    15
+
+
+// GL-Sync port (signal presence) states (unique values)
+
+/// GL-Sync port state is undefined
+#define ADL_GLSYNC_PORTSTATE_UNDEFINED       0
+/// GL-Sync port is not connected
+#define ADL_GLSYNC_PORTSTATE_NOCABLE         1
+/// GL-Sync port is Idle
+#define ADL_GLSYNC_PORTSTATE_IDLE            2
+/// GL-Sync port has an Input signal
+#define ADL_GLSYNC_PORTSTATE_INPUT           3
+/// GL-Sync port is Output
+#define ADL_GLSYNC_PORTSTATE_OUTPUT          4
+
+
+// GL-Sync LED types (used index within ADL_Workstation_GLSyncPortState_Get returned ppGlSyncLEDs array) (unique values)
+
+/// Index into the ADL_Workstation_GLSyncPortState_Get returned ppGlSyncLEDs array for the one LED of the BNC port
+#define ADL_GLSYNC_LEDTYPE_BNC               0
+/// Index into the ADL_Workstation_GLSyncPortState_Get returned ppGlSyncLEDs array for the Left LED of the RJ45(1) or RJ45(2) port
+#define ADL_GLSYNC_LEDTYPE_RJ45_LEFT         0
+/// Index into the ADL_Workstation_GLSyncPortState_Get returned ppGlSyncLEDs array for the Right LED of the RJ45(1) or RJ45(2) port
+#define ADL_GLSYNC_LEDTYPE_RJ45_RIGHT        1
+
+
+// GL-Sync LED colors (unique values)
+
+/// GL-Sync LED undefined color
+#define ADL_GLSYNC_LEDCOLOR_UNDEFINED        0
+/// GL-Sync LED is unlit
+#define ADL_GLSYNC_LEDCOLOR_NOLIGHT          1
+/// GL-Sync LED is yellow
+#define ADL_GLSYNC_LEDCOLOR_YELLOW           2
+/// GL-Sync LED is red
+#define ADL_GLSYNC_LEDCOLOR_RED              3
+/// GL-Sync LED is green
+#define ADL_GLSYNC_LEDCOLOR_GREEN            4
+/// GL-Sync LED is flashing green
+#define ADL_GLSYNC_LEDCOLOR_FLASH_GREEN      5
+
+
+// GL-Sync Port Control (refers one GL-Sync Port) (unique values)
+
+/// Used to configure the RJ54(1) or RJ42(2) port of GL-Sync is as Idle
+#define ADL_GLSYNC_PORTCNTL_NONE             0x00000000
+/// Used to configure the RJ54(1) or RJ42(2) port of GL-Sync is as Output
+#define ADL_GLSYNC_PORTCNTL_OUTPUT           0x00000001
+
+
+// GL-Sync Mode Control (refers one Display/Controller) (bitfields)
+
+/// Used to configure the display to use internal timing (not genlocked)
+#define ADL_GLSYNC_MODECNTL_NONE             0x00000000
+/// Bitfield used to configure the display as genlocked (either as Timing Client or as Timing Server)
+#define ADL_GLSYNC_MODECNTL_GENLOCK          0x00000001
+/// Bitfield used to configure the display as Timing Server
+#define ADL_GLSYNC_MODECNTL_TIMINGSERVER     0x00000002
+
+// GL-Sync Mode Status
+/// Display is currently not genlocked
+#define ADL_GLSYNC_MODECNTL_STATUS_NONE         0x00000000
+/// Display is currently genlocked
+#define ADL_GLSYNC_MODECNTL_STATUS_GENLOCK   0x00000001
+/// Display requires a mode switch
+#define ADL_GLSYNC_MODECNTL_STATUS_SETMODE_REQUIRED 0x00000002
+/// Display is capable of being genlocked
+#define ADL_GLSYNC_MODECNTL_STATUS_GENLOCK_ALLOWED 0x00000004
+
+#define ADL_MAX_GLSYNC_PORTS                            8
+#define ADL_MAX_GLSYNC_PORT_LEDS                        8
+
+/// @}
+
+/// \defgroup define_crossfirestate CrossfireX state of a particular adapter CrossfireX combination
+/// @{
+#define ADL_XFIREX_STATE_NOINTERCONNECT            ( 1 << 0 )    /* Dongle / cable is missing */
+#define ADL_XFIREX_STATE_DOWNGRADEPIPES            ( 1 << 1 )    /* CrossfireX can be enabled if pipes are downgraded */
+#define ADL_XFIREX_STATE_DOWNGRADEMEM            ( 1 << 2 )    /* CrossfireX cannot be enabled unless mem downgraded */
+#define ADL_XFIREX_STATE_REVERSERECOMMENDED        ( 1 << 3 )    /* Card reversal recommended, CrossfireX cannot be enabled. */
+#define ADL_XFIREX_STATE_3DACTIVE            ( 1 << 4 )    /* 3D client is active - CrossfireX cannot be safely enabled */
+#define ADL_XFIREX_STATE_MASTERONSLAVE            ( 1 << 5 )    /* Dongle is OK but master is on slave */
+#define ADL_XFIREX_STATE_NODISPLAYCONNECT        ( 1 << 6 )    /* No (valid) display connected to master card. */
+#define ADL_XFIREX_STATE_NOPRIMARYVIEW            ( 1 << 7 )    /* CrossfireX is enabled but master is not current primary device */
+#define ADL_XFIREX_STATE_DOWNGRADEVISMEM        ( 1 << 8 )    /* CrossfireX cannot be enabled unless visible mem downgraded */
+#define ADL_XFIREX_STATE_LESSTHAN8LANE_MASTER        ( 1 << 9 )     /* CrossfireX can be enabled however performance not optimal due to <8 lanes */
+#define ADL_XFIREX_STATE_LESSTHAN8LANE_SLAVE        ( 1 << 10 )    /* CrossfireX can be enabled however performance not optimal due to <8 lanes */
+#define ADL_XFIREX_STATE_PEERTOPEERFAILED        ( 1 << 11 )    /* CrossfireX cannot be enabled due to failed peer to peer test */
+#define ADL_XFIREX_STATE_MEMISDOWNGRADED        ( 1 << 16 )    /* Notification that memory is currently downgraded */
+#define ADL_XFIREX_STATE_PIPESDOWNGRADED        ( 1 << 17 )    /* Notification that pipes are currently downgraded */
+#define ADL_XFIREX_STATE_XFIREXACTIVE            ( 1 << 18 )    /* CrossfireX is enabled on current device */
+#define ADL_XFIREX_STATE_VISMEMISDOWNGRADED        ( 1 << 19 )    /* Notification that visible FB memory is currently downgraded */
+#define ADL_XFIREX_STATE_INVALIDINTERCONNECTION        ( 1 << 20 )    /* Cannot support current inter-connection configuration */
+#define ADL_XFIREX_STATE_NONP2PMODE            ( 1 << 21 )    /* CrossfireX will only work with clients supporting non P2P mode */
+#define ADL_XFIREX_STATE_DOWNGRADEMEMBANKS        ( 1 << 22 )    /* CrossfireX cannot be enabled unless memory banks downgraded */
+#define ADL_XFIREX_STATE_MEMBANKSDOWNGRADED        ( 1 << 23 )    /* Notification that memory banks are currently downgraded */
+#define ADL_XFIREX_STATE_DUALDISPLAYSALLOWED        ( 1 << 24 )    /* Extended desktop or clone mode is allowed. */
+#define ADL_XFIREX_STATE_P2P_APERTURE_MAPPING        ( 1 << 25 )    /* P2P mapping was through peer aperture */
+#define ADL_XFIREX_STATE_P2PFLUSH_REQUIRED        ADL_XFIREX_STATE_P2P_APERTURE_MAPPING    /* For back compatible */
+#define ADL_XFIREX_STATE_XSP_CONNECTED            ( 1 << 26 )    /* There is CrossfireX side port connection between GPUs */
+#define ADL_XFIREX_STATE_ENABLE_CF_REBOOT_REQUIRED    ( 1 << 27 )    /* System needs a reboot bofore enable CrossfireX */
+#define ADL_XFIREX_STATE_DISABLE_CF_REBOOT_REQUIRED    ( 1 << 28 )    /* System needs a reboot after disable CrossfireX */
+#define ADL_XFIREX_STATE_DRV_HANDLE_DOWNGRADE_KEY    ( 1 << 29 )    /* Indicate base driver handles the downgrade key updating */
+#define ADL_XFIREX_STATE_CF_RECONFIG_REQUIRED        ( 1 << 30 )    /* CrossfireX need to be reconfigured by CCC because of a LDA chain broken */
+#define ADL_XFIREX_STATE_ERRORGETTINGSTATUS        ( 1 << 31 )    /* Could not obtain current status */
+/// @}
+
+///////////////////////////////////////////////////////////////////////////
+// ADL_DISPLAY_ADJUSTMENT_PIXELFORMAT adjustment values
+// (bit-vector)
+///////////////////////////////////////////////////////////////////////////
+/// \defgroup define_pixel_formats Pixel Formats values
+/// This group defines the various Pixel Formats that a particular digital display can support. \n
+/// Since a display can support multiple formats, these values can be bit-or'ed to indicate the various formats \n
+/// @{
+#define ADL_DISPLAY_PIXELFORMAT_UNKNOWN             0
+#define ADL_DISPLAY_PIXELFORMAT_RGB                       (1 << 0)
+#define ADL_DISPLAY_PIXELFORMAT_YCRCB444                  (1 << 1)    //Limited range
+#define ADL_DISPLAY_PIXELFORMAT_YCRCB422                 (1 << 2)    //Limited range
+#define ADL_DISPLAY_PIXELFORMAT_RGB_LIMITED_RANGE      (1 << 3)
+#define ADL_DISPLAY_PIXELFORMAT_RGB_FULL_RANGE    ADL_DISPLAY_PIXELFORMAT_RGB  //Full range
+#define ADL_DISPLAY_PIXELFORMAT_YCRCB420              (1 << 4)
+/// @}
+
+/// \defgroup define_contype Connector Type Values
+/// ADLDisplayConfig.ulConnectorType defines
+/// @{
+#define ADL_DL_DISPLAYCONFIG_CONTYPE_UNKNOWN      0
+#define ADL_DL_DISPLAYCONFIG_CONTYPE_CV_NONI2C_JP 1
+#define ADL_DL_DISPLAYCONFIG_CONTYPE_CV_JPN       2
+#define ADL_DL_DISPLAYCONFIG_CONTYPE_CV_NA        3
+#define ADL_DL_DISPLAYCONFIG_CONTYPE_CV_NONI2C_NA 4
+#define ADL_DL_DISPLAYCONFIG_CONTYPE_VGA          5
+#define ADL_DL_DISPLAYCONFIG_CONTYPE_DVI_D        6
+#define ADL_DL_DISPLAYCONFIG_CONTYPE_DVI_I        7
+#define ADL_DL_DISPLAYCONFIG_CONTYPE_HDMI_TYPE_A  8
+#define ADL_DL_DISPLAYCONFIG_CONTYPE_HDMI_TYPE_B  9
+#define ADL_DL_DISPLAYCONFIG_CONTYPE_DISPLAYPORT  10
+/// @}
+
+///////////////////////////////////////////////////////////////////////////
+// ADL_DISPLAY_DISPLAYINFO_ Definitions
+// for ADLDisplayInfo.iDisplayInfoMask and ADLDisplayInfo.iDisplayInfoValue
+// (bit-vector)
+///////////////////////////////////////////////////////////////////////////
+/// \defgroup define_displayinfomask Display Info Mask Values
+/// @{
+#define ADL_DISPLAY_DISPLAYINFO_DISPLAYCONNECTED            0x00000001
+#define ADL_DISPLAY_DISPLAYINFO_DISPLAYMAPPED                0x00000002
+#define ADL_DISPLAY_DISPLAYINFO_NONLOCAL                    0x00000004
+#define ADL_DISPLAY_DISPLAYINFO_FORCIBLESUPPORTED            0x00000008
+#define ADL_DISPLAY_DISPLAYINFO_GENLOCKSUPPORTED            0x00000010
+#define ADL_DISPLAY_DISPLAYINFO_MULTIVPU_SUPPORTED            0x00000020
+#define ADL_DISPLAY_DISPLAYINFO_LDA_DISPLAY                    0x00000040
+#define ADL_DISPLAY_DISPLAYINFO_MODETIMING_OVERRIDESSUPPORTED            0x00000080
+
+#define ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_SINGLE            0x00000100
+#define ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_CLONE            0x00000200
+
+/// Legacy support for XP
+#define ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_2VSTRETCH        0x00000400
+#define ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_2HSTRETCH        0x00000800
+#define ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_EXTENDED        0x00001000
+
+/// More support manners
+#define ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_NSTRETCH1GPU    0x00010000
+#define ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_NSTRETCHNGPU    0x00020000
+#define ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_RESERVED2        0x00040000
+#define ADL_DISPLAY_DISPLAYINFO_MANNER_SUPPORTED_RESERVED3        0x00080000
+
+/// Projector display type
+#define ADL_DISPLAY_DISPLAYINFO_SHOWTYPE_PROJECTOR                0x00100000
+
+/// @}
+
+
+///////////////////////////////////////////////////////////////////////////
+// ADL_ADAPTER_DISPLAY_MANNER_SUPPORTED_ Definitions
+// for ADLAdapterDisplayCap of ADL_Adapter_Display_Cap()
+// (bit-vector)
+///////////////////////////////////////////////////////////////////////////
+/// \defgroup define_adaptermanner Adapter Manner Support Values
+/// @{
+#define ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_NOTACTIVE        0x00000001
+#define ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_SINGLE            0x00000002
+#define ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_CLONE            0x00000004
+#define ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_NSTRETCH1GPU    0x00000008
+#define ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_NSTRETCHNGPU    0x00000010
+
+/// Legacy support for XP
+#define ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_2VSTRETCH        0x00000020
+#define ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_2HSTRETCH        0x00000040
+#define ADL_ADAPTER_DISPLAYCAP_MANNER_SUPPORTED_EXTENDED        0x00000080
+
+#define ADL_ADAPTER_DISPLAYCAP_PREFERDISPLAY_SUPPORTED            0x00000100
+#define ADL_ADAPTER_DISPLAYCAP_BEZEL_SUPPORTED                    0x00000200
+
+
+///////////////////////////////////////////////////////////////////////////
+// ADL_DISPLAY_DISPLAYMAP_MANNER_ Definitions
+// for ADLDisplayMap.iDisplayMapMask and ADLDisplayMap.iDisplayMapValue
+// (bit-vector)
+///////////////////////////////////////////////////////////////////////////
+#define ADL_DISPLAY_DISPLAYMAP_MANNER_RESERVED            0x00000001
+#define ADL_DISPLAY_DISPLAYMAP_MANNER_NOTACTIVE            0x00000002
+#define ADL_DISPLAY_DISPLAYMAP_MANNER_SINGLE            0x00000004
+#define ADL_DISPLAY_DISPLAYMAP_MANNER_CLONE                0x00000008
+#define ADL_DISPLAY_DISPLAYMAP_MANNER_RESERVED1            0x00000010  // Removed NSTRETCH
+#define ADL_DISPLAY_DISPLAYMAP_MANNER_HSTRETCH            0x00000020
+#define ADL_DISPLAY_DISPLAYMAP_MANNER_VSTRETCH            0x00000040
+#define ADL_DISPLAY_DISPLAYMAP_MANNER_VLD                0x00000080
+
+/// @}
+
+///////////////////////////////////////////////////////////////////////////
+// ADL_DISPLAY_DISPLAYMAP_OPTION_ Definitions
+// for iOption in function ADL_Display_DisplayMapConfig_Get
+// (bit-vector)
+///////////////////////////////////////////////////////////////////////////
+#define ADL_DISPLAY_DISPLAYMAP_OPTION_GPUINFO            0x00000001
+
+///////////////////////////////////////////////////////////////////////////
+// ADL_DISPLAY_DISPLAYTARGET_ Definitions
+// for ADLDisplayTarget.iDisplayTargetMask and ADLDisplayTarget.iDisplayTargetValue
+// (bit-vector)
+///////////////////////////////////////////////////////////////////////////
+#define ADL_DISPLAY_DISPLAYTARGET_PREFERRED            0x00000001
+
+///////////////////////////////////////////////////////////////////////////
+// ADL_DISPLAY_POSSIBLEMAPRESULT_VALID Definitions
+// for ADLPossibleMapResult.iPossibleMapResultMask and ADLPossibleMapResult.iPossibleMapResultValue
+// (bit-vector)
+///////////////////////////////////////////////////////////////////////////
+#define ADL_DISPLAY_POSSIBLEMAPRESULT_VALID                0x00000001
+#define ADL_DISPLAY_POSSIBLEMAPRESULT_BEZELSUPPORTED    0x00000002
+#define ADL_DISPLAY_POSSIBLEMAPRESULT_OVERLAPSUPPORTED    0x00000004
+
+///////////////////////////////////////////////////////////////////////////
+// ADL_DISPLAY_MODE_ Definitions
+// for ADLMode.iModeMask, ADLMode.iModeValue, and ADLMode.iModeFlag
+// (bit-vector)
+///////////////////////////////////////////////////////////////////////////
+/// \defgroup define_displaymode Display Mode Values
+/// @{
+#define ADL_DISPLAY_MODE_COLOURFORMAT_565                0x00000001
+#define ADL_DISPLAY_MODE_COLOURFORMAT_8888                0x00000002
+#define ADL_DISPLAY_MODE_ORIENTATION_SUPPORTED_000        0x00000004
+#define ADL_DISPLAY_MODE_ORIENTATION_SUPPORTED_090        0x00000008
+#define ADL_DISPLAY_MODE_ORIENTATION_SUPPORTED_180        0x00000010
+#define ADL_DISPLAY_MODE_ORIENTATION_SUPPORTED_270        0x00000020
+#define ADL_DISPLAY_MODE_REFRESHRATE_ROUNDED            0x00000040
+#define ADL_DISPLAY_MODE_REFRESHRATE_ONLY                0x00000080
+
+#define ADL_DISPLAY_MODE_PROGRESSIVE_FLAG    0
+#define ADL_DISPLAY_MODE_INTERLACED_FLAG    2
+/// @}
+
+///////////////////////////////////////////////////////////////////////////
+// ADL_OSMODEINFO Definitions
+///////////////////////////////////////////////////////////////////////////
+/// \defgroup define_osmode OS Mode Values
+/// @{
+#define ADL_OSMODEINFOXPOS_DEFAULT                -640
+#define ADL_OSMODEINFOYPOS_DEFAULT                0
+#define ADL_OSMODEINFOXRES_DEFAULT                640
+#define ADL_OSMODEINFOYRES_DEFAULT                480
+#define ADL_OSMODEINFOXRES_DEFAULT800            800
+#define ADL_OSMODEINFOYRES_DEFAULT600            600
+#define ADL_OSMODEINFOREFRESHRATE_DEFAULT        60
+#define ADL_OSMODEINFOCOLOURDEPTH_DEFAULT        8
+#define ADL_OSMODEINFOCOLOURDEPTH_DEFAULT16        16
+#define ADL_OSMODEINFOCOLOURDEPTH_DEFAULT24        24
+#define ADL_OSMODEINFOCOLOURDEPTH_DEFAULT32        32
+#define ADL_OSMODEINFOORIENTATION_DEFAULT        0
+#define ADL_OSMODEINFOORIENTATION_DEFAULT_WIN7    DISPLAYCONFIG_ROTATION_FORCE_UINT32
+#define ADL_OSMODEFLAG_DEFAULT                    0
+/// @}
+
+///////////////////////////////////////////////////////////////////////////
+// ADLThreadingModel Enumeration
+///////////////////////////////////////////////////////////////////////////
+/// \defgroup thread_model
+/// Used with \ref ADL_Main_ControlX2_Create and \ref ADL2_Main_ControlX2_Create to specify how ADL handles API calls when executed by multiple threads concurrently.
+/// \brief Declares ADL threading behavior.
+/// @{
+typedef enum ADLThreadingModel
+{
+    ADL_THREADING_UNLOCKED    = 0, /*!< Default behavior. ADL will not enforce serialization of ADL API executions by multiple threads.  Multiple threads will be allowed to enter to ADL at the same time. Note that ADL library is not guaranteed to be thread-safe. Client that calls ADL_Main_Control_Create have to provide its own mechanism for ADL calls serialization. */
+    ADL_THREADING_LOCKED     /*!< ADL will enforce serialization of ADL API when called by multiple threads.  Only single thread will be allowed to enter ADL API at the time. This option makes ADL calls thread-safe. You shouldn't use this option if ADL calls will be executed on Linux on x-server rendering thread. It can cause the application to hung.  */
+}ADLThreadingModel;
+
+/// @}
+///////////////////////////////////////////////////////////////////////////
+// ADLPurposeCode Enumeration
+///////////////////////////////////////////////////////////////////////////
+enum ADLPurposeCode
+{
+    ADL_PURPOSECODE_NORMAL    = 0,
+    ADL_PURPOSECODE_HIDE_MODE_SWITCH,
+    ADL_PURPOSECODE_MODE_SWITCH,
+    ADL_PURPOSECODE_ATTATCH_DEVICE,
+    ADL_PURPOSECODE_DETACH_DEVICE,
+    ADL_PURPOSECODE_SETPRIMARY_DEVICE,
+    ADL_PURPOSECODE_GDI_ROTATION,
+    ADL_PURPOSECODE_ATI_ROTATION
+};
+///////////////////////////////////////////////////////////////////////////
+// ADLAngle Enumeration
+///////////////////////////////////////////////////////////////////////////
+enum ADLAngle
+{
+    ADL_ANGLE_LANDSCAPE = 0,
+    ADL_ANGLE_ROTATERIGHT = 90,
+    ADL_ANGLE_ROTATE180 = 180,
+    ADL_ANGLE_ROTATELEFT = 270,
+};
+
+///////////////////////////////////////////////////////////////////////////
+// ADLOrientationDataType Enumeration
+///////////////////////////////////////////////////////////////////////////
+enum ADLOrientationDataType
+{
+    ADL_ORIENTATIONTYPE_OSDATATYPE,
+    ADL_ORIENTATIONTYPE_NONOSDATATYPE
+};
+
+///////////////////////////////////////////////////////////////////////////
+// ADLPanningMode Enumeration
+///////////////////////////////////////////////////////////////////////////
+enum ADLPanningMode
+{
+    ADL_PANNINGMODE_NO_PANNING = 0,
+    ADL_PANNINGMODE_AT_LEAST_ONE_NO_PANNING = 1,
+    ADL_PANNINGMODE_ALLOW_PANNING = 2,
+};
+
+///////////////////////////////////////////////////////////////////////////
+// ADLLARGEDESKTOPTYPE Enumeration
+///////////////////////////////////////////////////////////////////////////
+enum ADLLARGEDESKTOPTYPE
+{
+    ADL_LARGEDESKTOPTYPE_NORMALDESKTOP = 0,
+    ADL_LARGEDESKTOPTYPE_PSEUDOLARGEDESKTOP = 1,
+    ADL_LARGEDESKTOPTYPE_VERYLARGEDESKTOP = 2
+};
+
+///////////////////////////////////////////////////////////////////////////
+// ADLPlatform Enumeration
+///////////////////////////////////////////////////////////////////////////
+enum ADLPlatForm
+{
+    GRAPHICS_PLATFORM_DESKTOP  = 0,
+    GRAPHICS_PLATFORM_MOBILE   = 1
+};
+
+///////////////////////////////////////////////////////////////////////////
+// ADLGraphicCoreGeneration Enumeration
+///////////////////////////////////////////////////////////////////////////
+enum ADLGraphicCoreGeneration
+{
+    ADL_GRAPHIC_CORE_GENERATION_UNDEFINED                   = 0,
+    ADL_GRAPHIC_CORE_GENERATION_PRE_GCN                     = 1,
+    ADL_GRAPHIC_CORE_GENERATION_GCN                         = 2,
+    ADL_GRAPHIC_CORE_GENERATION_RDNA                        = 3
+};
+
+// Other Definitions for internal use
+
+// Values for ADL_Display_WriteAndReadI2CRev_Get()
+
+#define ADL_I2C_MAJOR_API_REV           0x00000001
+#define ADL_I2C_MINOR_DEFAULT_API_REV   0x00000000
+#define ADL_I2C_MINOR_OEM_API_REV       0x00000001
+
+// Values for ADL_Display_WriteAndReadI2C()
+#define ADL_DL_I2C_LINE_OEM                0x00000001
+#define ADL_DL_I2C_LINE_OD_CONTROL         0x00000002
+#define ADL_DL_I2C_LINE_OEM2               0x00000003
+#define ADL_DL_I2C_LINE_OEM3               0x00000004
+#define ADL_DL_I2C_LINE_OEM4               0x00000005
+#define ADL_DL_I2C_LINE_OEM5               0x00000006
+#define ADL_DL_I2C_LINE_OEM6               0x00000007
+#define ADL_DL_I2C_LINE_GPIO               0x00000008
+
+// Max size of I2C data buffer
+#define ADL_DL_I2C_MAXDATASIZE             0x00000018
+#define ADL_DL_I2C_MAXWRITEDATASIZE        0x0000000C
+#define ADL_DL_I2C_MAXADDRESSLENGTH        0x00000006
+#define ADL_DL_I2C_MAXOFFSETLENGTH         0x00000004
+
+// I2C clock speed in KHz
+#define ADL_DL_I2C_SPEED_50K               50
+#define ADL_DL_I2C_SPEED_100K              100
+#define ALD_DL_I2C_SPEED_400K              400
+#define ADL_DL_I2C_SPEED_1M                1000
+#define ADL_DL_I2C_SPEED_2M                2300
+
+/// Values for ADLDisplayProperty.iPropertyType
+#define ADL_DL_DISPLAYPROPERTY_TYPE_UNKNOWN              0
+#define ADL_DL_DISPLAYPROPERTY_TYPE_EXPANSIONMODE        1
+#define ADL_DL_DISPLAYPROPERTY_TYPE_USEUNDERSCANSCALING     2
+/// Enables ITC processing for HDMI panels that are capable of the feature
+#define ADL_DL_DISPLAYPROPERTY_TYPE_ITCFLAGENABLE        9
+#define ADL_DL_DISPLAYPROPERTY_TYPE_DOWNSCALE            11
+#define ADL_DL_DISPLAYPROPERTY_TYPE_INTEGER_SCALING      12
+
+
+/// Values for ADLDisplayContent.iContentType
+/// Certain HDMI panels that support ITC have support for a feature such that, the display on the panel
+/// can be adjusted to optimize the view of the content being displayed, depending on the type of content.
+#define ADL_DL_DISPLAYCONTENT_TYPE_GRAPHICS        1
+#define ADL_DL_DISPLAYCONTENT_TYPE_PHOTO        2
+#define ADL_DL_DISPLAYCONTENT_TYPE_CINEMA        4
+#define ADL_DL_DISPLAYCONTENT_TYPE_GAME            8
+
+
+
+//values for ADLDisplayProperty.iExpansionMode
+#define ADL_DL_DISPLAYPROPERTY_EXPANSIONMODE_CENTER        0
+#define ADL_DL_DISPLAYPROPERTY_EXPANSIONMODE_FULLSCREEN    1
+#define ADL_DL_DISPLAYPROPERTY_EXPANSIONMODE_ASPECTRATIO   2
+
+
+///\defgroup define_dither_states Dithering options
+/// @{
+/// Dithering disabled.
+#define ADL_DL_DISPLAY_DITHER_DISABLED              0
+/// Use default driver settings for dithering. Note that the default setting could be dithering disabled.
+#define ADL_DL_DISPLAY_DITHER_DRIVER_DEFAULT        1
+/// Temporal dithering to 6 bpc. Note that if the input is 12 bits, the two least significant bits will be truncated.
+#define ADL_DL_DISPLAY_DITHER_FM6                   2
+/// Temporal dithering to 8 bpc.
+#define ADL_DL_DISPLAY_DITHER_FM8                   3
+/// Temporal dithering to 10 bpc.
+#define ADL_DL_DISPLAY_DITHER_FM10                  4
+/// Spatial dithering to 6 bpc. Note that if the input is 12 bits, the two least significant bits will be truncated.
+#define ADL_DL_DISPLAY_DITHER_DITH6                 5
+/// Spatial dithering to 8 bpc.
+#define ADL_DL_DISPLAY_DITHER_DITH8                 6
+/// Spatial dithering to 10 bpc.
+#define ADL_DL_DISPLAY_DITHER_DITH10                7
+/// Spatial dithering to 6 bpc. Random number generators are reset every frame, so the same input value of a certain pixel will always be dithered to the same output value. Note that if the input is 12 bits, the two least significant bits will be truncated.
+#define ADL_DL_DISPLAY_DITHER_DITH6_NO_FRAME_RAND   8
+/// Spatial dithering to 8 bpc. Random number generators are reset every frame, so the same input value of a certain pixel will always be dithered to the same output value.
+#define ADL_DL_DISPLAY_DITHER_DITH8_NO_FRAME_RAND   9
+/// Spatial dithering to 10 bpc. Random number generators are reset every frame, so the same input value of a certain pixel will always be dithered to the same output value.
+#define ADL_DL_DISPLAY_DITHER_DITH10_NO_FRAME_RAND  10
+/// Truncation to 6 bpc.
+#define ADL_DL_DISPLAY_DITHER_TRUN6                 11
+/// Truncation to 8 bpc.
+#define ADL_DL_DISPLAY_DITHER_TRUN8                 12
+/// Truncation to 10 bpc.
+#define ADL_DL_DISPLAY_DITHER_TRUN10                13
+/// Truncation to 10 bpc followed by spatial dithering to 8 bpc.
+#define ADL_DL_DISPLAY_DITHER_TRUN10_DITH8          14
+/// Truncation to 10 bpc followed by spatial dithering to 6 bpc.
+#define ADL_DL_DISPLAY_DITHER_TRUN10_DITH6          15
+/// Truncation to 10 bpc followed by temporal dithering to 8 bpc.
+#define ADL_DL_DISPLAY_DITHER_TRUN10_FM8            16
+/// Truncation to 10 bpc followed by temporal dithering to 6 bpc.
+#define ADL_DL_DISPLAY_DITHER_TRUN10_FM6            17
+/// Truncation to 10 bpc followed by spatial dithering to 8 bpc and temporal dithering to 6 bpc.
+#define ADL_DL_DISPLAY_DITHER_TRUN10_DITH8_FM6      18
+/// Spatial dithering to 10 bpc followed by temporal dithering to 8 bpc.
+#define ADL_DL_DISPLAY_DITHER_DITH10_FM8            19
+/// Spatial dithering to 10 bpc followed by temporal dithering to 6 bpc.
+#define ADL_DL_DISPLAY_DITHER_DITH10_FM6            20
+/// Truncation to 8 bpc followed by spatial dithering to 6 bpc.
+#define ADL_DL_DISPLAY_DITHER_TRUN8_DITH6           21
+/// Truncation to 8 bpc followed by temporal dithering to 6 bpc.
+#define ADL_DL_DISPLAY_DITHER_TRUN8_FM6             22
+/// Spatial dithering to 8 bpc followed by temporal dithering to 6 bpc.
+#define ADL_DL_DISPLAY_DITHER_DITH8_FM6             23
+#define ADL_DL_DISPLAY_DITHER_LAST                  ADL_DL_DISPLAY_DITHER_DITH8_FM6
+/// @}
+
+
+/// Display Get Cached EDID flag
+#define ADL_MAX_EDIDDATA_SIZE              256 // number of UCHAR
+#define ADL_MAX_OVERRIDEEDID_SIZE          512 // number of UCHAR
+#define ADL_MAX_EDID_EXTENSION_BLOCKS      3
+
+#define ADL_DL_CONTROLLER_OVERLAY_ALPHA         0
+#define ADL_DL_CONTROLLER_OVERLAY_ALPHAPERPIX   1
+
+#define ADL_DL_DISPLAY_DATA_PACKET__INFO_PACKET_RESET      0x00000000
+#define ADL_DL_DISPLAY_DATA_PACKET__INFO_PACKET_SET        0x00000001
+#define ADL_DL_DISPLAY_DATA_PACKET__INFO_PACKET_SCAN       0x00000002
+
+///\defgroup define_display_packet Display Data Packet Types
+/// @{
+#define ADL_DL_DISPLAY_DATA_PACKET__TYPE__AVI              0x00000001
+#define ADL_DL_DISPLAY_DATA_PACKET__TYPE__GAMMUT           0x00000002
+#define ADL_DL_DISPLAY_DATA_PACKET__TYPE__VENDORINFO       0x00000004
+#define ADL_DL_DISPLAY_DATA_PACKET__TYPE__HDR              0x00000008
+#define ADL_DL_DISPLAY_DATA_PACKET__TYPE__SPD              0x00000010
+/// @}
+
+// matrix types
+#define ADL_GAMUT_MATRIX_SD         1   // SD matrix i.e. BT601
+#define ADL_GAMUT_MATRIX_HD         2   // HD matrix i.e. BT709
+
+///\defgroup define_clockinfo_flags Clock flags
+/// Used by ADLAdapterODClockInfo.iFlag
+/// @{
+#define ADL_DL_CLOCKINFO_FLAG_FULLSCREEN3DONLY         0x00000001
+#define ADL_DL_CLOCKINFO_FLAG_ALWAYSFULLSCREEN3D       0x00000002
+#define ADL_DL_CLOCKINFO_FLAG_VPURECOVERYREDUCED       0x00000004
+#define ADL_DL_CLOCKINFO_FLAG_THERMALPROTECTION        0x00000008
+/// @}
+
+// Supported GPUs
+// ADL_Display_PowerXpressActiveGPU_Get()
+#define ADL_DL_POWERXPRESS_GPU_INTEGRATED        1
+#define ADL_DL_POWERXPRESS_GPU_DISCRETE            2
+
+// Possible values for lpOperationResult
+// ADL_Display_PowerXpressActiveGPU_Get()
+#define ADL_DL_POWERXPRESS_SWITCH_RESULT_STARTED         1 // Switch procedure has been started - Windows platform only
+#define ADL_DL_POWERXPRESS_SWITCH_RESULT_DECLINED        2 // Switch procedure cannot be started - All platforms
+#define ADL_DL_POWERXPRESS_SWITCH_RESULT_ALREADY         3 // System already has required status  - All platforms
+#define ADL_DL_POWERXPRESS_SWITCH_RESULT_DEFERRED        5  // Switch was deferred and requires an X restart - Linux platform only
+
+// PowerXpress support version
+// ADL_Display_PowerXpressVersion_Get()
+#define ADL_DL_POWERXPRESS_VERSION_MAJOR            2    // Current PowerXpress support version 2.0
+#define ADL_DL_POWERXPRESS_VERSION_MINOR            0
+
+#define ADL_DL_POWERXPRESS_VERSION    (((ADL_DL_POWERXPRESS_VERSION_MAJOR) << 16) | ADL_DL_POWERXPRESS_VERSION_MINOR)
+
+//values for ADLThermalControllerInfo.iThermalControllerDomain
+#define ADL_DL_THERMAL_DOMAIN_OTHER      0
+#define ADL_DL_THERMAL_DOMAIN_GPU        1
+
+//values for ADLThermalControllerInfo.iFlags
+#define ADL_DL_THERMAL_FLAG_INTERRUPT    1
+#define ADL_DL_THERMAL_FLAG_FANCONTROL   2
+
+///\defgroup define_fanctrl Fan speed cotrol
+/// Values for ADLFanSpeedInfo.iFlags
+/// @{
+#define ADL_DL_FANCTRL_SUPPORTS_PERCENT_READ     1
+#define ADL_DL_FANCTRL_SUPPORTS_PERCENT_WRITE    2
+#define ADL_DL_FANCTRL_SUPPORTS_RPM_READ         4
+#define ADL_DL_FANCTRL_SUPPORTS_RPM_WRITE        8
+/// @}
+
+//values for ADLFanSpeedValue.iSpeedType
+#define ADL_DL_FANCTRL_SPEED_TYPE_PERCENT    1
+#define ADL_DL_FANCTRL_SPEED_TYPE_RPM        2
+
+//values for ADLFanSpeedValue.iFlags
+#define ADL_DL_FANCTRL_FLAG_USER_DEFINED_SPEED   1
+
+// MVPU interfaces
+#define ADL_DL_MAX_MVPU_ADAPTERS   4
+#define MVPU_ADAPTER_0          0x00000001
+#define MVPU_ADAPTER_1          0x00000002
+#define MVPU_ADAPTER_2          0x00000004
+#define MVPU_ADAPTER_3          0x00000008
+#define ADL_DL_MAX_REGISTRY_PATH   256
+
+//values for ADLMVPUStatus.iStatus
+#define ADL_DL_MVPU_STATUS_OFF   0
+#define ADL_DL_MVPU_STATUS_ON    1
+
+// values for ASIC family
+///\defgroup define_Asic_type Detailed asic types
+/// Defines for Adapter ASIC family type
+/// @{
+#define ADL_ASIC_UNDEFINED      0
+#define ADL_ASIC_DISCRETE       (1 << 0)
+#define ADL_ASIC_INTEGRATED     (1 << 1)
+#define ADL_ASIC_WORKSTATION    (1 << 2)
+#define ADL_ASIC_FIREMV         (1 << 3)
+#define ADL_ASIC_XGP            (1 << 4)
+#define ADL_ASIC_FUSION         (1 << 5)
+#define ADL_ASIC_FIRESTREAM     (1 << 6)
+#define ADL_ASIC_EMBEDDED       (1 << 7)
+// Backward compatibility
+#define ADL_ASIC_FIREGL  ADL_ASIC_WORKSTATION
+/// @}
+
+///\defgroup define_detailed_timing_flags Detailed Timimg Flags
+/// Defines for ADLDetailedTiming.sTimingFlags field
+/// @{
+#define ADL_DL_TIMINGFLAG_DOUBLE_SCAN              0x0001
+//sTimingFlags is set when the mode is INTERLACED, if not PROGRESSIVE
+#define ADL_DL_TIMINGFLAG_INTERLACED               0x0002
+//sTimingFlags is set when the Horizontal Sync is POSITIVE, if not NEGATIVE
+#define ADL_DL_TIMINGFLAG_H_SYNC_POLARITY          0x0004
+//sTimingFlags is set when the Vertical Sync is POSITIVE, if not NEGATIVE
+#define ADL_DL_TIMINGFLAG_V_SYNC_POLARITY          0x0008
+/// @}
+
+///\defgroup define_modetiming_standard Timing Standards
+/// Defines for ADLDisplayModeInfo.iTimingStandard field
+/// @{
+#define ADL_DL_MODETIMING_STANDARD_CVT             0x00000001 // CVT Standard
+#define ADL_DL_MODETIMING_STANDARD_GTF             0x00000002 // GFT Standard
+#define ADL_DL_MODETIMING_STANDARD_DMT             0x00000004 // DMT Standard
+#define ADL_DL_MODETIMING_STANDARD_CUSTOM          0x00000008 // User-defined standard
+#define ADL_DL_MODETIMING_STANDARD_DRIVER_DEFAULT  0x00000010 // Remove Mode from overriden list
+#define ADL_DL_MODETIMING_STANDARD_CVT_RB           0x00000020 // CVT-RB Standard
+/// @}
+
+// \defgroup define_xserverinfo driver x-server info
+/// These flags are used by ADL_XServerInfo_Get()
+// @
+
+/// Xinerama is active in the x-server, Xinerama extension may report it to be active but it
+/// may not be active in x-server
+#define ADL_XSERVERINFO_XINERAMAACTIVE            (1<<0)
+
+/// RandR 1.2 is supported by driver, RandR extension may report version 1.2
+/// but driver may not support it
+#define ADL_XSERVERINFO_RANDR12SUPPORTED          (1<<1)
+// @
+
+
+///\defgroup define_eyefinity_constants Eyefinity Definitions
+/// @{
+
+#define ADL_CONTROLLERVECTOR_0        1    // ADL_CONTROLLERINDEX_0 = 0, (1 << ADL_CONTROLLERINDEX_0)
+#define ADL_CONTROLLERVECTOR_1        2    // ADL_CONTROLLERINDEX_1 = 1, (1 << ADL_CONTROLLERINDEX_1)
+
+#define ADL_DISPLAY_SLSGRID_ORIENTATION_000        0x00000001
+#define ADL_DISPLAY_SLSGRID_ORIENTATION_090        0x00000002
+#define ADL_DISPLAY_SLSGRID_ORIENTATION_180        0x00000004
+#define ADL_DISPLAY_SLSGRID_ORIENTATION_270        0x00000008
+#define ADL_DISPLAY_SLSGRID_CAP_OPTION_RELATIVETO_LANDSCAPE     0x00000001
+#define ADL_DISPLAY_SLSGRID_CAP_OPTION_RELATIVETO_CURRENTANGLE     0x00000002
+#define ADL_DISPLAY_SLSGRID_PORTAIT_MODE                         0x00000004
+#define ADL_DISPLAY_SLSGRID_KEEPTARGETROTATION                  0x00000080
+
+#define ADL_DISPLAY_SLSGRID_SAMEMODESLS_SUPPORT        0x00000010
+#define ADL_DISPLAY_SLSGRID_MIXMODESLS_SUPPORT        0x00000020
+#define ADL_DISPLAY_SLSGRID_DISPLAYROTATION_SUPPORT    0x00000040
+#define ADL_DISPLAY_SLSGRID_DESKTOPROTATION_SUPPORT    0x00000080
+
+
+#define ADL_DISPLAY_SLSMAP_SLSLAYOUTMODE_FIT        0x0100
+#define ADL_DISPLAY_SLSMAP_SLSLAYOUTMODE_FILL       0x0200
+#define ADL_DISPLAY_SLSMAP_SLSLAYOUTMODE_EXPAND     0x0400
+
+#define ADL_DISPLAY_SLSMAP_IS_SLS        0x1000
+#define ADL_DISPLAY_SLSMAP_IS_SLSBUILDER 0x2000
+#define ADL_DISPLAY_SLSMAP_IS_CLONEVT     0x4000
+
+#define ADL_DISPLAY_SLSMAPCONFIG_GET_OPTION_RELATIVETO_LANDSCAPE         0x00000001
+#define ADL_DISPLAY_SLSMAPCONFIG_GET_OPTION_RELATIVETO_CURRENTANGLE     0x00000002
+
+#define ADL_DISPLAY_SLSMAPCONFIG_CREATE_OPTION_RELATIVETO_LANDSCAPE         0x00000001
+#define ADL_DISPLAY_SLSMAPCONFIG_CREATE_OPTION_RELATIVETO_CURRENTANGLE     0x00000002
+
+#define ADL_DISPLAY_SLSMAPCONFIG_REARRANGE_OPTION_RELATIVETO_LANDSCAPE     0x00000001
+#define ADL_DISPLAY_SLSMAPCONFIG_REARRANGE_OPTION_RELATIVETO_CURRENTANGLE     0x00000002
+
+#define ADL_SLS_SAMEMODESLS_SUPPORT         0x0001
+#define ADL_SLS_MIXMODESLS_SUPPORT          0x0002
+#define ADL_SLS_DISPLAYROTATIONSLS_SUPPORT  0x0004
+#define ADL_SLS_DESKTOPROTATIONSLS_SUPPORT  0x0008
+
+#define ADL_SLS_TARGETS_INVALID     0x0001
+#define ADL_SLS_MODES_INVALID       0x0002
+#define ADL_SLS_ROTATIONS_INVALID   0x0004
+#define ADL_SLS_POSITIONS_INVALID   0x0008
+#define ADL_SLS_LAYOUTMODE_INVALID  0x0010
+
+#define ADL_DISPLAY_SLSDISPLAYOFFSET_VALID        0x0002
+
+#define ADL_DISPLAY_SLSGRID_RELATIVETO_LANDSCAPE         0x00000010
+#define ADL_DISPLAY_SLSGRID_RELATIVETO_CURRENTANGLE     0x00000020
+
+
+/// The bit mask identifies displays is currently in bezel mode.
+#define ADL_DISPLAY_SLSMAP_BEZELMODE            0x00000010
+/// The bit mask identifies displays from this map is arranged.
+#define ADL_DISPLAY_SLSMAP_DISPLAYARRANGED        0x00000002
+/// The bit mask identifies this map is currently in used for the current adapter.
+#define ADL_DISPLAY_SLSMAP_CURRENTCONFIG        0x00000004
+
+///For onlay active SLS  map info
+#define ADL_DISPLAY_SLSMAPINDEXLIST_OPTION_ACTIVE        0x00000001
+
+///For Bezel
+#define ADL_DISPLAY_BEZELOFFSET_STEPBYSTEPSET            0x00000004
+#define ADL_DISPLAY_BEZELOFFSET_COMMIT                    0x00000008
+
+typedef enum SLS_ImageCropType {
+    Fit = 1,
+    Fill = 2,
+    Expand = 3
+}SLS_ImageCropType;
+
+
+typedef enum DceSettingsType {
+    DceSetting_HdmiLq,
+    DceSetting_DpSettings,
+    DceSetting_Protection
+
+} DceSettingsType;
+
+typedef enum DpLinkRate {
+    DPLinkRate_Unknown,
+    DPLinkRate_RBR,
+	DPLinkRate_2_16Gbps,
+	DPLinkRate_2_43Gbps,
+    DPLinkRate_HBR,
+	DPLinkRate_4_32Gbps,
+    DPLinkRate_HBR2,
+    DPLinkRate_HBR3,
+	DPLinkRate_UHBR10,
+	DPLinkRate_UHBR13D5,
+	DPLinkRate_UHBR20
+
+} DpLinkRate;
+
+/// @}
+
+///\defgroup define_powerxpress_constants PowerXpress Definitions
+/// @{
+
+/// The bit mask identifies PX caps for ADLPXConfigCaps.iPXConfigCapMask and ADLPXConfigCaps.iPXConfigCapValue
+#define    ADL_PX_CONFIGCAPS_SPLASHSCREEN_SUPPORT        0x0001
+#define    ADL_PX_CONFIGCAPS_CF_SUPPORT                0x0002
+#define    ADL_PX_CONFIGCAPS_MUXLESS                    0x0004
+#define    ADL_PX_CONFIGCAPS_PROFILE_COMPLIANT            0x0008
+#define    ADL_PX_CONFIGCAPS_NON_AMD_DRIVEN_DISPLAYS    0x0010
+#define ADL_PX_CONFIGCAPS_FIXED_SUPPORT             0x0020
+#define ADL_PX_CONFIGCAPS_DYNAMIC_SUPPORT           0x0040
+#define ADL_PX_CONFIGCAPS_HIDE_AUTO_SWITCH            0x0080
+
+/// The bit mask identifies PX schemes for ADLPXSchemeRange
+#define ADL_PX_SCHEMEMASK_FIXED                        0x0001
+#define ADL_PX_SCHEMEMASK_DYNAMIC                    0x0002
+
+/// PX Schemes
+typedef enum ADLPXScheme
+{
+    ADL_PX_SCHEME_INVALID   = 0,
+    ADL_PX_SCHEME_FIXED     = ADL_PX_SCHEMEMASK_FIXED,
+    ADL_PX_SCHEME_DYNAMIC   = ADL_PX_SCHEMEMASK_DYNAMIC
+}ADLPXScheme;
+
+/// Just keep the old definitions for compatibility, need to be removed later
+typedef enum PXScheme
+{
+    PX_SCHEME_INVALID   = 0,
+    PX_SCHEME_FIXED     = 1,
+    PX_SCHEME_DYNAMIC   = 2
+} PXScheme;
+
+
+/// @}
+
+///\defgroup define_appprofiles For Application Profiles
+/// @{
+
+#define ADL_APP_PROFILE_FILENAME_LENGTH        256
+#define ADL_APP_PROFILE_TIMESTAMP_LENGTH    32
+#define ADL_APP_PROFILE_VERSION_LENGTH        32
+#define ADL_APP_PROFILE_PROPERTY_LENGTH        64
+
+enum ApplicationListType
+{
+    ADL_PX40_MRU,
+    ADL_PX40_MISSED,
+    ADL_PX40_DISCRETE,
+    ADL_PX40_INTEGRATED,
+    ADL_MMD_PROFILED,
+    ADL_PX40_TOTAL
+};
+
+typedef enum ADLProfilePropertyType
+{
+    ADL_PROFILEPROPERTY_TYPE_BINARY        = 0,
+    ADL_PROFILEPROPERTY_TYPE_BOOLEAN,
+    ADL_PROFILEPROPERTY_TYPE_DWORD,
+    ADL_PROFILEPROPERTY_TYPE_QWORD,
+    ADL_PROFILEPROPERTY_TYPE_ENUMERATED,
+    ADL_PROFILEPROPERTY_TYPE_STRING
+}ADLProfilePropertyType;
+
+
+//Virtual display type returning virtual display type and for request for creating a dummy target ID (xInput or remote play)
+typedef enum ADL_VIRTUALDISPLAY_TYPE
+{
+	ADL_VIRTUALDISPLAY_NONE = 0,
+	ADL_VIRTUALDISPLAY_XINPUT = 1,			//Requested for xInput
+	ADL_VIRTUALDISPLAY_REMOTEPLAY = 2,		//Requested for emulated display during remote play
+	ADL_VIRTUALDISPLAY_GENERIC = 10			//Generic virtual display, af a type different than any of the above special ones
+}ADL_VIRTUALDISPLAY_TYPE;
+
+/// @}
+
+///\defgroup define_dp12 For Display Port 1.2
+/// @{
+
+/// Maximum Relative Address Link
+#define ADL_MAX_RAD_LINK_COUNT    15
+
+/// @}
+
+///\defgroup defines_gamutspace Driver Supported Gamut Space
+/// @{
+
+/// The flags desribes that gamut is related to source or to destination and to overlay or to graphics
+#define ADL_GAMUT_REFERENCE_SOURCE       (1 << 0)
+#define ADL_GAMUT_GAMUT_VIDEO_CONTENT    (1 << 1)
+
+/// The flags are used to describe the source of gamut and how read information from struct ADLGamutData
+#define ADL_CUSTOM_WHITE_POINT           (1 << 0)
+#define ADL_CUSTOM_GAMUT                 (1 << 1)
+#define ADL_GAMUT_REMAP_ONLY             (1 << 2)
+
+/// The define means the predefined gamut values  .
+///Driver uses to find entry in the table and apply appropriate gamut space.
+#define ADL_GAMUT_SPACE_CCIR_709     (1 << 0)
+#define ADL_GAMUT_SPACE_CCIR_601     (1 << 1)
+#define ADL_GAMUT_SPACE_ADOBE_RGB    (1 << 2)
+#define ADL_GAMUT_SPACE_CIE_RGB      (1 << 3)
+#define ADL_GAMUT_SPACE_CUSTOM       (1 << 4)
+#define ADL_GAMUT_SPACE_CCIR_2020    (1 << 5)
+#define ADL_GAMUT_SPACE_APPCTRL      (1 << 6)
+
+/// Predefine white point values are structed similar to gamut .
+#define ADL_WHITE_POINT_5000K       (1 << 0)
+#define ADL_WHITE_POINT_6500K       (1 << 1)
+#define ADL_WHITE_POINT_7500K       (1 << 2)
+#define ADL_WHITE_POINT_9300K       (1 << 3)
+#define ADL_WHITE_POINT_CUSTOM      (1 << 4)
+
+///gamut and white point coordinates are from 0.0 -1.0 and divider is used to find the real value .
+/// X float = X int /divider
+#define ADL_GAMUT_WHITEPOINT_DIVIDER           10000
+
+///gamma a0 coefficient uses the following divider:
+#define ADL_REGAMMA_COEFFICIENT_A0_DIVIDER       10000000
+///gamma a1 ,a2,a3 coefficients use the following divider:
+#define ADL_REGAMMA_COEFFICIENT_A1A2A3_DIVIDER   1000
+
+///describes whether the coefficients are from EDID or custom user values.
+#define ADL_EDID_REGAMMA_COEFFICIENTS          (1 << 0)
+///Used for struct ADLRegamma. Feature if set use gamma ramp, if missing use regamma coefficents
+#define ADL_USE_GAMMA_RAMP                     (1 << 4)
+///Used for struct ADLRegamma. If the gamma ramp flag is used then the driver could apply de gamma corretion to the supplied curve and this depends on this flag
+#define ADL_APPLY_DEGAMMA                      (1 << 5)
+///specifies that standard SRGB gamma should be applied
+#define ADL_EDID_REGAMMA_PREDEFINED_SRGB       (1 << 1)
+///specifies that PQ gamma curve should be applied
+#define ADL_EDID_REGAMMA_PREDEFINED_PQ         (1 << 2)
+///specifies that PQ gamma curve should be applied, lower max nits
+#define ADL_EDID_REGAMMA_PREDEFINED_PQ_2084_INTERIM (1 << 3)
+///specifies that 3.6 gamma should be applied
+#define ADL_EDID_REGAMMA_PREDEFINED_36         (1 << 6)
+///specifies that BT709 gama should be applied
+#define ADL_EDID_REGAMMA_PREDEFINED_BT709      (1 << 7)
+///specifies that regamma should be disabled, and application controls regamma content (of the whole screen)
+#define ADL_EDID_REGAMMA_PREDEFINED_APPCTRL    (1 << 8)
+
+/// @}
+
+/// \defgroup define_ddcinfo_pixelformats DDCInfo Pixel Formats
+/// @{
+/// defines for iPanelPixelFormat  in struct ADLDDCInfo2
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB656                       0x00000001L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB666                       0x00000002L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB888                       0x00000004L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB101010                    0x00000008L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB161616                    0x00000010L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB_RESERVED1                0x00000020L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB_RESERVED2                0x00000040L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB_RESERVED3                0x00000080L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_XRGB_BIAS101010              0x00000100L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR444_8BPCC               0x00000200L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR444_10BPCC              0x00000400L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR444_12BPCC              0x00000800L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR422_8BPCC               0x00001000L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR422_10BPCC              0x00002000L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR422_12BPCC              0x00004000L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR420_8BPCC               0x00008000L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR420_10BPCC              0x00010000L
+#define ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_YCBCR420_12BPCC              0x00020000L
+/// @}
+
+/// \defgroup define_source_content_TF ADLSourceContentAttributes transfer functions (gamma)
+/// @{
+/// defines for iTransferFunction in ADLSourceContentAttributes
+#define ADL_TF_sRGB                0x0001      ///< sRGB
+#define ADL_TF_BT709            0x0002      ///< BT.709
+#define ADL_TF_PQ2084            0x0004      ///< PQ2084
+#define ADL_TF_PQ2084_INTERIM    0x0008        ///< PQ2084-Interim
+#define ADL_TF_LINEAR_0_1        0x0010      ///< Linear 0 - 1
+#define ADL_TF_LINEAR_0_125        0x0020      ///< Linear 0 - 125
+#define ADL_TF_DOLBYVISION        0x0040      ///< DolbyVision
+#define ADL_TF_GAMMA_22         0x0080      ///< Plain 2.2 gamma curve
+/// @}
+
+/// \defgroup define_source_content_CS ADLSourceContentAttributes color spaces
+/// @{
+/// defines for iColorSpace in ADLSourceContentAttributes
+#define ADL_CS_sRGB                0x0001      ///< sRGB
+#define ADL_CS_BT601             0x0002      ///< BT.601
+#define ADL_CS_BT709            0x0004      ///< BT.709
+#define ADL_CS_BT2020            0x0008      ///< BT.2020
+#define ADL_CS_ADOBE            0x0010      ///< Adobe RGB
+#define ADL_CS_P3                0x0020      ///< DCI-P3
+#define ADL_CS_scRGB_MS_REF        0x0040      ///< scRGB (MS Reference)
+#define ADL_CS_DISPLAY_NATIVE    0x0080      ///< Display Native
+#define ADL_CS_APP_CONTROL         0x0100      ///< Application Controlled
+#define ADL_CS_DOLBYVISION      0x0200      ///< DolbyVision
+/// @}
+
+/// \defgroup define_HDR_support ADLDDCInfo2 HDR support options
+/// @{
+/// defines for iSupportedHDR in ADLDDCInfo2
+#define ADL_HDR_CEA861_3        0x0001      ///< HDR10/CEA861.3 HDR supported
+#define ADL_HDR_DOLBYVISION     0x0002      ///< \deprecated DolbyVision HDR supported
+#define ADL_HDR_FREESYNC_HDR    0x0004      ///< FreeSync HDR supported
+/// @}
+
+/// \defgroup define_FreesyncFlags ADLDDCInfo2 Freesync HDR flags
+/// @{
+/// defines for iFreesyncFlags in ADLDDCInfo2
+#define ADL_HDR_FREESYNC_BACKLIGHT_SUPPORT           0x0001      ///< Global backlight control supported
+#define ADL_HDR_FREESYNC_LOCAL_DIMMING               0x0002      ///< Local dimming supported
+/// @}
+
+/// \defgroup define_source_content_flags ADLSourceContentAttributes flags
+/// @{
+/// defines for iFlags in ADLSourceContentAttributes
+#define ADL_SCA_LOCAL_DIMMING_DISABLE    0x0001      ///< Disable local dimming
+/// @}
+
+/// \defgroup define_dbd_state Deep Bit Depth
+/// @{
+
+/// defines for ADL_Workstation_DeepBitDepth_Get and  ADL_Workstation_DeepBitDepth_Set functions
+// This value indicates that the deep bit depth state is forced off
+#define ADL_DEEPBITDEPTH_FORCEOFF     0
+/// This value indicates that the deep bit depth state  is set to auto, the driver will automatically enable the
+/// appropriate deep bit depth state depending on what connected display supports.
+#define ADL_DEEPBITDEPTH_10BPP_AUTO     1
+/// This value indicates that the deep bit depth state  is forced on to 10 bits per pixel, this is regardless if the display
+/// supports 10 bpp.
+#define ADL_DEEPBITDEPTH_10BPP_FORCEON     2
+
+/// defines for ADLAdapterConfigMemory of ADL_Adapter_ConfigMemory_Get
+/// If this bit is set, it indicates that the Deep Bit Depth pixel is set on the display
+#define ADL_ADAPTER_CONFIGMEMORY_DBD            (1 << 0)
+/// If this bit is set, it indicates that the display is rotated (90, 180 or 270)
+#define ADL_ADAPTER_CONFIGMEMORY_ROTATE            (1 << 1)
+/// If this bit is set, it indicates that passive stereo is set on the display
+#define ADL_ADAPTER_CONFIGMEMORY_STEREO_PASSIVE    (1 << 2)
+/// If this bit is set, it indicates that the active stereo is set on the display
+#define ADL_ADAPTER_CONFIGMEMORY_STEREO_ACTIVE    (1 << 3)
+/// If this bit is set, it indicates that the tear free vsync is set on the display
+#define ADL_ADAPTER_CONFIGMEMORY_ENHANCEDVSYNC    (1 << 4)
+#define ADL_ADAPTER_CONFIGMEMORY_TEARFREEVSYNC    (1 << 4)
+/// @}
+
+/// \defgroup define_adl_validmemoryrequiredfields Memory Type
+/// @{
+
+///  This group defines memory types in ADLMemoryRequired struct \n
+/// Indicates that this is the visible memory
+#define ADL_MEMORYREQTYPE_VISIBLE                (1 << 0)
+/// Indicates that this is the invisible memory.
+#define ADL_MEMORYREQTYPE_INVISIBLE                (1 << 1)
+/// Indicates that this is amount of visible memory per GPU that should be reserved for all other allocations.
+#define ADL_MEMORYREQTYPE_GPURESERVEDVISIBLE    (1 << 2)
+/// @}
+
+/// \defgroup define_adapter_tear_free_status
+/// Used in ADL_Adapter_TEAR_FREE_Set and ADL_Adapter_TFD_Get functions to indicate the tear free
+/// desktop status.
+/// @{
+/// Tear free desktop is enabled.
+#define ADL_ADAPTER_TEAR_FREE_ON                1
+/// Tear free desktop can't be enabled due to a lack of graphic adapter memory.
+#define ADL_ADAPTER_TEAR_FREE_NOTENOUGHMEM        -1
+/// Tear free desktop can't be enabled due to quad buffer stereo being enabled.
+#define ADL_ADAPTER_TEAR_FREE_OFF_ERR_QUADBUFFERSTEREO    -2
+/// Tear free desktop can't be enabled due to MGPU-SLS being enabled.
+#define ADL_ADAPTER_TEAR_FREE_OFF_ERR_MGPUSLD    -3
+/// Tear free desktop is disabled.
+#define ADL_ADAPTER_TEAR_FREE_OFF                0
+/// @}
+
+/// \defgroup define_adapter_crossdisplay_platforminfo
+/// Used in ADL_Adapter_CrossDisplayPlatformInfo_Get function to indicate the Crossdisplay platform info.
+/// @{
+/// CROSSDISPLAY platform.
+#define ADL_CROSSDISPLAY_PLATFORM                    (1 << 0)
+/// CROSSDISPLAY platform for Lasso station.
+#define ADL_CROSSDISPLAY_PLATFORM_LASSO                (1 << 1)
+/// CROSSDISPLAY platform for docking station.
+#define ADL_CROSSDISPLAY_PLATFORM_DOCKSTATION        (1 << 2)
+/// @}
+
+/// \defgroup define_adapter_crossdisplay_option
+/// Used in ADL_Adapter_CrossdisplayInfoX2_Set function to indicate cross display options.
+/// @{
+/// Checking if 3D application is runnning. If yes, not to do switch, return ADL_OK_WAIT; otherwise do switch.
+#define ADL_CROSSDISPLAY_OPTION_NONE            0
+/// Force switching without checking for running 3D applications
+#define ADL_CROSSDISPLAY_OPTION_FORCESWITCH        (1 << 0)
+/// @}
+
+/// \defgroup define_adapter_states Adapter Capabilities
+/// These defines the capabilities supported by an adapter. It is used by \ref ADL_Adapter_ConfigureState_Get
+/// @{
+/// Indicates that the adapter is headless (i.e. no displays can be connected to it)
+#define ADL_ADAPTERCONFIGSTATE_HEADLESS ( 1 << 2 )
+/// Indicates that the adapter is configured to define the main rendering capabilities. For example, adapters
+/// in Crossfire(TM) configuration, this bit would only be set on the adapter driving the display(s).
+#define ADL_ADAPTERCONFIGSTATE_REQUISITE_RENDER ( 1 << 0 )
+/// Indicates that the adapter is configured to be used to unload some of the rendering work for a particular
+/// requisite rendering adapter. For eample, for adapters in a Crossfire configuration, this bit would be set
+/// on all adapters that are currently not driving the display(s)
+#define ADL_ADAPTERCONFIGSTATE_ANCILLARY_RENDER ( 1 << 1 )
+/// Indicates that scatter gather feature enabled on the adapter
+#define ADL_ADAPTERCONFIGSTATE_SCATTERGATHER ( 1 << 4 )
+/// @}
+
+/// \defgroup define_controllermode_ulModifiers
+/// These defines the detailed actions supported by set viewport. It is used by \ref ADL_Display_ViewPort_Set
+/// @{
+/// Indicate that the viewport set will change the view position
+#define ADL_CONTROLLERMODE_CM_MODIFIER_VIEW_POSITION       0x00000001
+/// Indicate that the viewport set will change the view PanLock
+#define ADL_CONTROLLERMODE_CM_MODIFIER_VIEW_PANLOCK        0x00000002
+/// Indicate that the viewport set will change the view size
+#define ADL_CONTROLLERMODE_CM_MODIFIER_VIEW_SIZE           0x00000008
+/// @}
+
+/// \defgroup defines for Mirabilis
+/// These defines are used for the Mirabilis feature
+/// @{
+///
+/// Indicates the maximum number of audio sample rates
+#define ADL_MAX_AUDIO_SAMPLE_RATE_COUNT                    16
+/// @}
+
+///////////////////////////////////////////////////////////////////////////
+// ADLMultiChannelSplitStateFlag Enumeration
+///////////////////////////////////////////////////////////////////////////
+enum ADLMultiChannelSplitStateFlag
+{
+    ADLMultiChannelSplit_Unitialized = 0,
+    ADLMultiChannelSplit_Disabled    = 1,
+    ADLMultiChannelSplit_Enabled     = 2,
+    ADLMultiChannelSplit_SaveProfile = 3
+};
+
+///////////////////////////////////////////////////////////////////////////
+// ADLSampleRate Enumeration
+///////////////////////////////////////////////////////////////////////////
+enum ADLSampleRate
+{
+    ADLSampleRate_32KHz =0,
+    ADLSampleRate_44P1KHz,
+    ADLSampleRate_48KHz,
+    ADLSampleRate_88P2KHz,
+    ADLSampleRate_96KHz,
+    ADLSampleRate_176P4KHz,
+    ADLSampleRate_192KHz,
+    ADLSampleRate_384KHz, //DP1.2
+    ADLSampleRate_768KHz, //DP1.2
+    ADLSampleRate_Undefined
+};
+
+/// \defgroup define_overdrive6_capabilities
+/// These defines the capabilities supported by Overdrive 6. It is used by \ref ADL_Overdrive6_Capabilities_Get
+/// @{
+/// Indicate that core (engine) clock can be changed.
+#define ADL_OD6_CAPABILITY_SCLK_CUSTOMIZATION               0x00000001
+/// Indicate that memory clock can be changed.
+#define ADL_OD6_CAPABILITY_MCLK_CUSTOMIZATION               0x00000002
+/// Indicate that graphics activity reporting is supported.
+#define ADL_OD6_CAPABILITY_GPU_ACTIVITY_MONITOR             0x00000004
+/// Indicate that power limit can be customized.
+#define ADL_OD6_CAPABILITY_POWER_CONTROL                    0x00000008
+/// Indicate that SVI2 Voltage Control is supported.
+#define ADL_OD6_CAPABILITY_VOLTAGE_CONTROL                  0x00000010
+/// Indicate that OD6+ percentage adjustment is supported.
+#define ADL_OD6_CAPABILITY_PERCENT_ADJUSTMENT               0x00000020
+/// Indicate that Thermal Limit Unlock is supported.
+#define ADL_OD6_CAPABILITY_THERMAL_LIMIT_UNLOCK             0x00000040
+///Indicate that Fan speed needs to be displayed in RPM
+#define ADL_OD6_CAPABILITY_FANSPEED_IN_RPM                    0x00000080
+/// @}
+
+/// \defgroup define_overdrive6_supported_states
+/// These defines the power states supported by Overdrive 6. It is used by \ref ADL_Overdrive6_Capabilities_Get
+/// @{
+/// Indicate that overdrive is supported in the performance state.  This is currently the only state supported.
+#define ADL_OD6_SUPPORTEDSTATE_PERFORMANCE                  0x00000001
+/// Do not use.  Reserved for future use.
+#define ADL_OD6_SUPPORTEDSTATE_POWER_SAVING                 0x00000002
+/// @}
+
+/// \defgroup define_overdrive6_getstateinfo
+/// These defines the power states to get information about. It is used by \ref ADL_Overdrive6_StateInfo_Get
+/// @{
+/// Get default clocks for the performance state.
+#define ADL_OD6_GETSTATEINFO_DEFAULT_PERFORMANCE            0x00000001
+/// Do not use.  Reserved for future use.
+#define ADL_OD6_GETSTATEINFO_DEFAULT_POWER_SAVING           0x00000002
+/// Get clocks for current state.  Currently this is the same as \ref ADL_OD6_GETSTATEINFO_CUSTOM_PERFORMANCE
+/// since only performance state is supported.
+#define ADL_OD6_GETSTATEINFO_CURRENT                        0x00000003
+/// Get the modified clocks (if any) for the performance state.  If clocks were not modified
+/// through Overdrive 6, then this will return the same clocks as \ref ADL_OD6_GETSTATEINFO_DEFAULT_PERFORMANCE.
+#define ADL_OD6_GETSTATEINFO_CUSTOM_PERFORMANCE             0x00000004
+/// Do not use.  Reserved for future use.
+#define ADL_OD6_GETSTATEINFO_CUSTOM_POWER_SAVING            0x00000005
+/// @}
+
+/// \defgroup define_overdrive6_getstate and define_overdrive6_getmaxclockadjust
+/// These defines the power states to get information about. It is used by \ref ADL_Overdrive6_StateEx_Get and \ref ADL_Overdrive6_MaxClockAdjust_Get
+/// @{
+/// Get default clocks for the performance state.  Only performance state is currently supported.
+#define ADL_OD6_STATE_PERFORMANCE            0x00000001
+/// @}
+
+/// \defgroup define_overdrive6_setstate
+/// These define which power state to set customized clocks on. It is used by \ref ADL_Overdrive6_State_Set
+/// @{
+/// Set customized clocks for the performance state.
+#define ADL_OD6_SETSTATE_PERFORMANCE                        0x00000001
+/// Do not use.  Reserved for future use.
+#define ADL_OD6_SETSTATE_POWER_SAVING                       0x00000002
+/// @}
+
+/// \defgroup define_overdrive6_thermalcontroller_caps
+/// These defines the capabilities of the GPU thermal controller. It is used by \ref ADL_Overdrive6_ThermalController_Caps
+/// @{
+/// GPU thermal controller is supported.
+#define ADL_OD6_TCCAPS_THERMAL_CONTROLLER                   0x00000001
+/// GPU fan speed control is supported.
+#define ADL_OD6_TCCAPS_FANSPEED_CONTROL                     0x00000002
+/// Fan speed percentage can be read.
+#define ADL_OD6_TCCAPS_FANSPEED_PERCENT_READ                0x00000100
+/// Fan speed can be set by specifying a percentage value.
+#define ADL_OD6_TCCAPS_FANSPEED_PERCENT_WRITE               0x00000200
+/// Fan speed RPM (revolutions-per-minute) can be read.
+#define ADL_OD6_TCCAPS_FANSPEED_RPM_READ                    0x00000400
+/// Fan speed can be set by specifying an RPM value.
+#define ADL_OD6_TCCAPS_FANSPEED_RPM_WRITE                   0x00000800
+/// @}
+
+/// \defgroup define_overdrive6_fanspeed_type
+/// These defines the fan speed type being reported. It is used by \ref ADL_Overdrive6_FanSpeed_Get
+/// @{
+/// Fan speed reported in percentage.
+#define ADL_OD6_FANSPEED_TYPE_PERCENT                       0x00000001
+/// Fan speed reported in RPM.
+#define ADL_OD6_FANSPEED_TYPE_RPM                           0x00000002
+/// Fan speed has been customized by the user, and fan is not running in automatic mode.
+#define ADL_OD6_FANSPEED_USER_DEFINED                       0x00000100
+/// @}
+
+/// \defgroup define_overdrive_EventCounter_type
+/// These defines the EventCounter type being reported. It is used by \ref ADL2_OverdriveN_CountOfEvents_Get ,can be used on older OD version supported ASICs also.
+/// @{
+#define ADL_ODN_EVENTCOUNTER_THERMAL        0
+#define ADL_ODN_EVENTCOUNTER_VPURECOVERY    1
+/// @}
+
+///////////////////////////////////////////////////////////////////////////
+// ADLODNControlType Enumeration
+///////////////////////////////////////////////////////////////////////////
+enum ADLODNControlType
+{
+    ODNControlType_Current = 0,
+    ODNControlType_Default,
+    ODNControlType_Auto,
+    ODNControlType_Manual
+};
+
+enum ADLODNDPMMaskType
+{
+     ADL_ODN_DPM_CLOCK               = 1 << 0,
+     ADL_ODN_DPM_VDDC                = 1 << 1,
+     ADL_ODN_DPM_MASK                = 1 << 2,
+};
+
+//ODN features Bits for ADLODNCapabilitiesX2
+enum ADLODNFeatureControl
+{
+     ADL_ODN_SCLK_DPM                = 1 << 0,
+     ADL_ODN_MCLK_DPM                = 1 << 1,
+     ADL_ODN_SCLK_VDD                = 1 << 2,
+     ADL_ODN_MCLK_VDD                = 1 << 3,
+     ADL_ODN_FAN_SPEED_MIN           = 1 << 4,
+     ADL_ODN_FAN_SPEED_TARGET        = 1 << 5,
+     ADL_ODN_ACOUSTIC_LIMIT_SCLK     = 1 << 6,
+     ADL_ODN_TEMPERATURE_FAN_MAX     = 1 << 7,
+     ADL_ODN_TEMPERATURE_SYSTEM      = 1 << 8,
+     ADL_ODN_POWER_LIMIT             = 1 << 9,
+     ADL_ODN_SCLK_AUTO_LIMIT             = 1 << 10,
+     ADL_ODN_MCLK_AUTO_LIMIT             = 1 << 11,
+     ADL_ODN_SCLK_DPM_MASK_ENABLE        = 1 << 12,
+     ADL_ODN_MCLK_DPM_MASK_ENABLE        = 1 << 13,
+     ADL_ODN_MCLK_UNDERCLOCK_ENABLE      = 1 << 14,
+     ADL_ODN_SCLK_DPM_THROTTLE_NOTIFY    = 1 << 15,
+     ADL_ODN_POWER_UTILIZATION           = 1 << 16,
+     ADL_ODN_PERF_TUNING_SLIDER          = 1 << 17,
+     ADL_ODN_REMOVE_WATTMAN_PAGE         = 1u << 31 // Internal Only
+};
+
+//If any new feature is added, PPLIB only needs to add ext feature ID and Item ID(Seeting ID). These IDs should match the drive defined in CWDDEPM.h
+enum ADLODNExtFeatureControl
+{
+	ADL_ODN_EXT_FEATURE_MEMORY_TIMING_TUNE = 1 << 0,
+	ADL_ODN_EXT_FEATURE_FAN_ZERO_RPM_CONTROL = 1 << 1,
+	ADL_ODN_EXT_FEATURE_AUTO_UV_ENGINE = 1 << 2,   //Auto under voltage
+	ADL_ODN_EXT_FEATURE_AUTO_OC_ENGINE = 1 << 3,   //Auto OC Enine
+	ADL_ODN_EXT_FEATURE_AUTO_OC_MEMORY = 1 << 4,   //Auto OC memory
+	ADL_ODN_EXT_FEATURE_FAN_CURVE = 1 << 5    //Fan curve
+
+};
+
+//If any new feature is added, PPLIB only needs to add ext feature ID and Item ID(Seeting ID).These IDs should match the drive defined in CWDDEPM.h
+enum ADLODNExtSettingId
+{
+	ADL_ODN_PARAMETER_AC_TIMING = 0,
+	ADL_ODN_PARAMETER_FAN_ZERO_RPM_CONTROL,
+	ADL_ODN_PARAMETER_AUTO_UV_ENGINE,
+	ADL_ODN_PARAMETER_AUTO_OC_ENGINE,
+	ADL_ODN_PARAMETER_AUTO_OC_MEMORY,
+	ADL_ODN_PARAMETER_FAN_CURVE_TEMPERATURE_1,
+	ADL_ODN_PARAMETER_FAN_CURVE_SPEED_1,
+	ADL_ODN_PARAMETER_FAN_CURVE_TEMPERATURE_2,
+	ADL_ODN_PARAMETER_FAN_CURVE_SPEED_2,
+	ADL_ODN_PARAMETER_FAN_CURVE_TEMPERATURE_3,
+	ADL_ODN_PARAMETER_FAN_CURVE_SPEED_3,
+	ADL_ODN_PARAMETER_FAN_CURVE_TEMPERATURE_4,
+	ADL_ODN_PARAMETER_FAN_CURVE_SPEED_4,
+	ADL_ODN_PARAMETER_FAN_CURVE_TEMPERATURE_5,
+	ADL_ODN_PARAMETER_FAN_CURVE_SPEED_5,
+    ADL_ODN_POWERGAUGE,
+	ODN_COUNT
+
+} ;
+
+//OD8 Capability features bits
+enum ADLOD8FeatureControl
+{
+    ADL_OD8_GFXCLK_LIMITS = 1 << 0,
+    ADL_OD8_GFXCLK_CURVE = 1 << 1,
+    ADL_OD8_UCLK_MAX = 1 << 2,
+    ADL_OD8_POWER_LIMIT = 1 << 3,
+    ADL_OD8_ACOUSTIC_LIMIT_SCLK = 1 << 4,   //FanMaximumRpm
+    ADL_OD8_FAN_SPEED_MIN = 1 << 5,   //FanMinimumPwm
+    ADL_OD8_TEMPERATURE_FAN = 1 << 6,   //FanTargetTemperature
+    ADL_OD8_TEMPERATURE_SYSTEM = 1 << 7,    //MaxOpTemp
+    ADL_OD8_MEMORY_TIMING_TUNE = 1 << 8,
+    ADL_OD8_FAN_ZERO_RPM_CONTROL = 1 << 9 ,
+	ADL_OD8_AUTO_UV_ENGINE = 1 << 10,  //Auto under voltage
+	ADL_OD8_AUTO_OC_ENGINE = 1 << 11,  //Auto overclock engine
+	ADL_OD8_AUTO_OC_MEMORY = 1 << 12,  //Auto overclock memory
+	ADL_OD8_FAN_CURVE = 1 << 13,   //Fan curve
+	ADL_OD8_WS_AUTO_FAN_ACOUSTIC_LIMIT = 1 << 14, //Workstation Manual Fan controller
+    ADL_OD8_GFXCLK_QUADRATIC_CURVE = 1 << 15,
+    ADL_OD8_OPTIMIZED_GPU_POWER_MODE = 1 << 16,
+    ADL_OD8_ODVOLTAGE_LIMIT = 1 << 17,
+    ADL_OD8_ADV_OC_LIMITS = 1 << 18,  //Advanced OC limits.
+    ADL_OD8_PER_ZONE_GFX_VOLTAGE_OFFSET = 1 << 19,  //Per Zone gfx voltage offset feature
+    ADL_OD8_AUTO_CURVE_OPTIMIZER = 1 << 20,  //Auto per zone tuning.
+    ADL_OD8_GFX_VOLTAGE_LIMIT = 1 << 21,  //Voltage limit slider
+    ADL_OD8_TDC_LIMIT = 1 << 22,  //TDC slider
+    ADL_OD8_FULL_CONTROL_MODE = 1 << 23,  //Full control
+    ADL_OD8_POWER_SAVING_FEATURE_CONTROL = 1 << 24,  //Power saving feature control
+    ADL_OD8_POWER_GAUGE = 1 << 25 //Power Gauge
+};
+
+
+typedef enum ADLOD8SettingId
+{
+	OD8_GFXCLK_FMAX = 0,
+	OD8_GFXCLK_FMIN,
+	OD8_GFXCLK_FREQ1,
+	OD8_GFXCLK_VOLTAGE1,
+	OD8_GFXCLK_FREQ2,
+	OD8_GFXCLK_VOLTAGE2,
+	OD8_GFXCLK_FREQ3,
+	OD8_GFXCLK_VOLTAGE3,
+	OD8_UCLK_FMAX,
+	OD8_POWER_PERCENTAGE,
+	OD8_FAN_MIN_SPEED,
+	OD8_FAN_ACOUSTIC_LIMIT,
+	OD8_FAN_TARGET_TEMP,
+	OD8_OPERATING_TEMP_MAX,
+	OD8_AC_TIMING,
+	OD8_FAN_ZERORPM_CONTROL,
+	OD8_AUTO_UV_ENGINE_CONTROL,
+	OD8_AUTO_OC_ENGINE_CONTROL,
+	OD8_AUTO_OC_MEMORY_CONTROL,
+	OD8_FAN_CURVE_TEMPERATURE_1,
+	OD8_FAN_CURVE_SPEED_1,
+	OD8_FAN_CURVE_TEMPERATURE_2,
+	OD8_FAN_CURVE_SPEED_2,
+	OD8_FAN_CURVE_TEMPERATURE_3,
+	OD8_FAN_CURVE_SPEED_3,
+	OD8_FAN_CURVE_TEMPERATURE_4,
+	OD8_FAN_CURVE_SPEED_4,
+	OD8_FAN_CURVE_TEMPERATURE_5,
+	OD8_FAN_CURVE_SPEED_5,
+	OD8_WS_FAN_AUTO_FAN_ACOUSTIC_LIMIT,
+    OD8_GFXCLK_CURVE_COEFFICIENT_A, // As part of the agreement with UI team, the min/max voltage limits for the
+    OD8_GFXCLK_CURVE_COEFFICIENT_B, // quadratic curve graph will be stored in the min and max limits of
+    OD8_GFXCLK_CURVE_COEFFICIENT_C, // coefficient a, b and c. A, b and c themselves do not have limits.
+    OD8_GFXCLK_CURVE_VFT_FMIN,
+    OD8_UCLK_FMIN,
+    OD8_FAN_ZERO_RPM_STOP_TEMPERATURE,
+    OD8_OPTIMZED_POWER_MODE,
+    OD8_OD_VOLTAGE,// RSX - voltage offset feature
+    OD8_ADV_OC_LIMITS_SETTING,
+    OD8_PER_ZONE_GFX_VOLTAGE_OFFSET_POINT_1,
+    OD8_PER_ZONE_GFX_VOLTAGE_OFFSET_POINT_2,
+    OD8_PER_ZONE_GFX_VOLTAGE_OFFSET_POINT_3,
+    OD8_PER_ZONE_GFX_VOLTAGE_OFFSET_POINT_4,
+    OD8_PER_ZONE_GFX_VOLTAGE_OFFSET_POINT_5,
+    OD8_PER_ZONE_GFX_VOLTAGE_OFFSET_POINT_6,
+    OD8_AUTO_CURVE_OPTIMIZER_SETTING,
+    OD8_GFX_VOLTAGE_LIMIT_SETTING,
+    OD8_TDC_PERCENTAGE,
+    OD8_FULL_CONTROL_MODE_SETTING,
+    OD8_IDLE_POWER_SAVING_FEATURE_CONTROL,
+    OD8_RUNTIME_POWER_SAVING_FEATURE_CONTROL,
+    OD8_POWER_GAUGE,
+    OD8_COUNT
+} ADLOD8SettingId;
+
+
+//Define Performance Metrics Log max sensors number
+#define ADL_PMLOG_MAX_SENSORS  256
+
+/// \deprecated Replaced with ADL_PMLOG_SENSORS
+typedef enum ADLSensorType
+{
+    SENSOR_MAXTYPES             = 0,
+    PMLOG_CLK_GFXCLK            = 1,    // Current graphic clock value in MHz
+    PMLOG_CLK_MEMCLK            = 2,    // Current memory clock value in MHz
+    PMLOG_CLK_SOCCLK            = 3,
+    PMLOG_CLK_UVDCLK1           = 4,
+    PMLOG_CLK_UVDCLK2           = 5,
+    PMLOG_CLK_VCECLK            = 6,
+    PMLOG_CLK_VCNCLK            = 7,
+    PMLOG_TEMPERATURE_EDGE      = 8,    // Current edge of the die temperature value in C
+    PMLOG_TEMPERATURE_MEM       = 9,
+    PMLOG_TEMPERATURE_VRVDDC    = 10,
+    PMLOG_TEMPERATURE_VRMVDD    = 11,
+    PMLOG_TEMPERATURE_LIQUID    = 12,
+    PMLOG_TEMPERATURE_PLX       = 13,
+    PMLOG_FAN_RPM               = 14,   // Current fan RPM value
+    PMLOG_FAN_PERCENTAGE        = 15,   // Current ratio of fan RPM and max RPM
+    PMLOG_SOC_VOLTAGE           = 16,
+    PMLOG_SOC_POWER             = 17,
+    PMLOG_SOC_CURRENT           = 18,
+    PMLOG_INFO_ACTIVITY_GFX     = 19,   // Current graphic activity level in percentage
+    PMLOG_INFO_ACTIVITY_MEM     = 20,   // Current memory activity level in percentage
+    PMLOG_GFX_VOLTAGE           = 21,   // Current graphic voltage in mV
+    PMLOG_MEM_VOLTAGE           = 22,
+    PMLOG_ASIC_POWER            = 23,   // Current ASIC power draw in Watt
+    PMLOG_TEMPERATURE_VRSOC     = 24,
+    PMLOG_TEMPERATURE_VRMVDD0   = 25,
+    PMLOG_TEMPERATURE_VRMVDD1   = 26,
+    PMLOG_TEMPERATURE_HOTSPOT   = 27,   // Current center of the die temperature value in C
+    PMLOG_TEMPERATURE_GFX       = 28,
+    PMLOG_TEMPERATURE_SOC       = 29,
+    PMLOG_GFX_POWER             = 30,
+    PMLOG_GFX_CURRENT           = 31,
+    PMLOG_TEMPERATURE_CPU       = 32,
+    PMLOG_CPU_POWER             = 33,
+    PMLOG_CLK_CPUCLK            = 34,
+    PMLOG_THROTTLER_STATUS      = 35,   // A bit map of GPU throttle information. If a bit is set, the bit represented type of thorttling occurred in the last metrics sampling period
+    PMLOG_CLK_VCN1CLK1          = 36,
+    PMLOG_CLK_VCN1CLK2          = 37,
+    PMLOG_SMART_POWERSHIFT_CPU  = 38,
+    PMLOG_SMART_POWERSHIFT_DGPU = 39,
+    PMLOG_BUS_SPEED             = 40,   // Current PCIE bus speed running
+    PMLOG_BUS_LANES             = 41,   // Current PCIE bus lanes using
+    PMLOG_TEMPERATURE_LIQUID0   = 42,
+    PMLOG_TEMPERATURE_LIQUID1   = 43,
+    PMLOG_CLK_FCLK              = 44,
+    PMLOG_THROTTLER_STATUS_CPU  = 45,
+    PMLOG_SSPAIRED_ASICPOWER    = 46, // apuPower
+    PMLOG_SSTOTAL_POWERLIMIT    = 47, // Total Power limit    
+    PMLOG_SSAPU_POWERLIMIT      = 48, // APU Power limit
+    PMLOG_SSDGPU_POWERLIMIT     = 49, // DGPU Power limit
+    PMLOG_TEMPERATURE_HOTSPOT_GCD      = 50,
+    PMLOG_TEMPERATURE_HOTSPOT_MCD      = 51,
+    PMLOG_THROTTLER_TEMP_EDGE_PERCENTAGE        = 52,
+    PMLOG_THROTTLER_TEMP_HOTSPOT_PERCENTAGE     = 53,
+    PMLOG_THROTTLER_TEMP_HOTSPOT_GCD_PERCENTAGE = 54,
+    PMLOG_THROTTLER_TEMP_HOTSPOT_MCD_PERCENTAGE = 55,
+    PMLOG_THROTTLER_TEMP_MEM_PERCENTAGE     = 56,
+    PMLOG_THROTTLER_TEMP_VR_GFX_PERCENTAGE  = 57,
+    PMLOG_THROTTLER_TEMP_VR_MEM0_PERCENTAGE = 58,
+    PMLOG_THROTTLER_TEMP_VR_MEM1_PERCENTAGE = 59,
+    PMLOG_THROTTLER_TEMP_VR_SOC_PERCENTAGE  = 60,
+    PMLOG_THROTTLER_TEMP_LIQUID0_PERCENTAGE = 61,
+    PMLOG_THROTTLER_TEMP_LIQUID1_PERCENTAGE = 62,
+    PMLOG_THROTTLER_TEMP_PLX_PERCENTAGE = 63,
+    PMLOG_THROTTLER_TDC_GFX_PERCENTAGE  = 64,
+    PMLOG_THROTTLER_TDC_SOC_PERCENTAGE  = 65,
+    PMLOG_THROTTLER_TDC_USR_PERCENTAGE  = 66,
+    PMLOG_THROTTLER_PPT0_PERCENTAGE     = 67,
+    PMLOG_THROTTLER_PPT1_PERCENTAGE     = 68,
+    PMLOG_THROTTLER_PPT2_PERCENTAGE     = 69,
+    PMLOG_THROTTLER_PPT3_PERCENTAGE     = 70,
+    PMLOG_THROTTLER_FIT_PERCENTAGE           = 71,
+    PMLOG_THROTTLER_GFX_APCC_PLUS_PERCENTAGE = 72,
+    PMLOG_BOARD_POWER                        = 73,
+    PMLOG_MAX_SENSORS_REAL
+} ADLSensorType;
+
+
+//Throttle Status
+typedef enum ADL_THROTTLE_NOTIFICATION
+{
+	ADL_PMLOG_THROTTLE_POWER = 1 << 0,
+	ADL_PMLOG_THROTTLE_THERMAL = 1 << 1,
+	ADL_PMLOG_THROTTLE_CURRENT = 1 << 2,
+} ADL_THROTTLE_NOTIFICATION;
+
+typedef enum ADL_PMLOG_SENSORS
+{
+    ADL_SENSOR_MAXTYPES             = 0,
+    ADL_PMLOG_CLK_GFXCLK            = 1,
+    ADL_PMLOG_CLK_MEMCLK            = 2,
+    ADL_PMLOG_CLK_SOCCLK            = 3,
+    ADL_PMLOG_CLK_UVDCLK1           = 4,
+    ADL_PMLOG_CLK_UVDCLK2           = 5,
+    ADL_PMLOG_CLK_VCECLK            = 6,
+    ADL_PMLOG_CLK_VCNCLK            = 7,
+    ADL_PMLOG_TEMPERATURE_EDGE      = 8,
+    ADL_PMLOG_TEMPERATURE_MEM       = 9,
+    ADL_PMLOG_TEMPERATURE_VRVDDC    = 10,
+    ADL_PMLOG_TEMPERATURE_VRMVDD    = 11,
+    ADL_PMLOG_TEMPERATURE_LIQUID    = 12,
+    ADL_PMLOG_TEMPERATURE_PLX       = 13,
+    ADL_PMLOG_FAN_RPM               = 14,
+    ADL_PMLOG_FAN_PERCENTAGE        = 15,
+    ADL_PMLOG_SOC_VOLTAGE           = 16,
+    ADL_PMLOG_SOC_POWER             = 17,
+    ADL_PMLOG_SOC_CURRENT           = 18,
+    ADL_PMLOG_INFO_ACTIVITY_GFX     = 19,
+    ADL_PMLOG_INFO_ACTIVITY_MEM     = 20,
+    ADL_PMLOG_GFX_VOLTAGE           = 21,
+    ADL_PMLOG_MEM_VOLTAGE           = 22,
+    ADL_PMLOG_ASIC_POWER            = 23,
+    ADL_PMLOG_TEMPERATURE_VRSOC     = 24,
+    ADL_PMLOG_TEMPERATURE_VRMVDD0   = 25,
+    ADL_PMLOG_TEMPERATURE_VRMVDD1   = 26,
+    ADL_PMLOG_TEMPERATURE_HOTSPOT   = 27,
+    ADL_PMLOG_TEMPERATURE_GFX       = 28,
+    ADL_PMLOG_TEMPERATURE_SOC       = 29,
+    ADL_PMLOG_GFX_POWER             = 30,
+    ADL_PMLOG_GFX_CURRENT           = 31,
+    ADL_PMLOG_TEMPERATURE_CPU       = 32,
+    ADL_PMLOG_CPU_POWER             = 33,
+    ADL_PMLOG_CLK_CPUCLK            = 34,
+    ADL_PMLOG_THROTTLER_STATUS      = 35,   // GFX
+    ADL_PMLOG_CLK_VCN1CLK1          = 36,
+    ADL_PMLOG_CLK_VCN1CLK2          = 37,
+    ADL_PMLOG_SMART_POWERSHIFT_CPU  = 38,
+    ADL_PMLOG_SMART_POWERSHIFT_DGPU = 39,
+    ADL_PMLOG_BUS_SPEED             = 40,
+    ADL_PMLOG_BUS_LANES             = 41,
+    ADL_PMLOG_TEMPERATURE_LIQUID0   = 42,
+    ADL_PMLOG_TEMPERATURE_LIQUID1   = 43,
+    ADL_PMLOG_CLK_FCLK              = 44,
+    ADL_PMLOG_THROTTLER_STATUS_CPU  = 45,
+    ADL_PMLOG_SSPAIRED_ASICPOWER    = 46, // apuPower
+    ADL_PMLOG_SSTOTAL_POWERLIMIT    = 47, // Total Power limit
+    ADL_PMLOG_SSAPU_POWERLIMIT      = 48, // APU Power limit
+    ADL_PMLOG_SSDGPU_POWERLIMIT     = 49, // DGPU Power limit
+    ADL_PMLOG_TEMPERATURE_HOTSPOT_GCD      = 50,
+    ADL_PMLOG_TEMPERATURE_HOTSPOT_MCD      = 51,
+    ADL_PMLOG_THROTTLER_TEMP_EDGE_PERCENTAGE        = 52,
+    ADL_PMLOG_THROTTLER_TEMP_HOTSPOT_PERCENTAGE     = 53,
+    ADL_PMLOG_THROTTLER_TEMP_HOTSPOT_GCD_PERCENTAGE = 54,
+    ADL_PMLOG_THROTTLER_TEMP_HOTSPOT_MCD_PERCENTAGE = 55,
+    ADL_PMLOG_THROTTLER_TEMP_MEM_PERCENTAGE     = 56,
+    ADL_PMLOG_THROTTLER_TEMP_VR_GFX_PERCENTAGE  = 57,
+    ADL_PMLOG_THROTTLER_TEMP_VR_MEM0_PERCENTAGE = 58,
+    ADL_PMLOG_THROTTLER_TEMP_VR_MEM1_PERCENTAGE = 59,
+    ADL_PMLOG_THROTTLER_TEMP_VR_SOC_PERCENTAGE  = 60,
+    ADL_PMLOG_THROTTLER_TEMP_LIQUID0_PERCENTAGE = 61,
+    ADL_PMLOG_THROTTLER_TEMP_LIQUID1_PERCENTAGE = 62,
+    ADL_PMLOG_THROTTLER_TEMP_PLX_PERCENTAGE = 63,
+    ADL_PMLOG_THROTTLER_TDC_GFX_PERCENTAGE  = 64,
+    ADL_PMLOG_THROTTLER_TDC_SOC_PERCENTAGE  = 65,
+    ADL_PMLOG_THROTTLER_TDC_USR_PERCENTAGE  = 66,
+    ADL_PMLOG_THROTTLER_PPT0_PERCENTAGE     = 67,
+    ADL_PMLOG_THROTTLER_PPT1_PERCENTAGE     = 68,
+    ADL_PMLOG_THROTTLER_PPT2_PERCENTAGE     = 69,
+    ADL_PMLOG_THROTTLER_PPT3_PERCENTAGE     = 70,
+    ADL_PMLOG_THROTTLER_FIT_PERCENTAGE           = 71,
+    ADL_PMLOG_THROTTLER_GFX_APCC_PLUS_PERCENTAGE = 72,
+    ADL_PMLOG_BOARD_POWER                        = 73,
+    ADL_PMLOG_MAX_SENSORS_REAL
+} ADL_PMLOG_SENSORS;
+
+/// \defgroup define_ecc_mode_states
+/// These defines the ECC(Error Correction Code) state. It is used by \ref ADL_Workstation_ECC_Get,ADL_Workstation_ECC_Set
+/// @{
+/// Error Correction is OFF.
+#define ECC_MODE_OFF 0
+/// Error Correction is ECCV2.
+#define ECC_MODE_ON 2
+/// Error Correction is HBM.
+#define ECC_MODE_HBM 3
+/// @}
+
+/// \defgroup define_board_layout_flags
+/// These defines are the board layout flags state which indicates what are the valid properties of \ref ADLBoardLayoutInfo . It is used by \ref ADL_Adapter_BoardLayout_Get
+/// @{
+/// Indicates the number of slots is valid.
+#define ADL_BLAYOUT_VALID_NUMBER_OF_SLOTS 0x1
+/// Indicates the slot sizes are valid. Size of the slot consists of the length and width.
+#define ADL_BLAYOUT_VALID_SLOT_SIZES 0x2
+/// Indicates the connector offsets are valid.
+#define ADL_BLAYOUT_VALID_CONNECTOR_OFFSETS 0x4
+/// Indicates the connector lengths is valid.
+#define ADL_BLAYOUT_VALID_CONNECTOR_LENGTHS 0x8
+/// @}
+
+/// \defgroup define_max_constants
+/// These defines are the maximum value constants.
+/// @{
+/// Indicates the Maximum supported slots on board.
+#define ADL_ADAPTER_MAX_SLOTS 4
+/// Indicates the Maximum supported connectors on slot.
+#define ADL_ADAPTER_MAX_CONNECTORS 10
+/// Indicates the Maximum supported properties of connection
+#define ADL_MAX_CONNECTION_TYPES 32
+/// Indicates the Maximum relative address link count.
+#define ADL_MAX_RELATIVE_ADDRESS_LINK_COUNT 15
+/// Indicates the Maximum size of EDID data block size
+#define ADL_MAX_DISPLAY_EDID_DATA_SIZE 1024
+/// Indicates the Maximum count of Error Records.
+#define ADL_MAX_ERROR_RECORDS_COUNT  256
+/// Indicates the maximum number of power states supported
+#define ADL_MAX_POWER_POLICY    6
+/// @}
+
+/// \defgroup define_connection_types
+/// These defines are the connection types constants which indicates  what are the valid connection type of given connector. It is used by \ref ADL_Adapter_SupportedConnections_Get
+/// @{
+/// Indicates the VGA connection type is valid.
+#define ADL_CONNECTION_TYPE_VGA 0
+/// Indicates the DVI_I connection type is valid.
+#define ADL_CONNECTION_TYPE_DVI 1
+/// Indicates the DVI_SL connection type is valid.
+#define ADL_CONNECTION_TYPE_DVI_SL 2
+/// Indicates the HDMI connection type is valid.
+#define ADL_CONNECTION_TYPE_HDMI 3
+/// Indicates the DISPLAY PORT connection type is valid.
+#define ADL_CONNECTION_TYPE_DISPLAY_PORT 4
+/// Indicates the Active dongle DP->DVI(single link) connection type is valid.
+#define ADL_CONNECTION_TYPE_ACTIVE_DONGLE_DP_DVI_SL 5
+/// Indicates the Active dongle DP->DVI(double link) connection type is valid.
+#define ADL_CONNECTION_TYPE_ACTIVE_DONGLE_DP_DVI_DL 6
+/// Indicates the Active dongle DP->HDMI connection type is valid.
+#define ADL_CONNECTION_TYPE_ACTIVE_DONGLE_DP_HDMI 7
+/// Indicates the Active dongle DP->VGA connection type is valid.
+#define ADL_CONNECTION_TYPE_ACTIVE_DONGLE_DP_VGA 8
+/// Indicates the Passive dongle DP->HDMI connection type is valid.
+#define ADL_CONNECTION_TYPE_PASSIVE_DONGLE_DP_HDMI 9
+/// Indicates the Active dongle DP->VGA connection type is valid.
+#define ADL_CONNECTION_TYPE_PASSIVE_DONGLE_DP_DVI 10
+/// Indicates the MST type is valid.
+#define ADL_CONNECTION_TYPE_MST 11
+/// Indicates the active dongle, all types.
+#define ADL_CONNECTION_TYPE_ACTIVE_DONGLE          12
+/// Indicates the Virtual Connection Type.
+#define ADL_CONNECTION_TYPE_VIRTUAL    13
+/// Macros for generating bitmask from index.
+#define ADL_CONNECTION_BITMAST_FROM_INDEX(index) (1 << index)
+/// @}
+
+/// \defgroup define_connection_properties
+/// These defines are the connection properties which indicates what are the valid properties of given connection type. It is used by \ref ADL_Adapter_SupportedConnections_Get
+/// @{
+/// Indicates the property Bitrate is valid.
+#define ADL_CONNECTION_PROPERTY_BITRATE 0x1
+/// Indicates the property number of lanes is valid.
+#define ADL_CONNECTION_PROPERTY_NUMBER_OF_LANES 0x2
+/// Indicates the property 3D caps is valid.
+#define ADL_CONNECTION_PROPERTY_3DCAPS  0x4
+/// Indicates the property output bandwidth is valid.
+#define ADL_CONNECTION_PROPERTY_OUTPUT_BANDWIDTH 0x8
+/// Indicates the property colordepth is valid.
+#define ADL_CONNECTION_PROPERTY_COLORDEPTH  0x10
+/// @}
+
+/// \defgroup define_lanecount_constants
+/// These defines are the Lane count constants which will be used in DP & etc.
+/// @{
+/// Indicates if lane count is unknown
+#define ADL_LANECOUNT_UNKNOWN 0
+/// Indicates if lane count is 1
+#define ADL_LANECOUNT_ONE 1
+/// Indicates if lane count is 2
+#define ADL_LANECOUNT_TWO 2
+/// Indicates if lane count is 4
+#define ADL_LANECOUNT_FOUR 4
+/// Indicates if lane count is 8
+#define ADL_LANECOUNT_EIGHT 8
+/// Indicates default value of lane count
+#define ADL_LANECOUNT_DEF ADL_LANECOUNT_FOUR
+/// @}
+
+/// \defgroup define_linkrate_constants
+/// These defines are the link rate constants which will be used in DP & etc.
+/// @{
+/// Indicates if link rate is unknown
+#define ADL_LINK_BITRATE_UNKNOWN 0
+/// Indicates if link rate is 1.62Ghz
+#define ADL_LINK_BITRATE_1_62_GHZ 0x06
+/// Indicates if link rate is 2.7Ghz
+#define ADL_LINK_BITRATE_2_7_GHZ 0x0A
+/// Indicates if link rate is 5.4Ghz
+#define ADL_LINK_BITRATE_5_4_GHZ 0x14
+
+/// Indicates if link rate is 8.1Ghz
+#define ADL_LINK_BITRATE_8_1_GHZ 0x1E
+/// Indicates default value of link rate
+#define ADL_LINK_BITRATE_DEF ADL_LINK_BITRATE_2_7_GHZ
+/// @}
+
+/// \defgroup define_colordepth_constants
+/// These defines are the color depth constants which will be used in DP & etc.
+/// @{
+#define ADL_CONNPROP_S3D_ALTERNATE_TO_FRAME_PACK            0x00000001
+/// @}
+
+
+/// \defgroup define_colordepth_constants
+/// These defines are the color depth constants which will be used in DP & etc.
+/// @{
+/// Indicates if color depth is unknown
+#define ADL_COLORDEPTH_UNKNOWN 0
+/// Indicates if color depth is 666
+#define ADL_COLORDEPTH_666 1
+/// Indicates if color depth is 888
+#define ADL_COLORDEPTH_888 2
+/// Indicates if color depth is 101010
+#define ADL_COLORDEPTH_101010 3
+/// Indicates if color depth is 121212
+#define ADL_COLORDEPTH_121212 4
+/// Indicates if color depth is 141414
+#define ADL_COLORDEPTH_141414 5
+/// Indicates if color depth is 161616
+#define ADL_COLORDEPTH_161616 6
+/// Indicates default value of color depth
+#define ADL_COLOR_DEPTH_DEF ADL_COLORDEPTH_888
+/// @}
+
+
+/// \defgroup define_emulation_status
+/// These defines are the status of emulation
+/// @{
+/// Indicates if real device is connected.
+#define ADL_EMUL_STATUS_REAL_DEVICE_CONNECTED 0x1
+/// Indicates if emulated device is presented.
+#define ADL_EMUL_STATUS_EMULATED_DEVICE_PRESENT 0x2
+/// Indicates if emulated device is used.
+#define ADL_EMUL_STATUS_EMULATED_DEVICE_USED  0x4
+/// In case when last active real/emulated device used (when persistence is enabled but no emulation enforced then persistence will use last connected/emulated device).
+#define ADL_EMUL_STATUS_LAST_ACTIVE_DEVICE_USED 0x8
+/// @}
+
+/// \defgroup define_emulation_mode
+/// These defines are the modes of emulation
+/// @{
+/// Indicates if no emulation is used
+#define ADL_EMUL_MODE_OFF 0
+/// Indicates if emulation is used when display connected
+#define ADL_EMUL_MODE_ON_CONNECTED 1
+/// Indicates if emulation is used when display dis connected
+#define ADL_EMUL_MODE_ON_DISCONNECTED 2
+/// Indicates if emulation is used always
+#define ADL_EMUL_MODE_ALWAYS 3
+/// @}
+
+/// \defgroup define_emulation_query
+/// These defines are the modes of emulation
+/// @{
+/// Indicates Data from real device
+#define ADL_QUERY_REAL_DATA 0
+/// Indicates Emulated data
+#define ADL_QUERY_EMULATED_DATA 1
+/// Indicates Data currently in use
+#define ADL_QUERY_CURRENT_DATA 2
+/// @}
+
+/// \defgroup define_persistence_state
+/// These defines are the states of persistence
+/// @{
+/// Indicates persistence is disabled
+#define ADL_EDID_PERSISTANCE_DISABLED 0
+/// Indicates persistence is enabled
+#define ADL_EDID_PERSISTANCE_ENABLED 1
+/// @}
+
+/// \defgroup define_connector_types Connector Type
+/// defines for ADLConnectorInfo.iType
+/// @{
+/// Indicates unknown Connector type
+#define ADL_CONNECTOR_TYPE_UNKNOWN                 0
+/// Indicates VGA Connector type
+#define ADL_CONNECTOR_TYPE_VGA                     1
+/// Indicates DVI-D Connector type
+#define ADL_CONNECTOR_TYPE_DVI_D                   2
+/// Indicates DVI-I Connector type
+#define ADL_CONNECTOR_TYPE_DVI_I                   3
+/// Indicates Active Dongle-NA Connector type
+#define ADL_CONNECTOR_TYPE_ATICVDONGLE_NA          4
+/// Indicates Active Dongle-JP Connector type
+#define ADL_CONNECTOR_TYPE_ATICVDONGLE_JP          5
+/// Indicates Active Dongle-NONI2C Connector type
+#define ADL_CONNECTOR_TYPE_ATICVDONGLE_NONI2C      6
+/// Indicates Active Dongle-NONI2C-D Connector type
+#define ADL_CONNECTOR_TYPE_ATICVDONGLE_NONI2C_D    7
+/// Indicates HDMI-Type A Connector type
+#define ADL_CONNECTOR_TYPE_HDMI_TYPE_A             8
+/// Indicates HDMI-Type B Connector type
+#define ADL_CONNECTOR_TYPE_HDMI_TYPE_B             9
+/// Indicates Display port Connector type
+#define ADL_CONNECTOR_TYPE_DISPLAYPORT             10
+/// Indicates EDP Connector type
+#define ADL_CONNECTOR_TYPE_EDP                     11
+/// Indicates MiniDP Connector type
+#define ADL_CONNECTOR_TYPE_MINI_DISPLAYPORT        12
+/// Indicates Virtual Connector type
+#define ADL_CONNECTOR_TYPE_VIRTUAL                   13
+/// Indicates USB type C Connector type
+#define ADL_CONNECTOR_TYPE_USB_TYPE_C              14
+/// @}
+
+/// \defgroup define_freesync_usecase
+/// These defines are to specify use cases in which FreeSync should be enabled
+/// They are a bit mask. To specify FreeSync for more than one use case, the input value
+/// should be set to include multiple bits set
+/// @{
+/// Indicates FreeSync is enabled for Static Screen case
+#define ADL_FREESYNC_USECASE_STATIC                 0x1
+/// Indicates FreeSync is enabled for Video use case
+#define ADL_FREESYNC_USECASE_VIDEO                  0x2
+/// Indicates FreeSync is enabled for Gaming use case
+#define ADL_FREESYNC_USECASE_GAMING                 0x4
+/// @}
+
+/// \defgroup define_freesync_caps
+/// These defines are used to retrieve FreeSync display capabilities.
+/// GPU support flag also indicates whether the display is
+/// connected to a GPU that actually supports FreeSync
+/// @{
+#define ADL_FREESYNC_CAP_SUPPORTED                      (1 << 0)
+#define ADL_FREESYNC_CAP_GPUSUPPORTED                   (1 << 1)
+#define ADL_FREESYNC_CAP_DISPLAYSUPPORTED               (1 << 2)
+#define ADL_FREESYNC_CAP_CURRENTMODESUPPORTED           (1 << 3)
+#define ADL_FREESYNC_CAP_NOCFXORCFXSUPPORTED            (1 << 4)
+#define ADL_FREESYNC_CAP_NOGENLOCKORGENLOCKSUPPORTED    (1 << 5)
+#define ADL_FREESYNC_CAP_BORDERLESSWINDOWSUPPORTED      (1 << 6)
+/// @}
+
+/// \defgroup define_freesync_labelIndex
+/// These defines are used to retrieve which FreeSync label to use
+/// @{
+#define ADL_FREESYNC_LABEL_UNSUPPORTED            0
+#define ADL_FREESYNC_LABEL_FREESYNC               1
+#define ADL_FREESYNC_LABEL_ADAPTIVE_SYNC          2
+#define ADL_FREESYNC_LABEL_VRR                    3
+#define ADL_FREESYNC_LABEL_FREESYNC_PREMIUM       4
+#define ADL_FREESYNC_LABEL_FREESYNC_PREMIUM_PRO   5
+/// @}
+
+/// Freesync Power optimization masks
+/// @{
+#define ADL_FREESYNC_POWEROPTIMIZATION_SUPPORTED_MASK		(1 << 0)
+#define ADL_FREESYNC_POWEROPTIMIZATION_ENABLED_MASK			(1 << 1)
+#define ADL_FREESYNC_POWEROPTIMIZATION_DEFAULT_VALUE_MASK	(1 << 2)
+/// @}
+
+/// \defgroup define_MST_CommandLine_execute
+/// @{
+/// Indicates the MST command line for branch message if the bit is set. Otherwise, it is display message
+#define ADL_MST_COMMANDLINE_PATH_MSG                 0x1
+/// Indicates the MST command line to send message in broadcast way it the bit is set
+#define ADL_MST_COMMANDLINE_BROADCAST                  0x2
+
+/// @}
+
+
+/// \defgroup define_Adapter_CloneTypes_Get
+/// @{
+/// Indicates there is crossGPU clone with non-AMD dispalys
+#define ADL_CROSSGPUDISPLAYCLONE_AMD_WITH_NONAMD                 0x1
+/// Indicates there is crossGPU clone
+#define ADL_CROSSGPUDISPLAYCLONE                  0x2
+
+/// @}
+
+/// \defgroup define_D3DKMT_HANDLE
+/// @{
+/// Handle can be used to create Device Handle when using CreateDevice()
+typedef unsigned int ADL_D3DKMT_HANDLE;
+/// @}
+
+
+// End Bracket for Constants and Definitions. Add new groups ABOVE this line!
+
+/// @}
+
+
+typedef enum ADL_RAS_ERROR_INJECTION_MODE
+{
+	ADL_RAS_ERROR_INJECTION_MODE_SINGLE = 1,
+	ADL_RAS_ERROR_INJECTION_MODE_MULTIPLE = 2
+}ADL_RAS_ERROR_INJECTION_MODE;
+
+
+typedef enum ADL_RAS_BLOCK_ID
+{
+	ADL_RAS_BLOCK_ID_UMC = 0,
+	ADL_RAS_BLOCK_ID_SDMA,
+	ADL_RAS_BLOCK_ID_GFX_HUB,
+	ADL_RAS_BLOCK_ID_MMHUB,
+	ADL_RAS_BLOCK_ID_ATHUB,
+	ADL_RAS_BLOCK_ID_PCIE_BIF,
+	ADL_RAS_BLOCK_ID_HDP,
+	ADL_RAS_BLOCK_ID_XGMI_WAFL,
+	ADL_RAS_BLOCK_ID_DF,
+	ADL_RAS_BLOCK_ID_SMN,
+	ADL_RAS_BLOCK_ID_SEM,
+	ADL_RAS_BLOCK_ID_MP0,
+	ADL_RAS_BLOCK_ID_MP1,
+	ADL_RAS_BLOCK_ID_FUSE
+}ADL_RAS_BLOCK_ID;
+
+typedef enum ADL_MEM_SUB_BLOCK_ID
+{
+	ADL_RAS__UMC_HBM = 0,
+	ADL_RAS__UMC_SRAM = 1
+}ADL_MEM_SUB_BLOCK_ID;
+
+typedef enum  _ADL_RAS_ERROR_TYPE
+{
+	ADL_RAS_ERROR__NONE = 0,
+	ADL_RAS_ERROR__PARITY = 1,
+	ADL_RAS_ERROR__SINGLE_CORRECTABLE = 2,
+	ADL_RAS_ERROR__PARITY_SINGLE_CORRECTABLE = 3,
+	ADL_RAS_ERROR__MULTI_UNCORRECTABLE = 4,
+	ADL_RAS_ERROR__PARITY_MULTI_UNCORRECTABLE = 5,
+	ADL_RAS_ERROR__SINGLE_CORRECTABLE_MULTI_UNCORRECTABLE = 6,
+	ADL_RAS_ERROR__PARITY_SINGLE_CORRECTABLE_MULTI_UNCORRECTABLE = 7,
+	ADL_RAS_ERROR__POISON = 8,
+	ADL_RAS_ERROR__PARITY_POISON = 9,
+	ADL_RAS_ERROR__SINGLE_CORRECTABLE_POISON = 10,
+	ADL_RAS_ERROR__PARITY_SINGLE_CORRECTABLE_POISON = 11,
+	ADL_RAS_ERROR__MULTI_UNCORRECTABLE_POISON = 12,
+	ADL_RAS_ERROR__PARITY_MULTI_UNCORRECTABLE_POISON = 13,
+	ADL_RAS_ERROR__SINGLE_CORRECTABLE_MULTI_UNCORRECTABLE_POISON = 14,
+	ADL_RAS_ERROR__PARITY_SINGLE_CORRECTABLE_MULTI_UNCORRECTABLE_POISON = 15
+}ADL_RAS_ERROR_TYPE;
+
+typedef enum ADL_RAS_INJECTION_METHOD
+{
+	ADL_RAS_ERROR__UMC_METH_COHERENT = 0,
+	ADL_RAS_ERROR__UMC_METH_SINGLE_SHOT = 1,
+	ADL_RAS_ERROR__UMC_METH_PERSISTENT = 2,
+	ADL_RAS_ERROR__UMC_METH_PERSISTENT_DISABLE = 3
+}ADL_RAS_INJECTION_METHOD;
+
+// Driver event types
+typedef enum ADL_DRIVER_EVENT_TYPE
+{
+	ADL_EVENT_ID_AUTO_FEATURE_COMPLETED = 30,
+	ADL_EVENT_ID_FEATURE_AVAILABILITY = 31,
+
+} ADL_DRIVER_EVENT_TYPE;
+
+
+//UIFeature Ids
+typedef enum ADL_UIFEATURES_GROUP
+{
+	ADL_UIFEATURES_GROUP_DVR = 0,
+	ADL_UIFEATURES_GROUP_TURBOSYNC = 1,
+	ADL_UIFEATURES_GROUP_FRAMEMETRICSMONITOR = 2,
+	ADL_UIFEATURES_GROUP_FRTC = 3,
+	ADL_UIFEATURES_GROUP_XVISION = 4,
+	ADL_UIFEATURES_GROUP_BLOCKCHAIN = 5,
+	ADL_UIFEATURES_GROUP_GAMEINTELLIGENCE = 6,
+	ADL_UIFEATURES_GROUP_CHILL = 7,
+	ADL_UIFEATURES_GROUP_DELAG = 8,
+	ADL_UIFEATURES_GROUP_BOOST = 9,
+	ADL_UIFEATURES_GROUP_USU = 10,
+	ADL_UIFEATURES_GROUP_XGMI = 11,
+	ADL_UIFEATURES_GROUP_PROVSR = 12,
+    ADL_UIFEATURES_GROUP_SMA = 13,
+    ADL_UIFEATURES_GROUP_CAMERA = 14,
+    ADL_UIFEATURES_GROUP_FRTCPRO = 15
+} ADL_UIFEATURES_GROUP;
+
+
+
+/// Maximum brightness supported by Radeon LED interface
+#define ADL_RADEON_LED_MAX_BRIGHTNESS		2
+
+/// Maximum speed supported by Radeon LED interface
+#define ADL_RADEON_LED_MAX_SPEED	        4
+
+/// Maximum RGB supported by Radeon LED interface
+#define ADL_RADEON_LED_MAX_RGB	            255
+
+/// Maximum MORSE code supported string
+#define ADL_RADEON_LED_MAX_MORSE_CODE       260
+
+/// Maximum LED ROW ON GRID
+#define ADL_RADEON_LED_MAX_LED_ROW_ON_GRID      7
+
+/// Maximum LED COLUMN ON GRID
+#define ADL_RADEON_LED_MAX_LED_COLUMN_ON_GRID   24
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief
+///
+///
+///
+///
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef enum ADL_RADEON_USB_LED_BAR_CONTROLS
+{
+   RadeonLEDBarControl_OFF = 0,
+   RadeonLEDBarControl_Static,
+   RadeonLEDBarControl_Rainbow,
+   RadeonLEDBarControl_Swirl,
+   RadeonLEDBarControl_Chase,
+   RadeonLEDBarControl_Bounce,
+   RadeonLEDBarControl_MorseCode,
+   RadeonLEDBarControl_ColorCycle,
+   RadeonLEDBarControl_Breathing,
+   RadeonLEDBarControl_CustomPattern,
+   RadeonLEDBarControl_MAX
+}ADL_RADEON_USB_LED_BAR_CONTROLS;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief
+///
+///
+///
+///
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef unsigned int RadeonLEDBARSupportedControl;
+
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief
+///
+///
+///
+///
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef enum ADL_RADEON_USB_LED_CONTROL_CONFIGS
+{
+   RadeonLEDPattern_Speed = 0,
+   RadeonLEDPattern_Brightness,
+   RadeonLEDPattern_Direction,
+   RadeonLEDPattern_Color,
+   RadeonLEDPattern_MAX
+}ADL_RADEON_USB_LED_CONTROL_CONFIGS;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief
+///
+///
+///
+///
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef unsigned int RadeonLEDBARSupportedConfig;
+
+//User blob feature settings
+typedef enum ADL_USER_SETTINGS
+{
+    ADL_USER_SETTINGS_ENHANCEDSYNC = 1 << 0,          //notify Enhanced Sync settings change
+    ADL_USER_SETTINGS_CHILL_PROFILE = 1 << 1,          //notify Chill settings change
+    ADL_USER_SETTINGS_DELAG_PROFILE = 1 << 2,          //notify Delag settings change
+    ADL_USER_SETTINGS_BOOST_PROFILE = 1 << 3,			//notify Boost settings change
+    ADL_USER_SETTINGS_USU_PROFILE = 1 << 4,  		//notify USU settings change
+    ADL_USER_SETTINGS_CVDC_PROFILE = 1 << 5,			//notify Color Vision Deficiency Corretion settings change
+    ADL_USER_SETTINGS_SCE_PROFILE = 1 << 6,
+    ADL_USER_SETTINGS_PROVSR = 1 << 7
+   } ADL_USER_SETTINGS;
+
+#define ADL_REG_DEVICE_FUNCTION_1            0x00000001
+#endif /* ADL_DEFINES_H_ */
+
+
diff --git a/dlls/atiadlxx/amdheaders/adl_sdk.h b/dlls/atiadlxx/amdheaders/adl_sdk.h
new file mode 100644
index 00000000000..4cdb44b5c22
--- /dev/null
+++ b/dlls/atiadlxx/amdheaders/adl_sdk.h
@@ -0,0 +1,46 @@
+//
+// Copyright (c) 2016 - 2022 Advanced Micro Devices, Inc. All rights reserved.
+//
+// MIT LICENSE:
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+/// \file adl_sdk.h
+/// \brief Contains the definition of the Memory Allocation Callback.\n <b>Included in ADL SDK</b>
+///
+/// \n\n
+/// This file contains the definition of the Memory Allocation Callback.\n
+/// It also includes definitions of the respective structures and constants.\n
+/// <b> This is the only header file to be included in a C/C++ project using ADL </b>
+
+#ifndef ADL_SDK_H_
+#define ADL_SDK_H_
+
+#include "adl_structures.h"
+
+#if defined (LINUX)
+#define __stdcall
+#endif /* (LINUX) */
+
+/// Memory Allocation Call back
+typedef void* ( __stdcall *ADL_MAIN_MALLOC_CALLBACK )( int );
+
+#define ADL_SDK_MAJOR_VERSION 17
+#define ADL_SDK_MINOR_VERSION 1
+
+#endif /* ADL_SDK_H_ */
diff --git a/dlls/atiadlxx/amdheaders/adl_structures.h b/dlls/atiadlxx/amdheaders/adl_structures.h
new file mode 100644
index 00000000000..601ad74bd83
--- /dev/null
+++ b/dlls/atiadlxx/amdheaders/adl_structures.h
@@ -0,0 +1,4289 @@
+//
+// Copyright (c) 2016 - 2022 Advanced Micro Devices, Inc. All rights reserved.
+//
+// MIT LICENSE:
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+/// \file adl_structures.h
+///\brief This file contains the structure declarations that are used by the public ADL interfaces for \ALL platforms.\n <b>Included in ADL SDK</b>
+///
+/// All data structures used in AMD Display Library (ADL) public interfaces should be defined in this header file.
+///
+
+#ifndef ADL_STRUCTURES_H_
+#define ADL_STRUCTURES_H_
+
+#include "adl_defines.h"
+#include <stdbool.h>
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the graphics adapter.
+///
+/// This structure is used to store various information about the graphics adapter.  This
+/// information can be returned to the user. Alternatively, it can be used to access various driver calls to set
+/// or fetch various settings upon the user's request.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct AdapterInfo
+{
+/// \ALL_STRUCT_MEM
+
+/// Size of the structure.
+    int iSize;
+/// The ADL index handle. One GPU may be associated with one or two index handles
+    int iAdapterIndex;
+/// The unique device ID associated with this adapter.
+    char strUDID[ADL_MAX_PATH];
+/// The BUS number associated with this adapter.
+    int iBusNumber;
+/// The driver number associated with this adapter.
+    int iDeviceNumber;
+/// The function number.
+    int iFunctionNumber;
+/// The vendor ID associated with this adapter.
+    int iVendorID;
+/// Adapter name.
+    char strAdapterName[ADL_MAX_PATH];
+/// Display name. For example, "\\\\Display0" for Windows or ":0:0" for Linux.
+    char strDisplayName[ADL_MAX_PATH];
+/// Present or not; 1 if present and 0 if not present.It the logical adapter is present, the display name such as \\\\.\\Display1 can be found from OS
+    int iPresent;
+
+#if defined (_WIN32) || defined (_WIN64)
+/// \WIN_STRUCT_MEM
+
+/// Exist or not; 1 is exist and 0 is not present.
+    int iExist;
+/// Driver registry path.
+    char strDriverPath[ADL_MAX_PATH];
+/// Driver registry path Ext for.
+    char strDriverPathExt[ADL_MAX_PATH];
+/// PNP string from Windows.
+    char strPNPString[ADL_MAX_PATH];
+/// It is generated from EnumDisplayDevices.
+    int iOSDisplayIndex;
+
+#endif /* (_WIN32) || (_WIN64) */
+
+#if defined (LINUX)
+/// \LNX_STRUCT_MEM
+
+/// Internal X screen number from GPUMapInfo (DEPRICATED use XScreenInfo)
+    int iXScreenNum;
+/// Internal driver index from GPUMapInfo
+    int iDrvIndex;
+/// \deprecated Internal x config file screen identifier name. Use XScreenInfo instead.
+    char strXScreenConfigName[ADL_MAX_PATH];
+
+#endif /* (LINUX) */
+} AdapterInfo, *LPAdapterInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the Linux X screen information.
+///
+/// This structure is used to store the current screen number and xorg.conf ID name assoicated with an adapter index.
+/// This structure is updated during ADL_Main_Control_Refresh or ADL_ScreenInfo_Update.
+/// Note:  This structure should be used in place of iXScreenNum and strXScreenConfigName in AdapterInfo as they will be
+/// deprecated.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+#if defined (LINUX)
+typedef struct XScreenInfo
+{
+/// Internal X screen number from GPUMapInfo.
+    int iXScreenNum;
+/// Internal x config file screen identifier name.
+    char strXScreenConfigName[ADL_MAX_PATH];
+} XScreenInfo, *LPXScreenInfo;
+#endif /* (LINUX) */
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about an controller mode
+///
+/// This structure is used to store information of an controller mode
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLAdapterCaps
+{
+	/// AdapterID for this adapter
+	int iAdapterID;
+	/// Number of controllers for this adapter
+	int iNumControllers;
+	/// Number of displays for this adapter
+	int iNumDisplays;
+	/// Number of overlays for this adapter
+	int iNumOverlays;
+	/// Number of GLSyncConnectors
+	int iNumOfGLSyncConnectors;
+	/// The bit mask identifies the adapter caps
+	int iCapsMask;
+	/// The bit identifies the adapter caps \ref define_adapter_caps
+	int iCapsValue;
+}ADLAdapterCaps;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing additional information about the ASIC memory
+///
+/// This structure is used to store additional information about the ASIC memory.  This
+/// information can be returned to the user.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLMemoryInfo2
+{
+	/// Memory size in bytes.
+	long long iMemorySize;
+	/// Memory type in string.
+	char strMemoryType[ADL_MAX_PATH];
+	/// Highest default performance level Memory bandwidth in Mbytes/s
+	long long iMemoryBandwidth;
+	/// HyperMemory size in bytes.
+	long long iHyperMemorySize;
+
+	/// Invisible Memory size in bytes.
+	long long iInvisibleMemorySize;
+	/// Visible Memory size in bytes.
+	long long iVisibleMemorySize;
+} ADLMemoryInfo2, *LPADLMemoryInfo2;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing additional information about the ASIC memory
+///
+/// This structure is used to store additional information about the ASIC memory.  This
+/// information can be returned to the user.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLMemoryInfo3
+{
+    /// Memory size in bytes.
+    long long iMemorySize;
+    /// Memory type in string.
+    char strMemoryType[ADL_MAX_PATH];
+    /// Highest default performance level Memory bandwidth in Mbytes/s
+    long long iMemoryBandwidth;
+    /// HyperMemory size in bytes.
+    long long iHyperMemorySize;
+
+    /// Invisible Memory size in bytes.
+    long long iInvisibleMemorySize;
+    /// Visible Memory size in bytes.
+    long long iVisibleMemorySize;
+    /// Vram vendor ID
+    long long iVramVendorRevId;
+} ADLMemoryInfo3, *LPADLMemoryInfo3;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing additional information about the ASIC memory
+///
+/// This structure is used to store additional information about the ASIC memory.  This
+/// information can be returned to the user.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLMemoryInfoX4
+{
+    /// Memory size in bytes.
+    long long iMemorySize;
+    /// Memory type in string.
+    char strMemoryType[ADL_MAX_PATH];
+    /// Highest default performance level Memory bandwidth in Mbytes/s
+    long long iMemoryBandwidth;
+    /// HyperMemory size in bytes.
+    long long iHyperMemorySize;
+
+    /// Invisible Memory size in bytes.
+    long long iInvisibleMemorySize;
+    /// Visible Memory size in bytes.
+    long long iVisibleMemorySize;
+    /// Vram vendor ID
+    long long iVramVendorRevId;
+    /// Memory Bandiwidth that is calculated and finalized on the driver side, grab and go.
+    long long iMemoryBandwidthX2;
+    /// Memory Bit Rate that is calculated and finalized on the driver side, grab and go.
+    long long iMemoryBitRateX2;
+
+} ADLMemoryInfoX4, *LPADLMemoryInfoX4;
+
+///////////////////////////////////////////////////////////////////////////
+// ADLvRamVendor Enumeration
+///////////////////////////////////////////////////////////////////////////
+enum ADLvRamVendors
+{
+    ADLvRamVendor_Unsupported = 0x0,
+    ADLvRamVendor_SAMSUNG,
+    ADLvRamVendor_INFINEON,
+    ADLvRamVendor_ELPIDA,
+    ADLvRamVendor_ETRON,
+    ADLvRamVendor_NANYA,
+    ADLvRamVendor_HYNIX,
+    ADLvRamVendor_MOSEL,
+    ADLvRamVendor_WINBOND,
+    ADLvRamVendor_ESMT,
+    ADLvRamVendor_MICRON = 0xF,
+    ADLvRamVendor_Undefined
+};
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about components of ASIC GCN architecture
+///
+///  Elements of GCN info are compute units, number of Tex (Texture filtering units)  , number of ROPs (render back-ends).
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLGcnInfo
+{
+	int CuCount; //Number of compute units on the ASIC.
+	int TexCount; //Number of texture mapping units.
+	int RopCount; //Number of Render backend Units.
+	int ASICFamilyId; //Such SI, VI. See /inc/asic_reg/atiid.h for family ids
+	int ASICRevisionId; //Such as Ellesmere, Fiji.   For example - VI family revision ids are stored in /inc/asic_reg/vi_id.h
+}ADLGcnInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information related virtual segment config information.
+///
+/// This structure is used to store information related virtual segment config
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLVirtualSegmentSettingsOutput
+{
+	int                      virtualSegmentSupported;   // 1 - subsequent values are valid
+	int                      virtualSegmentDefault;     //virtual segment default, 1: enable, 0: disable
+	int                      virtualSegmentCurrent;     //virtual segment current, 1: enable, 0: disable
+	int                      iMinSizeInMB;              //minimum value
+	int                      iMaxSizeInMB;              //maximum value
+	int                      icurrentSizeInMB;          //last configured otherwise same as factory default
+	int                      idefaultSizeInMB;          //factory default
+	int                      iMask;                     //fileds for extension in the future
+	int                      iValue;                    //fileds for extension in the future
+} ADLVirtualSegmentSettingsOutput;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing information about the Chipset.
+///
+/// This structure is used to store various information about the Chipset.  This
+/// information can be returned to the user.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLChipSetInfo
+{
+	int iBusType; 		///< Bus type.
+	int iBusSpeedType;	///Maximum Bus Speed of the current platform
+	int iMaxPCIELaneWidth; 	///< Number of PCIE lanes.
+	int iCurrentPCIELaneWidth;  ///< Current PCIE Lane Width
+	int iSupportedAGPSpeeds;    ///< Bit mask or AGP transfer speed.
+	int iCurrentAGPSpeed;       ///< Current AGP speed
+} ADLChipSetInfo, *LPADLChipSetInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the ASIC memory.
+///
+/// This structure is used to store various information about the ASIC memory.  This
+/// information can be returned to the user.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLMemoryInfo
+{
+/// Memory size in bytes.
+    long long iMemorySize;
+/// Memory type in string.
+    char strMemoryType[ADL_MAX_PATH];
+/// Memory bandwidth in Mbytes/s.
+    long long iMemoryBandwidth;
+} ADLMemoryInfo, *LPADLMemoryInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about memory required by type
+///
+/// This structure is returned by ADL_Adapter_ConfigMemory_Get, which given a desktop and display configuration
+/// will return the Memory used.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLMemoryRequired
+{
+    long long iMemoryReq;        /// Memory in bytes required
+    int iType;                    /// Type of Memory \ref define_adl_validmemoryrequiredfields
+    int iDisplayFeatureValue;   /// Display features \ref define_adl_visiblememoryfeatures that are using this type of memory
+} ADLMemoryRequired, *LPADLMemoryRequired;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the features associated with a display
+///
+/// This structure is a parameter to ADL_Adapter_ConfigMemory_Get, which given a desktop and display configuration
+/// will return the Memory used.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLMemoryDisplayFeatures
+{
+    int iDisplayIndex;            /// ADL Display index
+    int iDisplayFeatureValue;    /// features that the display is using \ref define_adl_visiblememoryfeatures
+} ADLMemoryDisplayFeatures, *LPADLMemoryDisplayFeatures;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing DDC information.
+///
+/// This structure is used to store various DDC information that can be returned to the user.
+/// Note that all fields of type int are actually defined as unsigned int types within the driver.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDDCInfo
+{
+/// Size of the structure
+    int  ulSize;
+/// Indicates whether the attached display supports DDC. If this field is zero on return, no other DDC information fields will be used.
+    int  ulSupportsDDC;
+/// Returns the manufacturer ID of the display device. Should be zeroed if this information is not available.
+    int  ulManufacturerID;
+/// Returns the product ID of the display device. Should be zeroed if this information is not available.
+    int  ulProductID;
+/// Returns the name of the display device. Should be zeroed if this information is not available.
+    char cDisplayName[ADL_MAX_DISPLAY_NAME];
+/// Returns the maximum Horizontal supported resolution. Should be zeroed if this information is not available.
+    int  ulMaxHResolution;
+/// Returns the maximum Vertical supported resolution. Should be zeroed if this information is not available.
+    int  ulMaxVResolution;
+/// Returns the maximum supported refresh rate. Should be zeroed if this information is not available.
+    int  ulMaxRefresh;
+/// Returns the display device preferred timing mode's horizontal resolution.
+    int  ulPTMCx;
+/// Returns the display device preferred timing mode's vertical resolution.
+    int  ulPTMCy;
+/// Returns the display device preferred timing mode's refresh rate.
+    int  ulPTMRefreshRate;
+/// Return EDID flags.
+    int  ulDDCInfoFlag;
+} ADLDDCInfo, *LPADLDDCInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing DDC information.
+///
+/// This structure is used to store various DDC information that can be returned to the user.
+/// Note that all fields of type int are actually defined as unsigned int types within the driver.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDDCInfo2
+{
+/// Size of the structure
+    int  ulSize;
+/// Indicates whether the attached display supports DDC. If this field is zero on return, no other DDC
+/// information fields will be used.
+    int  ulSupportsDDC;
+/// Returns the manufacturer ID of the display device. Should be zeroed if this information is not available.
+    int  ulManufacturerID;
+/// Returns the product ID of the display device. Should be zeroed if this information is not available.
+    int  ulProductID;
+/// Returns the name of the display device. Should be zeroed if this information is not available.
+    char cDisplayName[ADL_MAX_DISPLAY_NAME];
+/// Returns the maximum Horizontal supported resolution. Should be zeroed if this information is not available.
+    int  ulMaxHResolution;
+/// Returns the maximum Vertical supported resolution. Should be zeroed if this information is not available.
+    int  ulMaxVResolution;
+/// Returns the maximum supported refresh rate. Should be zeroed if this information is not available.
+    int  ulMaxRefresh;
+/// Returns the display device preferred timing mode's horizontal resolution.
+    int  ulPTMCx;
+/// Returns the display device preferred timing mode's vertical resolution.
+    int  ulPTMCy;
+/// Returns the display device preferred timing mode's refresh rate.
+    int  ulPTMRefreshRate;
+/// Return EDID flags.
+    int  ulDDCInfoFlag;
+/// Returns 1 if the display supported packed pixel, 0 otherwise
+    int bPackedPixelSupported;
+/// Returns the Pixel formats the display supports \ref define_ddcinfo_pixelformats
+    int iPanelPixelFormat;
+/// Return EDID serial ID.
+    int  ulSerialID;
+/// Return minimum monitor luminance data
+    int ulMinLuminanceData;
+/// Return average monitor luminance data
+    int ulAvgLuminanceData;
+/// Return maximum monitor luminance data
+    int ulMaxLuminanceData;
+
+/// Bit vector of supported transfer functions \ref define_source_content_TF
+    int iSupportedTransferFunction;
+
+/// Bit vector of supported color spaces \ref define_source_content_CS
+    int iSupportedColorSpace;
+
+/// Display Red Chromaticity X coordinate multiplied by 10000
+    int iNativeDisplayChromaticityRedX;
+/// Display Red Chromaticity Y coordinate multiplied by 10000
+    int iNativeDisplayChromaticityRedY;
+/// Display Green Chromaticity X coordinate multiplied by 10000
+    int iNativeDisplayChromaticityGreenX;
+/// Display Green Chromaticity Y coordinate multiplied by 10000
+    int iNativeDisplayChromaticityGreenY;
+/// Display Blue Chromaticity X coordinate multiplied by 10000
+    int iNativeDisplayChromaticityBlueX;
+/// Display Blue Chromaticity Y coordinate multiplied by 10000
+    int iNativeDisplayChromaticityBlueY;
+/// Display White Point X coordinate multiplied by 10000
+    int iNativeDisplayChromaticityWhitePointX;
+/// Display White Point Y coordinate multiplied by 10000
+    int iNativeDisplayChromaticityWhitePointY;
+/// Display diffuse screen reflectance 0-1 (100%) in units of 0.01
+    int iDiffuseScreenReflectance;
+/// Display specular screen reflectance 0-1 (100%) in units of 0.01
+    int iSpecularScreenReflectance;
+/// Bit vector of supported color spaces \ref define_HDR_support
+    int iSupportedHDR;
+/// Bit vector for freesync flags
+    int iFreesyncFlags;
+
+/// Return minimum monitor luminance without dimming data
+    int ulMinLuminanceNoDimmingData;
+
+    int ulMaxBacklightMaxLuminanceData;
+    int ulMinBacklightMaxLuminanceData;
+    int ulMaxBacklightMinLuminanceData;
+    int ulMinBacklightMinLuminanceData;
+
+    // Reserved for future use
+    int iReserved[4];
+} ADLDDCInfo2, *LPADLDDCInfo2;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information controller Gamma settings.
+///
+/// This structure is used to store the red, green and blue color channel information for the.
+/// controller gamma setting. This information is returned by ADL, and it can also be used to
+/// set the controller gamma setting.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLGamma
+{
+/// Red color channel gamma value.
+    float fRed;
+/// Green color channel gamma value.
+    float fGreen;
+/// Blue color channel gamma value.
+    float fBlue;
+} ADLGamma, *LPADLGamma;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about component video custom modes.
+///
+/// This structure is used to store the component video custom mode.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLCustomMode
+{
+/// Custom mode flags.  They are returned by the ADL driver.
+    int iFlags;
+/// Custom mode width.
+    int iModeWidth;
+/// Custom mode height.
+    int iModeHeight;
+/// Custom mode base width.
+    int iBaseModeWidth;
+/// Custom mode base height.
+    int iBaseModeHeight;
+/// Custom mode refresh rate.
+    int iRefreshRate;
+} ADLCustomMode, *LPADLCustomMode;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing Clock information for OD5 calls.
+///
+/// This structure is used to retrieve clock information for OD5 calls.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLGetClocksOUT
+{
+    long ulHighCoreClock;
+    long ulHighMemoryClock;
+    long ulHighVddc;
+    long ulCoreMin;
+    long ulCoreMax;
+    long ulMemoryMin;
+    long ulMemoryMax;
+    long ulActivityPercent;
+    long ulCurrentCoreClock;
+    long ulCurrentMemoryClock;
+    long ulReserved;
+} ADLGetClocksOUT;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing HDTV information for display calls.
+///
+/// This structure is used to retrieve HDTV information information for display calls.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDisplayConfig
+{
+/// Size of the structure
+  long ulSize;
+/// HDTV connector type.
+  long ulConnectorType;
+/// HDTV capabilities.
+  long ulDeviceData;
+/// Overridden HDTV capabilities.
+  long ulOverridedDeviceData;
+/// Reserved field
+  long ulReserved;
+} ADLDisplayConfig;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the display device.
+///
+/// This structure is used to store display device information
+/// such as display index, type, name, connection status, mapped adapter and controller indexes,
+/// whether or not multiple VPUs are supported, local display connections or not (through Lasso), etc.
+/// This information can be returned to the user. Alternatively, it can be used to access various driver calls to set
+/// or fetch various display device related settings upon the user's request.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDisplayID
+{
+/// The logical display index belonging to this adapter.
+    int iDisplayLogicalIndex;
+
+///\brief The physical display index.
+/// For example, display index 2 from adapter 2 can be used by current adapter 1.\n
+/// So current adapter may enumerate this adapter as logical display 7 but the physical display
+/// index is still 2.
+    int iDisplayPhysicalIndex;
+
+/// The persistent logical adapter index for the display.
+    int iDisplayLogicalAdapterIndex;
+
+///\brief The persistent physical adapter index for the display.
+/// It can be the current adapter or a non-local adapter. \n
+/// If this adapter index is different than the current adapter,
+/// the Display Non Local flag is set inside DisplayInfoValue.
+    int iDisplayPhysicalAdapterIndex;
+} ADLDisplayID, *LPADLDisplayID;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the display device.
+///
+/// This structure is used to store various information about the display device.  This
+/// information can be returned to the user, or used to access various driver calls to set
+/// or fetch various display-device-related settings upon the user's request
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDisplayInfo
+{
+/// The DisplayID structure
+    ADLDisplayID displayID;
+
+///\deprecated The controller index to which the display is mapped.\n Will not be used in the future\n
+    int  iDisplayControllerIndex;
+
+/// The display's EDID name.
+    char strDisplayName[ADL_MAX_PATH];
+
+/// The display's manufacturer name.
+    char strDisplayManufacturerName[ADL_MAX_PATH];
+
+/// The Display type. For example: CRT, TV, CV, DFP.
+    int  iDisplayType;
+
+/// The display output type. For example: HDMI, SVIDEO, COMPONMNET VIDEO.
+    int  iDisplayOutputType;
+
+/// The connector type for the device.
+    int  iDisplayConnector;
+
+///\brief The bit mask identifies the number of bits ADLDisplayInfo is currently using. \n
+/// It will be the sum all the bit definitions in ADL_DISPLAY_DISPLAYINFO_xxx.
+    int  iDisplayInfoMask;
+
+/// The bit mask identifies the display status. \ref define_displayinfomask
+    int  iDisplayInfoValue;
+} ADLDisplayInfo, *LPADLDisplayInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the display port MST device.
+///
+/// This structure is used to store various MST information about the display port device.  This
+/// information can be returned to the user, or used to access various driver calls to
+/// fetch various display-device-related settings upon the user's request
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDisplayDPMSTInfo
+{
+    /// The ADLDisplayID structure
+    ADLDisplayID displayID;
+
+    /// total bandwidth available on the DP connector
+    int    iTotalAvailableBandwidthInMpbs;
+    /// bandwidth allocated to this display
+    int    iAllocatedBandwidthInMbps;
+
+    // info from DAL DpMstSinkInfo
+    /// string identifier for the display
+    char    strGlobalUniqueIdentifier[ADL_MAX_PATH];
+
+    /// The link count of relative address, rad[0] upto rad[linkCount] are valid
+    int        radLinkCount;
+    /// The physical connector ID, used to identify the physical DP port
+    int        iPhysicalConnectorID;
+
+    /// Relative address, address scheme starts from source side
+    char    rad[ADL_MAX_RAD_LINK_COUNT];
+} ADLDisplayDPMSTInfo, *LPADLDisplayDPMSTInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing the display mode definition used per controller.
+///
+/// This structure is used to store the display mode definition used per controller.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDisplayMode
+{
+/// Vertical resolution (in pixels).
+   int  iPelsHeight;
+/// Horizontal resolution (in pixels).
+   int  iPelsWidth;
+/// Color depth.
+   int  iBitsPerPel;
+/// Refresh rate.
+   int  iDisplayFrequency;
+} ADLDisplayMode;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing detailed timing parameters.
+///
+/// This structure is used to store the detailed timing parameters.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDetailedTiming
+{
+/// Size of the structure.
+     int   iSize;
+/// Timing flags. \ref define_detailed_timing_flags
+     short sTimingFlags;
+/// Total width (columns).
+     short sHTotal;
+/// Displayed width.
+     short sHDisplay;
+/// Horizontal sync signal offset.
+     short sHSyncStart;
+/// Horizontal sync signal width.
+     short sHSyncWidth;
+/// Total height (rows).
+     short sVTotal;
+/// Displayed height.
+     short sVDisplay;
+/// Vertical sync signal offset.
+     short sVSyncStart;
+/// Vertical sync signal width.
+     short sVSyncWidth;
+/// Pixel clock value.
+     short sPixelClock;
+/// Overscan right.
+     short sHOverscanRight;
+/// Overscan left.
+     short sHOverscanLeft;
+/// Overscan bottom.
+     short sVOverscanBottom;
+/// Overscan top.
+     short sVOverscanTop;
+     short sOverscan8B;
+     short sOverscanGR;
+} ADLDetailedTiming;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing display mode information.
+///
+/// This structure is used to store the display mode information.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDisplayModeInfo
+{
+/// Timing standard of the current mode. \ref define_modetiming_standard
+  int  iTimingStandard;
+/// Applicable timing standards for the current mode.
+  int  iPossibleStandard;
+/// Refresh rate factor.
+  int  iRefreshRate;
+/// Num of pixels in a row.
+  int  iPelsWidth;
+/// Num of pixels in a column.
+  int  iPelsHeight;
+/// Detailed timing parameters.
+  ADLDetailedTiming  sDetailedTiming;
+} ADLDisplayModeInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing information about display property.
+///
+/// This structure is used to store the display property for the current adapter.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDisplayProperty
+{
+/// Must be set to sizeof the structure
+  int iSize;
+/// Must be set to \ref ADL_DL_DISPLAYPROPERTY_TYPE_EXPANSIONMODE or \ref ADL_DL_DISPLAYPROPERTY_TYPE_USEUNDERSCANSCALING
+  int iPropertyType;
+/// Get or Set \ref ADL_DL_DISPLAYPROPERTY_EXPANSIONMODE_CENTER or \ref ADL_DL_DISPLAYPROPERTY_EXPANSIONMODE_FULLSCREEN or \ref ADL_DL_DISPLAYPROPERTY_EXPANSIONMODE_ASPECTRATIO or \ref ADL_DL_DISPLAYPROPERTY_TYPE_ITCFLAGENABLE
+  int iExpansionMode;
+/// Display Property supported? 1: Supported, 0: Not supported
+  int iSupport;
+/// Display Property current value
+  int iCurrent;
+/// Display Property Default value
+  int iDefault;
+} ADLDisplayProperty;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Clock.
+///
+/// This structure is used to store the clock information for the current adapter
+/// such as core clock and memory clock info.
+///\nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLClockInfo
+{
+/// Core clock in 10 KHz.
+    int iCoreClock;
+/// Memory clock in 10 KHz.
+    int iMemoryClock;
+} ADLClockInfo, *LPADLClockInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about I2C.
+///
+/// This structure is used to store the I2C information for the current adapter.
+/// This structure is used by the ADL_Display_WriteAndReadI2C() function.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLI2C
+{
+/// Size of the structure
+    int iSize;
+/// Numerical value representing hardware I2C.
+    int iLine;
+/// The 7-bit I2C slave device address, shifted one bit to the left.
+    int iAddress;
+/// The offset of the data from the address.
+    int iOffset;
+/// Read from or write to slave device. \ref ADL_DL_I2C_ACTIONREAD or \ref ADL_DL_I2C_ACTIONWRITE or \ref ADL_DL_I2C_ACTIONREAD_REPEATEDSTART
+    int iAction;
+/// I2C clock speed in KHz.
+    int iSpeed;
+/// A numerical value representing the number of bytes to be sent or received on the I2C bus.
+    int iDataSize;
+/// Address of the characters which are to be sent or received on the I2C bus.
+    char *pcData;
+} ADLI2C;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about EDID data.
+///
+/// This structure is used to store the information about EDID data for the adapter.
+/// This structure is used by the ADL_Display_EdidData_Get() and ADL_Display_EdidData_Set() functions.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDisplayEDIDData
+{
+/// Size of the structure
+  int iSize;
+/// Set to 0
+  int iFlag;
+  /// Size of cEDIDData. Set by ADL_Display_EdidData_Get() upon return
+  int iEDIDSize;
+/// 0, 1 or 2. If set to 3 or above an error ADL_ERR_INVALID_PARAM is generated
+  int iBlockIndex;
+/// EDID data
+  char cEDIDData[ADL_MAX_EDIDDATA_SIZE];
+/// Reserved
+  int iReserved[4];
+}ADLDisplayEDIDData;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about input of controller overlay adjustment.
+///
+/// This structure is used to store the information about input of controller overlay adjustment for the adapter.
+/// This structure is used by the ADL_Display_ControllerOverlayAdjustmentCaps_Get, ADL_Display_ControllerOverlayAdjustmentData_Get, and
+/// ADL_Display_ControllerOverlayAdjustmentData_Set() functions.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLControllerOverlayInput
+{
+/// Should be set to the sizeof the structure
+  int  iSize;
+///\ref ADL_DL_CONTROLLER_OVERLAY_ALPHA or \ref ADL_DL_CONTROLLER_OVERLAY_ALPHAPERPIX
+  int  iOverlayAdjust;
+/// Data.
+  int  iValue;
+/// Should be 0.
+  int  iReserved;
+} ADLControllerOverlayInput;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about overlay adjustment.
+///
+/// This structure is used to store the information about overlay adjustment for the adapter.
+/// This structure is used by the ADLControllerOverlayInfo() function.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLAdjustmentinfo
+{
+/// Default value
+  int iDefault;
+/// Minimum value
+  int iMin;
+/// Maximum Value
+  int iMax;
+/// Step value
+  int iStep;
+} ADLAdjustmentinfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about controller overlay information.
+///
+/// This structure is used to store information about controller overlay info for the adapter.
+/// This structure is used by the ADL_Display_ControllerOverlayAdjustmentCaps_Get() function.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLControllerOverlayInfo
+{
+/// Should be set to the sizeof the structure
+  int                    iSize;
+/// Data.
+  ADLAdjustmentinfo        sOverlayInfo;
+/// Should be 0.
+  int                    iReserved[3];
+} ADLControllerOverlayInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing GL-Sync module information.
+///
+/// This structure is used to retrieve GL-Sync module information for
+/// Workstation Framelock/Genlock.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLGLSyncModuleID
+{
+/// Unique GL-Sync module ID.
+    int        iModuleID;
+/// GL-Sync GPU port index (to be passed into ADLGLSyncGenlockConfig.lSignalSource and ADLGlSyncPortControl.lSignalSource).
+    int        iGlSyncGPUPort;
+/// GL-Sync module firmware version of Boot Sector.
+    int        iFWBootSectorVersion;
+/// GL-Sync module firmware version of User Sector.
+    int        iFWUserSectorVersion;
+} ADLGLSyncModuleID , *LPADLGLSyncModuleID;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing GL-Sync ports capabilities.
+///
+/// This structure is used to retrieve hardware capabilities for the ports of the GL-Sync module
+/// for Workstation Framelock/Genlock (such as port type and number of associated LEDs).
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLGLSyncPortCaps
+{
+/// Port type. Bitfield of ADL_GLSYNC_PORTTYPE_*  \ref define_glsync
+    int        iPortType;
+/// Number of LEDs associated for this port.
+    int        iNumOfLEDs;
+}ADLGLSyncPortCaps, *LPADLGLSyncPortCaps;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing GL-Sync Genlock settings.
+///
+/// This structure is used to get and set genlock settings for the GPU ports of the GL-Sync module
+/// for Workstation Framelock/Genlock.\n
+/// \see define_glsync
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLGLSyncGenlockConfig
+{
+/// Specifies what fields in this structure are valid \ref define_glsync
+    int        iValidMask;
+/// Delay (ms) generating a sync signal.
+    int        iSyncDelay;
+/// Vector of framelock control bits. Bitfield of ADL_GLSYNC_FRAMELOCKCNTL_* \ref define_glsync
+    int        iFramelockCntlVector;
+/// Source of the sync signal. Either GL_Sync GPU Port index or ADL_GLSYNC_SIGNALSOURCE_* \ref define_glsync
+    int        iSignalSource;
+/// Use sampled sync signal. A value of 0 specifies no sampling.
+    int        iSampleRate;
+/// For interlaced sync signals, the value can be ADL_GLSYNC_SYNCFIELD_1 or *_BOTH \ref define_glsync
+    int        iSyncField;
+/// The signal edge that should trigger synchronization. ADL_GLSYNC_TRIGGEREDGE_* \ref define_glsync
+    int        iTriggerEdge;
+/// Scan rate multiplier applied to the sync signal. ADL_GLSYNC_SCANRATECOEFF_* \ref define_glsync
+    int        iScanRateCoeff;
+}ADLGLSyncGenlockConfig, *LPADLGLSyncGenlockConfig;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing GL-Sync port information.
+///
+/// This structure is used to get status of the GL-Sync ports (BNC or RJ45s)
+/// for Workstation Framelock/Genlock.
+/// \see define_glsync
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLGlSyncPortInfo
+{
+/// Type of GL-Sync port (ADL_GLSYNC_PORT_*).
+    int        iPortType;
+/// The number of LEDs for this port. It's also filled within ADLGLSyncPortCaps.
+    int        iNumOfLEDs;
+/// Port state ADL_GLSYNC_PORTSTATE_*  \ref define_glsync
+    int        iPortState;
+/// Scanned frequency for this port (vertical refresh rate in milliHz; 60000 means 60 Hz).
+    int        iFrequency;
+/// Used for ADL_GLSYNC_PORT_BNC. It is ADL_GLSYNC_SIGNALTYPE_*   \ref define_glsync
+    int        iSignalType;
+/// Used for ADL_GLSYNC_PORT_RJ45PORT*. It is GL_Sync GPU Port index or ADL_GLSYNC_SIGNALSOURCE_*.  \ref define_glsync
+    int        iSignalSource;
+} ADLGlSyncPortInfo, *LPADLGlSyncPortInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing GL-Sync port control settings.
+///
+/// This structure is used to configure the GL-Sync ports (RJ45s only)
+/// for Workstation Framelock/Genlock.
+/// \see define_glsync
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLGlSyncPortControl
+{
+/// Port to control ADL_GLSYNC_PORT_RJ45PORT1 or ADL_GLSYNC_PORT_RJ45PORT2   \ref define_glsync
+    int        iPortType;
+/// Port control data ADL_GLSYNC_PORTCNTL_*   \ref define_glsync
+    int        iControlVector;
+/// Source of the sync signal. Either GL_Sync GPU Port index or ADL_GLSYNC_SIGNALSOURCE_*   \ref define_glsync
+    int        iSignalSource;
+} ADLGlSyncPortControl;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing GL-Sync mode of a display.
+///
+/// This structure is used to get and set GL-Sync mode settings for a display connected to
+/// an adapter attached to a GL-Sync module for Workstation Framelock/Genlock.
+/// \see define_glsync
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLGlSyncMode
+{
+/// Mode control vector. Bitfield of ADL_GLSYNC_MODECNTL_*   \ref define_glsync
+    int        iControlVector;
+/// Mode status vector. Bitfield of ADL_GLSYNC_MODECNTL_STATUS_*   \ref define_glsync
+    int        iStatusVector;
+/// Index of GL-Sync connector used to genlock the display/controller.
+    int        iGLSyncConnectorIndex;
+} ADLGlSyncMode, *LPADLGlSyncMode;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing GL-Sync mode of a display.
+///
+/// This structure is used to get and set GL-Sync mode settings for a display connected to
+/// an adapter attached to a GL-Sync module for Workstation Framelock/Genlock.
+/// \see define_glsync
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLGlSyncMode2
+{
+/// Mode control vector. Bitfield of ADL_GLSYNC_MODECNTL_*   \ref define_glsync
+    int        iControlVector;
+/// Mode status vector. Bitfield of ADL_GLSYNC_MODECNTL_STATUS_*   \ref define_glsync
+    int        iStatusVector;
+/// Index of GL-Sync connector used to genlock the display/controller.
+    int        iGLSyncConnectorIndex;
+/// Index of the display to which this GLSync applies to.
+    int        iDisplayIndex;
+} ADLGlSyncMode2, *LPADLGlSyncMode2;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing the packet info of a display.
+///
+/// This structure is used to get and set the packet information of a display.
+/// This structure is used by ADLDisplayDataPacket.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct  ADLInfoPacket
+{
+    char hb0;
+    char hb1;
+    char hb2;
+/// sb0~sb27
+    char sb[28];
+}ADLInfoPacket;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing the AVI packet info of a display.
+///
+/// This structure is used to get and set AVI the packet info of a display.
+/// This structure is used by ADLDisplayDataPacket.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLAVIInfoPacket  //Valid user defined data/
+{
+/// byte 3, bit 7
+   char bPB3_ITC;
+/// byte 5, bit [7:4].
+   char bPB5;
+}ADLAVIInfoPacket;
+
+// Overdrive clock setting structure definition.
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing the Overdrive clock setting.
+///
+/// This structure is used to get the Overdrive clock setting.
+/// This structure is used by ADLAdapterODClockInfo.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLODClockSetting
+{
+/// Deafult clock
+    int iDefaultClock;
+/// Current clock
+    int iCurrentClock;
+/// Maximum clcok
+    int iMaxClock;
+/// Minimum clock
+    int iMinClock;
+/// Requested clcock
+    int iRequestedClock;
+/// Step
+    int iStepClock;
+} ADLODClockSetting;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing the Overdrive clock information.
+///
+/// This structure is used to get the Overdrive clock information.
+/// This structure is used by the ADL_Display_ODClockInfo_Get() function.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLAdapterODClockInfo
+{
+/// Size of the structure
+    int iSize;
+/// Flag \ref define_clockinfo_flags
+    int iFlags;
+/// Memory Clock
+    ADLODClockSetting sMemoryClock;
+/// Engine Clock
+    ADLODClockSetting sEngineClock;
+} ADLAdapterODClockInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing the Overdrive clock configuration.
+///
+/// This structure is used to set the Overdrive clock configuration.
+/// This structure is used by the ADL_Display_ODClockConfig_Set() function.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLAdapterODClockConfig
+{
+/// Size of the structure
+  int iSize;
+/// Flag \ref define_clockinfo_flags
+  int iFlags;
+/// Memory Clock
+  int iMemoryClock;
+/// Engine Clock
+  int iEngineClock;
+} ADLAdapterODClockConfig;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about current power management related activity.
+///
+/// This structure is used to store information about current power management related activity.
+/// This structure (Overdrive 5 interfaces) is used by the ADL_PM_CurrentActivity_Get() function.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLPMActivity
+{
+/// Must be set to the size of the structure
+    int iSize;
+/// Current engine clock.
+    int iEngineClock;
+/// Current memory clock.
+    int iMemoryClock;
+/// Current core voltage.
+    int iVddc;
+/// GPU utilization.
+    int iActivityPercent;
+/// Performance level index.
+    int iCurrentPerformanceLevel;
+/// Current PCIE bus speed.
+    int iCurrentBusSpeed;
+/// Number of PCIE bus lanes.
+    int iCurrentBusLanes;
+/// Maximum number of PCIE bus lanes.
+    int iMaximumBusLanes;
+/// Reserved for future purposes.
+    int iReserved;
+} ADLPMActivity;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about thermal controller.
+///
+/// This structure is used to store information about thermal controller.
+/// This structure is used by ADL_PM_ThermalDevices_Enum.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLThermalControllerInfo
+{
+/// Must be set to the size of the structure
+  int iSize;
+/// Possible valies: \ref ADL_DL_THERMAL_DOMAIN_OTHER or \ref ADL_DL_THERMAL_DOMAIN_GPU.
+  int iThermalDomain;
+///    GPU 0, 1, etc.
+  int iDomainIndex;
+/// Possible valies: \ref ADL_DL_THERMAL_FLAG_INTERRUPT or \ref ADL_DL_THERMAL_FLAG_FANCONTROL
+  int iFlags;
+} ADLThermalControllerInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about thermal controller temperature.
+///
+/// This structure is used to store information about thermal controller temperature.
+/// This structure is used by the ADL_PM_Temperature_Get() function.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLTemperature
+{
+/// Must be set to the size of the structure
+  int iSize;
+/// Temperature in millidegrees Celsius.
+  int iTemperature;
+} ADLTemperature;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about thermal controller fan speed.
+///
+/// This structure is used to store information about thermal controller fan speed.
+/// This structure is used by the ADL_PM_FanSpeedInfo_Get() function.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLFanSpeedInfo
+{
+/// Must be set to the size of the structure
+  int iSize;
+/// \ref define_fanctrl
+  int iFlags;
+/// Minimum possible fan speed value in percents.
+  int iMinPercent;
+/// Maximum possible fan speed value in percents.
+  int iMaxPercent;
+/// Minimum possible fan speed value in RPM.
+  int iMinRPM;
+/// Maximum possible fan speed value in RPM.
+  int iMaxRPM;
+} ADLFanSpeedInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about fan speed reported by thermal controller.
+///
+/// This structure is used to store information about fan speed reported by thermal controller.
+/// This structure is used by the ADL_Overdrive5_FanSpeed_Get() and ADL_Overdrive5_FanSpeed_Set() functions.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLFanSpeedValue
+{
+/// Must be set to the size of the structure
+  int iSize;
+/// Possible valies: \ref ADL_DL_FANCTRL_SPEED_TYPE_PERCENT or \ref ADL_DL_FANCTRL_SPEED_TYPE_RPM
+  int iSpeedType;
+/// Fan speed value
+  int iFanSpeed;
+/// The only flag for now is: \ref ADL_DL_FANCTRL_FLAG_USER_DEFINED_SPEED
+  int iFlags;
+} ADLFanSpeedValue;
+
+////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing the range of Overdrive parameter.
+///
+/// This structure is used to store information about the range of Overdrive parameter.
+/// This structure is used by ADLODParameters.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLODParameterRange
+{
+/// Minimum parameter value.
+  int iMin;
+/// Maximum parameter value.
+  int iMax;
+/// Parameter step value.
+  int iStep;
+} ADLODParameterRange;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive parameters.
+///
+/// This structure is used to store information about Overdrive parameters.
+/// This structure is used by the ADL_Overdrive5_ODParameters_Get() function.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLODParameters
+{
+/// Must be set to the size of the structure
+  int iSize;
+/// Number of standard performance states.
+  int iNumberOfPerformanceLevels;
+/// Indicates whether the GPU is capable to measure its activity.
+  int iActivityReportingSupported;
+/// Indicates whether the GPU supports discrete performance levels or performance range.
+  int iDiscretePerformanceLevels;
+/// Reserved for future use.
+  int iReserved;
+/// Engine clock range.
+  ADLODParameterRange sEngineClock;
+/// Memory clock range.
+  ADLODParameterRange sMemoryClock;
+/// Core voltage range.
+  ADLODParameterRange sVddc;
+} ADLODParameters;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive level.
+///
+/// This structure is used to store information about Overdrive level.
+/// This structure is used by ADLODPerformanceLevels.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLODPerformanceLevel
+{
+/// Engine clock.
+  int iEngineClock;
+/// Memory clock.
+  int iMemoryClock;
+/// Core voltage.
+  int iVddc;
+} ADLODPerformanceLevel;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive performance levels.
+///
+/// This structure is used to store information about Overdrive performance levels.
+/// This structure is used by the ADL_Overdrive5_ODPerformanceLevels_Get() and ADL_Overdrive5_ODPerformanceLevels_Set() functions.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLODPerformanceLevels
+{
+/// Must be set to sizeof( \ref ADLODPerformanceLevels ) + sizeof( \ref ADLODPerformanceLevel ) * (ADLODParameters.iNumberOfPerformanceLevels - 1)
+  int iSize;
+  int iReserved;
+/// Array of performance state descriptors. Must have ADLODParameters.iNumberOfPerformanceLevels elements.
+  ADLODPerformanceLevel aLevels [1];
+} ADLODPerformanceLevels;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the proper CrossfireX chains combinations.
+///
+/// This structure is used to store information about the CrossfireX chains combination for a particular adapter.
+/// This structure is used by the ADL_Adapter_Crossfire_Caps(), ADL_Adapter_Crossfire_Get(), and ADL_Adapter_Crossfire_Set() functions.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLCrossfireComb
+{
+/// Number of adapters in this combination.
+  int iNumLinkAdapter;
+/// A list of ADL indexes of the linked adapters in this combination.
+  int iAdaptLink[3];
+} ADLCrossfireComb;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing CrossfireX state and error information.
+///
+/// This structure is used to store state and error information about a particular adapter CrossfireX combination.
+/// This structure is used by the ADL_Adapter_Crossfire_Get() function.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLCrossfireInfo
+{
+/// Current error code of this CrossfireX combination.
+  int iErrorCode;
+/// Current \ref define_crossfirestate
+  int iState;
+/// If CrossfireX is supported by this combination. The value is either \ref ADL_TRUE or \ref ADL_FALSE.
+  int iSupported;
+} ADLCrossfireInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing information about the BIOS.
+///
+/// This structure is used to store various information about the Chipset.  This
+/// information can be returned to the user.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLBiosInfo
+{
+    char strPartNumber[ADL_MAX_PATH];    ///< Part number.
+    char strVersion[ADL_MAX_PATH];        ///< Version number.
+    char strDate[ADL_MAX_PATH];        ///< BIOS date in yyyy/mm/dd hh:mm format.
+} ADLBiosInfo, *LPADLBiosInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing information about adapter location.
+///
+/// This structure is used to store information about adapter location.
+/// This structure is used by ADLMVPUStatus.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLAdapterLocation
+{
+/// PCI Bus number : 8 bits
+    int iBus;
+/// Device number : 5 bits
+    int iDevice;
+/// Function number : 3 bits
+    int iFunction;
+} ADLAdapterLocation,ADLBdf;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing version information
+///
+/// This structure is used to store software version information, description of the display device and a web link to the latest installed Catalyst drivers.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLVersionsInfo
+{
+    /// Driver Release (Packaging) Version (e.g. 8.71-100128n-094835E-ATI)
+    char strDriverVer[ADL_MAX_PATH];
+    /// Catalyst Version(e.g. "10.1").
+    char strCatalystVersion[ADL_MAX_PATH];
+    /// Web link to an XML file with information about the latest AMD drivers and locations (e.g. "http://www.amd.com/us/driverxml" )
+    char strCatalystWebLink[ADL_MAX_PATH];
+} ADLVersionsInfo, *LPADLVersionsInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing version information
+///
+/// This structure is used to store software version information, description of the display device and a web link to the latest installed Catalyst drivers.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLVersionsInfoX2
+{
+    /// Driver Release (Packaging) Version (e.g. "16.20.1035-160621a-303814C")
+    char strDriverVer[ADL_MAX_PATH];
+    /// Catalyst Version(e.g. "15.8").
+    char strCatalystVersion[ADL_MAX_PATH];
+    /// Crimson Version(e.g. "16.6.2").
+    char strCrimsonVersion[ADL_MAX_PATH];
+    /// Web link to an XML file with information about the latest AMD drivers and locations (e.g. "http://support.amd.com/drivers/xml/driver_09_us.xml" )
+    char strCatalystWebLink[ADL_MAX_PATH];
+} ADLVersionsInfoX2, *LPADLVersionsInfoX2;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing information about MultiVPU capabilities.
+///
+/// This structure is used to store information about MultiVPU capabilities.
+/// This structure is used by the ADL_Display_MVPUCaps_Get() function.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLMVPUCaps
+{
+/// Must be set to sizeof( ADLMVPUCaps ).
+  int iSize;
+/// Number of adapters.
+  int iAdapterCount;
+/// Bits set for all possible MVPU masters. \ref MVPU_ADAPTER_0 .. \ref MVPU_ADAPTER_3
+  int iPossibleMVPUMasters;
+/// Bits set for all possible MVPU slaves. \ref MVPU_ADAPTER_0 .. \ref MVPU_ADAPTER_3
+  int iPossibleMVPUSlaves;
+/// Registry path for each adapter.
+  char cAdapterPath[ADL_DL_MAX_MVPU_ADAPTERS][ADL_DL_MAX_REGISTRY_PATH];
+} ADLMVPUCaps;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing information about MultiVPU status.
+///
+/// This structure is used to store information about MultiVPU status.
+/// Ths structure is used by the ADL_Display_MVPUStatus_Get() function.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLMVPUStatus
+{
+/// Must be set to sizeof( ADLMVPUStatus ).
+  int iSize;
+/// Number of active adapters.
+  int iActiveAdapterCount;
+/// MVPU status.
+  int iStatus;
+/// PCI Bus/Device/Function for each active adapter participating in MVPU.
+  ADLAdapterLocation aAdapterLocation[ADL_DL_MAX_MVPU_ADAPTERS];
+} ADLMVPUStatus;
+
+// Displays Manager structures
+
+///////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing information about the activatable source.
+///
+/// This structure is used to store activatable source information
+/// This information can be returned to the user.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLActivatableSource
+{
+    /// The Persistent logical Adapter Index.
+    int iAdapterIndex;
+    /// The number of Activatable Sources.
+    int iNumActivatableSources;
+    /// The bit mask identifies the number of bits ActivatableSourceValue is using. (Not currnetly used)
+    int iActivatableSourceMask;
+    /// The bit mask identifies the status.  (Not currnetly used)
+    int iActivatableSourceValue;
+} ADLActivatableSource, *LPADLActivatableSource;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing information about display mode.
+///
+/// This structure is used to store the display mode for the current adapter
+/// such as X, Y positions, screen resolutions, orientation,
+/// color depth, refresh rate, progressive or interlace mode, etc.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLMode
+{
+/// Adapter index.
+    int iAdapterIndex;
+/// Display IDs.
+    ADLDisplayID displayID;
+/// Screen position X coordinate.
+    int iXPos;
+/// Screen position Y coordinate.
+    int iYPos;
+/// Screen resolution Width.
+    int iXRes;
+/// Screen resolution Height.
+    int iYRes;
+/// Screen Color Depth. E.g., 16, 32.
+    int iColourDepth;
+/// Screen refresh rate. Could be fractional E.g. 59.97
+    float fRefreshRate;
+/// Screen orientation. E.g., 0, 90, 180, 270.
+    int iOrientation;
+/// Vista mode flag indicating Progressive or Interlaced mode.
+    int iModeFlag;
+/// The bit mask identifying the number of bits this Mode is currently using. It is the sum of all the bit definitions defined in \ref define_displaymode
+    int iModeMask;
+/// The bit mask identifying the display status. The detailed definition is in  \ref define_displaymode
+    int iModeValue;
+} ADLMode, *LPADLMode;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing information about display target information.
+///
+/// This structure is used to store the display target information.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDisplayTarget
+{
+    /// The Display ID.
+    ADLDisplayID displayID;
+
+    /// The display map index identify this manner and the desktop surface.
+    int iDisplayMapIndex;
+
+    /// The bit mask identifies the number of bits DisplayTarget is currently using. It is the sum of all the bit definitions defined in \ref ADL_DISPLAY_DISPLAYTARGET_PREFERRED.
+    int  iDisplayTargetMask;
+
+    /// The bit mask identifies the display status. The detailed definition is in \ref ADL_DISPLAY_DISPLAYTARGET_PREFERRED.
+    int  iDisplayTargetValue;
+} ADLDisplayTarget, *LPADLDisplayTarget;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the display SLS bezel Mode information.
+///
+/// This structure is used to store the display SLS bezel Mode information.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct tagADLBezelTransientMode
+{
+    /// Adapter Index
+    int iAdapterIndex;
+
+    /// SLS Map Index
+    int iSLSMapIndex;
+
+    /// The mode index
+    int iSLSModeIndex;
+
+    /// The mode
+    ADLMode displayMode;
+
+    /// The number of bezel offsets belongs to this map
+    int  iNumBezelOffset;
+
+    /// The first bezel offset array index in the native mode array
+    int  iFirstBezelOffsetArrayIndex;
+
+    /// The bit mask identifies the bits this structure is currently using. It will be the total OR of all the bit definitions.
+    int  iSLSBezelTransientModeMask;
+
+    /// The bit mask identifies the display status. The detail definition is defined below.
+    int  iSLSBezelTransientModeValue;
+} ADLBezelTransientMode, *LPADLBezelTransientMode;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing information about the adapter display manner.
+///
+/// This structure is used to store adapter display manner information
+/// This information can be returned to the user. Alternatively, it can be used to access various driver calls to
+/// fetch various display device related display manner settings upon the user's request.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLAdapterDisplayCap
+{
+    /// The Persistent logical Adapter Index.
+    int iAdapterIndex;
+    /// The bit mask identifies the number of bits AdapterDisplayCap is currently using. Sum all the bits defined in ADL_ADAPTER_DISPLAYCAP_XXX
+    int  iAdapterDisplayCapMask;
+    /// The bit mask identifies the status. Refer to ADL_ADAPTER_DISPLAYCAP_XXX
+    int  iAdapterDisplayCapValue;
+} ADLAdapterDisplayCap, *LPADLAdapterDisplayCap;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about display mapping.
+///
+/// This structure is used to store the display mapping data such as display manner.
+/// For displays with horizontal or vertical stretch manner,
+/// this structure also stores the display order, display row, and column data.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDisplayMap
+{
+/// The current display map index. It is the OS desktop index. For example, if the OS index 1 is showing clone mode, the display map will be 1.
+    int iDisplayMapIndex;
+
+/// The Display Mode for the current map
+    ADLMode displayMode;
+
+/// The number of display targets belongs to this map\n
+    int iNumDisplayTarget;
+
+/// The first target array index in the Target array\n
+    int iFirstDisplayTargetArrayIndex;
+
+/// The bit mask identifies the number of bits DisplayMap is currently using. It is the sum of all the bit definitions defined in ADL_DISPLAY_DISPLAYMAP_MANNER_xxx.
+     int  iDisplayMapMask;
+
+///The bit mask identifies the display status. The detailed definition is in ADL_DISPLAY_DISPLAYMAP_MANNER_xxx.
+    int  iDisplayMapValue;
+} ADLDisplayMap, *LPADLDisplayMap;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing information about the display device possible map for one GPU
+///
+/// This structure is used to store the display device possible map
+/// This information can be returned to the user.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLPossibleMap
+{
+    /// The current PossibleMap index. Each PossibleMap is assigned an index
+    int iIndex;
+    /// The adapter index identifying the GPU for which to validate these Maps & Targets
+    int iAdapterIndex;
+    /// Number of display Maps for this GPU to be validated
+    int iNumDisplayMap;
+    /// The display Maps list to validate
+    ADLDisplayMap* displayMap;
+    /// the number of display Targets for these display Maps
+    int iNumDisplayTarget;
+    /// The display Targets list for these display Maps to be validated.
+    ADLDisplayTarget* displayTarget;
+} ADLPossibleMap, *LPADLPossibleMap;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing information about display possible mapping.
+///
+/// This structure is used to store the display possible mapping's controller index for the current display.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLPossibleMapping
+{
+    int iDisplayIndex;                ///< The display index. Each display is assigned an index.
+    int iDisplayControllerIndex;    ///< The controller index to which display is mapped.
+    int iDisplayMannerSupported;    ///< The supported display manner.
+} ADLPossibleMapping, *LPADLPossibleMapping;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing information about the validated display device possible map result.
+///
+/// This structure is used to store the validated display device possible map result
+/// This information can be returned to the user.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLPossibleMapResult
+{
+    /// The current display map index. It is the OS Desktop index. For example, OS Index 1 showing clone mode. The Display Map will be 1.
+    int iIndex;
+    // The bit mask identifies the number of bits   PossibleMapResult is currently using. It will be the sum all the bit definitions defined in ADL_DISPLAY_POSSIBLEMAPRESULT_VALID.
+    int iPossibleMapResultMask;
+    /// The bit mask identifies the possible map result. The detail definition is defined in ADL_DISPLAY_POSSIBLEMAPRESULT_XXX.
+    int iPossibleMapResultValue;
+} ADLPossibleMapResult, *LPADLPossibleMapResult;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the display SLS Grid information.
+///
+/// This structure is used to store the display SLS Grid information.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLSLSGrid
+{
+/// The Adapter index.
+    int iAdapterIndex;
+
+/// The grid index.
+    int  iSLSGridIndex;
+
+/// The grid row.
+    int  iSLSGridRow;
+
+/// The grid column.
+    int  iSLSGridColumn;
+
+/// The grid bit mask identifies the number of bits DisplayMap is currently using. Sum of all bits defined in ADL_DISPLAY_SLSGRID_ORIENTATION_XXX
+    int  iSLSGridMask;
+
+/// The grid bit value identifies the display status. Refer to ADL_DISPLAY_SLSGRID_ORIENTATION_XXX
+    int  iSLSGridValue;
+} ADLSLSGrid, *LPADLSLSGrid;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the display SLS Map information.
+///
+/// This structure is used to store the display SLS Map information.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct    ADLSLSMap
+{
+    /// The Adapter Index
+    int iAdapterIndex;
+
+    /// The current display map index. It is the OS Desktop index. For example, OS Index 1 showing clone mode. The Display Map will be 1.
+    int iSLSMapIndex;
+
+    /// Indicate the current grid
+    ADLSLSGrid grid;
+
+    /// OS surface index
+    int  iSurfaceMapIndex;
+
+     ///  Screen orientation. E.g., 0, 90, 180, 270
+     int iOrientation;
+
+    /// The number of display targets belongs to this map
+    int  iNumSLSTarget;
+
+    /// The first target array index in the Target array
+    int  iFirstSLSTargetArrayIndex;
+
+    /// The number of native modes belongs to this map
+    int  iNumNativeMode;
+
+    /// The first native mode array index in the native mode array
+    int  iFirstNativeModeArrayIndex;
+
+    /// The number of bezel modes belongs to this map
+    int  iNumBezelMode;
+
+    /// The first bezel mode array index in the native mode array
+    int  iFirstBezelModeArrayIndex;
+
+    /// The number of bezel offsets belongs to this map
+    int  iNumBezelOffset;
+
+    /// The first bezel offset array index in the
+    int  iFirstBezelOffsetArrayIndex;
+
+    /// The bit mask identifies the number of bits DisplayMap is currently using. Sum all the bit definitions defined in ADL_DISPLAY_SLSMAP_XXX.
+    int  iSLSMapMask;
+
+    /// The bit mask identifies the display map status. Refer to ADL_DISPLAY_SLSMAP_XXX
+    int  iSLSMapValue;
+} ADLSLSMap, *LPADLSLSMap;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the display SLS Offset information.
+///
+/// This structure is used to store the display SLS Offset information.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLSLSOffset
+{
+    /// The Adapter Index
+    int iAdapterIndex;
+
+    /// The current display map index. It is the OS Desktop index. For example, OS Index 1 showing clone mode. The Display Map will be 1.
+    int iSLSMapIndex;
+
+    /// The Display ID.
+    ADLDisplayID displayID;
+
+    /// SLS Bezel Mode Index
+    int iBezelModeIndex;
+
+    /// SLS Bezel Offset X
+    int iBezelOffsetX;
+
+    /// SLS Bezel Offset Y
+    int iBezelOffsetY;
+
+    /// SLS Display Width
+    int iDisplayWidth;
+
+    /// SLS Display Height
+    int iDisplayHeight;
+
+    /// The bit mask identifies the number of bits Offset is currently using.
+    int iBezelOffsetMask;
+
+    /// The bit mask identifies the display status.
+    int  iBezelffsetValue;
+} ADLSLSOffset, *LPADLSLSOffset;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the display SLS Mode information.
+///
+/// This structure is used to store the display SLS Mode information.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLSLSMode
+{
+    /// The Adapter Index
+    int iAdapterIndex;
+
+    /// The current display map index. It is the OS Desktop index. For example, OS Index 1 showing clone mode. The Display Map will be 1.
+    int iSLSMapIndex;
+
+    /// The mode index
+    int iSLSModeIndex;
+
+    /// The mode for this map.
+    ADLMode displayMode;
+
+    /// The bit mask identifies the number of bits Mode is currently using.
+    int iSLSNativeModeMask;
+
+    /// The bit mask identifies the display status.
+    int iSLSNativeModeValue;
+} ADLSLSMode, *LPADLSLSMode;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the display Possible SLS Map information.
+///
+/// This structure is used to store the display Possible SLS Map information.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLPossibleSLSMap
+{
+    /// The current display map index. It is the OS Desktop index.
+    /// For example, OS Index 1 showing clone mode. The Display Map will be 1.
+    int iSLSMapIndex;
+
+    /// Number of display map to be validated.
+    int iNumSLSMap;
+
+    /// The display map list for validation
+    ADLSLSMap* lpSLSMap;
+
+    /// the number of display map config to be validated.
+    int iNumSLSTarget;
+
+    /// The display target list for validation.
+    ADLDisplayTarget* lpDisplayTarget;
+} ADLPossibleSLSMap, *LPADLPossibleSLSMap;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the SLS targets.
+///
+/// This structure is used to store the SLS targets information.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLSLSTarget
+{
+    /// the logic adapter index
+    int iAdapterIndex;
+
+    /// The SLS map index
+    int iSLSMapIndex;
+
+    /// The target ID
+    ADLDisplayTarget displayTarget;
+
+    /// Target postion X in SLS grid
+    int iSLSGridPositionX;
+
+    /// Target postion Y in SLS grid
+    int iSLSGridPositionY;
+
+    /// The view size width, height and rotation angle per SLS Target
+    ADLMode viewSize;
+
+    /// The bit mask identifies the bits in iSLSTargetValue are currently used
+    int iSLSTargetMask;
+
+    /// The bit mask identifies status info. It is for function extension purpose
+    int iSLSTargetValue;
+} ADLSLSTarget, *LPADLSLSTarget;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the Adapter offset stepping size.
+///
+/// This structure is used to store the Adapter offset stepping size information.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLBezelOffsetSteppingSize
+{
+    /// the logic adapter index
+    int iAdapterIndex;
+
+    /// The SLS map index
+    int iSLSMapIndex;
+
+    /// Bezel X stepping size offset
+    int iBezelOffsetSteppingSizeX;
+
+    /// Bezel Y stepping size offset
+    int iBezelOffsetSteppingSizeY;
+
+    /// Identifies the bits this structure is currently using. It will be the total OR of all the bit definitions.
+    int iBezelOffsetSteppingSizeMask;
+
+    /// Bit mask identifies the display status.
+    int iBezelOffsetSteppingSizeValue;
+} ADLBezelOffsetSteppingSize, *LPADLBezelOffsetSteppingSize;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the overlap offset info for all the displays for each SLS mode.
+///
+/// This structure is used to store the no. of overlapped modes for each SLS Mode once user finishes the configuration from Overlap Widget
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLSLSOverlappedMode
+{
+    /// the SLS mode for which the overlap is configured
+    ADLMode SLSMode;
+    /// the number of target displays in SLS.
+    int iNumSLSTarget;
+    /// the first target array index in the target array
+    int iFirstTargetArrayIndex;
+}ADLSLSTargetOverlap, *LPADLSLSTargetOverlap;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about driver supported PowerExpress Config Caps
+///
+/// This structure is used to store the driver supported PowerExpress Config Caps
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLPXConfigCaps
+{
+    /// The Persistent logical Adapter Index.
+    int iAdapterIndex;
+
+    /// The bit mask identifies the number of bits PowerExpress Config Caps is currently using. It is the sum of all the bit definitions defined in ADL_PX_CONFIGCAPS_XXXX /ref define_powerxpress_constants.
+    int  iPXConfigCapMask;
+
+    /// The bit mask identifies the PowerExpress Config Caps value. The detailed definition is in ADL_PX_CONFIGCAPS_XXXX /ref define_powerxpress_constants.
+    int  iPXConfigCapValue;
+} ADLPXConfigCaps, *LPADLPXConfigCaps;
+
+/////////////////////////////////////////////////////////////////////////////////////////
+///\brief Enum containing PX or HG type
+///
+/// This enum is used to get PX or hG type
+///
+/// \nosubgrouping
+//////////////////////////////////////////////////////////////////////////////////////////
+typedef enum ADLPxType
+{
+	//Not AMD related PX/HG or not PX or HG at all
+	ADL_PX_NONE = 0,
+	//A+A PX
+	ADL_SWITCHABLE_AMDAMD = 1,
+	// A+A HG
+	ADL_HG_AMDAMD = 2,
+	//A+I PX
+	ADL_SWITCHABLE_AMDOTHER = 3,
+	//A+I HG
+	ADL_HG_AMDOTHER = 4,
+}ADLPxType;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about an application
+///
+/// This structure is used to store basic information of an application
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLApplicationData
+{
+    /// Path Name
+    char strPathName[ADL_MAX_PATH];
+    /// File Name
+    char strFileName[ADL_APP_PROFILE_FILENAME_LENGTH];
+    /// Creation timestamp
+    char strTimeStamp[ADL_APP_PROFILE_TIMESTAMP_LENGTH];
+    /// Version
+    char strVersion[ADL_APP_PROFILE_VERSION_LENGTH];
+}ADLApplicationData;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about an application
+///
+/// This structure is used to store basic information of an application
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLApplicationDataX2
+{
+    /// Path Name
+    wchar_t strPathName[ADL_MAX_PATH];
+    /// File Name
+    wchar_t strFileName[ADL_APP_PROFILE_FILENAME_LENGTH];
+    /// Creation timestamp
+    wchar_t strTimeStamp[ADL_APP_PROFILE_TIMESTAMP_LENGTH];
+    /// Version
+    wchar_t strVersion[ADL_APP_PROFILE_VERSION_LENGTH];
+}ADLApplicationDataX2;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about an application
+///
+/// This structure is used to store basic information of an application including process id
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLApplicationDataX3
+{
+    /// Path Name
+    wchar_t strPathName[ADL_MAX_PATH];
+    /// File Name
+    wchar_t strFileName[ADL_APP_PROFILE_FILENAME_LENGTH];
+    /// Creation timestamp
+    wchar_t strTimeStamp[ADL_APP_PROFILE_TIMESTAMP_LENGTH];
+    /// Version
+    wchar_t strVersion[ADL_APP_PROFILE_VERSION_LENGTH];
+    //Application Process id
+    unsigned int iProcessId;
+}ADLApplicationDataX3;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information of a property of an application profile
+///
+/// This structure is used to store property information of an application profile
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct PropertyRecord
+{
+    /// Property Name
+    char strName [ADL_APP_PROFILE_PROPERTY_LENGTH];
+    /// Property Type
+    ADLProfilePropertyType eType;
+    /// Data Size in bytes
+    int iDataSize;
+    /// Property Value, can be any data type
+    unsigned char uData[1];
+}PropertyRecord;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about an application profile
+///
+/// This structure is used to store information of an application profile
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLApplicationProfile
+{
+    /// Number of properties
+    int iCount;
+    /// Buffer to store all property records
+    PropertyRecord record[1];
+}ADLApplicationProfile;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about an OD5 Power Control feature
+///
+/// This structure is used to store information of an Power Control feature
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLPowerControlInfo
+{
+/// Minimum value.
+int iMinValue;
+/// Maximum value.
+int iMaxValue;
+/// The minimum change in between minValue and maxValue.
+int iStepValue;
+ } ADLPowerControlInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about an controller mode
+///
+/// This structure is used to store information of an controller mode
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLControllerMode
+{
+    /// This falg indicates actions that will be applied by set viewport
+    /// The value can be a combination of ADL_CONTROLLERMODE_CM_MODIFIER_VIEW_POSITION,
+    /// ADL_CONTROLLERMODE_CM_MODIFIER_VIEW_PANLOCK and ADL_CONTROLLERMODE_CM_MODIFIER_VIEW_SIZE
+    int iModifiers;
+
+    /// Horizontal view starting position
+    int iViewPositionCx;
+
+    /// Vertical view starting position
+    int iViewPositionCy;
+
+    /// Horizontal left panlock position
+    int iViewPanLockLeft;
+
+    /// Horizontal right panlock position
+    int iViewPanLockRight;
+
+    /// Vertical top panlock position
+    int iViewPanLockTop;
+
+    /// Vertical bottom panlock position
+    int iViewPanLockBottom;
+
+    /// View resolution in pixels (width)
+    int iViewResolutionCx;
+
+    /// View resolution in pixels (hight)
+    int iViewResolutionCy;
+}ADLControllerMode;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about a display
+///
+/// This structure is used to store information about a display
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDisplayIdentifier
+{
+    /// ADL display index
+    long ulDisplayIndex;
+
+    /// manufacturer ID of the display
+    long ulManufacturerId;
+
+    /// product ID of the display
+    long ulProductId;
+
+    /// serial number of the display
+    long ulSerialNo;
+} ADLDisplayIdentifier;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive 6 clock range
+///
+/// This structure is used to store information about Overdrive 6 clock range
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLOD6ParameterRange
+{
+    /// The starting value of the clock range
+    int     iMin;
+    /// The ending value of the clock range
+    int     iMax;
+    /// The minimum increment between clock values
+    int     iStep;
+} ADLOD6ParameterRange;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive 6 capabilities
+///
+/// This structure is used to store information about Overdrive 6 capabilities
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLOD6Capabilities
+{
+    /// Contains a bitmap of the OD6 capability flags.  Possible values: \ref ADL_OD6_CAPABILITY_SCLK_CUSTOMIZATION,
+    /// \ref ADL_OD6_CAPABILITY_MCLK_CUSTOMIZATION, \ref ADL_OD6_CAPABILITY_GPU_ACTIVITY_MONITOR
+    int     iCapabilities;
+    /// Contains a bitmap indicating the power states
+    /// supported by OD6.  Currently only the performance state
+    /// is supported. Possible Values: \ref ADL_OD6_SUPPORTEDSTATE_PERFORMANCE
+    int     iSupportedStates;
+    /// Number of levels. OD6 will always use 2 levels, which describe
+    /// the minimum to maximum clock ranges.
+    /// The 1st level indicates the minimum clocks, and the 2nd level
+    /// indicates the maximum clocks.
+    int     iNumberOfPerformanceLevels;
+    /// Contains the hard limits of the sclk range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLOD6ParameterRange     sEngineClockRange;
+    /// Contains the hard limits of the mclk range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLOD6ParameterRange     sMemoryClockRange;
+
+    /// Value for future extension
+    int     iExtValue;
+    /// Mask for future extension
+    int     iExtMask;
+} ADLOD6Capabilities;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive 6 clock values.
+///
+/// This structure is used to store information about Overdrive 6 clock values.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLOD6PerformanceLevel
+{
+    /// Engine (core) clock.
+    int iEngineClock;
+    /// Memory clock.
+    int iMemoryClock;
+} ADLOD6PerformanceLevel;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive 6 clocks.
+///
+/// This structure is used to store information about Overdrive 6 clocks.  This is a
+/// variable-sized structure.  iNumberOfPerformanceLevels indicate how many elements
+/// are contained in the aLevels array.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLOD6StateInfo
+{
+    /// Number of levels.  OD6 uses clock ranges instead of discrete performance levels.
+    /// iNumberOfPerformanceLevels is always 2.  The 1st level indicates the minimum clocks
+    /// in the range.  The 2nd level indicates the maximum clocks in the range.
+    int     iNumberOfPerformanceLevels;
+
+    /// Value for future extension
+    int     iExtValue;
+    /// Mask for future extension
+    int     iExtMask;
+
+    /// Variable-sized array of levels.
+    /// The number of elements in the array is specified by iNumberofPerformanceLevels.
+    ADLOD6PerformanceLevel aLevels [1];
+} ADLOD6StateInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about current Overdrive 6 performance status.
+///
+/// This structure is used to store information about current Overdrive 6 performance status.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLOD6CurrentStatus
+{
+    /// Current engine clock in 10 KHz.
+    int     iEngineClock;
+    /// Current memory clock in 10 KHz.
+    int     iMemoryClock;
+    /// Current GPU activity in percent.  This
+    /// indicates how "busy" the GPU is.
+    int     iActivityPercent;
+    /// Not used.  Reserved for future use.
+    int     iCurrentPerformanceLevel;
+    /// Current PCI-E bus speed
+    int     iCurrentBusSpeed;
+    /// Current PCI-E bus # of lanes
+    int     iCurrentBusLanes;
+    /// Maximum possible PCI-E bus # of lanes
+    int     iMaximumBusLanes;
+
+    /// Value for future extension
+    int     iExtValue;
+    /// Mask for future extension
+    int     iExtMask;
+} ADLOD6CurrentStatus;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive 6 thermal contoller capabilities
+///
+/// This structure is used to store information about Overdrive 6 thermal controller capabilities
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLOD6ThermalControllerCaps
+{
+    /// Contains a bitmap of thermal controller capability flags. Possible values: \ref ADL_OD6_TCCAPS_THERMAL_CONTROLLER, \ref ADL_OD6_TCCAPS_FANSPEED_CONTROL,
+    /// \ref ADL_OD6_TCCAPS_FANSPEED_PERCENT_READ, \ref ADL_OD6_TCCAPS_FANSPEED_PERCENT_WRITE, \ref ADL_OD6_TCCAPS_FANSPEED_RPM_READ, \ref ADL_OD6_TCCAPS_FANSPEED_RPM_WRITE
+    int     iCapabilities;
+    /// Minimum fan speed expressed as a percentage
+    int     iFanMinPercent;
+    /// Maximum fan speed expressed as a percentage
+    int     iFanMaxPercent;
+    /// Minimum fan speed expressed in revolutions-per-minute
+    int     iFanMinRPM;
+    /// Maximum fan speed expressed in revolutions-per-minute
+    int     iFanMaxRPM;
+
+    /// Value for future extension
+    int     iExtValue;
+    /// Mask for future extension
+    int     iExtMask;
+} ADLOD6ThermalControllerCaps;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive 6 fan speed information
+///
+/// This structure is used to store information about Overdrive 6 fan speed information
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLOD6FanSpeedInfo
+{
+    /// Contains a bitmap of the valid fan speed type flags.  Possible values: \ref ADL_OD6_FANSPEED_TYPE_PERCENT, \ref ADL_OD6_FANSPEED_TYPE_RPM, \ref ADL_OD6_FANSPEED_USER_DEFINED
+    int     iSpeedType;
+    /// Contains current fan speed in percent (if valid flag exists in iSpeedType)
+    int     iFanSpeedPercent;
+    /// Contains current fan speed in RPM (if valid flag exists in iSpeedType)
+    int        iFanSpeedRPM;
+
+    /// Value for future extension
+    int     iExtValue;
+    /// Mask for future extension
+    int     iExtMask;
+} ADLOD6FanSpeedInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive 6 fan speed value
+///
+/// This structure is used to store information about Overdrive 6 fan speed value
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLOD6FanSpeedValue
+{
+    /// Indicates the units of the fan speed.  Possible values: \ref ADL_OD6_FANSPEED_TYPE_PERCENT, \ref ADL_OD6_FANSPEED_TYPE_RPM
+    int     iSpeedType;
+    /// Fan speed value (units as indicated above)
+    int     iFanSpeed;
+
+    /// Value for future extension
+    int     iExtValue;
+    /// Mask for future extension
+    int     iExtMask;
+} ADLOD6FanSpeedValue;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive 6 PowerControl settings.
+///
+/// This structure is used to store information about Overdrive 6 PowerControl settings.
+/// PowerControl is the feature which allows the performance characteristics of the GPU
+/// to be adjusted by changing the PowerTune power limits.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLOD6PowerControlInfo
+{
+    /// The minimum PowerControl adjustment value
+    int     iMinValue;
+    /// The maximum PowerControl adjustment value
+    int     iMaxValue;
+    /// The minimum difference between PowerControl adjustment values
+    int     iStepValue;
+
+    /// Value for future extension
+    int     iExtValue;
+    /// Mask for future extension
+    int     iExtMask;
+} ADLOD6PowerControlInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive 6 PowerControl settings.
+///
+/// This structure is used to store information about Overdrive 6 PowerControl settings.
+/// PowerControl is the feature which allows the performance characteristics of the GPU
+/// to be adjusted by changing the PowerTune power limits.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLOD6VoltageControlInfo
+{
+    /// The minimum VoltageControl adjustment value
+    int     iMinValue;
+    /// The maximum VoltageControl adjustment value
+    int     iMaxValue;
+    /// The minimum difference between VoltageControl adjustment values
+    int     iStepValue;
+
+    /// Value for future extension
+    int     iExtValue;
+    /// Mask for future extension
+    int     iExtMask;
+} ADLOD6VoltageControlInfo;
+
+////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing ECC statistics namely SEC counts and DED counts
+/// Single error count - count of errors that can be corrected
+/// Doubt Error Detect -  count of errors that cannot be corrected
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLECCData
+{
+    // Single error count - count of errors that can be corrected
+    int iSec;
+    // Double error detect - count of errors that cannot be corrected
+    int iDed;
+} ADLECCData;
+
+/// \brief Handle to ADL client context.
+///
+///  ADL clients obtain context handle from initial call to \ref ADL2_Main_Control_Create.
+///  Clients have to pass the handle to each subsequent ADL call and finally destroy
+///  the context with call to \ref ADL2_Main_Control_Destroy
+/// \nosubgrouping
+typedef void *ADL_CONTEXT_HANDLE;
+
+/// \brief Handle to ADL Frame Monitor Token.
+///
+///  Frame Monitor clients obtain handle from initial call to \ref ADL2_Adapter_FrameMetrics_FrameDuration_Enable
+///  Clients have to pass the handle to each subsequent ADL call to \ref ADL2_Adapter_FrameMetrics_FrameDuration_Get
+///  and finally destroy the token with call to \ref ADL2_Adapter_FrameMetrics_FrameDuration_Disable
+/// \nosubgrouping
+typedef void *ADL_FRAME_DURATION_HANDLE;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing the display mode definition used per controller.
+///
+/// This structure is used to store the display mode definition used per controller.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDisplayModeX2
+{
+/// Horizontal resolution (in pixels).
+   int  iWidth;
+/// Vertical resolution (in lines).
+   int  iHeight;
+/// Interlaced/Progressive. The value will be set for Interlaced as ADL_DL_TIMINGFLAG_INTERLACED. If not set it is progressive. Refer define_detailed_timing_flags.
+   int  iScanType;
+/// Refresh rate.
+   int  iRefreshRate;
+/// Timing Standard. Refer define_modetiming_standard.
+   int  iTimingStandard;
+} ADLDisplayModeX2;
+
+typedef enum ADLAppProcessState
+{
+	APP_PROC_INVALID = 0,          // Invalid Application
+	APP_PROC_PREMPTION = 1,          // The Application is being set up for Process Creation
+	APP_PROC_CREATION = 2,          // The Application's Main Process is created by the OS
+	APP_PROC_READ = 3,          // The Application's Data is ready to be read
+	APP_PROC_WAIT = 4,          // The Application is waiting for Timeout or Notification to Resume
+	APP_PROC_RUNNING = 5,          // The Application is running
+	APP_PROC_TERMINATE = 6           // The Application is about to terminate
+}ADLAppProcessState;
+
+typedef enum ADLAppInterceptionListType
+{
+	ADL_INVALID_FORMAT = 0,
+	ADL_IMAGEFILEFORMAT = 1,
+	ADL_ENVVAR = 2
+}ADLAppInterceptionListType;
+
+typedef struct ADLAppInterceptionInfo
+{
+	wchar_t                     AppName[ADL_MAX_PATH]; // the file name of the application or env var
+	unsigned int                ProcessId;
+	ADLAppInterceptionListType  AppFormat;
+	ADLAppProcessState          AppState;
+} ADLAppInterceptionInfo;
+
+typedef enum ADL_AP_DATABASE // same as _SHARED_AP_DATABASE in "inc/shared/shared_escape.h"
+{
+	ADL_AP_DATABASE__SYSTEM,
+	ADL_AP_DATABASE__USER,
+	ADL_AP_DATABASE__OEM
+} ADL_AP_DATABASE;
+
+typedef struct ADLAppInterceptionInfoX2
+{
+	wchar_t                     AppName[ADL_MAX_PATH]; // the file name of the application or env var
+	unsigned int                ProcessId;
+	unsigned int                WaitForResumeNeeded;
+	wchar_t                     CommandLine[ADL_MAX_PATH]; // The command line on app start/stop event
+	ADLAppInterceptionListType  AppFormat;
+	ADLAppProcessState          AppState;
+} ADLAppInterceptionInfoX2;
+
+typedef struct ADLAppInterceptionInfoX3
+{
+    wchar_t                     AppName[ADL_MAX_PATH]; // the file name of the application or env var
+    unsigned int                ProcessId;
+    unsigned int                WaitForResumeNeeded;
+    unsigned int                RayTracingStatus; // returns the Ray Tracing status if it is enabled atleast once in session.
+    wchar_t                     CommandLine[ADL_MAX_PATH]; // The command line on app start/stop event
+    ADLAppInterceptionListType  AppFormat;
+    ADLAppProcessState          AppState;
+} ADLAppInterceptionInfoX3;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information info for a property record in a profile
+///
+/// This structure is used to store info for a property record in a profile
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLPropertyRecordCreate
+{
+	/// Name of the property
+	wchar_t * strPropertyName;
+	/// Data type of the property
+	ADLProfilePropertyType eType;
+	// Value of the property
+	wchar_t * strPropertyValue;
+} ADLPropertyRecordCreate;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information info for an application record
+///
+/// This structure is used to store info for an application record
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLApplicationRecord
+{
+    /// Title of the application
+    wchar_t * strTitle;
+    /// File path of the application
+    wchar_t * strPathName;
+    /// File name of the application
+    wchar_t * strFileName;
+    /// File versin the application
+    wchar_t * strVersion;
+    /// Nostes on the application
+    wchar_t * strNotes;
+    /// Driver area which the application uses
+    wchar_t * strArea;
+    /// Name of profile assigned to the application
+    wchar_t * strProfileName;
+    // Source where this application record come from
+    ADL_AP_DATABASE recordSource;
+} ADLApplicationRecord;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive 6 extension capabilities
+///
+/// This structure is used to store information about Overdrive 6 extension capabilities
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLOD6CapabilitiesEx
+{
+    /// Contains a bitmap of the OD6 extension capability flags.  Possible values: \ref ADL_OD6_CAPABILITY_SCLK_CUSTOMIZATION,
+    /// \ref ADL_OD6_CAPABILITY_MCLK_CUSTOMIZATION, \ref ADL_OD6_CAPABILITY_GPU_ACTIVITY_MONITOR,
+    /// \ref ADL_OD6_CAPABILITY_POWER_CONTROL, \ref ADL_OD6_CAPABILITY_VOLTAGE_CONTROL, \ref ADL_OD6_CAPABILITY_PERCENT_ADJUSTMENT,
+    //// \ref ADL_OD6_CAPABILITY_THERMAL_LIMIT_UNLOCK
+    int iCapabilities;
+    /// The Power states that support clock and power customization.  Only performance state is currently supported.
+    /// Possible Values: \ref ADL_OD6_SUPPORTEDSTATE_PERFORMANCE
+    int iSupportedStates;
+    /// Returns the hard limits of the SCLK overdrive adjustment range.  Overdrive clocks should not be adjusted outside of this range.  The values are specified as +/- percentages.
+    ADLOD6ParameterRange sEngineClockPercent;
+    /// Returns the hard limits of the MCLK overdrive adjustment range.  Overdrive clocks should not be adjusted outside of this range.  The values are specified as +/- percentages.
+    ADLOD6ParameterRange sMemoryClockPercent;
+    /// Returns the hard limits of the Power Limit adjustment range.  Power limit should not be adjusted outside this range.  The values are specified as +/- percentages.
+    ADLOD6ParameterRange sPowerControlPercent;
+    /// Reserved for future expansion of the structure.
+    int iExtValue;
+    /// Reserved for future expansion of the structure.
+    int iExtMask;
+} ADLOD6CapabilitiesEx;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive 6 extension state information
+///
+/// This structure is used to store information about Overdrive 6 extension state information
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLOD6StateEx
+{
+    /// The current engine clock adjustment value, specified as a +/- percent.
+    int iEngineClockPercent;
+    /// The current memory clock adjustment value, specified as a +/- percent.
+    int iMemoryClockPercent;
+    /// The current power control adjustment value, specified as a +/- percent.
+    int iPowerControlPercent;
+    /// Reserved for future expansion of the structure.
+    int iExtValue;
+    /// Reserved for future expansion of the structure.
+    int iExtMask;
+} ADLOD6StateEx;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive 6 extension recommended maximum clock adjustment values
+///
+/// This structure is used to store information about Overdrive 6 extension recommended maximum clock adjustment values
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLOD6MaxClockAdjust
+{
+    /// The recommended maximum engine clock adjustment in percent, for the specified power limit value.
+    int iEngineClockMax;
+    /// The recommended maximum memory clock adjustment in percent, for the specified power limit value.
+    /// Currently the memory is independent of the Power Limit setting, so iMemoryClockMax will always return the maximum
+    /// possible adjustment value.  This field is here for future enhancement in case we add a dependency between Memory Clock
+    /// adjustment and Power Limit setting.
+    int iMemoryClockMax;
+    /// Reserved for future expansion of the structure.
+    int iExtValue;
+    /// Reserved for future expansion of the structure.
+    int iExtMask;
+} ADLOD6MaxClockAdjust;
+
+////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing the Connector information
+///
+/// this structure is used to get the connector information like length, positions & etc.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLConnectorInfo
+{
+    ///index of the connector(0-based)
+    int iConnectorIndex;
+    ///used for disply identification/ordering
+    int iConnectorId;
+    ///index of the slot, 0-based index.
+    int iSlotIndex;
+    ///Type of the connector. \ref define_connector_types
+    int iType;
+    ///Position of the connector(in millimeters), from the right side of the slot.
+    int iOffset;
+    ///Length of the connector(in millimeters).
+    int iLength;
+} ADLConnectorInfo;
+
+////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing the slot information
+///
+/// this structure is used to get the slot information like length of the slot, no of connectors on the slot & etc.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLBracketSlotInfo
+{
+    ///index of the slot, 0-based index.
+    int iSlotIndex;
+    ///length of the slot(in millimeters).
+    int iLength;
+    ///width of the slot(in millimeters).
+    int iWidth;
+} ADLBracketSlotInfo;
+
+////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing MST branch information
+///
+/// this structure is used to store the MST branch information
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLMSTRad
+{
+    ///depth of the link.
+    int iLinkNumber;
+    /// Relative address, address scheme starts from source side
+    char rad[ADL_MAX_RAD_LINK_COUNT];
+} ADLMSTRad;
+
+////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing port information
+///
+/// this structure is used to get the display or MST branch information
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDevicePort
+{
+    ///index of the connector.
+    int iConnectorIndex;
+    ///Relative MST address. If MST RAD contains 0 it means DP or Root of the MST topology. For non DP connectors MST RAD is ignored.
+    ADLMSTRad aMSTRad;
+} ADLDevicePort;
+
+////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing supported connection types and properties
+///
+/// this structure is used to get the supported connection types and supported properties of given connector
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLSupportedConnections
+{
+    ///Bit vector of supported connections. Bitmask is defined in constants section. \ref define_connection_types
+    int iSupportedConnections;
+    ///Array of bitvectors. Each bit vector represents supported properties for one connection type. Index of this array is connection type (bit number in mask).
+    int iSupportedProperties[ADL_MAX_CONNECTION_TYPES];
+} ADLSupportedConnections;
+
+////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing connection state of the connector
+///
+/// this structure is used to get the current Emulation status and mode of the given connector
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLConnectionState
+{
+    ///The value is bit vector. Each bit represents status. See masks constants for details. \ref define_emulation_status
+    int iEmulationStatus;
+    ///It contains information about current emulation mode. See constants for details. \ref define_emulation_mode
+    int iEmulationMode;
+    ///If connection is active it will contain display id, otherwise CWDDEDI_INVALID_DISPLAY_INDEX
+    int iDisplayIndex;
+} ADLConnectionState;
+
+////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing connection properties information
+///
+/// this structure is used to retrieve the properties of connection type
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLConnectionProperties
+{
+    //Bit vector. Represents actual properties. Supported properties for specific connection type. \ref define_connection_properties
+    int iValidProperties;
+    //Bitrate(in MHz). Could be used for MST branch, DP or DP active dongle. \ref define_linkrate_constants
+    int iBitrate;
+    //Number of lanes in DP connection. \ref define_lanecount_constants
+    int iNumberOfLanes;
+    //Color depth(in bits). \ref define_colordepth_constants
+    int iColorDepth;
+    //3D capabilities. It could be used for some dongles. For instance: alternate framepack. Value of this property is bit vector.
+    int iStereo3DCaps;
+    ///Output Bandwidth. Could be used for MST branch, DP or DP Active dongle. \ref define_linkrate_constants
+    int iOutputBandwidth;
+} ADLConnectionProperties;
+
+////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing connection information
+///
+/// this structure is used to retrieve the data from driver which includes
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLConnectionData
+{
+    ///Connection type. based on the connection type either iNumberofPorts or IDataSize,EDIDdata is valid, \ref define_connection_types
+    int iConnectionType;
+    ///Specifies the connection properties.
+    ADLConnectionProperties aConnectionProperties;
+    ///Number of ports
+    int iNumberofPorts;
+    ///Number of Active Connections
+    int iActiveConnections;
+    ///actual size of EDID data block size.
+    int iDataSize;
+    ///EDID Data
+    char EdidData[ADL_MAX_DISPLAY_EDID_DATA_SIZE];
+} ADLConnectionData;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about an controller mode including Number of Connectors
+///
+/// This structure is used to store information of an controller mode
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLAdapterCapsX2
+{
+    /// AdapterID for this adapter
+    int iAdapterID;
+    /// Number of controllers for this adapter
+    int iNumControllers;
+    /// Number of displays for this adapter
+    int iNumDisplays;
+    /// Number of overlays for this adapter
+    int iNumOverlays;
+    /// Number of GLSyncConnectors
+    int iNumOfGLSyncConnectors;
+    /// The bit mask identifies the adapter caps
+    int iCapsMask;
+    /// The bit identifies the adapter caps \ref define_adapter_caps
+    int iCapsValue;
+    /// Number of Connectors for this adapter
+    int iNumConnectors;
+}ADLAdapterCapsX2;
+
+typedef enum ADL_ERROR_RECORD_SEVERITY
+{
+    ADL_GLOBALLY_UNCORRECTED  = 1,
+    ADL_LOCALLY_UNCORRECTED   = 2,
+    ADL_DEFFERRED             = 3,
+    ADL_CORRECTED             = 4
+}ADL_ERROR_RECORD_SEVERITY;
+
+typedef union _ADL_ECC_EDC_FLAG
+{
+    struct
+    {
+        unsigned int isEccAccessing        : 1;
+        unsigned int reserved              : 31;
+    }bits;
+    unsigned int u32All;
+}ADL_ECC_EDC_FLAG;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about EDC Error Record
+///
+/// This structure is used to store EDC Error Record
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLErrorRecord
+{
+    // Severity of error
+    ADL_ERROR_RECORD_SEVERITY Severity;
+
+    // Is the counter valid?
+    int  countValid;
+
+    // Counter value, if valid
+    unsigned int count;
+
+    // Is the location information valid?
+    int locationValid;
+
+    // Physical location of error
+    unsigned int CU; // CU number on which error occurred, if known
+    char StructureName[32]; // e.g. LDS, TCC, etc.
+
+    // Time of error record creation (e.g. time of query, or time of poison interrupt)
+    char tiestamp[32];
+
+    unsigned int padding[3];
+}ADLErrorRecord;
+
+typedef enum ADL_EDC_BLOCK_ID
+{
+    ADL_EDC_BLOCK_ID_SQCIS = 1,
+    ADL_EDC_BLOCK_ID_SQCDS = 2,
+    ADL_EDC_BLOCK_ID_SGPR  = 3,
+    ADL_EDC_BLOCK_ID_VGPR  = 4,
+    ADL_EDC_BLOCK_ID_LDS   = 5,
+    ADL_EDC_BLOCK_ID_GDS   = 6,
+    ADL_EDC_BLOCK_ID_TCL1  = 7,
+    ADL_EDC_BLOCK_ID_TCL2  = 8
+}ADL_EDC_BLOCK_ID;
+
+typedef enum ADL_ERROR_INJECTION_MODE
+{
+    ADL_ERROR_INJECTION_MODE_SINGLE      = 1,
+    ADL_ERROR_INJECTION_MODE_MULTIPLE    = 2,
+    ADL_ERROR_INJECTION_MODE_ADDRESS     = 3
+}ADL_ERROR_INJECTION_MODE;
+
+typedef union _ADL_ERROR_PATTERN
+{
+    struct
+    {
+        unsigned long  EccInjVector         :  16;
+        unsigned long  EccInjEn             :  9;
+        unsigned long  EccBeatEn            :  4;
+        unsigned long  EccChEn              :  4;
+        unsigned long  reserved             :  31;
+    } bits;
+    unsigned long long u64Value;
+} ADL_ERROR_PATTERN;
+
+typedef struct ADL_ERROR_INJECTION_DATA
+{
+    unsigned long long errorAddress;
+    ADL_ERROR_PATTERN errorPattern;
+}ADL_ERROR_INJECTION_DATA;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about EDC Error Injection
+///
+/// This structure is used to store EDC Error Injection
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLErrorInjection
+{
+    ADL_EDC_BLOCK_ID blockId;
+    ADL_ERROR_INJECTION_MODE errorInjectionMode;
+}ADLErrorInjection;
+
+typedef struct ADLErrorInjectionX2
+{
+    ADL_EDC_BLOCK_ID blockId;
+    ADL_ERROR_INJECTION_MODE errorInjectionMode;
+    ADL_ERROR_INJECTION_DATA errorInjectionData;
+}ADLErrorInjectionX2;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing per display FreeSync capability information.
+///
+/// This structure is used to store the FreeSync capability of both the display and
+/// the GPU the display is connected to.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLFreeSyncCap
+{
+    /// FreeSync capability flags. \ref define_freesync_caps
+    int iCaps;
+    /// Reports minimum FreeSync refresh rate supported by the display in micro hertz
+    int iMinRefreshRateInMicroHz;
+    /// Reports maximum FreeSync refresh rate supported by the display in micro hertz
+    int iMaxRefreshRateInMicroHz;
+    /// Index of FreeSync Label to use:  ADL_FREESYNC_LABEL_*
+    unsigned char ucLabelIndex;
+    /// Reserved
+    char cReserved[3];
+    int iReserved[4];
+} ADLFreeSyncCap;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing per display Display Connectivty Experience Settings
+///
+/// This structure is used to store the Display Connectivity Experience settings of a
+/// display
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDceSettings
+{
+    DceSettingsType type;                       // Defines which structure is in the union below
+    union
+    {
+        struct
+        {
+            bool qualityDetectionEnabled;
+        } HdmiLq;
+        struct
+        {
+            DpLinkRate linkRate;                // Read-only
+            unsigned int numberOfActiveLanes;   // Read-only
+            unsigned int numberofTotalLanes;    // Read-only
+            int relativePreEmphasis;            // Allowable values are -2 to +2
+            int relativeVoltageSwing;           // Allowable values are -2 to +2
+            int persistFlag;
+        } DpLink;
+        struct
+        {
+            bool linkProtectionEnabled;         // Read-only
+        } Protection;
+    } Settings;
+    int iReserved[15];
+} ADLDceSettings;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Graphic Core
+///
+/// This structure is used to get Graphic Core Info
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLGraphicCoreInfo
+{
+    /// indicate the graphic core generation
+    int iGCGen;
+
+    union
+    {
+        /// Total number of CUs. Valid for GCN (iGCGen == GCN)
+        int iNumCUs;
+        /// Total number of WGPs. Valid for RDNA (iGCGen == RDNA)
+        int iNumWGPs;
+    };
+
+    union
+    {
+        /// Number of processing elements per CU. Valid for GCN (iGCGen == GCN)
+        int iNumPEsPerCU;
+        /// Number of processing elements per WGP. Valid for RDNA (iGCGen == RDNA)
+        int iNumPEsPerWGP;
+    };
+
+    /// Total number of SIMDs. Valid for Pre GCN (iGCGen == Pre-GCN)
+    int iNumSIMDs;
+
+    /// Total number of ROPs. Valid for both GCN and Pre GCN
+    int iNumROPs;
+
+    /// reserved for future use
+    int iReserved[11];
+}ADLGraphicCoreInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive N clock range
+///
+/// This structure is used to store information about Overdrive N clock range
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLODNParameterRange
+{
+    /// The starting value of the clock range
+    int     iMode;
+    /// The starting value of the clock range
+    int     iMin;
+    /// The ending value of the clock range
+    int     iMax;
+    /// The minimum increment between clock values
+    int     iStep;
+    /// The default clock values
+    int     iDefault;
+} ADLODNParameterRange;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive N capabilities
+///
+/// This structure is used to store information about Overdrive N capabilities
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLODNCapabilities
+{
+    /// Number of levels which describe the minimum to maximum clock ranges.
+    /// The 1st level indicates the minimum clocks, and the 2nd level
+    /// indicates the maximum clocks.
+    int     iMaximumNumberOfPerformanceLevels;
+    /// Contains the hard limits of the sclk range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     sEngineClockRange;
+    /// Contains the hard limits of the mclk range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     sMemoryClockRange;
+    /// Contains the hard limits of the vddc range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     svddcRange;
+    /// Contains the hard limits of the power range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     power;
+    /// Contains the hard limits of the power range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     powerTuneTemperature;
+    /// Contains the hard limits of the Temperature range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     fanTemperature;
+    /// Contains the hard limits of the Fan range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     fanSpeed;
+    /// Contains the hard limits of the Fan range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     minimumPerformanceClock;
+} ADLODNCapabilities;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive N capabilities
+///
+/// This structure is used to store information about Overdrive N capabilities
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLODNCapabilitiesX2
+{
+    /// Number of levels which describe the minimum to maximum clock ranges.
+    /// The 1st level indicates the minimum clocks, and the 2nd level
+    /// indicates the maximum clocks.
+    int     iMaximumNumberOfPerformanceLevels;
+    /// bit vector, which tells what are the features are supported.
+    /// \ref: ADLODNFEATURECONTROL
+    int iFlags;
+    /// Contains the hard limits of the sclk range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     sEngineClockRange;
+    /// Contains the hard limits of the mclk range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     sMemoryClockRange;
+    /// Contains the hard limits of the vddc range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     svddcRange;
+    /// Contains the hard limits of the power range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     power;
+    /// Contains the hard limits of the power range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     powerTuneTemperature;
+    /// Contains the hard limits of the Temperature range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     fanTemperature;
+    /// Contains the hard limits of the Fan range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     fanSpeed;
+    /// Contains the hard limits of the Fan range.  Overdrive
+    /// clocks cannot be set outside this range.
+    ADLODNParameterRange     minimumPerformanceClock;
+    /// Contains the hard limits of the throttleNotification
+    ADLODNParameterRange throttleNotificaion;
+    /// Contains the hard limits of the Auto Systemclock
+    ADLODNParameterRange autoSystemClock;
+} ADLODNCapabilitiesX2;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive level.
+///
+/// This structure is used to store information about Overdrive level.
+/// This structure is used by ADLODPerformanceLevels.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLODNPerformanceLevel
+{
+    /// clock.
+    int iClock;
+    /// VDCC.
+    int iVddc;
+    /// enabled
+    int iEnabled;
+} ADLODNPerformanceLevel;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive N performance levels.
+///
+/// This structure is used to store information about Overdrive performance levels.
+/// This structure is used by the ADL_OverdriveN_ODPerformanceLevels_Get() and ADL_OverdriveN_ODPerformanceLevels_Set() functions.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLODNPerformanceLevels
+{
+    int iSize;
+    //Automatic/manual
+    int iMode;
+    /// Must be set to sizeof( \ref ADLODPerformanceLevels ) + sizeof( \ref ADLODPerformanceLevel ) * (ADLODParameters.iNumberOfPerformanceLevels - 1)
+    int iNumberOfPerformanceLevels;
+    /// Array of performance state descriptors. Must have ADLODParameters.iNumberOfPerformanceLevels elements.
+    ADLODNPerformanceLevel aLevels[1];
+} ADLODNPerformanceLevels;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive N Fan Speed.
+///
+/// This structure is used to store information about Overdrive Fan control .
+/// This structure is used by the ADL_OverdriveN_ODPerformanceLevels_Get() and ADL_OverdriveN_ODPerformanceLevels_Set() functions.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLODNFanControl
+{
+    int iMode;
+    int iFanControlMode;
+    int iCurrentFanSpeedMode;
+    int iCurrentFanSpeed;
+    int iTargetFanSpeed;
+    int iTargetTemperature;
+    int iMinPerformanceClock;
+    int iMinFanLimit;
+} ADLODNFanControl;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive N power limit.
+///
+/// This structure is used to store information about Overdrive power limit.
+/// This structure is used by the ADL_OverdriveN_ODPerformanceLevels_Get() and ADL_OverdriveN_ODPerformanceLevels_Set() functions.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLODNPowerLimitSetting
+{
+    int iMode;
+    int iTDPLimit;
+    int iMaxOperatingTemperature;
+} ADLODNPowerLimitSetting;
+
+typedef struct ADLODNPerformanceStatus
+{
+    int iCoreClock;
+    int iMemoryClock;
+    int iDCEFClock;
+    int iGFXClock;
+    int iUVDClock;
+    int iVCEClock;
+    int iGPUActivityPercent;
+    int iCurrentCorePerformanceLevel;
+    int iCurrentMemoryPerformanceLevel;
+    int iCurrentDCEFPerformanceLevel;
+    int iCurrentGFXPerformanceLevel;
+    int iUVDPerformanceLevel;
+    int iVCEPerformanceLevel;
+    int iCurrentBusSpeed;
+    int iCurrentBusLanes;
+    int iMaximumBusLanes;
+    int iVDDC;
+    int iVDDCI;
+} ADLODNPerformanceStatus;
+
+///\brief Structure containing information about Overdrive level.
+///
+/// This structure is used to store information about Overdrive level.
+/// This structure is used by ADLODPerformanceLevels.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLODNPerformanceLevelX2
+{
+    /// clock.
+    int iClock;
+    /// VDCC.
+    int iVddc;
+    /// enabled
+    int iEnabled;
+    /// MASK
+    int iControl;
+} ADLODNPerformanceLevelX2;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive N performance levels.
+///
+/// This structure is used to store information about Overdrive performance levels.
+/// This structure is used by the ADL_OverdriveN_ODPerformanceLevels_Get() and ADL_OverdriveN_ODPerformanceLevels_Set() functions.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLODNPerformanceLevelsX2
+{
+    int iSize;
+    //Automatic/manual
+    int iMode;
+    /// Must be set to sizeof( \ref ADLODPerformanceLevels ) + sizeof( \ref ADLODPerformanceLevel ) * (ADLODParameters.iNumberOfPerformanceLevels - 1)
+    int iNumberOfPerformanceLevels;
+    /// Array of performance state descriptors. Must have ADLODParameters.iNumberOfPerformanceLevels elements.
+    ADLODNPerformanceLevelX2 aLevels[1];
+} ADLODNPerformanceLevelsX2;
+
+typedef enum ADLODNCurrentPowerType
+{
+    ODN_GPU_TOTAL_POWER = 0,
+    ODN_GPU_PPT_POWER,
+    ODN_GPU_SOCKET_POWER,
+    ODN_GPU_CHIP_POWER
+} ADLODNCurrentPowerType;
+
+// in/out: CWDDEPM_CURRENTPOWERPARAMETERS
+typedef struct ADLODNCurrentPowerParameters
+{
+    int   size;
+    ADLODNCurrentPowerType   powerType;
+    int  currentPower;
+} ADLODNCurrentPowerParameters;
+
+//ODN Ext range data structure
+typedef struct ADLODNExtSingleInitSetting
+{
+	int mode;
+	int minValue;
+	int maxValue;
+	int step;
+	int defaultValue;
+} ADLODNExtSingleInitSetting;
+
+//OD8 Ext range data structure
+typedef struct ADLOD8SingleInitSetting
+{
+    int featureID;
+    int minValue;
+    int maxValue;
+    int defaultValue;
+} ADLOD8SingleInitSetting;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive8 initial setting
+///
+/// This structure is used to store information about Overdrive8 initial setting
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLOD8InitSetting
+{
+    int count;
+    int overdrive8Capabilities;
+    ADLOD8SingleInitSetting  od8SettingTable[OD8_COUNT];
+} ADLOD8InitSetting;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive8 current setting
+///
+/// This structure is used to store information about Overdrive8 current setting
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLOD8CurrentSetting
+{
+    int count;
+    int Od8SettingTable[OD8_COUNT];
+} ADLOD8CurrentSetting;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Overdrive8 set setting
+///
+/// This structure is used to store information about Overdrive8 set setting
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLOD8SingleSetSetting
+{
+    int value;
+    int requested;      // 0 - default , 1 - requested
+    int reset;          // 0 - do not reset , 1 - reset setting back to default
+} ADLOD8SingleSetSetting;
+
+typedef struct ADLOD8SetSetting
+{
+    int count;
+    ADLOD8SingleSetSetting  od8SettingTable[OD8_COUNT];
+} ADLOD8SetSetting;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Performance Metrics data
+///
+/// This structure is used to store information about Performance Metrics data output
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLSingleSensorData
+{
+    int supported;
+    int  value;
+} ADLSingleSensorData;
+
+typedef struct ADLPMLogDataOutput
+{
+    int size;
+    ADLSingleSensorData sensors[ADL_PMLOG_MAX_SENSORS];
+}ADLPMLogDataOutput;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about PPLog settings.
+///
+/// This structure is used to store information about PPLog settings.
+/// This structure is used by the ADL2_PPLogSettings_Set() and ADL2_PPLogSettings_Get() functions.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLPPLogSettings
+{
+    int BreakOnAssert;
+    int BreakOnWarn;
+    int LogEnabled;
+    int LogFieldMask;
+    int LogDestinations;
+    int LogSeverityEnabled;
+    int LogSourceMask;
+    int PowerProfilingEnabled;
+    int PowerProfilingTimeInterval;
+}ADLPPLogSettings;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information related Frames Per Second for AC and DC.
+///
+/// This structure is used to store information related AC and DC Frames Per Second settings
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLFPSSettingsOutput
+{
+    /// size
+    int ulSize;
+    /// FPS Monitor is enabled in the AC state if 1
+    int bACFPSEnabled;
+    /// FPS Monitor is enabled in the DC state if 1
+    int bDCFPSEnabled;
+    /// Current Value of FPS Monitor in AC state
+    int ulACFPSCurrent;
+    /// Current Value of FPS Monitor in DC state
+    int ulDCFPSCurrent;
+    /// Maximum FPS Threshold allowed in PPLib for AC
+    int ulACFPSMaximum;
+    /// Minimum FPS Threshold allowed in PPLib for AC
+    int ulACFPSMinimum;
+    /// Maximum FPS Threshold allowed in PPLib for DC
+    int ulDCFPSMaximum;
+    /// Minimum FPS Threshold allowed in PPLib for DC
+    int ulDCFPSMinimum;
+} ADLFPSSettingsOutput;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information related Frames Per Second for AC and DC.
+///
+/// This structure is used to store information related AC and DC Frames Per Second settings
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLFPSSettingsInput
+{
+    /// size
+    int ulSize;
+    /// Settings are for Global FPS (used by CCC)
+    int bGlobalSettings;
+    /// Current Value of FPS Monitor in AC state
+    int ulACFPSCurrent;
+    /// Current Value of FPS Monitor in DC state
+    int ulDCFPSCurrent;
+    /// Reserved
+    int ulReserved[6];
+} ADLFPSSettingsInput;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information related power management logging.
+///
+/// This structure is used to store support information for power management logging.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+enum { ADL_PMLOG_MAX_SUPPORTED_SENSORS = 256 };
+
+typedef struct ADLPMLogSupportInfo
+{
+    /// list of sensors defined by ADL_PMLOG_SENSORS
+    unsigned short usSensors[ADL_PMLOG_MAX_SUPPORTED_SENSORS];
+    /// Reserved
+    int ulReserved[16];
+} ADLPMLogSupportInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information to start power management logging.
+///
+/// This structure is used as input to ADL2_Adapter_PMLog_Start
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLPMLogStartInput
+{
+    /// list of sensors defined by ADL_PMLOG_SENSORS
+    unsigned short usSensors[ADL_PMLOG_MAX_SUPPORTED_SENSORS];
+    /// Sample rate in milliseconds
+    unsigned long ulSampleRate;
+    /// Reserved
+    int ulReserved[15];
+} ADLPMLogStartInput;
+
+typedef struct ADLPMLogData
+{
+    /// Structure version
+    unsigned int ulVersion;
+    /// Current driver sample rate
+    unsigned int ulActiveSampleRate;
+    /// Timestamp of last update
+    unsigned long long ulLastUpdated;
+    /// 2D array of senesor and values
+    unsigned int ulValues[ADL_PMLOG_MAX_SUPPORTED_SENSORS][2];
+    /// Reserved
+    unsigned int ulReserved[256];
+} ADLPMLogData;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information to start power management logging.
+///
+/// This structure is returned as output from ADL2_Adapter_PMLog_Start
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLPMLogStartOutput
+{
+    /// Pointer to memory address containing logging data
+    union
+    {
+        void* pLoggingAddress;
+        unsigned long long ptr_LoggingAddress;
+    };
+    /// Reserved
+    int ulReserved[14];
+} ADLPMLogStartOutput;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information to query limts of power management logging.
+///
+/// This structure is returned as output from ADL2_Adapter_PMLog_SensorLimits_Get
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLPMLogSensorLimits
+{
+    int SensorLimits[ADL_PMLOG_MAX_SENSORS][2]; //index 0: min, 1: max
+} ADLPMLogSensorLimits;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information related RAS Get Error Counts Information
+///
+/// This structure is used to store RAS Error Counts Get Input Information
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLRASGetErrorCountsInput
+{
+    unsigned int                Reserved[16];
+} ADLRASGetErrorCountsInput;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information related RAS Get Error Counts Information
+///
+/// This structure is used to store RAS Error Counts Get Output Information
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLRASGetErrorCountsOutput
+{
+    unsigned int                CorrectedErrors;    // includes both DRAM and SRAM ECC
+    unsigned int                UnCorrectedErrors;  // includes both DRAM and SRAM ECC
+    unsigned int                Reserved[14];
+} ADLRASGetErrorCountsOutput;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information related RAS Get Error Counts Information
+///
+/// This structure is used to store RAS Error Counts Get Information
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLRASGetErrorCounts
+{
+    unsigned int                InputSize;
+    ADLRASGetErrorCountsInput   Input;
+    unsigned int                OutputSize;
+    ADLRASGetErrorCountsOutput  Output;
+} ADLRASGetErrorCounts;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information related RAS Error Counts Reset Information
+///
+/// This structure is used to store RAS Error Counts Reset Input Information
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLRASResetErrorCountsInput
+{
+    unsigned int                Reserved[8];
+} ADLRASResetErrorCountsInput;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information related RAS Error Counts Reset Information
+///
+/// This structure is used to store RAS Error Counts Reset Output Information
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLRASResetErrorCountsOutput
+{
+    unsigned int                Reserved[8];
+} ADLRASResetErrorCountsOutput;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information related RAS Error Counts Reset Information
+///
+/// This structure is used to store RAS Error Counts Reset Information
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLRASResetErrorCounts
+{
+    unsigned int                    InputSize;
+    ADLRASResetErrorCountsInput     Input;
+    unsigned int                    OutputSize;
+    ADLRASResetErrorCountsOutput    Output;
+} ADLRASResetErrorCounts;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information related RAS Error Injection information
+///
+/// This structure is used to store RAS Error Injection input information
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLRASErrorInjectonInput
+{
+    unsigned long long Address;
+    ADL_RAS_INJECTION_METHOD Value;
+    ADL_RAS_BLOCK_ID BlockId;
+    ADL_RAS_ERROR_TYPE InjectErrorType;
+    ADL_MEM_SUB_BLOCK_ID SubBlockIndex;
+    unsigned int padding[9];
+} ADLRASErrorInjectonInput;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information related RAS Error Injection information
+///
+/// This structure is used to store RAS Error Injection output information
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLRASErrorInjectionOutput
+{
+    unsigned int ErrorInjectionStatus;
+    unsigned int padding[15];
+} ADLRASErrorInjectionOutput;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information related RAS Error Injection information
+///
+/// This structure is used to store RAS Error Injection information
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLRASErrorInjection
+{
+    unsigned int                           InputSize;
+    ADLRASErrorInjectonInput               Input;
+    unsigned int                           OutputSize;
+    ADLRASErrorInjectionOutput             Output;
+} ADLRASErrorInjection;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about an application
+///
+/// This structure is used to store basic information of a recently ran or currently running application
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLSGApplicationInfo
+{
+    /// Application file name
+    wchar_t strFileName[ADL_MAX_PATH];
+    /// Application file path
+    wchar_t strFilePath[ADL_MAX_PATH];
+    /// Application version
+    wchar_t strVersion[ADL_MAX_PATH];
+    /// Timestamp at which application has run
+    long long int timeStamp;
+    /// Holds whether the applicaition profile exists or not
+    unsigned int iProfileExists;
+    /// The GPU on which application runs
+    unsigned int iGPUAffinity;
+    /// The BDF of the GPU on which application runs
+    ADLBdf GPUBdf;
+} ADLSGApplicationInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information related Frames Per Second for AC and DC.
+///
+/// This structure is used to store information related AC and DC Frames Per Second settings
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+enum { ADLPreFlipPostProcessingInfoInvalidLUTIndex = 0xFFFFFFFF };
+
+enum ADLPreFlipPostProcessingLUTAlgorithm
+{
+    ADLPreFlipPostProcessingLUTAlgorithm_Default = 0,
+    ADLPreFlipPostProcessingLUTAlgorithm_Full,
+    ADLPreFlipPostProcessingLUTAlgorithm_Approximation
+};
+
+typedef struct ADLPreFlipPostProcessingInfo
+{
+    /// size
+    int ulSize;
+    /// Current active state
+    int bEnabled;
+    /// Current selected LUT index.  0xFFFFFFF returned if nothing selected.
+    int ulSelectedLUTIndex;
+    /// Current selected LUT Algorithm
+    int ulSelectedLUTAlgorithm;
+    /// Reserved
+    int ulReserved[12];
+} ADLPreFlipPostProcessingInfo;
+
+typedef struct ADL_ERROR_REASON
+{
+    int boost; //ON, when boost is Enabled
+    int delag; //ON, when delag is Enabled
+    int chill; //ON, when chill is Enabled
+    int proVsr; //ON, when proVsr is Enabled
+}ADL_ERROR_REASON;
+
+typedef struct ADL_ERROR_REASON2
+{
+    int boost; //ON, when boost is Enabled
+    int delag; //ON, when delag is Enabled
+    int chill; //ON, when chill is Enabled
+    int proVsr; //ON, when proVsr is Enabled
+    int upscale; //ON, when RSR is Enabled
+}ADL_ERROR_REASON2;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about DELAG Settings change reason
+///
+///  Elements of DELAG settings changed reason.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_DELAG_NOTFICATION_REASON
+{
+	int HotkeyChanged; //Set when Hotkey value is changed
+	int GlobalEnableChanged; //Set when Global enable value is changed
+	int GlobalLimitFPSChanged; //Set when Global enable value is changed
+}ADL_DELAG_NOTFICATION_REASON;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about DELAG Settings
+///
+///  Elements of DELAG settings.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_DELAG_SETTINGS
+{
+	int Hotkey; // Hotkey value
+	int GlobalEnable; //Global enable value
+	int GlobalLimitFPS; //Global Limit FPS
+	int GlobalLimitFPS_MinLimit; //Gloabl Limit FPS slider min limit value
+	int GlobalLimitFPS_MaxLimit; //Gloabl Limit FPS slider max limit value
+	int GlobalLimitFPS_Step; //Gloabl Limit FPS step  value
+}ADL_DELAG_SETTINGS;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about BOOST Settings change reason
+///
+///  Elements of BOOST settings changed reason.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_BOOST_NOTFICATION_REASON
+{
+	int HotkeyChanged; //Set when Hotkey value is changed
+	int GlobalEnableChanged; //Set when Global enable value is changed
+	int GlobalMinResChanged; //Set when Global min resolution value is changed
+}ADL_BOOST_NOTFICATION_REASON;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about BOOST Settings
+///
+///  Elements of BOOST settings.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_BOOST_SETTINGS
+{
+	int Hotkey; // Hotkey value
+	int GlobalEnable; //Global enable value
+	int GlobalMinRes; //Gloabl Min Resolution value
+	int GlobalMinRes_MinLimit; //Gloabl Min Resolution slider min limit value
+	int GlobalMinRes_MaxLimit; //Gloabl Min Resolution slider max limit value
+	int GlobalMinRes_Step; //Gloabl Min Resolution step  value
+}ADL_BOOST_SETTINGS;
+
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about ProVSR Settings change reason
+///
+///  Elements of ProVSR settings changed reason.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_PROVSR_NOTFICATION_REASON
+{
+	int HotkeyChanged; //Set when Hotkey value is changed
+	int GlobalEnableChanged; //Set when Global enable value is changed
+}ADL_PROVSR_NOTFICATION_REASON;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Pro VSR Settings
+///
+///  Elements of ProVSR settings.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_PROVSR_SETTINGS
+{
+	int Hotkey; // Hotkey value
+	int GlobalEnable; //Global enable value
+}ADL_PROVSR_SETTINGS;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about Image Boost(OGL) Settings change reason
+///
+///  Elements of Image Boost settings changed reason.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_IMAGE_BOOST_NOTFICATION_REASON
+{
+    int HotkeyChanged; //Set when Hotkey value is changed
+    int GlobalEnableChanged; //Set when Global enable value is changed
+}ADL_IMAGE_BOOST_NOTFICATION_REASON;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about OGL IMAGE BOOST Settings
+///
+///  Elements of OGL IMAGE BOOST settings.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_IMAGE_BOOST_SETTINGS
+{
+    int Hotkey; // Hotkey value
+    int GlobalEnable; //Global enable value
+}ADL_IMAGE_BOOST_SETTINGS;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about RIS Settings change reason
+///
+///  Elements of RIS settings changed reason.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_RIS_NOTFICATION_REASON
+{
+	unsigned int GlobalEnableChanged; //Set when Global enable value is changed
+	unsigned int GlobalSharpeningDegreeChanged; //Set when Global sharpening Degree value is changed
+}ADL_RIS_NOTFICATION_REASON;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about RIS Settings
+///
+///  Elements of RIS settings.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_RIS_SETTINGS
+{
+	int GlobalEnable; //Global enable value
+	int GlobalSharpeningDegree; //Global sharpening value
+	int GlobalSharpeningDegree_MinLimit; //Gloabl sharpening slider min limit value
+	int GlobalSharpeningDegree_MaxLimit; //Gloabl sharpening slider max limit value
+	int GlobalSharpeningDegree_Step; //Gloabl sharpening step  value
+}ADL_RIS_SETTINGS;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about CHILL Settings change reason
+///
+///  Elements of Chiil settings changed reason.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_CHILL_NOTFICATION_REASON
+{
+	int HotkeyChanged; //Set when Hotkey value is changed
+	int GlobalEnableChanged; //Set when Global enable value is changed
+	int GlobalMinFPSChanged; //Set when Global min FPS value is changed
+	int GlobalMaxFPSChanged; //Set when Global max FPS value is changed
+}ADL_CHILL_NOTFICATION_REASON;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about CHILL Settings
+///
+///  Elements of Chill settings.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_CHILL_SETTINGS
+{
+	int Hotkey; // Hotkey value
+	int GlobalEnable; //Global enable value
+	int GlobalMinFPS; //Global Min FPS value
+	int GlobalMaxFPS; //Global Max FPS value
+	int GlobalFPS_MinLimit; //Gloabl FPS slider min limit value
+	int GlobalFPS_MaxLimit; //Gloabl FPS slider max limit value
+	int GlobalFPS_Step; //Gloabl FPS Slider step  value
+}ADL_CHILL_SETTINGS;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about DRIVERUPSCALE Settings change reason
+///
+///  Elements of DRIVERUPSCALE settings changed reason.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_DRIVERUPSCALE_NOTFICATION_REASON
+{
+    int ModeOverrideEnabledChanged;     //Set when Global min resolution value is changed
+    int GlobalEnabledChanged;           //Set when Global enable value is changed
+}ADL_DRIVERUPSCALE_NOTFICATION_REASON;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about DRIVERUPSCALE Settings
+///
+///  Elements of DRIVERUPSCALE settings.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_DRIVERUPSCALE_SETTINGS
+{
+    int ModeOverrideEnabled;
+    int GlobalEnabled;
+}ADL_DRIVERUPSCALE_SETTINGS;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief  Structure Containing R G B values for Radeon USB LED Bar
+///
+/// Elements of RGB Values.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_RADEON_LED_COLOR_CONFIG
+{
+	unsigned short R : 8; // Red Value
+	unsigned short G : 8; // Green Value
+	unsigned short B : 8; // Blue Value
+}ADL_RADEON_LED_COLOR_CONFIG;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure Containing All Generic LED configuration for user requested LED pattern. The driver will apply the confgiuration as requested
+///
+///  Elements of Radeon USB LED configuration.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_RADEON_LED_PATTERN_CONFIG_GENERIC
+{
+	short brightness : 8; // Brightness of LED
+	short speed : 8; // Speed of LED pattern
+	bool directionCounterClockWise; //Direction of LED Pattern
+	ADL_RADEON_LED_COLOR_CONFIG colorConfig; // RGB value of LED pattern
+	char morseCodeText[ADL_RADEON_LED_MAX_MORSE_CODE]; // Morse Code user input for Morse Code LED pattern
+	char morseCodeTextOutPut[ADL_RADEON_LED_MAX_MORSE_CODE]; // Driver set output representation of Morse Code
+	int  morseCodeTextOutPutLen; // Length of Morse Code output
+}ADL_RADEON_LED_PATTERN_CONFIG_GENERIC;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure Containing All custom grid pattern LED configuration for user requested LED grid pattern. The driver will apply the confgiuration as requested
+///
+///  Elements of Radeon USB LED custom grid configuration.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_RADEON_LED_CUSTOM_LED_CONFIG
+{
+	short brightness : 8; // Brightness of LED
+	ADL_RADEON_LED_COLOR_CONFIG colorConfig[ADL_RADEON_LED_MAX_LED_ROW_ON_GRID][ADL_RADEON_LED_MAX_LED_COLUMN_ON_GRID]; // Full grid array representation of Radeon LED to be populated by user
+}ADL_RADEON_LED_CUSTOM_GRID_LED_CONFIG;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure Containing All Radeon USB LED requests and controls.
+///
+/// Elements of Radeon USB LED Controls.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_RADEON_LED_PATTERN_CONFIG
+{
+	ADL_RADEON_USB_LED_BAR_CONTROLS control; //Requested LED pattern
+
+    union
+    {
+		ADL_RADEON_LED_PATTERN_CONFIG_GENERIC genericPararmeters; //Requested pattern configuration settings
+		ADL_RADEON_LED_CUSTOM_GRID_LED_CONFIG customGridConfig; //Requested custom grid configuration settings
+    };
+}ADL_RADEON_LED_PATTERN_CONFIG;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about the graphics adapter with extended caps
+///
+/// This structure is used to store various information about the graphics adapter.  This
+/// information can be returned to the user. Alternatively, it can be used to access various driver calls to set
+/// or fetch various settings upon the user's request.
+/// This AdapterInfoX2 struct extends the AdapterInfo struct in adl_structures.h
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct AdapterInfoX2
+{
+    /// \ALL_STRUCT_MEM
+
+    /// Size of the structure.
+    int iSize;
+    /// The ADL index handle. One GPU may be associated with one or two index handles
+    int iAdapterIndex;
+    /// The unique device ID associated with this adapter.
+    char strUDID[ADL_MAX_PATH];
+    /// The BUS number associated with this adapter.
+    int iBusNumber;
+    /// The driver number associated with this adapter.
+    int iDeviceNumber;
+    /// The function number.
+    int iFunctionNumber;
+    /// The vendor ID associated with this adapter.
+    int iVendorID;
+    /// Adapter name.
+    char strAdapterName[ADL_MAX_PATH];
+    /// Display name. For example, "\\\\Display0"
+    char strDisplayName[ADL_MAX_PATH];
+    /// Present or not; 1 if present and 0 if not present.It the logical adapter is present, the display name such as \\\\.\\Display1 can be found from OS
+    int iPresent;
+    /// Exist or not; 1 is exist and 0 is not present.
+    int iExist;
+    /// Driver registry path.
+    char strDriverPath[ADL_MAX_PATH];
+    /// Driver registry path Ext for.
+    char strDriverPathExt[ADL_MAX_PATH];
+    /// PNP string from Windows.
+    char strPNPString[ADL_MAX_PATH];
+    /// It is generated from EnumDisplayDevices.
+    int iOSDisplayIndex;
+    /// The bit mask identifies the adapter info
+    int iInfoMask;
+    /// The bit identifies the adapter info \ref define_adapter_info
+    int iInfoValue;
+} AdapterInfoX2, *LPAdapterInfoX2;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about driver  gamut space , whether it is related to source or to destination, overlay or graphics
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef  struct ADLGamutReference
+{
+    /// mask whether it is related to source or to destination, overlay or graphics
+    int      iGamutRef;
+}ADLGamutReference;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about driver supported gamut spaces , capability method
+///
+/// This structure is used to get driver all supported gamut spaces
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLGamutInfo
+{
+    ///Any combination of following ADL_GAMUT_SPACE_CCIR_709 - ADL_GAMUT_SPACE_CUSTOM
+    int    SupportedGamutSpace;
+
+    ///Any combination of following ADL_WHITE_POINT_5000K - ADL_WHITE_POINT_CUSTOM
+    int    SupportedWhitePoint;
+} ADLGamutInfo;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about driver point coordinates
+///
+/// This structure is used to store the driver point coodinates for gamut and white point
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLPoint
+{
+    /// x coordinate
+    int          iX;
+    /// y coordinate
+    int          iY;
+} ADLPoint;
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about driver supported gamut coordinates
+///
+/// This structure is used to store the driver supported supported gamut coordinates
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLGamutCoordinates
+{
+    /// red channel chromasity coordinate
+    ADLPoint      Red;
+    /// green channel chromasity coordinate
+    ADLPoint      Green;
+    /// blue channel chromasity coordinate
+    ADLPoint      Blue;
+} ADLGamutCoordinates;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about driver current gamut space , parent struct for ADLGamutCoordinates and ADLWhitePoint
+/// This structure is used to get/set driver supported gamut space
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef  struct ADLGamutData
+{
+    ///used as mask and could be 4 options
+    ///BIT_0 If flag ADL_GAMUT_REFERENCE_SOURCE is asserted set operation is related to gamut source ,
+    ///if not gamut destination
+    ///BIT_1 If flag ADL_GAMUT_GAMUT_VIDEO_CONTENT is asserted
+    ///BIT_2,BIT_3 used as mask and could be 4 options custom (2) + predefined (2)
+    ///0.  Gamut predefined,        white point predefined -> 0                | 0
+    ///1.  Gamut predefined,        white point custom     -> 0                | ADL_CUSTOM_WHITE_POINT
+    ///2.  White point predefined,  gamut custom           -> 0                | ADL_CUSTOM_GAMUT
+    ///3.  White point custom,      gamut custom           -> ADL_CUSTOM_GAMUT | ADL_CUSTOM_WHITE_POINT
+    int        iFeature;
+
+    ///one of ADL_GAMUT_SPACE_CCIR_709 - ADL_GAMUT_SPACE_CIE_RGB
+    int         iPredefinedGamut;
+
+    ///one of ADL_WHITE_POINT_5000K - ADL_WHITE_POINT_9300K
+    int         iPredefinedWhitePoint;
+
+    ///valid when in mask avails ADL_CUSTOM_WHITE_POINT
+    ADLPoint             CustomWhitePoint;
+
+    ///valid when in mask avails ADL_CUSTOM_GAMUT
+    ADLGamutCoordinates  CustomGamut;
+} ADLGamutData;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing detailed timing parameters.
+///
+/// This structure is used to store the detailed timing parameters.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDetailedTimingX2
+{
+    /// Size of the structure.
+    int   iSize;
+    /// Timing flags. \ref define_detailed_timing_flags
+    int sTimingFlags;
+    /// Total width (columns).
+    int sHTotal;
+    /// Displayed width.
+    int sHDisplay;
+    /// Horizontal sync signal offset.
+    int sHSyncStart;
+    /// Horizontal sync signal width.
+    int sHSyncWidth;
+    /// Total height (rows).
+    int sVTotal;
+    /// Displayed height.
+    int sVDisplay;
+    /// Vertical sync signal offset.
+    int sVSyncStart;
+    /// Vertical sync signal width.
+    int sVSyncWidth;
+    /// Pixel clock value.
+    int sPixelClock;
+    /// Overscan right.
+    short sHOverscanRight;
+    /// Overscan left.
+    short sHOverscanLeft;
+    /// Overscan bottom.
+    short sVOverscanBottom;
+    /// Overscan top.
+    short sVOverscanTop;
+    short sOverscan8B;
+    short sOverscanGR;
+} ADLDetailedTimingX2;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing display mode information.
+///
+/// This structure is used to store the display mode information.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLDisplayModeInfoX2
+{
+    /// Timing standard of the current mode. \ref define_modetiming_standard
+    int  iTimingStandard;
+    /// Applicable timing standards for the current mode.
+    int  iPossibleStandard;
+    /// Refresh rate factor.
+    int  iRefreshRate;
+    /// Num of pixels in a row.
+    int  iPelsWidth;
+    /// Num of pixels in a column.
+    int  iPelsHeight;
+    /// Detailed timing parameters.
+    ADLDetailedTimingX2  sDetailedTiming;
+} ADLDisplayModeInfoX2;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about I2C.
+///
+/// This structure is used to store the I2C information for the current adapter.
+/// This structure is used by \ref ADL_Display_WriteAndReadI2CLargePayload
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLI2CLargePayload
+{
+    /// Size of the structure
+    int iSize;
+    /// Numerical value representing hardware I2C.
+    int iLine;
+    /// The 7-bit I2C slave device address.
+    int iAddress;
+    /// The offset of the data from the address.
+    int iOffset;
+    /// Read from or write to slave device. \ref ADL_DL_I2C_ACTIONREAD or \ref ADL_DL_I2C_ACTIONWRITE
+    int iAction;
+    /// I2C clock speed in KHz.
+    int iSpeed;
+    /// I2C option flags.  \ref define_ADLI2CLargePayload
+    int iFlags;
+    /// A numerical value representing the number of bytes to be sent or received on the I2C bus.
+    int iDataSize;
+    /// Address of the characters which are to be sent or received on the I2C bus.
+    char *pcData;
+} ADLI2CLargePayload;
+
+/// Size in bytes of the Feature Name
+#define ADL_FEATURE_NAME_LENGTH 	16
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing the Multimedia Feature Name
+///
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLFeatureName
+{
+    /// The Feature Name
+    char FeatureName[ADL_FEATURE_NAME_LENGTH];
+}	ADLFeatureName, *LPADLFeatureName;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about MM Feature Capabilities.
+///
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLFeatureCaps
+{
+    /// The Feature Name
+    ADLFeatureName	Name;
+    //	char strFeatureName[ADL_FEATURE_NAME_LENGTH];
+
+    /// Group ID. All Features in the same group are shown sequentially in the same UI Page.
+    int  iGroupID;
+
+    /// Visual ID. Places one or more features in a Group Box. If zero, no Group Box is added.
+    int  iVisualID;
+
+    /// Page ID. All Features with the same Page ID value are shown together on the same UI page.
+    int iPageID;
+
+    /// Feature Property Mask. Indicates which are the valid bits for iFeatureProperties.
+    int iFeatureMask;
+
+    /// Feature Property Values. See definitions for ADL_FEATURE_PROPERTIES_XXX
+    int  iFeatureProperties;
+
+    /// Apperance of the User-Controlled Boolean.
+    int  iControlType;
+
+    /// Style of the User-Controlled Boolean.
+    int  iControlStyle;
+
+    /// Apperance of the Adjustment Controls.
+    int  iAdjustmentType;
+
+    /// Style of the Adjustment Controls.
+    int  iAdjustmentStyle;
+
+    /// Default user-controlled boolean value. Valid only if ADLFeatureCaps supports user-controlled boolean.
+    int bDefault;
+
+    /// Minimum integer value. Valid only if ADLFeatureCaps indicates support for integers.
+    int iMin;
+
+    /// Maximum integer value. Valid only if ADLFeatureCaps indicates support for integers.
+    int iMax;
+
+    /// Step integer value. Valid only if ADLFeatureCaps indicates support for integers.
+    int iStep;
+
+    /// Default integer value. Valid only if ADLFeatureCaps indicates support for integers.
+    int iDefault;
+
+    /// Minimum float value. Valid only if ADLFeatureCaps indicates support for floats.
+    float fMin;
+
+    /// Maximum float value. Valid only if ADLFeatureCaps indicates support for floats.
+    float fMax;
+
+    /// Step float value. Valid only if ADLFeatureCaps indicates support for floats.
+    float fStep;
+
+    /// Default float value. Valid only if ADLFeatureCaps indicates support for floats.
+    float fDefault;
+
+    /// The Mask for available bits for enumerated values.(If ADLFeatureCaps supports ENUM values)
+    int EnumMask;
+} ADLFeatureCaps, *LPADLFeatureCaps;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about MM Feature Values.
+///
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLFeatureValues
+{
+    /// The Feature Name
+    ADLFeatureName	Name;
+    //	char strFeatureName[ADL_FEATURE_NAME_LENGTH];
+
+    /// User controlled Boolean current value. Valid only if ADLFeatureCaps supports Boolean.
+    int bCurrent;
+
+    /// Current integer value. Valid only if ADLFeatureCaps indicates support for integers.
+    int iCurrent;
+
+    /// Current float value. Valid only if ADLFeatureCaps indicates support for floats.
+    float fCurrent;
+
+    /// The States for the available bits for enumerated values.
+    int EnumStates;
+} ADLFeatureValues, *LPADLFeatureValues;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing HDCP Settings info
+///
+/// This structure is used to store the HDCP settings of a
+/// display
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLHDCPSettings
+{
+	int iHDCPProtectionVersion; // Version, starting from 1
+	int iHDCPCaps; //Caps used to ensure at least one protection scheme is supported, 1 is HDCP1X and 2 is HDCP22
+	int iAllowAll; //Allow all is true, disable all is false
+	int iHDCPVale;
+	int iHDCPMask;
+} ADLHDCPSettings;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing Mantle App  info
+///
+/// This structure is used to store the Mantle Driver information
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef struct ADLMantleAppInfo
+{
+	/// mantle api version
+	int   apiVersion;
+	/// mantle driver version
+	long   driverVersion;
+	/// mantle vendroe id
+	long   vendorId;
+	/// mantle device id
+	long   deviceId;
+	/// mantle gpu type;
+	int     gpuType;
+	/// gpu name
+	char     gpuName[256];
+	/// mem size
+	int     maxMemRefsPerSubmission;
+	/// virtual mem size
+	long long virtualMemPageSize;
+	/// mem update
+	long long maxInlineMemoryUpdateSize;
+	/// bound descriptot
+	long     maxBoundDescriptorSets;
+	/// thread group size
+	long     maxThreadGroupSize;
+	/// time stamp frequency
+	long  long timestampFrequency;
+	/// color target
+	long     multiColorTargetClears;
+}ADLMantleAppInfo, *LPADLMantleAppInfo;
+
+////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about SDIData
+///This structure is used to store information about the state of the SDI whether it is on
+///or off and the current size of the segment or aperture size.
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLSDIData
+{
+	/// The SDI state, ADL_SDI_ON or ADL_SDI_OFF, for the current SDI mode
+	int iSDIState;
+	/// Size of the memory segment for SDI (in MB).
+	int iSizeofSDISegment;
+} ADLSDIData, *LPADLSDIData;
+
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about FRTCPRO Settings
+///
+///  Elements of FRTCPRO settings.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_FRTCPRO_Settings
+{
+    int DefaultState;              //The default status for FRTC pro
+    int CurrentState;              //The current enable/disable status for FRTC pro
+    unsigned int DefaultValue;     //The default FPS value for FRTC pro.
+    unsigned int CurrentValue;      //The current FPS value for FRTC pro.
+    unsigned int maxSupportedFps;      //The max value for FRTC pro.
+    unsigned int minSupportedFps;      //The min value for FRTC pro.
+}ADL_FRTCPRO_Settings, *LPADLFRTCProSettings;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information about FRTCPRO Settings changed reason
+///
+///  Reason of FRTCPRO changed.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_FRTCPRO_CHANGED_REASON
+{
+    int StateChanged;               // FRTCPro state changed
+    int ValueChanged;               // FRTCPro value changed
+}ADL_FRTCPRO_CHANGED_REASON;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure containing the display mode definition used per controller.
+///
+/// This structure is used to store the display mode definition used per controller.
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADL_DL_DISPLAY_MODE
+{
+    int  iPelsHeight;                      // Vertical resolution (in pixels).
+    int  iPelsWidth;                       // Horizontal resolution (in pixels).
+    int  iBitsPerPel;                      // Color depth.
+    int  iDisplayFrequency;                // Refresh rate.
+} ADL_DL_DISPLAY_MODE;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///\brief Structure containing information related DCE support
+///
+/// This structure is used to store a bit vector of possible DCE support
+///
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef union _ADLDCESupport
+{
+    struct
+    {
+        unsigned int PrePhasis : 1;
+        unsigned int voltageSwing : 1;
+        unsigned int reserved : 30;
+    }bits;
+    unsigned int u32All;
+}ADLDCESupport;
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+/// \brief Structure for Smart shift 2.0 settings
+///
+/// This structure is used to return the smart shift settings
+/// \nosubgrouping
+////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct ADLSmartShiftSettings
+{
+	int iMinRange;
+	int iMaxRange;
+	int iDefaultMode; //Refer to CWDDEPM_ODN_CONTROL_TYPE
+	int iDefaultValue;
+	int iCurrentMode;
+	int iCurrentValue;
+    int iFlags; //refer to define_smartshift_bits
+}ADLSmartShiftSettings, *LPADLSmartShiftSettings;
+#endif /* ADL_STRUCTURES_H_ */
diff --git a/dlls/atiadlxx/atiadlxx.spec b/dlls/atiadlxx/atiadlxx.spec
index 1e447f38ded..6b4d04d9eb9 100644
--- a/dlls/atiadlxx/atiadlxx.spec
+++ b/dlls/atiadlxx/atiadlxx.spec
@@ -10,17 +10,22 @@
 @ stub ADL2_AdapterLimitation_Caps
 @ stub ADL2_AdapterX2_Caps
 @ stub ADL2_Adapter_AMDAndNonAMDDIsplayClone_Get
-@ stub ADL2_Adapter_ASICFamilyType_Get
+@ cdecl -arch=i386 ADL2_Adapter_ASICFamilyType_Get(ptr long ptr ptr)
+@ stdcall -arch=!i386 ADL2_Adapter_ASICFamilyType_Get(ptr long ptr ptr)
 @ stub ADL2_Adapter_ASICInfo_Get
 @ stub ADL2_Adapter_Accessibility_Get
 @ stub ADL2_Adapter_AceDefaults_Restore
-@ stub ADL2_Adapter_Active_Get
+@ cdecl -arch=i386 ADL2_Adapter_Active_Get(ptr long ptr)
+@ stdcall -arch=!i386 ADL2_Adapter_Active_Get(ptr long ptr)
 @ stub ADL2_Adapter_Active_Set
 @ stub ADL2_Adapter_Active_SetPrefer
-@ stub ADL2_Adapter_AdapterInfoX2_Get
+@ cdecl -arch=i386 ADL2_Adapter_AdapterInfoX2_Get(ptr ptr)
+@ stdcall -arch=!i386 ADL2_Adapter_AdapterInfoX2_Get(ptr ptr)
 @ stub ADL2_Adapter_AdapterInfoX3_Get
-@ stub ADL2_Adapter_AdapterInfoX4_Get
-@ stub ADL2_Adapter_AdapterInfo_Get
+@ cdecl -arch=i386 ADL2_Adapter_AdapterInfoX4_Get(ptr long ptr ptr)
+@ stdcall -arch=!i386 ADL2_Adapter_AdapterInfoX4_Get(ptr long ptr ptr)
+@ cdecl -arch=i386 ADL2_Adapter_AdapterInfo_Get(ptr ptr long)
+@ stdcall -arch=!i386 ADL2_Adapter_AdapterInfo_Get(ptr ptr long)
 @ stub ADL2_Adapter_AdapterList_Disable
 @ stub ADL2_Adapter_AdapterLocationPath_Get
 @ stub ADL2_Adapter_Aspects_Get
@@ -49,7 +54,8 @@
 @ stub ADL2_Adapter_CrossdisplayInfo_Get
 @ stub ADL2_Adapter_CrossdisplayInfo_Set
 @ stub ADL2_Adapter_CrossfireX2_Get
-@ stub ADL2_Adapter_Crossfire_Caps
+@ cdecl -arch=i386 ADL2_Adapter_Crossfire_Caps(ptr long ptr ptr ptr)
+@ stdcall -arch=!i386 ADL2_Adapter_Crossfire_Caps(ptr long ptr ptr ptr)
 @ stub ADL2_Adapter_Crossfire_Get
 @ stub ADL2_Adapter_Crossfire_Set
 @ stub ADL2_Adapter_DefaultAudioChannelTable_Load
@@ -82,7 +88,8 @@
 @ stub ADL2_Adapter_FrameMetrics_Stop
 @ stub ADL2_Adapter_Gamma_Get
 @ stub ADL2_Adapter_Gamma_Set
-@ stub ADL2_Adapter_Graphic_Core_Info_Get
+@ cdecl -arch=i386 ADL2_Adapter_Graphic_Core_Info_Get(ptr long ptr)
+@ stdcall -arch=!i386 ADL2_Adapter_Graphic_Core_Info_Get(ptr long ptr)
 @ stub ADL2_Adapter_HBC_Caps
 @ stub ADL2_Adapter_HBM_ECC_UC_Check
 @ stub ADL2_Adapter_Headless_Get
@@ -93,14 +100,17 @@
 @ stub ADL2_Adapter_LocalDisplayState_Get
 @ stub ADL2_Adapter_MVPU_Set
 @ stub ADL2_Adapter_MaxCursorSize_Get
-@ stub ADL2_Adapter_MemoryInfo2_Get
-@ stub ADL2_Adapter_MemoryInfo_Get
+@ cdecl -arch=i386 ADL2_Adapter_MemoryInfo2_Get(ptr long ptr)
+@ stdcall -arch=!i386 ADL2_Adapter_MemoryInfo2_Get(ptr long ptr)
+@ cdecl -arch=i386 ADL2_Adapter_MemoryInfo_Get(ptr long ptr)
+@ stdcall -arch=!i386 ADL2_Adapter_MemoryInfo_Get(ptr long ptr)
 @ stub ADL2_Adapter_MirabilisSupport_Get
 @ stub ADL2_Adapter_ModeSwitch
 @ stub ADL2_Adapter_ModeTimingOverride_Caps
 @ stub ADL2_Adapter_Modes_ReEnumerate
 @ stub ADL2_Adapter_NumberOfActivatableSources_Get
-@ stdcall ADL2_Adapter_NumberOfAdapters_Get(ptr ptr)
+@ cdecl -arch=i386 ADL2_Adapter_NumberOfAdapters_Get(ptr ptr)
+@ stdcall -arch=!i386 ADL2_Adapter_NumberOfAdapters_Get(ptr ptr)
 @ stub ADL2_Adapter_ObservedClockInfo_Get
 @ stub ADL2_Adapter_PMLog_Start
 @ stub ADL2_Adapter_PMLog_Stop
@@ -249,7 +259,8 @@
 @ stub ADL2_Display_DCE_Get
 @ stub ADL2_Display_DCE_Set
 @ stub ADL2_Display_DDCBlockAccess_Get
-@ stub ADL2_Display_DDCInfo2_Get
+@ cdecl -arch=i386 ADL2_Display_DDCInfo2_Get(ptr long long ptr)
+@ stdcall -arch=!i386 ADL2_Display_DDCInfo2_Get(ptr long long ptr)
 @ stub ADL2_Display_DDCInfo_Get
 @ stub ADL2_Display_Deflicker_Get
 @ stub ADL2_Display_Deflicker_Set
@@ -257,9 +268,11 @@
 @ stub ADL2_Display_DisplayContent_Cap
 @ stub ADL2_Display_DisplayContent_Get
 @ stub ADL2_Display_DisplayContent_Set
-@ stub ADL2_Display_DisplayInfo_Get
+@ cdecl -arch=i386 ADL2_Display_DisplayInfo_Get(ptr long ptr ptr long)
+@ stdcall -arch=!i386 ADL2_Display_DisplayInfo_Get(ptr long ptr ptr long)
 @ stub ADL2_Display_DisplayMapConfigX2_Set
-@ stub ADL2_Display_DisplayMapConfig_Get
+@ cdecl -arch=i386 ADL2_Display_DisplayMapConfig_Get(ptr long ptr ptr ptr ptr long)
+@ stdcall -arch=!i386 ADL2_Display_DisplayMapConfig_Get(ptr long ptr ptr ptr ptr long)
 @ stub ADL2_Display_DisplayMapConfig_PossibleAddAndRemove
 @ stub ADL2_Display_DisplayMapConfig_Set
 @ stub ADL2_Display_DisplayMapConfig_Validate
@@ -270,7 +283,8 @@
 @ stub ADL2_Display_DpMstInfo_Get
 @ stub ADL2_Display_DummyVirtual_Destroy
 @ stub ADL2_Display_DummyVirtual_Get
-@ stub ADL2_Display_EdidData_Get
+@ cdecl -arch=i386 ADL2_Display_EdidData_Get(ptr long long ptr)
+@ stdcall -arch=!i386 ADL2_Display_EdidData_Get(ptr long long ptr)
 @ stub ADL2_Display_EdidData_Set
 @ stub ADL2_Display_EnumDisplays_Get
 @ stub ADL2_Display_FilterSVideo_Get
@@ -281,7 +295,8 @@
 @ stub ADL2_Display_FormatsOverride_Set
 @ stub ADL2_Display_FreeSyncState_Get
 @ stub ADL2_Display_FreeSyncState_Set
-@ stub ADL2_Display_FreeSync_Cap
+@ cdecl -arch=i386 ADL2_Display_FreeSync_Cap(ptr long long ptr)
+@ stdcall -arch=!i386 ADL2_Display_FreeSync_Cap(ptr long long ptr)
 @ stub ADL2_Display_GamutMapping_Get
 @ stub ADL2_Display_GamutMapping_Reset
 @ stub ADL2_Display_GamutMapping_Set
@@ -315,7 +330,8 @@
 @ stub ADL2_Display_ModeTimingOverride_Delete
 @ stub ADL2_Display_ModeTimingOverride_Get
 @ stub ADL2_Display_ModeTimingOverride_Set
-@ stub ADL2_Display_Modes_Get
+@ cdecl -arch=i386 ADL2_Display_Modes_Get(ptr long long ptr ptr)
+@ stdcall -arch=!i386 ADL2_Display_Modes_Get(ptr long long ptr ptr)
 @ stub ADL2_Display_Modes_Set
 @ stub ADL2_Display_Modes_X2_Get
 @ stub ADL2_Display_MonitorPowerState_Set
@@ -369,14 +385,16 @@
 @ stub ADL2_Display_SLSMapConfigX2_Get
 @ stub ADL2_Display_SLSMapConfig_Create
 @ stub ADL2_Display_SLSMapConfig_Delete
-@ stub ADL2_Display_SLSMapConfig_Get
+@ cdecl -arch=i386 ADL2_Display_SLSMapConfig_Get(ptr long long ptr ptr ptr ptr ptr ptr ptr ptr ptr ptr ptr long)
+@ stdcall -arch=!i386 ADL2_Display_SLSMapConfig_Get(ptr long long ptr ptr ptr ptr ptr ptr ptr ptr ptr ptr ptr long)
 @ stub ADL2_Display_SLSMapConfig_ImageCropType_Set
 @ stub ADL2_Display_SLSMapConfig_Rearrange
 @ stub ADL2_Display_SLSMapConfig_SetState
 @ stub ADL2_Display_SLSMapConfig_SupportedImageCropType_Get
 @ stub ADL2_Display_SLSMapConfig_Valid
 @ stub ADL2_Display_SLSMapIndexList_Get
-@ stub ADL2_Display_SLSMapIndex_Get
+@ cdecl -arch=i386 ADL2_Display_SLSMapIndex_Get(ptr long long ptr ptr)
+@ stdcall -arch=!i386 ADL2_Display_SLSMapIndex_Get(ptr long long ptr ptr)
 @ stub ADL2_Display_SLSMiddleMode_Get
 @ stub ADL2_Display_SLSMiddleMode_Set
 @ stub ADL2_Display_SLSRecords_Get
@@ -387,7 +405,8 @@
 @ stub ADL2_Display_Size_Get
 @ stub ADL2_Display_Size_Set
 @ stub ADL2_Display_SourceContentAttribute_Get
-@ stub ADL2_Display_SourceContentAttribute_Set
+@ cdecl -arch=i386 ADL2_Display_SourceContentAttribute_Set(ptr long long ptr)
+@ stdcall -arch=!i386 ADL2_Display_SourceContentAttribute_Set(ptr long long ptr)
 @ stub ADL2_Display_SplitDisplay_Caps
 @ stub ADL2_Display_SplitDisplay_Get
 @ stub ADL2_Display_SplitDisplay_RestoreDesktopConfiguration
@@ -429,11 +448,17 @@
 @ stub ADL2_GPUVerInfo_Get
 @ stub ADL2_GcnAsicInfo_Get
 @ stub ADL2_Graphics_IsDetachableGraphicsPlatform_Get
-@ stub ADL2_Graphics_IsGfx9AndAbove
+@ cdecl -arch=i386 ADL2_Graphics_IsGfx9AndAbove(ptr)
+@ stdcall -arch=!i386 ADL2_Graphics_IsGfx9AndAbove(ptr)
 @ stub ADL2_Graphics_MantleVersion_Get
-@ stub ADL2_Graphics_Platform_Get
-@ stdcall ADL2_Graphics_VersionsX2_Get(ptr ptr)
-@ stub ADL2_Graphics_Versions_Get
+@ cdecl -arch=i386 ADL2_Graphics_Platform_Get(ptr ptr)
+@ stdcall -arch=!i386 ADL2_Graphics_Platform_Get(ptr ptr)
+@ cdecl -arch=i386 ADL2_Graphics_VersionsX2_Get(ptr ptr)
+@ stdcall -arch=!i386 ADL2_Graphics_VersionsX2_Get(ptr ptr)
+@ cdecl -arch=i386 ADL2_Graphics_VersionsX3_Get(ptr long ptr)
+@ stdcall -arch=!i386 ADL2_Graphics_VersionsX3_Get(ptr long ptr)
+@ cdecl -arch=i386 ADL2_Graphics_Versions_Get(ptr ptr)
+@ stdcall -arch=!i386 ADL2_Graphics_Versions_Get(ptr ptr)
 @ stub ADL2_Graphics_VulkanVersion_Get
 @ stub ADL2_HybridGraphicsGPU_Set
 @ stub ADL2_MGPUSLS_Status_Set
@@ -450,9 +475,14 @@
 @ stub ADL2_MMD_VideoColor_Get
 @ stub ADL2_MMD_VideoColor_Set
 @ stub ADL2_MMD_Video_Caps
-@ stub ADL2_Main_ControlX2_Create
-@ stdcall ADL2_Main_Control_Create(ptr long ptr)
-@ stub ADL2_Main_Control_Destroy
+@ cdecl -arch=i386 ADL2_Main_ControlX3_Create(ptr long ptr long long)
+@ stdcall -arch=!i386 ADL2_Main_ControlX3_Create(ptr long ptr long long)
+@ cdecl -arch=i386 ADL2_Main_ControlX2_Create(ptr long ptr long)
+@ stdcall -arch=!i386 ADL2_Main_ControlX2_Create(ptr long ptr long)
+@ cdecl -arch=i386 ADL2_Main_Control_Create(ptr long ptr)
+@ stdcall -arch=!i386 ADL2_Main_Control_Create(ptr long ptr)
+@ cdecl -arch=i386 ADL2_Main_Control_Destroy(ptr)
+@ stdcall -arch=!i386 ADL2_Main_Control_Destroy(ptr)
 @ stub ADL2_Main_Control_GetProcAddress
 @ stub ADL2_Main_Control_IsFunctionValid
 @ stub ADL2_Main_Control_Refresh
@@ -478,7 +508,8 @@
 @ stub ADL2_Overdrive5_ThermalDevices_Enum
 @ stub ADL2_Overdrive6_AdvancedFan_Caps
 @ stub ADL2_Overdrive6_CapabilitiesEx_Get
-@ stub ADL2_Overdrive6_Capabilities_Get
+@ cdecl -arch=i386 ADL2_Overdrive6_Capabilities_Get(ptr long ptr)
+@ stdcall -arch=!i386 ADL2_Overdrive6_Capabilities_Get(ptr long ptr)
 @ stub ADL2_Overdrive6_ControlI2C
 @ stub ADL2_Overdrive6_CurrentPower_Get
 @ stub ADL2_Overdrive6_CurrentStatus_Get
@@ -497,7 +528,8 @@
 @ stub ADL2_Overdrive6_PowerControl_Set
 @ stub ADL2_Overdrive6_StateEx_Get
 @ stub ADL2_Overdrive6_StateEx_Set
-@ stub ADL2_Overdrive6_StateInfo_Get
+@ cdecl -arch=i386 ADL2_Overdrive6_StateInfo_Get(ptr long long ptr)
+@ stdcall -arch=!i386 ADL2_Overdrive6_StateInfo_Get(ptr long long ptr)
 @ stub ADL2_Overdrive6_State_Reset
 @ stub ADL2_Overdrive6_State_Set
 @ stub ADL2_Overdrive6_TargetTemperatureData_Get
@@ -537,7 +569,8 @@
 @ stub ADL2_OverdriveN_MemoryClocks_Set
 @ stub ADL2_OverdriveN_MemoryTimingLevel_Get
 @ stub ADL2_OverdriveN_MemoryTimingLevel_Set
-@ stub ADL2_OverdriveN_PerformanceStatus_Get
+@ cdecl -arch=i386 ADL2_OverdriveN_PerformanceStatus_Get(ptr long ptr)
+@ stdcall -arch=!i386 ADL2_OverdriveN_PerformanceStatus_Get(ptr long ptr)
 @ stub ADL2_OverdriveN_PowerLimit_Get
 @ stub ADL2_OverdriveN_PowerLimit_Set
 @ stub ADL2_OverdriveN_SCLKAutoOverClock_Get
@@ -548,12 +581,14 @@
 @ stub ADL2_OverdriveN_SystemClocksX2_Set
 @ stub ADL2_OverdriveN_SystemClocks_Get
 @ stub ADL2_OverdriveN_SystemClocks_Set
-@ stub ADL2_OverdriveN_Temperature_Get
+@ cdecl -arch=i386 ADL2_OverdriveN_Temperature_Get(ptr long long ptr)
+@ stdcall -arch=!i386 ADL2_OverdriveN_Temperature_Get(ptr long long ptr)
 @ stub ADL2_OverdriveN_Test_Set
 @ stub ADL2_OverdriveN_ThrottleNotification_Get
 @ stub ADL2_OverdriveN_ZeroRPMFan_Get
 @ stub ADL2_OverdriveN_ZeroRPMFan_Set
-@ stub ADL2_Overdrive_Caps
+@ cdecl -arch=i386 ADL2_Overdrive_Caps(ptr long ptr ptr ptr)
+@ stdcall -arch=!i386 ADL2_Overdrive_Caps(ptr long ptr ptr ptr)
 @ stub ADL2_PPLogSettings_Get
 @ stub ADL2_PPLogSettings_Set
 @ stub ADL2_PPW_Caps
@@ -681,14 +716,17 @@
 @ stub ADL_APO_AudioDelay_Set
 @ stub ADL_AdapterLimitation_Caps
 @ stub ADL_AdapterX2_Caps
-@ stdcall ADL_Adapter_ASICFamilyType_Get(long ptr ptr)
+@ cdecl -arch=i386 ADL_Adapter_ASICFamilyType_Get(long ptr ptr)
+@ stdcall -arch=!i386 ADL_Adapter_ASICFamilyType_Get(long ptr ptr)
 @ stub ADL_Adapter_ASICInfo_Get
 @ stub ADL_Adapter_Accessibility_Get
 @ stub ADL_Adapter_Active_Get
 @ stub ADL_Adapter_Active_Set
 @ stub ADL_Adapter_Active_SetPrefer
-@ stub ADL_Adapter_AdapterInfoX2_Get
-@ stdcall ADL_Adapter_AdapterInfo_Get(ptr long)
+@ cdecl -arch=i386 ADL_Adapter_AdapterInfoX2_Get(ptr)
+@ stdcall -arch=!i386 ADL_Adapter_AdapterInfoX2_Get(ptr)
+@ cdecl -arch=i386 ADL_Adapter_AdapterInfo_Get(ptr long)
+@ stdcall -arch=!i386 ADL_Adapter_AdapterInfo_Get(ptr long)
 @ stub ADL_Adapter_AdapterList_Disable
 @ stub ADL_Adapter_Aspects_Get
 @ stub ADL_Adapter_AudioChannelSplitConfiguration_Get
@@ -714,8 +752,8 @@
 @ stub ADL_Adapter_CrossdisplayInfo_Get
 @ stub ADL_Adapter_CrossdisplayInfo_Set
 @ stub ADL_Adapter_CrossfireX2_Get
-@ stdcall ADL_Adapter_Crossfire_Caps(long ptr ptr ptr)
-@ stdcall ADL_Adapter_Crossfire_Get(long ptr ptr)
+@ stub ADL_Adapter_Crossfire_Caps(long ptr ptr ptr)
+@ stub ADL_Adapter_Crossfire_Get(long ptr ptr)
 @ stub ADL_Adapter_Crossfire_Set
 @ stub ADL_Adapter_DefaultAudioChannelTable_Load
 @ stub ADL_Adapter_DisplayAudioEndpoint_Enable
@@ -736,15 +774,18 @@
 @ stub ADL_Adapter_LocalDisplayState_Get
 @ stub ADL_Adapter_MaxCursorSize_Get
 @ stub ADL_Adapter_MemoryInfo2_Get
-@ stdcall ADL_Adapter_MemoryInfo_Get(long ptr)
+@ cdecl -arch=i386 ADL_Adapter_MemoryInfo_Get(long ptr)
+@ stdcall -arch=!i386 ADL_Adapter_MemoryInfo_Get(long ptr)
 @ stub ADL_Adapter_MirabilisSupport_Get
 @ stub ADL_Adapter_ModeSwitch
 @ stub ADL_Adapter_ModeTimingOverride_Caps
 @ stub ADL_Adapter_Modes_ReEnumerate
 @ stub ADL_Adapter_NumberOfActivatableSources_Get
-@ stdcall ADL_Adapter_NumberOfAdapters_Get(ptr)
-@ stdcall ADL_Adapter_ObservedClockInfo_Get(long ptr ptr)
-@ stub ADL_Adapter_ObservedGameClockInfo_Get
+@ cdecl -arch=i386 ADL_Adapter_NumberOfAdapters_Get(ptr)
+@ stdcall -arch=!i386 ADL_Adapter_NumberOfAdapters_Get(ptr)
+@ stub ADL_Adapter_ObservedClockInfo_Get(long ptr ptr)
+@ cdecl -arch=i386 ADL_Adapter_ObservedGameClockInfo_Get(ptr long ptr ptr ptr ptr)
+@ stdcall -arch=!i386 ADL_Adapter_ObservedGameClockInfo_Get(ptr long ptr ptr ptr ptr)
 @ stub ADL_Adapter_Primary_Get
 @ stub ADL_Adapter_Primary_Set
 @ stub ADL_Adapter_RegValueInt_Get
@@ -844,8 +885,10 @@
 @ stub ADL_Display_DisplayContent_Cap
 @ stub ADL_Display_DisplayContent_Get
 @ stub ADL_Display_DisplayContent_Set
-@ stdcall ADL_Display_DisplayInfo_Get(long long ptr long)
-@ stdcall ADL_Display_DisplayMapConfig_Get(long ptr ptr ptr ptr long)
+@ cdecl -arch=i386 ADL_Display_DisplayInfo_Get(long long ptr long)
+@ stdcall -arch=!i386 ADL_Display_DisplayInfo_Get(long long ptr long)
+@ cdecl -arch=i386 ADL_Display_DisplayMapConfig_Get(long ptr ptr ptr ptr long)
+@ stdcall -arch=!i386 ADL_Display_DisplayMapConfig_Get(long ptr ptr ptr ptr long)
 @ stub ADL_Display_DisplayMapConfig_PossibleAddAndRemove
 @ stub ADL_Display_DisplayMapConfig_Set
 @ stub ADL_Display_DisplayMapConfig_Validate
@@ -853,7 +896,8 @@
 @ stub ADL_Display_DitherState_Set
 @ stub ADL_Display_Downscaling_Caps
 @ stub ADL_Display_DpMstInfo_Get
-@ stub ADL_Display_EdidData_Get
+@ cdecl -arch=i386 ADL_Display_EdidData_Get(long long ptr)
+@ stdcall -arch=!i386 ADL_Display_EdidData_Get(long long ptr)
 @ stub ADL_Display_EdidData_Set
 @ stub ADL_Display_EnumDisplays_Get
 @ stub ADL_Display_FilterSVideo_Get
@@ -890,7 +934,8 @@
 @ stub ADL_Display_ModeTimingOverride_Delete
 @ stub ADL_Display_ModeTimingOverride_Get
 @ stub ADL_Display_ModeTimingOverride_Set
-@ stub ADL_Display_Modes_Get
+@ cdecl -arch=i386 ADL_Display_Modes_Get(long long ptr ptr)
+@ stdcall -arch=!i386 ADL_Display_Modes_Get(long long ptr ptr)
 @ stub ADL_Display_Modes_Set
 @ stub ADL_Display_MonitorPowerState_Set
 @ stub ADL_Display_NativeAUXChannel_Access
@@ -932,11 +977,13 @@
 @ stub ADL_Display_SLSMapConfigX2_Get
 @ stub ADL_Display_SLSMapConfig_Create
 @ stub ADL_Display_SLSMapConfig_Delete
-@ stub ADL_Display_SLSMapConfig_Get
+@ cdecl -arch=i386 ADL_Display_SLSMapConfig_Get(long long ptr ptr ptr ptr ptr ptr ptr ptr ptr ptr ptr long)
+@ stdcall -arch=!i386 ADL_Display_SLSMapConfig_Get(long long ptr ptr ptr ptr ptr ptr ptr ptr ptr ptr ptr long)
 @ stub ADL_Display_SLSMapConfig_Rearrange
 @ stub ADL_Display_SLSMapConfig_SetState
 @ stub ADL_Display_SLSMapIndexList_Get
-@ stub ADL_Display_SLSMapIndex_Get
+@ cdecl -arch=i386 ADL_Display_SLSMapIndex_Get(long long ptr ptr)
+@ stdcall -arch=!i386 ADL_Display_SLSMapIndex_Get(long long ptr ptr)
 @ stub ADL_Display_SLSMiddleMode_Get
 @ stub ADL_Display_SLSMiddleMode_Set
 @ stub ADL_Display_SLSRecords_Get
@@ -969,8 +1016,10 @@
 @ stub ADL_Display_WriteAndReadI2CLargePayload
 @ stub ADL_Display_WriteAndReadI2CRev_Get
 @ stub ADL_Flush_Driver_Data
-@ stdcall ADL_Graphics_Platform_Get(ptr)
-@ stdcall ADL_Graphics_Versions_Get(ptr)
+@ cdecl -arch=i386 ADL_Graphics_Platform_Get(ptr)
+@ stdcall -arch=!i386 ADL_Graphics_Platform_Get(ptr)
+@ cdecl -arch=i386 ADL_Graphics_Versions_Get(ptr)
+@ stdcall -arch=!i386 ADL_Graphics_Versions_Get(ptr)
 @ stub ADL_MMD_FeatureList_Get
 @ stub ADL_MMD_FeatureValuesX2_Get
 @ stub ADL_MMD_FeatureValuesX2_Set
@@ -984,12 +1033,16 @@
 @ stub ADL_MMD_VideoColor_Get
 @ stub ADL_MMD_VideoColor_Set
 @ stub ADL_MMD_Video_Caps
-@ stub ADL_Main_ControlX2_Create
-@ stdcall ADL_Main_Control_Create(ptr long)
-@ stdcall ADL_Main_Control_Destroy()
+@ cdecl -arch=i386 ADL_Main_ControlX2_Create(ptr long long)
+@ stdcall -arch=!i386 ADL_Main_ControlX2_Create(ptr long long)
+@ cdecl -arch=i386 ADL_Main_Control_Create(ptr long)
+@ stdcall -arch=!i386 ADL_Main_Control_Create(ptr long)
+@ cdecl -arch=i386 ADL_Main_Control_Destroy()
+@ stdcall -arch=!i386 ADL_Main_Control_Destroy()
 @ stub ADL_Main_Control_GetProcAddress
 @ stub ADL_Main_Control_IsFunctionValid
-@ stub ADL_Main_Control_Refresh
+@ cdecl -arch=i386 ADL_Main_Control_Refresh()
+@ stdcall -arch=!i386 ADL_Main_Control_Refresh()
 @ stub ADL_Main_LogDebug_Set
 @ stub ADL_Main_LogError_Set
 @ stub ADL_Overdrive5_CurrentActivity_Get
diff --git a/dlls/atiadlxx/atiadlxx_main.c b/dlls/atiadlxx/atiadlxx_main.c
index 9399025f94b..1c97b25962b 100644
--- a/dlls/atiadlxx/atiadlxx_main.c
+++ b/dlls/atiadlxx/atiadlxx_main.c
@@ -1,493 +1,1290 @@
-/* Headers: https://github.com/GPUOpen-LibrariesAndSDKs/display-library */
+/*
+ * atiadlxx implementation
+ *
+ * Copyright 2023 Etaash Mathamsetty
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
 
 #include <stdarg.h>
-#include <stdio.h>
-#include <stdlib.h>
 
-#define COBJMACROS
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
 #include "windef.h"
 #include "winbase.h"
-#include "winuser.h"
-#include "objbase.h"
-#include "initguid.h"
+#include "winternl.h"
 #include "wine/debug.h"
+#include "wine/heap.h"
 
-#include "dxgi.h"
-
-#define MAX_GPUS 64
-#define VENDOR_AMD 0x1002
-
-#define ADL_OK                            0
-#define ADL_ERR                          -1
-#define ADL_ERR_INVALID_PARAM            -3
-#define ADL_ERR_INVALID_ADL_IDX          -5
-#define ADL_ERR_NOT_SUPPORTED            -8
-#define ADL_ERR_NULL_POINTER             -9
+#include "wine/vulkan.h"
+#include "wine/asm.h"
 
-#define ADL_DISPLAY_DISPLAYINFO_DISPLAYCONNECTED            0x00000001
-#define ADL_DISPLAY_DISPLAYINFO_DISPLAYMAPPED               0x00000002
-#define ADL_DISPLAY_DISPLAYINFO_MASK 0x31fff
+#define COBJMACROS
+#include "initguid.h"
+#include "d3d11.h"
+#include "d3d12.h"
 
-#define ADL_ASIC_DISCRETE    (1 << 0)
-#define ADL_ASIC_MASK        0xAF
+#include "dxgi1_6.h"
 
-enum ADLPlatForm
-{
-    GRAPHICS_PLATFORM_DESKTOP  = 0,
-    GRAPHICS_PLATFORM_MOBILE   = 1
-};
-#define GRAPHICS_PLATFORM_UNKNOWN -1
+#include "dxvk_interfaces.h"
 
+#include "unixlib.h"
 
-static IDXGIFactory *dxgi_factory;
+#include "amdheaders/adl_sdk.h"
+#include <wingdi.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(atiadlxx);
 
-BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
-{
-    TRACE("(%p, %u, %p)\n", instance, reason, reserved);
+#define AMD_VENDOR_ID 0x1002
 
-    switch (reason)
-    {
-    case DLL_PROCESS_ATTACH:
-        DisableThreadLibraryCalls(instance);
-        break;
-    }
+/* TODO split into multiple files */
 
-    return TRUE;
-}
+/* TODO: Switch adapter_descs to this structure */
+typedef struct _ADLAdapter {
+    DXGI_ADAPTER_DESC1 desc;
+    int monitor_index;
+} ADLAdapter;
 
-typedef void *(CALLBACK *ADL_MAIN_MALLOC_CALLBACK)(int);
-typedef void *ADL_CONTEXT_HANDLE;
-
-ADL_MAIN_MALLOC_CALLBACK adl_malloc;
-#define ADL_MAX_PATH 256
-
-typedef struct ADLVersionsInfo
-{
-    char strDriverVer[ADL_MAX_PATH];
-    char strCatalystVersion[ADL_MAX_PATH];
-    char strCatalystWebLink[ADL_MAX_PATH];
-} ADLVersionsInfo, *LPADLVersionsInfo;
-
-typedef struct ADLVersionsInfoX2
-{
-    char strDriverVer[ADL_MAX_PATH];
-    char strCatalystVersion[ADL_MAX_PATH];
-    char strCrimsonVersion[ADL_MAX_PATH];
-    char strCatalystWebLink[ADL_MAX_PATH];
-} ADLVersionsInfoX2, *LPADLVersionsInfoX2;
-
-typedef struct ADLAdapterInfo {
-    int iSize;
-    int iAdapterIndex;
-    char strUDID[ADL_MAX_PATH];
-    int iBusNumber;
-    int iDeviceNumber;
-    int iFunctionNumber;
-    int iVendorID;
-    char strAdapterName[ADL_MAX_PATH];
-    char strDisplayName[ADL_MAX_PATH];
-    int iPresent;
-    int iExist;
-    char strDriverPath[ADL_MAX_PATH];
-    char strDriverPathExt[ADL_MAX_PATH];
-    char strPNPString[ADL_MAX_PATH];
-    int iOSDisplayIndex;
-} ADLAdapterInfo, *LPADLAdapterInfo;
-
-typedef struct ADLDisplayID
-{
-    int iDisplayLogicalIndex;
-    int iDisplayPhysicalIndex;
-    int iDisplayLogicalAdapterIndex;
-    int iDisplayPhysicalAdapterIndex;
-} ADLDisplayID, *LPADLDisplayID;
-
-typedef struct ADLDisplayInfo
-{
-    ADLDisplayID displayID;
-    int  iDisplayControllerIndex;
-    char strDisplayName[ADL_MAX_PATH];
-    char strDisplayManufacturerName[ADL_MAX_PATH];
-    int  iDisplayType;
-    int  iDisplayOutputType;
-    int  iDisplayConnector;
-    int  iDisplayInfoMask;
-    int  iDisplayInfoValue;
-} ADLDisplayInfo, *LPADLDisplayInfo;
-
-typedef struct ADLCrossfireComb
-{
-    int iNumLinkAdapter;
-    int iAdaptLink[3];
-} ADLCrossfireComb;
-
-typedef struct ADLCrossfireInfo
-{
-  int iErrorCode;
-  int iState;
-  int iSupported;
-} ADLCrossfireInfo;
-
-typedef struct ADLMemoryInfo
-{
-    long long iMemorySize;
-    char strMemoryType[ADL_MAX_PATH];
-    long long iMemoryBandwidth;
-} ADLMemoryInfo, *LPADLMemoryInfo;
-
-typedef struct ADLDisplayTarget
-{
-    ADLDisplayID displayID;
-    int iDisplayMapIndex;
-    int iDisplayTargetMask;
-    int iDisplayTargetValue;
-} ADLDisplayTarget, *LPADLDisplayTarget;
-
-typedef struct ADLMode
-{
-    int iAdapterIndex;
-    ADLDisplayID displayID;
-    int iXPos;
-    int iYPos;
-    int iXRes;
-    int iYRes;
-    int iColourDepth;
-    float fRefreshRate;
-    int iOrientation;
-    int iModeFlag;
-    int iModeMask;
-    int iModeValue;
-} ADLMode, *LPADLMode;
-
-typedef struct ADLDisplayMap
-{
-    int iDisplayMapIndex;
-    ADLMode displayMode;
-    int iNumDisplayTarget;
-    int iFirstDisplayTargetArrayIndex;
-    int iDisplayMapMask;
-    int iDisplayMapValue;
-} ADLDisplayMap, *LPADLDisplayMap;
-
-static const ADLVersionsInfo version = {
+typedef struct _ADL_CONTEXT
+{
+    ADLThreadingModel model;
+    ADL_MAIN_MALLOC_CALLBACK callback;
+    IDXGIFactory1 *factory;
+    IDXGIVkInteropFactory1 *dxgi_interop;
+    DXGI_ADAPTER_DESC1 *adapter_descs;
+    BOOL adl1;
+    int monitor_count;
+    int adapter_count;
+    int enum_connected_adapters;
+} ADL_CONTEXT;
+
+static ADL_CONTEXT global_adl_context;
+
+static const ADLVersionsInfo global_versions_info =
+{
     "99.19.02-230831a-396538C-AMD-Software-Adrenalin-Edition",
-    "",
+    "99.10", /*BF4 reads this version*/
     "http://support.amd.com/drivers/xml/driver_09_us.xml",
 };
 
-static const ADLVersionsInfoX2 version2 = {
+static const ADLVersionsInfoX2 global_versions_infox2 =
+{
     "99.19.02-230831a-396538C-AMD-Software-Adrenalin-Edition",
-    "",
+    "99.10", /*BF4 reads this version*/
     "99.10.2",
     "http://support.amd.com/drivers/xml/driver_09_us.xml",
 };
 
-int WINAPI ADL2_Main_Control_Create(ADL_MAIN_MALLOC_CALLBACK cb, int arg, ADL_CONTEXT_HANDLE *ptr)
+static void create_dxgi_factory(IDXGIFactory1 **factory)
 {
-    FIXME("cb %p, arg %d, ptr %p stub!\n", cb, arg, ptr);
+    static typeof(CreateDXGIFactory1) *pCreateDxgiFactory1 = NULL;
+
+    if (!pCreateDxgiFactory1)
+    {
+        HMODULE dxgi_module = LoadLibraryW( L"dxgi.dll" );
+        if (!dxgi_module)
+        {
+            ERR("Failed to load dxgi.dll\n");
+            return;
+        }
+
+        pCreateDxgiFactory1 = (void *)GetProcAddress(dxgi_module, "CreateDXGIFactory1");
+        if (!pCreateDxgiFactory1)
+        {
+            ERR("Failed to get CreateDXGIFactory1\n");
+            return;
+        }
+    }
+
+    if(FAILED(pCreateDxgiFactory1(&IID_IDXGIFactory1, (void **)factory)))
+    {
+        ERR("Failed to create IDXGIFactory1\n");
+        return;
+    }
+}
+
+static INIT_ONCE unix_init_once = INIT_ONCE_STATIC_INIT;
+static BOOL unix_lib_initialized;
+
+#define ATI_CALL(func, args) WINE_UNIX_CALL( unix_ ## func, args )
+
+#ifdef __i386__
+#define AMDAPI __cdecl
+#else
+#define AMDAPI __stdcall
+#endif
+
+static BOOL WINAPI init_unix_lib_once( INIT_ONCE *once, void *param, void **context )
+{
+    unix_lib_initialized = !__wine_init_unix_call() && !ATI_CALL( init, NULL );
+    return TRUE;
+}
+
+static BOOL init_unix_lib(void)
+{
+    InitOnceExecuteOnce( &unix_init_once, init_unix_lib_once, NULL, NULL );
+    return unix_lib_initialized;
+}
+
+static int WINAPI count_monitors(HMONITOR monitor, HDC hdcMonitor, LPRECT lprcMonitor, LPARAM dwData)
+{
+    int *count = (int *)dwData;
+    (*count)++;
+    return TRUE;
+}
+
+static int init_context_descs(ADL_CONTEXT *context, int *num_adapters, DXGI_ADAPTER_DESC1 *descs)
+{
+    IDXGIAdapter1 *adapter = NULL;
+    DXGI_ADAPTER_DESC1 desc;
+    int i = 0;
+
+    TRACE("(%p, %p, %p)\n", context, num_adapters, descs);
+
+    if(!context)
+        return ADL_ERR;
+
+    for(; SUCCEEDED(IDXGIFactory1_EnumAdapters1(context->factory, i, &adapter)); i++)
+    {
+        IDXGIAdapter1_GetDesc1(adapter, &desc);
+
+        if(desc.VendorId != AMD_VENDOR_ID)
+            i--;
+        else if(descs)
+            descs[i] = desc;
+
+        IDXGIAdapter1_Release(adapter);
+    }
+
+    *num_adapters = i;
+
     return ADL_OK;
 }
 
-int WINAPI ADL_Main_Control_Create(ADL_MAIN_MALLOC_CALLBACK cb, int arg)
+static char* wchar_to_char(const WCHAR *src)
 {
-    FIXME("cb %p, arg %d stub!\n", cb, arg);
-    adl_malloc = cb;
+    int len = wcslen(src);
+    char *dst = calloc(len + 1, sizeof(char));
+    WideCharToMultiByte(CP_ACP, 0, src, -1, dst, len, NULL, NULL);
 
+    return dst;
+}
 
-    if (SUCCEEDED(CreateDXGIFactory(&IID_IDXGIFactory, (void**) &dxgi_factory)))
-        return ADL_OK;
-    else
+int AMDAPI ADL2_Main_ControlX3_Create(ADL_MAIN_MALLOC_CALLBACK callback, int enum_connected_adapters, ADL_CONTEXT_HANDLE* context, ADLThreadingModel model, int options)
+{
+    ADL_CONTEXT *adl_context = NULL;
+    TRACE("(%p, %d, %p, %d, %d)\n", callback, enum_connected_adapters, context, model, options);
+
+    if (!init_unix_lib())
+    {
+        ERR("Failed to initialize unixlib\n");
+        return ADL_ERR;
+    }
+
+    adl_context = calloc(1, sizeof(ADL_CONTEXT));
+
+    adl_context->model = model;
+    adl_context->callback = callback;
+    adl_context->enum_connected_adapters = enum_connected_adapters;
+    adl_context->adl1 = false;
+
+    create_dxgi_factory(&adl_context->factory);
+
+    if(!adl_context->factory)
+    {
+        ERR("Failed to create IDXGIFactory1\n");
+        return ADL_ERR;
+    }
+
+    if(FAILED(IDXGIFactory1_QueryInterface(adl_context->factory, &IID_IDXGIVkInteropFactory1, (void **)&adl_context->dxgi_interop)))
+    {
+        ERR("Failed to get IDXGIVkInteropFactory1\n");
+        return ADL_ERR;
+    }
+
+    EnumDisplayMonitors(NULL, NULL, count_monitors, (LPARAM)&adl_context->monitor_count);
+
+    *context = adl_context;
+
+    init_context_descs(adl_context, &adl_context->adapter_count, NULL);
+
+    adl_context->adapter_descs = calloc(adl_context->adapter_count, sizeof(DXGI_ADAPTER_DESC1));
+
+    init_context_descs(adl_context, &adl_context->adapter_count, adl_context->adapter_descs);
+
+    return ADL_OK;
+}
+
+int AMDAPI ADL2_Main_ControlX2_Create(ADL_MAIN_MALLOC_CALLBACK callback, int enum_connected_adapters, ADL_CONTEXT_HANDLE* context, ADLThreadingModel model)
+{
+    return ADL2_Main_ControlX3_Create(callback, enum_connected_adapters, context, model, 0);
+}
+
+int AMDAPI ADL2_Main_Control_Create(ADL_MAIN_MALLOC_CALLBACK callback, int enum_connected_adapters, ADL_CONTEXT_HANDLE* context)
+{
+    return ADL2_Main_ControlX2_Create(callback, enum_connected_adapters, context, ADL_THREADING_UNLOCKED);
+}
+
+int AMDAPI ADL2_Main_Control_Destroy(ADL_CONTEXT *context)
+{
+    TRACE("(%p)\n", context);
+
+    if(!context)
         return ADL_ERR;
+
+    if(context->factory)
+        IDXGIFactory1_Release(context->factory);
+
+    if(context->dxgi_interop)
+        IDXGIVkInteropFactory1_Release(context->dxgi_interop);
+
+    free(context->adapter_descs);
+    free(context);
+
+    return ADL_OK;
 }
 
-int WINAPI ADL_Main_Control_Destroy(void)
+int AMDAPI ADL2_Main_Control_Refresh(ADL_CONTEXT *context)
 {
-    FIXME("stub!\n");
+    TRACE("(%p)\n", context);
 
-    if (dxgi_factory != NULL)
-        IUnknown_Release(dxgi_factory);
+    if(!context)
+        return ADL_ERR;
 
     return ADL_OK;
 }
 
-int WINAPI ADL2_Adapter_NumberOfAdapters_Get(ADL_CONTEXT_HANDLE *ptr, int *count)
+int AMDAPI ADL_Main_ControlX2_Create(ADL_MAIN_MALLOC_CALLBACK callback, int enum_connected_adapters, ADLThreadingModel threadingModel)
 {
-    FIXME("ptr %p, count %p stub!\n", ptr, count);
+    TRACE("(%p, %d, %d)\n", callback, enum_connected_adapters, threadingModel);
+
+    if (!init_unix_lib())
+    {
+        ERR("Failed to initialize unixlib\n");
+        return ADL_ERR;
+    }
+
+    global_adl_context.model = threadingModel;
+    global_adl_context.callback = callback;
+    global_adl_context.enum_connected_adapters = enum_connected_adapters;
+    global_adl_context.adl1 = true;
+
+    EnumDisplayMonitors(NULL, NULL, count_monitors, (LPARAM)&global_adl_context.monitor_count);
+
+    create_dxgi_factory(&global_adl_context.factory);
+
+    if(!global_adl_context.factory)
+    {
+        ERR("Failed to create IDXGIFactory1\n");
+        return ADL_ERR;
+    }
+
+    if(FAILED(IDXGIFactory1_QueryInterface(global_adl_context.factory, &IID_IDXGIVkInteropFactory1, (void **)&global_adl_context.dxgi_interop)))
+    {
+        ERR("Failed to get IDXGIVkInteropFactory1\n");
+        return ADL_ERR;
+    }
+
+    init_context_descs(&global_adl_context, &global_adl_context.adapter_count, NULL);
 
-    *count = 0;
+    global_adl_context.adapter_descs = calloc(global_adl_context.adapter_count, sizeof(DXGI_ADAPTER_DESC1));
+
+    init_context_descs(&global_adl_context, &global_adl_context.adapter_count, global_adl_context.adapter_descs);
 
     return ADL_OK;
 }
 
-int WINAPI ADL2_Graphics_VersionsX2_Get(ADL_CONTEXT_HANDLE *ptr, ADLVersionsInfoX2 *ver)
+int AMDAPI ADL_Main_Control_Create(ADL_MAIN_MALLOC_CALLBACK callback, int enum_connected_adapters)
+{
+    return ADL_Main_ControlX2_Create(callback, enum_connected_adapters, ADL_THREADING_UNLOCKED);
+}
+
+int AMDAPI ADL_Main_Control_Refresh(void)
+{
+    return ADL2_Main_Control_Refresh(&global_adl_context);
+}
+
+int AMDAPI ADL_Main_Control_Destroy(void)
 {
-    FIXME("ptr %p, ver %p stub!\n", ptr, ver);
-    memcpy(ver, &version2, sizeof(version2));
+    TRACE("()\n");
+
+    if(global_adl_context.factory)
+        IDXGIFactory1_Release(global_adl_context.factory);
+
+    if(global_adl_context.dxgi_interop)
+        IDXGIVkInteropFactory1_Release(global_adl_context.dxgi_interop);
+
+    free(global_adl_context.adapter_descs);
+
     return ADL_OK;
 }
 
-int WINAPI ADL_Graphics_Versions_Get(ADLVersionsInfo *ver)
+int AMDAPI ADL2_Adapter_NumberOfAdapters_Get(ADL_CONTEXT *context, int *num_adapters)
 {
-    FIXME("ver %p stub!\n", ver);
-    memcpy(ver, &version, sizeof(version));
+    TRACE("(%p, %p)\n", context, num_adapters);
+
+    if(!context || !num_adapters)
+        return ADL_ERR;
+
+    *num_adapters = context->adapter_count * context->monitor_count;
+
     return ADL_OK;
 }
 
-int WINAPI ADL_Adapter_NumberOfAdapters_Get(int *count)
+static int convert_to_gen(uint32_t asic_family)
 {
-    IDXGIAdapter *adapter;
+    if(asic_family >= AsicFamily_RDNA)
+        return ADL_GRAPHIC_CORE_GENERATION_RDNA;
+    if(asic_family >= AsicFamily_GCN1)
+        return ADL_GRAPHIC_CORE_GENERATION_GCN;
+    if(asic_family == AsicFamily_PreGCN)
+        return ADL_GRAPHIC_CORE_GENERATION_PRE_GCN;
+
+    return ADL_GRAPHIC_CORE_GENERATION_UNDEFINED;
+}
+
+int AMDAPI ADL2_Adapter_Graphic_Core_Info_Get(ADL_CONTEXT *context, int index, ADLGraphicCoreInfo* info)
+{
+    struct get_device_info_params params = {0};
+    TRACE("(%p, %d, %p)\n", context, index, info);
+
+    if(!context || !info)
+        return ADL_ERR;
+
+    if(index >= context->adapter_count)
+        return ADL_ERR;
 
-    FIXME("count %p stub!\n", count);
+    params.device_id = context->adapter_descs[index].DeviceId;
 
-    *count = 0;
-    while (SUCCEEDED(IDXGIFactory_EnumAdapters(dxgi_factory, *count, &adapter)))
+    if(!ATI_CALL( get_device_info, &params ))
     {
-        (*count)++;
-        IUnknown_Release(adapter);
+        info->iNumCUs = params.num_cu;
+        info->iNumROPs = params.num_rops;
+        info->iNumWGPs = params.num_wgp;
+        info->iGCGen = convert_to_gen(params.asic_family);
+        return ADL_OK;
     }
 
-    TRACE("*count = %d\n", *count);
-    return ADL_OK;
+    return ADL_ERR;
 }
 
-static int get_adapter_desc(int adapter_index, DXGI_ADAPTER_DESC *desc)
+int AMDAPI ADL2_Graphics_VersionsX2_Get(ADL_CONTEXT *context, ADLVersionsInfoX2 *versions_info)
 {
-    IDXGIAdapter *adapter;
-    HRESULT hr;
+    TRACE("(%p, %p)\n", context, versions_info);
 
-    if (FAILED(IDXGIFactory_EnumAdapters(dxgi_factory, adapter_index, &adapter)))
+    if(!context || !versions_info)
         return ADL_ERR;
 
-    hr = IDXGIAdapter_GetDesc(adapter, desc);
+    *versions_info = global_versions_infox2;
 
-    IUnknown_Release(adapter);
+    return ADL_OK;
+}
+
+int AMDAPI ADL2_Graphics_VersionsX3_Get(ADL_CONTEXT *context, int adapter_idx, ADLVersionsInfoX2 *versions_nfo)
+{
+    FIXME("Ignoring adapter index %d\n", adapter_idx);
 
-    return SUCCEEDED(hr) ? ADL_OK : ADL_ERR;
+    return ADL2_Graphics_VersionsX2_Get(context, versions_nfo);
 }
 
-/* yep, seriously */
-static int convert_vendor_id(int id)
+int AMDAPI ADL2_Graphics_Versions_Get(ADL_CONTEXT *context, ADLVersionsInfo *versions_info)
 {
-    char str[16];
-    snprintf(str, ARRAY_SIZE(str), "%x", id);
-    return atoi(str);
+    TRACE("(%p, %p)\n", context, versions_info);
+
+    if(!context || !versions_info)
+        return ADL_ERR;
+
+    *versions_info = global_versions_info;
+
+    return ADL_OK;
 }
 
-int WINAPI ADL_Adapter_AdapterInfo_Get(ADLAdapterInfo *adapters, int input_size)
+int AMDAPI ADL_Graphics_Versions_Get(ADLVersionsInfo *versions_info)
 {
-    int count, i;
-    DXGI_ADAPTER_DESC adapter_desc;
+    return ADL2_Graphics_Versions_Get(&global_adl_context, versions_info);
+}
 
-    FIXME("adapters %p, input_size %d, stub!\n", adapters, input_size);
+int AMDAPI ADL2_Graphics_Platform_Get(ADL_CONTEXT *context, int *platform)
+{
+    FIXME("(%p) stub\n", platform);
 
-    ADL_Adapter_NumberOfAdapters_Get(&count);
+    if(!platform || !context)
+        return ADL_ERR;
 
-    if (!adapters) return ADL_ERR_INVALID_PARAM;
-    if (input_size != count * sizeof(ADLAdapterInfo)) return ADL_ERR_INVALID_PARAM;
+    *platform = GRAPHICS_PLATFORM_DESKTOP;
 
-    memset(adapters, 0, input_size);
+    return ADL_OK;
+}
 
-    for (i = 0; i < count; i++)
+int AMDAPI ADL_Graphics_Platform_Get(int *platform)
+{
+    return ADL2_Graphics_Platform_Get(&global_adl_context, platform);
+}
+
+int AMDAPI ADL2_Graphics_IsGfx9AndAbove(ADL_CONTEXT *context)
+{
+    struct get_device_info_params params = {0};
+    TRACE("(%p)\n", context);
+
+    if(!context)
+        return ADL_ERR;
+
+    params.device_id = context->adapter_descs[0].DeviceId;
+
+    if(!ATI_CALL( get_device_info, &params ))
     {
-        adapters[i].iSize = sizeof(ADLAdapterInfo);
-        adapters[i].iAdapterIndex = i;
+        return params.asic_family >= AsicFamily_Vega;
+    }
 
-        if (get_adapter_desc(i, &adapter_desc) != ADL_OK)
-            return ADL_ERR;
+    return FALSE;
+}
+
+int AMDAPI ADL2_Adapter_AdapterInfo_Get(ADL_CONTEXT *context, AdapterInfo *info, int size)
+{
+    TRACE("(%p, %p, %d)\n", context, info, size);
+
+    size /= sizeof(AdapterInfo);
 
-        adapters[i].iVendorID = convert_vendor_id(adapter_desc.VendorId);
+    if(!context || !info)
+        return ADL_ERR;
+
+    for(int l = 0; l < size; l++)
+    {
+        if(context->adapter_descs[l].VendorId == AMD_VENDOR_ID)
+        {
+            char strUDID[256];
+            char *dst;
+            info[l].iSize = sizeof(AdapterInfo);
+            info[l].iAdapterIndex = l;
+            info[l].iVendorID = AMD_VENDOR_ID;
+            info[l].iBusNumber = context->adapter_descs[l].DeviceId;
+            strcpy(info[l].strDisplayName, "\\\\.\\DISPLAY1");
+            sprintf(strUDID, "PCI\\VEN_%04X&DEV_%04X&REV_%02X", context->adapter_descs[l].VendorId, context->adapter_descs[l].DeviceId, 0);
+            strcpy(info[l].strUDID, strUDID);
+            info[l].iPresent = 1;
+            info[l].iExist = 1;
+            info[l].iDeviceNumber = l;
+            dst = wchar_to_char(context->adapter_descs[l].Description);
+            strcpy(info[l].strAdapterName, dst);
+            TRACE("added adapter %s\n", dst);
+            free(dst);
+        }
     }
 
     return ADL_OK;
 }
 
-int WINAPI ADL_Display_DisplayInfo_Get(int adapter_index, int *num_displays, ADLDisplayInfo **info, int force_detect)
+int AMDAPI ADL2_Adapter_AdapterInfoX2_Get(ADL_CONTEXT *context, AdapterInfo **info)
 {
-    IDXGIAdapter *adapter;
-    IDXGIOutput *output;
-    int i;
+    TRACE("(%p, %p)\n", context, info);
+
+    if(!context || !info)
+        return ADL_ERR;
 
-    FIXME("adapter %d, num_displays %p, info %p stub!\n", adapter_index, num_displays, info);
+    *info = (AdapterInfo*)context->callback(sizeof(AdapterInfo) * context->adapter_count);
 
-    if (info == NULL || num_displays == NULL) return ADL_ERR_NULL_POINTER;
+    if(!*info)
+        return ADL_ERR;
+
+    memset(*info, 0, sizeof(AdapterInfo) * context->adapter_count);
+
+    return ADL2_Adapter_AdapterInfo_Get(context, *info, sizeof(AdapterInfo) * context->adapter_count);
+}
 
-    if (FAILED(IDXGIFactory_EnumAdapters(dxgi_factory, adapter_index, &adapter)))
-        return ADL_ERR_INVALID_PARAM;
+int AMDAPI ADL_Adapter_ObservedGameClockInfo_Get(ADL_CONTEXT *context, int index, int *base, int *game, int *boost, int *memory)
+{
+    struct get_device_info_params params = {0};
+    FIXME("(%p, %d, %p, %p, %p, %p) semi-stub\n", context, index, base, game, boost, memory);
+
+    if(!context || !base || !game || !boost || !memory)
+        return ADL_ERR;
 
-    *num_displays = 0;
+    params.device_id = context->adapter_descs[index].DeviceId;
 
-    while (SUCCEEDED(IDXGIAdapter_EnumOutputs(adapter, *num_displays, &output)))
+    if(!ATI_CALL( get_device_info, &params ))
     {
-        (*num_displays)++;
-        IUnknown_Release(output);
+        *base = params.min_core_clock;
+        *game = params.core_clock;
+        *boost = params.core_clock;
+        *memory = params.memory_clock;
+        return ADL_OK;
     }
 
-    IUnknown_Release(adapter);
+    return ADL_ERR;
+}
+
+int AMDAPI ADL2_Adapter_MemoryInfo_Get(ADL_CONTEXT *context, int index, ADLMemoryInfo *info)
+{
+    struct get_device_info_params params = {0};
+    TRACE("(%p, %d, %p)\n", context, index, info);
+
+    if(!context || !info)
+        return ADL_ERR;
 
-    if (*num_displays == 0)
+    params.device_id = context->adapter_descs[index].DeviceId;
+
+    if(!ATI_CALL( get_device_info, &params ))
+    {
+        info->iMemorySize = context->adapter_descs[index].DedicatedVideoMemory;
+        info->iMemoryBandwidth = params.memory_bandwidth;
+        strcpy(info->strMemoryType, "GDDR6");
         return ADL_OK;
+    }
+
+    return ADL_ERR;
+}
 
-    *info = adl_malloc(*num_displays * sizeof(**info));
-    memset(*info, 0, *num_displays * sizeof(**info));
+int AMDAPI ADL2_Display_DisplayInfo_Get(ADL_CONTEXT *context, int index, int *displays, ADLDisplayInfo **infos, int force_detect)
+{
+    DEVMODEA devmode = {0};
+    DISPLAY_DEVICEA dispdev = {0};
+    IDXGIAdapter1 *adapter = NULL;
+    IDXGIOutput *output = NULL;
+    HRESULT res;
+    TRACE("(%p, %d, %p, %p, %d)\n", context, index, displays, infos, force_detect);
+
+    if(!context || !displays || !infos)
+        return ADL_ERR;
+
+    if(index == -1)
+        index = 0;
+
+    res = IDXGIFactory1_EnumAdapters1(context->factory, index, &adapter);
+
+    if(FAILED(res))
+    {
+        ERR("Failed to get IDXGIAdapter1\n");
+        return ADL_ERR;
+    }
+
+    res = IDXGIAdapter1_EnumOutputs(adapter, 0, &output);
 
-    for (i = 0; i < *num_displays; i++)
+    if(FAILED(res))
     {
-        (*info)[i].displayID.iDisplayLogicalIndex = i;
-        (*info)[i].iDisplayInfoValue = ADL_DISPLAY_DISPLAYINFO_DISPLAYCONNECTED | ADL_DISPLAY_DISPLAYINFO_DISPLAYMAPPED;
-        (*info)[i].iDisplayInfoMask = (*info)[i].iDisplayInfoValue;
+        ERR("Failed to get IDXGIOutput\n");
+        return ADL_ERR;
+    }
+
+    IDXGIAdapter1_Release(adapter);
+    IDXGIOutput_Release(output);
+
+    *displays = context->monitor_count;
+    *infos = context->callback(sizeof(ADLDisplayInfo) * context->monitor_count);
+
+    if(!*infos)
+        return ADL_ERR;
+
+    devmode.dmSize = sizeof(DEVMODEA);
+
+    for(int i = 0; i < context->monitor_count; i++)
+    {
+        ADLDisplayInfo* info = (*infos) + i;
+
+        EnumDisplayDevicesA(NULL, i, &dispdev, 0);
+
+        EnumDisplaySettingsA(dispdev.DeviceName, ENUM_CURRENT_SETTINGS, &devmode);
+
+        info->displayID.iDisplayLogicalAdapterIndex = index;
+        info->displayID.iDisplayLogicalIndex = i;
+        info->displayID.iDisplayPhysicalAdapterIndex = index;
+        info->displayID.iDisplayPhysicalIndex = i;
+
+        strcpy(info->strDisplayName, dispdev.DeviceString);
+        /* FIXME */
+        strcpy(info->strDisplayManufacturerName, "Samsung");
+        info->iDisplayConnector = ADL_DISPLAY_CONTYPE_DISPLAYPORT;
+        info->iDisplayControllerIndex = 0;
+        info->iDisplayInfoMask = ADL_DISPLAY_DISPLAYINFO_DISPLAYCONNECTED | ADL_DISPLAY_DISPLAYINFO_DISPLAYMAPPED;
+        info->iDisplayInfoValue = ADL_DISPLAY_DISPLAYINFO_DISPLAYCONNECTED | ADL_DISPLAY_DISPLAYINFO_DISPLAYMAPPED;
+        info->iDisplayOutputType = ADL_DT_LCD_PANEL;
+        /* FIXME */
+        info->iDisplayOutputType = 0;
     }
 
     return ADL_OK;
 }
 
-int WINAPI ADL_Adapter_Crossfire_Caps(int adapter_index, int *preffered, int *num_comb, ADLCrossfireComb** comb)
+int AMDAPI ADL2_Display_Modes_Get(ADL_CONTEXT *context, int index, int display, int *num_modes, ADLMode **modes)
 {
-    FIXME("adapter %d, preffered %p, num_comb %p, comb %p stub!\n", adapter_index, preffered, num_comb, comb);
-    return ADL_ERR;
+    IDXGIAdapter1 *adapter = NULL;
+    IDXGIOutput *output = NULL;
+    uint32_t num_modes_dxgi;
+    HRESULT res;
+    DEVMODEA devmode = {0};
+    DISPLAY_DEVICEA dispdev = {0};
+    DXGI_MODE_DESC *modes_dxgi = NULL;
+    TRACE("(%p, %d, %d, %p, %p)\n", context, index, display, num_modes, modes);
+
+    if(!context || !num_modes || !modes)
+        return ADL_ERR;
+
+    if(index == -1)
+        index = 0;
+    if(display == -1)
+        display = 0;
+
+    res = IDXGIFactory1_EnumAdapters1(context->factory, index, &adapter);
+
+    if(FAILED(res))
+    {
+        ERR("Failed to get IDXGIAdapter1\n");
+        return ADL_ERR;
+    }
+
+    res = IDXGIAdapter1_EnumOutputs(adapter, display, &output);
+
+    if(FAILED(res))
+    {
+        ERR("Failed to get IDXGIOutput\n");
+        return ADL_ERR;
+    }
+
+    res = IDXGIOutput_GetDisplayModeList(output, DXGI_FORMAT_R8G8B8A8_UNORM, 0, &num_modes_dxgi, NULL);
+
+    if(FAILED(res))
+    {
+        ERR("Failed to get display mode list\n");
+        return ADL_ERR;
+    }
+
+    modes_dxgi = calloc(num_modes_dxgi, sizeof(DXGI_MODE_DESC));
+
+    res = IDXGIOutput_GetDisplayModeList(output, DXGI_FORMAT_R8G8B8A8_UNORM, 0, &num_modes_dxgi, modes_dxgi);
+
+    if(FAILED(res))
+    {
+        ERR("Failed to get display mode list\n");
+        return ADL_ERR;
+    }
+
+    if(!modes_dxgi)
+        return ADL_ERR;
+
+    *num_modes = num_modes_dxgi;
+    *modes = (ADLMode*)context->callback(sizeof(ADLMode) * num_modes_dxgi);
+
+    if(!*modes)
+    {
+        free(modes_dxgi);
+        return ADL_ERR;
+    }
+
+    EnumDisplayDevicesA(NULL, display, &dispdev, 0);
+
+    EnumDisplaySettingsA(dispdev.DeviceName, ENUM_CURRENT_SETTINGS, &devmode);
+
+    for(uint32_t i = 0; i < num_modes_dxgi; i++)
+    {
+        ADLMode *mode = (*modes) + (num_modes_dxgi - i - 1);
+        mode->fRefreshRate = (float)modes_dxgi[i].RefreshRate.Numerator / (float)modes_dxgi[i].RefreshRate.Denominator;
+        mode->iColourDepth = devmode.dmBitsPerPel;
+        mode->iAdapterIndex = index;
+        mode->iXPos = devmode.dmPosition.x;
+        mode->iYPos = devmode.dmPosition.y;
+        mode->iXRes = modes_dxgi[i].Width;
+        mode->iYRes = modes_dxgi[i].Height;
+        mode->iOrientation = devmode.dmOrientation * 90;
+        mode->iModeFlag = modes_dxgi[i].ScanlineOrdering == DXGI_MODE_SCANLINE_ORDER_PROGRESSIVE ?
+                                        ADL_DISPLAY_MODE_PROGRESSIVE_FLAG : ADL_DISPLAY_MODE_INTERLACED_FLAG;
+        /* FIXME */
+        mode->iModeMask = ADL_DISPLAY_MODE_COLOURFORMAT_8888 | ADL_DISPLAY_MODE_ORIENTATION_SUPPORTED_000 | ADL_DISPLAY_MODE_REFRESHRATE_ROUNDED;
+        mode->iModeValue = ADL_DISPLAY_MODE_COLOURFORMAT_8888 | ADL_DISPLAY_MODE_ORIENTATION_SUPPORTED_000 | ADL_DISPLAY_MODE_REFRESHRATE_ROUNDED;
+
+        mode->displayID.iDisplayLogicalAdapterIndex = index;
+        mode->displayID.iDisplayLogicalIndex = i;
+        mode->displayID.iDisplayPhysicalAdapterIndex = index;
+        mode->displayID.iDisplayPhysicalIndex = i;
+    }
+
+    free(modes_dxgi);
+    IDXGIAdapter1_Release(adapter);
+    IDXGIOutput_Release(output);
+
+    return ADL_OK;
 }
 
-int WINAPI ADL_Adapter_Crossfire_Get(int adapter_index, ADLCrossfireComb *comb, ADLCrossfireInfo *info)
+int AMDAPI ADL_Display_Modes_Get(int index, int display, int *num_modes, ADLMode **modes)
 {
-    FIXME("adapter %d, comb %p, info %p, stub!\n", adapter_index, comb, info);
-    return ADL_ERR;
+    return ADL2_Display_Modes_Get(&global_adl_context, index, display, num_modes, modes);
+}
+
+static int convert_colorspace(DXGI_COLOR_SPACE_TYPE type)
+{
+    switch(type)
+    {
+        case DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709:
+            return ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB888;
+        default: /* FIXME */
+            FIXME("unknown colorspace %#x\n", type);
+            return ADL_DISPLAY_DDCINFO_PIXEL_FORMAT_RGB888;
+    }
 }
 
-int WINAPI ADL_Adapter_ASICFamilyType_Get(int adapter_index, int *asic_type, int *valids)
+int AMDAPI ADL2_Display_FreeSync_Cap(ADL_CONTEXT *context, int index, int display, ADLFreeSyncCap *caps)
 {
-    DXGI_ADAPTER_DESC adapter_desc;
+    DEVMODEA devmode = {0};
+    DISPLAY_DEVICEA dispdev = {0};
+    FIXME("(%p, %d, %d, %p) stub! faking freesync support\n", context, index, display, caps);
+
+    if(!context || !caps)
+        return ADL_ERR;
 
-    FIXME("adapter %d, asic_type %p, valids %p, stub!\n", adapter_index, asic_type, valids);
+    if(index == -1)
+        index = 0;
 
-    if (asic_type == NULL || valids == NULL)
-        return  ADL_ERR_NULL_POINTER;
+    if(display == -1)
+        display = 0;
 
-    if (get_adapter_desc(adapter_index, &adapter_desc) != ADL_OK)
-        return ADL_ERR_INVALID_ADL_IDX;
+    EnumDisplayDevicesA(NULL, display, &dispdev, 0);
 
-    if (adapter_desc.VendorId != VENDOR_AMD)
-        return ADL_ERR_NOT_SUPPORTED;
+    EnumDisplaySettingsA(dispdev.DeviceName, ENUM_CURRENT_SETTINGS, &devmode);
 
-    *asic_type = ADL_ASIC_DISCRETE;
-    *valids = ADL_ASIC_MASK;
+    caps->iCaps = ADL_FREESYNC_CAP_SUPPORTED | ADL_FREESYNC_CAP_CURRENTMODESUPPORTED | ADL_FREESYNC_CAP_GPUSUPPORTED;
+    caps->iMaxRefreshRateInMicroHz = devmode.dmDisplayFrequency * 1000000;
+    caps->iMinRefreshRateInMicroHz = devmode.dmDisplayFrequency * 1000000;
+    caps->ucLabelIndex = ADL_FREESYNC_LABEL_FREESYNC_PREMIUM_PRO;
 
     return ADL_OK;
 }
 
-static int get_max_clock(const char *clock, int default_value)
+int AMDAPI ADL2_Display_DDCInfo2_Get(ADL_CONTEXT *context, int index, int display, ADLDDCInfo2 *info)
 {
-    char path[MAX_PATH], line[256];
-    FILE *file;
-    int drm_card, value = 0;
+    DEVMODEA devmode = {0};
+    DISPLAY_DEVICEA dispdev = {0};
+    IDXGIOutput* output = NULL;
+    IDXGIOutput6 *output6 = NULL;
+    IDXGIAdapter1 *adapter = NULL;
+    ADLFreeSyncCap caps;
+    DXGI_OUTPUT_DESC1 desc;
+    HRESULT res;
+    TRACE("(%p, %d, %d, %p)\n", context, index, display, info);
+
+    if(!context || !info)
+        return ADL_ERR;
+
+    if(index == -1)
+        index = 0;
+
+    if(display == -1)
+        display = 0;
+
+    EnumDisplayDevicesA(NULL, display, &dispdev, 0);
 
-    for (drm_card = 0; drm_card < MAX_GPUS; drm_card++)
+    EnumDisplaySettingsA(dispdev.DeviceName, ENUM_CURRENT_SETTINGS, &devmode);
+
+    res = IDXGIFactory1_EnumAdapters1(context->factory, index, &adapter);
+
+    if(FAILED(res))
     {
-        sprintf(path, "/sys/class/drm/card%d/device/pp_dpm_%s", drm_card, clock);
-        file = fopen(path, "r");
+        ERR("Failed to get IDXGIAdapter1\n");
+        return ADL_ERR;
+    }
 
-        if (file == NULL)
-            continue;
+    res = IDXGIAdapter1_EnumOutputs(adapter, display, &output);
 
-        while (fgets(line, sizeof(line), file) != NULL)
-        {
-            char *number;
+    if(FAILED(res))
+    {
+        ERR("Failed to get IDXGIOutput\n");
+        return ADL_ERR;
+    }
 
-            number = strchr(line, ' ');
-            if (number == NULL)
-            {
-                WARN("pp_dpm_%s file has unexpected format\n", clock);
-                break;
-            }
+    res = IDXGIOutput_QueryInterface(output, &IID_IDXGIOutput6, (void **)&output6);
 
-            number++;
-            value = max(strtol(number, NULL, 0), value);
-        }
+    if(FAILED(res))
+    {
+        ERR("Failed to get IDXGIOutput6\n");
+        return ADL_ERR;
     }
 
-    if (value != 0)
-        return value;
+    res = IDXGIOutput6_GetDesc1(output6, &desc);
 
-    return default_value;
+    if(FAILED(res))
+    {
+        ERR("Failed to get output description\n");
+        return ADL_ERR;
+    }
+
+    memset(info, 0, sizeof(ADLDDCInfo2));
+
+    info->iNativeDisplayChromaticityBlueX = desc.BluePrimary[0];
+    info->iNativeDisplayChromaticityBlueY = desc.BluePrimary[1];
+    info->iNativeDisplayChromaticityGreenX = desc.GreenPrimary[0];
+    info->iNativeDisplayChromaticityGreenY = desc.GreenPrimary[1];
+    info->iNativeDisplayChromaticityRedX = desc.RedPrimary[0];
+    info->iNativeDisplayChromaticityRedY = desc.RedPrimary[1];
+    info->iNativeDisplayChromaticityWhitePointX = desc.WhitePoint[0];
+    info->iNativeDisplayChromaticityWhitePointY = desc.WhitePoint[1];
+
+    ADL2_Display_FreeSync_Cap(context, index, display, &caps);
+
+    TRACE("output_desc.ColorSpace %#x.\n", desc.ColorSpace);
+    if (desc.ColorSpace == DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020)
+    {
+        TRACE("Reporting monitor %s as HDR10 supported.\n", debugstr_a((char*)devmode.dmDeviceName));
+        /* FIXME check if freesync is supported */
+        info->iSupportedHDR = ADL_HDR_CEA861_3;
+
+        if(caps.iCaps & ADL_FREESYNC_CAP_SUPPORTED)
+            info->iSupportedHDR |= ADL_HDR_FREESYNC_HDR;
+    }
+
+    /* FIXME */
+    info->iFreesyncFlags = caps.iCaps;
+
+    info->ulMaxRefresh = devmode.dmDisplayFrequency;
+    info->ulPTMRefreshRate = devmode.dmDisplayFrequency;
+    info->ulPTMCx = devmode.dmPelsWidth;
+    info->ulPTMCy = devmode.dmPelsHeight;
+    info->ulMaxVResolution = devmode.dmPelsHeight;
+    info->ulMaxHResolution = devmode.dmPelsWidth;
+    strcpy(info->cDisplayName, (char*)devmode.dmDeviceName);
+
+    info->iPanelPixelFormat = convert_colorspace(desc.ColorSpace);
+
+    info->ulSupportsDDC = 1;
+    info->ulSize = sizeof(ADLDDCInfo2);
+    info->ulMinLuminanceData = desc.MinLuminance;
+    info->ulMaxLuminanceData = desc.MaxLuminance;
+    info->ulAvgLuminanceData = desc.MaxFullFrameLuminance;
+
+    IDXGIAdapter1_Release(adapter);
+    IDXGIOutput_Release(output);
+
+    /* TODO add the rest of the data */
+
+    return ADL_OK;
+}
+
+int AMDAPI ADL2_Display_DisplayMapConfig_Get(ADL_CONTEXT *context, int index, int *num_display_maps, ADLDisplayMap **display_maps,
+                                                        int *num_display_target, ADLDisplayTarget **display_target, int options)
+{
+    DEVMODEA devmode = {0};
+    DISPLAY_DEVICEA dispdev = {0};
+    FIXME("(%p, %d, %p, %p, %p, %p, %d) semi-stub\n", context, index, num_display_maps, display_maps, num_display_target, display_target, options);
+
+    if(!context || !num_display_maps || !display_maps || !num_display_target || !display_target)
+        return ADL_ERR;
+
+    if(index == -1)
+        index = 0;
+
+    if(options > 1)
+        FIXME("options %#x not supported\n", options);
+
+
+    *num_display_maps = context->monitor_count;
+    *num_display_target = context->monitor_count;
+
+    *display_maps = context->callback(sizeof(ADLDisplayMap) * context->monitor_count);
+    *display_target = context->callback(sizeof(ADLDisplayTarget) * context->monitor_count);
+
+    for(int i = 0; i < context->monitor_count; i++)
+    {
+        ADLDisplayMap *map = (*display_maps) + i;
+        ADLDisplayTarget *target = (*display_target) + i;
+        ADLMode mode;
+
+        EnumDisplayDevicesA(NULL, i, &dispdev, 0);
+        EnumDisplaySettingsA(dispdev.DeviceName, ENUM_CURRENT_SETTINGS, &devmode);
+
+        map->iDisplayMapIndex = i;
+        map->iNumDisplayTarget = 1;
+        map->iFirstDisplayTargetArrayIndex = i;
+
+        mode.displayID.iDisplayLogicalAdapterIndex = index;
+        mode.displayID.iDisplayLogicalIndex = i;
+        mode.displayID.iDisplayPhysicalAdapterIndex = index;
+        mode.displayID.iDisplayPhysicalIndex = i;
+
+        mode.fRefreshRate = (float)devmode.dmDisplayFrequency;
+        mode.iColourDepth = devmode.dmBitsPerPel;
+        mode.iAdapterIndex = index;
+        mode.iXPos = devmode.dmPosition.x;
+        mode.iYPos = devmode.dmPosition.y;
+        mode.iXRes = devmode.dmPelsWidth;
+        mode.iYRes = devmode.dmPelsHeight;
+        mode.iOrientation = devmode.dmOrientation * 90;
+        mode.iModeFlag = ADL_DISPLAY_MODE_PROGRESSIVE_FLAG;
+        /* FIXME */
+        mode.iModeMask = ADL_DISPLAY_MODE_COLOURFORMAT_8888 | ADL_DISPLAY_MODE_ORIENTATION_SUPPORTED_000 | ADL_DISPLAY_MODE_REFRESHRATE_ROUNDED;
+        mode.iModeValue = ADL_DISPLAY_MODE_COLOURFORMAT_8888 | ADL_DISPLAY_MODE_ORIENTATION_SUPPORTED_000 | ADL_DISPLAY_MODE_REFRESHRATE_ROUNDED;
+
+        map->displayMode = mode;
+        map->iDisplayMapMask = ADL_DISPLAY_DISPLAYMAP_MANNER_SINGLE;
+        map->iDisplayMapValue = ADL_DISPLAY_DISPLAYMAP_MANNER_SINGLE;
+
+        target->displayID.iDisplayLogicalAdapterIndex = index;
+        target->displayID.iDisplayLogicalIndex = i;
+        target->displayID.iDisplayPhysicalAdapterIndex = index;
+        target->displayID.iDisplayPhysicalIndex = i;
+
+        target->iDisplayMapIndex = i;
+        target->iDisplayTargetMask = ADL_DISPLAY_DISPLAYTARGET_PREFERRED;
+        target->iDisplayTargetValue = i == 0 ? ADL_DISPLAY_DISPLAYTARGET_PREFERRED : 0;
+    }
+
+    return ADL_OK;
+}
+
+int AMDAPI ADL_Display_DisplayMapConfig_Get(int index, int *num_display_maps, ADLDisplayMap **display_maps,
+                                                        int *num_display_target, ADLDisplayTarget **display_target, int options)
+{
+    return ADL2_Display_DisplayMapConfig_Get(&global_adl_context, index, num_display_maps, display_maps, num_display_target, display_target, options);
 }
 
-/* documented in the "Linux Specific APIs" section, present and used on Windows */
-/* the name and documentation suggests that this returns current freqs, but it's actually max */
-int WINAPI ADL_Adapter_ObservedClockInfo_Get(int adapter_index, int *core_clock, int *memory_clock)
+int AMDAPI ADL_Display_DisplayInfo_Get(int index, int *num_displays, ADLDisplayInfo **infos, int force_detect)
 {
-    DXGI_ADAPTER_DESC adapter_desc;
+    return ADL2_Display_DisplayInfo_Get(&global_adl_context, index, num_displays, infos, force_detect);
+}
+
+int AMDAPI ADL_Adapter_AdapterInfo_Get(AdapterInfo *info, int size)
+{
+    return ADL2_Adapter_AdapterInfo_Get(&global_adl_context, info, size);
+}
+
+int AMDAPI ADL_Adapter_AdapterInfoX2_Get(AdapterInfo **info)
+{
+    return ADL2_Adapter_AdapterInfoX2_Get(&global_adl_context, info);
+}
+
+int AMDAPI ADL_Adapter_MemoryInfo_Get(int index, ADLMemoryInfo *info)
+{
+    return ADL2_Adapter_MemoryInfo_Get(&global_adl_context, index, info);
+}
+
+int AMDAPI ADL_Adapter_NumberOfAdapters_Get(int *num_adapters)
+{
+    return ADL2_Adapter_NumberOfAdapters_Get(&global_adl_context, num_adapters);
+}
+
+int AMDAPI ADL2_Adapter_ASICFamilyType_Get(ADL_CONTEXT *context, int index, int *asic_types, int *valids)
+{
+    struct get_device_info_params params = {0};
+    FIXME("(%p, %d, %p, %p) semi-stub\n", context, index, asic_types, valids);
+
+    if(!context || !asic_types || !valids)
+        return ADL_ERR;
+
+    if(context->adapter_descs[index].VendorId != AMD_VENDOR_ID)
+        return ADL_ERR;
+
+    params.device_id = context->adapter_descs[index].DeviceId;
 
-    FIXME("adapter %d, core_clock %p, memory_clock %p, stub!\n", adapter_index, core_clock, memory_clock);
+    if(ATI_CALL( get_device_info, &params ))
+        return ADL_ERR;
+
+    *asic_types = params.is_apu ? ADL_ASIC_INTEGRATED : ADL_ASIC_DISCRETE;
+    *valids = 0xAF; /* ADL_ASIC_MASK */
+
+    return ADL_OK;
+}
+
+int AMDAPI ADL_Adapter_ASICFamilyType_Get(int index, int *asic_types, int *valids)
+{
+    return ADL2_Adapter_ASICFamilyType_Get(&global_adl_context, index, asic_types, valids);
+}
 
-    if (core_clock == NULL || memory_clock == NULL) return ADL_ERR;
-    if (get_adapter_desc(adapter_index, &adapter_desc) != ADL_OK) return ADL_ERR;
-    if (adapter_desc.VendorId != VENDOR_AMD) return ADL_ERR_INVALID_ADL_IDX;
+int AMDAPI ADL2_Overdrive_Caps(ADL_CONTEXT *context, int index, int *supported, int *enabled, int *version)
+{
+    FIXME("(%p, %d, %p, %p, %p) stub\n", context, index, supported, enabled, version);
 
-    /* default values based on RX580 */
-    *core_clock = get_max_clock("sclk", 1350);
-    *memory_clock = get_max_clock("mclk", 2000);
+    if(!context || !supported || !enabled || !version)
+        return ADL_ERR;
 
-    TRACE("*core_clock: %i, *memory_clock %i\n", *core_clock, *memory_clock);
+    *supported = ADL_TRUE;
+    *enabled = ADL_FALSE;
+    *version = 6;
 
     return ADL_OK;
 }
 
-/* documented in the "Linux Specific APIs" section, present and used on Windows */
-int WINAPI ADL_Adapter_MemoryInfo_Get(int adapter_index, ADLMemoryInfo *mem_info)
+int AMDAPI ADL2_Overdrive6_Capabilities_Get(ADL_CONTEXT *context, int index, ADLOD6Capabilities *caps)
 {
-    DXGI_ADAPTER_DESC adapter_desc;
+    int base, game, boost, memory;
+    FIXME("(%p, %d, %p) semi-stub\n", context, index, caps);
 
-    FIXME("adapter %d, mem_info %p stub!\n", adapter_index, mem_info);
+    if(!context || !caps)
+        return ADL_ERR;
 
-    if (mem_info == NULL) return ADL_ERR_NULL_POINTER;
-    if (get_adapter_desc(adapter_index, &adapter_desc) != ADL_OK) return ADL_ERR_INVALID_ADL_IDX;
-    if (adapter_desc.VendorId != VENDOR_AMD) return ADL_ERR;
 
-    mem_info->iMemorySize = adapter_desc.DedicatedVideoMemory;
-    mem_info->iMemoryBandwidth = 256000; /* not exposed on Linux, probably needs a lookup table */
+    caps->iCapabilities = ADL_OD6_CAPABILITY_POWER_CONTROL | ADL_OD6_CAPABILITY_MCLK_CUSTOMIZATION |
+                             ADL_OD6_CAPABILITY_GPU_ACTIVITY_MONITOR | ADL_OD6_CAPABILITY_SCLK_CUSTOMIZATION;
+    caps->iNumberOfPerformanceLevels = 2;
+    caps->iExtMask = 0;
+    caps->iExtValue = 0;
+    ADL_Adapter_ObservedGameClockInfo_Get(context, index, &base, &game, &boost, &memory);
+    caps->iSupportedStates = ADL_OD6_SUPPORTEDSTATE_PERFORMANCE;
+    caps->sEngineClockRange.iMax = game;
+    caps->sEngineClockRange.iMin = base;
+    caps->sMemoryClockRange.iMax = memory;
+    caps->sMemoryClockRange.iMin = 100; /* assume 100 is base */
 
-    TRACE("iMemoryBandwidth %s, iMemorySize %s\n",
-            wine_dbgstr_longlong(mem_info->iMemoryBandwidth),
-            wine_dbgstr_longlong(mem_info->iMemorySize));
     return ADL_OK;
 }
 
-int WINAPI ADL_Graphics_Platform_Get(int *platform)
+int AMDAPI ADL2_Overdrive6_StateInfo_Get(ADL_CONTEXT *context, int index, int type, ADLOD6StateInfo *info)
 {
-    DXGI_ADAPTER_DESC adapter_desc;
-    int count, i;
+    int base, game, boost, memory;
+    FIXME("(%p, %d, %d, %p) semi-stub\n", context, index, type, info);
+
+    if(!context || !info)
+        return ADL_ERR;
+
+    info->iExtMask = 0;
+    info->iExtValue = 0;
+    info->iNumberOfPerformanceLevels = 2;
+    ADL_Adapter_ObservedGameClockInfo_Get(context, index, &base, &game, &boost, &memory);
+    /* assume caller allocated the struct in the correct way */
+    info->aLevels[0].iEngineClock = base;
+    info->aLevels[0].iMemoryClock = 100; /* assume 100 is base */
+    info->aLevels[1].iEngineClock = game;
+    info->aLevels[1].iMemoryClock = memory;
 
-    FIXME("platform %p, stub!\n", platform);
+    return ADL_OK;
+}
 
-    *platform = GRAPHICS_PLATFORM_UNKNOWN;
+int AMDAPI ADL2_Adapter_AdapterInfoX4_Get(ADL_CONTEXT *context, int index, int *num_adapters, AdapterInfoX2 **info)
+{
+    AdapterInfoX2 *info2;
+    char *dst;
+    TRACE("(%p, %d, %p, %p)\n", context, index, num_adapters, info);
 
-    ADL_Adapter_NumberOfAdapters_Get(&count);
 
-    for (i = 0; i < count; i ++)
+    if(index == -1)
     {
-        if (get_adapter_desc(i, &adapter_desc) != ADL_OK)
-            continue;
+        *num_adapters = context->adapter_count;
+        *info = context->callback(sizeof(AdapterInfoX2) * context->adapter_count);
+
+        if(!*info)
+            return ADL_ERR;
+
+        info2 = *info;
+
+        for(int i = 0; i < context->adapter_count; i++)
+        {
+            info2[i].iSize = sizeof(AdapterInfoX2);
+            info2[i].iAdapterIndex = i;
+            info2[i].iPresent = 1;
+            info2[i].iExist = 1;
+            dst = wchar_to_char(context->adapter_descs[index].Description);
+            strcpy(info2->strAdapterName, dst);
+            free(dst);
+            info2[i].iVendorID = AMD_VENDOR_ID;
+            info2[i].iBusNumber = context->adapter_descs[i].DeviceId;
+            info2[i].iDeviceNumber = i;
+        }
 
-        if (adapter_desc.VendorId == VENDOR_AMD)
-            *platform = GRAPHICS_PLATFORM_DESKTOP;
+        return ADL_OK;
     }
 
-    /* NOTE: The real value can be obtained by doing:
-     * 1. ioctl(DRM_AMDGPU_INFO) with AMDGPU_INFO_DEV_INFO - dev_info.ids_flags & AMDGPU_IDS_FLAGS_FUSION
-     * 2. VkPhysicalDeviceType() if we ever want to use Vulkan directly
-     */
+    *info = context->callback(sizeof(AdapterInfoX2));
+
+    if(!*info)
+        return ADL_ERR;
+
+    info2 = *info;
+
+    memset(info2, 0, sizeof(AdapterInfoX2));
+
+    info2->iSize = sizeof(AdapterInfoX2);
+    info2->iAdapterIndex = index;
+    info2->iPresent = 1;
+    info2->iExist = 1;
+    info2->iDeviceNumber = index;
+    dst = wchar_to_char(context->adapter_descs[index].Description);
+    strcpy(info2->strAdapterName, dst);
+    free(dst);
+    info2->iVendorID = AMD_VENDOR_ID;
+    info2->iBusNumber = context->adapter_descs[index].DeviceId;
+
 
     return ADL_OK;
 }
 
-
-int WINAPI ADL_Display_DisplayMapConfig_Get(int adapter_index, int *display_map_count, ADLDisplayMap **display_maps,
-        int *display_target_count, ADLDisplayTarget **display_targets, int options)
+int AMDAPI ADL2_Adapter_MemoryInfo2_Get(ADL_CONTEXT *context, int index, ADLMemoryInfo2 *info)
 {
-    FIXME("adapter_index %d, display_map_count %p, display_maps %p, "
-            "display_target_count %p, display_targets %p, options %d stub.\n",
-            adapter_index, display_map_count, display_maps, display_target_count,
-            display_targets, options);
+    struct get_device_info_params params = {0};
+    TRACE("(%p, %d, %p)\n", context, index, info);
+
+    if(!context || !info)
+        return ADL_ERR;
+
+    params.device_id = context->adapter_descs[index].DeviceId;
+
+    if(!ATI_CALL( get_device_info, &params ))
+    {
+        info->iMemorySize = context->adapter_descs[index].DedicatedVideoMemory;
+        info->iMemoryBandwidth = params.memory_bandwidth;
+        strcpy(info->strMemoryType, "GDDR6");
+        info->iHyperMemorySize = 0;
+        info->iVisibleMemorySize = context->adapter_descs[index].SharedSystemMemory;
+        info->iInvisibleMemorySize = 0;
+        return ADL_OK;
+    }
 
     return ADL_ERR;
 }
+
+int AMDAPI ADL2_Display_SLSMapIndex_Get(ADL_CONTEXT *context, int index, int num_displays, ADLDisplayTarget *targets, int *ret)
+{
+    FIXME("(%p, %d, %d, %p, %p) stub\n", context, index, num_displays, targets, ret);
+
+    if(!context || !targets || !ret)
+        return ADL_ERR;
+
+    *ret = 0;
+    return ADL_OK;
+}
+
+int AMDAPI ADL_Display_SLSMapIndex_Get(int index, int num_displays, ADLDisplayTarget *targets, int *ret)
+{
+    return ADL2_Display_SLSMapIndex_Get(&global_adl_context, index, num_displays, targets, ret);
+}
+
+int AMDAPI ADL2_Display_SLSMapConfig_Get( 	ADL_CONTEXT *  	context,
+		int  	iAdapterIndex,
+		int  	iSLSMapIndex,
+		ADLSLSMap *  	lpSLSMap,
+		int *  	lpNumSLSTarget,
+		ADLSLSTarget **  	lppSLSTarget,
+		int *  	lpNumNativeMode,
+		ADLSLSMode **  	lppNativeMode,
+		int *  	lpNumBezelMode,
+		ADLBezelTransientMode **  	lppBezelMode,
+		int *  	lpNumTransientMode,
+		ADLBezelTransientMode **  	lppTransientMode,
+		int *  	lpNumSLSOffset,
+		ADLSLSOffset **  	lppSLSOffset,
+		int  	iOption )
+{
+    FIXME("(%p, %d, %d, %p, %p, %p, %p, %p, %p, %p, %p, %p, %p, %p, %d) stub\n", context, iAdapterIndex,
+            iSLSMapIndex, lpSLSMap, lpNumSLSTarget, lppSLSTarget, lpNumNativeMode, lppNativeMode,
+            lpNumBezelMode, lppBezelMode, lpNumTransientMode, lppTransientMode, lpNumSLSOffset, lppSLSOffset, iOption);
+
+    if(!context || !lpSLSMap || !lpNumSLSTarget || !lppSLSTarget || !lpNumNativeMode ||
+    !lppNativeMode || !lpNumBezelMode || !lppBezelMode || !lpNumTransientMode ||
+    !lppTransientMode || !lpNumSLSOffset || !lppSLSOffset)
+        return ADL_ERR;
+
+    *lpNumSLSTarget = 0;
+    *lpNumNativeMode = 0;
+    *lpNumBezelMode = 0;
+    *lpNumTransientMode = 0;
+    *lpNumSLSOffset = 0;
+
+    return ADL_OK;
+}
+
+int AMDAPI ADL_Display_SLSMapConfig_Get(
+        int  	iAdapterIndex,
+		int  	iSLSMapIndex,
+		ADLSLSMap *  	lpSLSMap,
+		int *  	lpNumSLSTarget,
+		ADLSLSTarget **  	lppSLSTarget,
+		int *  	lpNumNativeMode,
+		ADLSLSMode **  	lppNativeMode,
+		int *  	lpNumBezelMode,
+		ADLBezelTransientMode **  	lppBezelMode,
+		int *  	lpNumTransientMode,
+		ADLBezelTransientMode **  	lppTransientMode,
+		int *  	lpNumSLSOffset,
+		ADLSLSOffset **  	lppSLSOffset,
+		int  	iOption )
+{
+    return ADL2_Display_SLSMapConfig_Get(&global_adl_context, iAdapterIndex, iSLSMapIndex, lpSLSMap, lpNumSLSTarget,
+        lppSLSTarget, lpNumNativeMode, lppNativeMode, lpNumBezelMode, lppBezelMode, lpNumTransientMode,
+        lppTransientMode, lpNumSLSOffset, lppSLSOffset, iOption);
+}
+
+int AMDAPI ADL2_Display_EdidData_Get(ADL_CONTEXT *context, int adapter_index, int display_index, ADLDisplayEDIDData *data)
+{
+    FIXME("(%p, %d, %d, %p) stub\n", context, adapter_index, display_index, data);
+
+    if (!data) return ADL_ERR;
+
+    memset(data, 0, sizeof(ADLDisplayEDIDData));
+
+    return ADL_OK;
+}
+
+int AMDAPI ADL_Display_EdidData_Get(int adapter_index, int display_index, ADLDisplayEDIDData *data)
+{
+    return ADL2_Display_EdidData_Get(&global_adl_context, adapter_index, display_index, data);
+}
+
+int AMDAPI ADL2_Adapter_Active_Get(ADL_CONTEXT *context, int index, int *status)
+{
+    FIXME("(%p %d %p) stub!\n", context, index, status);
+
+    if(!context || !status)
+        return ADL_ERR;
+
+    *status = ADL_TRUE;
+
+    return ADL_OK;
+}
+
+typedef struct
+{
+    /* TODO: what are the elements? */
+    int xyz;
+} ADLDisplayContentAttribute;
+
+int AMDAPI ADL2_Display_SourceContentAttribute_Set(ADL_CONTEXT *context, int adapter_index, int display_index, ADLDisplayContentAttribute *attribute)
+{
+    FIXME("(%p %d %d %p) stub!\n", context, adapter_index, display_index, attribute);
+
+    if(!context || !attribute)
+        return ADL_ERR;
+
+    return ADL_OK;
+}
+
+int AMDAPI ADL2_Adapter_Crossfire_Caps(ADL_CONTEXT *context, int adapter_index, int *preffer, int *numComb, ADLCrossfireComb **combs) {
+
+    if(!context || !preffer || !numComb)
+        return ADL_ERR;
+
+    FIXME("(%p %d %p %p %p) stub!\n", context, adapter_index, preffer, numComb, combs);
+
+    *preffer = 0;
+    *numComb = 0;
+
+    return ADL_OK;
+}
+
+int AMDAPI ADL2_OverdriveN_Temperature_Get(ADL_CONTEXT *context, int adapter_index, int temptype, int *temp)
+{
+
+    if(!context || !temp)
+        return ADL_ERR;
+
+    FIXME("(%p %d %d %p) stub!\n", context, adapter_index, temptype, temp);
+
+    *temp = 0;
+
+    return ADL_OK;
+}
+
+int AMDAPI ADL2_OverdriveN_PerformanceStatus_Get(ADL_CONTEXT *context, int adapter_index, ADLODNPerformanceStatus *status)
+{
+    int temp;
+    if(!context || !status)
+        return ADL_ERR;
+
+    FIXME("(%p %d %p) semi-stub!\n", context, adapter_index, status);
+
+    return ADL_Adapter_ObservedGameClockInfo_Get(context, adapter_index, &status->iCoreClock, &temp, &temp, &status->iMemoryClock);
+}
diff --git a/dlls/atiadlxx/dxvk_interfaces.idl b/dlls/atiadlxx/dxvk_interfaces.idl
new file mode 100644
index 00000000000..9e405a32a06
--- /dev/null
+++ b/dlls/atiadlxx/dxvk_interfaces.idl
@@ -0,0 +1,153 @@
+/*
+ * Copyright 2023      Paul Gofman for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#pragma makedep register
+
+import "d3d11.idl";
+import "dxgi1_6.idl";
+
+typedef struct VkInstance_T *VkInstance;
+typedef void (__stdcall *PFN_vkVoidFunction)(void);
+typedef PFN_vkVoidFunction (__stdcall *PFN_vkGetInstanceProcAddr)(VkInstance instance, const char* pName);
+
+typedef enum D3D11_VK_EXTENSION
+{
+    D3D11_VK_EXT_MULTI_DRAW_INDIRECT,
+    D3D11_VK_EXT_MULTI_DRAW_INDIRECT_COUNT,
+    D3D11_VK_EXT_DEPTH_BOUNDS,
+    D3D11_VK_EXT_BARRIER_CONTROL,
+    D3D11_VK_NVX_BINARY_IMPORT,
+    D3D11_VK_NVX_IMAGE_VIEW_HANDLE,
+} D3D11_VK_EXTENSION;
+
+typedef enum D3D11_VK_BARRIER_CONTROL
+{
+    D3D11_VK_BARRIER_CONTROL_IGNORE_WRITE_AFTER_WRITE = 0x1,
+    D3D11_VK_BARRIER_CONTROL_IGNORE_GRAPHICS_UAV = 0x2,
+} D3D11_VK_BARRIER_CONTROL;
+
+[
+    object,
+    uuid(bb8a4fb9-3935-4762-b44b-35189a26414a),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtShader : IUnknown
+{
+    HRESULT GetSpirvCode([in, out] SIZE_T *code_size, [out] void *code);
+}
+
+[
+    object,
+    uuid(8a6e3c42-f74c-45b7-8265-a231b677ca17),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtDevice : IUnknown
+{
+    BOOL GetExtensionSupport([in] D3D11_VK_EXTENSION extension);
+}
+
+[
+    object,
+    uuid(cfcf64ef-9586-46d0-bca4-97cf2ca61b06),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtDevice1 : ID3D11VkExtDevice
+{
+    BOOL GetResourceHandleGPUVirtualAddressAndSizeNVX([in] void *object, [out] UINT64 *gpu_va_start,
+            [out] UINT64 *gpu_va_size);
+    BOOL CreateUnorderedAccessViewAndGetDriverHandleNVX([in] ID3D11Resource *resource,
+            [in] const D3D11_UNORDERED_ACCESS_VIEW_DESC *desc, [out] ID3D11UnorderedAccessView **uav,
+            UINT32 *driver_handle);
+    BOOL CreateShaderResourceViewAndGetDriverHandleNVX([in] ID3D11Resource *resource,
+            [in] const D3D11_SHADER_RESOURCE_VIEW_DESC* desc, [out] ID3D11ShaderResourceView **srv,
+            UINT32 *dirver_handle);
+    BOOL CreateSamplerStateAndGetDriverHandleNVX([in] const D3D11_SAMPLER_DESC *sample_desc,
+            [out] ID3D11SamplerState **sample_state, UINT32 *driver_handle);
+    BOOL CreateCubinComputeShaderWithNameNVX([in] const void *cubin, [in] UINT32 size, [in] UINT32 block_x,
+            [in] UINT32 block_y, [in] UINT32 block_z, [in] const char *shader_name, [out] IUnknown **shader);
+    BOOL GetCudaTextureObjectNVX([in] UINT32 srv_driver_hadnle, [in] UINT32 sample_driver_handle,
+            [out] UINT32 *cuda_texture_handle);
+}
+
+[
+    object,
+    uuid(fd0bca13-5cb6-4c3a-987e-4750de2ca791),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtContext : IUnknown
+{
+    void MultiDrawIndirect([in] UINT draw_count, [in] ID3D11Buffer *buffer_for_args, [in] UINT byte_offset_for_args,
+            [in] UINT byte_stride_for_args);
+    void MultiDrawIndexedIndirect([in] UINT draw_count, [in] ID3D11Buffer *buffer_for_args,
+            [in] UINT byte_offset_for_args, [in] UINT byte_stride_for_args);
+    void MultiDrawIndirectCount([in] UINT max_draw_count, [in] ID3D11Buffer *buffer_for_count,
+            [in] UINT byte_offset_for_count, [in] ID3D11Buffer *buffer_for_args,
+            [in] UINT byte_offset_for_args, [in] UINT byte_stride_for_args);
+    void MultiDrawIndexedIndirectCount([in] UINT max_draw_count, [in] ID3D11Buffer *buffer_for_count,
+            [in] UINT byte_offset_for_count, [in] ID3D11Buffer *buffer_for_args,
+            [in] UINT byte_offset_for_args, [in] UINT byte_stride_for_args);
+    void SetDepthBoundsTest([in] BOOL enable, [in] FLOAT min_depth_bounds, [in] FLOAT max_depth_bounds);
+    void SetBarrierControl([in] UINT control_flags);
+}
+
+[
+    object,
+    uuid(874b09b2-ae0b-41d8-8476-5f3b7a0e879d),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtContext1 : ID3D11VkExtContext
+{
+    BOOL LaunchCubinShaderNVX([in] IUnknown *shader,[in] UINT32 grid_x, [in] UINT32 grid_y, [in] UINT32 grid_z,
+            [in] const void *params, [in] UINT32 param_size, [in] void * const *read_resources,
+            [in] UINT32 read_resource_count, [in] void* const *write_resources, [in] UINT32 write_resources_count);
+}
+
+[
+    object,
+    uuid(4c5e1b0d-b0c8-4131-bfd8-9b2476f7f408),
+    local,
+    pointer_default(unique)
+]
+interface IDXGIVkInteropFactory : IUnknown
+{
+    void GetVulkanInstance(
+          [out] VkInstance *pInstance,
+          [out] PFN_vkGetInstanceProcAddr *ppfnVkGetInstanceProcAddr);
+}
+
+[
+    object,
+    uuid(2a289dbd-2d0a-4a51-89f7-f2adce465cd6),
+    local,
+    pointer_default(unique)
+]
+interface IDXGIVkInteropFactory1 : IDXGIVkInteropFactory
+{
+  HRESULT GetGlobalHDRState(
+          [out] DXGI_COLOR_SPACE_TYPE   *pOutColorSpace,
+          [out] DXGI_HDR_METADATA_HDR10 *ppOutMetadata) = 0;
+
+  HRESULT SetGlobalHDRState(
+          [in] DXGI_COLOR_SPACE_TYPE    ColorSpace,
+    [in] const DXGI_HDR_METADATA_HDR10 *pMetadata) = 0;
+}
diff --git a/dlls/atiadlxx/unixlib.c b/dlls/atiadlxx/unixlib.c
new file mode 100644
index 00000000000..95849bc0292
--- /dev/null
+++ b/dlls/atiadlxx/unixlib.c
@@ -0,0 +1,285 @@
+/*
+ * Unix library for atiadlxx functions
+ *
+ * Copyright 2023 Paul Gofman for CodeWeavers
+ * Copyright 2023 Etaash Mathamsetty
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include <stdarg.h>
+#include <stdlib.h>
+#include <dlfcn.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+
+#include <xf86drm.h>
+#include <amdgpu_drm.h>
+#include <amdgpu.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winternl.h"
+
+#include "wine/debug.h"
+
+#include "unixlib.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(atiadlxx);
+
+#define MAX_DEVICE_COUNT 64
+
+static unsigned int device_count;
+static struct drm_amdgpu_info_device *amd_info;
+
+static NTSTATUS init( void *args )
+{
+    drmDevicePtr devices[MAX_DEVICE_COUNT];
+    amdgpu_device_handle h;
+    uint32_t major, minor;
+    int i, count, fd, ret;
+
+    device_count = 0;
+
+    if ((count = drmGetDevices(devices, MAX_DEVICE_COUNT)) <= 0)
+    {
+        ERR("drmGetDevices failed, err %d.\n", count);
+        return STATUS_UNSUCCESSFUL;
+    }
+    TRACE("Got %d devices.\n", count);
+    for (i = 0; i < count; ++i)
+    {
+        if (!devices[i] || !devices[i]->nodes[DRM_NODE_RENDER])
+        {
+            TRACE("No render node, skipping.\n");
+            continue;
+        }
+        if ((fd = open(devices[i]->nodes[DRM_NODE_RENDER], O_RDONLY | O_CLOEXEC)) < 0)
+        {
+            ERR("Failed to open device %s, errno %d.\n", devices[i]->nodes[DRM_NODE_RENDER], errno);
+            continue;
+        }
+        if ((ret = amdgpu_device_initialize(fd, &major, &minor, &h)))
+        {
+            WARN("Failed to initialize amdgpu device bustype %d, %04x:%04x, err %d.\n", devices[i]->bustype,
+                    devices[i]->deviceinfo.pci->vendor_id, devices[i]->deviceinfo.pci->device_id, ret);
+            close(fd);
+            continue;
+        }
+        amd_info = realloc(amd_info, (device_count + 1) * sizeof(*amd_info));
+        /* amdgpu_query_info() doesn't fail on short buffer (filling in the available buffer size). So older or
+         * newer DRM version should be fine but zero init the structure to avoid random values. */
+        memset(&amd_info[device_count], 0, sizeof(*amd_info));
+        if (!(ret = amdgpu_query_info(h, AMDGPU_INFO_DEV_INFO, sizeof(*amd_info), &amd_info[device_count])))
+        {
+            TRACE("Got amdgpu info for device id %04x, family %#x, external_rev %#x, chip_rev %#x.\n",
+                    amd_info[device_count].device_id, amd_info[device_count].family, amd_info[device_count].external_rev,
+                    amd_info[device_count].chip_rev);
+            ++device_count;
+        }
+        else
+        {
+            ERR("amdgpu_query_info failed, ret %d.\n", ret);
+        }
+        amdgpu_device_deinitialize(h);
+        close(fd);
+    }
+    drmFreeDevices(devices, count);
+    return STATUS_SUCCESS;
+}
+
+#ifndef AMDGPU_VRAM_TYPE_DDR5
+#   define AMDGPU_VRAM_TYPE_DDR5  10
+#endif
+#ifndef AMDGPU_VRAM_TYPE_LPDDR4
+#   define AMDGPU_VRAM_TYPE_LPDDR4 11
+#endif
+#ifndef AMDGPU_VRAM_TYPE_LPDDR5
+#   define AMDGPU_VRAM_TYPE_LPDDR5 12
+#endif
+
+/* From Mesa source. */
+static uint32_t memory_ops_per_clock(uint32_t vram_type)
+{
+   /* Based on MemoryOpsPerClockTable from PAL. */
+   switch (vram_type) {
+   case AMDGPU_VRAM_TYPE_GDDR1:
+   case AMDGPU_VRAM_TYPE_GDDR3: /* last in low-end Evergreen */
+   case AMDGPU_VRAM_TYPE_GDDR4: /* last in R7xx, not used much */
+   case AMDGPU_VRAM_TYPE_UNKNOWN:
+   default:
+      return 0;
+   case AMDGPU_VRAM_TYPE_DDR2:
+   case AMDGPU_VRAM_TYPE_DDR3:
+   case AMDGPU_VRAM_TYPE_DDR4:
+   case AMDGPU_VRAM_TYPE_LPDDR4:
+   case AMDGPU_VRAM_TYPE_HBM: /* same for HBM2 and HBM3 */
+      return 2;
+   case AMDGPU_VRAM_TYPE_DDR5:
+   case AMDGPU_VRAM_TYPE_LPDDR5:
+   case AMDGPU_VRAM_TYPE_GDDR5: /* last in Polaris and low-end Navi14 */
+      return 4;
+   case AMDGPU_VRAM_TYPE_GDDR6:
+      return 16;
+   }
+}
+
+/* Constants from Mesa source. */
+#define FAMILY_UNKNOWN 0x00
+#define FAMILY_TN      0x69 /* # 105 / Trinity APUs */
+#define FAMILY_SI      0x6E /* # 110 / Southern Islands: Tahiti, Pitcairn, CapeVerde, Oland, Hainan */
+#define FAMILY_CI      0x78 /* # 120 / Sea Islands: Bonaire, Hawaii */
+#define FAMILY_KV      0x7D /* # 125 / Kaveri APUs: Spectre, Spooky, Kalindi, Godavari */
+#define FAMILY_VI      0x82 /* # 130 / Volcanic Islands: Iceland, Tonga, Fiji */
+#define FAMILY_POLARIS 0x82 /* # 130 / Polaris: 10, 11, 12 */
+#define FAMILY_CZ      0x87 /* # 135 / Carrizo APUs: Carrizo, Stoney */
+#define FAMILY_AI      0x8D /* # 141 / Vega: 10, 20 */
+#define FAMILY_RV      0x8E /* # 142 / Raven */
+#define FAMILY_NV      0x8F /* # 143 / Navi: 10 */
+#define FAMILY_VGH     0x90 /* # 144 / Van Gogh */
+#define FAMILY_NV3     0x91 /* # 145 / Navi: 3x */
+#define FAMILY_RMB     0x92 /* # 146 / Rembrandt */
+#define FAMILY_RPL     0x95 /* # 149 / Raphael */
+#define FAMILY_GFX1103 0x94
+#define FAMILY_GFX1150 0x96
+#define FAMILY_MDN     0x97 /* # 151 / Mendocino */
+
+#define ROUND_DIV(value, div) (((value) + (div) / 2) / (div))
+
+static void fill_device_info(struct drm_amdgpu_info_device *info, struct get_device_info_params *out)
+{
+    uint32_t erev = info->external_rev;
+    uint64_t max_engine_clock_khz, max_memory_clock_khz;
+
+    out->asic_family = AsicFamily_Unknown;
+    switch (info->family)
+    {
+        case FAMILY_AI:
+        case FAMILY_RV:
+            out->asic_family = AsicFamily_Vega;
+            break;
+
+        /* Treat pre-Polaris cards as Polaris. */
+        case FAMILY_CZ:
+        case FAMILY_SI:
+        case FAMILY_CI:
+        case FAMILY_KV:
+        case FAMILY_POLARIS:
+            out->asic_family = AsicFamily_GCN4;
+            break;
+
+        case FAMILY_NV:
+            if (erev >= 0x01 && erev < 0x28)
+                out->asic_family = AsicFamily_RDNA;
+            else if (erev >= 0x28 && erev < 0x50)
+                out->asic_family = AsicFamily_RDNA2;
+            break;
+
+        case FAMILY_RMB:
+        case FAMILY_RPL:
+        case FAMILY_MDN:
+        case FAMILY_VGH:
+            out->asic_family = AsicFamily_RDNA2;
+            break;
+
+        case FAMILY_NV3:
+        case FAMILY_GFX1103:
+        case FAMILY_GFX1150:
+            out->asic_family = AsicFamily_RDNA3;
+            break;
+    }
+    TRACE("family %u, erev %#x -> asicFamily %d.\n", info->family, erev, out->asic_family);
+    if (out->asic_family == AsicFamily_Unknown && info->family != FAMILY_UNKNOWN)
+    {
+        if (info->family > FAMILY_GFX1150)
+            out->asic_family = AsicFamily_RDNA3;
+        else
+            out->asic_family = AsicFamily_GCN4;
+
+        FIXME("Unrecognized family %u, erev %#x -> defaulting to %d.\n", info->family, erev,
+                out->asic_family);
+    }
+
+    out->num_cu = info->cu_active_number;
+    out->num_wgp = out->asic_family >= AsicFamily_RDNA ? out->num_cu / 2 : 0;
+    out->num_rops = info->num_rb_pipes * 4;
+    TRACE("num_cu %d, num_wgp %d, num_rops %d.\n", out->num_cu, out->num_wgp, out->num_rops);
+    /* These numbers are zero on Vangogh, workaround that (similar to how it is currently done
+     * in Mesa src/amd/common/ac_rgp.c. */
+    if (!(max_engine_clock_khz = info->max_engine_clock))
+        max_engine_clock_khz = 1300000;
+    if (!(max_memory_clock_khz = info->max_memory_clock))
+        max_memory_clock_khz = 687000;
+    out->core_clock = ROUND_DIV(max_engine_clock_khz, 1000);
+    out->memory_clock = ROUND_DIV(max_memory_clock_khz, 1000);
+    out->memory_bandwidth = ROUND_DIV(max_memory_clock_khz * memory_ops_per_clock(info->vram_type)
+            * info->vram_bit_width / 8, 1000);
+    /* out->min_memory_clock = ROUND_DIV(info->min_memory_clock, 1000);
+    out->min_core_clock = ROUND_DIV(info->min_engine_clock, 1000); */
+    TRACE("core_clock %uMHz, memory_clock %uMHz, memory_bandwidth %u.\n",
+            out->core_clock, out->memory_clock, out->memory_bandwidth);
+    out->teraflops = 1e-9f * max_engine_clock_khz * info->cu_active_number * 64 * 2;
+    out->is_apu = info->ids_flags & AMDGPU_IDS_FLAGS_FUSION;
+    TRACE("teraflops %.2f.\n", out->teraflops);
+}
+
+static NTSTATUS get_device_info( void *args )
+{
+    struct get_device_info_params *params = args;
+    unsigned int i;
+
+    for (i = 0; i < device_count; ++i)
+    {
+        if (amd_info[i].device_id != params->device_id)
+            continue;
+        TRACE("device %04x found.\n", params->device_id);
+        fill_device_info(&amd_info[i], params);
+        return STATUS_SUCCESS;
+    }
+    TRACE("Device %04x not found.\n", params->device_id);
+    return STATUS_NOT_FOUND;
+}
+
+static NTSTATUS wow64_init( void *args )
+{
+    /* no args lmao */
+    return init(args);
+}
+
+static NTSTATUS wow64_get_device_info( void *args )
+{
+    /* everything should be same size on x64 and x86 */
+    return get_device_info(args);
+}
+
+const unixlib_entry_t __wine_unix_call_funcs[] =
+{
+    init,
+    get_device_info,
+};
+
+const unixlib_entry_t __wine_unix_call_wow64_funcs[] =
+{
+    wow64_init,
+    wow64_get_device_info,
+};
diff --git a/dlls/atiadlxx/unixlib.h b/dlls/atiadlxx/unixlib.h
new file mode 100644
index 00000000000..ebe038a1b00
--- /dev/null
+++ b/dlls/atiadlxx/unixlib.h
@@ -0,0 +1,61 @@
+/*
+ * Unix library interface
+ *
+ * Copyright 2023 Paul Gofman for CodeWeavers
+ * Copyright 2023 Etaash Mathamsetty
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdbool.h>
+#include "wine/unixlib.h"
+
+enum amd_ags_funcs
+{
+    unix_init,
+    unix_get_device_info,
+};
+
+typedef enum AsicFamily
+{
+    AsicFamily_Unknown,                                         ///< Unknown architecture, potentially from another IHV. Check \ref AGSDeviceInfo::vendorId
+    AsicFamily_PreGCN,                                          ///< Pre GCN architecture.
+    AsicFamily_GCN1,                                            ///< AMD GCN 1 architecture: Oland, Cape Verde, Pitcairn & Tahiti.
+    AsicFamily_GCN2,                                            ///< AMD GCN 2 architecture: Hawaii & Bonaire.  This also includes APUs Kaveri and Carrizo.
+    AsicFamily_GCN3,                                            ///< AMD GCN 3 architecture: Tonga & Fiji.
+    AsicFamily_GCN4,                                            ///< AMD GCN 4 architecture: Polaris.
+    AsicFamily_Vega,                                            ///< AMD Vega architecture, including Raven Ridge (ie AMD Ryzen CPU + AMD Vega GPU).
+    AsicFamily_RDNA,                                            ///< AMD RDNA architecture
+    AsicFamily_RDNA2,                                           ///< AMD RDNA2 architecture
+    AsicFamily_RDNA3,                                           ///< AMD RDNA3 architecture
+} AsicFamily;
+
+struct get_device_info_params
+{
+    uint32_t device_id;
+    uint32_t _pad;
+    /* Output parameters. */
+    uint32_t asic_family;
+    uint32_t num_cu;
+    uint32_t num_wgp;
+    uint32_t num_rops;
+    uint32_t core_clock;
+    uint32_t memory_clock;
+    uint32_t memory_bandwidth;
+    uint32_t min_core_clock;
+    uint32_t min_memory_clock;
+    bool is_apu;
+    float teraflops;
+};
diff --git a/dlls/atidxx64/Makefile.in b/dlls/atidxx64/Makefile.in
new file mode 100644
index 00000000000..e4c1d2875c8
--- /dev/null
+++ b/dlls/atidxx64/Makefile.in
@@ -0,0 +1,9 @@
+MODULE = atidxx64.dll
+IMPORTS = version vulkan-1 user32 gdi32
+IMPORTLIB = atidxx64
+
+EXTRADLLFLAGS = -mno-cygwin -Wb,--prefer-native
+
+SOURCES = \
+	main.c \
+	dxvk_interfaces.idl
diff --git a/dlls/atidxx64/atidxx.h b/dlls/atidxx64/atidxx.h
new file mode 100644
index 00000000000..b57776daafd
--- /dev/null
+++ b/dlls/atidxx64/atidxx.h
@@ -0,0 +1,137 @@
+#include "objbase.h"
+
+typedef struct
+{
+    unsigned int        majorVersion;
+    unsigned int        minorVersion;
+} AmdDxExtVersion;
+
+typedef enum
+{
+                                                       // D3D10_DDI_PRIMITIVE_TOPOLOGY_* values
+    AmdDxExtPrimitiveTopology_Undefined          = 0,  // D3D10 UNDEFINED
+    AmdDxExtPrimitiveTopology_PointList          = 1,  // D3D10 POINTLIST
+    AmdDxExtPrimitiveTopology_LineList           = 2,  // D3D10 LINELIST
+    AmdDxExtPrimitiveTopology_LineStrip          = 3,  // D3D10 LINESTRIP
+    AmdDxExtPrimitiveTopology_TriangleList       = 4,  // D3D10 TRIANGLELIST
+    AmdDxExtPrimitiveTopology_TriangleStrip      = 5,  // D3D10 TRIANGLESTRIP
+                                                       // 6 is reserved for legacy triangle fans
+    AmdDxExtPrimitiveTopology_ExtQuadList        = 7,  // No D3D10 equivalent
+    AmdDxExtPrimitiveTopology_ExtPatch           = 8,  // No D3D10 equivalent
+    AmdDxExtPrimitiveTopology_ExtScreenRectList  = 9,  // No D3D10 equivalent
+    AmdDxExtPrimitiveTopology_LineListAdj        = 10, // D3D10 LINELIST_ADJ
+    AmdDxExtPrimitiveTopology_LineStripAdj       = 11, // D3D10 LINESTRIP_ADJ
+    AmdDxExtPrimitiveTopology_TriangleListAdj    = 12, // D3D10 TRIANGLELIST_ADJ
+    AmdDxExtPrimitiveTopology_TriangleStripAdj   = 13, // D3D10 TRIANGLESTRIP_ADJ
+    AmdDxExtPrimitiveTopology_Max                = 14
+} AmdDxExtPrimitiveTopology;
+
+typedef enum
+{
+    AmdDxExtFeature_ScreenRectSupport           = 1, // Screen Rect supported - data is BOOL
+    AmdDxExtFeature_DeviceHp3d                  = 2, // HP3D support
+    AmdDxExtFeature_DeviceCtxSupport            = 3, // Device Ctx Support
+} AmdDxExtFeatureToken;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef __cplusplus
+#define THISCALLMETHOD_(type,method)  virtual type __thiscall method
+#else
+#define THISCALLMETHOD_(type,method)  type (__thiscall *method)
+#endif
+
+#define INTERFACE IAmdDxExtInterface
+DECLARE_INTERFACE(IAmdDxExtInterface)
+{
+    THISCALLMETHOD_(unsigned int, AddRef)(THIS) PURE;
+    THISCALLMETHOD_(unsigned int, Release)(THIS) PURE;
+};
+#undef INTERFACE
+
+#define INTERFACE IAmdDxExt
+DECLARE_INTERFACE_(IAmdDxExt, IAmdDxExtInterface)
+{
+    /*** IAmdDxExtInterface methods ***/
+    THISCALLMETHOD_(unsigned int, AddRef)(THIS) PURE;
+    THISCALLMETHOD_(unsigned int, Release)(THIS) PURE;
+
+    /*** IAmdDxExt methods ***/
+    THISCALLMETHOD_(HRESULT, IaGetPrimitiveTopology)(THIS_ AmdDxExtPrimitiveTopology *topology) PURE;
+    THISCALLMETHOD_(HRESULT, GetVersion)(THIS_ AmdDxExtVersion *version) PURE;
+    THISCALLMETHOD_(IAmdDxExtInterface*,GetExtInterface)(THIS_ unsigned int iface) PURE;
+
+
+    THISCALLMETHOD_(HRESULT, IaSetPrimitiveTopology)(THIS_ D3D_PRIMITIVE_TOPOLOGY topology) PURE;
+    THISCALLMETHOD_(HRESULT, SetSingleSampleRead)(THIS_ ID3D10Resource *res, BOOL single_sample) PURE;
+    THISCALLMETHOD_(HRESULT, SetSingleSampleRead11)(THIS_ ID3D11Resource *res, BOOL single_sample) PURE;
+    THISCALLMETHOD_(HRESULT, IaSetPrimitiveTopologyCtx)(THIS_ unsigned int topology, ID3D11DeviceContext *ctx) PURE;
+    THISCALLMETHOD_(HRESULT, QueryFeatureSupport)(THIS_ unsigned int feature_token, void *data, unsigned int data_size) PURE;
+    THISCALLMETHOD_(HRESULT, IaGetPrimitiveTopologyCtx)(THIS_ AmdDxExtPrimitiveTopology *topology, ID3D11DeviceContext *ctx) PURE;
+};
+#undef INTERFACE
+
+#define INTERFACE IAmdDxExtUAVOverlap
+DECLARE_INTERFACE_(IAmdDxExtUAVOverlap, IAmdDxExtInterface)
+{
+    /*** IAmdDxExtInterface methods ***/
+    THISCALLMETHOD_(unsigned int, AddRef)(THIS) PURE;
+    THISCALLMETHOD_(unsigned int, Release)(THIS) PURE;
+
+    /*** IAmdDxExtUAVOverlap methods ***/
+    THISCALLMETHOD_(void, Unk1)(THIS) PURE;
+    THISCALLMETHOD_(HRESULT, BeginUAVOverlap)(THIS) PURE;
+    THISCALLMETHOD_(HRESULT, EndUAVOverlap)(THIS) PURE;
+    THISCALLMETHOD_(void, GetVersion)(THIS, AmdDxExtVersion* version) PURE;
+};
+#undef INTERFACE
+
+#define INTERFACE IAmdDxExtQuadBufferStereo
+DECLARE_INTERFACE_(IAmdDxExtQuadBufferStereo, IAmdDxExtInterface)
+{
+    /*** IAmdDxExtInterface methods ***/
+    THISCALLMETHOD_(unsigned int, AddRef)(THIS) PURE;
+    THISCALLMETHOD_(unsigned int, Release)(THIS) PURE;
+
+    /*** IAmdDxExtQuadBufferStereo methods ***/
+    THISCALLMETHOD_(HRESULT, EnableQuadBufferStereo)(THIS, BOOL enable) PURE;
+    THISCALLMETHOD_(UINT, GetLineOffset)(THIS, IDXGISwapChain *swapchain) PURE;
+    THISCALLMETHOD_(HRESULT, GetDisplayModeList)(THIS, DXGI_FORMAT format, unsigned int flags, unsigned int *num_modes, DXGI_MODE_DESC *desc) PURE;
+};
+#undef INTERFACE
+
+#define INTERFACE IAmdDxExtDepthBounds
+DECLARE_INTERFACE_(IAmdDxExtDepthBounds, IAmdDxExtInterface)
+{
+    /*** IAmdDxExtInterface methods ***/
+    THISCALLMETHOD_(unsigned int, AddRef)(THIS) PURE;
+    THISCALLMETHOD_(unsigned int, Release)(THIS) PURE;
+
+    /*** IAmdDxExtDepthBounds methods ***/
+    THISCALLMETHOD_(void, Unk1)(THIS) PURE;
+    THISCALLMETHOD_(HRESULT, SetDepthBounds)(THIS, BOOL enabled, float min, float max) PURE;
+    THISCALLMETHOD_(void, GetVersion)(THIS, AmdDxExtVersion *version) PURE;
+};
+#undef INTERFACE
+
+#define INTERFACE IAmdDxExtMultidrawIndirect
+DECLARE_INTERFACE_(IAmdDxExtMultidrawIndirect, IAmdDxExtInterface)
+{
+    /*** IAmdDxExtInterface methods ***/
+    THISCALLMETHOD_(unsigned int, AddRef)(THIS) PURE;
+    THISCALLMETHOD_(unsigned int, Release)(THIS) PURE;
+
+    /*** IAmdDxExtMultidrawIndirect methods ***/
+    THISCALLMETHOD_(void, Unk1)(THIS) PURE;
+    THISCALLMETHOD_(void, GetVersion)(THIS, AmdDxExtVersion *version) PURE;
+    THISCALLMETHOD_(HRESULT, MultiDrawIndirect)(THIS, unsigned int draw_count, ID3D11Buffer *buffer, unsigned int byte_offset, unsigned int byte_stride) PURE;
+    THISCALLMETHOD_(HRESULT, MultiDrawIndexedIndirect)(THIS, unsigned int draw_count, ID3D11Buffer *buffer, unsigned int byte_offset, unsigned int byte_stride) PURE;
+    THISCALLMETHOD_(HRESULT, MultiDrawIndirectCount)(THIS, ID3D11Buffer *buffer_for_count, unsigned int byte_offset_for_count, ID3D11Buffer *buffer, unsigned int byte_offset, unsigned int byte_stride) PURE;
+    THISCALLMETHOD_(HRESULT, MultiDrawIndexedIndirectCount)(THIS, ID3D11Buffer *buffer_for_count, unsigned int byte_offset_for_count, ID3D11Buffer *buffer, unsigned int byte_offset, unsigned int byte_stride) PURE;
+};
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/dlls/atidxx64/atidxx64.spec b/dlls/atidxx64/atidxx64.spec
new file mode 100644
index 00000000000..4012dcb0303
--- /dev/null
+++ b/dlls/atidxx64/atidxx64.spec
@@ -0,0 +1,17 @@
+@ stub AmdD3D11CreateDevice
+@ stub AmdD3D11CreateDeviceAndSwapChain
+@ stub AmdD3D11CreateDeviceAndSwapChainExt()
+@ stdcall AmdD3D11CreateDeviceExt(ptr long ptr long ptr long long ptr ptr ptr ptr)
+@ cdecl AmdDxExtCreate11(ptr ptr)
+@ stub AmdDxExtCreate
+@ stub AmdDxShimQueryInterface
+@ stub XdxInitXopAdapterServices
+@ stub XdxInitXopServices
+@ stub XdxQueryTlsLookupTable
+@ stub AmdDxGsaCompileShader
+@ stub AmdDxGsaFreeCompiledShader
+@ stub AmdGetDxxModuleHandle
+@ stub AmdLiquidVrAffinityInit
+@ stub AmdLiquidVrAffinityTerm
+@ stub AmdLiquidVrD3D11CreateDevice
+@ stub AmdLiquidVrD3D11WrapDeviceContext
diff --git a/dlls/atidxx64/dxvk_interfaces.idl b/dlls/atidxx64/dxvk_interfaces.idl
new file mode 100644
index 00000000000..9e405a32a06
--- /dev/null
+++ b/dlls/atidxx64/dxvk_interfaces.idl
@@ -0,0 +1,153 @@
+/*
+ * Copyright 2023      Paul Gofman for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#pragma makedep register
+
+import "d3d11.idl";
+import "dxgi1_6.idl";
+
+typedef struct VkInstance_T *VkInstance;
+typedef void (__stdcall *PFN_vkVoidFunction)(void);
+typedef PFN_vkVoidFunction (__stdcall *PFN_vkGetInstanceProcAddr)(VkInstance instance, const char* pName);
+
+typedef enum D3D11_VK_EXTENSION
+{
+    D3D11_VK_EXT_MULTI_DRAW_INDIRECT,
+    D3D11_VK_EXT_MULTI_DRAW_INDIRECT_COUNT,
+    D3D11_VK_EXT_DEPTH_BOUNDS,
+    D3D11_VK_EXT_BARRIER_CONTROL,
+    D3D11_VK_NVX_BINARY_IMPORT,
+    D3D11_VK_NVX_IMAGE_VIEW_HANDLE,
+} D3D11_VK_EXTENSION;
+
+typedef enum D3D11_VK_BARRIER_CONTROL
+{
+    D3D11_VK_BARRIER_CONTROL_IGNORE_WRITE_AFTER_WRITE = 0x1,
+    D3D11_VK_BARRIER_CONTROL_IGNORE_GRAPHICS_UAV = 0x2,
+} D3D11_VK_BARRIER_CONTROL;
+
+[
+    object,
+    uuid(bb8a4fb9-3935-4762-b44b-35189a26414a),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtShader : IUnknown
+{
+    HRESULT GetSpirvCode([in, out] SIZE_T *code_size, [out] void *code);
+}
+
+[
+    object,
+    uuid(8a6e3c42-f74c-45b7-8265-a231b677ca17),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtDevice : IUnknown
+{
+    BOOL GetExtensionSupport([in] D3D11_VK_EXTENSION extension);
+}
+
+[
+    object,
+    uuid(cfcf64ef-9586-46d0-bca4-97cf2ca61b06),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtDevice1 : ID3D11VkExtDevice
+{
+    BOOL GetResourceHandleGPUVirtualAddressAndSizeNVX([in] void *object, [out] UINT64 *gpu_va_start,
+            [out] UINT64 *gpu_va_size);
+    BOOL CreateUnorderedAccessViewAndGetDriverHandleNVX([in] ID3D11Resource *resource,
+            [in] const D3D11_UNORDERED_ACCESS_VIEW_DESC *desc, [out] ID3D11UnorderedAccessView **uav,
+            UINT32 *driver_handle);
+    BOOL CreateShaderResourceViewAndGetDriverHandleNVX([in] ID3D11Resource *resource,
+            [in] const D3D11_SHADER_RESOURCE_VIEW_DESC* desc, [out] ID3D11ShaderResourceView **srv,
+            UINT32 *dirver_handle);
+    BOOL CreateSamplerStateAndGetDriverHandleNVX([in] const D3D11_SAMPLER_DESC *sample_desc,
+            [out] ID3D11SamplerState **sample_state, UINT32 *driver_handle);
+    BOOL CreateCubinComputeShaderWithNameNVX([in] const void *cubin, [in] UINT32 size, [in] UINT32 block_x,
+            [in] UINT32 block_y, [in] UINT32 block_z, [in] const char *shader_name, [out] IUnknown **shader);
+    BOOL GetCudaTextureObjectNVX([in] UINT32 srv_driver_hadnle, [in] UINT32 sample_driver_handle,
+            [out] UINT32 *cuda_texture_handle);
+}
+
+[
+    object,
+    uuid(fd0bca13-5cb6-4c3a-987e-4750de2ca791),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtContext : IUnknown
+{
+    void MultiDrawIndirect([in] UINT draw_count, [in] ID3D11Buffer *buffer_for_args, [in] UINT byte_offset_for_args,
+            [in] UINT byte_stride_for_args);
+    void MultiDrawIndexedIndirect([in] UINT draw_count, [in] ID3D11Buffer *buffer_for_args,
+            [in] UINT byte_offset_for_args, [in] UINT byte_stride_for_args);
+    void MultiDrawIndirectCount([in] UINT max_draw_count, [in] ID3D11Buffer *buffer_for_count,
+            [in] UINT byte_offset_for_count, [in] ID3D11Buffer *buffer_for_args,
+            [in] UINT byte_offset_for_args, [in] UINT byte_stride_for_args);
+    void MultiDrawIndexedIndirectCount([in] UINT max_draw_count, [in] ID3D11Buffer *buffer_for_count,
+            [in] UINT byte_offset_for_count, [in] ID3D11Buffer *buffer_for_args,
+            [in] UINT byte_offset_for_args, [in] UINT byte_stride_for_args);
+    void SetDepthBoundsTest([in] BOOL enable, [in] FLOAT min_depth_bounds, [in] FLOAT max_depth_bounds);
+    void SetBarrierControl([in] UINT control_flags);
+}
+
+[
+    object,
+    uuid(874b09b2-ae0b-41d8-8476-5f3b7a0e879d),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtContext1 : ID3D11VkExtContext
+{
+    BOOL LaunchCubinShaderNVX([in] IUnknown *shader,[in] UINT32 grid_x, [in] UINT32 grid_y, [in] UINT32 grid_z,
+            [in] const void *params, [in] UINT32 param_size, [in] void * const *read_resources,
+            [in] UINT32 read_resource_count, [in] void* const *write_resources, [in] UINT32 write_resources_count);
+}
+
+[
+    object,
+    uuid(4c5e1b0d-b0c8-4131-bfd8-9b2476f7f408),
+    local,
+    pointer_default(unique)
+]
+interface IDXGIVkInteropFactory : IUnknown
+{
+    void GetVulkanInstance(
+          [out] VkInstance *pInstance,
+          [out] PFN_vkGetInstanceProcAddr *ppfnVkGetInstanceProcAddr);
+}
+
+[
+    object,
+    uuid(2a289dbd-2d0a-4a51-89f7-f2adce465cd6),
+    local,
+    pointer_default(unique)
+]
+interface IDXGIVkInteropFactory1 : IDXGIVkInteropFactory
+{
+  HRESULT GetGlobalHDRState(
+          [out] DXGI_COLOR_SPACE_TYPE   *pOutColorSpace,
+          [out] DXGI_HDR_METADATA_HDR10 *ppOutMetadata) = 0;
+
+  HRESULT SetGlobalHDRState(
+          [in] DXGI_COLOR_SPACE_TYPE    ColorSpace,
+    [in] const DXGI_HDR_METADATA_HDR10 *pMetadata) = 0;
+}
diff --git a/dlls/atidxx64/main.c b/dlls/atidxx64/main.c
new file mode 100644
index 00000000000..5d4def2d383
--- /dev/null
+++ b/dlls/atidxx64/main.c
@@ -0,0 +1,677 @@
+/*
+ * atidxx64 implementation
+ *
+ * Copyright 2023 Etaash Mathamsetty
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdarg.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winbase.h"
+#include "winternl.h"
+#include "wine/debug.h"
+#include "wine/heap.h"
+
+#include "wine/vulkan.h"
+#include "wine/asm.h"
+
+#define COBJMACROS
+#include "initguid.h"
+#include "d3d11.h"
+#include "d3d12.h"
+
+#include "dxgi1_6.h"
+
+#include "dxvk_interfaces.h"
+#include "atidxx.h"
+
+#include <wingdi.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(atidxx);
+
+static HMODULE d3d11_module;
+static HRESULT (WINAPI *pD3D11CreateDevice)(IDXGIAdapter *adapter, D3D_DRIVER_TYPE driver_type,
+        HMODULE swrast, UINT flags, const D3D_FEATURE_LEVEL *feature_levels, UINT levels,
+        UINT sdk_version, ID3D11Device **device_out, D3D_FEATURE_LEVEL *obtained_feature_level,
+        ID3D11DeviceContext **immediate_context);
+
+typedef void (*vtable_ptr)(void);
+
+static HRESULT load_d3d11(void)
+{
+    if (!d3d11_module)
+        d3d11_module = LoadLibraryA("d3d11.dll");
+
+    if (!d3d11_module)
+    {
+        ERR("Failed to load d3d11.dll\n");
+        return E_FAIL;
+    }
+
+    return S_OK;
+}
+
+
+HRESULT WINAPI AmdD3D11CreateDeviceExt(IDXGIAdapter *adapter, D3D_DRIVER_TYPE driver_type, HMODULE swrast, UINT flags,
+        const D3D_FEATURE_LEVEL *feature_levels, UINT levels, UINT sdk_version, ID3D11Device **device_out,
+        D3D_FEATURE_LEVEL *obtained_feature_level, ID3D11DeviceContext **immediate_context, void *unk)
+{
+    HRESULT ret;
+    FIXME("%p semi-stub\n", unk);
+
+    if ((ret = load_d3d11()))
+        return ret;
+
+    if (!pD3D11CreateDevice)
+        pD3D11CreateDevice = (void*)GetProcAddress(d3d11_module, "D3D11CreateDevice");
+
+    return pD3D11CreateDevice(adapter, driver_type, swrast, flags, feature_levels, levels, sdk_version,
+            device_out, obtained_feature_level, immediate_context);
+}
+
+/*
+    Ext Ifaces to implement:
+    field_0x170 = 0x11
+    field_0x190 = 0x17
+    field_0x188 = 0x15
+    field_0x178 = 0x14
+    field_0x1a0 = 0x1d
+    field_0x168 = 0xb
+    field_0x160 = 0xf
+    field_0x198 = 0x17
+ */
+
+/* field_0x160 (0xf)
+
+    0x0 = AddRef
+    0x8 = Release
+    0x10 = ??
+    0x18 = BeginUAVOverlap
+    0x20 = EndUAVOverlap
+    0x28 = GetVersion (called on init, prob some kind of version getter)
+
+*/
+
+/* field_0x168 (0xb)
+    0x0 = AddRef
+    0x8 = Release
+    0x10 = ??
+    0x18 = SetDepthBounds
+    0x20 = GetVersion
+*/
+
+/* field_0x170 (0x11)
+    0x0 = AddRef
+    0x8 = Release
+    0x10 = ??
+    0x18 = GetVersion
+    0x20 = MultiDrawIndirect
+    0x28 = MultiDrawIndexedIndirect
+    0x30 = MultiDrawIndirectCount
+    0x38 = MultiDrawIndexedIndirectCount
+*/
+
+typedef struct
+{
+    IAmdDxExt IAmdDxExt_iface;
+    IAmdDxExtUAVOverlap IAmdDxExtUAVOverlap_iface;
+    IAmdDxExtQuadBufferStereo IAmdDxExtQuadBufferStereo_iface;
+    IAmdDxExtDepthBounds IAmdDxExtDepthBounds_iface;
+    IAmdDxExtMultidrawIndirect IAmdDxExtMultidrawIndirect_iface;
+    LONG ref;
+    //could also be a d3d10 device, just cast
+    ID3D11Device *device;
+    ID3D11DeviceContext *context;
+    ID3D11VkExtContext *ext_context;
+    BOOL is_d3d11;
+    BOOL uav_overlap;
+    BOOL depth_bounds;
+    BOOL multi_draw_indirect;
+    BOOL multi_draw_indirect_count;
+} AmdDxExt;
+
+static inline AmdDxExt *impl_from_IAmdDxExt(IAmdDxExt *iface)
+{
+    return CONTAINING_RECORD(iface, AmdDxExt, IAmdDxExt_iface);
+}
+
+static inline AmdDxExt *impl_from_IAmdDxExtUAVOverlap(IAmdDxExtUAVOverlap *iface)
+{
+    return CONTAINING_RECORD(iface, AmdDxExt, IAmdDxExtUAVOverlap_iface);
+}
+
+static inline AmdDxExt *impl_from_IAmdDxExtQuadBufferStereo(IAmdDxExtQuadBufferStereo *iface)
+{
+    return CONTAINING_RECORD(iface, AmdDxExt, IAmdDxExtQuadBufferStereo_iface);
+}
+
+static inline AmdDxExt *impl_from_IAmdDxExtDepthBounds(IAmdDxExtDepthBounds *iface)
+{
+    return CONTAINING_RECORD(iface, AmdDxExt, IAmdDxExtDepthBounds_iface);
+}
+
+static inline AmdDxExt *impl_from_IAmdDxExtMultidrawIndirect(IAmdDxExtMultidrawIndirect *iface)
+{
+    return CONTAINING_RECORD(iface, AmdDxExt, IAmdDxExtMultidrawIndirect_iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_AddRef, 4)
+unsigned int __thiscall AmdDxExt_AddRef(IAmdDxExt *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExt(iface);
+    return InterlockedIncrement(&This->ref);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_Release, 4)
+unsigned int __thiscall AmdDxExt_Release(IAmdDxExt *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExt(iface);
+    LONG ref = InterlockedDecrement(&This->ref);
+    if(ref == 0)
+    {
+        if(This->is_d3d11)
+        {
+            ID3D11Device_Release(This->device);
+            ID3D11DeviceContext_Release(This->context);
+            ID3D11VkExtContext_Release(This->ext_context);
+        }
+        free(This);
+    }
+    return ref;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_GetVersion, 8)
+HRESULT __thiscall AmdDxExt_GetVersion(IAmdDxExt *ext, AmdDxExtVersion *version)
+{
+    FIXME("%p %p\n", ext, version);
+
+    version->majorVersion = 1;
+    version->minorVersion = 0;
+
+    return S_OK;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtUAVOverlap_AddRef, 4)
+unsigned int __thiscall AmdDxExtUAVOverlap_AddRef(IAmdDxExtUAVOverlap *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtUAVOverlap(iface);
+    return AmdDxExt_AddRef(&This->IAmdDxExt_iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtUAVOverlap_Release, 4)
+unsigned int __thiscall AmdDxExtUAVOverlap_Release(IAmdDxExtUAVOverlap *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtUAVOverlap(iface);
+    return AmdDxExt_Release(&This->IAmdDxExt_iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_GetExtInterface, 8)
+IAmdDxExtInterface* __thiscall AmdDxExt_GetExtInterface(IAmdDxExt *ext, unsigned int iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExt(ext);
+    IAmdDxExtInterface *ret = NULL;
+    TRACE("%p %x\n", ext, iface);
+
+    switch(iface)
+    {
+        case 0x2:
+            ret = (IAmdDxExtInterface *)&This->IAmdDxExtQuadBufferStereo_iface;
+            break;
+        case 0xb:
+            ret = (IAmdDxExtInterface *)&This->IAmdDxExtDepthBounds_iface;
+            break;
+        case 0xf:
+            ret = (IAmdDxExtInterface *)&This->IAmdDxExtUAVOverlap_iface;
+            break;
+        case 0x11:
+            ret = (IAmdDxExtInterface *)&This->IAmdDxExtMultidrawIndirect_iface;
+            break;
+        default:
+        {
+            FIXME("Unknown interface %x\n", iface);
+            break;
+        }
+    }
+
+    if (ret)
+    {
+        AmdDxExt_AddRef(ext);
+    }
+
+    return ret;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_IaSetPrimitiveTopology, 8)
+HRESULT __thiscall AmdDxExt_IaSetPrimitiveTopology(IAmdDxExt *ext, D3D_PRIMITIVE_TOPOLOGY topology)
+{
+    AmdDxExt *This = impl_from_IAmdDxExt(ext);
+    TRACE("%p %u\n", ext, topology);
+
+    if(This->is_d3d11)
+    {
+        ID3D11DeviceContext_IASetPrimitiveTopology(This->context, topology);
+    }
+
+    return S_OK;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_IaGetPrimitiveTopology, 8)
+HRESULT __thiscall AmdDxExt_IaGetPrimitiveTopology(IAmdDxExt *ext, AmdDxExtPrimitiveTopology *topology)
+{
+    FIXME("%p %p stub\n", ext, topology);
+
+    return E_NOTIMPL;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_SetSingleSampleRead, 12)
+HRESULT __thiscall AmdDxExt_SetSingleSampleRead(IAmdDxExt *iface, ID3D10Resource *res, BOOL single_sample)
+{
+    FIXME("%p %p %u stub\n", iface, res, single_sample);
+
+    return E_NOTIMPL;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_SetSingleSampleRead11, 12)
+HRESULT __thiscall AmdDxExt_SetSingleSampleRead11(IAmdDxExt *iface, ID3D11Resource *res, BOOL single_sample)
+{
+    FIXME("%p %p %u stub\n", iface, res, single_sample);
+
+    return E_NOTIMPL;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_QueryFeatureSupport, 16)
+HRESULT __thiscall AmdDxExt_QueryFeatureSupport(IAmdDxExt *iface, unsigned int feature_token, void *data, unsigned int data_size)
+{
+    FIXME("%p %u %p %u stub\n", iface, feature_token, data, data_size);
+
+    return E_NOTIMPL;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_IaSetPrimitiveTopologyCtx, 12)
+HRESULT __thiscall AmdDxExt_IaSetPrimitiveTopologyCtx(IAmdDxExt *iface, unsigned int topology, ID3D11DeviceContext *ctx)
+{
+    FIXME("%p %u %p stub\n", iface, topology, ctx);
+
+    return E_NOTIMPL;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExt_IaGetPrimitiveTopologyCtx, 12)
+HRESULT __thiscall AmdDxExt_IaGetPrimitiveTopologyCtx(IAmdDxExt *iface, AmdDxExtPrimitiveTopology *topology, ID3D11DeviceContext *ctx)
+{
+    FIXME("%p %p %p stub\n", iface, topology, ctx);
+
+    return E_NOTIMPL;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtUAVOverlap_Unk1, 4)
+void __thiscall AmdDxExtUAVOverlap_Unk1(IAmdDxExtUAVOverlap *iface)
+{
+    FIXME("%p stub\n", iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtUAVOverlap_BeginUAVOverlap, 4)
+HRESULT __thiscall AmdDxExtUAVOverlap_BeginUAVOverlap(IAmdDxExtUAVOverlap *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtUAVOverlap(iface);
+    TRACE("%p\n", iface);
+
+    if (!This->ext_context) return E_FAIL;
+
+    if (!This->uav_overlap) return E_FAIL;
+
+    ID3D11VkExtContext_SetBarrierControl(This->ext_context, D3D11_VK_BARRIER_CONTROL_IGNORE_WRITE_AFTER_WRITE);
+
+    return S_OK;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtUAVOverlap_EndUAVOverlap, 4)
+HRESULT __thiscall AmdDxExtUAVOverlap_EndUAVOverlap(IAmdDxExtUAVOverlap *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtUAVOverlap(iface);
+    TRACE("%p\n", iface);
+
+    if (!This->ext_context) return E_FAIL;
+
+    if (!This->uav_overlap) return E_FAIL;
+
+    ID3D11VkExtContext_SetBarrierControl(This->ext_context, 0);
+
+    return S_OK;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtUAVOverlap_GetVersion, 8)
+void __thiscall AmdDxExtUAVOverlap_GetVersion(IAmdDxExtUAVOverlap *iface, AmdDxExtVersion* version)
+{
+    FIXME("%p %p stub!\n", iface, version);
+    version->majorVersion = 1;
+    version->minorVersion = 0;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtQuadBufferStereo_AddRef, 4)
+unsigned int __thiscall AmdDxExtQuadBufferStereo_AddRef(IAmdDxExtQuadBufferStereo *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtQuadBufferStereo(iface);
+    return AmdDxExt_AddRef(&This->IAmdDxExt_iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtQuadBufferStereo_Release, 4)
+unsigned int __thiscall AmdDxExtQuadBufferStereo_Release(IAmdDxExtQuadBufferStereo *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtQuadBufferStereo(iface);
+    return AmdDxExt_Release(&This->IAmdDxExt_iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtQuadBufferStereo_EnableQuadBufferStereo, 8)
+HRESULT __thiscall AmdDxExtQuadBufferStereo_EnableQuadBufferStereo(IAmdDxExtQuadBufferStereo *iface, BOOL enable)
+{
+    FIXME("%p %u stub\n", iface, enable);
+
+    return E_NOTIMPL;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtQuadBufferStereo_GetDisplayModeList, 20)
+HRESULT __thiscall AmdDxExtQuadBufferStereo_GetDisplayModeList(IAmdDxExtQuadBufferStereo *iface, DXGI_FORMAT format, UINT flags, UINT *num_modes, DXGI_MODE_DESC *desc)
+{
+    FIXME("%p %u %u %p %p stub\n", iface, format, flags, num_modes, desc);
+
+    if (!num_modes) return E_INVALIDARG;
+
+    *num_modes = 0;
+
+    return S_OK;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtQuadBufferStereo_GetLineOffset, 8)
+UINT __thiscall AmdDxExtQuadBufferStereo_GetLineOffset(IAmdDxExtQuadBufferStereo *iface, IDXGISwapChain *swapchain)
+{
+    FIXME("%p %p stub\n", iface, swapchain);
+
+    return 0;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtDepthBounds_AddRef, 4)
+unsigned int __thiscall AmdDxExtDepthBounds_AddRef(IAmdDxExtDepthBounds *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtDepthBounds(iface);
+    return AmdDxExt_AddRef(&This->IAmdDxExt_iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtDepthBounds_Release, 4)
+unsigned int __thiscall AmdDxExtDepthBounds_Release(IAmdDxExtDepthBounds *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtDepthBounds(iface);
+    return AmdDxExt_Release(&This->IAmdDxExt_iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtDepthBounds_GetVersion, 8)
+void __thiscall AmdDxExtDepthBounds_GetVersion(IAmdDxExtDepthBounds *iface, AmdDxExtVersion* version)
+{
+    FIXME("%p %p stub!\n", iface, version);
+    version->majorVersion = 1;
+    version->minorVersion = 0;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtDepthBounds_SetDepthBounds, 16)
+HRESULT __thiscall AmdDxExtDepthBounds_SetDepthBounds(IAmdDxExtDepthBounds *iface, BOOL enabled, float min, float max)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtDepthBounds(iface);
+
+    TRACE("%p %u %f %f\n", iface, enabled, min, max);
+
+    if (!This->ext_context) return E_FAIL;
+
+    if (!This->depth_bounds) return E_FAIL;
+
+    ID3D11VkExtContext_SetDepthBoundsTest(This->ext_context, enabled, min, max);
+
+    return S_OK;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtDepthBounds_Unk1, 4)
+void __thiscall AmdDxExtDepthBounds_Unk1(IAmdDxExtDepthBounds *iface)
+{
+    FIXME("%p stub\n", iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtMultidrawIndirect_AddRef, 4)
+unsigned int __thiscall AmdDxExtMultidrawIndirect_AddRef(IAmdDxExtMultidrawIndirect *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtMultidrawIndirect(iface);
+    return AmdDxExt_AddRef(&This->IAmdDxExt_iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtMultidrawIndirect_Release, 4)
+unsigned int __thiscall AmdDxExtMultidrawIndirect_Release(IAmdDxExtMultidrawIndirect *iface)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtMultidrawIndirect(iface);
+    return AmdDxExt_Release(&This->IAmdDxExt_iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtMultidrawIndirect_Unk1, 4)
+void __thiscall AmdDxExtMultidrawIndirect_Unk1(IAmdDxExtMultidrawIndirect *iface)
+{
+    FIXME("%p stub\n", iface);
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtMultidrawIndirect_GetVersion, 8)
+void __thiscall AmdDxExtMultidrawIndirect_GetVersion(IAmdDxExtMultidrawIndirect *iface, AmdDxExtVersion* version)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtMultidrawIndirect(iface);
+    FIXME("%p %p semi-stub!\n", iface, version);
+    version->majorVersion = 1;
+    /* needed for indirect count */
+    version->minorVersion = This->multi_draw_indirect_count ? 2 : 0;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtMultidrawIndirect_MultiDrawIndirect, 20)
+HRESULT __thiscall AmdDxExtMultidrawIndirect_MultiDrawIndirect(IAmdDxExtMultidrawIndirect *iface, unsigned int draw_count, ID3D11Buffer *buffer, unsigned int byte_offset, unsigned int byte_stride)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtMultidrawIndirect(iface);
+    TRACE("%p %u %p %u %u\n", iface, draw_count, buffer, byte_offset, byte_stride);
+
+    if (!This->ext_context) return E_FAIL;
+
+    if (!This->multi_draw_indirect) return E_FAIL;
+
+    ID3D11VkExtContext_MultiDrawIndirect(This->ext_context, draw_count, buffer, byte_offset, byte_stride);
+
+    return S_OK;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxExtMultidrawIndirect_MultiDrawIndexedIndirect, 20)
+HRESULT __thiscall AmdDxExtMultidrawIndirect_MultiDrawIndexedIndirect(IAmdDxExtMultidrawIndirect *iface, unsigned int draw_count, ID3D11Buffer *buffer, unsigned int byte_offset, unsigned int byte_stride)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtMultidrawIndirect(iface);
+    TRACE("%p %u %p %u %u\n", iface, draw_count, buffer, byte_offset, byte_stride);
+
+    if (!This->ext_context) return E_FAIL;
+
+    if (!This->multi_draw_indirect) return E_FAIL;
+
+    ID3D11VkExtContext_MultiDrawIndexedIndirect(This->ext_context, draw_count, buffer, byte_offset, byte_stride);
+
+    return S_OK;
+}
+
+static unsigned int get_max_draw_count(ID3D11Buffer *buffer, unsigned int offset, unsigned int stride, unsigned int size)
+{
+    D3D11_BUFFER_DESC desc;
+    unsigned int count;
+
+    ID3D11Buffer_GetDesc(buffer, &desc);
+
+    if(offset >= desc.ByteWidth)
+    {
+        WARN("Offset %u, buffer size %u.", offset, desc.ByteWidth);
+        return 0;
+    }
+
+    count = (desc.ByteWidth - offset) / stride;
+    if (desc.ByteWidth - offset - count * stride >= size)
+        ++count;
+
+    if (!count)
+        WARN("zero count, buffer size %u, offset %u, stride %u, size %u.\n", desc.ByteWidth, offset, stride, size);
+
+    return count;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxextMultiDrawIndirect_MultiDrawIndirectCount, 24)
+HRESULT __thiscall AmdDxextMultiDrawIndirect_MultiDrawIndirectCount(IAmdDxExtMultidrawIndirect *iface, ID3D11Buffer *buffer_for_count, unsigned int byte_offset_for_count, ID3D11Buffer *buffer, unsigned int byte_offset, unsigned int byte_stride)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtMultidrawIndirect(iface);
+    unsigned int max_draw_count;
+    TRACE("%p %p %u %p %u %u\n", iface, buffer_for_count, byte_offset_for_count, buffer, byte_offset, byte_stride);
+
+    if (!This->ext_context) return E_FAIL;
+
+    if (!This->multi_draw_indirect_count) return E_FAIL;
+
+    max_draw_count = get_max_draw_count(buffer, byte_offset, byte_stride, sizeof(D3D11_DRAW_INDEXED_INSTANCED_INDIRECT_ARGS));
+
+    ID3D11VkExtContext_MultiDrawIndirectCount(This->ext_context, max_draw_count, buffer_for_count, byte_offset_for_count, buffer, byte_offset, byte_stride);
+
+    return S_OK;
+}
+
+DEFINE_THISCALL_WRAPPER(AmdDxextMultiDrawIndirect_MultiDrawIndexedIndirectCount, 24)
+HRESULT __thiscall AmdDxextMultiDrawIndirect_MultiDrawIndexedIndirectCount(IAmdDxExtMultidrawIndirect *iface, ID3D11Buffer *buffer_for_count, unsigned int byte_offset_for_count, ID3D11Buffer *buffer, unsigned int byte_offset, unsigned int byte_stride)
+{
+    AmdDxExt *This = impl_from_IAmdDxExtMultidrawIndirect(iface);
+    unsigned int max_draw_count;
+    TRACE("%p %p %u %p %u %u\n", iface, buffer_for_count, byte_offset_for_count, buffer, byte_offset, byte_stride);
+
+    if (!This->ext_context) return E_FAIL;
+
+    if (!This->multi_draw_indirect_count) return E_FAIL;
+
+    max_draw_count = get_max_draw_count(buffer, byte_offset, byte_stride, sizeof(D3D11_DRAW_INDEXED_INSTANCED_INDIRECT_ARGS));
+
+    ID3D11VkExtContext_MultiDrawIndexedIndirectCount(This->ext_context, max_draw_count, buffer_for_count, byte_offset_for_count, buffer, byte_offset, byte_stride);
+
+    return S_OK;
+}
+
+static const IAmdDxExtUAVOverlapVtbl amddxext_uav_vtable =
+{
+    THISCALL(AmdDxExtUAVOverlap_AddRef),
+    THISCALL(AmdDxExtUAVOverlap_Release),
+    THISCALL(AmdDxExtUAVOverlap_Unk1),
+    THISCALL(AmdDxExtUAVOverlap_BeginUAVOverlap),
+    THISCALL(AmdDxExtUAVOverlap_EndUAVOverlap),
+    THISCALL(AmdDxExtUAVOverlap_GetVersion)
+};
+
+static const IAmdDxExtVtbl AmdDxExt_vtable =
+{
+    THISCALL(AmdDxExt_AddRef), //0
+    THISCALL(AmdDxExt_Release), //0x8
+    THISCALL(AmdDxExt_IaGetPrimitiveTopology), // 0x10 ??
+    THISCALL(AmdDxExt_GetVersion), //0x18
+    THISCALL(AmdDxExt_GetExtInterface), //0x20
+    THISCALL(AmdDxExt_IaSetPrimitiveTopology), //0x28
+    THISCALL(AmdDxExt_SetSingleSampleRead), //0x30 ??
+    THISCALL(AmdDxExt_SetSingleSampleRead11), //0x38 ??
+    THISCALL(AmdDxExt_IaSetPrimitiveTopologyCtx), //0x40 ??
+    THISCALL(AmdDxExt_QueryFeatureSupport), //0x48
+    THISCALL(AmdDxExt_IaGetPrimitiveTopologyCtx) //0x50 ??
+};
+
+static const IAmdDxExtQuadBufferStereoVtbl quadbufstereo_vtable =
+{
+    THISCALL(AmdDxExtQuadBufferStereo_AddRef),
+    THISCALL(AmdDxExtQuadBufferStereo_Release),
+    THISCALL(AmdDxExtQuadBufferStereo_EnableQuadBufferStereo),
+    THISCALL(AmdDxExtQuadBufferStereo_GetLineOffset),
+    THISCALL(AmdDxExtQuadBufferStereo_GetDisplayModeList),
+};
+
+static const IAmdDxExtDepthBoundsVtbl amddxext_depth_vtable =
+{
+    THISCALL(AmdDxExtDepthBounds_AddRef),
+    THISCALL(AmdDxExtDepthBounds_Release),
+    THISCALL(AmdDxExtDepthBounds_Unk1),
+    THISCALL(AmdDxExtDepthBounds_SetDepthBounds),
+    THISCALL(AmdDxExtDepthBounds_GetVersion)
+};
+
+static const IAmdDxExtMultidrawIndirectVtbl amddxext_multidraw_vtable =
+{
+    THISCALL(AmdDxExtMultidrawIndirect_AddRef),
+    THISCALL(AmdDxExtMultidrawIndirect_Release),
+    THISCALL(AmdDxExtMultidrawIndirect_Unk1),
+    THISCALL(AmdDxExtMultidrawIndirect_GetVersion),
+    THISCALL(AmdDxExtMultidrawIndirect_MultiDrawIndirect),
+    THISCALL(AmdDxExtMultidrawIndirect_MultiDrawIndexedIndirect),
+    THISCALL(AmdDxextMultiDrawIndirect_MultiDrawIndirectCount),
+    THISCALL(AmdDxextMultiDrawIndirect_MultiDrawIndexedIndirectCount)
+};
+
+HRESULT CDECL AmdDxExtCreate11(ID3D11Device *device, IAmdDxExt **ext)
+{
+    HRESULT ret;
+    AmdDxExt *obj;
+    ID3D11VkExtDevice *ext_device;
+    TRACE("%p %p\n", device, ext);
+
+    if((ret = load_d3d11()) != S_OK)
+        return ret;
+
+    obj = malloc(sizeof(AmdDxExt));
+    if(!obj)
+        return E_OUTOFMEMORY;
+
+    obj->device = device;
+    ID3D11Device_AddRef(device);
+    ID3D11Device_GetImmediateContext(device, &obj->context);
+
+    if(FAILED(ret = ID3D11DeviceContext_QueryInterface(obj->context, &IID_ID3D11VkExtContext, (void**)&obj->ext_context)))
+    {
+        ERR("Failed to get ID3D11VkExtContext\n");
+        return ret;
+    }
+
+    if(FAILED(ret = ID3D11Device_QueryInterface(device, &IID_ID3D11VkExtDevice, (void**)&ext_device)))
+    {
+        ERR("Failed to get ID3D11VkExtDevice\n");
+        return ret;
+    }
+
+    obj->IAmdDxExt_iface.lpVtbl = &AmdDxExt_vtable;
+    obj->IAmdDxExtUAVOverlap_iface.lpVtbl = &amddxext_uav_vtable;
+    obj->IAmdDxExtQuadBufferStereo_iface.lpVtbl = &quadbufstereo_vtable;
+    obj->IAmdDxExtDepthBounds_iface.lpVtbl = &amddxext_depth_vtable;
+    obj->IAmdDxExtMultidrawIndirect_iface.lpVtbl = &amddxext_multidraw_vtable;
+    obj->is_d3d11 = TRUE;
+    obj->ref = 1;
+
+    obj->depth_bounds = !!ID3D11VkExtDevice_GetExtensionSupport(ext_device, D3D11_VK_EXT_DEPTH_BOUNDS);
+    obj->uav_overlap = !!ID3D11VkExtDevice_GetExtensionSupport(ext_device, D3D11_VK_EXT_BARRIER_CONTROL);
+    obj->multi_draw_indirect = !!ID3D11VkExtDevice_GetExtensionSupport(ext_device, D3D11_VK_EXT_MULTI_DRAW_INDIRECT);
+    obj->multi_draw_indirect_count = !!ID3D11VkExtDevice_GetExtensionSupport(ext_device, D3D11_VK_EXT_MULTI_DRAW_INDIRECT_COUNT);
+
+    TRACE("Supported extensions:\n DepthBounds: %d, UAVOverlap: %d, MultiDrawIndirect: %d, MultiDrawIndirectCount: %d\n",
+            obj->depth_bounds, obj->uav_overlap, obj->multi_draw_indirect, obj->multi_draw_indirect_count);
+
+    *ext = &obj->IAmdDxExt_iface;
+
+    ID3D11VkExtDevice_Release(ext_device);
+
+    return S_OK;
+}
diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index d22c6f8997f..347404ddd01 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -2980,6 +2980,7 @@ HKCU,Software\Wine\DllOverrides,"ucrtbase",0x2,"native,builtin"
 HKCU,Software\Wine\DllOverrides,"vcomp140",0x2,"native,builtin"
 HKCU,Software\Wine\DllOverrides,"vcruntime140",0x2,"native,builtin"
 HKCU,Software\Wine\DllOverrides,"atiadlxx",,"disabled"
+HKCU,Software\Wine\DllOverrides,"atidxx64",,"disabled"
 HKCU,Software\Wine\DllOverrides,"nvcuda",0x2,"disabled"
 HKCU,Software\Wine\DllOverrides,"vcruntime140_1",0x2,"native,builtin"
 HKCU,Software\Wine\AppDefaults\ShadowOfWar.exe\DllOverrides,"amd_ags_x64",,"disabled"
-- 
2.49.0

From 3cac2a464ff5b3f2d174d82dbbc18c2c5805963f Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty <etaash.mathamsetty@gmail.com>
Date: Sat, 14 Jun 2025 11:22:44 -0400
Subject: [PATCH 102/159] wine.inf: Add override for diabotical

---
 loader/wine.inf.in | 1 +
 1 file changed, 1 insertion(+)

diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 347404ddd01..83389e3403a 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -2986,6 +2986,7 @@ HKCU,Software\Wine\DllOverrides,"vcruntime140_1",0x2,"native,builtin"
 HKCU,Software\Wine\AppDefaults\ShadowOfWar.exe\DllOverrides,"amd_ags_x64",,"disabled"
 HKCU,Software\Wine\AppDefaults\TDUSC.exe\DllOverrides,"xinput1_3",,"native,builtin"
 HKCU,Software\Wine\AppDefaults\WRCG.exe\DllOverrides,"xinput1_3",,"native,builtin"
+HKCU,Software\Wine\AppDefaults\diabotical.exe\DllOverrides,"xaudio2_9",,"disabled"
 ;;App-specific overrides for atiadlxx.dll.
 HKCU,Software\Wine\AppDefaults\s2_sp64_ship.exe\DllOverrides,"atiadlxx",,"builtin"
 HKCU,Software\Wine\AppDefaults\s2_mp64_ship.exe\DllOverrides,"atiadlxx",,"builtin"
-- 
2.49.0

From 83cf93ef74a1aa4ec91140634ddada099cf78540 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty <etaash.mathamsetty@gmail.com>
Date: Sat, 14 Jun 2025 13:19:02 -0400
Subject: [PATCH 103/159] winewayland: Implement support for HDR static
 metadata extension

---
 dlls/win32u/sysparams.c               |  4 +-
 dlls/winewayland.drv/display.c        | 43 +++++++++++++++++++-
 dlls/winewayland.drv/wayland_output.c | 58 ++++++++++++++++++---------
 dlls/winewayland.drv/waylanddrv.h     |  4 +-
 4 files changed, 85 insertions(+), 24 deletions(-)

diff --git a/dlls/win32u/sysparams.c b/dlls/win32u/sysparams.c
index 6b8131c9903..f068438f4e8 100644
--- a/dlls/win32u/sysparams.c
+++ b/dlls/win32u/sysparams.c
@@ -7558,8 +7558,10 @@ NTSTATUS WINAPI NtUserDisplayConfigGetDeviceInfo( DISPLAYCONFIG_DEVICE_INFO_HEAD
     {
         DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO *info = (DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO *)packet;
         const char *env;
+        static int once;
 
-        FIXME( "DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO semi-stub.\n" );
+        if (!once++)
+            FIXME( "DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO semi-stub.\n" );
 
         if (packet->size < sizeof(*info))
             return STATUS_INVALID_PARAMETER;
diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index 60768fd620b..530dd30bd25 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -235,9 +235,19 @@ static void wayland_add_device_source(const struct gdi_device_manager *device_ma
     device_manager->add_source(output_info->output->name, state_flags, dpi, param);
 }
 
+/* We love gamescope */
+static uint8_t encode_max_luminance(float nits)
+{
+    if (nits == 0.0f)
+        return 0;
+
+    return ceilf((logf(nits / 50.0f) / logf(2.0f)) * 32.0f);
+}
+
 /* emulate some edid data */
 static UINT get_edid(const struct output_info *output_info, unsigned char **data_out)
 {
+    const unsigned int edid_size = 256;
     unsigned char *data, *p;
     unsigned int i, mwidth, mheight;
     unsigned char c;
@@ -248,7 +258,8 @@ static UINT get_edid(const struct output_info *output_info, unsigned char **data
     mwidth = mode->width / 60;
     mheight = mode->height / 60;
 
-    *data_out = calloc( 1, 128 );
+    /* another 128 bytes needed for CTA-861 extension */
+    *data_out = calloc( 1, edid_size );
     data = *data_out;
 
     if (!data) return 0;
@@ -299,11 +310,39 @@ static UINT get_edid(const struct output_info *output_info, unsigned char **data
     p[3] = 0x10;
 
     c = 0;
+    data[126] = 1; /* one extension */
     for (i = 0; i < 127; ++i)
         c += data[i];
     data[127] = 256 - c;
 
-    return 128;
+    p = data + 128;
+
+    p[0] = 2;
+    p[1] = 3;
+    p[2] = 0xa; /* FIXME: is this correct?  */
+
+    p += 4;
+
+    p[0] = (0x7 << 5) | 0x5; /* HDR static metadata size */
+    p[1] = 6;
+
+    /* HDR static metadata block */
+
+    p[2] = 0x7; /* ST2084 | SDR | HDR */
+    p[3] = 1;
+    p[4] = encode_max_luminance(output_info->output->max_cll);
+    p[5] = encode_max_luminance(output_info->output->max_fall);
+    p[6] = 0; /* assume undefined */
+
+    /* reset p to beginning of the CTA block */
+    p = data + 128;
+    c = 0;
+
+    for (i = 0; i < 127; ++i)
+        c += p[i];
+    p[127] = 256 - c;
+
+    return edid_size;
 }
 
 static void wayland_add_device_monitor(const struct gdi_device_manager *device_manager,
diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index 7c1bc4bb264..74923ffe93e 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -41,7 +41,8 @@ static uint32_t next_output_id = 0;
 #define WAYLAND_OUTPUT_CHANGED_LOGICAL_WH 0x08
 #define WAYLAND_OUTPUT_CHANGED_TRANSFORM  0x10
 #define WAYLAND_OUTPUT_CHANGED_PRIMARIES  0x20
-#define WAYLAND_OUTPUT_CHANGED_LUMINANCE  0x40
+#define WAYLAND_OUTPUT_CHANGED_FALL       0x40
+#define WAYLAND_OUTPUT_CHANGED_CLL        0x80
 
 /**********************************************************************
  *          Output handling
@@ -204,17 +205,21 @@ static void wayland_output_done(struct wayland_output *output)
         output->current.transform = output->pending.transform;
     }
 
+
+    /* Copy here as well in case this gets called first */
     if (output->pending_flags & WAYLAND_OUTPUT_CHANGED_PRIMARIES)
     {
-        /* Copy here as well in case this gets called first */
         output->current.primaries = output->pending.primaries;
     }
 
-    if (output->pending_flags & WAYLAND_OUTPUT_CHANGED_LUMINANCE)
+    if (output->pending_flags & WAYLAND_OUTPUT_CHANGED_FALL)
     {
-        output->current.max_luminance = output->pending.max_luminance;
-        output->current.min_luminance = output->pending.min_luminance;
+        output->current.max_fall = output->pending.max_fall;
+    }
 
+    if (output->pending_flags & WAYLAND_OUTPUT_CHANGED_CLL)
+    {
+        output->current.max_cll = output->pending.max_cll;
     }
 
     output->pending_flags = 0;
@@ -366,11 +371,16 @@ static void wp_image_description_info_v1_done(void *data,
         output->pending_flags &= ~WAYLAND_OUTPUT_CHANGED_PRIMARIES;
     }
 
-    if (output->pending_flags & WAYLAND_OUTPUT_CHANGED_LUMINANCE)
+    if (output->pending_flags & WAYLAND_OUTPUT_CHANGED_FALL)
     {
-        output->current.max_luminance = output->pending.max_luminance;
-        output->current.min_luminance = output->pending.min_luminance;
-        output->pending_flags &= ~WAYLAND_OUTPUT_CHANGED_LUMINANCE;
+        output->current.max_fall = output->pending.max_fall;
+        output->pending_flags &= ~WAYLAND_OUTPUT_CHANGED_FALL;
+    }
+
+    if (output->pending_flags & WAYLAND_OUTPUT_CHANGED_CLL)
+    {
+        output->current.max_cll = output->pending.max_cll;
+        output->pending_flags &= ~WAYLAND_OUTPUT_CHANGED_CLL;
     }
 
     TRACE("%p\n", output);
@@ -441,19 +451,10 @@ static void wayland_image_description_info_v1_luminance(void *data,
                             struct wp_image_description_info_v1 *info,
                             uint32_t min, uint32_t max, uint32_t ref)
 {
-    struct wayland_output *output = data;
-    pthread_mutex_lock(&process_wayland.output_mutex);
-
-    output->pending.max_luminance = max;
-    output->pending.min_luminance = min;
-    output->pending_flags |= WAYLAND_OUTPUT_CHANGED_LUMINANCE;
-
-    TRACE("min %lf max %u ref %u\n", min * 1e-4, max, ref);
-
-    pthread_mutex_unlock(&process_wayland.output_mutex);
 
 }
 
+/* FIXME: Make use of this event */
 static void wayland_image_description_info_v1_target_primaries(void *data,
 				 struct wp_image_description_info_v1 *info,
 				 int32_t r_x,
@@ -479,14 +480,33 @@ static void wayland_image_description_info_v1_target_max_cll(void *data,
 				            struct wp_image_description_info_v1 *info,
 				            uint32_t max)
 {
+    struct wayland_output *output = data;
 
+    pthread_mutex_lock(&process_wayland.output_mutex);
+
+
+    TRACE("Max CLL: %u\n", max);
+
+    output->pending.max_cll = max;
+    output->pending_flags |= WAYLAND_OUTPUT_CHANGED_CLL;
+
+    pthread_mutex_unlock(&process_wayland.output_mutex);
 }
 
 static void wayland_image_description_info_v1_target_max_fall(void *data,
 				            struct wp_image_description_info_v1 *info,
 				            uint32_t max)
 {
+    struct wayland_output *output = data;
+
+    pthread_mutex_lock(&process_wayland.output_mutex);
 
+    TRACE("Max FALL: %u\n", max);
+
+    output->pending.max_fall = max;
+    output->pending_flags |= WAYLAND_OUTPUT_CHANGED_FALL;
+
+    pthread_mutex_unlock(&process_wayland.output_mutex);
 }
 
 static const struct wp_image_description_info_v1_listener image_description_info_listener = {
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 189beef37d4..2dcc22ef392 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -245,8 +245,8 @@ struct wayland_output_state
     struct rb_tree modes;
     struct wayland_output_mode *current_mode;
     struct wayland_primaries primaries;
-    uint32_t max_luminance;
-    uint32_t min_luminance;
+    uint32_t max_fall;
+    uint32_t max_cll;
     char *name;
     int logical_x, logical_y;
     int logical_w, logical_h;
-- 
2.49.0

From 915489f41d0f1bca1b831cdfb85c7d38b3c6785a Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sat, 14 Jun 2025 20:46:22 -0400
Subject: [PATCH 104/159] atiadlxx: Remove outdated comment

---
 dlls/atiadlxx/atiadlxx_main.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/dlls/atiadlxx/atiadlxx_main.c b/dlls/atiadlxx/atiadlxx_main.c
index 1c97b25962b..b8cc4eb86f7 100644
--- a/dlls/atiadlxx/atiadlxx_main.c
+++ b/dlls/atiadlxx/atiadlxx_main.c
@@ -833,7 +833,6 @@ int AMDAPI ADL2_Display_DDCInfo2_Get(ADL_CONTEXT *context, int index, int displa
     if (desc.ColorSpace == DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020)
     {
         TRACE("Reporting monitor %s as HDR10 supported.\n", debugstr_a((char*)devmode.dmDeviceName));
-        /* FIXME check if freesync is supported */
         info->iSupportedHDR = ADL_HDR_CEA861_3;
 
         if(caps.iCaps & ADL_FREESYNC_CAP_SUPPORTED)
-- 
2.49.0

From fb6cb57aa899d4e1ed4de93dac9455c2767fe1b3 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty <etaash.mathamsetty@gmail.com>
Date: Sun, 15 Jun 2025 20:25:54 -0400
Subject: [PATCH 105/159] kernel32: Implement timeGetTime.

Cheat engine's speed hack expects this function to exist in kernel32 for some reason
---
 dlls/kernel32/kernel32.spec | 1 +
 dlls/kernel32/sync.c        | 8 ++++++++
 2 files changed, 9 insertions(+)

diff --git a/dlls/kernel32/kernel32.spec b/dlls/kernel32/kernel32.spec
index fff2d8e4678..ba36cc6f769 100644
--- a/dlls/kernel32/kernel32.spec
+++ b/dlls/kernel32/kernel32.spec
@@ -1714,6 +1714,7 @@
 @ stdcall -import lstrlen(str)
 @ stdcall -import lstrlenA(str)
 @ stdcall -import lstrlenW(wstr)
+@ stdcall timeGetTime()
 
 ################################################################
 # Wine internal extensions
diff --git a/dlls/kernel32/sync.c b/dlls/kernel32/sync.c
index 44fd01002d4..e4f22b73129 100644
--- a/dlls/kernel32/sync.c
+++ b/dlls/kernel32/sync.c
@@ -103,6 +103,14 @@ DWORD WINAPI DECLSPEC_HOTPATCH GetTickCount(void)
     return user_shared_data->TickCount.LowPart;
 }
 
+/***********************************************************************
+ *           timeGetTime       (KERNEL32.@)
+ */
+DWORD WINAPI DECLSPEC_HOTPATCH timeGetTime(void)
+{
+    return user_shared_data->TickCount.LowPart;
+}
+
 /***********************************************************************
  *           RegisterWaitForSingleObject   (KERNEL32.@)
  */
-- 
2.49.0

From 85a8cfdbc7364978eece37cdac4155f1dc1e2f52 Mon Sep 17 00:00:00 2001
From: Julius Bettin <julius.bettin@protonmail.com>
Date: Mon, 16 Jun 2025 19:56:38 -0400
Subject: [PATCH 106/159] kernelbase: Implement HeapSummary.

---
 dlls/kernel32/kernel32.spec     |  2 +-
 dlls/kernel32/tests/heap.c      | 48 ++++++++++++++++++++++++++++++
 dlls/kernelbase/kernelbase.spec |  2 +-
 dlls/kernelbase/memory.c        | 52 +++++++++++++++++++++++++++++++++
 include/winbase.h               | 10 +++++++
 5 files changed, 112 insertions(+), 2 deletions(-)

diff --git a/dlls/kernel32/kernel32.spec b/dlls/kernel32/kernel32.spec
index ba36cc6f769..7148eb5819e 100644
--- a/dlls/kernel32/kernel32.spec
+++ b/dlls/kernel32/kernel32.spec
@@ -957,7 +957,7 @@
 @ stub HeapSetFlags
 @ stdcall -import HeapSetInformation(ptr long ptr long)
 @ stdcall HeapSize(long long ptr) NTDLL.RtlSizeHeap
-@ stub HeapSummary
+@ stdcall -import HeapSummary(long long ptr)
 @ stdcall -import HeapUnlock(long)
 @ stub HeapUsage
 @ stdcall -import HeapValidate(long long ptr)
diff --git a/dlls/kernel32/tests/heap.c b/dlls/kernel32/tests/heap.c
index c62eb449192..a0ff7f10c7e 100644
--- a/dlls/kernel32/tests/heap.c
+++ b/dlls/kernel32/tests/heap.c
@@ -3740,6 +3740,53 @@ static void test_heap_sizes(void)
     }
 }
 
+static void test_HeapSummary(void)
+{
+    HANDLE heap;
+    HEAP_SUMMARY heap_summary;
+    BOOL ret;
+    DWORD err;
+    void *p;
+
+    /* setup */
+
+    heap = HeapCreate( 0, 0, 0 ); /* growable heap */
+    ok( heap != NULL, "creation failed\n" );
+
+    HeapAlloc( heap , 0, 0x100 );
+    HeapAlloc( heap , 0, 0x200 );
+    p = HeapAlloc( heap , 0, 0x300 );
+    HeapAlloc( heap, 0, 0x60000 );
+    HeapFree( heap, 0, p );
+
+    memset( &heap_summary, 0, sizeof(heap_summary) );
+
+    /* test cases */
+
+    ret = HeapSummary( heap, 0, &heap_summary );
+    err = GetLastError();
+    ok( !ret, "HeapSummary() with cb != sizeof(HEAP_SUMMARY) returned TRUE\n" );
+    ok( err == ERROR_INVALID_PARAMETER,
+        "HeapSummary() with cb != sizeof(HEAP_SUMMARY) set last error to %lu\n", err );
+
+    heap_summary.cb = sizeof(heap_summary);
+    ret = HeapSummary( heap, 0, &heap_summary );
+    ok( ret, "HeapSummary() returned FALSE\n" );
+
+    ok( heap_summary.cbAllocated == 0x100 + 0x200 + 0x60000,
+        "HeapSummary: wrong cbAllocated value %#Ix\n", heap_summary.cbAllocated );
+    ok( heap_summary.cbCommitted >= heap_summary.cbAllocated,
+        "HeapSummary: cbCommitted %#Ix < cbAllocated %#Ix\n",
+        heap_summary.cbCommitted, heap_summary.cbAllocated );
+    ok( heap_summary.cbReserved >= heap_summary.cbCommitted,
+        "HeapSummary: cbReserved %#Ix < cbCommitted %#Ix\n",
+        heap_summary.cbReserved, heap_summary.cbCommitted );
+
+    /* cleanup */
+
+    HeapDestroy( heap );
+}
+
 START_TEST(heap)
 {
     int argc;
@@ -3760,6 +3807,7 @@ START_TEST(heap)
 
     test_GetPhysicallyInstalledSystemMemory();
     test_GlobalMemoryStatus();
+    test_HeapSummary();
 
     if (pRtlGetNtGlobalFlags)
     {
diff --git a/dlls/kernelbase/kernelbase.spec b/dlls/kernelbase/kernelbase.spec
index 89320a8180c..7be3c1f0ad5 100644
--- a/dlls/kernelbase/kernelbase.spec
+++ b/dlls/kernelbase/kernelbase.spec
@@ -820,7 +820,7 @@
 @ stdcall HeapReAlloc(long long ptr long) ntdll.RtlReAllocateHeap
 @ stdcall HeapSetInformation(ptr long ptr long)
 @ stdcall HeapSize(long long ptr) ntdll.RtlSizeHeap
-@ stub HeapSummary
+@ stdcall HeapSummary(long long ptr)
 @ stdcall HeapUnlock(long)
 @ stdcall HeapValidate(long long ptr)
 @ stdcall HeapWalk(long ptr)
diff --git a/dlls/kernelbase/memory.c b/dlls/kernelbase/memory.c
index e102345119a..02de01bea0d 100644
--- a/dlls/kernelbase/memory.c
+++ b/dlls/kernelbase/memory.c
@@ -797,6 +797,58 @@ BOOL WINAPI HeapSetInformation( HANDLE heap, HEAP_INFORMATION_CLASS infoclass, P
 }
 
 
+/***********************************************************************
+ *           HeapSummary   (kernelbase.@)
+ */
+BOOL WINAPI HeapSummary( HANDLE heap, DWORD flags, LPHEAP_SUMMARY heap_summary )
+{
+    SIZE_T allocated = 0;
+    SIZE_T committed = 0;
+    SIZE_T uncommitted = 0;
+    PROCESS_HEAP_ENTRY entry;
+
+    if (heap_summary->cb != sizeof(*heap_summary))
+    {
+        /* needs to be set to the exact size by the caller */
+        SetLastError( ERROR_INVALID_PARAMETER );
+        return FALSE;
+    }
+
+    memset( &entry, 0, sizeof(entry) );
+
+    if (!HeapLock( heap ))
+        return FALSE;
+
+    while (HeapWalk( heap, &entry ))
+    {
+        if (entry.wFlags & PROCESS_HEAP_ENTRY_BUSY)
+        {
+            allocated += entry.cbData;
+        }
+        else if (entry.wFlags & PROCESS_HEAP_REGION)
+        {
+            committed += entry.Region.dwCommittedSize;
+            uncommitted += entry.Region.dwUnCommittedSize;
+        }
+    }
+
+    if (GetLastError() != ERROR_NO_MORE_ITEMS)
+    {
+        /* HeapWalk unsuccessful */
+        HeapUnlock( heap );
+        return FALSE;
+    }
+
+    HeapUnlock( heap );
+    heap_summary->cbAllocated = allocated;
+    heap_summary->cbCommitted = committed;
+    heap_summary->cbReserved = committed + uncommitted;
+    heap_summary->cbMaxReserve = heap_summary->cbReserved;
+
+    return TRUE;
+}
+
+
 /***********************************************************************
  *           HeapUnlock   (kernelbase.@)
  */
diff --git a/include/winbase.h b/include/winbase.h
index 172a921c3b2..3596e13d147 100644
--- a/include/winbase.h
+++ b/include/winbase.h
@@ -1820,6 +1820,15 @@ typedef struct DISK_SPACE_INFORMATION
     DWORD     BytesPerSector;
 } DISK_SPACE_INFORMATION;
 
+typedef struct _HEAP_SUMMARY
+{
+    DWORD  cb;
+    SIZE_T cbAllocated;
+    SIZE_T cbCommitted;
+    SIZE_T cbReserved;
+    SIZE_T cbMaxReserve;
+} HEAP_SUMMARY, *PHEAP_SUMMARY, *LPHEAP_SUMMARY;
+
 WINBASEAPI BOOL        WINAPI ActivateActCtx(HANDLE,ULONG_PTR *);
 WINADVAPI  BOOL        WINAPI AddAccessAllowedAce(PACL,DWORD,DWORD,PSID);
 WINADVAPI  BOOL        WINAPI AddAccessAllowedAceEx(PACL,DWORD,DWORD,DWORD,PSID);
@@ -2452,6 +2461,7 @@ WINBASEAPI LPVOID      WINAPI HeapReAlloc(HANDLE,DWORD,LPVOID,SIZE_T) __WINE_ALL
 WINBASEAPI BOOL        WINAPI HeapQueryInformation(HANDLE,HEAP_INFORMATION_CLASS,PVOID,SIZE_T,PSIZE_T);
 WINBASEAPI BOOL        WINAPI HeapSetInformation(HANDLE,HEAP_INFORMATION_CLASS,PVOID,SIZE_T);
 WINBASEAPI SIZE_T      WINAPI HeapSize(HANDLE,DWORD,LPCVOID);
+WINBASEAPI BOOL        WINAPI HeapSummary(HANDLE,DWORD,LPHEAP_SUMMARY);
 WINBASEAPI BOOL        WINAPI HeapUnlock(HANDLE);
 WINBASEAPI BOOL        WINAPI HeapValidate(HANDLE,DWORD,LPCVOID);
 WINBASEAPI BOOL        WINAPI HeapWalk(HANDLE,LPPROCESS_HEAP_ENTRY);
-- 
2.49.0

From f74c136e1a41bb3d22adfbfebd787f10a87e9268 Mon Sep 17 00:00:00 2001
From: Alexandre Julliard <julliard@winehq.org>
Date: Thu, 17 Apr 2025 18:52:52 +0200
Subject: [PATCH 107/159] ntdll: Add a stub for NtCreateSectionEx().

---
 dlls/ntdll/ntdll.spec       |  2 ++
 dlls/ntdll/signal_arm64ec.c |  1 +
 dlls/ntdll/unix/sync.c      | 12 ++++++++++++
 dlls/wow64/virtual.c        | 30 ++++++++++++++++++++++++++++++
 include/winternl.h          |  1 +
 5 files changed, 46 insertions(+)

diff --git a/dlls/ntdll/ntdll.spec b/dlls/ntdll/ntdll.spec
index 4ac3ce4dc36..d99e6d5be9e 100644
--- a/dlls/ntdll/ntdll.spec
+++ b/dlls/ntdll/ntdll.spec
@@ -192,6 +192,7 @@
 # @ stub NtCreateProcessEx
 # @ stub NtCreateProfile
 @ stdcall -syscall NtCreateSection(ptr long ptr ptr long long long)
+@ stdcall -syscall NtCreateSectionEx(ptr long ptr ptr long long long ptr long)
 @ stdcall -syscall NtCreateSemaphore(ptr long ptr long long)
 @ stdcall -syscall NtCreateSymbolicLinkObject(ptr long ptr ptr)
 @ stdcall -syscall NtCreateThread(ptr long ptr long ptr ptr ptr long)
@@ -1260,6 +1261,7 @@
 # @ stub ZwCreateProcessEx
 # @ stub ZwCreateProfile
 @ stdcall -private -syscall ZwCreateSection(ptr long ptr ptr long long long) NtCreateSection
+@ stdcall -private -syscall ZwCreateSectionEx(ptr long ptr ptr long long long ptr long) NtCreateSectionEx
 @ stdcall -private -syscall ZwCreateSemaphore(ptr long ptr long long) NtCreateSemaphore
 @ stdcall -private -syscall ZwCreateSymbolicLinkObject(ptr long ptr ptr) NtCreateSymbolicLinkObject
 @ stdcall -private -syscall ZwCreateThread(ptr long ptr long ptr ptr ptr long) NtCreateThread
diff --git a/dlls/ntdll/signal_arm64ec.c b/dlls/ntdll/signal_arm64ec.c
index 13d92bee67a..e3a9a664c9b 100644
--- a/dlls/ntdll/signal_arm64ec.c
+++ b/dlls/ntdll/signal_arm64ec.c
@@ -387,6 +387,7 @@ DEFINE_SYSCALL(NtCreateNamedPipeFile, (HANDLE *handle, ULONG access, OBJECT_ATTR
 DEFINE_SYSCALL(NtCreatePagingFile, (UNICODE_STRING *name, LARGE_INTEGER *min_size, LARGE_INTEGER *max_size, LARGE_INTEGER *actual_size))
 DEFINE_SYSCALL(NtCreatePort, (HANDLE *handle, OBJECT_ATTRIBUTES *attr, ULONG info_len, ULONG data_len, ULONG *reserved))
 DEFINE_SYSCALL(NtCreateSection, (HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr, const LARGE_INTEGER *size, ULONG protect, ULONG sec_flags, HANDLE file))
+DEFINE_SYSCALL(NtCreateSectionEx, (HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr, const LARGE_INTEGER *size, ULONG protect, ULONG sec_flags, HANDLE file, MEM_EXTENDED_PARAMETER *parameters, ULONG count))
 DEFINE_SYSCALL(NtCreateSemaphore, (HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr, LONG initial, LONG max))
 DEFINE_SYSCALL(NtCreateSymbolicLinkObject, (HANDLE *handle, ACCESS_MASK access, OBJECT_ATTRIBUTES *attr, UNICODE_STRING *target))
 DEFINE_SYSCALL(NtCreateThread, (HANDLE *handle, ACCESS_MASK access, OBJECT_ATTRIBUTES *attr, HANDLE process, CLIENT_ID *id, CONTEXT *ctx, INITIAL_TEB *teb, BOOLEAN suspended))
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 47fd5b24c46..7ac12a97606 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -2378,6 +2378,18 @@ NTSTATUS WINAPI NtCreateSection( HANDLE *handle, ACCESS_MASK access, const OBJEC
 }
 
 
+/***********************************************************************
+ *             NtCreateSectionEx (NTDLL.@)
+ */
+NTSTATUS WINAPI NtCreateSectionEx( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr,
+                                   const LARGE_INTEGER *size, ULONG protect, ULONG sec_flags,
+                                   HANDLE file, MEM_EXTENDED_PARAMETER *parameters, ULONG count )
+{
+    if (count) FIXME( "extended params not supported\n" );
+    return NtCreateSection( handle, access, attr, size, protect, sec_flags, file );
+}
+
+
 /***********************************************************************
  *             NtOpenSection (NTDLL.@)
  */
diff --git a/dlls/wow64/virtual.c b/dlls/wow64/virtual.c
index ca362438340..5239089a0bd 100644
--- a/dlls/wow64/virtual.c
+++ b/dlls/wow64/virtual.c
@@ -229,6 +229,36 @@ NTSTATUS WINAPI wow64_NtAreMappedFilesTheSame( UINT *args )
 }
 
 
+/**********************************************************************
+ *           wow64_NtCreateSectionEx
+ */
+NTSTATUS WINAPI wow64_NtCreateSectionEx( UINT *args )
+{
+    ULONG *handle_ptr = get_ptr( &args );
+    ACCESS_MASK access = get_ulong( &args );
+    OBJECT_ATTRIBUTES32 *attr32 = get_ptr( &args );
+    const LARGE_INTEGER *size = get_ptr( &args );
+    ULONG protect = get_ulong( &args );
+    ULONG flags = get_ulong( &args );
+    HANDLE file = get_handle( &args );
+    MEM_EXTENDED_PARAMETER32 *params32 = get_ptr( &args );
+    ULONG count = get_ulong( &args );
+
+    MEM_EXTENDED_PARAMETER *params64;
+    struct object_attr64 attr;
+    HANDLE handle = 0;
+    NTSTATUS status;
+
+    if ((status = mem_extended_parameters_32to64( &params64, params32, &count, FALSE ))) return status;
+
+    *handle_ptr = 0;
+    status = NtCreateSectionEx( &handle, access, objattr_32to64( &attr, attr32 ),
+                                size, protect, flags, file, params64, count );
+    put_handle( handle_ptr, handle );
+    return status;
+}
+
+
 /**********************************************************************
  *           wow64_NtFlushInstructionCache
  */
diff --git a/include/winternl.h b/include/winternl.h
index be01f3b31d0..591291e8d68 100644
--- a/include/winternl.h
+++ b/include/winternl.h
@@ -4553,6 +4553,7 @@ NTSYSAPI NTSTATUS  WINAPI NtCreatePort(PHANDLE,POBJECT_ATTRIBUTES,ULONG,ULONG,PU
 NTSYSAPI NTSTATUS  WINAPI NtCreateProcess(PHANDLE,ACCESS_MASK,POBJECT_ATTRIBUTES,HANDLE,BOOLEAN,HANDLE,HANDLE,HANDLE);
 NTSYSAPI NTSTATUS  WINAPI NtCreateProfile(PHANDLE,HANDLE,PVOID,ULONG,ULONG,PVOID,ULONG,KPROFILE_SOURCE,KAFFINITY);
 NTSYSAPI NTSTATUS  WINAPI NtCreateSection(HANDLE*,ACCESS_MASK,const OBJECT_ATTRIBUTES*,const LARGE_INTEGER*,ULONG,ULONG,HANDLE);
+NTSYSAPI NTSTATUS  WINAPI NtCreateSectionEx(HANDLE*,ACCESS_MASK,const OBJECT_ATTRIBUTES*,const LARGE_INTEGER*,ULONG,ULONG,HANDLE,MEM_EXTENDED_PARAMETER*,ULONG);
 NTSYSAPI NTSTATUS  WINAPI NtCreateSemaphore(PHANDLE,ACCESS_MASK,const OBJECT_ATTRIBUTES*,LONG,LONG);
 NTSYSAPI NTSTATUS  WINAPI NtCreateSymbolicLinkObject(PHANDLE,ACCESS_MASK,POBJECT_ATTRIBUTES,PUNICODE_STRING);
 NTSYSAPI NTSTATUS  WINAPI NtCreateThread(PHANDLE,ACCESS_MASK,POBJECT_ATTRIBUTES,HANDLE,PCLIENT_ID,PCONTEXT,PINITIAL_TEB,BOOLEAN);
-- 
2.49.0

From b5f9eb14f0c1d0759e0520b9a53a5bba2017dde1 Mon Sep 17 00:00:00 2001
From: Alexandre Julliard <julliard@winehq.org>
Date: Thu, 17 Apr 2025 20:33:59 +0200
Subject: [PATCH 108/159] kernelbase: Implement CreateFileMapping2().

---
 dlls/kernelbase/kernelbase.spec |  1 +
 dlls/kernelbase/sync.c          | 29 +++++++++++++++++++++++++++++
 include/memoryapi.h             |  5 ++---
 include/winbase.h               |  1 +
 4 files changed, 33 insertions(+), 3 deletions(-)

diff --git a/dlls/kernelbase/kernelbase.spec b/dlls/kernelbase/kernelbase.spec
index 7be3c1f0ad5..1399bc0da19 100644
--- a/dlls/kernelbase/kernelbase.spec
+++ b/dlls/kernelbase/kernelbase.spec
@@ -192,6 +192,7 @@
 @ stdcall CreateFiberEx(long long long ptr ptr)
 @ stdcall CreateFile2(wstr long long long ptr)
 @ stdcall CreateFileA(str long long ptr long long long)
+@ stdcall CreateFileMapping2(long ptr long long long int64 wstr ptr long)
 @ stdcall CreateFileMappingFromApp(long ptr long int64 wstr)
 @ stdcall CreateFileMappingNumaW(long ptr long long long wstr long)
 @ stdcall CreateFileMappingW(long ptr long long long wstr)
diff --git a/dlls/kernelbase/sync.c b/dlls/kernelbase/sync.c
index 4c7efc359f2..731c5e55c95 100644
--- a/dlls/kernelbase/sync.c
+++ b/dlls/kernelbase/sync.c
@@ -1087,6 +1087,35 @@ HANDLE WINAPI DECLSPEC_HOTPATCH CreateFileMappingW( HANDLE file, LPSECURITY_ATTR
 }
 
 
+/***********************************************************************
+ *             CreateFileMapping2   (kernelbase.@)
+ */
+HANDLE WINAPI DECLSPEC_HOTPATCH CreateFileMapping2( HANDLE file, SECURITY_ATTRIBUTES *sa, ULONG access,
+                                                    ULONG protect, ULONG sec_type, ULONG64 max_size,
+                                                    const WCHAR *name, MEM_EXTENDED_PARAMETER *params,
+                                                    ULONG count )
+{
+    HANDLE ret;
+    NTSTATUS status;
+    LARGE_INTEGER size;
+    UNICODE_STRING nameW;
+    OBJECT_ATTRIBUTES attr;
+
+    if (!sec_type) sec_type = SEC_COMMIT;
+    size.QuadPart = max_size;
+    if (file == INVALID_HANDLE_VALUE) file = 0;
+
+    get_create_object_attributes( &attr, &nameW, sa, name );
+
+    status = NtCreateSectionEx( &ret, access, &attr, &size, protect, sec_type, file, params, count );
+    if (status == STATUS_OBJECT_NAME_EXISTS)
+        SetLastError( ERROR_ALREADY_EXISTS );
+    else
+        SetLastError( RtlNtStatusToDosError(status) );
+    return ret;
+}
+
+
 /***********************************************************************
  *             CreateFileMappingFromApp   (kernelbase.@)
  */
diff --git a/include/memoryapi.h b/include/memoryapi.h
index 6728b832fa7..6eb62ea3a05 100644
--- a/include/memoryapi.h
+++ b/include/memoryapi.h
@@ -41,6 +41,5 @@ typedef struct WIN32_MEMORY_REGION_INFORMATION
     SIZE_T CommitSize;
 } WIN32_MEMORY_REGION_INFORMATION;
 
-DWORD WINAPI DiscardVirtualMemory(void *addr, SIZE_T size);
-BOOL WINAPI QueryVirtualMemoryInformation(HANDLE process,const void *addr,
-        WIN32_MEMORY_INFORMATION_CLASS info_class, void *info, SIZE_T size, SIZE_T *ret_size);
+WINBASEAPI DWORD  WINAPI DiscardVirtualMemory(void *addr, SIZE_T size);
+WINBASEAPI BOOL   WINAPI QueryVirtualMemoryInformation(HANDLE process,const void *addr, WIN32_MEMORY_INFORMATION_CLASS info_class, void *info, SIZE_T size, SIZE_T *ret_size);
diff --git a/include/winbase.h b/include/winbase.h
index 3596e13d147..d474193c699 100644
--- a/include/winbase.h
+++ b/include/winbase.h
@@ -1936,6 +1936,7 @@ WINBASEAPI LPVOID      WINAPI CreateFiberEx(SIZE_T,SIZE_T,DWORD,LPFIBER_START_RO
 WINBASEAPI HANDLE      WINAPI CreateFileA(LPCSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE);
 WINBASEAPI HANDLE      WINAPI CreateFileW(LPCWSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE);
 #define                       CreateFile WINELIB_NAME_AW(CreateFile)
+WINBASEAPI HANDLE      WINAPI CreateFileMapping2(HANDLE,LPSECURITY_ATTRIBUTES,ULONG,ULONG,ULONG,ULONG64,const WCHAR*,MEM_EXTENDED_PARAMETER*,ULONG);
 WINBASEAPI HANDLE      WINAPI CreateFileMappingA(HANDLE,LPSECURITY_ATTRIBUTES,DWORD,DWORD,DWORD,LPCSTR);
 WINBASEAPI HANDLE      WINAPI CreateFileMappingW(HANDLE,LPSECURITY_ATTRIBUTES,DWORD,DWORD,DWORD,LPCWSTR);
 #define                       CreateFileMapping WINELIB_NAME_AW(CreateFileMapping)
-- 
2.49.0

From 5de3f948274c7586ee580fb76d3ce84dbb3d87f3 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Wed, 18 Jun 2025 16:46:53 -0400
Subject: [PATCH 109/159] winewayland: Don't drop pointer frames in relative
 only mode.

---
 dlls/winewayland.drv/wayland_pointer.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index d5328f33ace..8cab18688f9 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -1172,7 +1172,9 @@ static void wayland_pointer_update_constraint(struct wl_surface *wl_surface,
 
     pointer->relative_only = needs_relative;
 
-    InterlockedExchange(&pointer->confinement_updated, TRUE);
+    /* we don't need to drop pointer frames when in relative only mode */
+    if (!pointer->relative_only)
+        InterlockedExchange(&pointer->confinement_updated, TRUE);
 }
 
 void wayland_pointer_clear_constraint(void)
-- 
2.49.0

From 3380888e5976b026ce792f067eab031004c0dec6 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Wed, 18 Jun 2025 22:09:44 -0400
Subject: [PATCH 110/159] winewayland: Prefer using target primaries.

---
 dlls/winewayland.drv/wayland_output.c | 74 +++++++++++++++++----------
 1 file changed, 46 insertions(+), 28 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index 74923ffe93e..83cef777e7c 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -359,7 +359,7 @@ static const struct zxdg_output_v1_listener zxdg_output_v1_listener = {
     zxdg_output_v1_handle_description,
 };
 
-static void wp_image_description_info_v1_done(void *data,
+static void wayland_image_description_info_v1_done(void *data,
                                               struct wp_image_description_info_v1 *info)
 {
     struct wayland_output *output = data;
@@ -390,38 +390,41 @@ static void wp_image_description_info_v1_done(void *data,
     maybe_init_display_devices();
 }
 
-static void wp_image_description_info_v1_icc_file(void *data,
+static void wayland_image_description_info_v1_icc_file(void *data,
                                                   struct wp_image_description_info_v1 *info,
                                                   int32_t icc, uint32_t icc_size)
 {
 
 }
 
-static void wp_image_description_info_v1_primaries(void *data,
+static void wayland_image_description_info_v1_primaries(void *data,
                                                    struct wp_image_description_info_v1 *info,
                                                    int32_t r_x, int32_t r_y, int32_t g_x,
-			                                       int32_t g_y, int32_t b_x, int32_t b_y,
+                                                   int32_t g_y, int32_t b_x, int32_t b_y,
                                                    int32_t w_x, int32_t w_y)
 {
     struct wayland_output *output = data;
 
     pthread_mutex_lock(&process_wayland.output_mutex);
 
+    if ((output->pending_flags & WAYLAND_OUTPUT_CHANGED_PRIMARIES) == 0)
+    {
 #define COPY(name) output->pending.primaries.name = round((name * 1e-6) * 1024)
-    COPY(r_x);
-    COPY(r_y);
-    COPY(g_x);
-    COPY(g_y);
-    COPY(b_x);
-    COPY(b_y);
-    COPY(w_x);
-    COPY(w_y);
+        COPY(r_x);
+        COPY(r_y);
+        COPY(g_x);
+        COPY(g_y);
+        COPY(b_x);
+        COPY(b_y);
+        COPY(w_x);
+        COPY(w_y);
 #undef COPY
 
-    TRACE("primaries: {%lf, %lf, %lf, %lf, %lf, %lf, %lf, %lf}\n",
-        r_x * 1e-6, r_y * 1e-6, g_x * 1e-6, g_y * 1e-6, b_x * 1e-6, b_y * 1e-6, w_x * 1e-6, w_y * 1e-6);
+        TRACE("primaries: {%lf, %lf, %lf, %lf, %lf, %lf, %lf, %lf}\n",
+            r_x * 1e-6, r_y * 1e-6, g_x * 1e-6, g_y * 1e-6, b_x * 1e-6, b_y * 1e-6, w_x * 1e-6, w_y * 1e-6);
 
-    output->pending_flags |= WAYLAND_OUTPUT_CHANGED_PRIMARIES;
+        output->pending_flags |= WAYLAND_OUTPUT_CHANGED_PRIMARIES;
+    }
 
     pthread_mutex_unlock(&process_wayland.output_mutex);
 }
@@ -454,19 +457,35 @@ static void wayland_image_description_info_v1_luminance(void *data,
 
 }
 
-/* FIXME: Make use of this event */
 static void wayland_image_description_info_v1_target_primaries(void *data,
 				 struct wp_image_description_info_v1 *info,
-				 int32_t r_x,
-				 int32_t r_y,
-				 int32_t g_x,
-				 int32_t g_y,
-				 int32_t b_x,
-				 int32_t b_y,
-				 int32_t w_x,
-				 int32_t w_y)
+				 int32_t r_x, int32_t r_y,
+				 int32_t g_x, int32_t g_y,
+				 int32_t b_x, int32_t b_y,
+				 int32_t w_x, int32_t w_y)
 {
+    struct wayland_output *output = data;
+
+    pthread_mutex_lock(&process_wayland.output_mutex);
+
+#define COPY(name) output->pending.primaries.name = round((name * 1e-6) * 1024)
+    COPY(r_x);
+    COPY(r_y);
+    COPY(g_x);
+    COPY(g_y);
+    COPY(b_x);
+    COPY(b_y);
+    COPY(w_x);
+    COPY(w_y);
+#undef COPY
+
+    TRACE("primaries: {%lf, %lf, %lf, %lf, %lf, %lf, %lf, %lf}\n",
+            r_x * 1e-6, r_y * 1e-6, g_x * 1e-6, g_y * 1e-6,
+            b_x * 1e-6, b_y * 1e-6, w_x * 1e-6, w_y * 1e-6);
 
+    output->pending_flags |= WAYLAND_OUTPUT_CHANGED_PRIMARIES;
+
+    pthread_mutex_unlock(&process_wayland.output_mutex);
 }
 
 static void wayland_image_description_info_v1_target_luminance(void *data,
@@ -484,7 +503,6 @@ static void wayland_image_description_info_v1_target_max_cll(void *data,
 
     pthread_mutex_lock(&process_wayland.output_mutex);
 
-
     TRACE("Max CLL: %u\n", max);
 
     output->pending.max_cll = max;
@@ -510,9 +528,9 @@ static void wayland_image_description_info_v1_target_max_fall(void *data,
 }
 
 static const struct wp_image_description_info_v1_listener image_description_info_listener = {
-    wp_image_description_info_v1_done,
-    wp_image_description_info_v1_icc_file,
-    wp_image_description_info_v1_primaries,
+    wayland_image_description_info_v1_done,
+    wayland_image_description_info_v1_icc_file,
+    wayland_image_description_info_v1_primaries,
     wayland_image_description_info_v1_primaries_named,
     wayland_image_description_info_v1_tfpower,
     wayland_image_description_info_v1_tfnamed,
-- 
2.49.0

From 5b7c6c06a781bb89ec854f429ffdc10d05204108 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty <etaash.mathamsetty@gmail.com>
Date: Thu, 19 Jun 2025 22:08:46 -0400
Subject: [PATCH 111/159] winewayland: implement support for color management
 description change event.

---
 dlls/winewayland.drv/wayland_output.c | 39 ++++++++++++++++++++++++---
 1 file changed, 35 insertions(+), 4 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index 83cef777e7c..c0ce474ed8f 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -541,6 +541,36 @@ static const struct wp_image_description_info_v1_listener image_description_info
     wayland_image_description_info_v1_target_max_fall
 };
 
+static void wayland_color_management_output_image_description_changed(void *user_data, struct wp_color_management_output_v1 *wp_color_management_output_v1)
+{
+    struct wayland_output *output = user_data;
+
+    pthread_mutex_lock(&process_wayland.output_mutex);
+
+    if (output->wp_image_description_v1)
+        wp_image_description_v1_destroy(output->wp_image_description_v1);
+
+    if (output->wp_image_description_info_v1)
+        wp_image_description_info_v1_destroy(output->wp_image_description_info_v1);
+
+
+    output->wp_image_description_v1 =
+        wp_color_management_output_v1_get_image_description(
+            output->wp_color_management_output_v1);
+    output->wp_image_description_info_v1 =
+        wp_image_description_v1_get_information(
+            output->wp_image_description_v1);
+    wp_image_description_info_v1_add_listener(
+        output->wp_image_description_info_v1,
+        &image_description_info_listener, output);
+
+    pthread_mutex_unlock(&process_wayland.output_mutex);
+}
+
+static const struct wp_color_management_output_v1_listener color_management_output_listener = {
+    wayland_color_management_output_image_description_changed
+};
+
 /**********************************************************************
  *          wayland_output_create
  *
@@ -590,14 +620,15 @@ BOOL wayland_output_create(uint32_t id, uint32_t version)
             wp_color_manager_v1_get_output(
                         process_wayland.wp_color_manager_v1,
                                      output->wl_output);
+        wp_color_management_output_v1_add_listener(
+            output->wp_color_management_output_v1,
+            &color_management_output_listener, output);
         output->wp_image_description_v1 =
             wp_color_management_output_v1_get_image_description(
-                output->wp_color_management_output_v1
-            );
+                output->wp_color_management_output_v1);
         output->wp_image_description_info_v1 =
             wp_image_description_v1_get_information(
-                output->wp_image_description_v1
-            );
+                output->wp_image_description_v1);
         wp_image_description_info_v1_add_listener(
             output->wp_image_description_info_v1,
             &image_description_info_listener, output);
-- 
2.49.0

From 5334c5917bceb575587dfaa30a47fcaad64f7fdb Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Fri, 20 Jun 2025 14:18:52 -0400
Subject: [PATCH 112/159] winebus: remove duplicate code.

---
 dlls/winebus.sys/main.c | 6 ------
 1 file changed, 6 deletions(-)

diff --git a/dlls/winebus.sys/main.c b/dlls/winebus.sys/main.c
index fe785e5804a..2aa5727a2f1 100644
--- a/dlls/winebus.sys/main.c
+++ b/dlls/winebus.sys/main.c
@@ -473,12 +473,6 @@ static BOOL is_hidraw_enabled(WORD vid, WORD pid, const USAGE_AND_PAGE *usages,
         return !!device->hidraw;
     }
 
-    if (usages->UsagePage == HID_USAGE_PAGE_DIGITIZER)
-    {
-        WARN("Ignoring unsupported %04X:%04X hidraw touchscreen\n", vid, pid);
-        return FALSE;
-    }
-
     if (!RtlQueryEnvironmentVariable(NULL, L"PROTON_DISABLE_HIDRAW", 20, value, ARRAY_SIZE(value) - 1, &len))
     {
         value[len] = 0;
-- 
2.49.0

From b6270e78d032193aec068f69809f842f7e3484ec Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Fri, 20 Jun 2025 15:42:58 -0400
Subject: [PATCH 113/159] opengl32: Improve wow64 mapping performance by 20x

TODO: determine if NtAllocateVirtualMemory helps performance (I believe it does)
---
 dlls/opengl32/unix_wgl.c | 162 ++++++++++++++++++++++++++++++++++-----
 dlls/opengl32/wgl.c      |  45 ++++++++---
 2 files changed, 179 insertions(+), 28 deletions(-)

diff --git a/dlls/opengl32/unix_wgl.c b/dlls/opengl32/unix_wgl.c
index 5ebe8ce9a38..8c4aada8dfd 100644
--- a/dlls/opengl32/unix_wgl.c
+++ b/dlls/opengl32/unix_wgl.c
@@ -1891,12 +1891,44 @@ static void unmap_named_buffer( TEB *teb, GLint buffer )
     if (func) func( buffer );
 }
 
+static void buffer_sub_data( TEB *teb, GLenum target, GLintptr offset, GLsizeiptr size, const void *data )
+{
+    const struct opengl_funcs *funcs = teb->glTable;
+    typeof(*funcs->ext.p_glBufferSubData) *func;
+    if (!(func = funcs->ext.p_glBufferSubData)) func = (void *)funcs->wgl.p_wglGetProcAddress( "glBufferSubData" );
+    if (func) func( target, offset, size, data );
+}
+
+static void named_buffer_sub_data( TEB *teb, GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data )
+{
+    const struct opengl_funcs *funcs = teb->glTable;
+    typeof(*funcs->ext.p_glNamedBufferSubData) *func;
+    if (!(func = funcs->ext.p_glNamedBufferSubData)) func = (void *)funcs->wgl.p_wglGetProcAddress( "glNamedBufferSubData" );
+    if (func) func( buffer, offset, size, data );
+}
+
+static void get_buffer_sub_data( TEB *teb, GLenum target, GLintptr offset, GLsizeiptr size, void *data )
+{
+    const struct opengl_funcs *funcs = teb->glTable;
+    typeof(*funcs->ext.p_glGetBufferSubData) *func;
+    if (!(func = funcs->ext.p_glGetBufferSubData)) func = (void *)funcs->wgl.p_wglGetProcAddress( "glNamedBufferSubData" );
+    if (func) func( target, offset, size, data );
+}
+
+static void get_named_buffer_sub_data( TEB *teb, GLuint buffer, GLintptr offset, GLsizeiptr size, void *data )
+{
+    const struct opengl_funcs *funcs = teb->glTable;
+    typeof(*funcs->ext.p_glGetNamedBufferSubData) *func;
+    if (!(func = funcs->ext.p_glGetNamedBufferSubData)) func = (void *)funcs->wgl.p_wglGetProcAddress( "glGetNamedBufferSubData" );
+    if (func) func( buffer, offset, size, data );
+}
+
 static NTSTATUS wow64_map_buffer( TEB *teb, GLint buffer, GLenum target, void *ptr, SIZE_T size,
                                   GLbitfield access, PTR32 *ret )
 {
     static unsigned int once;
 
-    if (*ret)  /* wow64 pointer provided, map buffer to it */
+    if (*ret)  /* wow64 pointer provided, copy buffer data to it */
     {
         if (!(access & (GL_MAP_INVALIDATE_RANGE_BIT | GL_MAP_INVALIDATE_BUFFER_BIT)))
         {
@@ -1904,11 +1936,12 @@ static NTSTATUS wow64_map_buffer( TEB *teb, GLint buffer, GLenum target, void *p
                 FIXME( "Doing a copy of a mapped buffer (expect performance issues)\n" );
 
             TRACE( "Copying %#zx from buffer at %p to wow64 buffer %p\n", size, ptr, UlongToPtr(*ret) );
-            memcpy( UlongToPtr(*ret), ptr, size );
+            if (buffer)
+                get_named_buffer_sub_data( teb, buffer, 0, size, UlongToPtr(*ret) );
+            else
+                get_buffer_sub_data( teb, target, 0, size, UlongToPtr(*ret) );
         }
 
-        /* save the wow64 pointer in the buffer data, we'll overwrite it on unmap */
-        *(PTR32 *)ptr = (UINT_PTR)*ret;
         return STATUS_SUCCESS;
     }
 
@@ -1944,17 +1977,27 @@ static GLbitfield map_range_flags_from_map_flags( GLenum flags )
     }
 }
 
-static NTSTATUS wow64_unmap_buffer( void *ptr, SIZE_T size, GLbitfield access )
+static NTSTATUS wow64_unmap_buffer( TEB *teb, void *ptr, void *wow_ptr, GLenum target, SIZE_T size, GLbitfield access )
 {
-    void *wow_ptr;
+    if (ULongToPtr(PtrToUlong(ptr)) == ptr) return STATUS_SUCCESS;  /* we're lucky */
+
+    if (access & GL_MAP_WRITE_BIT)
+    {
+        TRACE( "Copying %#zx from wow64 buffer %p to buffer %p\n", size, wow_ptr, ptr );
+        buffer_sub_data(teb, target, 0, size, wow_ptr);
+    }
+
+    return STATUS_INVALID_ADDRESS;
+}
 
+static NTSTATUS wow64_unmap_buffer_named( TEB *teb, void *ptr, void *wow_ptr, GLuint buffer, SIZE_T size, GLbitfield access )
+{
     if (ULongToPtr(PtrToUlong(ptr)) == ptr) return STATUS_SUCCESS;  /* we're lucky */
 
-    wow_ptr = UlongToPtr(*(PTR32 *)ptr);
     if (access & GL_MAP_WRITE_BIT)
     {
         TRACE( "Copying %#zx from wow64 buffer %p to buffer %p\n", size, wow_ptr, ptr );
-        memcpy( ptr, wow_ptr, size );
+        named_buffer_sub_data(teb, buffer, 0, size, wow_ptr);
     }
 
     return STATUS_INVALID_ADDRESS;
@@ -2050,13 +2093,29 @@ static NTSTATUS wow64_gl_map_buffer( void *args, NTSTATUS (*gl_map_buffer64)(voi
         .access = params32->access,
     };
     NTSTATUS status;
+    PTR32 wow_ptr = 0;
 
     /* already mapped, we're being called again with a wow64 pointer */
-    if (params32->ret) params.ret = get_buffer_pointer( params.teb, params.target );
+    if (params32->ret)
+    {
+        params.ret = get_buffer_pointer( params.teb, params.target );
+        wow_ptr = params32->ret;
+        unmap_buffer( params.teb, params.target );
+    }
     else if ((status = gl_map_buffer64( &params ))) return status;
 
     status = wow64_map_buffer( params.teb, 0, params.target, params.ret, 0,
                                map_range_flags_from_map_flags( params.access ), &params32->ret );
+    if (wow_ptr)
+    {
+        /* re-map the buffer
+         * if we get lucky here I'm sorry to inform that you lost your chance
+         */
+        if ((status = gl_map_buffer64( &params ))) return status;
+
+        /* save the wow64 pointer in the buffer data, we'll overwrite it on unmap */
+        *(PTR32 *)params.ret = wow_ptr;
+    }
     if (!status || status == STATUS_INVALID_ADDRESS) return status;
 
     unmap_buffer( params.teb, params.target );
@@ -2093,12 +2152,30 @@ NTSTATUS wow64_ext_glMapBufferRange( void *args )
         .access = params32->access,
     };
     NTSTATUS status;
+    PTR32 wow_ptr = 0;
 
     /* already mapped, we're being called again with a wow64 pointer */
-    if (params32->ret) params.ret = (char *)get_buffer_pointer( params.teb, params.target );
+    if (params32->ret)
+    {
+        params.ret = (char *)get_buffer_pointer( params.teb, params.target );
+        wow_ptr = params32->ret;
+        unmap_buffer( params.teb, params.target );
+    }
     else if ((status = ext_glMapBufferRange( &params ))) return status;
 
     status = wow64_map_buffer( params.teb, 0, params.target, params.ret, params.length, params.access, &params32->ret );
+
+    if (wow_ptr)
+    {
+        /* re-map the buffer
+         * if we get lucky here I'm sorry to inform that you lost your chance
+         */
+        if ((status = ext_glMapBufferRange( &params ))) return status;
+
+        /* save the wow64 pointer in the buffer data, we'll overwrite it on unmap */
+        *(PTR32 *)params.ret = wow_ptr;
+    }
+
     if (!status || status == STATUS_INVALID_ADDRESS) return status;
 
     unmap_buffer( params.teb, params.target );
@@ -2121,13 +2198,29 @@ static NTSTATUS wow64_gl_map_named_buffer( void *args, NTSTATUS (*gl_map_named_b
         .access = params32->access,
     };
     NTSTATUS status;
+    PTR32 wow_ptr = 0;
 
     /* already mapped, we're being called again with a wow64 pointer */
-    if (params32->ret) params.ret = get_named_buffer_pointer( params.teb, params.buffer );
+    if (params32->ret)
+    {
+        params.ret = get_named_buffer_pointer( params.teb, params.buffer );
+        wow_ptr = params32->ret;
+        unmap_named_buffer( params.teb, params.buffer );
+    }
     else if ((status = gl_map_named_buffer64( &params ))) return status;
 
     status = wow64_map_buffer( params.teb, params.buffer, 0, params.ret, 0,
                                map_range_flags_from_map_flags( params.access ), &params32->ret );
+    if (wow_ptr)
+    {
+        /* re-map the buffer
+         * if we get lucky here I'm sorry to inform that you lost your chance
+         */
+        if ((status = gl_map_named_buffer64( &params ))) return status;
+
+        /* save the wow64 pointer in the buffer data, we'll overwrite it on unmap */
+        *(PTR32 *)params.ret = wow_ptr;
+    }
     if (!status || status == STATUS_INVALID_ADDRESS) return status;
 
     unmap_named_buffer( params.teb, params.buffer );
@@ -2164,12 +2257,27 @@ static NTSTATUS wow64_gl_map_named_buffer_range( void *args, NTSTATUS (*gl_map_n
         .access = params32->access,
     };
     NTSTATUS status;
+    PTR32 wow_ptr = 0;
 
     /* already mapped, we're being called again with a wow64 pointer */
-    if (params32->ret) params.ret = get_named_buffer_pointer( params.teb, params.buffer );
+    if (params32->ret)
+    {
+        params.ret = get_named_buffer_pointer( params.teb, params.buffer );
+        wow_ptr = params32->ret;
+        unmap_named_buffer( params.teb, params.buffer );
+    }
     else if ((status = gl_map_named_buffer_range64( &params ))) return status;
 
     status = wow64_map_buffer( params.teb, params.buffer, 0, params.ret, params.length, params.access, &params32->ret );
+
+    if (wow_ptr)
+    {
+        if ((status = gl_map_named_buffer_range64( &params ))) return status;
+
+        /* save the wow64 pointer in the buffer data, we'll overwrite it on unmap */
+        *(PTR32 *)params.ret = wow_ptr;
+    }
+
     if (!status || status == STATUS_INVALID_ADDRESS) return status;
 
     unmap_named_buffer( params.teb, params.buffer );
@@ -2188,7 +2296,6 @@ NTSTATUS wow64_ext_glMapNamedBufferRangeEXT( void *args )
 
 static NTSTATUS wow64_gl_unmap_buffer( void *args, NTSTATUS (*gl_unmap_buffer64)(void *) )
 {
-    PTR32 *ptr;
     struct
     {
         PTR32 teb;
@@ -2201,13 +2308,23 @@ static NTSTATUS wow64_gl_unmap_buffer( void *args, NTSTATUS (*gl_unmap_buffer64)
         .target = params32->target,
         .ret = TRUE,
     };
+    PTR32 *ptr;
+    void *wow_ptr;
+    GLint size, flags;
     NTSTATUS status;
 
     if (!(ptr = get_buffer_pointer( params.teb, params.target ))) return STATUS_SUCCESS;
 
-    status = wow64_unmap_buffer( ptr, get_buffer_param( params.teb, params.target, GL_BUFFER_MAP_LENGTH ),
-                                 get_buffer_param( params.teb, params.target, GL_BUFFER_ACCESS_FLAGS ) );
+    /* copy required data while buffer is still mapped */
+    wow_ptr = UlongToPtr(*ptr);
+    size = get_buffer_param( params.teb, params.target, GL_BUFFER_MAP_LENGTH );
+    flags = get_buffer_param( params.teb, params.target, GL_BUFFER_ACCESS_FLAGS );
+
+    /* copy original data back before unmap */
+    *ptr = *(PTR32 *)wow_ptr;
+
     gl_unmap_buffer64( &params );
+    status = wow64_unmap_buffer( params.teb, ptr, wow_ptr, params.target, size, flags );
     params32->ret = params.ret;
 
     return status;
@@ -2225,7 +2342,6 @@ NTSTATUS wow64_ext_glUnmapBufferARB( void *args )
 
 static NTSTATUS wow64_gl_unmap_named_buffer( void *args, NTSTATUS (*gl_unmap_named_buffer64)(void *) )
 {
-    PTR32 *ptr;
     struct
     {
         PTR32 teb;
@@ -2238,13 +2354,23 @@ static NTSTATUS wow64_gl_unmap_named_buffer( void *args, NTSTATUS (*gl_unmap_nam
         .buffer = params32->buffer,
         .ret = TRUE,
     };
+    PTR32 *ptr;
+    void *wow_ptr;
+    GLint size, flags;
     NTSTATUS status;
 
     if (!(ptr = get_named_buffer_pointer( params.teb, params.buffer ))) return STATUS_SUCCESS;
 
-    status = wow64_unmap_buffer( ptr, get_named_buffer_param( params.teb, params.buffer, GL_BUFFER_MAP_LENGTH ),
-                                 get_named_buffer_param( params.teb, params.buffer, GL_BUFFER_ACCESS_FLAGS ) );
+    /* copy required data while buffer is still mapped */
+    wow_ptr = UlongToPtr(*ptr);
+    size = get_named_buffer_param( params.teb, params.buffer, GL_BUFFER_MAP_LENGTH );
+    flags = get_named_buffer_param( params.teb, params.buffer, GL_BUFFER_ACCESS_FLAGS );
+
+    /* copy original data back before unmap */
+    *ptr = *(PTR32 *)wow_ptr;
+
     gl_unmap_named_buffer64( &params );
+    status = wow64_unmap_buffer_named( params.teb, ptr, wow_ptr, params.buffer, size, flags);
     params32->ret = params.ret;
 
     return status;
diff --git a/dlls/opengl32/wgl.c b/dlls/opengl32/wgl.c
index 8d5b8473c7e..c6db41c8061 100644
--- a/dlls/opengl32/wgl.c
+++ b/dlls/opengl32/wgl.c
@@ -1674,6 +1674,31 @@ static void *get_named_buffer_pointer( GLint buffer )
     p_glGetNamedBufferPointerv( buffer, GL_BUFFER_MAP_POINTER, &ptr );
     return ptr;
 }
+
+/* if this code gets called we are in wow64 mode */
+static void *allocate_mapping( SIZE_T length )
+{
+    NTSTATUS status;
+    MEM_EXTENDED_PARAMETER param;
+    void *ret = NULL;
+    MEM_ADDRESS_REQUIREMENTS req = {0};
+
+    req.Alignment = 0x10000;
+    param.Type = MemExtendedParameterAddressRequirements;
+    param.Pointer = &req;
+
+    status = NtAllocateVirtualMemoryEx(NtCurrentProcess(), &ret, &length,
+                                       MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE, &param, 1);
+    if (status) ret = NULL;
+
+    return ret;
+}
+
+static void free_mapping( void *ptr )
+{
+    SIZE_T size = 0;
+    NtFreeVirtualMemory(NtCurrentProcess(), &ptr, &size, MEM_RELEASE);
+}
 #endif
 
 static void *gl_map_buffer( enum unix_funcs code, GLenum target, GLenum access )
@@ -1693,9 +1718,9 @@ static void *gl_map_buffer( enum unix_funcs code, GLenum target, GLenum access )
     if (status == STATUS_INVALID_ADDRESS)
     {
         TRACE( "Unable to map wow64 buffer directly, using copy buffer!\n" );
-        if (!(args.ret = _aligned_malloc( (size_t)args.ret, 16 ))) status = STATUS_NO_MEMORY;
+        if (!(args.ret = allocate_mapping( (SIZE_T)args.ret ))) status = STATUS_NO_MEMORY;
         else if (!(status = WINE_UNIX_CALL( code, &args ))) return args.ret;
-        _aligned_free( args.ret );
+        free_mapping( args.ret );
     }
 #endif
     WARN( "glMapBuffer returned %#lx\n", status );
@@ -1731,9 +1756,9 @@ void * WINAPI glMapBufferRange( GLenum target, GLintptr offset, GLsizeiptr lengt
     if (status == STATUS_INVALID_ADDRESS)
     {
         TRACE( "Unable to map wow64 buffer directly, using copy buffer!\n" );
-        if (!(args.ret = _aligned_malloc( length, 16 ))) status = STATUS_NO_MEMORY;
+        if (!(args.ret = allocate_mapping( (SIZE_T)args.ret ))) status = STATUS_NO_MEMORY;
         else if (!(status = UNIX_CALL( glMapBufferRange, &args ))) return args.ret;
-        _aligned_free( args.ret );
+        free_mapping( args.ret );
     }
 #endif
     WARN( "glMapBufferRange returned %#lx\n", status );
@@ -1757,9 +1782,9 @@ static void *gl_map_named_buffer( enum unix_funcs code, GLuint buffer, GLenum ac
     if (status == STATUS_INVALID_ADDRESS)
     {
         TRACE( "Unable to map wow64 buffer directly, using copy buffer!\n" );
-        if (!(args.ret = _aligned_malloc( (size_t)args.ret, 16 ))) status = STATUS_NO_MEMORY;
+        if (!(args.ret = allocate_mapping( (SIZE_T)args.ret ))) status = STATUS_NO_MEMORY;
         else if (!(status = WINE_UNIX_CALL( code, &args ))) return args.ret;
-        _aligned_free( args.ret );
+        free_mapping( args.ret );
     }
 #endif
     WARN( "glMapNamedBuffer returned %#lx\n", status );
@@ -1795,9 +1820,9 @@ static void *gl_map_named_buffer_range( enum unix_funcs code, GLuint buffer, GLi
     if (status == STATUS_INVALID_ADDRESS)
     {
         TRACE( "Unable to map wow64 buffer directly, using copy buffer!\n" );
-        if (!(args.ret = _aligned_malloc( length, 16 ))) status = STATUS_NO_MEMORY;
+        if (!(args.ret = allocate_mapping( (SIZE_T)args.ret ))) status = STATUS_NO_MEMORY;
         else if (!(status = WINE_UNIX_CALL( code, &args ))) return args.ret;
-        _aligned_free( args.ret );
+        free_mapping( args.ret );
     }
 #endif
     WARN( "glMapNamedBufferRange returned %#lx\n", status );
@@ -1833,7 +1858,7 @@ static GLboolean gl_unmap_buffer( enum unix_funcs code, GLenum target )
     if (status == STATUS_INVALID_ADDRESS)
     {
         TRACE( "Releasing wow64 copy buffer %p\n", ptr );
-        _aligned_free( ptr );
+        free_mapping( ptr );
         return args.ret;
     }
 #endif
@@ -1870,7 +1895,7 @@ static GLboolean gl_unmap_named_buffer( enum unix_funcs code, GLuint buffer )
     if (status == STATUS_INVALID_ADDRESS)
     {
         TRACE( "Releasing wow64 copy buffer %p\n", ptr );
-        _aligned_free( ptr );
+        free_mapping( ptr );
         return args.ret;
     }
 #endif
-- 
2.49.0

From 14ad987cab038a0961cf762df5f298d2bdf33aa0 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Fri, 20 Jun 2025 16:18:18 -0400
Subject: [PATCH 114/159] HACK: opengl32: Reuse allocated memory

around 1.5x to 2x faster on top of the 20x speed up
---
 dlls/opengl32/wgl.c | 51 +++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 49 insertions(+), 2 deletions(-)

diff --git a/dlls/opengl32/wgl.c b/dlls/opengl32/wgl.c
index c6db41c8061..ba7ee6cc5de 100644
--- a/dlls/opengl32/wgl.c
+++ b/dlls/opengl32/wgl.c
@@ -1675,6 +1675,16 @@ static void *get_named_buffer_pointer( GLint buffer )
     return ptr;
 }
 
+/* FIXME: these should be one per GL context */
+struct mem_desc {
+    void *addr;
+    SIZE_T size;
+    BOOL active;
+};
+#define NUM_MAPPINGS 512
+static struct mem_desc mappings[NUM_MAPPINGS];
+static LONG count;
+
 /* if this code gets called we are in wow64 mode */
 static void *allocate_mapping( SIZE_T length )
 {
@@ -1682,6 +1692,34 @@ static void *allocate_mapping( SIZE_T length )
     MEM_EXTENDED_PARAMETER param;
     void *ret = NULL;
     MEM_ADDRESS_REQUIREMENTS req = {0};
+    struct mem_desc *slot = NULL;
+
+    /* an array is easy to implement but may not be the best option */
+    for (LONG i = 0; i < count; i++)
+    {
+        if (!mappings[i].active && mappings[i].size >= length)
+        {
+            return mappings[i].addr;
+        }
+    }
+
+    /* too many mappings are present!
+     * time to clear some out
+     * FIXME: This is not optimal, need to find a way to reduce the count as well when this happens
+     */
+    if (count >= NUM_MAPPINGS)
+    {
+        for (LONG i = 0; i < count; i++)
+        {
+            if (!mappings[i].active)
+            {
+                mappings[i].size = 0;
+                NtFreeVirtualMemory(NtCurrentProcess(), &mappings[i].addr, &mappings[i].size, MEM_RELEASE);
+                mappings[i].addr = NULL;
+                slot = &mappings[i];
+            }
+        }
+    }
 
     req.Alignment = 0x10000;
     param.Type = MemExtendedParameterAddressRequirements;
@@ -1691,13 +1729,22 @@ static void *allocate_mapping( SIZE_T length )
                                        MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE, &param, 1);
     if (status) ret = NULL;
 
+    if (!slot) slot = &mappings[count++];
+
+    slot->addr = ret;
+    slot->size = length;
+    slot->active = TRUE;
+
     return ret;
 }
 
 static void free_mapping( void *ptr )
 {
-    SIZE_T size = 0;
-    NtFreeVirtualMemory(NtCurrentProcess(), &ptr, &size, MEM_RELEASE);
+    for (LONG i = 0; i < count; i++)
+    {
+        if (ptr == mappings[i].addr)
+            mappings[i].active = FALSE;
+    }
 }
 #endif
 
-- 
2.49.0

From 32a124624cac9fd1fb9b4cfd21a1f4b1045aaccd Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Fri, 20 Jun 2025 16:53:50 -0400
Subject: [PATCH 115/159] fixup! opengl32: Support map buffer offsets

---
 dlls/opengl32/unix_wgl.c | 42 +++++++++++++++++-----------------------
 1 file changed, 18 insertions(+), 24 deletions(-)

diff --git a/dlls/opengl32/unix_wgl.c b/dlls/opengl32/unix_wgl.c
index 8c4aada8dfd..9877eedd146 100644
--- a/dlls/opengl32/unix_wgl.c
+++ b/dlls/opengl32/unix_wgl.c
@@ -1924,7 +1924,7 @@ static void get_named_buffer_sub_data( TEB *teb, GLuint buffer, GLintptr offset,
 }
 
 static NTSTATUS wow64_map_buffer( TEB *teb, GLint buffer, GLenum target, void *ptr, SIZE_T size,
-                                  GLbitfield access, PTR32 *ret )
+                                  GLintptr offset, GLbitfield access, PTR32 *ret )
 {
     static unsigned int once;
 
@@ -1937,9 +1937,9 @@ static NTSTATUS wow64_map_buffer( TEB *teb, GLint buffer, GLenum target, void *p
 
             TRACE( "Copying %#zx from buffer at %p to wow64 buffer %p\n", size, ptr, UlongToPtr(*ret) );
             if (buffer)
-                get_named_buffer_sub_data( teb, buffer, 0, size, UlongToPtr(*ret) );
+                get_named_buffer_sub_data( teb, buffer, offset, size, UlongToPtr(*ret) );
             else
-                get_buffer_sub_data( teb, target, 0, size, UlongToPtr(*ret) );
+                get_buffer_sub_data( teb, target, offset, size, UlongToPtr(*ret) );
         }
 
         return STATUS_SUCCESS;
@@ -1977,27 +1977,17 @@ static GLbitfield map_range_flags_from_map_flags( GLenum flags )
     }
 }
 
-static NTSTATUS wow64_unmap_buffer( TEB *teb, void *ptr, void *wow_ptr, GLenum target, SIZE_T size, GLbitfield access )
+static NTSTATUS wow64_unmap_buffer( TEB *teb, void *ptr, void *wow_ptr, GLuint buffer, GLenum target, SIZE_T size, GLintptr offset,  GLbitfield access )
 {
     if (ULongToPtr(PtrToUlong(ptr)) == ptr) return STATUS_SUCCESS;  /* we're lucky */
 
     if (access & GL_MAP_WRITE_BIT)
     {
         TRACE( "Copying %#zx from wow64 buffer %p to buffer %p\n", size, wow_ptr, ptr );
-        buffer_sub_data(teb, target, 0, size, wow_ptr);
-    }
-
-    return STATUS_INVALID_ADDRESS;
-}
-
-static NTSTATUS wow64_unmap_buffer_named( TEB *teb, void *ptr, void *wow_ptr, GLuint buffer, SIZE_T size, GLbitfield access )
-{
-    if (ULongToPtr(PtrToUlong(ptr)) == ptr) return STATUS_SUCCESS;  /* we're lucky */
-
-    if (access & GL_MAP_WRITE_BIT)
-    {
-        TRACE( "Copying %#zx from wow64 buffer %p to buffer %p\n", size, wow_ptr, ptr );
-        named_buffer_sub_data(teb, buffer, 0, size, wow_ptr);
+        if (buffer)
+            named_buffer_sub_data(teb, buffer, offset, size, wow_ptr);
+        else
+            buffer_sub_data(teb, target, offset, size, wow_ptr);
     }
 
     return STATUS_INVALID_ADDRESS;
@@ -2104,7 +2094,7 @@ static NTSTATUS wow64_gl_map_buffer( void *args, NTSTATUS (*gl_map_buffer64)(voi
     }
     else if ((status = gl_map_buffer64( &params ))) return status;
 
-    status = wow64_map_buffer( params.teb, 0, params.target, params.ret, 0,
+    status = wow64_map_buffer( params.teb, 0, params.target, params.ret, 0, 0,
                                map_range_flags_from_map_flags( params.access ), &params32->ret );
     if (wow_ptr)
     {
@@ -2163,7 +2153,7 @@ NTSTATUS wow64_ext_glMapBufferRange( void *args )
     }
     else if ((status = ext_glMapBufferRange( &params ))) return status;
 
-    status = wow64_map_buffer( params.teb, 0, params.target, params.ret, params.length, params.access, &params32->ret );
+    status = wow64_map_buffer( params.teb, 0, params.target, params.ret, params.length, params.offset, params.access, &params32->ret );
 
     if (wow_ptr)
     {
@@ -2209,7 +2199,7 @@ static NTSTATUS wow64_gl_map_named_buffer( void *args, NTSTATUS (*gl_map_named_b
     }
     else if ((status = gl_map_named_buffer64( &params ))) return status;
 
-    status = wow64_map_buffer( params.teb, params.buffer, 0, params.ret, 0,
+    status = wow64_map_buffer( params.teb, params.buffer, 0, params.ret, 0, 0,
                                map_range_flags_from_map_flags( params.access ), &params32->ret );
     if (wow_ptr)
     {
@@ -2268,7 +2258,7 @@ static NTSTATUS wow64_gl_map_named_buffer_range( void *args, NTSTATUS (*gl_map_n
     }
     else if ((status = gl_map_named_buffer_range64( &params ))) return status;
 
-    status = wow64_map_buffer( params.teb, params.buffer, 0, params.ret, params.length, params.access, &params32->ret );
+    status = wow64_map_buffer( params.teb, params.buffer, 0, params.ret, params.length, params.offset, params.access, &params32->ret );
 
     if (wow_ptr)
     {
@@ -2310,6 +2300,7 @@ static NTSTATUS wow64_gl_unmap_buffer( void *args, NTSTATUS (*gl_unmap_buffer64)
     };
     PTR32 *ptr;
     void *wow_ptr;
+    GLintptr offset;
     GLint size, flags;
     NTSTATUS status;
 
@@ -2319,12 +2310,13 @@ static NTSTATUS wow64_gl_unmap_buffer( void *args, NTSTATUS (*gl_unmap_buffer64)
     wow_ptr = UlongToPtr(*ptr);
     size = get_buffer_param( params.teb, params.target, GL_BUFFER_MAP_LENGTH );
     flags = get_buffer_param( params.teb, params.target, GL_BUFFER_ACCESS_FLAGS );
+    offset = get_buffer_param( params.teb, params.target, GL_BUFFER_MAP_OFFSET );
 
     /* copy original data back before unmap */
     *ptr = *(PTR32 *)wow_ptr;
 
     gl_unmap_buffer64( &params );
-    status = wow64_unmap_buffer( params.teb, ptr, wow_ptr, params.target, size, flags );
+    status = wow64_unmap_buffer( params.teb, ptr, wow_ptr, 0, params.target, size, offset, flags );
     params32->ret = params.ret;
 
     return status;
@@ -2356,6 +2348,7 @@ static NTSTATUS wow64_gl_unmap_named_buffer( void *args, NTSTATUS (*gl_unmap_nam
     };
     PTR32 *ptr;
     void *wow_ptr;
+    GLintptr offset;
     GLint size, flags;
     NTSTATUS status;
 
@@ -2365,12 +2358,13 @@ static NTSTATUS wow64_gl_unmap_named_buffer( void *args, NTSTATUS (*gl_unmap_nam
     wow_ptr = UlongToPtr(*ptr);
     size = get_named_buffer_param( params.teb, params.buffer, GL_BUFFER_MAP_LENGTH );
     flags = get_named_buffer_param( params.teb, params.buffer, GL_BUFFER_ACCESS_FLAGS );
+    offset = get_named_buffer_param( params.teb, params.buffer, GL_BUFFER_MAP_OFFSET );
 
     /* copy original data back before unmap */
     *ptr = *(PTR32 *)wow_ptr;
 
     gl_unmap_named_buffer64( &params );
-    status = wow64_unmap_buffer_named( params.teb, ptr, wow_ptr, params.buffer, size, flags);
+    status = wow64_unmap_buffer( params.teb, ptr, wow_ptr, params.buffer, 0, size, offset, flags);
     params32->ret = params.ret;
 
     return status;
-- 
2.49.0

From 9a26abd7ba89e712ed45cb2214c6f719ca44bef6 Mon Sep 17 00:00:00 2001
From: Byeongsik Jeon <bsjeon@hanmail.net>
Date: Thu, 17 Apr 2025 04:21:14 +0900
Subject: [PATCH 116/159] winewayland: Use an empty string to clear the
 composition string.

---
 dlls/winewayland.drv/wayland_text_input.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_text_input.c b/dlls/winewayland.drv/wayland_text_input.c
index f8df5fe09cb..bb974cd06fd 100644
--- a/dlls/winewayland.drv/wayland_text_input.c
+++ b/dlls/winewayland.drv/wayland_text_input.c
@@ -35,6 +35,9 @@ WINE_DEFAULT_DEBUG_CHANNEL(imm);
 
 static void post_ime_update(HWND hwnd, UINT cursor_pos, WCHAR *comp_str, WCHAR *result_str)
 {
+    /* Windows uses an empty string to clear the composition string. */
+    if (!comp_str && !result_str) comp_str = (WCHAR *)L"";
+
     NtUserMessageCall(hwnd, WINE_IME_POST_UPDATE, cursor_pos, (LPARAM)comp_str, result_str,
             NtUserImeDriverCall, FALSE);
 }
-- 
2.49.0

From 487676b75a3ba313592c031cd0573d4e2cb92715 Mon Sep 17 00:00:00 2001
From: Byeongsik Jeon <bsjeon@hanmail.net>
Date: Mon, 21 Oct 2024 08:19:49 +0900
Subject: [PATCH 117/159] win32u: Preserve result string from multiple
 WINE_IME_POST_UPDATE calls during ImeProcessKey.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

In winemac.drv, there are multiple ime update calls occur during ImeProcessKey.
These multiple ime update calls need to be properly merged into ‘data->update’.
However, currently win32u/imm.c::post_ime_update() only keeps the last ime
update call.

Valid rules are:
 - The previous comp_str is discarded when the new ime update call occurs,
   so it is only valid if the last ime update call comp_str is not NULL.
 - The previous result_str is kept if the new ime update call result_str is NULL.
 - If both the previous and the new ime update call result_str are not NULL, then
   concatenate them.

Test key sequences are:
 - "Japanese Romanji" : 'nihongo-SPACE-n'
 - "Korean 2-Set Keyboard" : 'r-k-s-k'
 - "Korean 2-Set Keyboard" : 'r-k-1" or 'r-k-SPACE'
---
 dlls/win32u/imm.c | 25 +++++++++++++++++++++++--
 1 file changed, 23 insertions(+), 2 deletions(-)

diff --git a/dlls/win32u/imm.c b/dlls/win32u/imm.c
index 99dc3e5e225..717dbf43ee6 100644
--- a/dlls/win32u/imm.c
+++ b/dlls/win32u/imm.c
@@ -440,7 +440,8 @@ static void post_ime_update( HWND hwnd, UINT cursor_pos, WCHAR *comp_str, WCHAR
     static UINT ime_update_count;
 
     struct imm_thread_data *data = get_imm_thread_data();
-    UINT id = -1, comp_len, result_len;
+    UINT id = -1, comp_len, result_len, prev_result_len;
+    WCHAR *prev_result_str, *tmp;
     struct ime_update *update;
 
     TRACE( "hwnd %p, cursor_pos %u, comp_str %s, result_str %s\n", hwnd, cursor_pos,
@@ -449,7 +450,25 @@ static void post_ime_update( HWND hwnd, UINT cursor_pos, WCHAR *comp_str, WCHAR
     comp_len = comp_str ? wcslen( comp_str ) + 1 : 0;
     result_len = result_str ? wcslen( result_str ) + 1 : 0;
 
-    if (!(update = malloc( offsetof(struct ime_update, buffer[comp_len + result_len]) ))) return;
+    /* prepend or keep the previous result string, if there was any */
+    if (!data->ime_process_vkey || !data->update) prev_result_str = NULL;
+    else prev_result_str = data->update->result_str;
+    prev_result_len = prev_result_str ? wcslen( prev_result_str ) + 1 : 0;
+
+    if (!prev_result_len && !result_len) tmp = NULL;
+    else if (!(tmp = malloc( (prev_result_len + result_len) * sizeof(WCHAR) ))) return;
+
+    if (prev_result_len && result_len) prev_result_len -= 1; /* concat both strings */
+    if (prev_result_len) memcpy( tmp, prev_result_str, prev_result_len * sizeof(WCHAR) );
+    if (result_len) memcpy( tmp + prev_result_len, result_str, result_len * sizeof(WCHAR) );
+    result_len += prev_result_len;
+    result_str = tmp;
+
+    if (!(update = malloc( offsetof(struct ime_update, buffer[comp_len + result_len]) )))
+    {
+        free( tmp );
+        return;
+    }
     update->cursor_pos = cursor_pos;
     update->comp_str = comp_str ? memcpy( update->buffer, comp_str, comp_len * sizeof(WCHAR) ) : NULL;
     update->result_str = result_str ? memcpy( update->buffer + comp_len, result_str, result_len * sizeof(WCHAR) ) : NULL;
@@ -470,6 +489,8 @@ static void post_ime_update( HWND hwnd, UINT cursor_pos, WCHAR *comp_str, WCHAR
         free( data->update );
         data->update = update;
     }
+
+    free( tmp );
 }
 
 static struct ime_update *find_ime_update( WORD vkey, WORD scan )
-- 
2.49.0

From 762e5533cc7c26912aa6815b806b8cebccd78368 Mon Sep 17 00:00:00 2001
From: Byeongsik Jeon <bsjeon@hanmail.net>
Date: Tue, 8 Apr 2025 21:00:28 +0900
Subject: [PATCH 118/159] win32u: Support WM_IME_KEYDOWN message during
 ImeProcessKey.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

In Korean input, when ime is in the composition state, if a non-printable key
(ENTER, HOME, etc) is pressed, it returns a result_string and passes the key
to WinProc with the WM_IME_KEYDOWN message.

This can be seen in ‘imm32/test/imm32.c::test_ga_na_da()’.

In the current winemac.drv, if I select the “Korean 2-Set Keyboard” as the
input source and type ‘r-k-ENTER’, it only returns the result string ‘0xAC00’.
No WM_IME_KEYDOWN message is generated.

At this point, the WINE_IME_POST_UPDATE call occurs and macdrv_ImeProcessKey
returns FALSE. A FALSE return value means that the key has not been consumed
by ime and the key should be passed to the WinProc as a raw WM_KEYDOWN.

However, because the ime_update call have occurred, ImeProcessKey should return
TRUE and a raw WM_KEYDOWN message should be generated via a different path.
So a WM_IME_KEYDOWN message is required.

This patch allows the macdrv_ImeProcessKey return value to be passed to
ImeToAsciiEx() to determine if a WM_IME_KEYDOWN message should be generated.
---
 dlls/imm32/ime.c     |  8 ++++++++
 dlls/win32u/imm.c    | 10 ++++++++--
 dlls/wow64win/user.c |  2 ++
 include/ntuser.h     |  1 +
 4 files changed, 19 insertions(+), 2 deletions(-)

diff --git a/dlls/imm32/ime.c b/dlls/imm32/ime.c
index 6f1d68ad0d4..77caf884efa 100644
--- a/dlls/imm32/ime.c
+++ b/dlls/imm32/ime.c
@@ -529,6 +529,7 @@ UINT WINAPI ImeToAsciiEx( UINT vkey, UINT vsc, BYTE *state, TRANSMSGLIST *msgs,
     UINT size, count = 0;
     INPUTCONTEXT *ctx;
     NTSTATUS status;
+    BOOL key_consumed = TRUE;
 
     TRACE( "vkey %#x, vsc %#x, state %p, msgs %p, flags %#x, himc %p\n",
            vkey, vsc, state, msgs, flags, himc );
@@ -547,6 +548,7 @@ UINT WINAPI ImeToAsciiEx( UINT vkey, UINT vsc, BYTE *state, TRANSMSGLIST *msgs,
         if (!(compstr = ImmLockIMCC( (ctx->hCompStr = himcc) ))) goto done;
 
         params.compstr = compstr;
+        params.key_consumed = &key_consumed;
         status = NtUserMessageCall( ctx->hWnd, WINE_IME_TO_ASCII_EX, vkey, vsc, &params,
                                     NtUserImeDriverCall, FALSE );
         size = compstr->dwSize;
@@ -575,6 +577,12 @@ UINT WINAPI ImeToAsciiEx( UINT vkey, UINT vsc, BYTE *state, TRANSMSGLIST *msgs,
             else msg.lParam |= CS_INSERTCHAR|CS_NOMOVECARET;
             msgs->TransMsg[count++] = msg;
         }
+
+        if (!key_consumed)
+        {
+            TRANSMSG msg = {.message = WM_IME_KEYDOWN, .wParam = vkey, .lParam = vsc};
+            msgs->TransMsg[count++] = msg;
+        }
     }
 
     ImmUnlockIMCC( ctx->hCompStr );
diff --git a/dlls/win32u/imm.c b/dlls/win32u/imm.c
index 717dbf43ee6..c0ed670e779 100644
--- a/dlls/win32u/imm.c
+++ b/dlls/win32u/imm.c
@@ -39,6 +39,7 @@ struct ime_update
     struct list entry;
     WORD vkey;
     WORD scan;
+    BOOL key_consumed;
     DWORD cursor_pos;
     WCHAR *comp_str;
     WCHAR *result_str;
@@ -478,6 +479,7 @@ static void post_ime_update( HWND hwnd, UINT cursor_pos, WCHAR *comp_str, WCHAR
         pthread_mutex_lock( &imm_mutex );
         id = update->scan = ++ime_update_count;
         update->vkey = VK_PROCESSKEY;
+        update->key_consumed = TRUE;
         list_add_tail( &ime_updates, &update->entry );
         pthread_mutex_unlock( &imm_mutex );
 
@@ -503,7 +505,8 @@ static struct ime_update *find_ime_update( WORD vkey, WORD scan )
     return NULL;
 }
 
-UINT ime_to_tascii_ex( UINT vkey, UINT lparam, const BYTE *state, COMPOSITIONSTRING *compstr, HIMC himc )
+static UINT ime_to_tascii_ex( UINT vkey, UINT lparam, const BYTE *state, COMPOSITIONSTRING *compstr,
+                              BOOL *key_consumed, HIMC himc )
 {
     UINT needed = sizeof(COMPOSITIONSTRING), comp_len, result_len;
     struct ime_update *update;
@@ -519,6 +522,8 @@ UINT ime_to_tascii_ex( UINT vkey, UINT lparam, const BYTE *state, COMPOSITIONSTR
         return STATUS_NOT_FOUND;
     }
 
+    *key_consumed = update->key_consumed;
+
     if (!update->comp_str) comp_len = 0;
     else
     {
@@ -611,6 +616,7 @@ LRESULT ime_driver_call( HWND hwnd, enum wine_ime_call call, WPARAM wparam, LPAR
 
         if (data->update)
         {
+            data->update->key_consumed = res;
             pthread_mutex_lock( &imm_mutex );
             list_add_tail( &ime_updates, &data->update->entry );
             pthread_mutex_unlock( &imm_mutex );
@@ -622,7 +628,7 @@ LRESULT ime_driver_call( HWND hwnd, enum wine_ime_call call, WPARAM wparam, LPAR
         return res;
     }
     case WINE_IME_TO_ASCII_EX:
-        return ime_to_tascii_ex( wparam, lparam, params->state, params->compstr, params->himc );
+        return ime_to_tascii_ex( wparam, lparam, params->state, params->compstr, params->key_consumed, params->himc );
     case WINE_IME_POST_UPDATE:
         post_ime_update( hwnd, wparam, (WCHAR *)lparam, (WCHAR *)params );
         return 0;
diff --git a/dlls/wow64win/user.c b/dlls/wow64win/user.c
index b75c2962398..effe8ebffae 100644
--- a/dlls/wow64win/user.c
+++ b/dlls/wow64win/user.c
@@ -3662,12 +3662,14 @@ NTSTATUS WINAPI wow64_NtUserMessageCall( UINT *args )
                 ULONG himc;
                 ULONG state;
                 ULONG compstr;
+                ULONG key_consumed;
             } *params32 = result_info;
             struct ime_driver_call_params params;
             if (msg == WINE_IME_POST_UPDATE) ERR( "Unexpected WINE_IME_POST_UPDATE message\n" );
             params.himc = UlongToPtr( params32->himc );
             params.state = UlongToPtr( params32->state );
             params.compstr = UlongToPtr( params32->compstr );
+            params.key_consumed = UlongToPtr( params32->key_consumed );
             return NtUserMessageCall( hwnd, msg, wparam, lparam, &params, type, ansi );
         }
 
diff --git a/include/ntuser.h b/include/ntuser.h
index 9bd04a647dd..6f5c0eba0ee 100644
--- a/include/ntuser.h
+++ b/include/ntuser.h
@@ -647,6 +647,7 @@ struct ime_driver_call_params
     HIMC himc;
     const BYTE *state;
     COMPOSITIONSTRING *compstr;
+    BOOL *key_consumed;
 };
 
 /* NtUserSystemTrayCall calls */
-- 
2.49.0

From d0bcfecb180b9111741ee2dff0dbe6b8f18bf789 Mon Sep 17 00:00:00 2001
From: Byeongsik Jeon <bsjeon@hanmail.net>
Date: Sun, 6 Apr 2025 10:14:41 +0900
Subject: [PATCH 119/159] win32u: Add more CompAttr, CompClause implementation
 using cursor_begin, cursor_end concept.

If CompAttr and CompClause are properly configured, Japanese input
will be more comfortable.

Inspired by cursor_begin and cursor_end from Wayland zwp_text_input_v3::
preedit_string, I extended the cursor_pos concept as follows:

    cursor_pos = MAKELONG( cursor_begin, cursor_end );

ime_to_tascii_ex() uses this to construct Compttr, CompClause.
MS Windows native CompStrAttr, CompStrClause is a bit more complicated
than this, but the concept is useful enough.

It requires additional implementation in the Wine ime_ui_window proc and
richedit control. However, it is useful for applications that inline ime
composition string.

This can be tested with MS Office Word, Excel. LANG=ja_JP.UTF-8 wine EXCEL.EXE

Test key sequences:
  - 'n-i-h-o-n-g-o-n-o-m-o-j-i-d-e-s-u-.-SPACE'.
  - And, RIGHT, LEFT, Shift+LEFT, Shift+RIGHT, ESC, SPACE, UP, DOWN, etc.
---
 dlls/win32u/imm.c | 69 ++++++++++++++++++++++++++++++++++++++++-------
 1 file changed, 60 insertions(+), 9 deletions(-)

diff --git a/dlls/win32u/imm.c b/dlls/win32u/imm.c
index c0ed670e779..1c677772e0c 100644
--- a/dlls/win32u/imm.c
+++ b/dlls/win32u/imm.c
@@ -445,8 +445,8 @@ static void post_ime_update( HWND hwnd, UINT cursor_pos, WCHAR *comp_str, WCHAR
     WCHAR *prev_result_str, *tmp;
     struct ime_update *update;
 
-    TRACE( "hwnd %p, cursor_pos %u, comp_str %s, result_str %s\n", hwnd, cursor_pos,
-           debugstr_w(comp_str), debugstr_w(result_str) );
+    TRACE( "hwnd %p, cursor_pos %u - %u, comp_str %s, result_str %s\n", hwnd, LOWORD(cursor_pos),
+           HIWORD(cursor_pos), debugstr_w(comp_str), debugstr_w(result_str) );
 
     comp_len = comp_str ? wcslen( comp_str ) + 1 : 0;
     result_len = result_str ? wcslen( result_str ) + 1 : 0;
@@ -495,6 +495,48 @@ static void post_ime_update( HWND hwnd, UINT cursor_pos, WCHAR *comp_str, WCHAR
     free( tmp );
 }
 
+static UINT get_comp_clause_count( UINT comp_len, UINT cursor_begin, UINT cursor_end )
+{
+    if (cursor_begin == cursor_end || (cursor_begin == 0 && cursor_end == comp_len))
+        return 2;
+    else if (cursor_begin == 0 || cursor_end == comp_len)
+        return 3;
+    else
+        return 4;
+}
+
+static void set_comp_clause( DWORD *comp_clause, UINT comp_clause_count, UINT comp_len,
+                             UINT cursor_begin, UINT cursor_end )
+{
+    comp_clause[0] = 0;
+    switch (comp_clause_count)
+    {
+    case 2:
+        comp_clause[1] = comp_len;
+        break;
+    case 3:
+        comp_clause[1] = cursor_begin == 0 ? cursor_end : cursor_begin;
+        comp_clause[2] = comp_len;
+        break;
+    case 4:
+        comp_clause[1] = cursor_begin;
+        comp_clause[2] = cursor_end;
+        comp_clause[3] = comp_len;
+        break;
+    }
+}
+
+static void set_comp_attr( BYTE *comp_attr, UINT comp_attr_len, UINT cursor_begin, UINT cursor_end )
+{
+    if (cursor_begin == cursor_end)
+        memset( comp_attr, ATTR_INPUT, comp_attr_len );
+    else
+    {
+        memset( comp_attr, ATTR_CONVERTED, comp_attr_len );
+        memset( comp_attr + cursor_begin, ATTR_TARGET_CONVERTED, cursor_end - cursor_begin );
+    }
+}
+
 static struct ime_update *find_ime_update( WORD vkey, WORD scan )
 {
     struct ime_update *update;
@@ -508,7 +550,8 @@ static struct ime_update *find_ime_update( WORD vkey, WORD scan )
 static UINT ime_to_tascii_ex( UINT vkey, UINT lparam, const BYTE *state, COMPOSITIONSTRING *compstr,
                               BOOL *key_consumed, HIMC himc )
 {
-    UINT needed = sizeof(COMPOSITIONSTRING), comp_len, result_len;
+    UINT needed = sizeof(COMPOSITIONSTRING), comp_len, result_len, comp_clause_count = 0;
+    UINT cursor_begin = 0, cursor_end = 0;
     struct ime_update *update;
     void *dst;
 
@@ -528,9 +571,18 @@ static UINT ime_to_tascii_ex( UINT vkey, UINT lparam, const BYTE *state, COMPOSI
     else
     {
         comp_len = wcslen( update->comp_str );
+        cursor_begin = LOWORD(update->cursor_pos);
+        cursor_end   = HIWORD(update->cursor_pos);
+
+        if (cursor_begin > comp_len) cursor_begin = comp_len;
+        if (cursor_end > comp_len) cursor_end = comp_len;
+        if (cursor_end < cursor_begin) cursor_end = cursor_begin;
+
+        comp_clause_count = get_comp_clause_count( comp_len, cursor_begin, cursor_end );
+
         needed += comp_len * sizeof(WCHAR); /* GCS_COMPSTR */
         needed += comp_len; /* GCS_COMPATTR */
-        needed += 2 * sizeof(DWORD); /* GCS_COMPCLAUSE */
+        needed += comp_clause_count * sizeof(DWORD); /* GCS_COMPCLAUSE */
     }
 
     if (!update->result_str) result_len = 0;
@@ -556,7 +608,7 @@ static UINT ime_to_tascii_ex( UINT vkey, UINT lparam, const BYTE *state, COMPOSI
 
     if (update->comp_str)
     {
-        compstr->dwCursorPos = update->cursor_pos;
+        compstr->dwCursorPos = cursor_begin;
 
         compstr->dwCompStrLen = comp_len;
         compstr->dwCompStrOffset = compstr->dwSize;
@@ -564,17 +616,16 @@ static UINT ime_to_tascii_ex( UINT vkey, UINT lparam, const BYTE *state, COMPOSI
         memcpy( dst, update->comp_str, compstr->dwCompStrLen * sizeof(WCHAR) );
         compstr->dwSize += compstr->dwCompStrLen * sizeof(WCHAR);
 
-        compstr->dwCompClauseLen = 2 * sizeof(DWORD);
+        compstr->dwCompClauseLen = comp_clause_count * sizeof(DWORD);
         compstr->dwCompClauseOffset = compstr->dwSize;
         dst = (BYTE *)compstr + compstr->dwCompClauseOffset;
-        *((DWORD *)dst + 0) = 0;
-        *((DWORD *)dst + 1) = compstr->dwCompStrLen;
+        set_comp_clause( dst, comp_clause_count, comp_len, cursor_begin, cursor_end );
         compstr->dwSize += compstr->dwCompClauseLen;
 
         compstr->dwCompAttrLen = compstr->dwCompStrLen;
         compstr->dwCompAttrOffset = compstr->dwSize;
         dst = (BYTE *)compstr + compstr->dwCompAttrOffset;
-        memset( dst, ATTR_INPUT, compstr->dwCompAttrLen );
+        set_comp_attr( dst, compstr->dwCompAttrLen, cursor_begin, cursor_end );
         compstr->dwSize += compstr->dwCompAttrLen;
     }
 
-- 
2.49.0

From 87b0bad3786d639da1a4f399cab498270db516ea Mon Sep 17 00:00:00 2001
From: Byeongsik Jeon <bsjeon@hanmail.net>
Date: Sun, 6 Apr 2025 10:13:19 +0900
Subject: [PATCH 120/159] winewayland: Extend cursor_pos using cursor_begin,
 cursor_end.

---
 dlls/winewayland.drv/wayland_text_input.c | 13 ++++++++-----
 1 file changed, 8 insertions(+), 5 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_text_input.c b/dlls/winewayland.drv/wayland_text_input.c
index bb974cd06fd..18f64797131 100644
--- a/dlls/winewayland.drv/wayland_text_input.c
+++ b/dlls/winewayland.drv/wayland_text_input.c
@@ -103,14 +103,17 @@ static void text_input_preedit_string(void *data, struct zwp_text_input_v3 *zwp_
         const char *text, int32_t cursor_begin, int32_t cursor_end)
 {
     struct wayland_text_input *text_input = data;
-    TRACE("data %p, text_input %p, text %s, cursor_begin %d.\n", data, zwp_text_input_v3,
-            debugstr_a(text), cursor_begin);
+    TRACE("data %p, text_input %p, text %s, cursor %d - %d.\n", data, zwp_text_input_v3,
+            debugstr_a(text), cursor_begin, cursor_end);
 
     pthread_mutex_lock(&text_input->mutex);
-    if ((text_input->preedit_string = strdupUtoW(text)) && cursor_begin > 0)
+    if ((text_input->preedit_string = strdupUtoW(text)))
     {
-        RtlUTF8ToUnicodeN(NULL, 0, &text_input->preedit_cursor_pos, text, cursor_begin);
-        text_input->preedit_cursor_pos /= sizeof(WCHAR);
+        DWORD begin = 0, end = 0;
+
+        if (cursor_begin > 0) RtlUTF8ToUnicodeN(NULL, 0, &begin, text, cursor_begin);
+        if (cursor_end > 0) RtlUTF8ToUnicodeN(NULL, 0, &end, text, cursor_end);
+        text_input->preedit_cursor_pos = MAKELONG(begin / sizeof(WCHAR), end / sizeof(WCHAR));
     }
     pthread_mutex_unlock(&text_input->mutex);
 }
-- 
2.49.0

From 2188b929bd0a4cffbac6411d9cce800c61828bc2 Mon Sep 17 00:00:00 2001
From: Byeongsik Jeon <bsjeon@hanmail.net>
Date: Fri, 21 Feb 2025 22:40:05 +0900
Subject: [PATCH 121/159] winemac: Extend cursor_pos using cursor_begin,
 cursor_end.

---
 dlls/winemac.drv/cocoa_window.m | 3 ++-
 dlls/winemac.drv/event.c        | 4 +++-
 dlls/winemac.drv/macdrv_cocoa.h | 3 ++-
 3 files changed, 7 insertions(+), 3 deletions(-)

diff --git a/dlls/winemac.drv/cocoa_window.m b/dlls/winemac.drv/cocoa_window.m
index ce8b571fa23..7348d692e15 100644
--- a/dlls/winemac.drv/cocoa_window.m
+++ b/dlls/winemac.drv/cocoa_window.m
@@ -874,7 +874,8 @@ - (void) setMarkedText:(id)string selectedRange:(NSRange)selectedRange replaceme
             event->im_set_text.himc = [window himc];
             event->im_set_text.text = (CFStringRef)[[markedText string] copy];
             event->im_set_text.complete = FALSE;
-            event->im_set_text.cursor_pos = markedTextSelection.location + markedTextSelection.length;
+            event->im_set_text.cursor_begin = markedTextSelection.location;
+            event->im_set_text.cursor_end = markedTextSelection.location + markedTextSelection.length;
 
             [[window queue] postEvent:event];
 
diff --git a/dlls/winemac.drv/event.c b/dlls/winemac.drv/event.c
index 20a791ac48a..82bf829d1a0 100644
--- a/dlls/winemac.drv/event.c
+++ b/dlls/winemac.drv/event.c
@@ -176,7 +176,9 @@ static void macdrv_im_set_text(const macdrv_event *event)
     }
 
     if (event->im_set_text.complete) post_ime_update(hwnd, -1, NULL, text);
-    else post_ime_update(hwnd, event->im_set_text.cursor_pos, text, NULL);
+    else post_ime_update(hwnd,
+                         MAKELONG(event->im_set_text.cursor_begin, event->im_set_text.cursor_end),
+                         text, NULL);
 
     free(text);
 }
diff --git a/dlls/winemac.drv/macdrv_cocoa.h b/dlls/winemac.drv/macdrv_cocoa.h
index 20d82b9bef8..7e88e5f094b 100644
--- a/dlls/winemac.drv/macdrv_cocoa.h
+++ b/dlls/winemac.drv/macdrv_cocoa.h
@@ -365,7 +365,8 @@ extern int macdrv_set_display_mode(const struct macdrv_display* display,
         struct {
             void           *himc;
             CFStringRef     text;       /* new text or NULL if just completing existing text */
-            unsigned int    cursor_pos;
+            unsigned int    cursor_begin;
+            unsigned int    cursor_end;
             unsigned int    complete;   /* is completing text? */
         }                                           im_set_text;
         struct {
-- 
2.49.0

From 97cef8c651192c1a565362c17c08dd195fac6d10 Mon Sep 17 00:00:00 2001
From: Byeongsik Jeon <bsjeon@hanmail.net>
Date: Sat, 22 Feb 2025 00:51:43 +0900
Subject: [PATCH 122/159] winex11: Extend cursor_pos using cursor_begin,
 cursor_end.

When tested on ibus, fcitx5, and uim, the applicable bit is XIMReverse.
Since these always have chg_first == 0, I referenced the libX11 documentation
for applying chg_first.
---
 dlls/winex11.drv/xim.c | 31 +++++++++++++++++++++++++++++--
 1 file changed, 29 insertions(+), 2 deletions(-)

diff --git a/dlls/winex11.drv/xim.c b/dlls/winex11.drv/xim.c
index f09067f232e..a7592a146f2 100644
--- a/dlls/winex11.drv/xim.c
+++ b/dlls/winex11.drv/xim.c
@@ -168,6 +168,33 @@ static int xic_preedit_done( XIC xic, XPointer user, XPointer arg )
     return 0;
 }
 
+static DWORD get_comp_cursor_pos( XIMPreeditDrawCallbackStruct *params )
+{
+    int i, cursor_begin = -1, cursor_end = -1;
+    XIMText *text = params->text;
+
+    if (text && text->feedback)
+    {
+        for (i = 0; i < text->length; i++)
+        {
+            if (text->feedback[i] & XIMReverse)
+            {
+                if (cursor_begin == -1) cursor_begin = i;
+                cursor_end = i + 1;
+            }
+        }
+        if (cursor_begin != -1) cursor_begin += params->chg_first;
+        if (cursor_end   != -1) cursor_end   += params->chg_first;
+    }
+
+    if (cursor_begin == cursor_end)
+        cursor_begin = cursor_end = params->caret; /* ATTR_INPUT */
+
+    TRACE( "caret %d, cursor_begin %d, cursor_end %d\n", params->caret, cursor_begin, cursor_end );
+
+    return MAKELONG( cursor_begin, cursor_end );
+}
+
 static int xic_preedit_draw( XIC xic, XPointer user, XPointer arg )
 {
     XIMPreeditDrawCallbackStruct *params = (void *)arg;
@@ -202,7 +229,7 @@ static int xic_preedit_draw( XIC xic, XPointer user, XPointer arg )
 
     if (text && str != text->string.multi_byte) free( str );
 
-    post_ime_update( hwnd, params->caret, ime_comp_buf, NULL );
+    post_ime_update( hwnd, get_comp_cursor_pos( params ), ime_comp_buf, NULL );
 
     return 0;
 }
@@ -248,7 +275,7 @@ static int xic_preedit_caret( XIC xic, XPointer user, XPointer arg )
     }
     params->position = xim_caret_pos = pos;
 
-    post_ime_update( hwnd, pos, ime_comp_buf, NULL );
+    post_ime_update( hwnd, MAKELONG( pos, pos ), ime_comp_buf, NULL );
 
     return 0;
 }
-- 
2.49.0

From 974f30b6ebad31e13f6abd6d889bbc5cb008dada Mon Sep 17 00:00:00 2001
From: Byeongsik Jeon <bsjeon@hanmail.net>
Date: Thu, 10 Apr 2025 14:21:31 +0900
Subject: [PATCH 123/159] winex11: Update only when caret pos changed in
 xic_preedit_caret.

---
 dlls/winex11.drv/xim.c | 19 ++++++++++++++-----
 1 file changed, 14 insertions(+), 5 deletions(-)

diff --git a/dlls/winex11.drv/xim.c b/dlls/winex11.drv/xim.c
index a7592a146f2..4c93c73cc23 100644
--- a/dlls/winex11.drv/xim.c
+++ b/dlls/winex11.drv/xim.c
@@ -45,6 +45,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(xim);
 #endif
 
 static WCHAR *ime_comp_buf;
+static DWORD ime_comp_cursor_pos = 0;
 
 static XIMStyle input_style = 0;
 static XIMStyle input_style_req = XIMPreeditCallbacks | XIMStatusCallbacks;
@@ -229,14 +230,14 @@ static int xic_preedit_draw( XIC xic, XPointer user, XPointer arg )
 
     if (text && str != text->string.multi_byte) free( str );
 
-    post_ime_update( hwnd, get_comp_cursor_pos( params ), ime_comp_buf, NULL );
+    ime_comp_cursor_pos = get_comp_cursor_pos( params );
+    post_ime_update( hwnd, ime_comp_cursor_pos, ime_comp_buf, NULL );
 
     return 0;
 }
 
 static int xic_preedit_caret( XIC xic, XPointer user, XPointer arg )
 {
-    static int xim_caret_pos;
     XIMPreeditCaretCallbackStruct *params = (void *)arg;
     HWND hwnd = (HWND)user;
     int pos;
@@ -245,7 +246,7 @@ static int xic_preedit_caret( XIC xic, XPointer user, XPointer arg )
 
     if (!params) return 0;
 
-    pos = xim_caret_pos;
+    pos = LOWORD( ime_comp_cursor_pos );
     switch (params->direction)
     {
     case XIMForwardChar:
@@ -273,9 +274,17 @@ static int xic_preedit_caret( XIC xic, XPointer user, XPointer arg )
         FIXME( "Not implemented\n" );
         break;
     }
-    params->position = xim_caret_pos = pos;
+    params->position = pos;
 
-    post_ime_update( hwnd, MAKELONG( pos, pos ), ime_comp_buf, NULL );
+    /* uim implements the preedit_caret callback. This callback is only
+       valid when the xim is in non-converted state (ATTR_INPUT).
+     */
+    if (LOWORD( ime_comp_cursor_pos ) == HIWORD( ime_comp_cursor_pos ) &&
+        LOWORD( ime_comp_cursor_pos ) != pos)
+    {
+        ime_comp_cursor_pos = MAKELONG( pos, pos );
+        post_ime_update( hwnd, ime_comp_cursor_pos, ime_comp_buf, NULL );
+    }
 
     return 0;
 }
-- 
2.49.0

From ac44f675b6a51247823c81d29e30c4a52bd901ae Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 3 Jun 2025 14:57:00 +0300
Subject: [PATCH 124/159] winewayland: Improve cleanup of text-input pending
 state.

Ensure state resources are cleaned up when not needed, and also avoid
memory leaks in case we get multiple events for the same state before
a "done" event.
---
 dlls/winewayland.drv/wayland_text_input.c | 33 +++++++++++++++--------
 1 file changed, 22 insertions(+), 11 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_text_input.c b/dlls/winewayland.drv/wayland_text_input.c
index 18f64797131..ddf30abe12a 100644
--- a/dlls/winewayland.drv/wayland_text_input.c
+++ b/dlls/winewayland.drv/wayland_text_input.c
@@ -60,6 +60,15 @@ static WCHAR *strdupUtoW(const char *str)
     return ret;
 }
 
+static void wayland_text_input_reset_pending_state(struct wayland_text_input *text_input)
+{
+    free(text_input->preedit_string);
+    text_input->preedit_string = NULL;
+    text_input->preedit_cursor_pos = 0;
+    free(text_input->commit_string);
+    text_input->commit_string = NULL;
+}
+
 static void text_input_enter(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
         struct wl_surface *surface)
 {
@@ -96,6 +105,7 @@ static void text_input_leave(void *data, struct zwp_text_input_v3 *zwp_text_inpu
         post_ime_update(text_input->focused_hwnd, 0, NULL, NULL);
         text_input->focused_hwnd = NULL;
     }
+    wayland_text_input_reset_pending_state(text_input);
     pthread_mutex_unlock(&text_input->mutex);
 }
 
@@ -103,18 +113,22 @@ static void text_input_preedit_string(void *data, struct zwp_text_input_v3 *zwp_
         const char *text, int32_t cursor_begin, int32_t cursor_end)
 {
     struct wayland_text_input *text_input = data;
+    DWORD begin = 0, end = 0;
+    WCHAR *textW;
+
     TRACE("data %p, text_input %p, text %s, cursor %d - %d.\n", data, zwp_text_input_v3,
             debugstr_a(text), cursor_begin, cursor_end);
 
-    pthread_mutex_lock(&text_input->mutex);
-    if ((text_input->preedit_string = strdupUtoW(text)))
+    if ((textW = strdupUtoW(text)))
     {
-        DWORD begin = 0, end = 0;
-
         if (cursor_begin > 0) RtlUTF8ToUnicodeN(NULL, 0, &begin, text, cursor_begin);
         if (cursor_end > 0) RtlUTF8ToUnicodeN(NULL, 0, &end, text, cursor_end);
-        text_input->preedit_cursor_pos = MAKELONG(begin / sizeof(WCHAR), end / sizeof(WCHAR));
     }
+
+    pthread_mutex_lock(&text_input->mutex);
+    free(text_input->preedit_string);
+    text_input->preedit_string = textW;
+    text_input->preedit_cursor_pos = MAKELONG(begin / sizeof(WCHAR), end / sizeof(WCHAR));
     pthread_mutex_unlock(&text_input->mutex);
 }
 
@@ -125,6 +139,7 @@ static void text_input_commit_string(void *data, struct zwp_text_input_v3 *zwp_t
     TRACE("data %p, text_input %p, text %s.\n", data, zwp_text_input_v3, debugstr_a(text));
 
     pthread_mutex_lock(&text_input->mutex);
+    free(text_input->commit_string);
     text_input->commit_string = strdupUtoW(text);
     pthread_mutex_unlock(&text_input->mutex);
 }
@@ -149,12 +164,7 @@ static void text_input_done(void *data, struct zwp_text_input_v3 *zwp_text_input
         post_ime_update(text_input->focused_hwnd, text_input->preedit_cursor_pos,
                 text_input->preedit_string, text_input->commit_string);
     }
-
-    free(text_input->preedit_string);
-    text_input->preedit_string = NULL;
-    text_input->preedit_cursor_pos = 0;
-    free(text_input->commit_string);
-    text_input->commit_string = NULL;
+    wayland_text_input_reset_pending_state(text_input);
     pthread_mutex_unlock(&text_input->mutex);
 }
 
@@ -187,6 +197,7 @@ void wayland_text_input_deinit(void)
     zwp_text_input_v3_destroy(text_input->zwp_text_input_v3);
     text_input->zwp_text_input_v3 = NULL;
     text_input->focused_hwnd = NULL;
+    wayland_text_input_reset_pending_state(text_input);
     pthread_mutex_unlock(&text_input->mutex);
 };
 
-- 
2.49.0

From 9b293011e65ef1685e1acc2896c5b833696911f1 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 3 Jun 2025 16:39:47 +0300
Subject: [PATCH 125/159] winewayland: Ignore text-input "done" events that
 don't modify state.

Compositors send a "done" event after every text-input commit, even if
the reported state (preedit etc) hasn't changed. Acting on such events
is at best wasteful, but can additionally lead to incorrect IME related
effects (e.g., deleting the currently selected text), so ignore them,
similarly to what Qt and GTK do.
---
 dlls/winewayland.drv/wayland_text_input.c | 41 ++++++++++++++++-------
 dlls/winewayland.drv/waylanddrv.h         |  7 ++--
 2 files changed, 34 insertions(+), 14 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_text_input.c b/dlls/winewayland.drv/wayland_text_input.c
index ddf30abe12a..52cfef27e50 100644
--- a/dlls/winewayland.drv/wayland_text_input.c
+++ b/dlls/winewayland.drv/wayland_text_input.c
@@ -62,13 +62,21 @@ static WCHAR *strdupUtoW(const char *str)
 
 static void wayland_text_input_reset_pending_state(struct wayland_text_input *text_input)
 {
-    free(text_input->preedit_string);
-    text_input->preedit_string = NULL;
-    text_input->preedit_cursor_pos = 0;
+    free(text_input->preedit.string);
+    text_input->preedit.string = NULL;
+    text_input->preedit.cursor_pos = 0;
     free(text_input->commit_string);
     text_input->commit_string = NULL;
 }
 
+static void wayland_text_input_reset_all_state(struct wayland_text_input *text_input)
+{
+    free(text_input->current_preedit.string);
+    text_input->current_preedit.string = NULL;
+    text_input->current_preedit.cursor_pos = 0;
+    wayland_text_input_reset_pending_state(text_input);
+}
+
 static void text_input_enter(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
         struct wl_surface *surface)
 {
@@ -105,7 +113,7 @@ static void text_input_leave(void *data, struct zwp_text_input_v3 *zwp_text_inpu
         post_ime_update(text_input->focused_hwnd, 0, NULL, NULL);
         text_input->focused_hwnd = NULL;
     }
-    wayland_text_input_reset_pending_state(text_input);
+    wayland_text_input_reset_all_state(text_input);
     pthread_mutex_unlock(&text_input->mutex);
 }
 
@@ -126,9 +134,9 @@ static void text_input_preedit_string(void *data, struct zwp_text_input_v3 *zwp_
     }
 
     pthread_mutex_lock(&text_input->mutex);
-    free(text_input->preedit_string);
-    text_input->preedit_string = textW;
-    text_input->preedit_cursor_pos = MAKELONG(begin / sizeof(WCHAR), end / sizeof(WCHAR));
+    free(text_input->preedit.string);
+    text_input->preedit.string = textW;
+    text_input->preedit.cursor_pos = MAKELONG(begin / sizeof(WCHAR), end / sizeof(WCHAR));
     pthread_mutex_unlock(&text_input->mutex);
 }
 
@@ -158,12 +166,21 @@ static void text_input_done(void *data, struct zwp_text_input_v3 *zwp_text_input
     pthread_mutex_lock(&text_input->mutex);
     /* Some compositors will send a done event for every commit, regardless of
      * the focus state of the text input. This behavior is arguably out of spec,
-     * but otherwise harmless, so just ignore the new state in such cases. */
-    if (text_input->focused_hwnd)
+     * but otherwise harmless, so just ignore the new state in such cases.
+     * Additionally ignore done events that don't actually modify the state. */
+    if (text_input->focused_hwnd &&
+        (text_input->commit_string ||
+         text_input->preedit.cursor_pos != text_input->current_preedit.cursor_pos ||
+         !!text_input->preedit.string != !!text_input->current_preedit.string ||
+         (text_input->preedit.string && text_input->current_preedit.string &&
+          wcscmp(text_input->preedit.string, text_input->current_preedit.string))))
     {
-        post_ime_update(text_input->focused_hwnd, text_input->preedit_cursor_pos,
-                text_input->preedit_string, text_input->commit_string);
+        post_ime_update(text_input->focused_hwnd, text_input->preedit.cursor_pos,
+                text_input->preedit.string, text_input->commit_string);
     }
+    free(text_input->current_preedit.string);
+    text_input->current_preedit = text_input->preedit;
+    text_input->preedit.string = NULL;
     wayland_text_input_reset_pending_state(text_input);
     pthread_mutex_unlock(&text_input->mutex);
 }
@@ -197,7 +214,7 @@ void wayland_text_input_deinit(void)
     zwp_text_input_v3_destroy(text_input->zwp_text_input_v3);
     text_input->zwp_text_input_v3 = NULL;
     text_input->focused_hwnd = NULL;
-    wayland_text_input_reset_pending_state(text_input);
+    wayland_text_input_reset_all_state(text_input);
     pthread_mutex_unlock(&text_input->mutex);
 };
 
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 2dcc22ef392..44e478a91d8 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -151,8 +151,11 @@ struct wayland_pointer
 struct wayland_text_input
 {
     struct zwp_text_input_v3 *zwp_text_input_v3;
-    WCHAR *preedit_string;
-    DWORD preedit_cursor_pos;
+    struct
+    {
+        WCHAR *string;
+        DWORD cursor_pos;
+    } preedit, current_preedit;
     WCHAR *commit_string;
     HWND focused_hwnd;
     pthread_mutex_t mutex;
-- 
2.49.0

From b6e9973f358808c84f199bc2c624c56b2af93077 Mon Sep 17 00:00:00 2001
From: Byeongsik Jeon <bsjeon@hanmail.net>
Date: Sat, 12 Apr 2025 22:32:26 +0900
Subject: [PATCH 126/159] imm32: Fix the WM_IME_COMPOSITION messages to be
 between the WM_IME_{START|END}COMPOSITION message.

This patch fixes a Japanese input issue in MS Office Visual Basic and Mery text
editor ime inline mode. The following was considered:

  1. Japanese ime: the result string message is always placed between
     WM_IME_STARTCOMPOSITION and WM_IME_ENDCOMPOSITION. Currently in Wine,
     the result string message follows WM_IME_ENDCOMPOSITION.

     dlls/imm32/tests/imm32.c::test_nihongo_no().

  2. Chinese ime: same as Japanese ime.

  3. Korean ime: mostly the same, but there are some cases where it is not
     (e.g. CPS_COMPLETE, 'r-k-RETURN'). However, I haven't found any problem
     even if it behave like Japanese ime message order.

  3. zero-length preedit string: as in MR !3115 commit d1f9aae, the message
     followed by WM_IME_ENDCOMPOSITION. Currently in Wine, it is associated
     with WM_IME_STARTCOMPOSITION.

  4. zero-length result string: ignore.
---
 dlls/imm32/ime.c | 17 +++++++++++++----
 1 file changed, 13 insertions(+), 4 deletions(-)

diff --git a/dlls/imm32/ime.c b/dlls/imm32/ime.c
index 77caf884efa..536f67602f9 100644
--- a/dlls/imm32/ime.c
+++ b/dlls/imm32/ime.c
@@ -557,14 +557,17 @@ UINT WINAPI ImeToAsciiEx( UINT vkey, UINT vsc, BYTE *state, TRANSMSGLIST *msgs,
     if (status) WARN( "WINE_IME_TO_ASCII_EX returned status %#lx\n", status );
     else
     {
-        TRANSMSG status_msg = {.message = ime_set_composition_status( himc, !!compstr->dwCompStrOffset )};
-        if (status_msg.message) msgs->TransMsg[count++] = status_msg;
+        if (compstr->dwCompStrOffset || compstr->dwResultStrLen)
+        {
+            TRANSMSG msg = {.message = ime_set_composition_status( himc, TRUE )};
+            if (msg.message == WM_IME_STARTCOMPOSITION) msgs->TransMsg[count++] = msg;
+        }
 
-        if (compstr->dwResultStrOffset)
+        if (compstr->dwResultStrLen)
         {
             const WCHAR *result = (WCHAR *)((BYTE *)compstr + compstr->dwResultStrOffset);
             TRANSMSG msg = {.message = WM_IME_COMPOSITION, .wParam = result[0], .lParam = GCS_RESULTSTR};
-            if (compstr->dwResultClauseOffset) msg.lParam |= GCS_RESULTCLAUSE;
+            if (compstr->dwResultClauseLen) msg.lParam |= GCS_RESULTCLAUSE;
             msgs->TransMsg[count++] = msg;
         }
 
@@ -578,6 +581,12 @@ UINT WINAPI ImeToAsciiEx( UINT vkey, UINT vsc, BYTE *state, TRANSMSGLIST *msgs,
             msgs->TransMsg[count++] = msg;
         }
 
+        if (!compstr->dwCompStrLen)
+        {
+            TRANSMSG msg = {.message = ime_set_composition_status( himc, FALSE )};
+            if (msg.message == WM_IME_ENDCOMPOSITION) msgs->TransMsg[count++] = msg;
+        }
+
         if (!key_consumed)
         {
             TRANSMSG msg = {.message = WM_IME_KEYDOWN, .wParam = vkey, .lParam = vsc};
-- 
2.49.0

From 6cbb9e1f87ee0bd30ab7eddc82c8f0c5e2df91a4 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sat, 21 Jun 2025 18:54:32 -0400
Subject: [PATCH 127/159] opengl32: Use VirtualAlloc instead of
 NtAllocateVirtualMemory

---
 dlls/opengl32/wgl.c | 13 +++----------
 1 file changed, 3 insertions(+), 10 deletions(-)

diff --git a/dlls/opengl32/wgl.c b/dlls/opengl32/wgl.c
index ba7ee6cc5de..0c6bea28903 100644
--- a/dlls/opengl32/wgl.c
+++ b/dlls/opengl32/wgl.c
@@ -1688,10 +1688,7 @@ static LONG count;
 /* if this code gets called we are in wow64 mode */
 static void *allocate_mapping( SIZE_T length )
 {
-    NTSTATUS status;
-    MEM_EXTENDED_PARAMETER param;
     void *ret = NULL;
-    MEM_ADDRESS_REQUIREMENTS req = {0};
     struct mem_desc *slot = NULL;
 
     /* an array is easy to implement but may not be the best option */
@@ -1713,21 +1710,17 @@ static void *allocate_mapping( SIZE_T length )
         {
             if (!mappings[i].active)
             {
+                VirtualFree(mappings[i].addr, 0, MEM_RELEASE);
                 mappings[i].size = 0;
-                NtFreeVirtualMemory(NtCurrentProcess(), &mappings[i].addr, &mappings[i].size, MEM_RELEASE);
                 mappings[i].addr = NULL;
                 slot = &mappings[i];
             }
         }
     }
 
-    req.Alignment = 0x10000;
-    param.Type = MemExtendedParameterAddressRequirements;
-    param.Pointer = &req;
+    ret = VirtualAlloc(NULL, length, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
 
-    status = NtAllocateVirtualMemoryEx(NtCurrentProcess(), &ret, &length,
-                                       MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE, &param, 1);
-    if (status) ret = NULL;
+    if (!ret) return ret;
 
     if (!slot) slot = &mappings[count++];
 
-- 
2.49.0

From 3ac40ab2b175a40c3756e7f340a2c5c0c1583bcf Mon Sep 17 00:00:00 2001
From: Alex Henrie <alexhenrie24@gmail.com>
Date: Sun, 22 Jun 2025 12:06:55 -0400
Subject: [PATCH 128/159] setupapi: Use wide character string literals.

---
 dlls/setupapi/devinst.c   | 306 +++++++++++++++-----------------------
 dlls/setupapi/diskspace.c |   3 +-
 dlls/setupapi/misc.c      |   7 +-
 dlls/setupapi/parser.c    |  34 ++---
 dlls/setupapi/query.c     |  61 +++-----
 5 files changed, 148 insertions(+), 263 deletions(-)

diff --git a/dlls/setupapi/devinst.c b/dlls/setupapi/devinst.c
index f6675ee7840..3abd781ed50 100644
--- a/dlls/setupapi/devinst.c
+++ b/dlls/setupapi/devinst.c
@@ -50,67 +50,21 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(setupapi);
 
-/* Unicode constants */
-static const WCHAR Chicago[]  = {'$','C','h','i','c','a','g','o','$',0};
-static const WCHAR ClassGUID[]  = {'C','l','a','s','s','G','U','I','D',0};
-static const WCHAR Class[]  = {'C','l','a','s','s',0};
-static const WCHAR ClassInstall32[]  = {'C','l','a','s','s','I','n','s','t','a','l','l','3','2',0};
-static const WCHAR NoDisplayClass[]  = {'N','o','D','i','s','p','l','a','y','C','l','a','s','s',0};
-static const WCHAR NoInstallClass[]  = {'N','o','I','n','s','t','a','l','l','C','l','a','s','s',0};
-static const WCHAR NoUseClass[]  = {'N','o','U','s','e','C','l','a','s','s',0};
-static const WCHAR NtExtension[]  = {'.','N','T',0};
 #ifdef __i386__
-static const WCHAR NtPlatformExtension[]  = {'.','N','T','x','8','6',0};
+static const WCHAR NtPlatformExtension[]  = L".NTx86";
 #elif defined(__x86_64__)
-static const WCHAR NtPlatformExtension[]  = {'.','N','T','a','m','d','6','4',0};
+static const WCHAR NtPlatformExtension[]  = L".NTamd64";
 #elif defined(__arm__)
-static const WCHAR NtPlatformExtension[]  = {'.','N','T','a','r','m',0};
+static const WCHAR NtPlatformExtension[]  = L".NTarm";
 #elif defined(__aarch64__)
-static const WCHAR NtPlatformExtension[]  = {'.','N','T','a','r','m','6','4',0};
+static const WCHAR NtPlatformExtension[]  = L".NTarm64";
 #endif
-static const WCHAR Signature[]  = {'S','i','g','n','a','t','u','r','e',0};
-static const WCHAR Version[]  = {'V','e','r','s','i','o','n',0};
-static const WCHAR WinExtension[]  = {'.','W','i','n',0};
-static const WCHAR WindowsNT[]  = {'$','W','i','n','d','o','w','s',' ','N','T','$',0};
-
-/* Registry key and value names */
-static const WCHAR ControlClass[] = {'S','y','s','t','e','m','\\',
-                                  'C','u','r','r','e','n','t','C','o','n','t','r','o','l','S','e','t','\\',
-                                  'C','o','n','t','r','o','l','\\',
-                                  'C','l','a','s','s',0};
-
-static const WCHAR DeviceClasses[] = {'S','y','s','t','e','m','\\',
-                                  'C','u','r','r','e','n','t','C','o','n','t','r','o','l','S','e','t','\\',
-                                  'C','o','n','t','r','o','l','\\',
-                                  'D','e','v','i','c','e','C','l','a','s','s','e','s',0};
-static const WCHAR Enum[] = {'S','y','s','t','e','m','\\',
-                                  'C','u','r','r','e','n','t','C','o','n','t','r','o','l','S','e','t','\\',
-				  'E','n','u','m',0};
-static const WCHAR DeviceDesc[] = {'D','e','v','i','c','e','D','e','s','c',0};
-static const WCHAR DeviceInstance[] = {'D','e','v','i','c','e','I','n','s','t','a','n','c','e',0};
-static const WCHAR DeviceParameters[] = {'D','e','v','i','c','e',' ','P','a','r','a','m','e','t','e','r','s',0};
-static const WCHAR HardwareId[] = {'H','a','r','d','w','a','r','e','I','D',0};
-static const WCHAR CompatibleIDs[] = {'C','o','m','p','a','t','i','b','l','e','I','d','s',0};
-static const WCHAR Service[] = {'S','e','r','v','i','c','e',0};
-static const WCHAR Driver[] = {'D','r','i','v','e','r',0};
-static const WCHAR ConfigFlags[] = {'C','o','n','f','i','g','F','l','a','g','s',0};
-static const WCHAR Mfg[] = {'M','f','g',0};
-static const WCHAR FriendlyName[] = {'F','r','i','e','n','d','l','y','N','a','m','e',0};
-static const WCHAR LocationInformation[] = {'L','o','c','a','t','i','o','n','I','n','f','o','r','m','a','t','i','o','n',0};
-static const WCHAR Capabilities[] = {'C','a','p','a','b','i','l','i','t','i','e','s',0};
-static const WCHAR UINumber[] = {'U','I','N','u','m','b','e','r',0};
-static const WCHAR UpperFilters[] = {'U','p','p','e','r','F','i','l','t','e','r','s',0};
-static const WCHAR LowerFilters[] = {'L','o','w','e','r','F','i','l','t','e','r','s',0};
-static const WCHAR ContainerId[] = {'C','o','n','t','a','i','n','e','r','I','d',0};
-static const WCHAR Phantom[] = {'P','h','a','n','t','o','m',0};
-static const WCHAR SymbolicLink[] = {'S','y','m','b','o','l','i','c','L','i','n','k',0};
-static const WCHAR Control[] = {'C','o','n','t','r','o','l',0};
-static const WCHAR Linked[] = {'L','i','n','k','e','d',0};
-static const WCHAR dotInterfaces[] = {'.','I','n','t','e','r','f','a','c','e','s',0};
-static const WCHAR AddInterface[] = {'A','d','d','I','n','t','e','r','f','a','c','e',0};
-static const WCHAR backslashW[] = {'\\',0};
-static const WCHAR hashW[] = {'#',0};
-static const WCHAR emptyW[] = {0};
+
+/* Registry key names */
+static const WCHAR ControlClass[] = L"System\\CurrentControlSet\\Control\\Class";
+static const WCHAR DeviceClasses[] = L"System\\CurrentControlSet\\Control\\DeviceClasses";
+static const WCHAR Enum[] = L"System\\CurrentControlSet\\Enum";
+
 
 #define SERVICE_CONTROL_REENUMERATE_ROOT_DEVICES 128
 
@@ -331,19 +285,14 @@ static DEVINST alloc_devinst_for_device_id(const WCHAR *id)
 
 static void SETUPDI_GuidToString(const GUID *guid, LPWSTR guidStr)
 {
-    static const WCHAR fmt[] = {'{','%','0','8','X','-','%','0','4','X','-',
-        '%','0','4','X','-','%','0','2','X','%','0','2','X','-','%','0','2',
-        'X','%','0','2','X','%','0','2','X','%','0','2','X','%','0','2','X','%',
-        '0','2','X','}',0};
-
-    swprintf(guidStr, 39, fmt, guid->Data1, guid->Data2, guid->Data3,
+    swprintf(guidStr, 39, L"{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
+        guid->Data1, guid->Data2, guid->Data3,
         guid->Data4[0], guid->Data4[1], guid->Data4[2], guid->Data4[3],
         guid->Data4[4], guid->Data4[5], guid->Data4[6], guid->Data4[7]);
 }
 
 static WCHAR *get_iface_key_path(struct device_iface *iface)
 {
-    static const WCHAR slashW[] = {'\\',0};
     WCHAR *path, *ptr;
     size_t len = lstrlenW(DeviceClasses) + 1 + 38 + 1 + lstrlenW(iface->symlink);
 
@@ -354,9 +303,9 @@ static WCHAR *get_iface_key_path(struct device_iface *iface)
     }
 
     lstrcpyW(path, DeviceClasses);
-    lstrcatW(path, slashW);
+    lstrcatW(path, L"\\");
     SETUPDI_GuidToString(&iface->class, path + lstrlenW(path));
-    lstrcatW(path, slashW);
+    lstrcatW(path, L"\\");
     ptr = path + lstrlenW(path);
     lstrcatW(path, iface->symlink);
     if (lstrlenW(iface->symlink) > 3)
@@ -370,7 +319,6 @@ static WCHAR *get_iface_key_path(struct device_iface *iface)
 
 static WCHAR *get_refstr_key_path(struct device_iface *iface)
 {
-    static const WCHAR slashW[] = {'\\',0};
     WCHAR *path, *ptr;
     size_t len = lstrlenW(DeviceClasses) + 1 + 38 + 1 + lstrlenW(iface->symlink) + 1 + 1;
 
@@ -384,9 +332,9 @@ static WCHAR *get_refstr_key_path(struct device_iface *iface)
     }
 
     lstrcpyW(path, DeviceClasses);
-    lstrcatW(path, slashW);
+    lstrcatW(path, L"\\");
     SETUPDI_GuidToString(&iface->class, path + lstrlenW(path));
-    lstrcatW(path, slashW);
+    lstrcatW(path, L"\\");
     ptr = path + lstrlenW(path);
     lstrcatW(path, iface->symlink);
     if (lstrlenW(iface->symlink) > 3)
@@ -395,8 +343,7 @@ static WCHAR *get_refstr_key_path(struct device_iface *iface)
     ptr = wcschr(ptr, '\\');
     if (ptr) *ptr = 0;
 
-    lstrcatW(path, slashW);
-    lstrcatW(path, hashW);
+    lstrcatW(path, L"\\#");
 
     if (iface->refstr)
         lstrcatW(path, iface->refstr);
@@ -429,7 +376,7 @@ static BOOL is_valid_property_type(DEVPROPTYPE prop_type)
 static LPWSTR SETUPDI_CreateSymbolicLinkPath(LPCWSTR instanceId,
         const GUID *InterfaceClassGuid, LPCWSTR ReferenceString)
 {
-    static const WCHAR fmt[] = {'\\','\\','?','\\','%','s','#','%','s',0};
+    static const WCHAR fmt[] = L"\\\\?\\%s#%s";
     WCHAR guidStr[39];
     DWORD len;
     LPWSTR ret;
@@ -470,10 +417,10 @@ static BOOL is_linked(HKEY key)
     HKEY control_key;
     BOOL ret = FALSE;
 
-    if (!RegOpenKeyW(key, Control, &control_key))
+    if (!RegOpenKeyW(key, L"Control", &control_key))
     {
         size = sizeof(DWORD);
-        if (!RegQueryValueExW(control_key, Linked, NULL, &type, (BYTE *)&linked, &size)
+        if (!RegQueryValueExW(control_key, L"Linked", NULL, &type, (BYTE *)&linked, &size)
                 && type == REG_DWORD && linked)
             ret = TRUE;
 
@@ -531,7 +478,7 @@ static struct device_iface *SETUPDI_CreateDeviceInterface(struct device *device,
         SetLastError(ret);
         goto err;
     }
-    RegSetValueExW(key, DeviceInstance, 0, REG_SZ, (BYTE *)device->instanceId,
+    RegSetValueExW(key, L"DeviceInstance", 0, REG_SZ, (BYTE *)device->instanceId,
         lstrlenW(device->instanceId) * sizeof(WCHAR));
     free(path);
 
@@ -548,7 +495,7 @@ static struct device_iface *SETUPDI_CreateDeviceInterface(struct device *device,
         SetLastError(ret);
         goto err;
     }
-    RegSetValueExW(key, SymbolicLink, 0, REG_SZ, (BYTE *)iface->symlink,
+    RegSetValueExW(key, L"SymbolicLink", 0, REG_SZ, (BYTE *)iface->symlink,
         lstrlenW(iface->symlink) * sizeof(WCHAR));
 
     if (is_linked(key))
@@ -608,7 +555,7 @@ static LONG open_driver_key(struct device *device, REGSAM access, HKEY *key)
         return l;
     }
 
-    if (!(l = RegGetValueW(device->key, NULL, Driver, RRF_RT_REG_SZ, NULL, path, &size)))
+    if (!(l = RegGetValueW(device->key, NULL, L"Driver", RRF_RT_REG_SZ, NULL, path, &size)))
     {
         if (!(l = RegOpenKeyExW(class_key, path, 0, access, key)))
         {
@@ -624,8 +571,6 @@ static LONG open_driver_key(struct device *device, REGSAM access, HKEY *key)
 
 static LONG create_driver_key(struct device *device, HKEY *key)
 {
-    static const WCHAR formatW[] = {'%','0','4','u',0};
-    static const WCHAR slash[] = { '\\',0 };
     unsigned int i = 0;
     WCHAR path[50];
     HKEY class_key;
@@ -643,17 +588,17 @@ static LONG create_driver_key(struct device *device, HKEY *key)
     }
 
     SETUPDI_GuidToString(&device->class, path);
-    lstrcatW(path, slash);
+    lstrcatW(path, L"\\");
     /* Allocate a new driver key, by finding the first integer value that's not
      * already taken. */
     for (;;)
     {
-        swprintf(path + 39, ARRAY_SIZE(path) - 39, formatW, i++);
+        swprintf(path + 39, ARRAY_SIZE(path) - 39, L"%04u", i++);
         if ((l = RegCreateKeyExW(class_key, path, 0, NULL, 0, KEY_READ | KEY_WRITE, NULL, key, &dispos)))
             break;
         else if (dispos == REG_CREATED_NEW_KEY)
         {
-            RegSetValueExW(device->key, Driver, 0, REG_SZ, (BYTE *)path, lstrlenW(path) * sizeof(WCHAR));
+            RegSetValueExW(device->key, L"Driver", 0, REG_SZ, (BYTE *)path, lstrlenW(path) * sizeof(WCHAR));
             RegCloseKey(class_key);
             return ERROR_SUCCESS;
         }
@@ -671,7 +616,7 @@ static LONG delete_driver_key(struct device *device)
 
     if (!(l = open_driver_key(device, KEY_READ | KEY_WRITE, &key)))
     {
-        l = RegDeleteKeyW(key, emptyW);
+        l = RegDeleteKeyW(key, L"");
         RegCloseKey(key);
     }
 
@@ -685,28 +630,30 @@ struct PropertyMapEntry
     LPCWSTR nameW;
 };
 
+#define PROPERTY_MAP_ENTRY(type, name) { type, name, L##name }
 static const struct PropertyMapEntry PropertyMap[] = {
-    { REG_SZ, "DeviceDesc", DeviceDesc },
-    { REG_MULTI_SZ, "HardwareId", HardwareId },
-    { REG_MULTI_SZ, "CompatibleIDs", CompatibleIDs },
+    PROPERTY_MAP_ENTRY(REG_SZ, "DeviceDesc"),
+    PROPERTY_MAP_ENTRY(REG_MULTI_SZ, "HardwareId"),
+    PROPERTY_MAP_ENTRY(REG_MULTI_SZ, "CompatibleIDs"),
     { 0, NULL, NULL }, /* SPDRP_UNUSED0 */
-    { REG_SZ, "Service", Service },
+    PROPERTY_MAP_ENTRY(REG_SZ, "Service"),
     { 0, NULL, NULL }, /* SPDRP_UNUSED1 */
     { 0, NULL, NULL }, /* SPDRP_UNUSED2 */
-    { REG_SZ, "Class", Class },
-    { REG_SZ, "ClassGUID", ClassGUID },
-    { REG_SZ, "Driver", Driver },
-    { REG_DWORD, "ConfigFlags", ConfigFlags },
-    { REG_SZ, "Mfg", Mfg },
-    { REG_SZ, "FriendlyName", FriendlyName },
-    { REG_SZ, "LocationInformation", LocationInformation },
+    PROPERTY_MAP_ENTRY(REG_SZ, "Class"),
+    PROPERTY_MAP_ENTRY(REG_SZ, "ClassGUID"),
+    PROPERTY_MAP_ENTRY(REG_SZ, "Driver"),
+    PROPERTY_MAP_ENTRY(REG_DWORD, "ConfigFlags"),
+    PROPERTY_MAP_ENTRY(REG_SZ, "Mfg"),
+    PROPERTY_MAP_ENTRY(REG_SZ, "FriendlyName"),
+    PROPERTY_MAP_ENTRY(REG_SZ, "LocationInformation"),
     { 0, NULL, NULL }, /* SPDRP_PHYSICAL_DEVICE_OBJECT_NAME */
-    { REG_DWORD, "Capabilities", Capabilities },
-    { REG_DWORD, "UINumber", UINumber },
-    { REG_MULTI_SZ, "UpperFilters", UpperFilters },
-    { REG_MULTI_SZ, "LowerFilters", LowerFilters },
-    [SPDRP_BASE_CONTAINERID] = { REG_SZ, "ContainerId", ContainerId },
+    PROPERTY_MAP_ENTRY(REG_DWORD, "Capabilities"),
+    PROPERTY_MAP_ENTRY(REG_DWORD, "UINumber"),
+    PROPERTY_MAP_ENTRY(REG_MULTI_SZ, "UpperFilters"),
+    PROPERTY_MAP_ENTRY(REG_MULTI_SZ, "LowerFilters"),
+    [SPDRP_BASE_CONTAINERID] = PROPERTY_MAP_ENTRY(REG_SZ, "ContainerId"),
 };
+#undef PROPERTY_MAP_ENTRY
 
 static BOOL SETUPDI_SetDeviceRegistryPropertyW(struct device *device,
     DWORD prop, const BYTE *buffer, DWORD size)
@@ -726,11 +673,11 @@ static BOOL SETUPDI_SetDeviceRegistryPropertyW(struct device *device,
 static void remove_device_iface(struct device_iface *iface)
 {
     RegDeleteTreeW(iface->refstr_key, NULL);
-    RegDeleteKeyW(iface->refstr_key, emptyW);
+    RegDeleteKeyW(iface->refstr_key, L"");
     RegCloseKey(iface->refstr_key);
     iface->refstr_key = NULL;
     /* Also remove the class key if it's empty. */
-    RegDeleteKeyW(iface->class_key, emptyW);
+    RegDeleteKeyW(iface->class_key, L"");
     RegCloseKey(iface->class_key);
     iface->class_key = NULL;
     iface->flags |= SPINT_REMOVED;
@@ -835,7 +782,7 @@ static void remove_device(struct device *device)
     }
 
     RegDeleteTreeW(device->key, NULL);
-    RegDeleteKeyW(device->key, emptyW);
+    RegDeleteKeyW(device->key, L"");
 
     /* delete all empty parents of the key */
     if (!RegOpenKeyExW(HKEY_LOCAL_MACHINE, Enum, 0, 0, &enum_key))
@@ -931,7 +878,7 @@ static struct device *create_device(struct DeviceInfoSet *set,
     device->params.cbSize = sizeof(SP_DEVINSTALL_PARAMS_W);
 
     if (phantom)
-        RegSetValueExW(device->key, Phantom, 0, REG_DWORD, (const BYTE *)&one, sizeof(one));
+        RegSetValueExW(device->key, L"Phantom", 0, REG_DWORD, (const BYTE *)&one, sizeof(one));
 
     SETUPDI_GuidToString(class, guidstr);
     SETUPDI_SetDeviceRegistryPropertyW(device, SPDRP_CLASSGUID,
@@ -1119,7 +1066,7 @@ BOOL WINAPI SetupDiBuildClassInfoListExW(
 	    }
 
 	    if (!RegQueryValueExW(hClassKey,
-				  NoUseClass,
+				  L"NoUseClass",
 				  NULL,
 				  NULL,
 				  NULL,
@@ -1132,7 +1079,7 @@ BOOL WINAPI SetupDiBuildClassInfoListExW(
 
 	    if ((Flags & DIBCI_NOINSTALLCLASS) &&
 		(!RegQueryValueExW(hClassKey,
-				   NoInstallClass,
+				   L"NoInstallClass",
 				   NULL,
 				   NULL,
 				   NULL,
@@ -1145,7 +1092,7 @@ BOOL WINAPI SetupDiBuildClassInfoListExW(
 
 	    if ((Flags & DIBCI_NODISPLAYCLASS) &&
 		(!RegQueryValueExW(hClassKey,
-				   NoDisplayClass,
+				   L"NoDisplayClass",
 				   NULL,
 				   NULL,
 				   NULL,
@@ -1320,7 +1267,7 @@ BOOL WINAPI SetupDiClassGuidsFromNameExW(
 
 	    dwLength = sizeof(szClassName);
 	    if (!RegQueryValueExW(hClassKey,
-				  Class,
+				  L"Class",
 				  NULL,
 				  NULL,
 				  (LPBYTE)szClassName,
@@ -1457,7 +1404,7 @@ BOOL WINAPI SetupDiClassNameFromGuidExW(
     {
 	dwLength = 0;
 	if (RegQueryValueExW(hKey,
-			     Class,
+			     L"Class",
 			     NULL,
 			     NULL,
 			     NULL,
@@ -1472,7 +1419,7 @@ BOOL WINAPI SetupDiClassNameFromGuidExW(
 
     dwLength = ClassNameSize * sizeof(WCHAR);
     if (RegQueryValueExW(hKey,
-			 Class,
+			 L"Class",
 			 NULL,
 			 NULL,
 			 (LPBYTE)ClassName,
@@ -1658,7 +1605,7 @@ HKEY WINAPI SetupDiCreateDevRegKeyW(HDEVINFO devinfo, SP_DEVINFO_DATA *device_da
     switch (KeyType)
     {
         case DIREG_DEV:
-            l = RegCreateKeyExW(device->key, DeviceParameters, 0, NULL, 0,
+            l = RegCreateKeyExW(device->key, L"Device Parameters", 0, NULL, 0,
                     KEY_READ | KEY_WRITE, NULL, &key, NULL);
             break;
         case DIREG_DRV:
@@ -1748,7 +1695,6 @@ BOOL WINAPI SetupDiCreateDeviceInfoW(HDEVINFO devinfo, const WCHAR *name, const
     }
     if ((flags & DICD_GENERATE_ID))
     {
-        static const WCHAR formatW[] = {'R','O','O','T','\\','%','s','\\','%','0','4','u',0};
         unsigned int instance_id;
 
         if (wcschr(name, '\\'))
@@ -1759,7 +1705,7 @@ BOOL WINAPI SetupDiCreateDeviceInfoW(HDEVINFO devinfo, const WCHAR *name, const
 
         for (instance_id = 0; ; ++instance_id)
         {
-            if (swprintf(id, ARRAY_SIZE(id), formatW, name, instance_id) == -1)
+            if (swprintf(id, ARRAY_SIZE(id), L"ROOT\\%s\\%04u", name, instance_id) == -1)
             {
                 SetLastError(ERROR_INVALID_DEVINST_NAME);
                 return FALSE;
@@ -1838,7 +1784,7 @@ BOOL WINAPI SetupDiRegisterDeviceInfo(HDEVINFO devinfo, SP_DEVINFO_DATA *device_
     if (device->phantom)
     {
         device->phantom = FALSE;
-        RegDeleteValueW(device->key, Phantom);
+        RegDeleteValueW(device->key, L"Phantom");
     }
     return TRUE;
 }
@@ -2101,14 +2047,14 @@ BOOL WINAPI SetupDiGetActualSectionToInstallExW(HINF hinf, const WCHAR *section,
         if (line_count == -1)
         {
             /* Test section name with '.NT' extension */
-            lstrcpyW(&buffer[len], NtExtension);
+            lstrcpyW(&buffer[len], L".NT");
             line_count = SetupGetLineCountW(hinf, buffer);
         }
     }
     else
     {
         /* Test section name with '.Win' extension */
-        lstrcpyW(&buffer[len], WinExtension);
+        lstrcpyW(&buffer[len], L".Win");
         line_count = SetupGetLineCountW(hinf, buffer);
     }
 
@@ -2350,7 +2296,7 @@ static void SETUPDI_AddDeviceInterfaces(struct device *device, HKEY key,
                         iface = SETUPDI_CreateDeviceInterface(device, guid, subKeyName + 1);
 
                         len = sizeof(symbolicLink);
-                        l = RegQueryValueExW(subKey, SymbolicLink, NULL, &dataType,
+                        l = RegQueryValueExW(subKey, L"SymbolicLink", NULL, &dataType,
                                 (BYTE *)symbolicLink, &len);
                         if (!l && dataType == REG_SZ)
                             SETUPDI_SetInterfaceSymbolicLink(iface, symbolicLink);
@@ -2393,7 +2339,7 @@ static void SETUPDI_EnumerateMatchingInterfaces(HDEVINFO DeviceInfoSet,
                 DWORD dataType;
 
                 len = sizeof(deviceInst);
-                l = RegQueryValueExW(subKey, DeviceInstance, NULL, &dataType,
+                l = RegQueryValueExW(subKey, L"DeviceInstance", NULL, &dataType,
                         (BYTE *)deviceInst, &len);
                 if (!l && dataType == REG_SZ)
                 {
@@ -2409,7 +2355,7 @@ static void SETUPDI_EnumerateMatchingInterfaces(HDEVINFO DeviceInfoSet,
                             WCHAR deviceClassStr[40];
 
                             len = sizeof(deviceClassStr);
-                            l = RegQueryValueExW(deviceKey, ClassGUID, NULL,
+                            l = RegQueryValueExW(deviceKey, L"ClassGUID", NULL,
                                     &dataType, (BYTE *)deviceClassStr, &len);
                             if (!l && dataType == REG_SZ &&
                                     deviceClassStr[0] == '{' &&
@@ -2531,7 +2477,7 @@ static BOOL is_device_instance_linked(HKEY interfacesKey, const WCHAR *deviceIns
                 continue;
 
             len = ARRAY_SIZE(interface_devinstance);
-            l = RegQueryValueExW(device_key, DeviceInstance, NULL, &type, (BYTE *)interface_devinstance, &len);
+            l = RegQueryValueExW(device_key, L"DeviceInstance", NULL, &type, (BYTE *)interface_devinstance, &len);
             if (l || type != REG_SZ)
             {
                 RegCloseKey(device_key);
@@ -2545,7 +2491,7 @@ static BOOL is_device_instance_linked(HKEY interfacesKey, const WCHAR *deviceIns
                 continue;
             }
 
-            l = RegOpenKeyExW(device_key, hashW, 0, KEY_READ, &link_key);
+            l = RegOpenKeyExW(device_key, L"#", 0, KEY_READ, &link_key);
             if (l)
             {
                 RegCloseKey(device_key);
@@ -2598,7 +2544,7 @@ static void SETUPDI_EnumerateMatchingDeviceInstances(struct DeviceInfoSet *set,
                 DWORD dataType;
 
                 len = sizeof(classGuid);
-                l = RegQueryValueExW(subKey, ClassGUID, NULL, &dataType,
+                l = RegQueryValueExW(subKey, L"ClassGUID", NULL, &dataType,
                         (BYTE *)classGuid, &len);
                 if (!l && dataType == REG_SZ)
                 {
@@ -2940,7 +2886,7 @@ HKEY WINAPI SetupDiCreateDeviceInterfaceRegKeyA(
 
 static LONG create_iface_key(const struct device_iface *iface, REGSAM access, HKEY *key)
 {
-    return RegCreateKeyExW(iface->refstr_key, DeviceParameters, 0, NULL, 0, access, NULL, key, NULL);
+    return RegCreateKeyExW(iface->refstr_key, L"Device Parameters", 0, NULL, 0, access, NULL, key, NULL);
 }
 
 /***********************************************************************
@@ -2990,7 +2936,7 @@ BOOL WINAPI SetupDiDeleteDeviceInterfaceRegKey(HDEVINFO devinfo,
     if (!(iface = get_device_iface(devinfo, iface_data)))
         return FALSE;
 
-    ret = RegDeleteKeyW(iface->refstr_key, DeviceParameters);
+    ret = RegDeleteKeyW(iface->refstr_key, L"Device Parameters");
     if (ret)
     {
         SetLastError(ret);
@@ -3401,7 +3347,6 @@ BOOL WINAPI SetupDiInstallClassA(
 
 static HKEY CreateClassKey(HINF hInf)
 {
-    static const WCHAR slash[] = { '\\',0 };
     WCHAR FullBuffer[MAX_PATH];
     WCHAR Buffer[MAX_PATH];
     DWORD RequiredSize;
@@ -3409,8 +3354,8 @@ static HKEY CreateClassKey(HINF hInf)
 
     if (!SetupGetLineTextW(NULL,
 			   hInf,
-			   Version,
-			   ClassGUID,
+			   L"Version",
+			   L"ClassGUID",
 			   Buffer,
 			   MAX_PATH,
 			   &RequiredSize))
@@ -3419,7 +3364,7 @@ static HKEY CreateClassKey(HINF hInf)
     }
 
     lstrcpyW(FullBuffer, ControlClass);
-    lstrcatW(FullBuffer, slash);
+    lstrcatW(FullBuffer, L"\\");
     lstrcatW(FullBuffer, Buffer);
 
     if (RegOpenKeyExW(HKEY_LOCAL_MACHINE,
@@ -3430,8 +3375,8 @@ static HKEY CreateClassKey(HINF hInf)
     {
 	if (!SetupGetLineTextW(NULL,
 			       hInf,
-			       Version,
-			       Class,
+			       L"Version",
+			       L"Class",
 			       Buffer,
 			       MAX_PATH,
 			       &RequiredSize))
@@ -3455,7 +3400,7 @@ static HKEY CreateClassKey(HINF hInf)
     }
 
     if (RegSetValueExW(hClassKey,
-		       Class,
+		       L"Class",
 		       0,
 		       REG_SZ,
 		       (LPBYTE)Buffer,
@@ -3524,7 +3469,7 @@ BOOL WINAPI SetupDiInstallClassW(
 
     /* Retrieve the actual section name */
     SetupDiGetActualSectionToInstallW(hInf,
-				      ClassInstall32,
+				      L"ClassInstall32",
 				      SectionName,
 				      MAX_PATH,
 				      &SectionNameLength,
@@ -3752,12 +3697,12 @@ BOOL WINAPI SetupDiOpenDeviceInfoW(HDEVINFO devinfo, PCWSTR instance_id, HWND hw
 
     /* If it's an unregistered instance, aka phantom instance, report ERROR_NO_SUCH_DEVINST */
     size = sizeof(phantom);
-    if (!RegQueryValueExW(instanceKey, Phantom, NULL, NULL, (BYTE *)&phantom, &size))
+    if (!RegQueryValueExW(instanceKey, L"Phantom", NULL, NULL, (BYTE *)&phantom, &size))
         goto done;
 
     /* Check class GUID */
     size = sizeof(classW);
-    if (RegQueryValueExW(instanceKey, ClassGUID, NULL, NULL, (BYTE *)classW, &size))
+    if (RegQueryValueExW(instanceKey, L"ClassGUID", NULL, NULL, (BYTE *)classW, &size))
         goto done;
 
     classW[37] = 0;
@@ -3863,7 +3808,7 @@ HKEY WINAPI SetupDiOpenDeviceInterfaceRegKey(HDEVINFO devinfo, PSP_DEVICE_INTERF
     if (!(iface = get_device_iface(devinfo, iface_data)))
         return INVALID_HANDLE_VALUE;
 
-    lr = RegOpenKeyExW(iface->refstr_key, DeviceParameters, 0, access, &key);
+    lr = RegOpenKeyExW(iface->refstr_key, L"Device Parameters", 0, access, &key);
     if (lr)
     {
         SetLastError(lr);
@@ -3954,12 +3899,7 @@ static BOOL call_coinstallers(WCHAR *list, DI_FUNCTION function, HDEVINFO devinf
  */
 BOOL WINAPI SetupDiCallClassInstaller(DI_FUNCTION function, HDEVINFO devinfo, SP_DEVINFO_DATA *device_data)
 {
-    static const WCHAR class_coinst_pathW[] = {'S','y','s','t','e','m',
-            '\\','C','u','r','r','e','n','t','C','o','n','t','r','o','l','S','e','t',
-            '\\','C','o','n','t','r','o','l',
-            '\\','C','o','D','e','v','i','c','e','I','n','s','t','a','l','l','e','r','s',0};
-    static const WCHAR coinstallers32W[] = {'C','o','I','n','s','t','a','l','l','e','r','s','3','2',0};
-    static const WCHAR installer32W[] = {'I','n','s','t','a','l','l','e','r','3','2',0};
+    static const WCHAR class_coinst_pathW[] = L"System\\CurrentControlSet\\Control\\CoDeviceInstallers";
     DWORD (CALLBACK *classinst_proc)(DI_FUNCTION, HDEVINFO, SP_DEVINFO_DATA *);
     DWORD ret = ERROR_DI_DO_DEFAULT;
     HKEY class_key, coinst_key;
@@ -3994,10 +3934,10 @@ BOOL WINAPI SetupDiCallClassInstaller(DI_FUNCTION function, HDEVINFO devinfo, SP
 
     if (!open_driver_key(device, KEY_READ, &coinst_key))
     {
-        if (!RegGetValueW(coinst_key, NULL, coinstallers32W, RRF_RT_REG_MULTI_SZ, NULL, NULL, &size))
+        if (!RegGetValueW(coinst_key, NULL, L"CoInstallers32", RRF_RT_REG_MULTI_SZ, NULL, NULL, &size))
         {
             path = malloc(size);
-            if (!RegGetValueW(coinst_key, NULL, coinstallers32W, RRF_RT_REG_MULTI_SZ, NULL, path, &size))
+            if (!RegGetValueW(coinst_key, NULL, L"CoInstallers32", RRF_RT_REG_MULTI_SZ, NULL, path, &size))
                 coret = call_coinstallers(path, function, devinfo, device_data);
             free(path);
         }
@@ -4006,10 +3946,10 @@ BOOL WINAPI SetupDiCallClassInstaller(DI_FUNCTION function, HDEVINFO devinfo, SP
 
     if ((class_key = SetupDiOpenClassRegKey(&device->class, KEY_READ)) != INVALID_HANDLE_VALUE)
     {
-        if (!RegGetValueW(class_key, NULL, installer32W, RRF_RT_REG_SZ, NULL, NULL, &size))
+        if (!RegGetValueW(class_key, NULL, L"Installer32", RRF_RT_REG_SZ, NULL, NULL, &size))
         {
             path = malloc(size);
-            if (!RegGetValueW(class_key, NULL, installer32W, RRF_RT_REG_SZ, NULL, path, &size))
+            if (!RegGetValueW(class_key, NULL, L"Installer32", RRF_RT_REG_SZ, NULL, path, &size))
             {
                 TRACE("Found class installer %s.\n", debugstr_w(path));
                 if ((procnameW = wcschr(path, ',')))
@@ -4178,8 +4118,6 @@ BOOL WINAPI SetupDiSetDeviceInstallParamsW(HDEVINFO devinfo,
 BOOL WINAPI SetupDiSetDevicePropertyW(HDEVINFO devinfo, PSP_DEVINFO_DATA device_data, const DEVPROPKEY *key,
                                       DEVPROPTYPE type, const BYTE *buffer, DWORD size, DWORD flags)
 {
-    static const WCHAR propertiesW[] = {'P', 'r', 'o', 'p', 'e', 'r', 't', 'i', 'e', 's', 0};
-    static const WCHAR formatW[] = {'\\', '%', '0', '4', 'X', 0};
     struct device *device;
     HKEY properties_hkey, property_hkey;
     WCHAR property_hkey_path[44];
@@ -4210,7 +4148,7 @@ BOOL WINAPI SetupDiSetDevicePropertyW(HDEVINFO devinfo, PSP_DEVINFO_DATA device_
         return FALSE;
     }
 
-    ls = RegCreateKeyExW(device->key, propertiesW, 0, NULL, 0, KEY_READ | KEY_WRITE, NULL, &properties_hkey, NULL);
+    ls = RegCreateKeyExW(device->key, L"Properties", 0, NULL, 0, KEY_READ | KEY_WRITE, NULL, &properties_hkey, NULL);
     if (ls)
     {
         SetLastError(ls);
@@ -4218,7 +4156,7 @@ BOOL WINAPI SetupDiSetDevicePropertyW(HDEVINFO devinfo, PSP_DEVINFO_DATA device_
     }
 
     SETUPDI_GuidToString(&key->fmtid, property_hkey_path);
-    swprintf(property_hkey_path + 38, ARRAY_SIZE(property_hkey_path) - 38, formatW, key->pid);
+    swprintf(property_hkey_path + 38, ARRAY_SIZE(property_hkey_path) - 38, L"\\%04X", key->pid);
 
     if (type == DEVPROP_TYPE_EMPTY)
     {
@@ -4291,7 +4229,7 @@ HKEY WINAPI SetupDiOpenDevRegKey(HDEVINFO devinfo, SP_DEVINFO_DATA *device_data,
     switch (KeyType)
     {
         case DIREG_DEV:
-            l = RegOpenKeyExW(device->key, DeviceParameters, 0, samDesired, &key);
+            l = RegOpenKeyExW(device->key, L"Device Parameters", 0, samDesired, &key);
             break;
         case DIREG_DRV:
             l = open_driver_key(device, samDesired, &key);
@@ -4347,7 +4285,7 @@ BOOL WINAPI SetupDiDeleteDevRegKey(HDEVINFO devinfo, SP_DEVINFO_DATA *device_dat
                 break;
             /* fall through */
         case DIREG_DEV:
-            l = RegDeleteKeyW(device->key, DeviceParameters);
+            l = RegDeleteKeyW(device->key, L"Device Parameters");
             break;
         default:
             FIXME("Unhandled type %#lx.\n", KeyType);
@@ -4945,7 +4883,7 @@ BOOL WINAPI SetupDiGetINFClassW(PCWSTR inf, LPGUID class_guid, PWSTR class_name,
         return FALSE;
     }
 
-    if (!SetupFindFirstLineW(hinf, Version, Signature, &inf_ctx))
+    if (!SetupFindFirstLineW(hinf, L"Version", L"Signature", &inf_ctx))
     {
         ERR("INF file %s does not have mandatory [Version].Signature\n", debugstr_w(inf));
         goto out;
@@ -4957,13 +4895,13 @@ BOOL WINAPI SetupDiGetINFClassW(PCWSTR inf, LPGUID class_guid, PWSTR class_name,
         goto out;
     }
 
-    if (lstrcmpiW(buffer, Chicago) && lstrcmpiW(buffer, WindowsNT))
+    if (lstrcmpiW(buffer, L"$Chicago$") && lstrcmpiW(buffer, L"$Windows NT$"))
     {
         ERR("INF file %s has invalid [Version].Signature: %s\n", debugstr_w(inf), debugstr_w(buffer));
         goto out;
     }
 
-    have_guid = SetupFindFirstLineW(hinf, Version, ClassGUID, &inf_ctx);
+    have_guid = SetupFindFirstLineW(hinf, L"Version", L"ClassGUID", &inf_ctx);
 
     if (have_guid)
     {
@@ -4982,7 +4920,7 @@ BOOL WINAPI SetupDiGetINFClassW(PCWSTR inf, LPGUID class_guid, PWSTR class_name,
         }
     }
 
-    have_name = SetupFindFirstLineW(hinf, Version, Class, &inf_ctx);
+    have_name = SetupFindFirstLineW(hinf, L"Version", L"Class", &inf_ctx);
 
     class_name_len = 0;
     if (have_name)
@@ -5300,8 +5238,8 @@ BOOL WINAPI SetupDiInstallDeviceInterfaces(HDEVINFO devinfo, SP_DEVINFO_DATA *de
 
     callback_ctx = SetupInitDefaultQueueCallback(NULL);
 
-    lstrcatW(section_ext, dotInterfaces);
-    if (SetupFindFirstLineW(hinf, section_ext, AddInterface, &ctx))
+    lstrcatW(section_ext, L".Interfaces");
+    if (SetupFindFirstLineW(hinf, section_ext, L"AddInterface", &ctx))
     {
         do {
             SetupGetStringFieldW(&ctx, 1, guidstr, ARRAY_SIZE(guidstr), NULL);
@@ -5326,7 +5264,7 @@ BOOL WINAPI SetupDiInstallDeviceInterfaces(HDEVINFO devinfo, SP_DEVINFO_DATA *de
                     NULL, SP_COPY_NEWER_ONLY, SetupDefaultQueueCallbackW, callback_ctx, NULL, NULL);
 
             RegCloseKey(iface_key);
-        } while (SetupFindNextMatchLineW(&ctx, AddInterface, &ctx));
+        } while (SetupFindNextMatchLineW(&ctx, L"AddInterface", &ctx));
     }
 
     SetupTermDefaultQueueCallback(callback_ctx);
@@ -5340,7 +5278,6 @@ BOOL WINAPI SetupDiInstallDeviceInterfaces(HDEVINFO devinfo, SP_DEVINFO_DATA *de
  */
 BOOL WINAPI SetupDiRegisterCoDeviceInstallers(HDEVINFO devinfo, SP_DEVINFO_DATA *device_data)
 {
-    static const WCHAR coinstallersW[] = {'.','C','o','I','n','s','t','a','l','l','e','r','s',0};
     WCHAR coinst_key_ext[LINE_LEN];
     struct device *device;
     struct driver *driver;
@@ -5365,7 +5302,7 @@ BOOL WINAPI SetupDiRegisterCoDeviceInstallers(HDEVINFO devinfo, SP_DEVINFO_DATA
         return FALSE;
 
     SetupDiGetActualSectionToInstallW(hinf, driver->section, coinst_key_ext, ARRAY_SIZE(coinst_key_ext), NULL, NULL);
-    lstrcatW(coinst_key_ext, coinstallersW);
+    lstrcatW(coinst_key_ext, L".CoInstallers");
 
     if ((l = create_driver_key(device, &driver_key)))
     {
@@ -5424,16 +5361,16 @@ static BOOL version_is_compatible(const WCHAR *version)
     if ((p = wcschr(version, '.')))
         len = p - version;
 
-    if (!wcsnicmp(version, NtExtension + 1, len))
+    if (!wcsnicmp(version, L"NT", len))
         return TRUE;
 
     if (IsWow64Process(GetCurrentProcess(), &wow64) && wow64)
     {
 #ifdef __i386__
-        static const WCHAR wow_ext[] = {'N','T','a','m','d','6','4',0};
+        static const WCHAR wow_ext[] = L"NTamd64";
         machine_ext = wow_ext;
 #elif defined(__arm__)
-        static const WCHAR wow_ext[] = {'N','T','a','r','m','6','4',0};
+        static const WCHAR wow_ext[] = L"NTarm64";
         machine_ext = wow_ext;
 #endif
     }
@@ -5460,7 +5397,6 @@ static bool any_version_is_compatible(INFCONTEXT *ctx)
 
 static void enum_compat_drivers_from_file(struct device *device, const WCHAR *path)
 {
-    static const WCHAR manufacturerW[] = {'M','a','n','u','f','a','c','t','u','r','e','r',0};
     WCHAR mfg_key[LINE_LEN], id[MAX_DEVICE_ID_LEN];
     DWORD i, j, k, driver_count = device->driver_count;
     struct driver driver, *drivers = device->drivers;
@@ -5475,7 +5411,7 @@ static void enum_compat_drivers_from_file(struct device *device, const WCHAR *pa
 
     lstrcpyW(driver.inf_path, path);
 
-    for (i = 0; SetupGetLineByIndexW(hinf, manufacturerW, i, &ctx); ++i)
+    for (i = 0; SetupGetLineByIndexW(hinf, L"Manufacturer", i, &ctx); ++i)
     {
         SetupGetStringFieldW(&ctx, 0, driver.manufacturer, ARRAY_SIZE(driver.manufacturer), NULL);
         if (!SetupGetStringFieldW(&ctx, 1, mfg_key, ARRAY_SIZE(mfg_key), NULL))
@@ -5496,9 +5432,9 @@ static void enum_compat_drivers_from_file(struct device *device, const WCHAR *pa
             driver.rank = 0;
             for (k = 2, found = FALSE; SetupGetStringFieldW(&ctx, k, id, ARRAY_SIZE(id), NULL); ++k)
             {
-                if ((found = device_matches_id(device, HardwareId, id, &driver.rank))) break;
+                if ((found = device_matches_id(device, L"HardwareId", id, &driver.rank))) break;
                 driver.rank += 0x2000;
-                if ((found = device_matches_id(device, CompatibleIDs, id, &driver.rank))) break;
+                if ((found = device_matches_id(device, L"CompatibleIDs", id, &driver.rank))) break;
                 driver.rank = 0x1000 + min(0x0100 * (k - 2), 0xf00);
             }
 
@@ -5548,8 +5484,6 @@ BOOL WINAPI SetupDiBuildDriverInfoList(HDEVINFO devinfo, SP_DEVINFO_DATA *device
     }
     else
     {
-        static const WCHAR default_path[] = {'C',':','/','w','i','n','d','o','w','s','/','i','n','f',0};
-        static const WCHAR wildcardW[] = {'*',0};
         WCHAR dir[MAX_PATH], file[MAX_PATH];
         WIN32_FIND_DATAW find_data;
         HANDLE find_handle;
@@ -5557,9 +5491,8 @@ BOOL WINAPI SetupDiBuildDriverInfoList(HDEVINFO devinfo, SP_DEVINFO_DATA *device
         if (device->params.DriverPath[0])
             lstrcpyW(dir, device->params.DriverPath);
         else
-            lstrcpyW(dir, default_path);
-        lstrcatW(dir, backslashW);
-        lstrcatW(dir, wildcardW);
+            lstrcpyW(dir, L"C:/windows/inf");
+        lstrcatW(dir, L"\\*");
 
         TRACE("Searching for drivers in %s.\n", debugstr_w(dir));
 
@@ -5927,14 +5860,14 @@ BOOL WINAPI SetupDiInstallDriverFiles(HDEVINFO devinfo, SP_DEVINFO_DATA *device_
     SetupInstallFromInfSectionW(NULL, hinf, section_ext, SPINST_FILES, NULL, NULL,
             SP_COPY_NEWER_ONLY, SetupDefaultQueueCallbackW, callback_ctx, NULL, NULL);
 
-    lstrcatW(section_ext, dotInterfaces);
-    if (SetupFindFirstLineW(hinf, section_ext, AddInterface, &ctx))
+    lstrcatW(section_ext, L".Interfaces");
+    if (SetupFindFirstLineW(hinf, section_ext, L"AddInterface", &ctx))
     {
         do {
             SetupGetStringFieldW(&ctx, 3, iface_section, ARRAY_SIZE(iface_section), NULL);
             SetupInstallFromInfSectionW(NULL, hinf, iface_section, SPINST_FILES, NULL, NULL,
                     SP_COPY_NEWER_ONLY, SetupDefaultQueueCallbackW, callback_ctx, NULL, NULL);
-        } while (SetupFindNextMatchLineW(&ctx, AddInterface, &ctx));
+        } while (SetupFindNextMatchLineW(&ctx, L"AddInterface", &ctx));
     }
 
     SetupTermDefaultQueueCallback(callback_ctx);
@@ -5948,13 +5881,6 @@ BOOL WINAPI SetupDiInstallDriverFiles(HDEVINFO devinfo, SP_DEVINFO_DATA *device_
  */
 BOOL WINAPI SetupDiInstallDevice(HDEVINFO devinfo, SP_DEVINFO_DATA *device_data)
 {
-    static const WCHAR infpathW[] = {'I','n','f','P','a','t','h',0};
-    static const WCHAR infsectionW[] = {'I','n','f','S','e','c','t','i','o','n',0};
-    static const WCHAR infsectionextW[] = {'I','n','f','S','e','c','t','i','o','n','E','x','t',0};
-    static const WCHAR dothwW[] = {'.','H','W',0};
-    static const WCHAR dotservicesW[] = {'.','S','e','r','v','i','c','e','s',0};
-    static const WCHAR addserviceW[] = {'A','d','d','S','e','r','v','i','c','e',0};
-    static const WCHAR rootW[] = {'r','o','o','t','\\',0};
     WCHAR section_ext[LINE_LEN], subsection[LINE_LEN], inf_path[MAX_PATH], *extptr, *filepart;
     static const DWORD config_flags = 0;
     UINT install_flags = SPINST_ALL;
@@ -5995,7 +5921,7 @@ BOOL WINAPI SetupDiInstallDevice(HDEVINFO devinfo, SP_DEVINFO_DATA *device_data)
         return FALSE;
     }
 
-    if ((l = RegCreateKeyExW(device->key, DeviceParameters, 0, NULL, 0,
+    if ((l = RegCreateKeyExW(device->key, L"Device Parameters", 0, NULL, 0,
             KEY_READ | KEY_WRITE, NULL, &device_key, NULL)))
     {
         SetLastError(l);
@@ -6017,17 +5943,17 @@ BOOL WINAPI SetupDiInstallDevice(HDEVINFO devinfo, SP_DEVINFO_DATA *device_data)
             SP_COPY_NEWER_ONLY, SetupDefaultQueueCallbackW, callback_ctx, NULL, NULL);
 
     lstrcpyW(subsection, section_ext);
-    lstrcatW(subsection, dothwW);
+    lstrcatW(subsection, L".HW");
 
     SetupInstallFromInfSectionW(NULL, hinf, subsection, install_flags, device_key, NULL,
             SP_COPY_NEWER_ONLY, SetupDefaultQueueCallbackW, callback_ctx, NULL, NULL);
 
     lstrcpyW(subsection, section_ext);
-    lstrcatW(subsection, dotservicesW);
+    lstrcatW(subsection, L".Services");
     SetupInstallServicesFromInfSectionW(hinf, subsection, 0);
 
     svc_name[0] = 0;
-    if (SetupFindFirstLineW(hinf, subsection, addserviceW, &ctx))
+    if (SetupFindFirstLineW(hinf, subsection, L"AddService", &ctx))
     {
         do
         {
@@ -6036,10 +5962,10 @@ BOOL WINAPI SetupDiInstallDevice(HDEVINFO devinfo, SP_DEVINFO_DATA *device_data)
             if (SetupGetIntField(&ctx, 2, &flags) && (flags & SPSVCINST_ASSOCSERVICE))
             {
                 if (SetupGetStringFieldW(&ctx, 1, svc_name, ARRAY_SIZE(svc_name), NULL) && svc_name[0])
-                    RegSetValueExW(device->key, Service, 0, REG_SZ, (BYTE *)svc_name, lstrlenW(svc_name) * sizeof(WCHAR));
+                    RegSetValueExW(device->key, L"Service", 0, REG_SZ, (BYTE *)svc_name, lstrlenW(svc_name) * sizeof(WCHAR));
                 break;
             }
-        } while (SetupFindNextMatchLineW(&ctx, addserviceW, &ctx));
+        } while (SetupFindNextMatchLineW(&ctx, L"AddService", &ctx));
     }
 
     SetupTermDefaultQueueCallback(callback_ctx);
@@ -6048,15 +5974,15 @@ BOOL WINAPI SetupDiInstallDevice(HDEVINFO devinfo, SP_DEVINFO_DATA *device_data)
     SetupCopyOEMInfW(driver->inf_path, NULL, SPOST_NONE, 0, inf_path, ARRAY_SIZE(inf_path), NULL, &filepart);
     TRACE("Copied INF file %s to %s.\n", debugstr_w(driver->inf_path), debugstr_w(inf_path));
 
-    RegSetValueExW(driver_key, infpathW, 0, REG_SZ, (BYTE *)filepart, lstrlenW(filepart) * sizeof(WCHAR));
-    RegSetValueExW(driver_key, infsectionW, 0, REG_SZ, (BYTE *)driver->section, lstrlenW(driver->section) * sizeof(WCHAR));
+    RegSetValueExW(driver_key, L"InfPath", 0, REG_SZ, (BYTE *)filepart, lstrlenW(filepart) * sizeof(WCHAR));
+    RegSetValueExW(driver_key, L"InfSection", 0, REG_SZ, (BYTE *)driver->section, lstrlenW(driver->section) * sizeof(WCHAR));
     if (extptr)
-        RegSetValueExW(driver_key, infsectionextW, 0, REG_SZ, (BYTE *)extptr, lstrlenW(extptr) * sizeof(WCHAR));
+        RegSetValueExW(driver_key, L"InfSectionExt", 0, REG_SZ, (BYTE *)extptr, lstrlenW(extptr) * sizeof(WCHAR));
 
     RegCloseKey(device_key);
     RegCloseKey(driver_key);
 
-    if (!wcsnicmp(device->instanceId, rootW, lstrlenW(rootW)) && svc_name[0]
+    if (!wcsnicmp(device->instanceId, L"root\\", strlen("root\\")) && svc_name[0]
             && (manager = OpenSCManagerW(NULL, NULL, SC_MANAGER_CONNECT)))
     {
         if ((service = OpenServiceW(manager, svc_name, SERVICE_START | SERVICE_USER_DEFINED_CONTROL)))
diff --git a/dlls/setupapi/diskspace.c b/dlls/setupapi/diskspace.c
index 5b89fd5ca99..425ec80b7e8 100644
--- a/dlls/setupapi/diskspace.c
+++ b/dlls/setupapi/diskspace.c
@@ -163,7 +163,6 @@ BOOL WINAPI SetupQuerySpaceRequiredOnDriveW(HDSKSPC DiskSpace,
     unsigned int i;
     LPDISKSPACELIST list = DiskSpace;
     BOOL rc = FALSE;
-    static const WCHAR bkslsh[]= {'\\',0};
 
     if (!DiskSpace)
     {
@@ -185,7 +184,7 @@ BOOL WINAPI SetupQuerySpaceRequiredOnDriveW(HDSKSPC DiskSpace,
     }
 
     lstrcpyW(driveW,DriveSpec);
-    lstrcatW(driveW,bkslsh);
+    lstrcatW(driveW,L"\\");
 
     TRACE("Looking for drive %s\n",debugstr_w(driveW));
  
diff --git a/dlls/setupapi/misc.c b/dlls/setupapi/misc.c
index 3a44f3f4c60..bef8bfd7622 100644
--- a/dlls/setupapi/misc.c
+++ b/dlls/setupapi/misc.c
@@ -1354,9 +1354,6 @@ BOOL WINAPI SetupOpenLog(BOOL reserved)
 {
     WCHAR path[MAX_PATH];
 
-    static const WCHAR setupactlog[] = {'\\','s','e','t','u','p','a','c','t','.','l','o','g',0};
-    static const WCHAR setuperrlog[] = {'\\','s','e','t','u','p','e','r','r','.','l','o','g',0};
-
     EnterCriticalSection(&setupapi_cs);
 
     if (setupact != INVALID_HANDLE_VALUE && setuperr != INVALID_HANDLE_VALUE)
@@ -1366,7 +1363,7 @@ BOOL WINAPI SetupOpenLog(BOOL reserved)
     }
 
     GetWindowsDirectoryW(path, MAX_PATH);
-    lstrcatW(path, setupactlog);
+    lstrcatW(path, L"\\setupact.log");
 
     setupact = CreateFileW(path, FILE_GENERIC_WRITE, FILE_SHARE_WRITE | FILE_SHARE_READ,
                            NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
@@ -1379,7 +1376,7 @@ BOOL WINAPI SetupOpenLog(BOOL reserved)
     SetFilePointer(setupact, 0, NULL, FILE_END);
 
     GetWindowsDirectoryW(path, MAX_PATH);
-    lstrcatW(path, setuperrlog);
+    lstrcatW(path, L"\\setuperr.log");
 
     setuperr = CreateFileW(path, FILE_GENERIC_WRITE, FILE_SHARE_WRITE | FILE_SHARE_READ,
                            NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
diff --git a/dlls/setupapi/parser.c b/dlls/setupapi/parser.c
index 22dc23c54fd..1c09d39a0fe 100644
--- a/dlls/setupapi/parser.c
+++ b/dlls/setupapi/parser.c
@@ -143,14 +143,6 @@ static const parser_state_func parser_funcs[NB_PARSER_STATES] =
 };
 
 
-/* Unicode string constants */
-static const WCHAR Version[]    = {'V','e','r','s','i','o','n',0};
-static const WCHAR Signature[]  = {'S','i','g','n','a','t','u','r','e',0};
-static const WCHAR Chicago[]    = {'$','C','h','i','c','a','g','o','$',0};
-static const WCHAR WindowsNT[]  = {'$','W','i','n','d','o','w','s',' ','N','T','$',0};
-static const WCHAR Windows95[]  = {'$','W','i','n','d','o','w','s',' ','9','5','$',0};
-static const WCHAR LayoutFile[] = {'L','a','y','o','u','t','F','i','l','e',0};
-
 /* extend an array, allocating more memory if necessary */
 static void *grow_array( void *array, unsigned int *count, size_t elem )
 {
@@ -870,8 +862,6 @@ static void free_inf_file( struct inf_file *file )
 static DWORD parse_buffer( struct inf_file *file, const WCHAR *buffer, const WCHAR *end,
                            UINT *error_line )
 {
-    static const WCHAR Strings[] = {'S','t','r','i','n','g','s',0};
-
     struct parser parser;
     const WCHAR *pos = buffer;
 
@@ -911,7 +901,7 @@ static DWORD parse_buffer( struct inf_file *file, const WCHAR *buffer, const WCH
     }
 
     /* find the [strings] section */
-    file->strings_section = find_section( file, Strings );
+    file->strings_section = find_section( file, L"Strings" );
 
     if (file->strings_section == -1 && parser.broken_line)
     {
@@ -1007,16 +997,16 @@ static struct inf_file *parse_file( HANDLE handle, const WCHAR *class, DWORD sty
 
     if (!err)  /* now check signature */
     {
-        int version_index = find_section( file, Version );
+        int version_index = find_section( file, L"Version" );
         if (version_index != -1)
         {
-            struct line *line = find_line( file, version_index, Signature );
+            struct line *line = find_line( file, version_index, L"Signature" );
             if (line && line->nb_fields > 0)
             {
                 struct field *field = file->fields + line->first_field;
-                if (!wcsicmp( field->text, Chicago )) goto done;
-                if (!wcsicmp( field->text, WindowsNT )) goto done;
-                if (!wcsicmp( field->text, Windows95 )) goto done;
+                if (!wcsicmp( field->text, L"$Chicago$" )) goto done;
+                if (!wcsicmp( field->text, L"$Windows NT$" )) goto done;
+                if (!wcsicmp( field->text, L"$Windows 95$" )) goto done;
             }
         }
         if (error_line) *error_line = 0;
@@ -1119,9 +1109,6 @@ HINF WINAPI SetupOpenInfFileW( PCWSTR name, PCWSTR class, DWORD style, UINT *err
     }
     else  /* try Windows directory */
     {
-        static const WCHAR Inf[]      = {'\\','i','n','f','\\',0};
-        static const WCHAR System32[] = {'\\','s','y','s','t','e','m','3','2','\\',0};
-
         len = GetWindowsDirectoryW( NULL, 0 ) + lstrlenW(name) + 12;
         if (!(path = malloc( len * sizeof(WCHAR) )))
         {
@@ -1130,12 +1117,12 @@ HINF WINAPI SetupOpenInfFileW( PCWSTR name, PCWSTR class, DWORD style, UINT *err
         }
         GetWindowsDirectoryW( path, len );
         p = path + lstrlenW(path);
-        lstrcpyW( p, Inf );
+        lstrcpyW( p, L"\\inf\\" );
         lstrcatW( p, name );
         handle = CreateFileW( path, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0 );
         if (handle == INVALID_HANDLE_VALUE)
         {
-            lstrcpyW( p, System32 );
+            lstrcpyW( p, L"\\system32\\" );
             lstrcatW( p, name );
             handle = CreateFileW( path, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0 );
         }
@@ -1187,7 +1174,7 @@ BOOL WINAPI SetupOpenAppendInfFileW( PCWSTR name, HINF parent_hinf, UINT *error
         WCHAR filename[MAX_PATH];
         int idx = 1;
 
-        if (!SetupFindFirstLineW( parent_hinf, Version, LayoutFile, &context )) return FALSE;
+        if (!SetupFindFirstLineW( parent_hinf, L"Version", L"LayoutFile", &context )) return FALSE;
         while (SetupGetStringFieldW( &context, idx++, filename, ARRAY_SIZE( filename ), NULL ))
         {
             child_hinf = SetupOpenInfFileW( filename, NULL, INF_STYLE_WIN4, error );
@@ -1210,11 +1197,10 @@ BOOL WINAPI SetupOpenAppendInfFileW( PCWSTR name, HINF parent_hinf, UINT *error
  */
 HINF WINAPI SetupOpenMasterInf( VOID )
 {
-    static const WCHAR Layout[] = {'\\','i','n','f','\\', 'l', 'a', 'y', 'o', 'u', 't', '.', 'i', 'n', 'f', 0};
     WCHAR Buffer[MAX_PATH];
 
     GetWindowsDirectoryW( Buffer, MAX_PATH );
-    lstrcatW( Buffer, Layout );
+    lstrcatW( Buffer, L"\\inf\\layout.inf" );
     return SetupOpenInfFileW( Buffer, NULL, INF_STYLE_WIN4, NULL);
 }
 
diff --git a/dlls/setupapi/query.c b/dlls/setupapi/query.c
index 707492ac984..60b7c95290f 100644
--- a/dlls/setupapi/query.c
+++ b/dlls/setupapi/query.c
@@ -34,35 +34,23 @@
 WINE_DEFAULT_DEBUG_CHANNEL(setupapi);
 
 #ifdef __i386__
-static const WCHAR source_disks_names_platform[] =
-    {'S','o','u','r','c','e','D','i','s','k','s','N','a','m','e','s','.','x','8','6',0};
-static const WCHAR source_disks_files_platform[] =
-    {'S','o','u','r','c','e','D','i','s','k','s','F','i','l','e','s','.','x','8','6',0};
+static const WCHAR source_disks_names_platform[] = L"SourceDisksNames.x86";
+static const WCHAR source_disks_files_platform[] = L"SourceDisksFiles.x86";
 #elif defined(__x86_64__)
-static const WCHAR source_disks_names_platform[] =
-    {'S','o','u','r','c','e','D','i','s','k','s','N','a','m','e','s','.','a','m','d','6','4',0};
-static const WCHAR source_disks_files_platform[] =
-    {'S','o','u','r','c','e','D','i','s','k','s','F','i','l','e','s','.','a','m','d','6','4',0};
+static const WCHAR source_disks_names_platform[] = L"SourceDisksNames.amd64";
+static const WCHAR source_disks_files_platform[] = L"SourceDisksFiles.amd64";
 #elif defined(__arm__)
-static const WCHAR source_disks_names_platform[] =
-    {'S','o','u','r','c','e','D','i','s','k','s','N','a','m','e','s','.','a','r','m',0};
-static const WCHAR source_disks_files_platform[] =
-    {'S','o','u','r','c','e','D','i','s','k','s','F','i','l','e','s','.','a','r','m',0};
+static const WCHAR source_disks_names_platform[] = L"SourceDisksNames.arm";
+static const WCHAR source_disks_files_platform[] = L"SourceDisksFiles.arm";
 #elif defined(__aarch64__)
-static const WCHAR source_disks_names_platform[] =
-    {'S','o','u','r','c','e','D','i','s','k','s','N','a','m','e','s','.','a','r','m','6','4',0};
-static const WCHAR source_disks_files_platform[] =
-    {'S','o','u','r','c','e','D','i','s','k','s','F','i','l','e','s','.','a','r','m','6','4',0};
+static const WCHAR source_disks_names_platform[] = L"SourceDisksNames.arm64";
+static const WCHAR source_disks_files_platform[] = L"SourceDisksFiles.arm64";
 #else  /* FIXME: other platforms */
-static const WCHAR source_disks_names_platform[] =
-    {'S','o','u','r','c','e','D','i','s','k','s','N','a','m','e','s',0};
-static const WCHAR source_disks_files_platform[] =
-    {'S','o','u','r','c','e','D','i','s','k','s','F','i','l','e','s',0};
+static const WCHAR source_disks_names_platform[] = L"SourceDisksNames";
+static const WCHAR source_disks_files_platform[] = L"SourceDisksFiles";
 #endif
-static const WCHAR source_disks_names[] =
-    {'S','o','u','r','c','e','D','i','s','k','s','N','a','m','e','s',0};
-static const WCHAR source_disks_files[] =
-    {'S','o','u','r','c','e','D','i','s','k','s','F','i','l','e','s',0};
+static const WCHAR source_disks_names[] = L"SourceDisksNames";
+static const WCHAR source_disks_files[] = L"SourceDisksFiles";
 
 /* fills the PSP_INF_INFORMATION struct fill_info is TRUE
  * always returns the required size of the information
@@ -96,13 +84,10 @@ static HINF search_for_inf(LPCVOID InfSpec, DWORD SearchControl)
     HINF hInf = INVALID_HANDLE_VALUE;
     WCHAR inf_path[MAX_PATH];
 
-    static const WCHAR infW[] = {'\\','i','n','f','\\',0};
-    static const WCHAR system32W[] = {'\\','s','y','s','t','e','m','3','2','\\',0};
-
     if (SearchControl == INFINFO_REVERSE_DEFAULT_SEARCH)
     {
         GetWindowsDirectoryW(inf_path, MAX_PATH);
-        lstrcatW(inf_path, system32W);
+        lstrcatW(inf_path, L"\\system32\\");
         lstrcatW(inf_path, InfSpec);
 
         hInf = SetupOpenInfFileW(inf_path, NULL,
@@ -111,7 +96,7 @@ static HINF search_for_inf(LPCVOID InfSpec, DWORD SearchControl)
             return hInf;
 
         GetWindowsDirectoryW(inf_path, MAX_PATH);
-        lstrcpyW(inf_path, infW);
+        lstrcpyW(inf_path, L"\\inf\\");
         lstrcatW(inf_path, InfSpec);
 
         return SetupOpenInfFileW(inf_path, NULL,
@@ -485,13 +470,12 @@ BOOL WINAPI SetupGetSourceInfoW( HINF hinf, UINT source_id, UINT info,
 {
     INFCONTEXT ctx;
     WCHAR source_id_str[11];
-    static const WCHAR fmt[] = {'%','d',0};
     DWORD index;
 
     TRACE("%p, %d, %d, %p, %ld, %p\n", hinf, source_id, info, buffer, buffer_size,
           required_size);
 
-    swprintf( source_id_str, ARRAY_SIZE(source_id_str), fmt, source_id );
+    swprintf( source_id_str, ARRAY_SIZE(source_id_str), L"%d", source_id );
 
     if (!SetupFindFirstLineW( hinf, source_disks_names_platform, source_id_str, &ctx ) &&
         !SetupFindFirstLineW( hinf, source_disks_names, source_id_str, &ctx ))
@@ -578,11 +562,6 @@ BOOL WINAPI SetupGetTargetPathA( HINF hinf, PINFCONTEXT context, PCSTR section,
 BOOL WINAPI SetupGetTargetPathW( HINF hinf, PINFCONTEXT context, PCWSTR section, PWSTR buffer,
                                  DWORD buffer_size, PDWORD required_size )
 {
-    static const WCHAR destination_dirs[] =
-        {'D','e','s','t','i','n','a','t','i','o','n','D','i','r','s',0};
-    static const WCHAR default_dest_dir[]  =
-        {'D','e','f','a','u','l','t','D','e','s','t','D','i','r',0};
-
     INFCONTEXT ctx;
     WCHAR *dir, systemdir[MAX_PATH];
     unsigned int size;
@@ -591,11 +570,11 @@ BOOL WINAPI SetupGetTargetPathW( HINF hinf, PINFCONTEXT context, PCWSTR section,
     TRACE("%p, %p, %s, %p, 0x%08lx, %p\n", hinf, context, debugstr_w(section), buffer,
           buffer_size, required_size);
 
-    if (context) ret = SetupFindFirstLineW( hinf, destination_dirs, NULL, context );
+    if (context) ret = SetupFindFirstLineW( hinf, L"DestinationDirs", NULL, context );
     else if (section)
     {
-        if (!(ret = SetupFindFirstLineW( hinf, destination_dirs, section, &ctx )))
-            ret = SetupFindFirstLineW( hinf, destination_dirs, default_dest_dir, &ctx );
+        if (!(ret = SetupFindFirstLineW( hinf, L"DestinationDirs", section, &ctx )))
+            ret = SetupFindFirstLineW( hinf, L"DestinationDirs", L"DefaultDestDir", &ctx );
     }
     if (!ret || !(dir = PARSER_get_dest_dir( context ? context : &ctx )))
     {
@@ -666,8 +645,6 @@ BOOL WINAPI SetupQueryInfOriginalFileInformationW(
     LPCWSTR inf_name;
     LPCWSTR inf_path;
     HINF hinf;
-    static const WCHAR wszVersion[] = { 'V','e','r','s','i','o','n',0 };
-    static const WCHAR wszCatalogFile[] = { 'C','a','t','a','l','o','g','F','i','l','e',0 };
 
     FIXME("(%p, %d, %p, %p): semi-stub\n", InfInformation, InfIndex,
         AlternativePlatformInfo, OriginalFileInfo);
@@ -687,7 +664,7 @@ BOOL WINAPI SetupQueryInfOriginalFileInformationW(
     hinf = SetupOpenInfFileW(inf_path, NULL, INF_STYLE_WIN4, NULL);
     if (hinf == INVALID_HANDLE_VALUE) return FALSE;
 
-    if (!SetupGetLineTextW(NULL, hinf, wszVersion, wszCatalogFile,
+    if (!SetupGetLineTextW(NULL, hinf, L"Version", L"CatalogFile",
                            OriginalFileInfo->OriginalCatalogName,
                            ARRAY_SIZE(OriginalFileInfo->OriginalCatalogName), NULL))
     {
-- 
2.49.0

From 562fb8709f5d78b793b06c3bca4edb423df38a87 Mon Sep 17 00:00:00 2001
From: Alexander Morozov <amorozov@etersoft.ru>
Date: Sat, 15 Mar 2025 18:20:13 +0300
Subject: [PATCH 129/159] ntoskrnl.exe/tests: Improve device properties test,
 avoid BSOD.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=57940
---
 dlls/ntoskrnl.exe/tests/driver_pnp.c | 14 +++++++++-----
 1 file changed, 9 insertions(+), 5 deletions(-)

diff --git a/dlls/ntoskrnl.exe/tests/driver_pnp.c b/dlls/ntoskrnl.exe/tests/driver_pnp.c
index eb0f469ebbe..2ccfd1eaf17 100644
--- a/dlls/ntoskrnl.exe/tests/driver_pnp.c
+++ b/dlls/ntoskrnl.exe/tests/driver_pnp.c
@@ -654,8 +654,8 @@ static void test_device_properties( DEVICE_OBJECT *device )
         if (status == STATUS_SUCCESS)
         {
             void *buf;
-            ULONG req_size;
-            DEVPROPTYPE stored_type;
+            ULONG req_size = 0;
+            DEVPROPTYPE stored_type = DEVPROP_TYPE_EMPTY;
 
             status = IoGetDevicePropertyData( device, key, LOCALE_NEUTRAL, 0, 0, NULL, &req_size,
                                               &stored_type );
@@ -669,11 +669,16 @@ static void test_device_properties( DEVICE_OBJECT *device )
             ok( buf != NULL, "Failed to allocate buffer.\n" );
             if (buf != NULL)
             {
+                req_size = 0;
+                stored_type = DEVPROP_TYPE_EMPTY;
                 memset( buf, 0, size );
-                status = IoGetDevicePropertyData( device, key, LOCALE_NEUTRAL, 0, size, buf, NULL,
-                                                  &stored_type );
+                status = IoGetDevicePropertyData( device, key, LOCALE_NEUTRAL, 0, size, buf,
+                                                  &req_size, &stored_type );
                 ok( status == STATUS_SUCCESS, "Failed to get device property, status %#lx.\n",
                     status );
+                ok( req_size == size, "Expected required size %lu, got %lu.\n", req_size, size );
+                ok( stored_type == type, "Expected DEVPROPTYPE value %#lx, got %#lx.\n", type,
+                    stored_type );
                 if (status == STATUS_SUCCESS)
                     ok( memcmp( buf, value, size ) == 0,
                         "Got unexpected device property value.\n" );
@@ -683,7 +688,6 @@ static void test_device_properties( DEVICE_OBJECT *device )
         status = IoSetDevicePropertyData( device, key, LOCALE_NEUTRAL, 0, type, 0, NULL );
         ok( status == STATUS_SUCCESS, "Failed to delete device property, status %#lx.\n", status );
     }
-    return;
 }
 
 static NTSTATUS fdo_ioctl(IRP *irp, IO_STACK_LOCATION *stack, ULONG code)
-- 
2.49.0

From 33b855614a271d3e7e7793f1c735e0595862f96b Mon Sep 17 00:00:00 2001
From: Alexander Morozov <amorozov@etersoft.ru>
Date: Thu, 24 Apr 2025 02:48:07 +0300
Subject: [PATCH 130/159] ntoskrnl.exe/tests: Test some Io functions with FDO
 and PDO.

---
 dlls/ntoskrnl.exe/tests/driver_pnp.c | 61 ++++++++++++++++++++++++++++
 dlls/ntoskrnl.exe/tests/ntoskrnl.c   | 11 +++++
 include/ddk/wdm.h                    |  4 ++
 3 files changed, 76 insertions(+)

diff --git a/dlls/ntoskrnl.exe/tests/driver_pnp.c b/dlls/ntoskrnl.exe/tests/driver_pnp.c
index 2ccfd1eaf17..7ae76d5bbb1 100644
--- a/dlls/ntoskrnl.exe/tests/driver_pnp.c
+++ b/dlls/ntoskrnl.exe/tests/driver_pnp.c
@@ -690,6 +690,65 @@ static void test_device_properties( DEVICE_OBJECT *device )
     }
 }
 
+static void test_enumerator_name(void)
+{
+    static const WCHAR root[] = L"ROOT";
+    WCHAR buffer[10];
+    ULONG req_size;
+    NTSTATUS status;
+
+    status = IoGetDeviceProperty(bus_fdo, DevicePropertyEnumeratorName, sizeof(buffer), buffer, &req_size);
+    todo_wine ok(status == STATUS_INVALID_DEVICE_REQUEST, "got unexpected status %#lx\n", status);
+
+    req_size = 0;
+    memset(buffer, 0, sizeof(buffer));
+    status = IoGetDeviceProperty(bus_pdo, DevicePropertyEnumeratorName, sizeof(buffer), buffer, &req_size);
+    ok(status == STATUS_SUCCESS, "IoGetDeviceProperty failed: %#lx\n", status);
+    todo_wine ok(req_size == sizeof(root), "unexpected size %lu\n", req_size);
+    if (status == STATUS_SUCCESS)
+        todo_wine ok(!wcscmp(root, buffer), "unexpected property value '%ls'\n", buffer);
+}
+
+static void test_device_registry_key(void)
+{
+    static const WCHAR foobar[] = L"foobar";
+    static const WCHAR foo[] = L"foo";
+
+    KEY_VALUE_PARTIAL_INFORMATION *info;
+    UNICODE_STRING name_str;
+    NTSTATUS status;
+    HANDLE hkey;
+    DWORD size;
+
+    status = IoOpenDeviceRegistryKey(bus_fdo, PLUGPLAY_REGKEY_DEVICE, KEY_ALL_ACCESS, &hkey);
+    todo_wine ok(status == STATUS_INVALID_PARAMETER, "got unexpected status %#lx\n", status);
+
+    status = IoOpenDeviceRegistryKey(bus_pdo, PLUGPLAY_REGKEY_DEVICE, KEY_ALL_ACCESS, &hkey);
+    ok(status == STATUS_SUCCESS, "IoOpenDeviceRegistryKey failed: %#lx\n", status);
+    if (status == STATUS_SUCCESS)
+    {
+        RtlInitUnicodeString(&name_str, foobar);
+        status = ZwQueryValueKey(hkey, &name_str, KeyValuePartialInformation, NULL, 0, &size);
+        ok(status == STATUS_BUFFER_TOO_SMALL, "got unexpected status %#lx\n", status);
+
+        info = ExAllocatePool(PagedPool, size);
+        ok(!!info, "failed to allocate memory\n");
+        if (info)
+        {
+            memset(info, 0, size);
+            status = ZwQueryValueKey(hkey, &name_str, KeyValuePartialInformation, info, size, &size);
+            ok(status == STATUS_SUCCESS, "ZwQueryValueKey failed: %#lx\n", status);
+            ok(info->Type == REG_SZ, "expected type REG_SZ, got %lu\n", info->Type);
+            ok(info->DataLength == sizeof(foo), "unexpected DataLength %lu\n", info->DataLength);
+            ok(!wcscmp((WCHAR *)info->Data, foo), "got unexpected key value\n");
+            ExFreePool(info);
+        }
+
+        status = ZwClose(hkey);
+        ok(status == STATUS_SUCCESS, "ZwClose failed: %#lx\n", status);
+    }
+}
+
 static NTSTATUS fdo_ioctl(IRP *irp, IO_STACK_LOCATION *stack, ULONG code)
 {
     switch (code)
@@ -697,6 +756,8 @@ static NTSTATUS fdo_ioctl(IRP *irp, IO_STACK_LOCATION *stack, ULONG code)
         case IOCTL_WINETEST_BUS_MAIN:
             test_bus_query();
             test_device_properties( bus_pdo );
+            test_enumerator_name();
+            test_device_registry_key();
             return STATUS_SUCCESS;
 
         case IOCTL_WINETEST_BUS_REGISTER_IFACE:
diff --git a/dlls/ntoskrnl.exe/tests/ntoskrnl.c b/dlls/ntoskrnl.exe/tests/ntoskrnl.c
index 48deda7c455..e2cdfabae49 100644
--- a/dlls/ntoskrnl.exe/tests/ntoskrnl.c
+++ b/dlls/ntoskrnl.exe/tests/ntoskrnl.c
@@ -1450,6 +1450,8 @@ static void test_pnp_devices(void)
     static const char expect_hardware_id[] = "winetest_hardware\0winetest_hardware_1\0";
     static const char expect_compat_id[] = "winetest_compat\0winetest_compat_1\0";
     static const WCHAR expect_container_id_w[] = L"{12345678-1234-1234-1234-123456789123}";
+    static const char foobar[] = "foobar";
+    static const char foo[] = "foo";
 
     char buffer[200];
     WCHAR buffer_w[200];
@@ -1475,6 +1477,8 @@ static void test_pnp_devices(void)
     IO_STATUS_BLOCK io;
     HDEVINFO set;
     HWND window;
+    LSTATUS status;
+    HKEY key;
     BOOL ret;
     int id;
 
@@ -1508,6 +1512,13 @@ static void test_pnp_devices(void)
     ok(!strcmp(iface_detail->DevicePath, "\\\\?\\root#winetest#0#{deadbeef-29ef-4538-a5fd-b69573a362c0}"),
             "wrong path %s\n", debugstr_a(iface_detail->DevicePath));
 
+    /* Create a device parameter for testing IoOpenDeviceRegistryKey */
+    key = SetupDiCreateDevRegKeyA(set, &device, DICS_FLAG_GLOBAL, 0, DIREG_DEV, NULL, NULL);
+    ok(key != INVALID_HANDLE_VALUE, "failed to create a hardware parameters key, got error %#lx\n", GetLastError());
+    status = RegSetValueExA(key, foobar, 0, REG_SZ, (const BYTE *)foo, sizeof(foo));
+    ok(status == ERROR_SUCCESS, "failed to save a device parameter, got error %lu\n", status);
+    RegCloseKey(key);
+
     SetupDiDestroyDeviceInfoList(set);
 
     bus = CreateFileA(iface_detail->DevicePath, 0, 0, NULL, OPEN_EXISTING, 0, NULL);
diff --git a/include/ddk/wdm.h b/include/ddk/wdm.h
index 787fe5853c5..fbc1b07f77b 100644
--- a/include/ddk/wdm.h
+++ b/include/ddk/wdm.h
@@ -1744,6 +1744,10 @@ void      WINAPI ExReleaseResourceForThreadLite(ERESOURCE*,ERESOURCE_THREAD);
 ULONG     WINAPI ExSetTimerResolution(ULONG,BOOLEAN);
 void      WINAPI ExUnregisterCallback(void*);
 
+#define PLUGPLAY_REGKEY_DEVICE            1
+#define PLUGPLAY_REGKEY_DRIVER            2
+#define PLUGPLAY_REGKEY_CURRENT_HWPROFILE 4
+
 #define PLUGPLAY_PROPERTY_PERSISTENT 0x0001
 
 void      WINAPI IoFreeErrorLogEntry(void*);
-- 
2.49.0

From dd39e6bd2a2f739c2f0088dc2ef9f86247a0be07 Mon Sep 17 00:00:00 2001
From: Alexander Morozov <amorozov@etersoft.ru>
Date: Thu, 24 Apr 2025 02:49:56 +0300
Subject: [PATCH 131/159] ntoskrnl.exe/tests: Test that calling some Io
 functions does not result in receiving IRP_MN_QUERY_ID.

---
 dlls/ntoskrnl.exe/tests/driver.h     |   1 +
 dlls/ntoskrnl.exe/tests/driver_pnp.c | 100 ++++++++++++++++++++++++++-
 dlls/ntoskrnl.exe/tests/ntoskrnl.c   |  11 +++
 3 files changed, 111 insertions(+), 1 deletion(-)

diff --git a/dlls/ntoskrnl.exe/tests/driver.h b/dlls/ntoskrnl.exe/tests/driver.h
index 9c51af0a4c6..e22d756e69e 100644
--- a/dlls/ntoskrnl.exe/tests/driver.h
+++ b/dlls/ntoskrnl.exe/tests/driver.h
@@ -47,6 +47,7 @@
 #define IOCTL_WINETEST_CHILD_GET_ID         CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)
 #define IOCTL_WINETEST_CHILD_MARK_PENDING   CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_NEITHER, FILE_ANY_ACCESS)
 #define IOCTL_WINETEST_CHILD_CHECK_REMOVED  CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802, METHOD_NEITHER, FILE_ANY_ACCESS)
+#define IOCTL_WINETEST_CHILD_MAIN           CTL_CODE(FILE_DEVICE_UNKNOWN, 0x803, METHOD_BUFFERED, FILE_ANY_ACCESS)
 
 static const char teststr[] = "Wine is not an emulator";
 
diff --git a/dlls/ntoskrnl.exe/tests/driver_pnp.c b/dlls/ntoskrnl.exe/tests/driver_pnp.c
index 7ae76d5bbb1..652fad79458 100644
--- a/dlls/ntoskrnl.exe/tests/driver_pnp.c
+++ b/dlls/ntoskrnl.exe/tests/driver_pnp.c
@@ -60,7 +60,11 @@ static UNICODE_STRING control_symlink, bus_symlink;
 static DRIVER_OBJECT *driver_obj;
 static DEVICE_OBJECT *bus_fdo, *bus_pdo;
 
-static unsigned int remove_device_count, surprise_removal_count, query_remove_device_count, cancel_remove_device_count;
+static unsigned int remove_device_count;
+static unsigned int surprise_removal_count;
+static unsigned int query_remove_device_count;
+static unsigned int cancel_remove_device_count;
+static unsigned int query_id_count;
 
 struct irp_queue
 {
@@ -270,6 +274,7 @@ static NTSTATUS pdo_pnp(DEVICE_OBJECT *device_obj, IRP *irp)
     switch (stack->MinorFunction)
     {
         case IRP_MN_QUERY_ID:
+            query_id_count++;
             ret = query_id(device, irp, stack->Parameters.QueryId.IdType);
             break;
 
@@ -285,7 +290,9 @@ static NTSTATUS pdo_pnp(DEVICE_OBJECT *device_obj, IRP *irp)
             ok(!stack->Parameters.StartDevice.AllocatedResources, "expected no resources\n");
             ok(!stack->Parameters.StartDevice.AllocatedResourcesTranslated, "expected no translated resources\n");
 
+            query_id_count = 0;
             status = IoRegisterDeviceInterface(device_obj, &child_class, NULL, &device->child_symlink);
+            todo_wine ok(query_id_count == 0, "expected no IRP_MN_QUERY_ID\n");
             ok(!status, "Failed to register interface, status %#lx.\n", status);
             ok(device->child_symlink.Length == sizeof(expect_symlink) - sizeof(WCHAR),
                     "Got length %u.\n", device->child_symlink.Length);
@@ -690,6 +697,36 @@ static void test_device_properties( DEVICE_OBJECT *device )
     }
 }
 
+static void test_child_device_properties(DEVICE_OBJECT *device)
+{
+    NTSTATUS status;
+    const DEVPROPKEY *key = &DEVPKEY_Winetest_1;
+    DEVPROPTYPE type = DEVPROP_TYPE_BYTE;
+    DEVPROPTYPE stored_type = DEVPROP_TYPE_EMPTY;
+    ULONG size = sizeof(BYTE);
+    ULONG req_size = 0;
+    BYTE value = 0xe2;
+    BYTE stored_value = 0;
+
+    query_id_count = 0;
+    status = IoSetDevicePropertyData(device, key, LOCALE_NEUTRAL, 0, type, size, &value);
+    todo_wine ok(query_id_count == 0, "expected no IRP_MN_QUERY_ID\n");
+    ok(status == STATUS_SUCCESS, "failed to set device property, status %#lx\n", status);
+
+    query_id_count = 0;
+    status = IoGetDevicePropertyData(device, key, LOCALE_NEUTRAL, 0, size, &stored_value, &req_size, &stored_type);
+    todo_wine ok(query_id_count == 0, "expected no IRP_MN_QUERY_ID\n");
+    ok(status == STATUS_SUCCESS, "failed to get device property, status %#lx\n", status);
+    ok(req_size == size, "expected required size %lu, got %lu\n", req_size, size);
+    ok(stored_type == type, "expected DEVPROPTYPE value %#lx, got %#lx\n", type, stored_type);
+    ok(stored_value == value, "got unexpected device property value: %#x\n", stored_value);
+
+    query_id_count = 0;
+    status = IoSetDevicePropertyData(device, key, LOCALE_NEUTRAL, 0, type, 0, NULL);
+    todo_wine ok(query_id_count == 0, "expected no IRP_MN_QUERY_ID\n");
+    ok(status == STATUS_SUCCESS, "failed to delete device property, status %#lx\n", status);
+}
+
 static void test_enumerator_name(void)
 {
     static const WCHAR root[] = L"ROOT";
@@ -709,6 +746,22 @@ static void test_enumerator_name(void)
         todo_wine ok(!wcscmp(root, buffer), "unexpected property value '%ls'\n", buffer);
 }
 
+static void test_child_enumerator_name(DEVICE_OBJECT *device)
+{
+    static const WCHAR wine[] = L"Wine";
+    WCHAR buffer[10] = {0};
+    ULONG req_size = 0;
+    NTSTATUS status;
+
+    query_id_count = 0;
+    status = IoGetDeviceProperty(device, DevicePropertyEnumeratorName, sizeof(buffer), buffer, &req_size);
+    todo_wine ok(query_id_count == 0, "expected no IRP_MN_QUERY_ID\n");
+    ok(status == STATUS_SUCCESS, "IoGetDeviceProperty failed: %#lx\n", status);
+    todo_wine ok(req_size == sizeof(wine), "unexpected size %lu\n", req_size);
+    if (status == STATUS_SUCCESS)
+        todo_wine ok(!wcscmp(wine, buffer), "unexpected property value '%ls'\n", buffer);
+}
+
 static void test_device_registry_key(void)
 {
     static const WCHAR foobar[] = L"foobar";
@@ -749,6 +802,45 @@ static void test_device_registry_key(void)
     }
 }
 
+static void test_child_device_registry_key(DEVICE_OBJECT *device)
+{
+    static const WCHAR foobar[] = L"foobar";
+    static const WCHAR bar[] = L"bar";
+
+    KEY_VALUE_PARTIAL_INFORMATION *info;
+    UNICODE_STRING name_str;
+    NTSTATUS status;
+    HANDLE hkey;
+    DWORD size;
+
+    query_id_count = 0;
+    status = IoOpenDeviceRegistryKey(device, PLUGPLAY_REGKEY_DEVICE, KEY_ALL_ACCESS, &hkey);
+    todo_wine ok(query_id_count == 0, "expected no IRP_MN_QUERY_ID\n");
+    ok(status == STATUS_SUCCESS, "IoOpenDeviceRegistryKey failed: %#lx\n", status);
+    if (status == STATUS_SUCCESS)
+    {
+        RtlInitUnicodeString(&name_str, foobar);
+        status = ZwQueryValueKey(hkey, &name_str, KeyValuePartialInformation, NULL, 0, &size);
+        ok(status == STATUS_BUFFER_TOO_SMALL, "got unexpected status %#lx\n", status);
+
+        info = ExAllocatePool(PagedPool, size);
+        ok(!!info, "failed to allocate memory\n");
+        if (info)
+        {
+            memset(info, 0, size);
+            status = ZwQueryValueKey(hkey, &name_str, KeyValuePartialInformation, info, size, &size);
+            ok(status == STATUS_SUCCESS, "ZwQueryValueKey failed: %#lx\n", status);
+            ok(info->Type == REG_SZ, "expected type REG_SZ, got %lu\n", info->Type);
+            ok(info->DataLength == sizeof(bar), "unexpected DataLength %lu\n", info->DataLength);
+            ok(!wcscmp((WCHAR *)info->Data, bar), "got unexpected key value\n");
+            ExFreePool(info);
+        }
+
+        status = ZwClose(hkey);
+        ok(status == STATUS_SUCCESS, "ZwClose failed: %#lx\n", status);
+    }
+}
+
 static NTSTATUS fdo_ioctl(IRP *irp, IO_STACK_LOCATION *stack, ULONG code)
 {
     switch (code)
@@ -909,6 +1001,12 @@ static NTSTATUS pdo_ioctl(DEVICE_OBJECT *device_obj, IRP *irp, IO_STACK_LOCATION
             cancel_remove_device_count = 0;
             return STATUS_SUCCESS;
 
+        case IOCTL_WINETEST_CHILD_MAIN:
+            test_child_device_properties(device_obj);
+            test_child_enumerator_name(device_obj);
+            test_child_device_registry_key(device_obj);
+            return STATUS_SUCCESS;
+
         default:
             ok(0, "Unexpected ioctl %#lx.\n", code);
             return STATUS_NOT_IMPLEMENTED;
diff --git a/dlls/ntoskrnl.exe/tests/ntoskrnl.c b/dlls/ntoskrnl.exe/tests/ntoskrnl.c
index e2cdfabae49..2bfa091f432 100644
--- a/dlls/ntoskrnl.exe/tests/ntoskrnl.c
+++ b/dlls/ntoskrnl.exe/tests/ntoskrnl.c
@@ -1452,6 +1452,7 @@ static void test_pnp_devices(void)
     static const WCHAR expect_container_id_w[] = L"{12345678-1234-1234-1234-123456789123}";
     static const char foobar[] = "foobar";
     static const char foo[] = "foo";
+    static const char bar[] = "bar";
 
     char buffer[200];
     WCHAR buffer_w[200];
@@ -1691,6 +1692,13 @@ static void test_pnp_devices(void)
     ok(!strcmp(iface_detail->DevicePath, "\\\\?\\wine#test#1#{deadbeef-29ef-4538-a5fd-b69573a362c2}"),
             "wrong path %s\n", debugstr_a(iface_detail->DevicePath));
 
+    /* Create a device parameter for testing IoOpenDeviceRegistryKey */
+    key = SetupDiCreateDevRegKeyA(set, &device, DICS_FLAG_GLOBAL, 0, DIREG_DEV, NULL, NULL);
+    ok(key != INVALID_HANDLE_VALUE, "failed to create a hardware parameters key, got error %#lx\n", GetLastError());
+    status = RegSetValueExA(key, foobar, 0, REG_SZ, (const BYTE *)bar, sizeof(bar));
+    ok(status == ERROR_SUCCESS, "failed to save a device parameter, got error %lu\n", status);
+    RegCloseKey(key);
+
     SetupDiDestroyDeviceInfoList(set);
 
     RtlInitUnicodeString(&string, L"\\Device\\winetest_pnp_1");
@@ -1704,6 +1712,9 @@ static void test_pnp_devices(void)
     ok(id == 1, "got id %d\n", id);
     ok(size == sizeof(id), "got size %lu\n", size);
 
+    ret = DeviceIoControl(child, IOCTL_WINETEST_CHILD_MAIN, NULL, 0, NULL, 0, &size, NULL);
+    ok(ret, "got error %lu\n", GetLastError());
+
     CloseHandle(child);
 
     ret = NtOpenFile(&child, SYNCHRONIZE, &attr, &io, 0, 0);
-- 
2.49.0

From ea148382eb9cfff06140fc5b4ae742f18d5345ff Mon Sep 17 00:00:00 2001
From: Alexander Morozov <amorozov@etersoft.ru>
Date: Thu, 24 Apr 2025 02:52:32 +0300
Subject: [PATCH 132/159] ntoskrnl.exe: Fix getting
 DevicePropertyEnumeratorName.

---
 dlls/ntoskrnl.exe/pnp.c              | 3 +--
 dlls/ntoskrnl.exe/tests/driver_pnp.c | 8 ++++----
 2 files changed, 5 insertions(+), 6 deletions(-)

diff --git a/dlls/ntoskrnl.exe/pnp.c b/dlls/ntoskrnl.exe/pnp.c
index 67c9e5dbe05..56117628f8b 100644
--- a/dlls/ntoskrnl.exe/pnp.c
+++ b/dlls/ntoskrnl.exe/pnp.c
@@ -561,14 +561,13 @@ NTSTATUS WINAPI IoGetDeviceProperty( DEVICE_OBJECT *device, DEVICE_REGISTRY_PROP
         {
             WCHAR *id, *ptr;
 
-            status = get_device_id( device, BusQueryInstanceID, &id );
+            status = get_device_id( device, BusQueryDeviceID, &id );
             if (status != STATUS_SUCCESS)
             {
                 ERR("Failed to get instance ID, status %#lx.\n", status);
                 break;
             }
 
-            wcsupr( id );
             ptr = wcschr( id, '\\' );
             if (ptr) *ptr = 0;
 
diff --git a/dlls/ntoskrnl.exe/tests/driver_pnp.c b/dlls/ntoskrnl.exe/tests/driver_pnp.c
index 652fad79458..212d4a1efbd 100644
--- a/dlls/ntoskrnl.exe/tests/driver_pnp.c
+++ b/dlls/ntoskrnl.exe/tests/driver_pnp.c
@@ -741,9 +741,9 @@ static void test_enumerator_name(void)
     memset(buffer, 0, sizeof(buffer));
     status = IoGetDeviceProperty(bus_pdo, DevicePropertyEnumeratorName, sizeof(buffer), buffer, &req_size);
     ok(status == STATUS_SUCCESS, "IoGetDeviceProperty failed: %#lx\n", status);
-    todo_wine ok(req_size == sizeof(root), "unexpected size %lu\n", req_size);
+    ok(req_size == sizeof(root), "unexpected size %lu\n", req_size);
     if (status == STATUS_SUCCESS)
-        todo_wine ok(!wcscmp(root, buffer), "unexpected property value '%ls'\n", buffer);
+        ok(!wcscmp(root, buffer), "unexpected property value '%ls'\n", buffer);
 }
 
 static void test_child_enumerator_name(DEVICE_OBJECT *device)
@@ -757,9 +757,9 @@ static void test_child_enumerator_name(DEVICE_OBJECT *device)
     status = IoGetDeviceProperty(device, DevicePropertyEnumeratorName, sizeof(buffer), buffer, &req_size);
     todo_wine ok(query_id_count == 0, "expected no IRP_MN_QUERY_ID\n");
     ok(status == STATUS_SUCCESS, "IoGetDeviceProperty failed: %#lx\n", status);
-    todo_wine ok(req_size == sizeof(wine), "unexpected size %lu\n", req_size);
+    ok(req_size == sizeof(wine), "unexpected size %lu\n", req_size);
     if (status == STATUS_SUCCESS)
-        todo_wine ok(!wcscmp(wine, buffer), "unexpected property value '%ls'\n", buffer);
+        ok(!wcscmp(wine, buffer), "unexpected property value '%ls'\n", buffer);
 }
 
 static void test_device_registry_key(void)
-- 
2.49.0

From de60924861d8181b8ce663fb5e4059b9df3c83b4 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sun, 22 Jun 2025 12:17:00 -0400
Subject: [PATCH 133/159] Revert "setupapi: Don't use NULL as key value in
 get_device_property()."

This reverts commit 3a090968a7e7e7d2290797e9fd672a9c41a24981.
---
 dlls/setupapi/devinst.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/setupapi/devinst.c b/dlls/setupapi/devinst.c
index 3abd781ed50..f6df1025005 100644
--- a/dlls/setupapi/devinst.c
+++ b/dlls/setupapi/devinst.c
@@ -4983,7 +4983,7 @@ static LSTATUS get_device_property(struct device *device, const DEVPROPKEY *prop
     if (!ls)
     {
         value_size = prop_buff_size;
-        ls = RegQueryValueExW(hkey, L"", NULL, &value_type, prop_buff, &value_size);
+        ls = RegQueryValueExW(hkey, NULL, NULL, &value_type, prop_buff, &value_size);
         RegCloseKey(hkey);
     }
 
-- 
2.49.0

From 7ee5d97d361b09a38541be46839440479451ffdb Mon Sep 17 00:00:00 2001
From: Vibhav Pant <vibhavp@gmail.com>
Date: Wed, 18 Jun 2025 23:32:50 +0530
Subject: [PATCH 134/159] setupapi/tests: Add tests for
 SetupDi{Set,Get}DeviceInterfacePropertyW.

---
 dlls/setupapi/devinst.c       |  20 +++++
 dlls/setupapi/setupapi.spec   |   2 +
 dlls/setupapi/tests/devinst.c | 153 ++++++++++++++++++++++++++++++++++
 include/setupapi.h            |   2 +
 4 files changed, 177 insertions(+)

diff --git a/dlls/setupapi/devinst.c b/dlls/setupapi/devinst.c
index f6df1025005..059fcb93698 100644
--- a/dlls/setupapi/devinst.c
+++ b/dlls/setupapi/devinst.c
@@ -3186,6 +3186,26 @@ BOOL WINAPI SetupDiGetDeviceInterfaceDetailW(HDEVINFO devinfo, SP_DEVICE_INTERFA
     return ret;
 }
 
+BOOL WINAPI SetupDiGetDeviceInterfacePropertyW( HDEVINFO devinfo, SP_DEVICE_INTERFACE_DATA *iface_data,
+                                                const DEVPROPKEY *key, DEVPROPTYPE *type, BYTE *buf, DWORD buf_size,
+                                                DWORD *req_size, DWORD flags )
+{
+    FIXME( "devinfo %p, iface_data %p, key %p, type %p, buf %p, buf_size %lu, req_size %p, flags %#lx: stub!\n",
+           devinfo, iface_data, key, type, buf, buf_size, req_size, flags );
+    SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
+    return FALSE;
+}
+
+BOOL WINAPI SetupDiSetDeviceInterfacePropertyW( HDEVINFO devinfo, SP_DEVICE_INTERFACE_DATA *iface_data,
+                                                const DEVPROPKEY *key, DEVPROPTYPE type, const BYTE *buf,
+                                                DWORD buf_size, DWORD flags )
+{
+    FIXME( "devinfo %p, iface_data %p, key %p, type %#lx, buf %p, buf_size %lu, flags %#lx: stub!\n", devinfo,
+           iface_data, key, type, buf, buf_size, flags );
+    SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
+    return FALSE;
+}
+
 /***********************************************************************
  *		SetupDiGetDeviceRegistryPropertyA (SETUPAPI.@)
  */
diff --git a/dlls/setupapi/setupapi.spec b/dlls/setupapi/setupapi.spec
index 1c93a1f3b9b..23d7df3e219 100644
--- a/dlls/setupapi/setupapi.spec
+++ b/dlls/setupapi/setupapi.spec
@@ -357,6 +357,7 @@
 @ stub SetupDiGetDeviceInterfaceAlias
 @ stdcall SetupDiGetDeviceInterfaceDetailA(long ptr ptr long ptr ptr)
 @ stdcall SetupDiGetDeviceInterfaceDetailW(long ptr ptr long ptr ptr)
+@ stdcall SetupDiGetDeviceInterfacePropertyW(ptr ptr ptr ptr ptr long ptr long)
 @ stdcall SetupDiGetDevicePropertyKeys(ptr ptr ptr long ptr long)
 @ stdcall SetupDiGetDevicePropertyW(ptr ptr ptr ptr ptr long ptr long)
 @ stdcall SetupDiGetDeviceRegistryPropertyA(long ptr long ptr ptr long ptr)
@@ -407,6 +408,7 @@
 @ stdcall SetupDiSetClassInstallParamsW(ptr ptr ptr long)
 @ stdcall SetupDiSetDeviceInstallParamsA(ptr ptr ptr)
 @ stdcall SetupDiSetDeviceInstallParamsW(ptr ptr ptr)
+@ stdcall SetupDiSetDeviceInterfacePropertyW(ptr ptr ptr long ptr long long)
 @ stdcall SetupDiSetDevicePropertyW(ptr ptr ptr long ptr long long)
 @ stdcall SetupDiSetDeviceRegistryPropertyA(ptr ptr long ptr long)
 @ stdcall SetupDiSetDeviceRegistryPropertyW(ptr ptr long ptr long)
diff --git a/dlls/setupapi/tests/devinst.c b/dlls/setupapi/tests/devinst.c
index c5c0114b2b7..65b638b7418 100644
--- a/dlls/setupapi/tests/devinst.c
+++ b/dlls/setupapi/tests/devinst.c
@@ -2726,6 +2726,158 @@ static void test_open_device_interface_key(void)
     ok(ret, "Failed to destroy device list, error %#lx.\n", GetLastError());
 }
 
+static void test_device_interface_properties(void)
+{
+    const WCHAR str[] = L"Wine is not an emulator.";
+    DEVPROPTYPE type = DEVPROP_TYPE_EMPTY;
+    DEVPROP_BOOLEAN boolean = DEVPROP_TRUE;
+    SP_DEVICE_INTERFACE_DATA iface;
+    SP_DEVINFO_DATA device;
+    DWORD err, req;
+    WCHAR buf[50];
+    HDEVINFO set;
+    BOOL ret;
+
+    set = SetupDiCreateDeviceInfoList(&guid, NULL);
+    ok(set != INVALID_HANDLE_VALUE, "Failed to create device list, error %#lx\n", GetLastError());
+
+    device.cbSize = sizeof(device);
+    ret = SetupDiCreateDeviceInfoA(set, "ROOT\\LEGACY_BOGUS\\0000", &guid, NULL, NULL, 0, &device);
+    ok(ret, "Failed to create device, error %#lx.\n", GetLastError());
+
+    iface.cbSize = sizeof(iface);
+    ret = SetupDiCreateDeviceInterfaceA(set, &device, &guid, NULL, 0, &iface);
+    ok(ret, "Failed to create interface, error %#lx.\n", GetLastError());
+
+    ret = SetupDiSetDeviceInterfacePropertyW(NULL, NULL, NULL, DEVPROP_TYPE_STRING, NULL, 0, 0);
+    err = GetLastError();
+    todo_wine ok(!ret && err == ERROR_INVALID_HANDLE, "%lu != %d\n", err, ERROR_INVALID_HANDLE);
+
+    ret = SetupDiSetDeviceInterfacePropertyW(set, NULL, NULL, DEVPROP_TYPE_STRING, NULL, 0, 0);
+    err = GetLastError();
+    todo_wine ok(!ret && err == ERROR_INVALID_PARAMETER, "%lu != %d\n", err, ERROR_INVALID_PARAMETER);
+
+    ret = SetupDiSetDeviceInterfacePropertyW(set, &iface, NULL, DEVPROP_TYPE_STRING, NULL, 0, 0);
+    err = GetLastError();
+    todo_wine ok(!ret && err == ERROR_INVALID_DATA, "%lu != %d\n", err, ERROR_INVALID_DATA);
+
+    ret = SetupDiSetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_FriendlyName, DEVPROP_TYPE_STRING,
+                                             NULL, 0, 0);
+    err = GetLastError();
+    todo_wine ok(!ret && err == ERROR_INVALID_DATA, "%lu != %d\n", err, ERROR_INVALID_DATA);
+
+    ret = SetupDiSetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_FriendlyName, DEVPROP_TYPE_STRING,
+                                             (BYTE *)str, 0, 0);
+    err = GetLastError();
+    todo_wine ok(!ret && err == ERROR_INVALID_DATA, "%lu != %d\n", err, ERROR_INVALID_DATA);
+
+    ret = SetupDiSetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_FriendlyName, DEVPROP_TYPE_STRING,
+                                             NULL, 1, 0);
+    err = GetLastError();
+    todo_wine ok(!ret && err == ERROR_INVALID_USER_BUFFER, "%lu != %d\n", err, ERROR_INVALID_USER_BUFFER);
+
+    ret = SetupDiSetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_FriendlyName, DEVPROP_TYPE_STRING,
+                                             (BYTE *)str, sizeof(str), 1);
+    err = GetLastError();
+    todo_wine ok(!ret && err == ERROR_INVALID_FLAGS, "%lu != %d\n", err, ERROR_INVALID_FLAGS);
+
+    ret = SetupDiGetDeviceInterfacePropertyW(NULL, NULL, NULL, NULL, NULL, 0, NULL, 0);
+    err = GetLastError();
+    todo_wine ok(!ret && err == ERROR_INVALID_HANDLE, "%lu != %d\n", err, ERROR_INVALID_HANDLE);
+
+    ret = SetupDiGetDeviceInterfacePropertyW(set, NULL, NULL, NULL, NULL, 0, NULL, 0);
+    err = GetLastError();
+    todo_wine ok(!ret && err == ERROR_INVALID_PARAMETER, "%lu != %d\n", err, ERROR_INVALID_PARAMETER);
+
+    ret = SetupDiGetDeviceInterfacePropertyW(set, &iface, NULL, NULL, NULL, 0, NULL, 0);
+    err = GetLastError();
+    todo_wine ok(!ret && err == ERROR_INVALID_USER_BUFFER, "%lu != %d\n", err, ERROR_INVALID_USER_BUFFER);
+
+    ret = SetupDiGetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_FriendlyName, NULL, NULL, 0, NULL, 0);
+    err = GetLastError();
+    todo_wine ok(!ret && err == ERROR_INVALID_USER_BUFFER, "%lu != %d\n", err, ERROR_INVALID_USER_BUFFER);
+
+    ret = SetupDiGetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_FriendlyName, &type, NULL, sizeof(buf), &req, 0);
+    err = GetLastError();
+    todo_wine ok(!ret && err == ERROR_INVALID_USER_BUFFER, "%lu != %d\n", err, ERROR_INVALID_USER_BUFFER);
+
+    ret = SetupDiGetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_FriendlyName, &type, (BYTE *)buf, sizeof(buf), NULL, 1);
+    err = GetLastError();
+    todo_wine ok(!ret && err == ERROR_INVALID_FLAGS, "%lu != %d\n", err, ERROR_INVALID_FLAGS);
+
+    ret = SetupDiGetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_FriendlyName, &type, (BYTE *)buf, sizeof(buf), NULL, 0);
+    err = GetLastError();
+    todo_wine ok(!ret && err == ERROR_NOT_FOUND, "%lu != %d\n", err, ERROR_NOT_FOUND);
+
+    ret = SetupDiGetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_FriendlyName, &type, (BYTE *)buf, sizeof(buf), &req, 0);
+    err = GetLastError();
+    todo_wine ok(!ret && err == ERROR_NOT_FOUND, "%lu != %d\n", err, ERROR_NOT_FOUND);
+
+    ret = SetupDiSetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_FriendlyName, DEVPROP_TYPE_STRING,
+                                             (const BYTE *)str, sizeof(str), 0);
+    err = GetLastError();
+    todo_wine ok(ret, "SetupDiSetDeviceInterfacePropertyW failed: %lu\n", err);
+
+    ret = SetupDiGetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_FriendlyName, &type, NULL, 0, &req, 0);
+    err = GetLastError();
+    todo_wine ok(!ret && err == ERROR_INSUFFICIENT_BUFFER, "%lu != %d\n", err, ERROR_INSUFFICIENT_BUFFER);
+    todo_wine ok(type == DEVPROP_TYPE_STRING, "%#lx != %#x\n", type, DEVPROP_TYPE_STRING);
+    todo_wine ok(req == sizeof(str), "%lu != %lu\n", req, (DWORD)sizeof(str));
+
+    buf[0] = '\0';
+    ret = SetupDiGetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_FriendlyName, &type, (BYTE *)buf,
+                                             sizeof(buf), &req, 0);
+    err = GetLastError();
+    todo_wine ok(ret, "SetupDiGetDeviceInterfacePropertyW failed: %lu\n", err);
+    todo_wine ok(!wcscmp(buf, str), "%s != %s\n", debugstr_w(buf), debugstr_w(str));
+
+    ret = SetupDiSetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_FriendlyName, DEVPROP_TYPE_EMPTY,
+                                             NULL, 0, 0);
+    err = GetLastError();
+    todo_wine ok(ret, "SetupDiSetDeviceInterfacePropertyW failed: %lu\n", err);
+
+    /* DEVPKEY_DeviceInterface_Enabled is a "special" key, as it does not seem to be actually stored in the registry. */
+    ret = SetupDiGetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_Enabled, &type, (BYTE *)&boolean,
+                                             sizeof(boolean), &req, 0);
+    err = GetLastError();
+    todo_wine ok(ret, "SetupDiGetDeviceInterfacePropertyW failed: %lu\n", err);
+    todo_wine ok(req == sizeof(boolean), "%lu != %lu\n", req, (DWORD)sizeof(boolean));
+    todo_wine ok(boolean == DEVPROP_FALSE, "%d != %d\n", boolean, DEVPROP_FALSE);
+
+    boolean = DEVPROP_TRUE;
+    /*  DEVPKEY_DeviceInterface_Enabled cannot be toggled for interfaces. */
+    ret = SetupDiSetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_Enabled, DEVPROP_TYPE_BOOLEAN,
+                                             (const BYTE *)&boolean, sizeof(boolean), 0);
+    err = GetLastError();
+    todo_wine ok(!ret && err == ERROR_ACCESS_DENIED, "%lu != %d\n", err, ERROR_ACCESS_DENIED);
+
+    /* Nor can it be set to anything that's not a DEVPROP_TYPE_BOOLEAN. */
+    ret = SetupDiSetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_Enabled, DEVPROP_TYPE_STRING,
+                                             (const BYTE *)str, sizeof(str), 0);
+    err = GetLastError();
+    todo_wine ok(!ret && err == ERROR_INVALID_DATA, "%lu != %d\n", err, ERROR_INVALID_DATA);
+
+    /* It can however, be "set" to to its current value, i.e whether the interface is enabled. This seems to be a no-op. */
+    boolean = DEVPROP_FALSE;
+    ret = SetupDiSetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_Enabled, DEVPROP_TYPE_BOOLEAN,
+                                             (const BYTE *)&boolean, sizeof(boolean), 0);
+    err = GetLastError();
+    todo_wine ok(ret, "SetupDiGetDeviceInterfacePropertyW failed: %lu\n", err);
+
+    boolean = 0xde;
+    ret = SetupDiSetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_Enabled, DEVPROP_TYPE_BOOLEAN,
+                                             (const BYTE *)&boolean, sizeof(boolean), 0);
+    err = GetLastError();
+    todo_wine ok(!ret && err == ERROR_INVALID_DATA, "%lu != %d\n", err, ERROR_INVALID_DATA);
+
+    ret = SetupDiRemoveDeviceInterface(set, &iface);
+    ok(ret, "Failed to remove device interface, error %#lx.\n", GetLastError());
+    ret = SetupDiRemoveDevice(set, &device);
+    ok(ret, "Failed to remove device, error %#lx.\n", GetLastError());
+    ret = SetupDiDestroyDeviceInfoList(set);
+    ok(ret, "Failed to destroy device list, error %#lx.\n", GetLastError());
+}
+
 static void test_device_install_params(void)
 {
     SP_DEVINFO_DATA device = {sizeof(device)};
@@ -4697,6 +4849,7 @@ START_TEST(devinst)
     test_devnode();
     test_device_interface_key();
     test_open_device_interface_key();
+    test_device_interface_properties();
     test_device_install_params();
     test_driver_list();
     test_call_class_installer();
diff --git a/include/setupapi.h b/include/setupapi.h
index 74b5d003453..56a0a7d662d 100644
--- a/include/setupapi.h
+++ b/include/setupapi.h
@@ -1573,6 +1573,7 @@ WINSETUPAPI BOOL     WINAPI SetupDiGetDeviceInterfaceAlias(HDEVINFO, PSP_DEVICE_
 WINSETUPAPI BOOL     WINAPI SetupDiGetDeviceInterfaceDetailA(HDEVINFO, PSP_DEVICE_INTERFACE_DATA, PSP_DEVICE_INTERFACE_DETAIL_DATA_A, DWORD, PDWORD, PSP_DEVINFO_DATA);
 WINSETUPAPI BOOL     WINAPI SetupDiGetDeviceInterfaceDetailW(HDEVINFO, PSP_DEVICE_INTERFACE_DATA, PSP_DEVICE_INTERFACE_DETAIL_DATA_W, DWORD, PDWORD, PSP_DEVINFO_DATA);
 #define                     SetupDiGetDeviceInterfaceDetail WINELIB_NAME_AW(SetupDiGetDeviceInterfaceDetail)
+WINSETUPAPI BOOL     WINAPI SetupDiGetDeviceInterfacePropertyW(HDEVINFO, PSP_DEVICE_INTERFACE_DATA, const DEVPROPKEY *, DEVPROPTYPE *, BYTE *, DWORD, DWORD *, DWORD);
 WINSETUPAPI BOOL WINAPI SetupDiGetDevicePropertyKeys(HDEVINFO, PSP_DEVINFO_DATA, DEVPROPKEY *, DWORD, DWORD *, DWORD);
 WINSETUPAPI BOOL     WINAPI SetupDiGetDevicePropertyW(HDEVINFO, PSP_DEVINFO_DATA, const DEVPROPKEY *, DEVPROPTYPE *, BYTE *, DWORD, DWORD *, DWORD);
 #define                     SetupDiGetDeviceProperty WINELIB_NAME_AW(SetupDiGetDeviceProperty)  /* note: A function doesn't exist */
@@ -1640,6 +1641,7 @@ WINSETUPAPI BOOL     WINAPI SetupDiSetClassRegistryPropertyA(const GUID *, DWORD
 WINSETUPAPI BOOL     WINAPI SetupDiSetClassRegistryPropertyW(const GUID *, DWORD, const BYTE *, DWORD, PCWSTR, PVOID);
 #define                     SetupDiSetClassRegistryProperty WINELIB_NAME_AW(SetupDiSetClassRegistryProperty)
 WINSETUPAPI BOOL     WINAPI SetupDiSetDeviceInterfaceDefault(HDEVINFO, PSP_DEVICE_INTERFACE_DATA, DWORD, PVOID);
+WINSETUPAPI BOOL     WINAPI SetupDiSetDeviceInterfacePropertyW(HDEVINFO, PSP_DEVICE_INTERFACE_DATA, const DEVPROPKEY *, DEVPROPTYPE, const BYTE *, DWORD, DWORD);
 WINSETUPAPI BOOL     WINAPI SetupDiSetDeviceInstallParamsA(HDEVINFO, PSP_DEVINFO_DATA, PSP_DEVINSTALL_PARAMS_A);
 WINSETUPAPI BOOL     WINAPI SetupDiSetDeviceInstallParamsW(HDEVINFO, PSP_DEVINFO_DATA, PSP_DEVINSTALL_PARAMS_W);
 #define                     SetupDiSetDeviceInstallParams WINELIB_NAME_AW(SetupDiSetDeviceInstallParams)
-- 
2.49.0

From c9c4880de6c0ec0d1c389786af1b8091e0149405 Mon Sep 17 00:00:00 2001
From: Vibhav Pant <vibhavp@gmail.com>
Date: Thu, 19 Jun 2025 20:53:20 +0530
Subject: [PATCH 135/159] setupapi: Implement
 SetupDiSetDeviceInterfacePropertyW.

---
 dlls/setupapi/devinst.c       | 142 ++++++++++++++++++++++------------
 dlls/setupapi/tests/devinst.c |  26 +++----
 2 files changed, 107 insertions(+), 61 deletions(-)

diff --git a/dlls/setupapi/devinst.c b/dlls/setupapi/devinst.c
index 059fcb93698..827dcfc6f80 100644
--- a/dlls/setupapi/devinst.c
+++ b/dlls/setupapi/devinst.c
@@ -47,6 +47,8 @@
 
 #include "setupapi_private.h"
 
+#include "initguid.h"
+#include "devpkey.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(setupapi);
 
@@ -3196,14 +3198,99 @@ BOOL WINAPI SetupDiGetDeviceInterfacePropertyW( HDEVINFO devinfo, SP_DEVICE_INTE
     return FALSE;
 }
 
+static DWORD set_device_reg_property( HKEY base_key, const DEVPROPKEY *key, DEVPROPTYPE type, const BYTE *buf,
+                                      DWORD buf_size )
+{
+    HKEY properties, property;
+    WCHAR prop_path[44];
+    LSTATUS ret;
+
+    ret = RegCreateKeyExW( base_key, L"Properties", 0, NULL, 0, KEY_READ | KEY_WRITE, NULL, &properties, NULL );
+    if (ret)
+    {
+        SetLastError( ret );
+        return FALSE;
+    }
+
+    SETUPDI_GuidToString( &key->fmtid, prop_path );
+    swprintf( &prop_path[38], ARRAY_SIZE( prop_path ) - 38, L"\\%04X", key->pid );
+    switch (type)
+    {
+    case DEVPROP_TYPE_EMPTY:
+        ret = RegDeleteKeyW( properties, prop_path );
+        SetLastError( ret == ERROR_FILE_NOT_FOUND ? ERROR_NOT_FOUND : ret );
+        break;
+    case DEVPROP_TYPE_NULL:
+        if (!(ret = RegOpenKeyW( properties, prop_path, &property )))
+        {
+            ret = RegDeleteValueW( property, NULL );
+            RegCloseKey( property );
+        }
+        break;
+    default:
+        if (!(ret = RegCreateKeyExW( properties, prop_path, 0, NULL, 0, KEY_READ | KEY_WRITE, NULL, &property, NULL )))
+        {
+            ret = RegSetValueExW( property, NULL, 0, 0xffff0000 | (0xffff & type), buf, buf_size );
+            RegCloseKey( property );
+        }
+        break;
+    }
+
+    RegCloseKey( properties );
+    return ret == ERROR_FILE_NOT_FOUND ? ERROR_NOT_FOUND : ret;
+}
+
 BOOL WINAPI SetupDiSetDeviceInterfacePropertyW( HDEVINFO devinfo, SP_DEVICE_INTERFACE_DATA *iface_data,
                                                 const DEVPROPKEY *key, DEVPROPTYPE type, const BYTE *buf,
                                                 DWORD buf_size, DWORD flags )
 {
-    FIXME( "devinfo %p, iface_data %p, key %p, type %#lx, buf %p, buf_size %lu, flags %#lx: stub!\n", devinfo,
+    struct device_iface *iface;
+    DWORD ret;
+
+    TRACE( "devinfo %p, iface_data %p, key %p, type %#lx, buf %p, buf_size %lu, flags %#lx\n", devinfo,
            iface_data, key, type, buf, buf_size, flags );
-    SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
-    return FALSE;
+
+    if (!(iface = get_device_iface( devinfo, iface_data )))
+        return FALSE;
+    if (buf_size && !buf)
+    {
+        SetLastError( ERROR_INVALID_USER_BUFFER );
+        return FALSE;
+    }
+    if (!key || !is_valid_property_type(type)
+        || (!(buf && buf_size) && !(type == DEVPROP_TYPE_EMPTY || type == DEVPROP_TYPE_NULL))
+        || (buf && buf_size && (type == DEVPROP_TYPE_EMPTY || type == DEVPROP_TYPE_NULL)))
+    {
+        SetLastError( ERROR_INVALID_DATA );
+        return FALSE;
+    }
+    if (flags)
+    {
+        SetLastError( ERROR_INVALID_FLAGS );
+        return FALSE;
+    }
+
+
+    if (IsEqualDevPropKey( *key, DEVPKEY_DeviceInterface_Enabled ))
+    {
+        DEVPROP_BOOLEAN val = *(DEVPROP_BOOLEAN *)buf;
+
+        if (type != DEVPROP_TYPE_BOOLEAN || buf_size != sizeof( DEVPROP_BOOLEAN )
+            || !(val == DEVPROP_FALSE || val == DEVPROP_TRUE))
+        {
+            SetLastError( ERROR_INVALID_DATA );
+            return FALSE;
+        }
+
+        ret = !!(iface->flags & SPINT_ACTIVE) == !!val ? ERROR_SUCCESS : ERROR_ACCESS_DENIED;
+        /* Setting this to the interface's current status is a no-op, otherwise return ERROR_ACCESS_DENEID. */
+        SetLastError( ret );
+        return !ret;
+    }
+
+    ret = set_device_reg_property( iface->refstr_key, key, type, buf, buf_size );
+    SetLastError( ret );
+    return !ret;
 }
 
 /***********************************************************************
@@ -4139,9 +4226,7 @@ BOOL WINAPI SetupDiSetDevicePropertyW(HDEVINFO devinfo, PSP_DEVINFO_DATA device_
                                       DEVPROPTYPE type, const BYTE *buffer, DWORD size, DWORD flags)
 {
     struct device *device;
-    HKEY properties_hkey, property_hkey;
-    WCHAR property_hkey_path[44];
-    LSTATUS ls;
+    DWORD ret;
 
     TRACE("%p %p %p %#lx %p %ld %#lx\n", devinfo, device_data, key, type, buffer, size, flags);
 
@@ -4168,48 +4253,9 @@ BOOL WINAPI SetupDiSetDevicePropertyW(HDEVINFO devinfo, PSP_DEVINFO_DATA device_
         return FALSE;
     }
 
-    ls = RegCreateKeyExW(device->key, L"Properties", 0, NULL, 0, KEY_READ | KEY_WRITE, NULL, &properties_hkey, NULL);
-    if (ls)
-    {
-        SetLastError(ls);
-        return FALSE;
-    }
-
-    SETUPDI_GuidToString(&key->fmtid, property_hkey_path);
-    swprintf(property_hkey_path + 38, ARRAY_SIZE(property_hkey_path) - 38, L"\\%04X", key->pid);
-
-    if (type == DEVPROP_TYPE_EMPTY)
-    {
-        ls = RegDeleteKeyW(properties_hkey, property_hkey_path);
-        RegCloseKey(properties_hkey);
-        SetLastError(ls == ERROR_FILE_NOT_FOUND ? ERROR_NOT_FOUND : ls);
-        return !ls;
-    }
-    else if (type == DEVPROP_TYPE_NULL)
-    {
-        if (!(ls = RegOpenKeyW(properties_hkey, property_hkey_path, &property_hkey)))
-        {
-            ls = RegDeleteValueW(property_hkey, NULL);
-            RegCloseKey(property_hkey);
-        }
-
-        RegCloseKey(properties_hkey);
-        SetLastError(ls == ERROR_FILE_NOT_FOUND ? ERROR_NOT_FOUND : ls);
-        return !ls;
-    }
-    else
-    {
-        if (!(ls = RegCreateKeyExW(properties_hkey, property_hkey_path, 0, NULL, 0, KEY_READ | KEY_WRITE, NULL,
-                                  &property_hkey, NULL)))
-        {
-            ls = RegSetValueExW(property_hkey, NULL, 0, 0xffff0000 | (0xffff & type), buffer, size);
-            RegCloseKey(property_hkey);
-        }
-
-        RegCloseKey(properties_hkey);
-        SetLastError(ls);
-        return !ls;
-    }
+    ret = set_device_reg_property( device->key, key, type, buffer, size );
+    SetLastError( ret );
+    return !ret;
 }
 
 /***********************************************************************
diff --git a/dlls/setupapi/tests/devinst.c b/dlls/setupapi/tests/devinst.c
index 65b638b7418..fceef41ffea 100644
--- a/dlls/setupapi/tests/devinst.c
+++ b/dlls/setupapi/tests/devinst.c
@@ -2751,35 +2751,35 @@ static void test_device_interface_properties(void)
 
     ret = SetupDiSetDeviceInterfacePropertyW(NULL, NULL, NULL, DEVPROP_TYPE_STRING, NULL, 0, 0);
     err = GetLastError();
-    todo_wine ok(!ret && err == ERROR_INVALID_HANDLE, "%lu != %d\n", err, ERROR_INVALID_HANDLE);
+    ok(!ret && err == ERROR_INVALID_HANDLE, "%lu != %d\n", err, ERROR_INVALID_HANDLE);
 
     ret = SetupDiSetDeviceInterfacePropertyW(set, NULL, NULL, DEVPROP_TYPE_STRING, NULL, 0, 0);
     err = GetLastError();
-    todo_wine ok(!ret && err == ERROR_INVALID_PARAMETER, "%lu != %d\n", err, ERROR_INVALID_PARAMETER);
+    ok(!ret && err == ERROR_INVALID_PARAMETER, "%lu != %d\n", err, ERROR_INVALID_PARAMETER);
 
     ret = SetupDiSetDeviceInterfacePropertyW(set, &iface, NULL, DEVPROP_TYPE_STRING, NULL, 0, 0);
     err = GetLastError();
-    todo_wine ok(!ret && err == ERROR_INVALID_DATA, "%lu != %d\n", err, ERROR_INVALID_DATA);
+    ok(!ret && err == ERROR_INVALID_DATA, "%lu != %d\n", err, ERROR_INVALID_DATA);
 
     ret = SetupDiSetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_FriendlyName, DEVPROP_TYPE_STRING,
                                              NULL, 0, 0);
     err = GetLastError();
-    todo_wine ok(!ret && err == ERROR_INVALID_DATA, "%lu != %d\n", err, ERROR_INVALID_DATA);
+    ok(!ret && err == ERROR_INVALID_DATA, "%lu != %d\n", err, ERROR_INVALID_DATA);
 
     ret = SetupDiSetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_FriendlyName, DEVPROP_TYPE_STRING,
                                              (BYTE *)str, 0, 0);
     err = GetLastError();
-    todo_wine ok(!ret && err == ERROR_INVALID_DATA, "%lu != %d\n", err, ERROR_INVALID_DATA);
+    ok(!ret && err == ERROR_INVALID_DATA, "%lu != %d\n", err, ERROR_INVALID_DATA);
 
     ret = SetupDiSetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_FriendlyName, DEVPROP_TYPE_STRING,
                                              NULL, 1, 0);
     err = GetLastError();
-    todo_wine ok(!ret && err == ERROR_INVALID_USER_BUFFER, "%lu != %d\n", err, ERROR_INVALID_USER_BUFFER);
+    ok(!ret && err == ERROR_INVALID_USER_BUFFER, "%lu != %d\n", err, ERROR_INVALID_USER_BUFFER);
 
     ret = SetupDiSetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_FriendlyName, DEVPROP_TYPE_STRING,
                                              (BYTE *)str, sizeof(str), 1);
     err = GetLastError();
-    todo_wine ok(!ret && err == ERROR_INVALID_FLAGS, "%lu != %d\n", err, ERROR_INVALID_FLAGS);
+    ok(!ret && err == ERROR_INVALID_FLAGS, "%lu != %d\n", err, ERROR_INVALID_FLAGS);
 
     ret = SetupDiGetDeviceInterfacePropertyW(NULL, NULL, NULL, NULL, NULL, 0, NULL, 0);
     err = GetLastError();
@@ -2816,7 +2816,7 @@ static void test_device_interface_properties(void)
     ret = SetupDiSetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_FriendlyName, DEVPROP_TYPE_STRING,
                                              (const BYTE *)str, sizeof(str), 0);
     err = GetLastError();
-    todo_wine ok(ret, "SetupDiSetDeviceInterfacePropertyW failed: %lu\n", err);
+    ok(ret, "SetupDiSetDeviceInterfacePropertyW failed: %lu\n", err);
 
     ret = SetupDiGetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_FriendlyName, &type, NULL, 0, &req, 0);
     err = GetLastError();
@@ -2834,7 +2834,7 @@ static void test_device_interface_properties(void)
     ret = SetupDiSetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_FriendlyName, DEVPROP_TYPE_EMPTY,
                                              NULL, 0, 0);
     err = GetLastError();
-    todo_wine ok(ret, "SetupDiSetDeviceInterfacePropertyW failed: %lu\n", err);
+    ok(ret, "SetupDiSetDeviceInterfacePropertyW failed: %lu\n", err);
 
     /* DEVPKEY_DeviceInterface_Enabled is a "special" key, as it does not seem to be actually stored in the registry. */
     ret = SetupDiGetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_Enabled, &type, (BYTE *)&boolean,
@@ -2849,26 +2849,26 @@ static void test_device_interface_properties(void)
     ret = SetupDiSetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_Enabled, DEVPROP_TYPE_BOOLEAN,
                                              (const BYTE *)&boolean, sizeof(boolean), 0);
     err = GetLastError();
-    todo_wine ok(!ret && err == ERROR_ACCESS_DENIED, "%lu != %d\n", err, ERROR_ACCESS_DENIED);
+    ok(!ret && err == ERROR_ACCESS_DENIED, "%lu != %d\n", err, ERROR_ACCESS_DENIED);
 
     /* Nor can it be set to anything that's not a DEVPROP_TYPE_BOOLEAN. */
     ret = SetupDiSetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_Enabled, DEVPROP_TYPE_STRING,
                                              (const BYTE *)str, sizeof(str), 0);
     err = GetLastError();
-    todo_wine ok(!ret && err == ERROR_INVALID_DATA, "%lu != %d\n", err, ERROR_INVALID_DATA);
+    ok(!ret && err == ERROR_INVALID_DATA, "%lu != %d\n", err, ERROR_INVALID_DATA);
 
     /* It can however, be "set" to to its current value, i.e whether the interface is enabled. This seems to be a no-op. */
     boolean = DEVPROP_FALSE;
     ret = SetupDiSetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_Enabled, DEVPROP_TYPE_BOOLEAN,
                                              (const BYTE *)&boolean, sizeof(boolean), 0);
     err = GetLastError();
-    todo_wine ok(ret, "SetupDiGetDeviceInterfacePropertyW failed: %lu\n", err);
+    ok(ret, "SetupDiGetDeviceInterfacePropertyW failed: %lu\n", err);
 
     boolean = 0xde;
     ret = SetupDiSetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_Enabled, DEVPROP_TYPE_BOOLEAN,
                                              (const BYTE *)&boolean, sizeof(boolean), 0);
     err = GetLastError();
-    todo_wine ok(!ret && err == ERROR_INVALID_DATA, "%lu != %d\n", err, ERROR_INVALID_DATA);
+    ok(!ret && err == ERROR_INVALID_DATA, "%lu != %d\n", err, ERROR_INVALID_DATA);
 
     ret = SetupDiRemoveDeviceInterface(set, &iface);
     ok(ret, "Failed to remove device interface, error %#lx.\n", GetLastError());
-- 
2.49.0

From e32796fb1d1e923d21140d1333cab318b114d52e Mon Sep 17 00:00:00 2001
From: Vibhav Pant <vibhavp@gmail.com>
Date: Thu, 19 Jun 2025 21:47:23 +0530
Subject: [PATCH 136/159] setupapi: Implement
 SetupDiGetDeviceInterfacePropertyW.

---
 dlls/setupapi/devinst.c       | 148 ++++++++++++++++++++--------------
 dlls/setupapi/tests/devinst.c |  32 ++++----
 2 files changed, 105 insertions(+), 75 deletions(-)

diff --git a/dlls/setupapi/devinst.c b/dlls/setupapi/devinst.c
index 827dcfc6f80..222d7ca0452 100644
--- a/dlls/setupapi/devinst.c
+++ b/dlls/setupapi/devinst.c
@@ -3188,14 +3188,98 @@ BOOL WINAPI SetupDiGetDeviceInterfaceDetailW(HDEVINFO devinfo, SP_DEVICE_INTERFA
     return ret;
 }
 
+static DWORD get_device_reg_property( HKEY base_key, const DEVPROPKEY *prop_key, DEVPROPTYPE *prop_type,
+                                      BYTE *buf, DWORD buf_size, DWORD *req_size, DWORD flags )
+{
+    WCHAR prop_path[55] = L"Properties\\";
+    HKEY property;
+    DWORD size = 0, val_type;
+    LSTATUS ret;
+
+    if (!prop_key)
+        return ERROR_INVALID_DATA;
+    if (!prop_type || (!buf && buf_size))
+        return ERROR_INVALID_USER_BUFFER;
+    if (flags)
+        return ERROR_INVALID_FLAGS;
+
+    SETUPDI_GuidToString( &prop_key->fmtid, prop_path + 11 );
+    swprintf( prop_path + 49, ARRAY_SIZE( prop_path ) - 49, L"\\%04X", prop_key->pid );
+    if (!(ret = RegOpenKeyExW( base_key, prop_path, 0, KEY_QUERY_VALUE, &property )))
+    {
+        size = buf_size;
+        ret = RegQueryValueExW( property, NULL, NULL, &val_type, buf, &size );
+        RegCloseKey( property );
+    }
+
+    switch (ret)
+    {
+    case ERROR_SUCCESS:
+    case ERROR_MORE_DATA:
+        *prop_type = val_type & 0xffff;
+        ret = (ret == ERROR_MORE_DATA || !buf) ? ERROR_INSUFFICIENT_BUFFER : ERROR_SUCCESS;
+        break;
+    case ERROR_FILE_NOT_FOUND:
+        *prop_type = DEVPROP_TYPE_EMPTY;
+        size = 0;
+        ret = ERROR_NOT_FOUND;
+        break;
+    default:
+        *prop_type = DEVPROP_TYPE_EMPTY;
+        size = 0;
+        FIXME( "Unhandled error: %lu\n", ret );
+        break;
+    }
+
+    if (req_size)
+        *req_size = size;
+    return ret;
+}
+
 BOOL WINAPI SetupDiGetDeviceInterfacePropertyW( HDEVINFO devinfo, SP_DEVICE_INTERFACE_DATA *iface_data,
                                                 const DEVPROPKEY *key, DEVPROPTYPE *type, BYTE *buf, DWORD buf_size,
                                                 DWORD *req_size, DWORD flags )
 {
-    FIXME( "devinfo %p, iface_data %p, key %p, type %p, buf %p, buf_size %lu, req_size %p, flags %#lx: stub!\n",
+    struct device_iface *iface;
+    LSTATUS ret;
+
+    TRACE( "devinfo %p, iface_data %p, key %p, type %p, buf %p, buf_size %lu, req_size %p, flags %#lx\n",
            devinfo, iface_data, key, type, buf, buf_size, req_size, flags );
-    SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
-    return FALSE;
+
+    if (!(iface = get_device_iface( devinfo, iface_data )))
+        return FALSE;
+    if (!type || (!buf && buf_size))
+    {
+        SetLastError( ERROR_INVALID_USER_BUFFER );
+        return FALSE;
+    }
+    if (!key)
+    {
+        SetLastError( ERROR_INVALID_DATA );
+        return FALSE;
+    }
+    if (flags)
+    {
+        SetLastError( ERROR_INVALID_FLAGS );
+        return FALSE;
+    }
+
+    if (IsEqualDevPropKey( *key, DEVPKEY_DeviceInterface_Enabled ))
+    {
+        *type = DEVPROP_TYPE_BOOLEAN;
+        ret = ERROR_SUCCESS;
+        if (buf_size >= sizeof( DEVPROP_BOOLEAN ))
+            *buf = (iface->flags & SPINT_ACTIVE) ? DEVPROP_TRUE : DEVPROP_FALSE;
+        else
+            ret = ERROR_INSUFFICIENT_BUFFER;
+        if (req_size)
+            *req_size = sizeof( DEVPROP_BOOLEAN );
+    }
+    else
+        ret = get_device_reg_property( iface->refstr_key, key, type, buf, buf_size, req_size, flags );
+
+    SetLastError( ret );
+    return !ret;
 }
 
 static DWORD set_device_reg_property( HKEY base_key, const DEVPROPKEY *key, DEVPROPTYPE type, const BYTE *buf,
@@ -5024,60 +5108,6 @@ out:
     return retval;
 }
 
-static LSTATUS get_device_property(struct device *device, const DEVPROPKEY *prop_key, DEVPROPTYPE *prop_type,
-                BYTE *prop_buff, DWORD prop_buff_size, DWORD *required_size, DWORD flags)
-{
-    WCHAR key_path[55] = L"Properties\\";
-    HKEY hkey;
-    DWORD value_type;
-    DWORD value_size = 0;
-    LSTATUS ls;
-
-    if (!prop_key)
-        return ERROR_INVALID_DATA;
-
-    if (!prop_type || (!prop_buff && prop_buff_size))
-        return ERROR_INVALID_USER_BUFFER;
-
-    if (flags)
-        return ERROR_INVALID_FLAGS;
-
-    SETUPDI_GuidToString(&prop_key->fmtid, key_path + 11);
-    swprintf(key_path + 49, ARRAY_SIZE(key_path) - 49, L"\\%04X", prop_key->pid);
-
-    ls = RegOpenKeyExW(device->key, key_path, 0, KEY_QUERY_VALUE, &hkey);
-    if (!ls)
-    {
-        value_size = prop_buff_size;
-        ls = RegQueryValueExW(hkey, NULL, NULL, &value_type, prop_buff, &value_size);
-        RegCloseKey(hkey);
-    }
-
-    switch (ls)
-    {
-    case NO_ERROR:
-    case ERROR_MORE_DATA:
-        *prop_type = 0xffff & value_type;
-        ls = (ls == ERROR_MORE_DATA || !prop_buff) ? ERROR_INSUFFICIENT_BUFFER : NO_ERROR;
-        break;
-    case ERROR_FILE_NOT_FOUND:
-        *prop_type = DEVPROP_TYPE_EMPTY;
-        value_size = 0;
-        ls = ERROR_NOT_FOUND;
-        break;
-    default:
-        *prop_type = DEVPROP_TYPE_EMPTY;
-        value_size = 0;
-        FIXME("Unhandled error %#lx\n", ls);
-        break;
-    }
-
-    if (required_size)
-        *required_size = value_size;
-
-    return ls;
-}
-
 BOOL WINAPI SetupDiGetDevicePropertyKeys( HDEVINFO devinfo, PSP_DEVINFO_DATA device_data,
                                           DEVPROPKEY *prop_keys, DWORD prop_keys_len,
                                           DWORD *required_prop_keys, DWORD flags )
@@ -5208,7 +5238,7 @@ BOOL WINAPI SetupDiGetDevicePropertyW(HDEVINFO devinfo, PSP_DEVINFO_DATA device_
     if (!(device = get_device(devinfo, device_data)))
         return FALSE;
 
-    ls = get_device_property(device, prop_key, prop_type, prop_buff, prop_buff_size, required_size, flags);
+    ls = get_device_reg_property(device->key, prop_key, prop_type, prop_buff, prop_buff_size, required_size, flags);
 
     SetLastError(ls);
     return !ls;
@@ -5236,7 +5266,7 @@ CONFIGRET WINAPI CM_Get_DevNode_Property_ExW(DEVINST devnode, const DEVPROPKEY *
     if (!(device = get_devnode_device(devnode, &set)))
         return CR_NO_SUCH_DEVINST;
 
-    ls = get_device_property(device, prop_key, prop_type, prop_buff, *prop_buff_size, prop_buff_size, flags);
+    ls = get_device_reg_property(device->key, prop_key, prop_type, prop_buff, *prop_buff_size, prop_buff_size, flags);
     SetupDiDestroyDeviceInfoList(set);
     switch (ls)
     {
diff --git a/dlls/setupapi/tests/devinst.c b/dlls/setupapi/tests/devinst.c
index fceef41ffea..1add6555154 100644
--- a/dlls/setupapi/tests/devinst.c
+++ b/dlls/setupapi/tests/devinst.c
@@ -2783,35 +2783,35 @@ static void test_device_interface_properties(void)
 
     ret = SetupDiGetDeviceInterfacePropertyW(NULL, NULL, NULL, NULL, NULL, 0, NULL, 0);
     err = GetLastError();
-    todo_wine ok(!ret && err == ERROR_INVALID_HANDLE, "%lu != %d\n", err, ERROR_INVALID_HANDLE);
+    ok(!ret && err == ERROR_INVALID_HANDLE, "%lu != %d\n", err, ERROR_INVALID_HANDLE);
 
     ret = SetupDiGetDeviceInterfacePropertyW(set, NULL, NULL, NULL, NULL, 0, NULL, 0);
     err = GetLastError();
-    todo_wine ok(!ret && err == ERROR_INVALID_PARAMETER, "%lu != %d\n", err, ERROR_INVALID_PARAMETER);
+    ok(!ret && err == ERROR_INVALID_PARAMETER, "%lu != %d\n", err, ERROR_INVALID_PARAMETER);
 
     ret = SetupDiGetDeviceInterfacePropertyW(set, &iface, NULL, NULL, NULL, 0, NULL, 0);
     err = GetLastError();
-    todo_wine ok(!ret && err == ERROR_INVALID_USER_BUFFER, "%lu != %d\n", err, ERROR_INVALID_USER_BUFFER);
+    ok(!ret && err == ERROR_INVALID_USER_BUFFER, "%lu != %d\n", err, ERROR_INVALID_USER_BUFFER);
 
     ret = SetupDiGetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_FriendlyName, NULL, NULL, 0, NULL, 0);
     err = GetLastError();
-    todo_wine ok(!ret && err == ERROR_INVALID_USER_BUFFER, "%lu != %d\n", err, ERROR_INVALID_USER_BUFFER);
+    ok(!ret && err == ERROR_INVALID_USER_BUFFER, "%lu != %d\n", err, ERROR_INVALID_USER_BUFFER);
 
     ret = SetupDiGetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_FriendlyName, &type, NULL, sizeof(buf), &req, 0);
     err = GetLastError();
-    todo_wine ok(!ret && err == ERROR_INVALID_USER_BUFFER, "%lu != %d\n", err, ERROR_INVALID_USER_BUFFER);
+    ok(!ret && err == ERROR_INVALID_USER_BUFFER, "%lu != %d\n", err, ERROR_INVALID_USER_BUFFER);
 
     ret = SetupDiGetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_FriendlyName, &type, (BYTE *)buf, sizeof(buf), NULL, 1);
     err = GetLastError();
-    todo_wine ok(!ret && err == ERROR_INVALID_FLAGS, "%lu != %d\n", err, ERROR_INVALID_FLAGS);
+    ok(!ret && err == ERROR_INVALID_FLAGS, "%lu != %d\n", err, ERROR_INVALID_FLAGS);
 
     ret = SetupDiGetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_FriendlyName, &type, (BYTE *)buf, sizeof(buf), NULL, 0);
     err = GetLastError();
-    todo_wine ok(!ret && err == ERROR_NOT_FOUND, "%lu != %d\n", err, ERROR_NOT_FOUND);
+    ok(!ret && err == ERROR_NOT_FOUND, "%lu != %d\n", err, ERROR_NOT_FOUND);
 
     ret = SetupDiGetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_FriendlyName, &type, (BYTE *)buf, sizeof(buf), &req, 0);
     err = GetLastError();
-    todo_wine ok(!ret && err == ERROR_NOT_FOUND, "%lu != %d\n", err, ERROR_NOT_FOUND);
+    ok(!ret && err == ERROR_NOT_FOUND, "%lu != %d\n", err, ERROR_NOT_FOUND);
 
     ret = SetupDiSetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_FriendlyName, DEVPROP_TYPE_STRING,
                                              (const BYTE *)str, sizeof(str), 0);
@@ -2820,16 +2820,16 @@ static void test_device_interface_properties(void)
 
     ret = SetupDiGetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_FriendlyName, &type, NULL, 0, &req, 0);
     err = GetLastError();
-    todo_wine ok(!ret && err == ERROR_INSUFFICIENT_BUFFER, "%lu != %d\n", err, ERROR_INSUFFICIENT_BUFFER);
-    todo_wine ok(type == DEVPROP_TYPE_STRING, "%#lx != %#x\n", type, DEVPROP_TYPE_STRING);
-    todo_wine ok(req == sizeof(str), "%lu != %lu\n", req, (DWORD)sizeof(str));
+    ok(!ret && err == ERROR_INSUFFICIENT_BUFFER, "%lu != %d\n", err, ERROR_INSUFFICIENT_BUFFER);
+    ok(type == DEVPROP_TYPE_STRING, "%#lx != %#x\n", type, DEVPROP_TYPE_STRING);
+    ok(req == sizeof(str), "%lu != %lu\n", req, (DWORD)sizeof(str));
 
     buf[0] = '\0';
     ret = SetupDiGetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_FriendlyName, &type, (BYTE *)buf,
                                              sizeof(buf), &req, 0);
     err = GetLastError();
-    todo_wine ok(ret, "SetupDiGetDeviceInterfacePropertyW failed: %lu\n", err);
-    todo_wine ok(!wcscmp(buf, str), "%s != %s\n", debugstr_w(buf), debugstr_w(str));
+    ok(ret, "SetupDiGetDeviceInterfacePropertyW failed: %lu\n", err);
+    ok(!wcscmp(buf, str), "%s != %s\n", debugstr_w(buf), debugstr_w(str));
 
     ret = SetupDiSetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_FriendlyName, DEVPROP_TYPE_EMPTY,
                                              NULL, 0, 0);
@@ -2840,9 +2840,9 @@ static void test_device_interface_properties(void)
     ret = SetupDiGetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_Enabled, &type, (BYTE *)&boolean,
                                              sizeof(boolean), &req, 0);
     err = GetLastError();
-    todo_wine ok(ret, "SetupDiGetDeviceInterfacePropertyW failed: %lu\n", err);
-    todo_wine ok(req == sizeof(boolean), "%lu != %lu\n", req, (DWORD)sizeof(boolean));
-    todo_wine ok(boolean == DEVPROP_FALSE, "%d != %d\n", boolean, DEVPROP_FALSE);
+    ok(ret, "SetupDiGetDeviceInterfacePropertyW failed: %lu\n", err);
+    ok(req == sizeof(boolean), "%lu != %lu\n", req, (DWORD)sizeof(boolean));
+    ok(boolean == DEVPROP_FALSE, "%d != %d\n", boolean, DEVPROP_FALSE);
 
     boolean = DEVPROP_TRUE;
     /*  DEVPKEY_DeviceInterface_Enabled cannot be toggled for interfaces. */
-- 
2.49.0

From ff58011cdbb487f906ba25bd3bb8bcd9d57b1dc9 Mon Sep 17 00:00:00 2001
From: Vibhav Pant <vibhavp@gmail.com>
Date: Fri, 20 Jun 2025 19:54:53 +0530
Subject: [PATCH 137/159] ntoskrnl.exe/test: Add tests for
 SetupDiGetDeviceInterfacePropertyW with enabled interfaces.

---
 dlls/ntoskrnl.exe/tests/ntoskrnl.c | 22 +++++++++++++++++++++-
 1 file changed, 21 insertions(+), 1 deletion(-)

diff --git a/dlls/ntoskrnl.exe/tests/ntoskrnl.c b/dlls/ntoskrnl.exe/tests/ntoskrnl.c
index 2bfa091f432..e9cda54da47 100644
--- a/dlls/ntoskrnl.exe/tests/ntoskrnl.c
+++ b/dlls/ntoskrnl.exe/tests/ntoskrnl.c
@@ -40,6 +40,7 @@
 #include "dbt.h"
 #include "initguid.h"
 #include "devguid.h"
+#include "devpkey.h"
 #include "ddk/hidclass.h"
 #include "ddk/hidsdi.h"
 #include "ddk/hidpi.h"
@@ -1459,6 +1460,8 @@ static void test_pnp_devices(void)
     SP_DEVICE_INTERFACE_DETAIL_DATA_A *iface_detail = (void *)buffer;
     SP_DEVICE_INTERFACE_DATA iface = {sizeof(iface)};
     SP_DEVINFO_DATA device = {sizeof(device)};
+    DEVPROP_BOOLEAN enabled = DEVPROP_FALSE;
+    DEVPROPTYPE prop_type = DEVPROP_TYPE_EMPTY;
     DEV_BROADCAST_DEVICEINTERFACE_A filter =
     {
         .dbcc_size = sizeof(filter),
@@ -1470,7 +1473,7 @@ static void test_pnp_devices(void)
         .lpfnWndProc = device_notify_proc,
     };
     HDEVNOTIFY notify_handle;
-    DWORD size, type, dword;
+    DWORD size = 0, type, dword;
     HANDLE bus, child, tmp;
     OBJECT_ATTRIBUTES attr;
     UNICODE_STRING string;
@@ -1513,6 +1516,13 @@ static void test_pnp_devices(void)
     ok(!strcmp(iface_detail->DevicePath, "\\\\?\\root#winetest#0#{deadbeef-29ef-4538-a5fd-b69573a362c0}"),
             "wrong path %s\n", debugstr_a(iface_detail->DevicePath));
 
+    ret = SetupDiGetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_Enabled, &prop_type,
+                                             (BYTE *)&enabled, sizeof(enabled), &size, 0);
+    ok(ret, "failed to get device interface property, got error %lu\n", GetLastError());
+    ok(prop_type == DEVPROP_TYPE_BOOLEAN, "got prop_type %#lx\n", prop_type);
+    ok(size == sizeof(enabled), "got size %lu\n", size);
+    ok(enabled == DEVPROP_TRUE, "got enabled %d\n", enabled);
+
     /* Create a device parameter for testing IoOpenDeviceRegistryKey */
     key = SetupDiCreateDevRegKeyA(set, &device, DICS_FLAG_GLOBAL, 0, DIREG_DEV, NULL, NULL);
     ok(key != INVALID_HANDLE_VALUE, "failed to create a hardware parameters key, got error %#lx\n", GetLastError());
@@ -1692,6 +1702,16 @@ static void test_pnp_devices(void)
     ok(!strcmp(iface_detail->DevicePath, "\\\\?\\wine#test#1#{deadbeef-29ef-4538-a5fd-b69573a362c2}"),
             "wrong path %s\n", debugstr_a(iface_detail->DevicePath));
 
+    prop_type = DEVPROP_TYPE_EMPTY;
+    size = 0;
+    enabled = DEVPROP_FALSE;
+    ret = SetupDiGetDeviceInterfacePropertyW(set, &iface, &DEVPKEY_DeviceInterface_Enabled, &prop_type,
+                                             (BYTE *)&enabled, sizeof(enabled), &size, 0);
+    ok(ret, "failed to get device interface property, got error %lu\n", GetLastError());
+    ok(prop_type == DEVPROP_TYPE_BOOLEAN, "got prop_type %#lx\n", prop_type);
+    ok(size == sizeof(enabled), "got size %lu\n", size);
+    ok(enabled == DEVPROP_TRUE, "got enabled %d\n", enabled);
+
     /* Create a device parameter for testing IoOpenDeviceRegistryKey */
     key = SetupDiCreateDevRegKeyA(set, &device, DICS_FLAG_GLOBAL, 0, DIREG_DEV, NULL, NULL);
     ok(key != INVALID_HANDLE_VALUE, "failed to create a hardware parameters key, got error %#lx\n", GetLastError());
-- 
2.49.0

From 98773eb162a8d9f8acbffee93f174d5297d1de7b Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Sun, 22 Jun 2025 12:18:31 -0400
Subject: [PATCH 138/159] setupapi: Don't use NULL as key value in
 get_device_reg_property().

---
 dlls/setupapi/devinst.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/setupapi/devinst.c b/dlls/setupapi/devinst.c
index 222d7ca0452..9065ea5cfde 100644
--- a/dlls/setupapi/devinst.c
+++ b/dlls/setupapi/devinst.c
@@ -3208,7 +3208,7 @@ static DWORD get_device_reg_property( HKEY base_key, const DEVPROPKEY *prop_key,
     if (!(ret = RegOpenKeyExW( base_key, prop_path, 0, KEY_QUERY_VALUE, &property )))
     {
         size = buf_size;
-        ret = RegQueryValueExW( property, NULL, NULL, &val_type, buf, &size );
+        ret = RegQueryValueExW( property, L"", NULL, &val_type, buf, &size );
         RegCloseKey( property );
     }
 
-- 
2.49.0

From 7335d86ef870a18e799bd332685d8a2237bed430 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sun, 22 Jun 2025 12:35:14 -0400
Subject: [PATCH 139/159] setupapi: Implement DEVPKEY_Device_InstanceId in
 SetupDiGetDeviceInterfacePropertyW.

Based on patch by ClearlyClaire
---
 dlls/setupapi/devinst.c | 25 +++++++++++++++++++++++--
 1 file changed, 23 insertions(+), 2 deletions(-)

diff --git a/dlls/setupapi/devinst.c b/dlls/setupapi/devinst.c
index 9065ea5cfde..605c5d14591 100644
--- a/dlls/setupapi/devinst.c
+++ b/dlls/setupapi/devinst.c
@@ -3274,8 +3274,29 @@ BOOL WINAPI SetupDiGetDeviceInterfacePropertyW( HDEVINFO devinfo, SP_DEVICE_INTE
             ret = ERROR_INSUFFICIENT_BUFFER;
         if (req_size)
             *req_size = sizeof( DEVPROP_BOOLEAN );
-    }
-    else
+    } else if (IsEqualDevPropKey( *key, DEVPKEY_Device_InstanceId )) {
+        struct device *device;
+
+        ret = ERROR_SUCCESS;
+
+        if ((device = iface->device))
+        {
+            DWORD len = wcslen(device->instanceId) + 1;
+            len *= sizeof(WCHAR); /* it is in units of bytes */
+
+            if (req_size) *req_size = len;
+
+            if (buf_size >= len)
+            {
+                wcscpy((WCHAR *)buf, device->instanceId);
+                *type = DEVPROP_TYPE_STRING;
+            }
+            else
+                ret = ERROR_INSUFFICIENT_BUFFER;
+        }
+        else
+            ret = ERROR_INVALID_PARAMETER;
+    } else
         ret = get_device_reg_property( iface->refstr_key, key, type, buf, buf_size, req_size, flags );
 
     SetLastError( ret );
-- 
2.49.0

From 8010ff432e6e7970685fee9484fcce77762db559 Mon Sep 17 00:00:00 2001
From: NelloKudo <marshnelloosu@gmail.com>
Date: Wed, 18 Jun 2025 19:23:02 +0200
Subject: [PATCH 140/159] ntdll: Also trap syscalls in the top-down reserved
 area

Backport of wine-staging patch from "mkrsym1@gmail.com".
https://github.com/wine-staging/wine-staging/commit/d88d44f1d9d94cb11aff9e2f0ce37d0d67fe1e95
---
 dlls/ntdll/unix/signal_x86_64.c | 16 ++++++++++++----
 1 file changed, 12 insertions(+), 4 deletions(-)

diff --git a/dlls/ntdll/unix/signal_x86_64.c b/dlls/ntdll/unix/signal_x86_64.c
index 473c4b994ad..659178038f0 100644
--- a/dlls/ntdll/unix/signal_x86_64.c
+++ b/dlls/ntdll/unix/signal_x86_64.c
@@ -1982,14 +1982,22 @@ static void install_bpf(struct sigaction *sig_act)
 
     static struct sock_filter filter[] =
     {
-        BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, instruction_pointer) + 4),
-        /* Native libs are loaded at high addresses. */
-        BPF_JUMP(BPF_JMP | BPF_JGT | BPF_K, NATIVE_SYSCALL_ADDRESS_START >> 32, 0, 1),
-        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),
         /* Allow i386. */
         BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, arch)),
         BPF_JUMP (BPF_JMP | BPF_JEQ | BPF_K, AUDIT_ARCH_X86_64, 1, 0),
         BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),
+        /* Native libs are loaded at high addresses. */
+        BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, instruction_pointer) + 4),
+        BPF_JUMP(BPF_JMP | BPF_JGT | BPF_K, NATIVE_SYSCALL_ADDRESS_START >> 32, 0, 8),
+        /* High addresses may be top-down allocations, trap those */
+        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 0x7fff, 1, 0),
+        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),
+        BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, instruction_pointer)),
+        BPF_JUMP(BPF_JMP | BPF_JGE | BPF_K, 0xfe000000, 1, 0),
+        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),
+        BPF_JUMP(BPF_JMP | BPF_JGE | BPF_K, 0xffff0000, 0, 1),
+        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),
+        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_TRAP),
         /* Allow wine64-preloader */
         BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, instruction_pointer)),
         BPF_JUMP(BPF_JMP | BPF_JGE | BPF_K, 0x7d400000, 1, 0),
-- 
2.49.0

From 3267f87805d52106f3dd073253d4f6ea6fcd97be Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Mon, 19 May 2025 20:33:06 -0400
Subject: [PATCH 141/159] winebus: Fix PROTON_ENABLE/DISABLE_HIDRAW.

---
 dlls/winebus.sys/main.c    | 43 ++++++++------------------------------
 dlls/winebus.sys/unixlib.c | 22 +++++++++++++++++++
 dlls/winebus.sys/unixlib.h |  9 ++++++++
 3 files changed, 40 insertions(+), 34 deletions(-)

diff --git a/dlls/winebus.sys/main.c b/dlls/winebus.sys/main.c
index 2aa5727a2f1..df3e2663abc 100644
--- a/dlls/winebus.sys/main.c
+++ b/dlls/winebus.sys/main.c
@@ -435,36 +435,26 @@ static DWORD check_bus_option(const WCHAR *option, DWORD default_value)
     return default_value;
 }
 
-static const WCHAR *wcscasestr(const WCHAR *search, const WCHAR *needle)
-{
-    UNICODE_STRING search_str, needle_str;
-
-    RtlInitUnicodeString(&search_str, search);
-    RtlInitUnicodeString(&needle_str, needle);
-
-    while (needle_str.Length <= search_str.Length)
-    {
-        if (!RtlCompareUnicodeString(&search_str, &needle_str, TRUE)) return search_str.Buffer;
-        search_str.Length -= sizeof(WCHAR);
-        search_str.Buffer += 1;
-    }
-
-    return NULL;
-}
-
 static BOOL is_hidraw_enabled(WORD vid, WORD pid, const USAGE_AND_PAGE *usages, UINT buttons)
 {
     char buffer[FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data[1024])];
     KEY_VALUE_PARTIAL_INFORMATION *info = (KEY_VALUE_PARTIAL_INFORMATION *)buffer;
+    struct hidraw_enabled_params params = {0};
     struct device_options *device;
-    WCHAR vidpid[MAX_PATH], *tmp, value[1024];
+    WCHAR vidpid[MAX_PATH], *tmp;
     BOOL prefer_hidraw = FALSE;
     UNICODE_STRING str;
-    SIZE_T len;
     DWORD size;
 
     if (options.disable_hidraw) return FALSE;
 
+    params.vid = vid;
+    params.pid = pid;
+    if (!winebus_call(hidraw_enabled, &params) && params.env_set)
+    {
+        return params.enabled;
+    }
+
     LIST_FOR_EACH_ENTRY(device, &options.devices, struct device_options, entry)
     {
         if (device->vid != vid) continue;
@@ -473,21 +463,6 @@ static BOOL is_hidraw_enabled(WORD vid, WORD pid, const USAGE_AND_PAGE *usages,
         return !!device->hidraw;
     }
 
-    if (!RtlQueryEnvironmentVariable(NULL, L"PROTON_DISABLE_HIDRAW", 20, value, ARRAY_SIZE(value) - 1, &len))
-    {
-        value[len] = 0;
-        if (!wcscmp(value, L"1")) return FALSE;
-        swprintf(vidpid, ARRAY_SIZE(vidpid), L"0x%04X/0x%04X", vid, pid);
-        if (wcscasestr(value, vidpid)) return FALSE;
-    }
-    if (!RtlQueryEnvironmentVariable(NULL, L"PROTON_ENABLE_HIDRAW", 20, value, ARRAY_SIZE(value) - 1, &len))
-    {
-        value[len] = 0;
-        if (!wcscmp(value, L"1")) return TRUE;
-        swprintf(vidpid, ARRAY_SIZE(vidpid), L"0x%04X/0x%04X", vid, pid);
-        if (wcscasestr(value, vidpid)) return TRUE;
-    }
-
     if (usages->UsagePage == HID_USAGE_PAGE_DIGITIZER)
     {
         WARN("Ignoring unsupported %04X:%04X hidraw touchscreen\n", vid, pid);
diff --git a/dlls/winebus.sys/unixlib.c b/dlls/winebus.sys/unixlib.c
index bd4351f059c..da5d4502f45 100644
--- a/dlls/winebus.sys/unixlib.c
+++ b/dlls/winebus.sys/unixlib.c
@@ -300,6 +300,27 @@ static NTSTATUS unix_device_set_feature_report(void *args)
     return STATUS_SUCCESS;
 }
 
+static NTSTATUS unix_hidraw_enabled(void *args)
+{
+    char *value;
+    char vidpid[MAX_PATH] = {0};
+    struct hidraw_enabled_params *params = args;
+
+    if ((value = getenv("PROTON_DISABLE_HIDRAW")))
+    {
+        if (!strcmp(value, "1")) { params->enabled = FALSE; params->env_set = TRUE; }
+        snprintf(vidpid, ARRAY_SIZE(vidpid), "0x%04X/0x%04X", params->vid, params->pid);
+        if (strcasestr(value, vidpid)) { params->enabled = FALSE; params->env_set = TRUE; }
+    } else if ((value = getenv("PROTON_ENABLE_HIDRAW")))
+    {
+        if (!strcmp(value, "1")) { params->enabled = TRUE; params->env_set = TRUE; }
+        snprintf(vidpid, ARRAY_SIZE(vidpid), "0x%04X/0x%04X", params->vid, params->pid);
+        if (strcasestr(value, vidpid)) { params->enabled = TRUE; params->env_set = TRUE; }
+    }
+
+    return STATUS_SUCCESS;
+}
+
 const unixlib_entry_t __wine_unix_call_funcs[] =
 {
     sdl_bus_init,
@@ -319,6 +340,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     unix_device_set_output_report,
     unix_device_get_feature_report,
     unix_device_set_feature_report,
+    unix_hidraw_enabled
 };
 
 C_ASSERT(ARRAYSIZE(__wine_unix_call_funcs) == unix_funcs_count);
diff --git a/dlls/winebus.sys/unixlib.h b/dlls/winebus.sys/unixlib.h
index 6974174dda1..64eab2b976a 100644
--- a/dlls/winebus.sys/unixlib.h
+++ b/dlls/winebus.sys/unixlib.h
@@ -131,6 +131,14 @@ struct device_report_params
     IO_STATUS_BLOCK *io;
 };
 
+struct hidraw_enabled_params
+{
+    unsigned short vid;
+    unsigned short pid;
+    BOOL env_set;
+    BOOL enabled;
+};
+
 enum unix_funcs
 {
     sdl_init,
@@ -150,6 +158,7 @@ enum unix_funcs
     device_set_output_report,
     device_get_feature_report,
     device_set_feature_report,
+    hidraw_enabled,
     unix_funcs_count,
 };
 
-- 
2.49.0

From 364b374e86cb093d40140f53e07a1ff77f80e337 Mon Sep 17 00:00:00 2001
From: Harald Sitter <sitter@kde.org>
Date: Sun, 19 Jan 2025 15:05:15 +0100
Subject: [PATCH 142/159] mmdevapi: correctly read and write containerid as
 clsid blob

ContainerId on Windows is a bit special. It actually gets stored in the
registry as a blob of data that starts with the variant type and ends
with the GUID. The bits inbetween have no immediately obvious meaning
and aren't used for the time being.
---
 dlls/mmdevapi/devenum.c | 43 ++++++++++++++++++++++++++++++++---------
 1 file changed, 34 insertions(+), 9 deletions(-)

diff --git a/dlls/mmdevapi/devenum.c b/dlls/mmdevapi/devenum.c
index c32e85ea5e8..b1e7e2e7eaa 100644
--- a/dlls/mmdevapi/devenum.c
+++ b/dlls/mmdevapi/devenum.c
@@ -47,6 +47,13 @@ DEFINE_GUID(GUID_NULL,0,0,0,0,0,0,0,0,0,0,0);
 static HKEY key_render;
 static HKEY key_capture;
 
+struct clsid_blob {
+    BYTE vt;
+    BYTE wReserved0[3]; // Unknown metadata, maybe flags?
+    DWORD wReserved1; // Possibly a version of some sort?
+    GUID puuid;
+};
+
 typedef struct MMDevPropStoreImpl
 {
     IPropertyStore IPropertyStore_iface;
@@ -196,15 +203,28 @@ static HRESULT MMDevice_GetPropValue(const GUID *devguid, DWORD flow, REFPROPERT
             RegGetValueW(regkey, NULL, buffer, RRF_RT_REG_DWORD, NULL, (BYTE*)&pv->ulVal, &size);
             break;
         }
-        case REG_BINARY:
-        {
-            pv->vt = VT_BLOB;
-            pv->blob.cbSize = size;
-            pv->blob.pBlobData = CoTaskMemAlloc(size);
-            if (!pv->blob.pBlobData)
-                hr = E_OUTOFMEMORY;
-            else
-                RegGetValueW(regkey, NULL, buffer, RRF_RT_REG_BINARY, NULL, (BYTE*)pv->blob.pBlobData, &size);
+        case REG_BINARY: {
+            if (IsEqualPropertyKey(*key, DEVPKEY_Device_ContainerId)) {
+                struct clsid_blob blob;
+                DWORD size = sizeof(blob);
+
+                RegGetValueW(regkey, NULL, buffer, RRF_RT_REG_BINARY, NULL, (BYTE *)&blob, &size);
+
+                pv->vt = VT_CLSID;
+                pv->puuid = CoTaskMemAlloc(sizeof(GUID));
+                if (!pv->puuid)
+                    hr = E_OUTOFMEMORY;
+                else
+                    *pv->puuid = blob.puuid;
+            } else {
+                pv->vt = VT_BLOB;
+                pv->blob.cbSize = size;
+                pv->blob.pBlobData = CoTaskMemAlloc(size);
+                if (!pv->blob.pBlobData)
+                    hr = E_OUTOFMEMORY;
+                else
+                    RegGetValueW(regkey, NULL, buffer, RRF_RT_REG_BINARY, NULL, (BYTE *)pv->blob.pBlobData, &size);
+            }
             break;
         }
         default:
@@ -249,6 +269,11 @@ static HRESULT MMDevice_SetPropValue(const GUID *devguid, DWORD flow, REFPROPERT
             ret = RegSetValueExW(regkey, buffer, 0, REG_SZ, (const BYTE*)pv->pwszVal, sizeof(WCHAR)*(1+lstrlenW(pv->pwszVal)));
             break;
         }
+        case VT_CLSID: {
+            struct clsid_blob blob = {.vt = VT_CLSID, .wReserved0 = {0, 0, 0}, .wReserved1 = 0, .puuid = *pv->puuid};
+            ret = RegSetValueExW(regkey, buffer, 0, REG_BINARY, (const BYTE *)&blob, sizeof(blob));
+            break;
+        }
         default:
             ret = 0;
             FIXME("Unhandled type %u\n", pv->vt);
-- 
2.49.0

From 28bc8cd8a6c15e86f31a3421212ae93b0f1eca8d Mon Sep 17 00:00:00 2001
From: Harald Sitter <sitter@kde.org>
Date: Sun, 22 Jun 2025 14:44:12 -0400
Subject: [PATCH 143/159] containerid: helper to generate a containerid from a 
 sysfs path

---
 dlls/mmdevapi/devenum.c       |   2 +
 dlls/ntdll/Makefile.in        |   1 +
 dlls/ntdll/unix/containerid.c | 196 ++++++++++++++++++++++++++++++++++
 dlls/winebus.sys/bus_udev.c   |  27 +++++
 dlls/winebus.sys/main.c       |  20 ++++
 dlls/winebus.sys/unixlib.h    |   1 +
 dlls/winepulse.drv/pulse.c    |  23 ++++
 include/Makefile.in           |   1 +
 include/wine/containerid.h    |  28 +++++
 9 files changed, 299 insertions(+)
 create mode 100644 dlls/ntdll/unix/containerid.c
 create mode 100644 include/wine/containerid.h

diff --git a/dlls/mmdevapi/devenum.c b/dlls/mmdevapi/devenum.c
index b1e7e2e7eaa..2bbcdbfa8fa 100644
--- a/dlls/mmdevapi/devenum.c
+++ b/dlls/mmdevapi/devenum.c
@@ -441,6 +441,8 @@ static MMDevice *MMDevice_Create(const WCHAR *name, GUID *id, EDataFlow flow, DW
             pv.pwszVal = guidstr;
             MMDevice_SetPropValue(id, flow, &deviceinterface_key, &pv);
 
+            set_driver_prop_value(id, flow, (const PROPERTYKEY*)&DEVPKEY_Device_ContainerId);
+
             if (FAILED(set_driver_prop_value(id, flow, &PKEY_AudioEndpoint_FormFactor)))
             {
                 pv.vt = VT_UI4;
diff --git a/dlls/ntdll/Makefile.in b/dlls/ntdll/Makefile.in
index 457ae577399..6d77ff4a0c9 100644
--- a/dlls/ntdll/Makefile.in
+++ b/dlls/ntdll/Makefile.in
@@ -46,6 +46,7 @@ SOURCES = \
 	threadpool.c \
 	time.c \
 	unix/cdrom.c \
+	unix/containerid.c \
 	unix/debug.c \
 	unix/env.c \
 	unix/esync.c \
diff --git a/dlls/ntdll/unix/containerid.c b/dlls/ntdll/unix/containerid.c
new file mode 100644
index 00000000000..61fa5896049
--- /dev/null
+++ b/dlls/ntdll/unix/containerid.c
@@ -0,0 +1,196 @@
+/*
+ * ContainerID helper functions
+ *
+ * Copyright 2025 Harald Sitter <sitter@kde.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include <dirent.h>
+#include <errno.h>
+#include <fcntl.h> /* Definition of AT_* constants */
+#include <libgen.h>
+#include <limits.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winternl.h"
+#include "wine/containerid.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(containerid);
+
+// Find the directory with a 'removeble' file. Mutates sysfs_path in place.
+static BOOL find_removable_file_dir(char *sysfs_path)
+{
+    DIR *device_dir = NULL;
+    struct stat st;
+    for (;;) {
+        if (strcmp("/sys/devices", sysfs_path) == 0) {
+            TRACE("Device is not removable (could not find removable file)\n");
+            return FALSE;
+        }
+        device_dir = opendir(sysfs_path);
+        if (fstatat(dirfd(device_dir), "removable", &st, 0) == 0) {
+            closedir(device_dir);
+            return TRUE;
+        }
+        closedir(device_dir);
+        dirname(sysfs_path); // mutates in place
+    }
+    return FALSE;
+}
+
+// Checks if the device at sysfs_path is removable by checking the contents of the 'removable' file.
+static BOOL is_device_removable(char *sysfs_path)
+{
+    char is_removable_str[MAX_PATH];
+    char removable[] = "removable";
+    DIR *device_dir = opendir(sysfs_path);
+    int fd = openat(dirfd(device_dir), "removable", O_RDONLY | O_CLOEXEC);
+    int err = errno;
+
+    closedir(device_dir);
+
+    if (fd != -1) {
+        read(fd, is_removable_str, sizeof(is_removable_str));
+        close(fd);
+        if (strncmp(is_removable_str, removable, strlen(removable)) == 0) {
+            // Perfect, it's removable, so let's expose the sysfs path and by extension generate a container id.
+            return TRUE;
+        } else {
+            return FALSE;
+            TRACE("Device is not removable, not exposing sysfs path\n");
+        }
+    }
+
+    WARN("Failed to open %s/removable: %s\n", sysfs_path, strerror(err));
+    return FALSE;
+}
+
+static BOOL get_device_sysfs_path_from_sys_path(char const *sysfs_path, char device_path[MAX_PATH])
+{
+    char resolved_sysfs_path[MAX_PATH];
+    // Resolve all parts.
+    if (realpath(sysfs_path, resolved_sysfs_path) == NULL) {
+        WARN("realpath failed: %s\n", strerror(errno));
+        return FALSE;
+    }
+    // Then walk up until we find a removable file marker.
+    if (find_removable_file_dir(resolved_sysfs_path)) {
+        // resolved_sysfs_path is now pointing at the device directory containing a removable file.
+        // Next let's figure out if this device is actually removable.
+        if (is_device_removable(resolved_sysfs_path)) {
+            strcpy(device_path, resolved_sysfs_path);
+            return TRUE;
+        }
+    }
+    return FALSE;
+}
+
+static void container_id_from_inputs(char const **inputs, unsigned inputs_count, GUID *container_id)
+{
+    UINT8 hash[sizeof(GUID)] = {0};
+    UINT8 hash_index = 0;
+
+    // Trivialistic hash function. XOR all the bytes of all the inputs together.
+    for (int i = 0; i < inputs_count; i++) {
+        for (int j = 0; j < strlen(inputs[i]); j++) {
+            hash[hash_index] ^= inputs[i][j];
+            hash_index = (hash_index + 1) % ARRAY_SIZE(hash);
+        }
+    }
+
+    memcpy(container_id, hash, sizeof(GUID));
+}
+
+static  NTSTATUS fill_container_id(char const device_path[MAX_PATH], char const id_product[7], char const id_vendor[7], GUID *container_id)
+{
+    char const *inputs[] = {device_path, id_product, id_vendor};
+
+    // When sysfs_path is empty it means something has gone horribly wrong.
+    if (device_path[0] == 0) {
+        return STATUS_INVALID_PARAMETER;
+    }
+
+    container_id_from_inputs(inputs, ARRAY_SIZE(inputs), container_id);
+    TRACE("Generated container id: %s\n", wine_dbgstr_guid(container_id));
+
+    return STATUS_SUCCESS;
+}
+
+static BOOL read_id_file(char const *sysfs_path, char const *file, char *buffer, size_t buffer_size)
+{
+    DIR *device_dir = opendir(sysfs_path);
+    int fd = openat(dirfd(device_dir), file, O_RDONLY | O_CLOEXEC);
+    int err = errno;
+    off_t offset = 0;
+
+    closedir(device_dir);
+
+    if (fd == -1) {
+        WARN("Failed to open %s/%s: %s\n", sysfs_path, file, strerror(err));
+        return FALSE;
+    }
+
+    for (;;) {
+        ssize_t len = read(fd, buffer + offset, buffer_size - offset);
+        if (len == 0)
+            break;
+        if (len == -1) {
+            if (errno == EINTR)
+                continue;
+            WARN("Failed to read %s/%s: %s\n", sysfs_path, file, strerror(errno));
+            close(fd);
+            return FALSE;
+        }
+    }
+    close(fd);
+    return TRUE;
+
+}
+
+BOOL container_id_for_sysfs(char const *sysfs_path, GUID *container_id)
+{
+    char device_path[MAX_PATH] = {0};
+    char id_product[7] = {0}; // 7 = strlen(0x0b05)+1
+    char id_vendor[7] = {0};
+
+    if (!get_device_sysfs_path_from_sys_path(sysfs_path, device_path)) {
+        return FALSE;
+    }
+
+    if (!read_id_file(device_path, "idProduct", id_product, sizeof(id_product))) {
+        return FALSE;
+    }
+
+    if (!read_id_file(device_path, "idVendor", id_vendor, sizeof(id_vendor))) {
+        return FALSE;
+    }
+
+    fill_container_id(device_path, id_product, id_vendor, container_id);
+    return TRUE;
+}
diff --git a/dlls/winebus.sys/bus_udev.c b/dlls/winebus.sys/bus_udev.c
index 4a763f72da2..c3ab8d13158 100644
--- a/dlls/winebus.sys/bus_udev.c
+++ b/dlls/winebus.sys/bus_udev.c
@@ -73,6 +73,7 @@
 #include "ddk/hidtypes.h"
 #include "ddk/hidsdi.h"
 
+#include "wine/containerid.h"
 #include "wine/debug.h"
 #include "wine/hid.h"
 #include "wine/unixlib.h"
@@ -1563,6 +1564,30 @@ static void get_device_subsystem_info(struct udev_device *dev, const char *subsy
     }
 }
 
+static const char *get_device_syspath(struct udev_device *dev)
+{
+    struct udev_device *parent;
+
+    if ((parent = udev_device_get_parent_with_subsystem_devtype(dev, "hid", NULL)))
+        return udev_device_get_syspath(parent);
+
+    if ((parent = udev_device_get_parent_with_subsystem_devtype(dev, "usb", "usb_device")))
+        return udev_device_get_syspath(parent);
+
+    return udev_device_get_syspath(dev);
+}
+
+void get_container_id(struct udev_device *dev, struct device_desc *desc)
+{
+    const char *sysfs_path = get_device_syspath(dev);
+
+    memset(&desc->container_id, 0, sizeof(GUID));
+    if (!sysfs_path || sysfs_path[0] == 0) {
+        return;
+    }
+    container_id_for_sysfs(sysfs_path, &desc->container_id);
+}
+
 static void udev_add_device(struct udev_device *dev, int fd)
 {
     struct device_desc desc =
@@ -1588,6 +1613,8 @@ static void udev_add_device(struct udev_device *dev, int fd)
 
     TRACE("udev %s syspath %s\n", debugstr_a(devnode), udev_device_get_syspath(dev));
 
+    get_container_id(dev, &desc);
+
     get_device_subsystem_info(dev, "hid", NULL, &desc, &bus);
     get_device_subsystem_info(dev, "input", NULL, &desc, &bus);
     get_device_subsystem_info(dev, "usb", "usb_device", &desc, &bus);
diff --git a/dlls/winebus.sys/main.c b/dlls/winebus.sys/main.c
index df3e2663abc..05f098a0382 100644
--- a/dlls/winebus.sys/main.c
+++ b/dlls/winebus.sys/main.c
@@ -200,6 +200,22 @@ static WCHAR *get_instance_id(DEVICE_OBJECT *device)
     return dst;
 }
 
+static WCHAR *get_container_id(DEVICE_OBJECT *device)
+{
+    struct device_extension *ext = (struct device_extension *)device->DeviceExtension;
+    const GUID empty = {0};
+    UNICODE_STRING dst;
+
+    if (IsEqualGUID(&ext->desc.container_id, &empty)) {
+        return NULL;
+    }
+
+    RtlZeroMemory(&dst, sizeof(dst));
+    RtlStringFromGUID(&ext->desc.container_id, &dst);
+
+    return dst.Buffer;
+}
+
 static WCHAR *get_device_id(DEVICE_OBJECT *device)
 {
     static const WCHAR input_format[] = L"&MI_%02u";
@@ -727,6 +743,10 @@ static NTSTATUS handle_IRP_MN_QUERY_ID(DEVICE_OBJECT *device, IRP *irp)
             TRACE("BusQueryInstanceID\n");
             irp->IoStatus.Information = (ULONG_PTR)get_instance_id(device);
             break;
+        case BusQueryContainerID:
+            TRACE("BusQueryContainerID\n");
+            irp->IoStatus.Information = (ULONG_PTR)get_container_id(device);
+            break;
         default:
             WARN("Unhandled type %08x\n", type);
             return status;
diff --git a/dlls/winebus.sys/unixlib.h b/dlls/winebus.sys/unixlib.h
index 64eab2b976a..b798867a959 100644
--- a/dlls/winebus.sys/unixlib.h
+++ b/dlls/winebus.sys/unixlib.h
@@ -45,6 +45,7 @@ struct device_desc
     WCHAR manufacturer[MAX_PATH];
     WCHAR product[MAX_PATH];
     WCHAR serialnumber[MAX_PATH];
+    GUID container_id;
 };
 
 #define AUTOCENTER_DISABLE -3
diff --git a/dlls/winepulse.drv/pulse.c b/dlls/winepulse.drv/pulse.c
index 9cb29be21b6..77dafb2fb2f 100644
--- a/dlls/winepulse.drv/pulse.c
+++ b/dlls/winepulse.drv/pulse.c
@@ -38,10 +38,14 @@
 #include "initguid.h"
 #include "audioclient.h"
 
+#include "wine/containerid.h"
 #include "wine/debug.h"
 #include "wine/list.h"
 #include "wine/unixlib.h"
 
+#include "initguid.h"
+#include "devpkey.h"
+
 #include "../mmdevapi/unixlib.h"
 
 #include "mult.h"
@@ -105,6 +109,7 @@ typedef struct _PhysDevice {
     UINT index;
     REFERENCE_TIME min_period, def_period;
     WAVEFORMATEXTENSIBLE fmt;
+    GUID container_id;
     char pulse_name[0];
 } PhysDevice;
 
@@ -550,6 +555,7 @@ static void fill_device_info(PhysDevice *dev, pa_proplist *p)
     dev->bus_type = phys_device_bus_invalid;
     dev->vendor_id = 0;
     dev->product_id = 0;
+    memset(&dev->container_id, 0, sizeof(GUID));
 
     if (!p)
         return;
@@ -566,6 +572,13 @@ static void fill_device_info(PhysDevice *dev, pa_proplist *p)
 
     if ((buffer = pa_proplist_gets(p, PA_PROP_DEVICE_PRODUCT_ID)))
         dev->product_id = strtol(buffer, NULL, 16);
+
+    if ((buffer = pa_proplist_gets(p, "sysfs.path"))) {
+        // The syspath is of the audio device. Resolve it up to the device level.
+        char sysfs_path[MAX_PATH];
+        snprintf(sysfs_path, sizeof(sysfs_path), "/sys%s/device", buffer);
+        container_id_for_sysfs(sysfs_path, &dev->container_id);
+    }
 }
 
 static void pulse_add_device(struct list *list, pa_proplist *proplist, int index, EndpointFormFactor form,
@@ -2622,6 +2635,16 @@ static NTSTATUS pulse_get_prop_value(void *args)
                 params->result = S_OK;
                 return STATUS_SUCCESS;
             }
+        } else if (IsEqualGUID(&params->prop->fmtid, &DEVPKEY_Device_ContainerId)) {
+            params->value->vt = VT_CLSID;
+            params->value->puuid = malloc(sizeof(GUID));
+            if (!params->value->puuid)
+                params->result = E_OUTOFMEMORY;
+            else {
+                params->result = S_OK;
+                *params->value->puuid = dev->container_id;
+            }
+            return STATUS_SUCCESS;
         }
 
         params->result = E_NOTIMPL;
diff --git a/include/Makefile.in b/include/Makefile.in
index d56bc5182d8..6271c62d5d5 100644
--- a/include/Makefile.in
+++ b/include/Makefile.in
@@ -918,6 +918,7 @@ SOURCES = \
 	wine/afd.h \
 	wine/asm.h \
 	wine/atsvc.idl \
+	wine/containerid.h \
 	wine/condrv.h \
 	wine/dcetypes.idl \
 	wine/debug.h \
diff --git a/include/wine/containerid.h b/include/wine/containerid.h
new file mode 100644
index 00000000000..0a5b84794ff
--- /dev/null
+++ b/include/wine/containerid.h
@@ -0,0 +1,28 @@
+/*
+ * ContainerID helper functions
+ *
+ * Copyright 2025 Harald Sitter <sitter@kde.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef _WINE_CONTAINERID
+#define _WINE_CONTAINERID
+
+#include "winternl.h"
+
+NTSYSAPI BOOL container_id_for_sysfs(char const *sysfs_path, GUID *container_id);
+
+#endif /* _WINE_CONTAINERID */
-- 
2.49.0

From c2dce8cb2633735e365fa014c3ff9b8a37758119 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty <etaash.mathamsetty@gmail.com>
Date: Thu, 26 Jan 2023 15:07:16 -0500
Subject: [PATCH 144/159] ntoskrnl.exe: Implement KeAcquireGuardedMutex.

---
 dlls/ntoskrnl.exe/ntoskrnl.exe.spec |  2 ++
 dlls/ntoskrnl.exe/sync.c            | 23 +++++++++++++++++++++++
 2 files changed, 25 insertions(+)

diff --git a/dlls/ntoskrnl.exe/ntoskrnl.exe.spec b/dlls/ntoskrnl.exe/ntoskrnl.exe.spec
index 276e166c4a9..72926454352 100644
--- a/dlls/ntoskrnl.exe/ntoskrnl.exe.spec
+++ b/dlls/ntoskrnl.exe/ntoskrnl.exe.spec
@@ -52,6 +52,8 @@
 @ stdcall -fastcall IofCompleteRequest(ptr long)
 @ stdcall -arch=!i386 KeAcquireInStackQueuedSpinLock(ptr ptr)
 @ stdcall -fastcall KeAcquireInStackQueuedSpinLockAtDpcLevel(ptr ptr)
+@ stdcall KeAcquireGuardedMutexUnsafe(ptr)
+@ stdcall KeAcquireGuardedMutex(ptr)
 @ stdcall KeEnterGuardedRegion()
 @ stdcall KeExpandKernelStackAndCallout(ptr ptr long)
 @ stdcall KeExpandKernelStackAndCalloutEx(ptr ptr long long ptr)
diff --git a/dlls/ntoskrnl.exe/sync.c b/dlls/ntoskrnl.exe/sync.c
index d9b5726b920..331c3e1bce2 100644
--- a/dlls/ntoskrnl.exe/sync.c
+++ b/dlls/ntoskrnl.exe/sync.c
@@ -439,6 +439,29 @@ void WINAPI KeInitializeGuardedMutex(PKGUARDED_MUTEX mutex)
     KeInitializeEvent(&mutex->Event, SynchronizationEvent, FALSE);
 }
 
+/***********************************************************************
+ *           KeAcquireGuardedMutexUnsafe   (NTOSKRNL.EXE.@)
+ */
+void WINAPI KeAcquireGuardedMutexUnsafe(PKGUARDED_MUTEX mutex)
+{
+    LONG count;
+
+    TRACE("mutex %p.\n", mutex);
+
+    count = InterlockedDecrement( &mutex->Count );
+    if (count < 0)
+        KeWaitForSingleObject( &mutex->Event, Executive, KernelMode, FALSE, NULL );
+}
+
+/***********************************************************************
+ *           KeAcquireGuardedMutex   (NTOSKRNL.EXE.@)
+ */
+void WINAPI KeAcquireGuardedMutex(PKGUARDED_MUTEX mutex)
+{
+    /* FIXME: Enter Guarded Region */
+    KeAcquireGuardedMutexUnsafe(mutex);
+}
+
 static void CALLBACK ke_timer_complete_proc(PTP_CALLBACK_INSTANCE instance, void *timer_, PTP_TIMER tp_timer)
 {
     KTIMER *timer = timer_;
-- 
2.49.0

From 99b2a5d31ad11c895bacb628875c99a07b73c729 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty <etaash.mathamsetty@gmail.com>
Date: Thu, 26 Jan 2023 15:09:21 -0500
Subject: [PATCH 145/159] ntoskrnl.exe: Implement KeReleaseGuardedMutex.

---
 dlls/ntoskrnl.exe/ntoskrnl.exe.spec |  2 ++
 dlls/ntoskrnl.exe/sync.c            | 23 +++++++++++++++++++++++
 2 files changed, 25 insertions(+)

diff --git a/dlls/ntoskrnl.exe/ntoskrnl.exe.spec b/dlls/ntoskrnl.exe/ntoskrnl.exe.spec
index 72926454352..1c2449d9f4d 100644
--- a/dlls/ntoskrnl.exe/ntoskrnl.exe.spec
+++ b/dlls/ntoskrnl.exe/ntoskrnl.exe.spec
@@ -60,6 +60,8 @@
 @ stdcall KeLeaveGuardedRegion()
 @ stdcall -arch=!i386 KeReleaseInStackQueuedSpinLock(ptr)
 @ stdcall -fastcall KeReleaseInStackQueuedSpinLockFromDpcLevel(ptr)
+@ stdcall KeReleaseGuardedMutexUnsafe(ptr)
+@ stdcall KeReleaseGuardedMutex(ptr)
 @ stub KeSetTimeUpdateNotifyRoutine
 @ stub KefAcquireSpinLockAtDpcLevel
 @ stub KefReleaseSpinLockFromDpcLevel
diff --git a/dlls/ntoskrnl.exe/sync.c b/dlls/ntoskrnl.exe/sync.c
index 331c3e1bce2..a06bfcc05b6 100644
--- a/dlls/ntoskrnl.exe/sync.c
+++ b/dlls/ntoskrnl.exe/sync.c
@@ -462,6 +462,29 @@ void WINAPI KeAcquireGuardedMutex(PKGUARDED_MUTEX mutex)
     KeAcquireGuardedMutexUnsafe(mutex);
 }
 
+/***********************************************************************
+ *           KeReleaseGuardedMutexUnsafe   (NTOSKRNL.EXE.@)
+ */
+void WINAPI KeReleaseGuardedMutexUnsafe(PKGUARDED_MUTEX mutex)
+{
+    LONG count;
+
+    TRACE("mutex %p.\n", mutex);
+
+    count = InterlockedIncrement( &mutex->Count );
+    if (count < 1)
+        KeSetEvent( &mutex->Event, IO_NO_INCREMENT, FALSE );
+}
+
+/***********************************************************************
+ *           KeReleaseGuardedMutex   (NTOSKRNL.EXE.@)
+ */
+void WINAPI KeReleaseGuardedMutex(PKGUARDED_MUTEX mutex)
+{
+    KeReleaseGuardedMutexUnsafe(mutex);
+    /* FIXME: Leave Guarded Region */
+}
+
 static void CALLBACK ke_timer_complete_proc(PTP_CALLBACK_INSTANCE instance, void *timer_, PTP_TIMER tp_timer)
 {
     KTIMER *timer = timer_;
-- 
2.49.0

From e63dda18a62b40f102fe9b521df1b3355d60a569 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Mon, 23 Jun 2025 00:19:00 -0400
Subject: [PATCH 146/159] tdh: Add stub for TdhEnumerateProviders.

---
 dlls/tdh/tdh.spec   |  2 +-
 dlls/tdh/tdh_main.c | 35 +++++++++++++++++++++++++++++++++++
 2 files changed, 36 insertions(+), 1 deletion(-)

diff --git a/dlls/tdh/tdh.spec b/dlls/tdh/tdh.spec
index cde397c3899..0a2663714fe 100644
--- a/dlls/tdh/tdh.spec
+++ b/dlls/tdh/tdh.spec
@@ -7,7 +7,7 @@
 @ stub TdhEnumerateManifestProviderEvents
 @ stub TdhEnumerateProviderFieldInformation
 @ stub TdhEnumerateProviderFilters
-@ stub TdhEnumerateProviders
+@ stdcall TdhEnumerateProviders(ptr ptr)
 @ stub TdhEnumerateRemoteWBEMProviderFieldInformation
 @ stub TdhEnumerateRemoteWBEMProviders
 @ stub TdhFormatProperty
diff --git a/dlls/tdh/tdh_main.c b/dlls/tdh/tdh_main.c
index 60f32976b98..dab6e636384 100644
--- a/dlls/tdh/tdh_main.c
+++ b/dlls/tdh/tdh_main.c
@@ -38,3 +38,38 @@ ULONG WINAPI TdhLoadManifestFromBinary(LPWSTR binary)
     FIXME("(%s): stub\n", debugstr_w(binary));
     return STATUS_SUCCESS;
 }
+
+/* FIXME: Move this */
+
+typedef struct _TRACE_PROVIDER_INFO {
+    GUID  ProviderGuid;
+    ULONG SchemaSource;
+    ULONG ProviderNameOffset;
+} TRACE_PROVIDER_INFO;
+
+typedef struct _PROVIDER_ENUMERATION_INFO {
+    ULONG               NumberOfProviders;
+    ULONG               Reserved;
+    TRACE_PROVIDER_INFO TraceProviderInfoArray[ANYSIZE_ARRAY];
+} PROVIDER_ENUMERATION_INFO;
+
+ULONG WINAPI TdhEnumerateProviders(PROVIDER_ENUMERATION_INFO *buffer, ULONG *size)
+{
+    FIXME("%p %p stub!\n", buffer, size);
+
+    if (!size) return ERROR_INVALID_PARAMETER;
+
+    if (!buffer)
+    {
+        *size = sizeof(PROVIDER_ENUMERATION_INFO);
+        return ERROR_SUCCESS;
+    }
+
+    if (*size < sizeof(PROVIDER_ENUMERATION_INFO))
+        return ERROR_INSUFFICIENT_BUFFER;
+
+    buffer->NumberOfProviders = 0;
+    buffer->Reserved = 0;
+
+    return ERROR_SUCCESS;
+}
-- 
2.49.0

From 8abd9a26f2e2f880b1004eab335f1723ea276d59 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Tue, 24 Jun 2025 13:04:54 -0400
Subject: [PATCH 147/159] winewayland: Use SEND_HWMSG_NO_RAW for keyboard.

---
 dlls/winewayland.drv/wayland_keyboard.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index 39b42231b00..5234302884e 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -810,7 +810,7 @@ static void send_right_control(HWND hwnd, uint32_t state)
     input.ki.wScan = 0xe000 | (key2scan(KEY_RIGHTCTRL) & 0xff);
     input.ki.dwFlags = KEYEVENTF_SCANCODE | KEYEVENTF_EXTENDEDKEY;
     if (state == WL_KEYBOARD_KEY_STATE_RELEASED) input.ki.dwFlags |= KEYEVENTF_KEYUP;
-    NtUserSendHardwareInput(hwnd, 0, &input, 0);
+    NtUserSendHardwareInput(hwnd, SEND_HWMSG_NO_RAW, &input, 0);
 }
 
 static void keyboard_handle_key(void *data, struct wl_keyboard *wl_keyboard,
@@ -836,7 +836,7 @@ static void keyboard_handle_key(void *data, struct wl_keyboard *wl_keyboard,
     if (scan & ~0xff) input.ki.dwFlags |= KEYEVENTF_EXTENDEDKEY;
 
     if (state == WL_KEYBOARD_KEY_STATE_RELEASED) input.ki.dwFlags |= KEYEVENTF_KEYUP;
-    NtUserSendHardwareInput(hwnd, 0, &input, 0);
+    NtUserSendHardwareInput(hwnd, SEND_HWMSG_NO_RAW, &input, 0);
 }
 
 static void keyboard_handle_modifiers(void *data, struct wl_keyboard *wl_keyboard,
-- 
2.49.0

From 85c351a880fca238f72110507dae03cdcd452a9b Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Tue, 24 Jun 2025 13:05:02 -0400
Subject: [PATCH 148/159] winewayland: Add more logging for keyboard.

---
 dlls/winewayland.drv/wayland_keyboard.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index 5234302884e..44d90749162 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -747,6 +747,8 @@ static void keyboard_handle_enter(void *private, struct wl_keyboard *wl_keyboard
 
     InterlockedExchange(&process_wayland.input_serial, serial);
 
+    TRACE("surface=%p\n", wl_surface);
+
     if (!wl_surface) return;
 
     /* The wl_surface user data remains valid and immutable for the whole
@@ -784,6 +786,8 @@ static void keyboard_handle_leave(void *data, struct wl_keyboard *wl_keyboard,
 
     InterlockedExchange(&process_wayland.input_serial, serial);
 
+    TRACE("surface=%p\n", wl_surface);
+
     if (!wl_surface) return;
 
     /* The wl_surface user data remains valid and immutable for the whole
-- 
2.49.0

From 9331e6a6aaeb56a884e366413d16e39cc16a29f3 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Tue, 24 Jun 2025 14:55:36 -0400
Subject: [PATCH 149/159] fixup! Revert "winewayland: Use SEND_HWMSG_NO_RAW for
 keyboard."

This reverts commit 6fc63b9626c4b67819e71127ce94dc69463666f6.

This behavior is wrong
---
 dlls/winewayland.drv/wayland_keyboard.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index 44d90749162..a26915c412c 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -814,7 +814,7 @@ static void send_right_control(HWND hwnd, uint32_t state)
     input.ki.wScan = 0xe000 | (key2scan(KEY_RIGHTCTRL) & 0xff);
     input.ki.dwFlags = KEYEVENTF_SCANCODE | KEYEVENTF_EXTENDEDKEY;
     if (state == WL_KEYBOARD_KEY_STATE_RELEASED) input.ki.dwFlags |= KEYEVENTF_KEYUP;
-    NtUserSendHardwareInput(hwnd, SEND_HWMSG_NO_RAW, &input, 0);
+    NtUserSendHardwareInput(hwnd, 0, &input, 0);
 }
 
 static void keyboard_handle_key(void *data, struct wl_keyboard *wl_keyboard,
@@ -840,7 +840,7 @@ static void keyboard_handle_key(void *data, struct wl_keyboard *wl_keyboard,
     if (scan & ~0xff) input.ki.dwFlags |= KEYEVENTF_EXTENDEDKEY;
 
     if (state == WL_KEYBOARD_KEY_STATE_RELEASED) input.ki.dwFlags |= KEYEVENTF_KEYUP;
-    NtUserSendHardwareInput(hwnd, SEND_HWMSG_NO_RAW, &input, 0);
+    NtUserSendHardwareInput(hwnd, 0, &input, 0);
 }
 
 static void keyboard_handle_modifiers(void *data, struct wl_keyboard *wl_keyboard,
-- 
2.49.0

From 668628c896f6e72a569c8d113602f053a601e5a5 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Wed, 25 Jun 2025 12:17:22 -0400
Subject: [PATCH 150/159] amdxc: Add support for anti lag 2

---
 dlls/amdxc64/main.c | 65 +--------------------------------------------
 1 file changed, 1 insertion(+), 64 deletions(-)

diff --git a/dlls/amdxc64/main.c b/dlls/amdxc64/main.c
index e02e6525aea..e9537cca1fc 100644
--- a/dlls/amdxc64/main.c
+++ b/dlls/amdxc64/main.c
@@ -120,65 +120,6 @@ static const struct IAmdExtFfxApiVtbl AMDFSR4FFX_vtable = {
     AMDFSR4FFX_UpdateFfxApiProvider
 };
 
-struct AMDAntiLag2
-{
-    IAmdExtAntiLagApi IAmdExtAntiLagApi_iface;
-    LONG ref;
-};
-
-static struct AMDAntiLag2* impl_from_IAmdExtAntiLagApi(IAmdExtAntiLagApi *iface)
-{
-    return CONTAINING_RECORD(iface, struct AMDAntiLag2, IAmdExtAntiLagApi_iface);
-}
-
-ULONG STDMETHODCALLTYPE AMDAntiLag2_AddRef(IAmdExtAntiLagApi *iface)
-{
-    struct AMDAntiLag2 *data = impl_from_IAmdExtAntiLagApi(iface);
-    return InterlockedIncrement(&data->ref);
-}
-
-ULONG STDMETHODCALLTYPE AMDAntiLag2_Release(IAmdExtAntiLagApi *iface)
-{
-    struct AMDAntiLag2 *data = impl_from_IAmdExtAntiLagApi(iface);
-    ULONG ret = InterlockedDecrement(&data->ref);
-    if (!ret) free(data);
-    return ret;
-}
-
-HRESULT STDMETHODCALLTYPE AMDAntiLag2_QueryInterface(IAmdExtAntiLagApi *iface, REFIID iid, void **out)
-{
-    FIXME("(%p %s %p) stub!\n", iface, debugstr_guid(iid), out);
-    return E_NOINTERFACE;
-}
-
-HRESULT STDMETHODCALLTYPE AMDAntiLag2_UpdateAntiLagState(IAmdExtAntiLagApi *iface, void* data)
-{
-    union {
-        struct APIData_v1 *v1;
-        struct APIData_v2 *v2;
-    } apidata = {data};
-    TRACE("(%p %p)!\n", iface, data);
-
-    if (!data) {
-        /* perform sleep */
-    } else if(apidata.v1->uiVersion == 1) {
-        /* access apidata v1 */
-        if(apidata.v1->uiSize != sizeof(struct APIData_v1)) return E_INVALIDARG;
-    } else if(apidata.v1->uiVersion == 2) {
-        /* access apidata v2 */
-        if(apidata.v2->uiSize != sizeof(struct APIData_v2)) return E_INVALIDARG;
-    }
-
-    return E_NOTIMPL;
-}
-
-static const struct IAmdExtAntiLagApiVtbl AMDANTILAG_vtable = {
-    AMDAntiLag2_QueryInterface,
-    AMDAntiLag2_AddRef,
-    AMDAntiLag2_Release,
-    AMDAntiLag2_UpdateAntiLagState
-};
-
 struct AMDExtStub2
 {
     IAmdExtStub2 IAmdExtStub2_iface;
@@ -302,11 +243,7 @@ HRESULT CDECL AmdExtD3DCreateInterface(IUnknown *outer, REFIID iid, void **obj)
         *obj = &ffx->IAmdExtFfxApi_iface;
         return S_OK;
     } else if (IsEqualGUID(iid, &IID_IAmdExtAntiLagApi)) {
-        struct AMDAntiLag2 *out = calloc(1, sizeof(struct AMDAntiLag2));
-        out->IAmdExtAntiLagApi_iface.lpVtbl = &AMDANTILAG_vtable;
-        out->ref = 1;
-        *obj = &out->IAmdExtAntiLagApi_iface;
-        return S_OK;
+        return ID3D12Device_QueryInterface((ID3D12Device *)outer, &IID_IAmdExtAntiLagApi, obj);
     } else if(IsEqualGUID(iid, &IID_IAmdExtStub1)) {
         struct AMDExtStub1 *this = calloc(1, sizeof(struct AMDExtStub1));
         this->IAmdExtStub1_iface.lpVtbl = &AMDSTUB1_vtable;
-- 
2.49.0

From 44b8bbc42ec3c976312ca6f8df8324fc530b31e2 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Thu, 26 Jun 2025 23:16:18 -0400
Subject: [PATCH 151/159] amdxc: code cleanups.

---
 dlls/amdxc64/Makefile.in          |   1 -
 dlls/amdxc64/amdxc64.spec         | 316 +-----------------------------
 dlls/amdxc64/amdxc_interfaces.idl |  33 ----
 dlls/amdxc64/dxvk_interfaces.idl  | 153 ---------------
 dlls/amdxc64/main.c               |  16 +-
 5 files changed, 6 insertions(+), 513 deletions(-)
 delete mode 100644 dlls/amdxc64/dxvk_interfaces.idl

diff --git a/dlls/amdxc64/Makefile.in b/dlls/amdxc64/Makefile.in
index 999a7d043e1..a27f1da40ff 100644
--- a/dlls/amdxc64/Makefile.in
+++ b/dlls/amdxc64/Makefile.in
@@ -6,5 +6,4 @@ EXTRADLLFLAGS = -mno-cygwin
 
 SOURCES = \
 	main.c \
-	dxvk_interfaces.idl \
 	amdxc_interfaces.idl \
diff --git a/dlls/amdxc64/amdxc64.spec b/dlls/amdxc64/amdxc64.spec
index 2daa1ddbc94..5c6ecb267df 100644
--- a/dlls/amdxc64/amdxc64.spec
+++ b/dlls/amdxc64/amdxc64.spec
@@ -1,315 +1,5 @@
-1 stub ??0?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_IR_MODE_SELECTOR@@@detail@archive@boost@@QEAA@XZ
-2 stub ??0?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_MINIMIZE_VGPRS_STRATEGY@@@detail@archive@boost@@QEAA@XZ
-3 stub ??0?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_NPI_DISABLE@@@detail@archive@boost@@QEAA@XZ
-4 stub ??0?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_THREAD_LATENCY_STRATEGY@@@detail@archive@boost@@QEAA@XZ
-5 stub ??0?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_USE_MORE_D16_SELECTOR@@@detail@archive@boost@@QEAA@XZ
-6 stub ??0?$oserializer@Vsc_xml_oarchive@@T_SC_COMPILE_FLAGS@@@detail@archive@boost@@QEAA@XZ
-7 stub ??0?$oserializer@Vsc_xml_oarchive@@T_SC_LAUNCH_MODE_FLAGS@@@detail@archive@boost@@QEAA@XZ
-8 stub ??0?$oserializer@Vsc_xml_oarchive@@T_SC_SI_GLC_CONTROL@@@detail@archive@boost@@QEAA@XZ
-9 stub ??0?$oserializer@Vsc_xml_oarchive@@T_SC_SI_SLC_CONTROL@@@detail@archive@boost@@QEAA@XZ
-10 stub ??0?$oserializer@Vsc_xml_oarchive@@USC_INPUT@@@detail@archive@boost@@QEAA@XZ
-11 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY@serialization@boost@@@detail@archive@boost@@QEAA@XZ
-12 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_ATOMIC@@@detail@archive@boost@@QEAA@XZ
-13 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_CONTROL@@@detail@archive@boost@@QEAA@XZ
-14 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_READ@@@detail@archive@boost@@QEAA@XZ
-15 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_WRITE@@@detail@archive@boost@@QEAA@XZ
-16 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_CBCONSTVALUES@@@detail@archive@boost@@QEAA@XZ
-17 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_CBRCONSTVALUES@@@detail@archive@boost@@QEAA@XZ
-18 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_CI_TRANSFORM_SHADER_DESC@@@detail@archive@boost@@QEAA@XZ
-19 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_CONSTANTUSAGE@@@detail@archive@boost@@QEAA@XZ
-20 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_CPS_CONFIG@@@detail@archive@boost@@QEAA@XZ
-21 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_FLOAT_CONST@@@detail@archive@boost@@QEAA@XZ
-22 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_INT_CONST@@@detail@archive@boost@@QEAA@XZ
-23 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_CB_OFFSET_LUT@@@detail@archive@boost@@QEAA@XZ
-24 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_CONTROL_FLAGS@@@detail@archive@boost@@QEAA@XZ
-25 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_VPORT_CONTROLS_LUT@@@detail@archive@boost@@QEAA@XZ
-26 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_PS_EXPORT_INFO@@@detail@archive@boost@@QEAA@XZ
-27 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SHADERSTATE@@@detail@archive@boost@@QEAA@XZ
-28 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SI_DATA_IN_OUT@@@detail@archive@boost@@QEAA@XZ
-29 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SI_DESCRIPTOR_VALUES@@@detail@archive@boost@@QEAA@XZ
-30 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SI_OPTIMIZATIONS@@@detail@archive@boost@@QEAA@XZ
-31 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SI_PSSHADERDCL_IN@@@detail@archive@boost@@QEAA@XZ
-32 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SI_PS_ATTR_CH_ENTRY@@@detail@archive@boost@@QEAA@XZ
-33 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@QEAA@XZ
-34 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SI_STREAMIODCL_OUT@@@detail@archive@boost@@QEAA@XZ
-35 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SI_USER_DATA_ELEMENT@@@detail@archive@boost@@QEAA@XZ
-36 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@QEAA@XZ
-37 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@QEAA@XZ
-38 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_TXCONSTVALUES@@@detail@archive@boost@@QEAA@XZ
-39 stub ??0?$oserializer@Vsc_xml_oarchive@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@detail@archive@boost@@QEAA@XZ
-40 stub ??0?$singleton@V?$extended_type_info_typeid@T_E_SC_SI_OPT_IR_MODE_SELECTOR@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-41 stub ??0?$singleton@V?$extended_type_info_typeid@T_E_SC_SI_OPT_MINIMIZE_VGPRS_STRATEGY@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-42 stub ??0?$singleton@V?$extended_type_info_typeid@T_E_SC_SI_OPT_NPI_DISABLE@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-43 stub ??0?$singleton@V?$extended_type_info_typeid@T_E_SC_SI_OPT_THREAD_LATENCY_STRATEGY@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-44 stub ??0?$singleton@V?$extended_type_info_typeid@T_E_SC_SI_OPT_USE_MORE_D16_SELECTOR@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-45 stub ??0?$singleton@V?$extended_type_info_typeid@T_SC_COMPILE_FLAGS@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-46 stub ??0?$singleton@V?$extended_type_info_typeid@T_SC_LAUNCH_MODE_FLAGS@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-47 stub ??0?$singleton@V?$extended_type_info_typeid@T_SC_SI_GLC_CONTROL@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-48 stub ??0?$singleton@V?$extended_type_info_typeid@T_SC_SI_SLC_CONTROL@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-49 stub ??0?$singleton@V?$extended_type_info_typeid@USC_INPUT@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-50 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_CACHE_POLICY@serialization@boost@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-51 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_CACHE_POLICY_ATOMIC@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-52 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_CACHE_POLICY_CONTROL@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-53 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_CACHE_POLICY_READ@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-54 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_CACHE_POLICY_WRITE@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-55 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_CBCONSTVALUES@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-56 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_CBRCONSTVALUES@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-57 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_CI_TRANSFORM_SHADER_DESC@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-58 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_CONSTANTUSAGE@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-59 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_CPS_CONFIG@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-60 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_FLOAT_CONST@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-61 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_INT_CONST@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-62 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_PRIMSHADER_CB_OFFSET_LUT@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-63 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_PRIMSHADER_CONTROL_FLAGS@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-64 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_PRIMSHADER_VPORT_CONTROLS_LUT@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-65 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_PS_EXPORT_INFO@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-66 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SHADERSTATE@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-67 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SI_DATA_IN_OUT@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-68 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SI_DESCRIPTOR_VALUES@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-69 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SI_OPTIMIZATIONS@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-70 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SI_PSSHADERDCL_IN@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-71 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SI_PS_ATTR_CH_ENTRY@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-72 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SI_SHADERSTATE@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-73 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SI_STREAMIODCL_OUT@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-74 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SI_USER_DATA_ELEMENT@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-75 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SRCSHADER@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-76 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SRC_PIPELINE@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-77 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_TXCONSTVALUES@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-78 stub ??0?$singleton@V?$extended_type_info_typeid@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@serialization@boost@@@serialization@boost@@IEAA@XZ
-79 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@T_E_SC_SI_OPT_IR_MODE_SELECTOR@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@T_E_SC_SI_OPT_IR_MODE_SELECTOR@@@23@XZ
-80 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@T_E_SC_SI_OPT_MINIMIZE_VGPRS_STRATEGY@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@T_E_SC_SI_OPT_MINIMIZE_VGPRS_STRATEGY@@@23@XZ
-81 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@T_E_SC_SI_OPT_NPI_DISABLE@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@T_E_SC_SI_OPT_NPI_DISABLE@@@23@XZ
-82 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@T_E_SC_SI_OPT_THREAD_LATENCY_STRATEGY@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@T_E_SC_SI_OPT_THREAD_LATENCY_STRATEGY@@@23@XZ
-83 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@T_E_SC_SI_OPT_USE_MORE_D16_SELECTOR@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@T_E_SC_SI_OPT_USE_MORE_D16_SELECTOR@@@23@XZ
-84 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@T_SC_COMPILE_FLAGS@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@T_SC_COMPILE_FLAGS@@@23@XZ
-85 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@T_SC_LAUNCH_MODE_FLAGS@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@T_SC_LAUNCH_MODE_FLAGS@@@23@XZ
-86 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@T_SC_SI_GLC_CONTROL@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@T_SC_SI_GLC_CONTROL@@@23@XZ
-87 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@T_SC_SI_SLC_CONTROL@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@T_SC_SI_SLC_CONTROL@@@23@XZ
-88 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@USC_INPUT@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@USC_INPUT@@@23@XZ
-89 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_CACHE_POLICY@serialization@boost@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_CACHE_POLICY@serialization@boost@@@23@XZ
-90 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_CACHE_POLICY_ATOMIC@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_CACHE_POLICY_ATOMIC@@@23@XZ
-91 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_CACHE_POLICY_CONTROL@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_CACHE_POLICY_CONTROL@@@23@XZ
-92 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_CACHE_POLICY_READ@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_CACHE_POLICY_READ@@@23@XZ
-93 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_CACHE_POLICY_WRITE@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_CACHE_POLICY_WRITE@@@23@XZ
-94 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_CBCONSTVALUES@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_CBCONSTVALUES@@@23@XZ
-95 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_CBRCONSTVALUES@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_CBRCONSTVALUES@@@23@XZ
-96 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_CI_TRANSFORM_SHADER_DESC@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_CI_TRANSFORM_SHADER_DESC@@@23@XZ
-97 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_CONSTANTUSAGE@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_CONSTANTUSAGE@@@23@XZ
-98 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_CPS_CONFIG@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_CPS_CONFIG@@@23@XZ
-99 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_FLOAT_CONST@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_FLOAT_CONST@@@23@XZ
-100 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_INT_CONST@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_INT_CONST@@@23@XZ
-101 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_PRIMSHADER_CB_OFFSET_LUT@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_PRIMSHADER_CB_OFFSET_LUT@@@23@XZ
-102 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_PRIMSHADER_CONTROL_FLAGS@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_PRIMSHADER_CONTROL_FLAGS@@@23@XZ
-103 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_PRIMSHADER_VPORT_CONTROLS_LUT@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_PRIMSHADER_VPORT_CONTROLS_LUT@@@23@XZ
-104 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_PS_EXPORT_INFO@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_PS_EXPORT_INFO@@@23@XZ
-105 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SHADERSTATE@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SHADERSTATE@@@23@XZ
-106 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SI_DATA_IN_OUT@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SI_DATA_IN_OUT@@@23@XZ
-107 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SI_DESCRIPTOR_VALUES@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SI_DESCRIPTOR_VALUES@@@23@XZ
-108 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SI_OPTIMIZATIONS@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SI_OPTIMIZATIONS@@@23@XZ
-109 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SI_PSSHADERDCL_IN@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SI_PSSHADERDCL_IN@@@23@XZ
-110 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SI_PS_ATTR_CH_ENTRY@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SI_PS_ATTR_CH_ENTRY@@@23@XZ
-111 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SI_SHADERSTATE@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SI_SHADERSTATE@@@23@XZ
-112 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SI_STREAMIODCL_OUT@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SI_STREAMIODCL_OUT@@@23@XZ
-113 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SI_USER_DATA_ELEMENT@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SI_USER_DATA_ELEMENT@@@23@XZ
-114 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SRCSHADER@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SRCSHADER@@@23@XZ
-115 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SRC_PIPELINE@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SRC_PIPELINE@@@23@XZ
-116 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_TXCONSTVALUES@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_TXCONSTVALUES@@@23@XZ
-117 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@23@XZ
-118 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_IR_MODE_SELECTOR@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_IR_MODE_SELECTOR@@@detail@archive@3@XZ
-119 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_MINIMIZE_VGPRS_STRATEGY@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_MINIMIZE_VGPRS_STRATEGY@@@detail@archive@3@XZ
-120 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_NPI_DISABLE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_NPI_DISABLE@@@detail@archive@3@XZ
-121 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_THREAD_LATENCY_STRATEGY@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_THREAD_LATENCY_STRATEGY@@@detail@archive@3@XZ
-122 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_USE_MORE_D16_SELECTOR@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_USE_MORE_D16_SELECTOR@@@detail@archive@3@XZ
-123 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@T_SC_COMPILE_FLAGS@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@T_SC_COMPILE_FLAGS@@@detail@archive@3@XZ
-124 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@T_SC_LAUNCH_MODE_FLAGS@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@T_SC_LAUNCH_MODE_FLAGS@@@detail@archive@3@XZ
-125 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@T_SC_SI_GLC_CONTROL@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@T_SC_SI_GLC_CONTROL@@@detail@archive@3@XZ
-126 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@T_SC_SI_SLC_CONTROL@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@T_SC_SI_SLC_CONTROL@@@detail@archive@3@XZ
-127 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@USC_INPUT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@USC_INPUT@@@detail@archive@3@XZ
-128 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY@serialization@boost@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY@serialization@boost@@@detail@archive@3@XZ
-129 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_ATOMIC@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_ATOMIC@@@detail@archive@3@XZ
-130 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_CONTROL@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_CONTROL@@@detail@archive@3@XZ
-131 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_READ@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_READ@@@detail@archive@3@XZ
-132 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_WRITE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_WRITE@@@detail@archive@3@XZ
-133 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_CBCONSTVALUES@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_CBCONSTVALUES@@@detail@archive@3@XZ
-134 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_CBRCONSTVALUES@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_CBRCONSTVALUES@@@detail@archive@3@XZ
-135 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_CI_TRANSFORM_SHADER_DESC@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_CI_TRANSFORM_SHADER_DESC@@@detail@archive@3@XZ
-136 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_CONSTANTUSAGE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_CONSTANTUSAGE@@@detail@archive@3@XZ
-137 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_CPS_CONFIG@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_CPS_CONFIG@@@detail@archive@3@XZ
-138 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_FLOAT_CONST@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_FLOAT_CONST@@@detail@archive@3@XZ
-139 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_INT_CONST@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_INT_CONST@@@detail@archive@3@XZ
-140 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_PRIMSHADER_CB_OFFSET_LUT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_PRIMSHADER_CB_OFFSET_LUT@@@detail@archive@3@XZ
-141 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_PRIMSHADER_CONTROL_FLAGS@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_PRIMSHADER_CONTROL_FLAGS@@@detail@archive@3@XZ
-142 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_PRIMSHADER_VPORT_CONTROLS_LUT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_PRIMSHADER_VPORT_CONTROLS_LUT@@@detail@archive@3@XZ
-143 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_PS_EXPORT_INFO@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_PS_EXPORT_INFO@@@detail@archive@3@XZ
-144 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SHADERSTATE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SHADERSTATE@@@detail@archive@3@XZ
-145 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SI_DATA_IN_OUT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SI_DATA_IN_OUT@@@detail@archive@3@XZ
-146 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SI_DESCRIPTOR_VALUES@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SI_DESCRIPTOR_VALUES@@@detail@archive@3@XZ
-147 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SI_OPTIMIZATIONS@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SI_OPTIMIZATIONS@@@detail@archive@3@XZ
-148 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SI_PSSHADERDCL_IN@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SI_PSSHADERDCL_IN@@@detail@archive@3@XZ
-149 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SI_PS_ATTR_CH_ENTRY@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SI_PS_ATTR_CH_ENTRY@@@detail@archive@3@XZ
-150 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@3@XZ
-151 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SI_STREAMIODCL_OUT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SI_STREAMIODCL_OUT@@@detail@archive@3@XZ
-152 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SI_USER_DATA_ELEMENT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SI_USER_DATA_ELEMENT@@@detail@archive@3@XZ
-153 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SRCSHADER@@@detail@archive@3@XZ
-154 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SRC_PIPELINE@@@detail@archive@3@XZ
-155 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_TXCONSTVALUES@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_TXCONSTVALUES@@@detail@archive@3@XZ
-156 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@detail@archive@3@XZ
-157 stub ?get_const_instance@?$singleton@V?$map@Vsc_xml_iarchive@@@extra_detail@detail@archive@boost@@@serialization@boost@@SAAEBV?$map@Vsc_xml_iarchive@@@extra_detail@detail@archive@3@XZ
-158 stub ?get_const_instance@?$singleton@V?$multiset@PEBVextended_type_info@serialization@boost@@Ukey_compare@detail@23@V?$allocator@PEBVextended_type_info@serialization@boost@@@std@@@std@@@serialization@boost@@SAAEBV?$multiset@PEBVextended_type_info@serialization@boost@@Ukey_compare@detail@23@V?$allocator@PEBVextended_type_info@serialization@boost@@@std@@@std@@XZ
-159 stub ?get_const_instance@?$singleton@V?$multiset@PEBVextended_type_info_typeid_0@typeid_system@serialization@boost@@Utype_compare@234@V?$allocator@PEBVextended_type_info_typeid_0@typeid_system@serialization@boost@@@std@@@std@@@serialization@boost@@SAAEBV?$multiset@PEBVextended_type_info_typeid_0@typeid_system@serialization@boost@@Utype_compare@234@V?$allocator@PEBVextended_type_info_typeid_0@typeid_system@serialization@boost@@@std@@@std@@XZ
-160 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_IR_MODE_SELECTOR@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_IR_MODE_SELECTOR@@@detail@archive@3@XZ
-161 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_MINIMIZE_VGPRS_STRATEGY@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_MINIMIZE_VGPRS_STRATEGY@@@detail@archive@3@XZ
-162 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_NPI_DISABLE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_NPI_DISABLE@@@detail@archive@3@XZ
-163 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_THREAD_LATENCY_STRATEGY@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_THREAD_LATENCY_STRATEGY@@@detail@archive@3@XZ
-164 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_USE_MORE_D16_SELECTOR@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_USE_MORE_D16_SELECTOR@@@detail@archive@3@XZ
-165 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@T_SC_COMPILE_FLAGS@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@T_SC_COMPILE_FLAGS@@@detail@archive@3@XZ
-166 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@T_SC_LAUNCH_MODE_FLAGS@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@T_SC_LAUNCH_MODE_FLAGS@@@detail@archive@3@XZ
-167 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@T_SC_SI_GLC_CONTROL@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@T_SC_SI_GLC_CONTROL@@@detail@archive@3@XZ
-168 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@T_SC_SI_SLC_CONTROL@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@T_SC_SI_SLC_CONTROL@@@detail@archive@3@XZ
-169 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@USC_INPUT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@USC_INPUT@@@detail@archive@3@XZ
-170 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY@serialization@boost@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY@serialization@boost@@@detail@archive@3@XZ
-171 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_ATOMIC@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_ATOMIC@@@detail@archive@3@XZ
-172 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_CONTROL@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_CONTROL@@@detail@archive@3@XZ
-173 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_READ@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_READ@@@detail@archive@3@XZ
-174 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_WRITE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_WRITE@@@detail@archive@3@XZ
-175 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_CBCONSTVALUES@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_CBCONSTVALUES@@@detail@archive@3@XZ
-176 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_CBRCONSTVALUES@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_CBRCONSTVALUES@@@detail@archive@3@XZ
-177 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_CI_TRANSFORM_SHADER_DESC@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_CI_TRANSFORM_SHADER_DESC@@@detail@archive@3@XZ
-178 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_CONSTANTUSAGE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_CONSTANTUSAGE@@@detail@archive@3@XZ
-179 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_CPS_CONFIG@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_CPS_CONFIG@@@detail@archive@3@XZ
-180 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_FLOAT_CONST@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_FLOAT_CONST@@@detail@archive@3@XZ
-181 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_INT_CONST@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_INT_CONST@@@detail@archive@3@XZ
-182 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_CB_OFFSET_LUT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_CB_OFFSET_LUT@@@detail@archive@3@XZ
-183 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_CONTROL_FLAGS@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_CONTROL_FLAGS@@@detail@archive@3@XZ
-184 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_VPORT_CONTROLS_LUT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_VPORT_CONTROLS_LUT@@@detail@archive@3@XZ
-185 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_PS_EXPORT_INFO@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_PS_EXPORT_INFO@@@detail@archive@3@XZ
-186 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SHADERSTATE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SHADERSTATE@@@detail@archive@3@XZ
-187 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SI_DATA_IN_OUT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SI_DATA_IN_OUT@@@detail@archive@3@XZ
-188 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SI_DESCRIPTOR_VALUES@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SI_DESCRIPTOR_VALUES@@@detail@archive@3@XZ
-189 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SI_OPTIMIZATIONS@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SI_OPTIMIZATIONS@@@detail@archive@3@XZ
-190 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SI_PSSHADERDCL_IN@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SI_PSSHADERDCL_IN@@@detail@archive@3@XZ
-191 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SI_PS_ATTR_CH_ENTRY@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SI_PS_ATTR_CH_ENTRY@@@detail@archive@3@XZ
-192 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@3@XZ
-193 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SI_STREAMIODCL_OUT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SI_STREAMIODCL_OUT@@@detail@archive@3@XZ
-194 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SI_USER_DATA_ELEMENT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SI_USER_DATA_ELEMENT@@@detail@archive@3@XZ
-195 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SRCSHADER@@@detail@archive@3@XZ
-196 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SRC_PIPELINE@@@detail@archive@3@XZ
-197 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_TXCONSTVALUES@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_TXCONSTVALUES@@@detail@archive@3@XZ
-198 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@detail@archive@3@XZ
-199 stub ?get_const_instance@?$singleton@V?$pointer_iserializer@Vsc_xml_iarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$pointer_iserializer@Vsc_xml_iarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@3@XZ
-200 stub ?get_const_instance@?$singleton@V?$pointer_iserializer@Vsc_xml_iarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$pointer_iserializer@Vsc_xml_iarchive@@U_SC_SRCSHADER@@@detail@archive@3@XZ
-201 stub ?get_const_instance@?$singleton@V?$pointer_iserializer@Vsc_xml_iarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$pointer_iserializer@Vsc_xml_iarchive@@U_SC_SRC_PIPELINE@@@detail@archive@3@XZ
-202 stub ?get_const_instance@?$singleton@V?$pointer_oserializer@Vsc_xml_oarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$pointer_oserializer@Vsc_xml_oarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@3@XZ
-203 stub ?get_const_instance@?$singleton@V?$pointer_oserializer@Vsc_xml_oarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$pointer_oserializer@Vsc_xml_oarchive@@U_SC_SRCSHADER@@@detail@archive@3@XZ
-204 stub ?get_const_instance@?$singleton@V?$pointer_oserializer@Vsc_xml_oarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$pointer_oserializer@Vsc_xml_oarchive@@U_SC_SRC_PIPELINE@@@detail@archive@3@XZ
-205 stub ?get_const_instance@?$singleton@V?$set@PEBVvoid_caster@void_cast_detail@serialization@boost@@Uvoid_caster_compare@234@V?$allocator@PEBVvoid_caster@void_cast_detail@serialization@boost@@@std@@@std@@@serialization@boost@@SAAEBV?$set@PEBVvoid_caster@void_cast_detail@serialization@boost@@Uvoid_caster_compare@234@V?$allocator@PEBVvoid_caster@void_cast_detail@serialization@boost@@@std@@@std@@XZ
-206 stub ?get_lock@singleton_module@serialization@boost@@AEAAAEA_NXZ
-207 stub ?get_mutable_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@@serialization@boost@@SAAEAV?$iserializer@Vsc_xml_iarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@3@XZ
-208 stub ?get_mutable_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@@serialization@boost@@SAAEAV?$iserializer@Vsc_xml_iarchive@@U_SC_SRCSHADER@@@detail@archive@3@XZ
-209 stub ?get_mutable_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@@serialization@boost@@SAAEAV?$iserializer@Vsc_xml_iarchive@@U_SC_SRC_PIPELINE@@@detail@archive@3@XZ
-210 stub ?get_mutable_instance@?$singleton@V?$map@Vsc_xml_iarchive@@@extra_detail@detail@archive@boost@@@serialization@boost@@SAAEAV?$map@Vsc_xml_iarchive@@@extra_detail@detail@archive@3@XZ
-211 stub ?get_mutable_instance@?$singleton@V?$map@Vsc_xml_oarchive@@@extra_detail@detail@archive@boost@@@serialization@boost@@SAAEAV?$map@Vsc_xml_oarchive@@@extra_detail@detail@archive@3@XZ
-212 stub ?get_mutable_instance@?$singleton@V?$multiset@PEBVextended_type_info@serialization@boost@@Ukey_compare@detail@23@V?$allocator@PEBVextended_type_info@serialization@boost@@@std@@@std@@@serialization@boost@@SAAEAV?$multiset@PEBVextended_type_info@serialization@boost@@Ukey_compare@detail@23@V?$allocator@PEBVextended_type_info@serialization@boost@@@std@@@std@@XZ
-213 stub ?get_mutable_instance@?$singleton@V?$multiset@PEBVextended_type_info_typeid_0@typeid_system@serialization@boost@@Utype_compare@234@V?$allocator@PEBVextended_type_info_typeid_0@typeid_system@serialization@boost@@@std@@@std@@@serialization@boost@@SAAEAV?$multiset@PEBVextended_type_info_typeid_0@typeid_system@serialization@boost@@Utype_compare@234@V?$allocator@PEBVextended_type_info_typeid_0@typeid_system@serialization@boost@@@std@@@std@@XZ
-214 stub ?get_mutable_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@@serialization@boost@@SAAEAV?$oserializer@Vsc_xml_oarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@3@XZ
-215 stub ?get_mutable_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@@serialization@boost@@SAAEAV?$oserializer@Vsc_xml_oarchive@@U_SC_SRCSHADER@@@detail@archive@3@XZ
-216 stub ?get_mutable_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@@serialization@boost@@SAAEAV?$oserializer@Vsc_xml_oarchive@@U_SC_SRC_PIPELINE@@@detail@archive@3@XZ
-217 stub ?get_mutable_instance@?$singleton@V?$set@PEBVvoid_caster@void_cast_detail@serialization@boost@@Uvoid_caster_compare@234@V?$allocator@PEBVvoid_caster@void_cast_detail@serialization@boost@@@std@@@std@@@serialization@boost@@SAAEAV?$set@PEBVvoid_caster@void_cast_detail@serialization@boost@@Uvoid_caster_compare@234@V?$allocator@PEBVvoid_caster@void_cast_detail@serialization@boost@@@std@@@std@@XZ
-218 stub ?is_destroyed@?$singleton@V?$map@Vsc_xml_iarchive@@@extra_detail@detail@archive@boost@@@serialization@boost@@SA_NXZ
-219 stub ?is_destroyed@?$singleton@V?$map@Vsc_xml_oarchive@@@extra_detail@detail@archive@boost@@@serialization@boost@@SA_NXZ
-220 stub ?is_destroyed@?$singleton@V?$multiset@PEBVextended_type_info@serialization@boost@@Ukey_compare@detail@23@V?$allocator@PEBVextended_type_info@serialization@boost@@@std@@@std@@@serialization@boost@@SA_NXZ
-221 stub ?is_destroyed@?$singleton@V?$multiset@PEBVextended_type_info_typeid_0@typeid_system@serialization@boost@@Utype_compare@234@V?$allocator@PEBVextended_type_info_typeid_0@typeid_system@serialization@boost@@@std@@@std@@@serialization@boost@@SA_NXZ
-222 stub ?is_destroyed@?$singleton@V?$set@PEBVvoid_caster@void_cast_detail@serialization@boost@@Uvoid_caster_compare@234@V?$allocator@PEBVvoid_caster@void_cast_detail@serialization@boost@@@std@@@std@@@serialization@boost@@SA_NXZ
-223 stub ?is_locked@singleton_module@serialization@boost@@QEAA_NXZ
-224 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_IR_MODE_SELECTOR@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-225 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_MINIMIZE_VGPRS_STRATEGY@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-226 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_NPI_DISABLE@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-227 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_THREAD_LATENCY_STRATEGY@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-228 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_USE_MORE_D16_SELECTOR@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-229 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@T_SC_COMPILE_FLAGS@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-230 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@T_SC_LAUNCH_MODE_FLAGS@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-231 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@T_SC_SI_GLC_CONTROL@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-232 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@T_SC_SI_SLC_CONTROL@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-233 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@USC_INPUT@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-234 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY@serialization@boost@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-235 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_ATOMIC@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-236 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_CONTROL@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-237 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_READ@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-238 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_WRITE@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-239 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_CBCONSTVALUES@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-240 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_CBRCONSTVALUES@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-241 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_CI_TRANSFORM_SHADER_DESC@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-242 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_CONSTANTUSAGE@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-243 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_CPS_CONFIG@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-244 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_FLOAT_CONST@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-245 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_INT_CONST@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-246 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_PRIMSHADER_CB_OFFSET_LUT@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-247 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_PRIMSHADER_CONTROL_FLAGS@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-248 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_PRIMSHADER_VPORT_CONTROLS_LUT@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-249 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_PS_EXPORT_INFO@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-250 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SHADERSTATE@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-251 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SI_DATA_IN_OUT@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-252 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SI_DESCRIPTOR_VALUES@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-253 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SI_OPTIMIZATIONS@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-254 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SI_PSSHADERDCL_IN@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-255 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SI_PS_ATTR_CH_ENTRY@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-256 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-257 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SI_STREAMIODCL_OUT@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-258 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SI_USER_DATA_ELEMENT@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-259 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-260 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-261 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_TXCONSTVALUES@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-262 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
-263 stub ?load_object_ptr@?$pointer_iserializer@Vsc_xml_iarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@EEBAXAEAVbasic_iarchive@234@PEAXI@Z
-264 stub ?load_object_ptr@?$pointer_iserializer@Vsc_xml_iarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@EEBAXAEAVbasic_iarchive@234@PEAXI@Z
-265 stub ?load_object_ptr@?$pointer_iserializer@Vsc_xml_iarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@EEBAXAEAVbasic_iarchive@234@PEAXI@Z
-266 stub ?lock@?1??get_lock@singleton_module@serialization@boost@@AEAAAEA_NXZ@4_NA
-267 stub ?lock@singleton_module@serialization@boost@@QEAAXXZ
-268 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_IR_MODE_SELECTOR@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-269 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_MINIMIZE_VGPRS_STRATEGY@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-270 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_NPI_DISABLE@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-271 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_THREAD_LATENCY_STRATEGY@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-272 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_USE_MORE_D16_SELECTOR@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-273 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@T_SC_COMPILE_FLAGS@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-274 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@T_SC_LAUNCH_MODE_FLAGS@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-275 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@T_SC_SI_GLC_CONTROL@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-276 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@T_SC_SI_SLC_CONTROL@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-277 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@USC_INPUT@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-278 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY@serialization@boost@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-279 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_ATOMIC@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-280 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_CONTROL@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-281 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_READ@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-282 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_WRITE@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-283 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_CBCONSTVALUES@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-284 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_CBRCONSTVALUES@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-285 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_CI_TRANSFORM_SHADER_DESC@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-286 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_CONSTANTUSAGE@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-287 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_CPS_CONFIG@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-288 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_FLOAT_CONST@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-289 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_INT_CONST@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-290 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_CB_OFFSET_LUT@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-291 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_CONTROL_FLAGS@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-292 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_VPORT_CONTROLS_LUT@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-293 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_PS_EXPORT_INFO@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-294 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SHADERSTATE@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-295 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SI_DATA_IN_OUT@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-296 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SI_DESCRIPTOR_VALUES@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-297 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SI_OPTIMIZATIONS@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-298 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SI_PSSHADERDCL_IN@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-299 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SI_PS_ATTR_CH_ENTRY@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-300 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-301 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SI_STREAMIODCL_OUT@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-302 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SI_USER_DATA_ELEMENT@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-303 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-304 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-305 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_TXCONSTVALUES@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-306 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
-307 stub ?save_object_ptr@?$pointer_oserializer@Vsc_xml_oarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@EEBAXAEAVbasic_oarchive@234@PEBX@Z
-308 stub ?save_object_ptr@?$pointer_oserializer@Vsc_xml_oarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@EEBAXAEAVbasic_oarchive@234@PEBX@Z
-309 stub ?save_object_ptr@?$pointer_oserializer@Vsc_xml_oarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@EEBAXAEAVbasic_oarchive@234@PEBX@Z
-310 stub ?unlock@singleton_module@serialization@boost@@QEAAXXZ
 @ cdecl AmdExtD3DCreateInterface(ptr ptr ptr)
 @ stdcall AmdGetDxcModuleHandle()
-313 stub GetSettingsBlobsAll
-314 stub OpenAdapter12
-315 stub OpenShimInterface
+@ stub GetSettingsBlobsAll
+@ stub OpenAdapter12
+@ stub OpenShimInterface
diff --git a/dlls/amdxc64/amdxc_interfaces.idl b/dlls/amdxc64/amdxc_interfaces.idl
index 2c2f568df37..0c88ec17540 100644
--- a/dlls/amdxc64/amdxc_interfaces.idl
+++ b/dlls/amdxc64/amdxc_interfaces.idl
@@ -20,39 +20,6 @@
 import "wtypes.idl";
 import "unknwn.idl";
 
-/* Structure version 1 for Anti-Lag 2.0: */
-struct APIData_v1
-{
-    unsigned int    uiSize;
-    unsigned int    uiVersion;
-    unsigned int    eMode;
-    const char*     sControlStr;
-    unsigned int    uiControlStrLength;
-    unsigned int    maxFPS;
-};
-
-/* Structure version 2 for Anti-Lag 2.0: */
-struct APIData_v2
-{
-    unsigned int    uiSize;
-    unsigned int    uiVersion;
-    struct Flags
-    {
-        unsigned int unused0               : 1;
-        unsigned int unused1               : 1;
-
-        unsigned int signalFgFrameType     : 1;
-        unsigned int isInterpolatedFrame   : 1;
-
-        unsigned int signalGetUserInputIdx : 1;
-        unsigned int signalEndOfFrameIdx   : 1;
-
-        unsigned int reserved              :26;
-    }               flags;
-    unsigned __int64    iiFrameIdx;
-    unsigned __int64    uiiReserved[19];
-};
-
 [
     object,
     uuid(b58d6601-7401-4234-8180-6febfc0e484c),
diff --git a/dlls/amdxc64/dxvk_interfaces.idl b/dlls/amdxc64/dxvk_interfaces.idl
deleted file mode 100644
index 9e405a32a06..00000000000
--- a/dlls/amdxc64/dxvk_interfaces.idl
+++ /dev/null
@@ -1,153 +0,0 @@
-/*
- * Copyright 2023      Paul Gofman for CodeWeavers
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#pragma makedep register
-
-import "d3d11.idl";
-import "dxgi1_6.idl";
-
-typedef struct VkInstance_T *VkInstance;
-typedef void (__stdcall *PFN_vkVoidFunction)(void);
-typedef PFN_vkVoidFunction (__stdcall *PFN_vkGetInstanceProcAddr)(VkInstance instance, const char* pName);
-
-typedef enum D3D11_VK_EXTENSION
-{
-    D3D11_VK_EXT_MULTI_DRAW_INDIRECT,
-    D3D11_VK_EXT_MULTI_DRAW_INDIRECT_COUNT,
-    D3D11_VK_EXT_DEPTH_BOUNDS,
-    D3D11_VK_EXT_BARRIER_CONTROL,
-    D3D11_VK_NVX_BINARY_IMPORT,
-    D3D11_VK_NVX_IMAGE_VIEW_HANDLE,
-} D3D11_VK_EXTENSION;
-
-typedef enum D3D11_VK_BARRIER_CONTROL
-{
-    D3D11_VK_BARRIER_CONTROL_IGNORE_WRITE_AFTER_WRITE = 0x1,
-    D3D11_VK_BARRIER_CONTROL_IGNORE_GRAPHICS_UAV = 0x2,
-} D3D11_VK_BARRIER_CONTROL;
-
-[
-    object,
-    uuid(bb8a4fb9-3935-4762-b44b-35189a26414a),
-    local,
-    pointer_default(unique)
-]
-interface ID3D11VkExtShader : IUnknown
-{
-    HRESULT GetSpirvCode([in, out] SIZE_T *code_size, [out] void *code);
-}
-
-[
-    object,
-    uuid(8a6e3c42-f74c-45b7-8265-a231b677ca17),
-    local,
-    pointer_default(unique)
-]
-interface ID3D11VkExtDevice : IUnknown
-{
-    BOOL GetExtensionSupport([in] D3D11_VK_EXTENSION extension);
-}
-
-[
-    object,
-    uuid(cfcf64ef-9586-46d0-bca4-97cf2ca61b06),
-    local,
-    pointer_default(unique)
-]
-interface ID3D11VkExtDevice1 : ID3D11VkExtDevice
-{
-    BOOL GetResourceHandleGPUVirtualAddressAndSizeNVX([in] void *object, [out] UINT64 *gpu_va_start,
-            [out] UINT64 *gpu_va_size);
-    BOOL CreateUnorderedAccessViewAndGetDriverHandleNVX([in] ID3D11Resource *resource,
-            [in] const D3D11_UNORDERED_ACCESS_VIEW_DESC *desc, [out] ID3D11UnorderedAccessView **uav,
-            UINT32 *driver_handle);
-    BOOL CreateShaderResourceViewAndGetDriverHandleNVX([in] ID3D11Resource *resource,
-            [in] const D3D11_SHADER_RESOURCE_VIEW_DESC* desc, [out] ID3D11ShaderResourceView **srv,
-            UINT32 *dirver_handle);
-    BOOL CreateSamplerStateAndGetDriverHandleNVX([in] const D3D11_SAMPLER_DESC *sample_desc,
-            [out] ID3D11SamplerState **sample_state, UINT32 *driver_handle);
-    BOOL CreateCubinComputeShaderWithNameNVX([in] const void *cubin, [in] UINT32 size, [in] UINT32 block_x,
-            [in] UINT32 block_y, [in] UINT32 block_z, [in] const char *shader_name, [out] IUnknown **shader);
-    BOOL GetCudaTextureObjectNVX([in] UINT32 srv_driver_hadnle, [in] UINT32 sample_driver_handle,
-            [out] UINT32 *cuda_texture_handle);
-}
-
-[
-    object,
-    uuid(fd0bca13-5cb6-4c3a-987e-4750de2ca791),
-    local,
-    pointer_default(unique)
-]
-interface ID3D11VkExtContext : IUnknown
-{
-    void MultiDrawIndirect([in] UINT draw_count, [in] ID3D11Buffer *buffer_for_args, [in] UINT byte_offset_for_args,
-            [in] UINT byte_stride_for_args);
-    void MultiDrawIndexedIndirect([in] UINT draw_count, [in] ID3D11Buffer *buffer_for_args,
-            [in] UINT byte_offset_for_args, [in] UINT byte_stride_for_args);
-    void MultiDrawIndirectCount([in] UINT max_draw_count, [in] ID3D11Buffer *buffer_for_count,
-            [in] UINT byte_offset_for_count, [in] ID3D11Buffer *buffer_for_args,
-            [in] UINT byte_offset_for_args, [in] UINT byte_stride_for_args);
-    void MultiDrawIndexedIndirectCount([in] UINT max_draw_count, [in] ID3D11Buffer *buffer_for_count,
-            [in] UINT byte_offset_for_count, [in] ID3D11Buffer *buffer_for_args,
-            [in] UINT byte_offset_for_args, [in] UINT byte_stride_for_args);
-    void SetDepthBoundsTest([in] BOOL enable, [in] FLOAT min_depth_bounds, [in] FLOAT max_depth_bounds);
-    void SetBarrierControl([in] UINT control_flags);
-}
-
-[
-    object,
-    uuid(874b09b2-ae0b-41d8-8476-5f3b7a0e879d),
-    local,
-    pointer_default(unique)
-]
-interface ID3D11VkExtContext1 : ID3D11VkExtContext
-{
-    BOOL LaunchCubinShaderNVX([in] IUnknown *shader,[in] UINT32 grid_x, [in] UINT32 grid_y, [in] UINT32 grid_z,
-            [in] const void *params, [in] UINT32 param_size, [in] void * const *read_resources,
-            [in] UINT32 read_resource_count, [in] void* const *write_resources, [in] UINT32 write_resources_count);
-}
-
-[
-    object,
-    uuid(4c5e1b0d-b0c8-4131-bfd8-9b2476f7f408),
-    local,
-    pointer_default(unique)
-]
-interface IDXGIVkInteropFactory : IUnknown
-{
-    void GetVulkanInstance(
-          [out] VkInstance *pInstance,
-          [out] PFN_vkGetInstanceProcAddr *ppfnVkGetInstanceProcAddr);
-}
-
-[
-    object,
-    uuid(2a289dbd-2d0a-4a51-89f7-f2adce465cd6),
-    local,
-    pointer_default(unique)
-]
-interface IDXGIVkInteropFactory1 : IDXGIVkInteropFactory
-{
-  HRESULT GetGlobalHDRState(
-          [out] DXGI_COLOR_SPACE_TYPE   *pOutColorSpace,
-          [out] DXGI_HDR_METADATA_HDR10 *ppOutMetadata) = 0;
-
-  HRESULT SetGlobalHDRState(
-          [in] DXGI_COLOR_SPACE_TYPE    ColorSpace,
-    [in] const DXGI_HDR_METADATA_HDR10 *pMetadata) = 0;
-}
diff --git a/dlls/amdxc64/main.c b/dlls/amdxc64/main.c
index e9537cca1fc..b4eb97f34a9 100644
--- a/dlls/amdxc64/main.c
+++ b/dlls/amdxc64/main.c
@@ -29,21 +29,12 @@
 #include "wine/debug.h"
 #include "wine/heap.h"
 
-#include "wine/vulkan.h"
-#include "wine/asm.h"
-
 #define COBJMACROS
 #include "initguid.h"
-#include "d3d11.h"
 #include "d3d12.h"
 
-#include "dxgi1_6.h"
-
-#include "dxvk_interfaces.h"
 #include "amdxc_interfaces.h"
 
-#include <wingdi.h>
-
 WINE_DEFAULT_DEBUG_CHANNEL(amdxc);
 
 struct AMDFSR4FFX
@@ -91,7 +82,7 @@ HRESULT STDMETHODCALLTYPE AMDFSR4FFX_UpdateFfxApiProvider(IAmdExtFfxApi *iface,
 
     env = getenv("FSR4_UPGRADE");
 
-    if(env && !strcmp(env, "1"))
+    if (env && !strcmp(env, "1"))
     {
         amdffx = LoadLibraryA("amdxcffx64");
         if (!amdffx)
@@ -102,10 +93,9 @@ HRESULT STDMETHODCALLTYPE AMDFSR4FFX_UpdateFfxApiProvider(IAmdExtFfxApi *iface,
 
         pfn = (updateffxapi_pfn)GetProcAddress(amdffx, "UpdateFfxApiProvider");
 
-        if(pfn)
+        if (pfn)
         {
-            if (!once++)
-                FIXME("Replaced FSR3 with FSR4!\n");
+            if (!once++) WARN("Replaced FSR3 with FSR4!\n");
             return pfn(data, size);
         }
     }
-- 
2.49.0

From 8802a8da546a825fd335c8c1deb8e3e5a16d0f84 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Fri, 27 Jun 2025 16:22:01 -0400
Subject: [PATCH 152/159] winewayland: Add error message for cross process
 rendering.

---
 dlls/winewayland.drv/opengl.c | 7 +++++++
 dlls/winewayland.drv/vulkan.c | 7 +++++++
 2 files changed, 14 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 9d0aba68370..c6a84a4f1bd 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -199,6 +199,7 @@ static struct wayland_gl_drawable *wayland_gl_drawable_create(HWND hwnd, int for
 {
     struct wayland_gl_drawable *gl;
     int client_width, client_height;
+    DWORD tid, pid;
     RECT client_rect = {0};
     const EGLint attribs[] = {EGL_PRESENT_OPAQUE_EXT, EGL_TRUE, EGL_NONE};
 
@@ -221,6 +222,12 @@ static struct wayland_gl_drawable *wayland_gl_drawable_create(HWND hwnd, int for
      * target render surface. */
     if (!(gl->client = get_client_surface(hwnd))) goto err;
 
+    tid = NtUserGetWindowThread(hwnd, &pid);
+    if (tid && pid != GetCurrentProcessId())
+    {
+        ERR("Cross process rendering is not supported!\n");
+    }
+
     gl->wl_egl_window = wl_egl_window_create(gl->client->wl_surface,
                                              client_width, client_height);
     if (!gl->wl_egl_window)
diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 03d1ad09db5..97b611dc980 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -69,6 +69,7 @@ static void wine_vk_surface_destroy(struct wayland_client_surface *client)
 static VkResult wayland_vulkan_surface_create(HWND hwnd, const struct vulkan_instance *instance, VkSurfaceKHR *surface, void **private)
 {
     VkResult res;
+    DWORD pid, tid;
     VkWaylandSurfaceCreateInfoKHR create_info_host;
     struct wayland_client_surface *client;
 
@@ -80,6 +81,12 @@ static VkResult wayland_vulkan_surface_create(HWND hwnd, const struct vulkan_ins
         return VK_ERROR_OUT_OF_HOST_MEMORY;
     }
 
+    tid = NtUserGetWindowThread(hwnd, &pid);
+    if (tid && pid != GetCurrentProcessId())
+    {
+        ERR("Cross process rendering is not supported!\n");
+    }
+
     create_info_host.sType = VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR;
     create_info_host.pNext = NULL;
     create_info_host.flags = 0; /* reserved */
-- 
2.49.0

From c0be63f3c47a15449506ff5b6ad7f0b08290ea3d Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sat, 28 Jun 2025 20:25:21 -0400
Subject: [PATCH 153/159] HACK: win32u: Place windows on the vscreen.

---
 dlls/win32u/window.c | 38 +++++++++++++++++++++++++++++++++++++-
 1 file changed, 37 insertions(+), 1 deletion(-)

diff --git a/dlls/win32u/window.c b/dlls/win32u/window.c
index 68fd577a390..199160c9866 100644
--- a/dlls/win32u/window.c
+++ b/dlls/win32u/window.c
@@ -2097,11 +2097,47 @@ static BOOL apply_window_pos( HWND hwnd, HWND insert_after, UINT swp_flags, stru
     WND *win;
     HWND owner_hint, surface_win = 0, parent = NtUserGetAncestor( hwnd, GA_PARENT );
     BOOL ret, is_fullscreen, is_layered, is_child;
-    struct window_rects old_rects;
+    struct window_rects old_rects, adjusted;
     RECT extra_rects[3];
     struct window_surface *old_surface;
     UINT raw_dpi_num, raw_dpi_den, monitor_dpi;
 
+    /* HACK: move windows within the virtual screen on winewayland */
+    if (user_driver->pHasWindowManager("waylanddrv"))
+    {
+        RECT temp;
+        RECT virtual_screen = get_virtual_screen_rect( get_thread_dpi(), MDT_DEFAULT );
+
+        adjusted = *new_rects;
+
+        intersect_rect(&temp, &virtual_screen, &adjusted.window);
+
+        /* we aren't off screen */
+        if (!IsRectEmpty(&temp))
+        {
+            LONG offset_x = 0, offset_y = 0;
+
+            if (adjusted.window.bottom > virtual_screen.bottom)
+                offset_y = virtual_screen.bottom - adjusted.window.bottom;
+            else if (virtual_screen.top > adjusted.window.top)
+                offset_y = virtual_screen.top - adjusted.window.top;
+
+            if (adjusted.window.right > virtual_screen.right)
+                offset_x = virtual_screen.right - adjusted.window.right;
+            else if (virtual_screen.left > adjusted.window.left)
+                offset_x = virtual_screen.left - adjusted.window.left;
+
+            OffsetRect(&adjusted.client, offset_x, offset_y);
+            OffsetRect(&adjusted.visible, offset_x, offset_y);
+            OffsetRect(&adjusted.window, offset_x, offset_y);
+
+            TRACE("Adjusted window rects: %s\n", debugstr_window_rects(&adjusted));
+            TRACE("Original window rects: %s\n", debugstr_window_rects(new_rects));
+
+            new_rects = &adjusted;
+        }
+    }
+
     is_layered = new_surface && new_surface->alpha_mask;
     is_fullscreen = is_window_rect_full_screen( &new_rects->visible, get_thread_dpi() );
     is_child = parent && parent != NtUserGetDesktopWindow();
-- 
2.49.0

From 821a0a57c6117f9e283c85e5c6f7d2b70581a526 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sun, 29 Jun 2025 10:28:03 -0400
Subject: [PATCH 154/159] fixup! win32u: Don't move windows when it's
 impossible.

---
 dlls/win32u/window.c | 27 ++++++++++++++++++---------
 1 file changed, 18 insertions(+), 9 deletions(-)

diff --git a/dlls/win32u/window.c b/dlls/win32u/window.c
index 199160c9866..e95e739bad8 100644
--- a/dlls/win32u/window.c
+++ b/dlls/win32u/window.c
@@ -2117,15 +2117,24 @@ static BOOL apply_window_pos( HWND hwnd, HWND insert_after, UINT swp_flags, stru
         {
             LONG offset_x = 0, offset_y = 0;
 
-            if (adjusted.window.bottom > virtual_screen.bottom)
-                offset_y = virtual_screen.bottom - adjusted.window.bottom;
-            else if (virtual_screen.top > adjusted.window.top)
-                offset_y = virtual_screen.top - adjusted.window.top;
-
-            if (adjusted.window.right > virtual_screen.right)
-                offset_x = virtual_screen.right - adjusted.window.right;
-            else if (virtual_screen.left > adjusted.window.left)
-                offset_x = virtual_screen.left - adjusted.window.left;
+            if (adjusted.window.bottom - adjusted.window.top <=
+                virtual_screen.bottom - virtual_screen.top)
+            {
+                if (adjusted.window.bottom > virtual_screen.bottom)
+                    offset_y = virtual_screen.bottom - adjusted.window.bottom;
+                else if (virtual_screen.top > adjusted.window.top)
+                    offset_y = virtual_screen.top - adjusted.window.top;
+            }
+
+            if (adjusted.window.right - adjusted.window.left <=
+                virtual_screen.right - virtual_screen.left)
+            {
+                if (adjusted.window.right > virtual_screen.right)
+                    offset_x = virtual_screen.right - adjusted.window.right;
+                else if (virtual_screen.left > adjusted.window.left)
+                    offset_x = virtual_screen.left - adjusted.window.left;
+            }
+
 
             OffsetRect(&adjusted.client, offset_x, offset_y);
             OffsetRect(&adjusted.visible, offset_x, offset_y);
-- 
2.49.0

From aab79b2738d7410332760a1b7827cd283f0aac93 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 30 May 2025 10:24:20 +0200
Subject: [PATCH 155/159] winewayland: Switch client surfaces when presenting.

---
 dlls/winewayland.drv/opengl.c     |  5 +++-
 dlls/winewayland.drv/vulkan.c     |  5 +++-
 dlls/winewayland.drv/waylanddrv.h |  1 +
 dlls/winewayland.drv/window.c     | 41 +++++++++++--------------------
 4 files changed, 23 insertions(+), 29 deletions(-)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index c6a84a4f1bd..cd5c20fa3fe 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -220,7 +220,8 @@ static struct wayland_gl_drawable *wayland_gl_drawable_create(HWND hwnd, int for
     /* Get the client surface for the HWND. If don't have a wayland surface
      * (e.g., HWND_MESSAGE windows) just create a dummy surface to act as the
      * target render surface. */
-    if (!(gl->client = get_client_surface(hwnd))) goto err;
+    if (!(gl->client = wayland_client_surface_create(hwnd))) goto err;
+    set_client_surface(hwnd, gl->client);
 
     tid = NtUserGetWindowThread(hwnd, &pid);
     if (tid && pid != GetCurrentProcessId())
@@ -729,6 +730,8 @@ static BOOL wayland_wglSwapBuffers(HDC hdc)
 
     if (ctx) wgl_context_refresh(ctx);
     ensure_window_surface_contents(toplevel);
+    set_client_surface(hwnd, gl->client);
+
     /* Although all the EGL surfaces we create are double-buffered, we want to
      * use some as single-buffered, so avoid swapping those. */
     if (gl->double_buffered) p_eglSwapBuffers(egl_display, gl->surface);
diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 97b611dc980..ade62d0df22 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -75,7 +75,7 @@ static VkResult wayland_vulkan_surface_create(HWND hwnd, const struct vulkan_ins
 
     TRACE("%p %p %p %p\n", hwnd, instance, surface, private);
 
-    if (!(client = get_client_surface(hwnd)))
+    if (!(client = wayland_client_surface_create(hwnd)))
     {
         ERR("Failed to create client surface for hwnd=%p\n", hwnd);
         return VK_ERROR_OUT_OF_HOST_MEMORY;
@@ -103,6 +103,7 @@ static VkResult wayland_vulkan_surface_create(HWND hwnd, const struct vulkan_ins
         return res;
     }
 
+    set_client_surface(hwnd, client);
     *private = client;
 
     TRACE("Created surface=0x%s, private=%p\n", wine_dbgstr_longlong(*surface), *private);
@@ -128,8 +129,10 @@ static void wayland_vulkan_surface_update(HWND hwnd, void *private)
 
 static void wayland_vulkan_surface_presented(HWND hwnd, void *private, VkResult result)
 {
+    struct wayland_client_surface *client = private;
     HWND toplevel = NtUserGetAncestor(hwnd, GA_ROOT);
     ensure_window_surface_contents(toplevel);
+    set_client_surface(hwnd, client);
 }
 
 static BOOL wayland_vulkan_surface_enable_fshack(HWND hwnd, void *private)
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 44e478a91d8..15e21848b37 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -440,6 +440,7 @@ struct wayland_win_data *wayland_win_data_get_nolock(HWND hwnd);
 void wayland_win_data_release(struct wayland_win_data *data);
 
 struct wayland_client_surface *get_client_surface(HWND hwnd);
+void set_client_surface(HWND hwnd, struct wayland_client_surface *client);
 BOOL set_window_surface_contents(HWND hwnd, struct wayland_shm_buffer *shm_buffer, HRGN damage_region);
 struct wayland_shm_buffer *get_window_surface_contents(HWND hwnd);
 void ensure_window_surface_contents(HWND hwnd);
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 32b1a00f6cd..26735e3fb51 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -810,42 +810,29 @@ void WAYLAND_FlashWindowEx(FLASHWINFO *info)
     }
 }
 
-/**********************************************************************
- *          get_client_surface
- */
-struct wayland_client_surface *get_client_surface(HWND hwnd)
+void set_client_surface(HWND hwnd, struct wayland_client_surface *new_client)
 {
-    struct wayland_client_surface *client;
+    struct wayland_client_surface *old_client;
     struct wayland_win_data *data;
     HWND toplevel = NtUserGetAncestor(hwnd, GA_ROOT);
 
-    if ((data = wayland_win_data_get(hwnd)))
-    {
-        /* ownership is shared with one of the callers, the last caller to release
-         * its reference will also destroy it and clear our pointer. */
-        if ((client = data->client_surface)) InterlockedIncrement(&client->ref);
-    }
-    else
-    {
-        client = NULL;
-    }
+    /* ownership is shared with the callers, the last caller to release
+     * its reference will also destroy it and clear our pointer. */
 
-    if (!client && !(client = wayland_client_surface_create(hwnd)))
-    {
-        if (data) wayland_win_data_release(data);
-        return NULL;
-    }
-    if (!data) return client;
+    if (!(data = wayland_win_data_get(hwnd))) return;
 
-    if (toplevel && NtUserIsWindowVisible(hwnd))
-        wayland_client_surface_attach(client, toplevel);
-    else
-        wayland_client_surface_detach(client);
+    if ((old_client = data->client_surface))
+        wayland_client_surface_detach(old_client);
 
-    if (!data->client_surface) data->client_surface = client;
+    if ((data->client_surface = new_client))
+    {
+        if (toplevel && NtUserIsWindowVisible(hwnd))
+            wayland_client_surface_attach(new_client, toplevel);
+        else
+            wayland_client_surface_detach(new_client);
+    }
 
     wayland_win_data_release(data);
-    return client;
 }
 
 BOOL set_window_surface_contents(HWND hwnd, struct wayland_shm_buffer *shm_buffer, HRGN damage_region)
-- 
2.49.0

From 84582cd00ce82df45113986b81718f9fb9d425f2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 30 Jun 2025 09:59:16 +0200
Subject: [PATCH 156/159] winewayland: Only detach/attach client surface if it
 is different.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=58423
---
 dlls/winewayland.drv/window.c | 19 +++++++++++--------
 1 file changed, 11 insertions(+), 8 deletions(-)

diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 26735e3fb51..b84a0a42edb 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -821,15 +821,18 @@ void set_client_surface(HWND hwnd, struct wayland_client_surface *new_client)
 
     if (!(data = wayland_win_data_get(hwnd))) return;
 
-    if ((old_client = data->client_surface))
-        wayland_client_surface_detach(old_client);
-
-    if ((data->client_surface = new_client))
+    if (new_client != data->client_surface)
     {
-        if (toplevel && NtUserIsWindowVisible(hwnd))
-            wayland_client_surface_attach(new_client, toplevel);
-        else
-            wayland_client_surface_detach(new_client);
+        if ((old_client = data->client_surface))
+            wayland_client_surface_detach(old_client);
+
+        if ((data->client_surface = new_client))
+        {
+            if (toplevel && NtUserIsWindowVisible(hwnd))
+                wayland_client_surface_attach(new_client, toplevel);
+            else
+                wayland_client_surface_detach(new_client);
+        }
     }
 
     wayland_win_data_release(data);
-- 
2.49.0

From 3adb52bfaccba96402f16c21cf4e3ab1a9b2d458 Mon Sep 17 00:00:00 2001
From: Louis Lenders <xerox.xerox2000x@gmail.com>
Date: Sun, 25 May 2025 13:34:13 +0200
Subject: [PATCH 157/159] pdh: Add stub for PdhEnumObjects{A,W}.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=58255
---
 dlls/pdh/pdh.spec   |  4 ++--
 dlls/pdh/pdh_main.c | 20 ++++++++++++++++++++
 2 files changed, 22 insertions(+), 2 deletions(-)

diff --git a/dlls/pdh/pdh.spec b/dlls/pdh/pdh.spec
index 854b8004399..6e0e07ace4b 100644
--- a/dlls/pdh/pdh.spec
+++ b/dlls/pdh/pdh.spec
@@ -32,10 +32,10 @@
 @ stub PdhEnumObjectItemsHA
 @ stub PdhEnumObjectItemsHW
 @ stdcall PdhEnumObjectItemsW(wstr wstr wstr ptr ptr ptr ptr long long)
-@ stub PdhEnumObjectsA
+@ stdcall PdhEnumObjectsA(str str ptr ptr long long)
 @ stub PdhEnumObjectsHA
 @ stub PdhEnumObjectsHW
-@ stub PdhEnumObjectsW
+@ stdcall PdhEnumObjectsW(wstr wstr ptr ptr long long)
 @ stdcall PdhExpandCounterPathA(str ptr ptr)
 @ stdcall PdhExpandCounterPathW(wstr ptr ptr)
 @ stdcall PdhExpandWildCardPathA(str str ptr ptr long)
diff --git a/dlls/pdh/pdh_main.c b/dlls/pdh/pdh_main.c
index f915f509177..19092107dc6 100644
--- a/dlls/pdh/pdh_main.c
+++ b/dlls/pdh/pdh_main.c
@@ -1309,3 +1309,23 @@ PDH_STATUS WINAPI PdhConnectMachineA(const char *name)
     FIXME("%s: stub\n", debugstr_a(name));
     return PDH_NOT_IMPLEMENTED;
 }
+
+/***********************************************************************
+ *              PdhEnumObjectsA   (PDH.@)
+ */
+PDH_STATUS WINAPI PdhEnumObjectsA(const char *source, const char *machine, char *list,
+                                  DWORD *size, DWORD detail, BOOL refresh)
+{
+    FIXME("%s %s %p %p %lu %d: stub\n", debugstr_a(source),debugstr_a(machine), list, size, detail, refresh);
+    return PDH_NOT_IMPLEMENTED;
+}
+
+/***********************************************************************
+ *              PdhEnumObjectsW   (PDH.@)
+ */
+PDH_STATUS WINAPI PdhEnumObjectsW(const WCHAR *source, const WCHAR *machine, WCHAR *list,
+                                  DWORD *size, DWORD detail, BOOL refresh)
+{
+    FIXME("%s %s %p %p %lu %d: stub\n", debugstr_w(source),debugstr_w(machine), list, size, detail, refresh);
+    return PDH_NOT_IMPLEMENTED;
+}
-- 
2.49.0

From 29746c74d0fb33ebbe0275aa0590283d7660aa6f Mon Sep 17 00:00:00 2001
From: Louis Lenders <xerox.xerox2000x@gmail.com>
Date: Wed, 28 May 2025 13:24:50 +0200
Subject: [PATCH 158/159] pdh: Add stub for PdhGetRawCounterArrayW{A,W}.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=58285
---
 dlls/pdh/pdh.spec   |  4 ++--
 dlls/pdh/pdh_main.c | 18 ++++++++++++++++++
 include/pdh.h       | 15 +++++++++++++++
 3 files changed, 35 insertions(+), 2 deletions(-)

diff --git a/dlls/pdh/pdh.spec b/dlls/pdh/pdh.spec
index 6e0e07ace4b..93db4f56eea 100644
--- a/dlls/pdh/pdh.spec
+++ b/dlls/pdh/pdh.spec
@@ -65,8 +65,8 @@
 @ stdcall PdhGetLogFileTypeA(str ptr)
 @ stdcall PdhGetLogFileTypeW(wstr ptr)
 @ stub PdhGetLogSetGUID
-@ stub PdhGetRawCounterArrayA
-@ stub PdhGetRawCounterArrayW
+@ stdcall PdhGetRawCounterArrayA(ptr ptr ptr ptr)
+@ stdcall PdhGetRawCounterArrayW(ptr ptr ptr ptr)
 @ stdcall PdhGetRawCounterValue(ptr ptr ptr)
 @ stub PdhIsRealTimeQuery
 @ stub PdhListLogFileHeaderA
diff --git a/dlls/pdh/pdh_main.c b/dlls/pdh/pdh_main.c
index 19092107dc6..8354bddcdb0 100644
--- a/dlls/pdh/pdh_main.c
+++ b/dlls/pdh/pdh_main.c
@@ -1329,3 +1329,21 @@ PDH_STATUS WINAPI PdhEnumObjectsW(const WCHAR *source, const WCHAR *machine, WCH
     FIXME("%s %s %p %p %lu %d: stub\n", debugstr_w(source),debugstr_w(machine), list, size, detail, refresh);
     return PDH_NOT_IMPLEMENTED;
 }
+
+/***********************************************************************
+ *              PdhGetRawCounterArrayA   (PDH.@)
+ */
+PDH_STATUS WINAPI PdhGetRawCounterArrayA(PDH_HCOUNTER counter, DWORD *size, DWORD *count, PDH_RAW_COUNTER_ITEM_A *buffer)
+{
+    FIXME("%p %p %p %p: stub\n", counter, size, count, buffer);
+    return PDH_NOT_IMPLEMENTED;
+}
+
+/***********************************************************************
+ *              PdhGetRawCounterArrayW   (PDH.@)
+ */
+PDH_STATUS WINAPI PdhGetRawCounterArrayW(PDH_HCOUNTER counter, DWORD *size, DWORD *count, PDH_RAW_COUNTER_ITEM_W *buffer)
+{
+    FIXME("%p %p %p %p: stub\n", counter, size, count, buffer);
+    return PDH_NOT_IMPLEMENTED;
+}
diff --git a/include/pdh.h b/include/pdh.h
index 5a6d89e91c9..32e29acedf0 100644
--- a/include/pdh.h
+++ b/include/pdh.h
@@ -201,6 +201,18 @@ typedef struct _PDH_FMT_COUNTERVALUE_ITEM_W
     PDH_FMT_COUNTERVALUE FmtValue;
 } PDH_FMT_COUNTERVALUE_ITEM_W, *PPDH_FMT_COUNTERVALUE_ITEM_W;
 
+typedef struct _PDH_RAW_COUNTER_ITEM_A
+{
+    LPSTR szName;
+    PDH_RAW_COUNTER RawValue;
+} PDH_RAW_COUNTER_ITEM_A,*PPDH_RAW_COUNTER_ITEM_A;
+
+typedef struct _PDH_RAW_COUNTER_ITEM_W
+{
+    LPWSTR szName;
+    PDH_RAW_COUNTER RawValue;
+} PDH_RAW_COUNTER_ITEM_W,*PPDH_RAW_COUNTER_ITEM_W;
+
 DECL_PDH_TYPE_AW(PDH_COUNTER_INFO)
 DECL_PDH_TYPE_AW(PPDH_COUNTER_INFO)
 
@@ -231,6 +243,9 @@ PDH_STATUS WINAPI PdhGetCounterInfoW(PDH_HCOUNTER, BOOLEAN, LPDWORD, PPDH_COUNTE
 PDH_STATUS WINAPI PdhGetCounterTimeBase(PDH_HCOUNTER, LONGLONG *);
 PDH_STATUS WINAPI PdhGetDllVersion(LPDWORD);
 PDH_STATUS WINAPI PdhGetFormattedCounterValue(PDH_HCOUNTER, DWORD, LPDWORD, PPDH_FMT_COUNTERVALUE);
+PDH_STATUS WINAPI PdhGetRawCounterArrayA(PDH_HCOUNTER, LPDWORD, LPDWORD, PPDH_RAW_COUNTER_ITEM_A);
+PDH_STATUS WINAPI PdhGetRawCounterArrayW(PDH_HCOUNTER, LPDWORD, LPDWORD, PPDH_RAW_COUNTER_ITEM_W);
+#define    PdhGetRawCounterArray WINELIB_NAME_AW(PdhGetRawCounterArray)
 PDH_STATUS WINAPI PdhGetRawCounterValue(PDH_HCOUNTER, LPDWORD, PPDH_RAW_COUNTER);
 PDH_STATUS WINAPI PdhLookupPerfIndexByNameA(LPCSTR, LPCSTR, LPDWORD);
 PDH_STATUS WINAPI PdhLookupPerfIndexByNameW(LPCWSTR, LPCWSTR, LPDWORD);
-- 
2.49.0

From c6fb68f69aa8211dfce7ed476746e0364c14f744 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Tue, 1 Jul 2025 22:13:04 -0400
Subject: [PATCH 159/159] atidxx: Return error with anti-lag 2 usage.

---
 dlls/atidxx64/main.c | 16 +++++++++++++---
 1 file changed, 13 insertions(+), 3 deletions(-)

diff --git a/dlls/atidxx64/main.c b/dlls/atidxx64/main.c
index 5d4def2d383..b1f3240b219 100644
--- a/dlls/atidxx64/main.c
+++ b/dlls/atidxx64/main.c
@@ -628,13 +628,23 @@ HRESULT CDECL AmdDxExtCreate11(ID3D11Device *device, IAmdDxExt **ext)
     HRESULT ret;
     AmdDxExt *obj;
     ID3D11VkExtDevice *ext_device;
+    UINT64 id;
     TRACE("%p %p\n", device, ext);
 
-    if((ret = load_d3d11()) != S_OK)
+    if (!ext) return E_INVALIDARG;
+
+    id = (ULONG_PTR)*ext;
+
+    if (id == 0xbf380ebc5ab4d0a6ull)
+    {
+        ERR("D3D11 Anti-Lag 2 is not supported!\n");
+        return E_NOTIMPL;
+    }
+
+    if ((ret = load_d3d11()))
         return ret;
 
-    obj = malloc(sizeof(AmdDxExt));
-    if(!obj)
+    if (!(obj = malloc(sizeof(AmdDxExt))))
         return E_OUTOFMEMORY;
 
     obj->device = device;
-- 
2.49.0


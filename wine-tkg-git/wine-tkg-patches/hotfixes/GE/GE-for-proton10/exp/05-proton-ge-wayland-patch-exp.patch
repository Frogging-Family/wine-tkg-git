From 24ba97ad6054a1dabc258a7338a7ea5d1e3b002b Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sun, 4 May 2025 14:13:08 -0400
Subject: [PATCH 01/78] use surfaceless for GST

---
 dlls/winegstreamer/unixlib.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/dlls/winegstreamer/unixlib.c b/dlls/winegstreamer/unixlib.c
index 0d1b3b6f65a..cd631535b50 100644
--- a/dlls/winegstreamer/unixlib.c
+++ b/dlls/winegstreamer/unixlib.c
@@ -278,7 +278,6 @@ NTSTATUS wg_init_gstreamer(void *arg)
     if (params->err_on)
         setenv("GST_DEBUG", "1", FALSE);
     setenv("GST_DEBUG_NO_COLOR", "1", FALSE);
-    setenv("GST_GL_WINDOW", "x11", 1);
 
     /* GStreamer installs a temporary SEGV handler when it loads plugins
      * to initialize its registry calling exit(-1) when any fault is caught.
@@ -322,7 +321,7 @@ NTSTATUS wg_init_gstreamer(void *arg)
     GST_INFO("GStreamer library version %s; wine built with %d.%d.%d.",
             gst_version_string(), GST_VERSION_MAJOR, GST_VERSION_MINOR, GST_VERSION_MICRO);
 
-    if (!(gl_display = gst_gl_display_new()))
+    if (!(gl_display = gst_gl_display_new_with_type(GST_GL_DISPLAY_TYPE_EGL_SURFACELESS)))
         GST_ERROR("Failed to create OpenGL display");
     else
     {
-- 
2.49.0

From 5ebf37b35b60fe7779736f4b4683321cfe9b0417 Mon Sep 17 00:00:00 2001
From: Attila Fidan <dev@print0.net>
Date: Sun, 2 Feb 2025 07:53:36 +0000
Subject: [PATCH 02/78] winewayland: Enable/disable the zwp_text_input_v3
 object.

---
 dlls/winewayland.drv/Makefile.in              |   2 +
 .../text-input-unstable-v3.xml                | 457 ++++++++++++++++++
 dlls/winewayland.drv/wayland.c                |  12 +
 dlls/winewayland.drv/wayland_text_input.c     | 109 +++++
 dlls/winewayland.drv/waylanddrv.h             |  16 +
 5 files changed, 596 insertions(+)
 create mode 100644 dlls/winewayland.drv/text-input-unstable-v3.xml
 create mode 100644 dlls/winewayland.drv/wayland_text_input.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 9ad1ad6889d..9129a3f2839 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -9,6 +9,7 @@ SOURCES = \
 	opengl.c \
 	pointer-constraints-unstable-v1.xml \
 	relative-pointer-unstable-v1.xml \
+	text-input-unstable-v3.xml \
 	version.rc \
 	viewporter.xml \
 	vulkan.c \
@@ -17,6 +18,7 @@ SOURCES = \
 	wayland_output.c \
 	wayland_pointer.c \
 	wayland_surface.c \
+	wayland_text_input.c \
 	waylanddrv_main.c \
 	window.c \
 	window_surface.c \
diff --git a/dlls/winewayland.drv/text-input-unstable-v3.xml b/dlls/winewayland.drv/text-input-unstable-v3.xml
new file mode 100644
index 00000000000..1fae54d7ba7
--- /dev/null
+++ b/dlls/winewayland.drv/text-input-unstable-v3.xml
@@ -0,0 +1,457 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<protocol name="text_input_unstable_v3">
+  <copyright>
+    Copyright © 2012, 2013 Intel Corporation
+    Copyright © 2015, 2016 Jan Arne Petersen
+    Copyright © 2017, 2018 Red Hat, Inc.
+    Copyright © 2018       Purism SPC
+
+    Permission to use, copy, modify, distribute, and sell this
+    software and its documentation for any purpose is hereby granted
+    without fee, provided that the above copyright notice appear in
+    all copies and that both that copyright notice and this permission
+    notice appear in supporting documentation, and that the name of
+    the copyright holders not be used in advertising or publicity
+    pertaining to distribution of the software without specific,
+    written prior permission.  The copyright holders make no
+    representations about the suitability of this software for any
+    purpose.  It is provided "as is" without express or implied
+    warranty.
+
+    THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+    SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+    FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+    SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+    AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+    ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
+    THIS SOFTWARE.
+  </copyright>
+
+  <description summary="Protocol for composing text">
+    This protocol allows compositors to act as input methods and to send text
+    to applications. A text input object is used to manage state of what are
+    typically text entry fields in the application.
+
+    This document adheres to the RFC 2119 when using words like "must",
+    "should", "may", etc.
+
+    Warning! The protocol described in this file is experimental and
+    backward incompatible changes may be made. Backward compatible changes
+    may be added together with the corresponding interface version bump.
+    Backward incompatible changes are done by bumping the version number in
+    the protocol and interface names and resetting the interface version.
+    Once the protocol is to be declared stable, the 'z' prefix and the
+    version number in the protocol and interface names are removed and the
+    interface version number is reset.
+  </description>
+
+  <interface name="zwp_text_input_v3" version="1">
+    <description summary="text input">
+      The zwp_text_input_v3 interface represents text input and input methods
+      associated with a seat. It provides enter/leave events to follow the
+      text input focus for a seat.
+
+      Requests are used to enable/disable the text-input object and set
+      state information like surrounding and selected text or the content type.
+      The information about the entered text is sent to the text-input object
+      via the preedit_string and commit_string events.
+
+      Text is valid UTF-8 encoded, indices and lengths are in bytes. Indices
+      must not point to middle bytes inside a code point: they must either
+      point to the first byte of a code point or to the end of the buffer.
+      Lengths must be measured between two valid indices.
+
+      Focus moving throughout surfaces will result in the emission of
+      zwp_text_input_v3.enter and zwp_text_input_v3.leave events. The focused
+      surface must commit zwp_text_input_v3.enable and
+      zwp_text_input_v3.disable requests as the keyboard focus moves across
+      editable and non-editable elements of the UI. Those two requests are not
+      expected to be paired with each other, the compositor must be able to
+      handle consecutive series of the same request.
+
+      State is sent by the state requests (set_surrounding_text,
+      set_content_type and set_cursor_rectangle) and a commit request. After an
+      enter event or disable request all state information is invalidated and
+      needs to be resent by the client.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="Destroy the wp_text_input">
+        Destroy the wp_text_input object. Also disables all surfaces enabled
+        through this wp_text_input object.
+      </description>
+    </request>
+
+    <request name="enable">
+      <description summary="Request text input to be enabled">
+        Requests text input on the surface previously obtained from the enter
+        event.
+
+        This request must be issued every time the active text input changes
+        to a new one, including within the current surface. Use
+        zwp_text_input_v3.disable when there is no longer any input focus on
+        the current surface.
+
+        Clients must not enable more than one text input on the single seat
+        and should disable the current text input before enabling the new one.
+        At most one instance of text input may be in enabled state per instance,
+        Requests to enable the another text input when some text input is active
+        must be ignored by compositor.
+
+        This request resets all state associated with previous enable, disable,
+        set_surrounding_text, set_text_change_cause, set_content_type, and
+        set_cursor_rectangle requests, as well as the state associated with
+        preedit_string, commit_string, and delete_surrounding_text events.
+
+        The set_surrounding_text, set_content_type and set_cursor_rectangle
+        requests must follow if the text input supports the necessary
+        functionality.
+
+        State set with this request is double-buffered. It will get applied on
+        the next zwp_text_input_v3.commit request, and stay valid until the
+        next committed enable or disable request.
+
+        The changes must be applied by the compositor after issuing a
+        zwp_text_input_v3.commit request.
+      </description>
+    </request>
+
+    <request name="disable">
+      <description summary="Disable text input on a surface">
+        Explicitly disable text input on the current surface (typically when
+        there is no focus on any text entry inside the surface).
+
+        State set with this request is double-buffered. It will get applied on
+        the next zwp_text_input_v3.commit request.
+      </description>
+    </request>
+
+    <request name="set_surrounding_text">
+      <description summary="sets the surrounding text">
+        Sets the surrounding plain text around the input, excluding the preedit
+        text.
+
+        The client should notify the compositor of any changes in any of the
+        values carried with this request, including changes caused by handling
+        incoming text-input events as well as changes caused by other
+        mechanisms like keyboard typing.
+
+        If the client is unaware of the text around the cursor, it should not
+        issue this request, to signify lack of support to the compositor.
+
+        Text is UTF-8 encoded, and should include the cursor position, the
+        complete selection and additional characters before and after them.
+        There is a maximum length of wayland messages, so text can not be
+        longer than 4000 bytes.
+
+        Cursor is the byte offset of the cursor within text buffer.
+
+        Anchor is the byte offset of the selection anchor within text buffer.
+        If there is no selected text, anchor is the same as cursor.
+
+        If any preedit text is present, it is replaced with a cursor for the
+        purpose of this event.
+
+        Values set with this request are double-buffered. They will get applied
+        on the next zwp_text_input_v3.commit request, and stay valid until the
+        next committed enable or disable request.
+
+        The initial state for affected fields is empty, meaning that the text
+        input does not support sending surrounding text. If the empty values
+        get applied, subsequent attempts to change them may have no effect.
+      </description>
+      <arg name="text" type="string"/>
+      <arg name="cursor" type="int"/>
+      <arg name="anchor" type="int"/>
+    </request>
+
+    <enum name="change_cause">
+      <description summary="text change reason">
+        Reason for the change of surrounding text or cursor posision.
+      </description>
+      <entry name="input_method" value="0" summary="input method caused the change"/>
+      <entry name="other" value="1" summary="something else than the input method caused the change"/>
+    </enum>
+
+    <request name="set_text_change_cause">
+      <description summary="indicates the cause of surrounding text change">
+        Tells the compositor why the text surrounding the cursor changed.
+
+        Whenever the client detects an external change in text, cursor, or
+        anchor posision, it must issue this request to the compositor. This
+        request is intended to give the input method a chance to update the
+        preedit text in an appropriate way, e.g. by removing it when the user
+        starts typing with a keyboard.
+
+        cause describes the source of the change.
+
+        The value set with this request is double-buffered. It must be applied
+        and reset to initial at the next zwp_text_input_v3.commit request.
+
+        The initial value of cause is input_method.
+      </description>
+      <arg name="cause" type="uint" enum="change_cause"/>
+    </request>
+
+    <enum name="content_hint" bitfield="true">
+      <description summary="content hint">
+        Content hint is a bitmask to allow to modify the behavior of the text
+        input.
+      </description>
+      <entry name="none" value="0x0" summary="no special behavior"/>
+      <entry name="completion" value="0x1" summary="suggest word completions"/>
+      <entry name="spellcheck" value="0x2" summary="suggest word corrections"/>
+      <entry name="auto_capitalization" value="0x4" summary="switch to uppercase letters at the start of a sentence"/>
+      <entry name="lowercase" value="0x8" summary="prefer lowercase letters"/>
+      <entry name="uppercase" value="0x10" summary="prefer uppercase letters"/>
+      <entry name="titlecase" value="0x20" summary="prefer casing for titles and headings (can be language dependent)"/>
+      <entry name="hidden_text" value="0x40" summary="characters should be hidden"/>
+      <entry name="sensitive_data" value="0x80" summary="typed text should not be stored"/>
+      <entry name="latin" value="0x100" summary="just Latin characters should be entered"/>
+      <entry name="multiline" value="0x200" summary="the text input is multiline"/>
+    </enum>
+
+    <enum name="content_purpose">
+      <description summary="content purpose">
+        The content purpose allows to specify the primary purpose of a text
+        input.
+
+        This allows an input method to show special purpose input panels with
+        extra characters or to disallow some characters.
+      </description>
+      <entry name="normal" value="0" summary="default input, allowing all characters"/>
+      <entry name="alpha" value="1" summary="allow only alphabetic characters"/>
+      <entry name="digits" value="2" summary="allow only digits"/>
+      <entry name="number" value="3" summary="input a number (including decimal separator and sign)"/>
+      <entry name="phone" value="4" summary="input a phone number"/>
+      <entry name="url" value="5" summary="input an URL"/>
+      <entry name="email" value="6" summary="input an email address"/>
+      <entry name="name" value="7" summary="input a name of a person"/>
+      <entry name="password" value="8" summary="input a password (combine with sensitive_data hint)"/>
+      <entry name="pin" value="9" summary="input is a numeric password (combine with sensitive_data hint)"/>
+      <entry name="date" value="10" summary="input a date"/>
+      <entry name="time" value="11" summary="input a time"/>
+      <entry name="datetime" value="12" summary="input a date and time"/>
+      <entry name="terminal" value="13" summary="input for a terminal"/>
+    </enum>
+
+    <request name="set_content_type">
+      <description summary="set content purpose and hint">
+        Sets the content purpose and content hint. While the purpose is the
+        basic purpose of an input field, the hint flags allow to modify some of
+        the behavior.
+
+        Values set with this request are double-buffered. They will get applied
+        on the next zwp_text_input_v3.commit request.
+        Subsequent attempts to update them may have no effect. The values
+        remain valid until the next committed enable or disable request.
+
+        The initial value for hint is none, and the initial value for purpose
+        is normal.
+      </description>
+      <arg name="hint" type="uint" enum="content_hint"/>
+      <arg name="purpose" type="uint" enum="content_purpose"/>
+    </request>
+
+    <request name="set_cursor_rectangle">
+      <description summary="set cursor position">
+        Marks an area around the cursor as a x, y, width, height rectangle in
+        surface local coordinates.
+
+        Allows the compositor to put a window with word suggestions near the
+        cursor, without obstructing the text being input.
+
+        If the client is unaware of the position of edited text, it should not
+        issue this request, to signify lack of support to the compositor.
+
+        Values set with this request are double-buffered. They will get applied
+        on the next zwp_text_input_v3.commit request, and stay valid until the
+        next committed enable or disable request.
+
+        The initial values describing a cursor rectangle are empty. That means
+        the text input does not support describing the cursor area. If the
+        empty values get applied, subsequent attempts to change them may have
+        no effect.
+      </description>
+      <arg name="x" type="int"/>
+      <arg name="y" type="int"/>
+      <arg name="width" type="int"/>
+      <arg name="height" type="int"/>
+    </request>
+
+    <request name="commit">
+      <description summary="commit state">
+        Atomically applies state changes recently sent to the compositor.
+
+        The commit request establishes and updates the state of the client, and
+        must be issued after any changes to apply them.
+
+        Text input state (enabled status, content purpose, content hint,
+        surrounding text and change cause, cursor rectangle) is conceptually
+        double-buffered within the context of a text input, i.e. between a
+        committed enable request and the following committed enable or disable
+        request.
+
+        Protocol requests modify the pending state, as opposed to the current
+        state in use by the input method. A commit request atomically applies
+        all pending state, replacing the current state. After commit, the new
+        pending state is as documented for each related request.
+
+        Requests are applied in the order of arrival.
+
+        Neither current nor pending state are modified unless noted otherwise.
+
+        The compositor must count the number of commit requests coming from
+        each zwp_text_input_v3 object and use the count as the serial in done
+        events.
+      </description>
+    </request>
+
+    <event name="enter">
+      <description summary="enter event">
+        Notification that this seat's text-input focus is on a certain surface.
+
+        If client has created multiple text input objects, compositor must send
+        this event to all of them.
+
+        When the seat has the keyboard capability the text-input focus follows
+        the keyboard focus. This event sets the current surface for the
+        text-input object.
+      </description>
+      <arg name="surface" type="object" interface="wl_surface"/>
+    </event>
+
+    <event name="leave">
+      <description summary="leave event">
+        Notification that this seat's text-input focus is no longer on a
+        certain surface. The client should reset any preedit string previously
+        set.
+
+        The leave notification clears the current surface. It is sent before
+        the enter notification for the new focus. After leave event, compositor
+        must ignore requests from any text input instances until next enter
+        event.
+
+        When the seat has the keyboard capability the text-input focus follows
+        the keyboard focus.
+      </description>
+      <arg name="surface" type="object" interface="wl_surface"/>
+    </event>
+
+    <event name="preedit_string">
+      <description summary="pre-edit">
+        Notify when a new composing text (pre-edit) should be set at the
+        current cursor position. Any previously set composing text must be
+        removed. Any previously existing selected text must be removed.
+
+        The argument text contains the pre-edit string buffer.
+
+        The parameters cursor_begin and cursor_end are counted in bytes
+        relative to the beginning of the submitted text buffer. Cursor should
+        be hidden when both are equal to -1.
+
+        They could be represented by the client as a line if both values are
+        the same, or as a text highlight otherwise.
+
+        Values set with this event are double-buffered. They must be applied
+        and reset to initial on the next zwp_text_input_v3.done event.
+
+        The initial value of text is an empty string, and cursor_begin,
+        cursor_end and cursor_hidden are all 0.
+      </description>
+      <arg name="text" type="string" allow-null="true"/>
+      <arg name="cursor_begin" type="int"/>
+      <arg name="cursor_end" type="int"/>
+    </event>
+
+    <event name="commit_string">
+      <description summary="text commit">
+        Notify when text should be inserted into the editor widget. The text to
+        commit could be either just a single character after a key press or the
+        result of some composing (pre-edit).
+
+        Values set with this event are double-buffered. They must be applied
+        and reset to initial on the next zwp_text_input_v3.done event.
+
+        The initial value of text is an empty string.
+      </description>
+      <arg name="text" type="string" allow-null="true"/>
+    </event>
+
+    <event name="delete_surrounding_text">
+      <description summary="delete surrounding text">
+        Notify when the text around the current cursor position should be
+        deleted.
+
+        Before_length and after_length are the number of bytes before and after
+        the current cursor index (excluding the selection) to delete.
+
+        If a preedit text is present, in effect before_length is counted from
+        the beginning of it, and after_length from its end (see done event
+        sequence).
+
+        Values set with this event are double-buffered. They must be applied
+        and reset to initial on the next zwp_text_input_v3.done event.
+
+        The initial values of both before_length and after_length are 0.
+      </description>
+      <arg name="before_length" type="uint" summary="length of text before current cursor position"/>
+      <arg name="after_length" type="uint" summary="length of text after current cursor position"/>
+    </event>
+
+    <event name="done">
+      <description summary="apply changes">
+        Instruct the application to apply changes to state requested by the
+        preedit_string, commit_string and delete_surrounding_text events. The
+        state relating to these events is double-buffered, and each one
+        modifies the pending state. This event replaces the current state with
+        the pending state.
+
+        The application must proceed by evaluating the changes in the following
+        order:
+
+        1. Replace existing preedit string with the cursor.
+        2. Delete requested surrounding text.
+        3. Insert commit string with the cursor at its end.
+        4. Calculate surrounding text to send.
+        5. Insert new preedit text in cursor position.
+        6. Place cursor inside preedit text.
+
+        The serial number reflects the last state of the zwp_text_input_v3
+        object known to the compositor. The value of the serial argument must
+        be equal to the number of commit requests already issued on that object.
+
+        When the client receives a done event with a serial different than the
+        number of past commit requests, it must proceed with evaluating and
+        applying the changes as normal, except it should not change the current
+        state of the zwp_text_input_v3 object. All pending state requests
+        (set_surrounding_text, set_content_type and set_cursor_rectangle) on
+        the zwp_text_input_v3 object should be sent and committed after
+        receiving a zwp_text_input_v3.done event with a matching serial.
+      </description>
+      <arg name="serial" type="uint"/>
+    </event>
+  </interface>
+
+  <interface name="zwp_text_input_manager_v3" version="1">
+    <description summary="text input manager">
+      A factory for text-input objects. This object is a global singleton.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="Destroy the wp_text_input_manager">
+        Destroy the wp_text_input_manager object.
+      </description>
+    </request>
+
+    <request name="get_text_input">
+      <description summary="create a new text input object">
+        Creates a new text-input object for a given seat.
+      </description>
+      <arg name="id" type="new_id" interface="zwp_text_input_v3"/>
+      <arg name="seat" type="object" interface="wl_seat"/>
+    </request>
+  </interface>
+</protocol>
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 9432dc934c9..f4170f6dcc4 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -37,6 +37,7 @@ struct wayland process_wayland =
     .seat.mutex = PTHREAD_MUTEX_INITIALIZER,
     .keyboard.mutex = PTHREAD_MUTEX_INITIALIZER,
     .pointer.mutex = PTHREAD_MUTEX_INITIALIZER,
+    .text_input.mutex = PTHREAD_MUTEX_INITIALIZER,
     .output_list = {&process_wayland.output_list, &process_wayland.output_list},
     .output_mutex = PTHREAD_MUTEX_INITIALIZER
 };
@@ -143,6 +144,7 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         seat->global_id = id;
         wl_seat_add_listener(seat->wl_seat, &seat_listener, NULL);
         pthread_mutex_unlock(&seat->mutex);
+        if (process_wayland.zwp_text_input_manager_v3) wayland_text_input_init();
     }
     else if (strcmp(interface, "wp_viewporter") == 0)
     {
@@ -164,6 +166,12 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         process_wayland.zwp_relative_pointer_manager_v1 =
             wl_registry_bind(registry, id, &zwp_relative_pointer_manager_v1_interface, 1);
     }
+    else if (strcmp(interface, "zwp_text_input_manager_v3") == 0)
+    {
+        process_wayland.zwp_text_input_manager_v3 =
+            wl_registry_bind(registry, id, &zwp_text_input_manager_v3_interface, 1);
+        if (process_wayland.seat.wl_seat) wayland_text_input_init();
+    }
 }
 
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
@@ -189,6 +197,7 @@ static void registry_handle_global_remove(void *data, struct wl_registry *regist
     {
         TRACE("removing seat\n");
         if (process_wayland.pointer.wl_pointer) wayland_pointer_deinit();
+        if (process_wayland.text_input.zwp_text_input_v3) wayland_text_input_deinit();
         pthread_mutex_lock(&seat->mutex);
         wl_seat_release(seat->wl_seat);
         seat->wl_seat = NULL;
@@ -282,6 +291,9 @@ BOOL wayland_process_init(void)
     if (!process_wayland.zwp_relative_pointer_manager_v1)
         ERR("Wayland compositor doesn't support optional zwp_relative_pointer_manager_v1 (relative motion won't work)\n");
 
+    if (!process_wayland.zwp_text_input_manager_v3)
+        ERR("Wayland compositor doesn't support optional zwp_text_input_manager_v3 (host input methods won't work)\n");
+
     process_wayland.initialized = TRUE;
 
     return TRUE;
diff --git a/dlls/winewayland.drv/wayland_text_input.c b/dlls/winewayland.drv/wayland_text_input.c
new file mode 100644
index 00000000000..56c17cc3cc6
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_text_input.c
@@ -0,0 +1,109 @@
+/*
+ * Wayland text input handling
+ *
+ * Copyright 2025 Attila Fidan
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(imm);
+
+static void text_input_enter(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
+        struct wl_surface *surface)
+{
+    struct wayland_text_input *text_input = data;
+    TRACE("data %p, text_input %p, surface %p.\n", data, zwp_text_input_v3, surface);
+
+    pthread_mutex_lock(&text_input->mutex);
+    zwp_text_input_v3_enable(text_input->zwp_text_input_v3);
+    zwp_text_input_v3_set_content_type(text_input->zwp_text_input_v3,
+            ZWP_TEXT_INPUT_V3_CONTENT_HINT_NONE,
+            ZWP_TEXT_INPUT_V3_CONTENT_PURPOSE_NORMAL);
+    zwp_text_input_v3_set_cursor_rectangle(text_input->zwp_text_input_v3, 0, 0, 0, 0);
+    zwp_text_input_v3_commit(text_input->zwp_text_input_v3);
+    pthread_mutex_unlock(&text_input->mutex);
+}
+
+static void text_input_leave(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
+        struct wl_surface *surface)
+{
+    struct wayland_text_input *text_input = data;
+    TRACE("data %p, text_input %p, surface %p.\n", data, zwp_text_input_v3, surface);
+
+    pthread_mutex_lock(&text_input->mutex);
+    zwp_text_input_v3_disable(text_input->zwp_text_input_v3);
+    zwp_text_input_v3_commit(text_input->zwp_text_input_v3);
+    pthread_mutex_unlock(&text_input->mutex);
+}
+
+static void text_input_preedit_string(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
+        const char *text, int32_t cursor_begin, int32_t cursor_end)
+{
+}
+
+static void text_input_commit_string(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
+        const char *text)
+{
+}
+
+static void text_input_delete_surrounding_text(void *data,
+        struct zwp_text_input_v3 *zwp_text_input_v3, uint32_t before_length, uint32_t after_length)
+{
+}
+
+static void text_input_done(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
+        uint32_t serial)
+{
+}
+
+static const struct zwp_text_input_v3_listener text_input_listener =
+{
+    text_input_enter,
+    text_input_leave,
+    text_input_preedit_string,
+    text_input_commit_string,
+    text_input_delete_surrounding_text,
+    text_input_done,
+};
+
+void wayland_text_input_init(void)
+{
+    struct wayland_text_input *text_input = &process_wayland.text_input;
+
+    pthread_mutex_lock(&text_input->mutex);
+    text_input->zwp_text_input_v3 = zwp_text_input_manager_v3_get_text_input(
+            process_wayland.zwp_text_input_manager_v3, process_wayland.seat.wl_seat);
+    zwp_text_input_v3_add_listener(text_input->zwp_text_input_v3, &text_input_listener, text_input);
+    pthread_mutex_unlock(&text_input->mutex);
+};
+
+void wayland_text_input_deinit(void)
+{
+    struct wayland_text_input *text_input = &process_wayland.text_input;
+
+    pthread_mutex_lock(&text_input->mutex);
+    zwp_text_input_v3_destroy(text_input->zwp_text_input_v3);
+    text_input->zwp_text_input_v3 = NULL;
+    pthread_mutex_unlock(&text_input->mutex);
+};
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 72a37cb3ffb..c5dec335485 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -31,6 +31,7 @@
 #include <xkbcommon/xkbregistry.h>
 #include "pointer-constraints-unstable-v1-client-protocol.h"
 #include "relative-pointer-unstable-v1-client-protocol.h"
+#include "text-input-unstable-v3-client-protocol.h"
 #include "viewporter-client-protocol.h"
 #include "xdg-output-unstable-v1-client-protocol.h"
 #include "xdg-shell-client-protocol.h"
@@ -111,6 +112,12 @@ struct wayland_pointer
     pthread_mutex_t mutex;
 };
 
+struct wayland_text_input
+{
+    struct zwp_text_input_v3 *zwp_text_input_v3;
+    pthread_mutex_t mutex;
+};
+
 struct wayland_seat
 {
     struct wl_seat *wl_seat;
@@ -132,9 +139,11 @@ struct wayland
     struct wl_subcompositor *wl_subcompositor;
     struct zwp_pointer_constraints_v1 *zwp_pointer_constraints_v1;
     struct zwp_relative_pointer_manager_v1 *zwp_relative_pointer_manager_v1;
+    struct zwp_text_input_manager_v3 *zwp_text_input_manager_v3;
     struct wayland_seat seat;
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
+    struct wayland_text_input text_input;
     struct wl_list output_list;
     /* Protects the output_list and the wayland_output.current states. */
     pthread_mutex_t output_mutex;
@@ -340,6 +349,13 @@ void wayland_pointer_init(struct wl_pointer *wl_pointer);
 void wayland_pointer_deinit(void);
 void wayland_pointer_clear_constraint(void);
 
+/**********************************************************************
+ *          Wayland text input
+ */
+
+void wayland_text_input_init(void);
+void wayland_text_input_deinit(void);
+
 /**********************************************************************
  *          OpenGL
  */
-- 
2.49.0

From bc91747f2300f92be4c1c48d6d871c195322023d Mon Sep 17 00:00:00 2001
From: Attila Fidan <dev@print0.net>
Date: Sun, 2 Feb 2025 08:07:41 +0000
Subject: [PATCH 03/78] winewayland: Post IME update for committed text.

---
 dlls/winewayland.drv/wayland_text_input.c | 50 +++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h         |  2 +
 2 files changed, 52 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_text_input.c b/dlls/winewayland.drv/wayland_text_input.c
index 56c17cc3cc6..91355c23a9c 100644
--- a/dlls/winewayland.drv/wayland_text_input.c
+++ b/dlls/winewayland.drv/wayland_text_input.c
@@ -24,11 +24,39 @@
 
 #include "config.h"
 
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+
 #include "waylanddrv.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(imm);
 
+static void post_ime_update(HWND hwnd, UINT cursor_pos, WCHAR *comp_str, WCHAR *result_str)
+{
+    NtUserMessageCall(hwnd, WINE_IME_POST_UPDATE, cursor_pos, (LPARAM)comp_str, result_str,
+            NtUserImeDriverCall, FALSE);
+}
+
+static WCHAR *strdupUtoW(const char *str)
+{
+    WCHAR *ret = NULL;
+    size_t len;
+    DWORD reslen;
+
+    if (!str) return ret;
+    len = strlen(str);
+    ret = malloc((len + 1) * sizeof(WCHAR));
+    if (ret)
+    {
+        RtlUTF8ToUnicodeN(ret, len * sizeof(WCHAR), &reslen, str, len);
+        reslen /= sizeof(WCHAR);
+        ret[reslen] = 0;
+    }
+    return ret;
+}
+
 static void text_input_enter(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
         struct wl_surface *surface)
 {
@@ -42,6 +70,7 @@ static void text_input_enter(void *data, struct zwp_text_input_v3 *zwp_text_inpu
             ZWP_TEXT_INPUT_V3_CONTENT_PURPOSE_NORMAL);
     zwp_text_input_v3_set_cursor_rectangle(text_input->zwp_text_input_v3, 0, 0, 0, 0);
     zwp_text_input_v3_commit(text_input->zwp_text_input_v3);
+    text_input->wl_surface = surface;
     pthread_mutex_unlock(&text_input->mutex);
 }
 
@@ -54,6 +83,7 @@ static void text_input_leave(void *data, struct zwp_text_input_v3 *zwp_text_inpu
     pthread_mutex_lock(&text_input->mutex);
     zwp_text_input_v3_disable(text_input->zwp_text_input_v3);
     zwp_text_input_v3_commit(text_input->zwp_text_input_v3);
+    text_input->wl_surface = NULL;
     pthread_mutex_unlock(&text_input->mutex);
 }
 
@@ -65,6 +95,12 @@ static void text_input_preedit_string(void *data, struct zwp_text_input_v3 *zwp_
 static void text_input_commit_string(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
         const char *text)
 {
+    struct wayland_text_input *text_input = data;
+    TRACE("data %p, text_input %p, text %s.\n", data, zwp_text_input_v3, debugstr_a(text));
+
+    pthread_mutex_lock(&text_input->mutex);
+    text_input->commit_string = strdupUtoW(text);
+    pthread_mutex_unlock(&text_input->mutex);
 }
 
 static void text_input_delete_surrounding_text(void *data,
@@ -75,6 +111,19 @@ static void text_input_delete_surrounding_text(void *data,
 static void text_input_done(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
         uint32_t serial)
 {
+    struct wayland_text_input *text_input = data;
+    HWND hwnd;
+    TRACE("data %p, text_input %p, serial %u.\n", data, zwp_text_input_v3, serial);
+
+    pthread_mutex_lock(&text_input->mutex);
+    assert(text_input->wl_surface);
+    hwnd = wl_surface_get_user_data(text_input->wl_surface);
+
+    post_ime_update(hwnd, 0, NULL, text_input->commit_string);
+
+    free(text_input->commit_string);
+    text_input->commit_string = NULL;
+    pthread_mutex_unlock(&text_input->mutex);
 }
 
 static const struct zwp_text_input_v3_listener text_input_listener =
@@ -105,5 +154,6 @@ void wayland_text_input_deinit(void)
     pthread_mutex_lock(&text_input->mutex);
     zwp_text_input_v3_destroy(text_input->zwp_text_input_v3);
     text_input->zwp_text_input_v3 = NULL;
+    text_input->wl_surface = NULL;
     pthread_mutex_unlock(&text_input->mutex);
 };
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index c5dec335485..60c345e6601 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -115,6 +115,8 @@ struct wayland_pointer
 struct wayland_text_input
 {
     struct zwp_text_input_v3 *zwp_text_input_v3;
+    WCHAR *commit_string;
+    struct wl_surface *wl_surface;
     pthread_mutex_t mutex;
 };
 
-- 
2.49.0

From 3ab33ca6c182b1f3afb1e0da9b706c8cb9c900af Mon Sep 17 00:00:00 2001
From: Attila Fidan <dev@print0.net>
Date: Sun, 2 Feb 2025 08:26:56 +0000
Subject: [PATCH 04/78] winewayland: Implement SetIMECompositionRect.

---
 dlls/winewayland.drv/wayland_text_input.c | 47 +++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h         |  1 +
 dlls/winewayland.drv/waylanddrv_main.c    |  1 +
 3 files changed, 49 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_text_input.c b/dlls/winewayland.drv/wayland_text_input.c
index 91355c23a9c..769862ecdea 100644
--- a/dlls/winewayland.drv/wayland_text_input.c
+++ b/dlls/winewayland.drv/wayland_text_input.c
@@ -157,3 +157,50 @@ void wayland_text_input_deinit(void)
     text_input->wl_surface = NULL;
     pthread_mutex_unlock(&text_input->mutex);
 };
+
+/***********************************************************************
+ *      SetIMECompositionRect (WAYLANDDRV.@)
+ */
+BOOL WAYLAND_SetIMECompositionRect(HWND hwnd, RECT rect)
+{
+    struct wayland_text_input *text_input = &process_wayland.text_input;
+    struct wayland_win_data *data;
+    struct wayland_surface *surface;
+    int cursor_x, cursor_y, cursor_width, cursor_height;
+    TRACE("hwnd %p, rect %s.\n", hwnd, wine_dbgstr_rect(&rect));
+
+    pthread_mutex_lock(&text_input->mutex);
+
+    if (!text_input->zwp_text_input_v3)
+        goto err;
+
+    if (!(data = wayland_win_data_get(hwnd)))
+        goto err;
+
+    if (!(surface = data->wayland_surface) || surface->wl_surface != text_input->wl_surface)
+    {
+        wayland_win_data_release(data);
+        goto err;
+    }
+
+    wayland_surface_coords_from_window(surface,
+            rect.left - surface->window.rect.left,
+            rect.top - surface->window.rect.top,
+            &cursor_x, &cursor_y);
+    wayland_surface_coords_from_window(surface,
+            rect.right - rect.left,
+            rect.bottom - rect.top,
+            &cursor_width, &cursor_height);
+    wayland_win_data_release(data);
+
+    zwp_text_input_v3_set_cursor_rectangle(text_input->zwp_text_input_v3,
+            cursor_x, cursor_y, cursor_width, cursor_height);
+    zwp_text_input_v3_commit(text_input->zwp_text_input_v3);
+
+    pthread_mutex_unlock(&text_input->mutex);
+    return TRUE;
+
+err:
+    pthread_mutex_unlock(&text_input->mutex);
+    return FALSE;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 60c345e6601..afc480e6652 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -392,6 +392,7 @@ RGNDATA *get_region_data(HRGN region);
 BOOL WAYLAND_ClipCursor(const RECT *clip, BOOL reset);
 LRESULT WAYLAND_DesktopWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
 void WAYLAND_DestroyWindow(HWND hwnd);
+BOOL WAYLAND_SetIMECompositionRect(HWND hwnd, RECT rect);
 void WAYLAND_SetCursor(HWND hwnd, HCURSOR hcursor);
 void WAYLAND_SetWindowText(HWND hwnd, LPCWSTR text);
 LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam, const POINT *pos);
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 47c1299dd01..633b2f4a043 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -38,6 +38,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pClipCursor = WAYLAND_ClipCursor,
     .pDesktopWindowProc = WAYLAND_DesktopWindowProc,
     .pDestroyWindow = WAYLAND_DestroyWindow,
+    .pSetIMECompositionRect = WAYLAND_SetIMECompositionRect,
     .pKbdLayerDescriptor = WAYLAND_KbdLayerDescriptor,
     .pReleaseKbdTables = WAYLAND_ReleaseKbdTables,
     .pSetCursor = WAYLAND_SetCursor,
-- 
2.49.0

From 348aeaaf88a79c5c4a2eefc259426385a2af8b2d Mon Sep 17 00:00:00 2001
From: Attila Fidan <dev@print0.net>
Date: Sat, 8 Feb 2025 05:59:04 +0000
Subject: [PATCH 05/78] winewayland: Post IME update for preedit text.

---
 dlls/winewayland.drv/wayland_text_input.c | 21 ++++++++++++++++++++-
 dlls/winewayland.drv/waylanddrv.h         |  2 ++
 2 files changed, 22 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/wayland_text_input.c b/dlls/winewayland.drv/wayland_text_input.c
index 769862ecdea..17257634b2e 100644
--- a/dlls/winewayland.drv/wayland_text_input.c
+++ b/dlls/winewayland.drv/wayland_text_input.c
@@ -78,11 +78,15 @@ static void text_input_leave(void *data, struct zwp_text_input_v3 *zwp_text_inpu
         struct wl_surface *surface)
 {
     struct wayland_text_input *text_input = data;
+    HWND hwnd;
     TRACE("data %p, text_input %p, surface %p.\n", data, zwp_text_input_v3, surface);
 
     pthread_mutex_lock(&text_input->mutex);
     zwp_text_input_v3_disable(text_input->zwp_text_input_v3);
     zwp_text_input_v3_commit(text_input->zwp_text_input_v3);
+    assert(text_input->wl_surface);
+    hwnd = wl_surface_get_user_data(text_input->wl_surface);
+    post_ime_update(hwnd, 0, NULL, NULL);
     text_input->wl_surface = NULL;
     pthread_mutex_unlock(&text_input->mutex);
 }
@@ -90,6 +94,17 @@ static void text_input_leave(void *data, struct zwp_text_input_v3 *zwp_text_inpu
 static void text_input_preedit_string(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
         const char *text, int32_t cursor_begin, int32_t cursor_end)
 {
+    struct wayland_text_input *text_input = data;
+    TRACE("data %p, text_input %p, text %s, cursor_begin %d.\n", data, zwp_text_input_v3,
+            debugstr_a(text), cursor_begin);
+
+    pthread_mutex_lock(&text_input->mutex);
+    if ((text_input->preedit_string = strdupUtoW(text)) && cursor_begin > 0)
+    {
+        RtlUTF8ToUnicodeN(NULL, 0, &text_input->preedit_cursor_pos, text, cursor_begin);
+        text_input->preedit_cursor_pos /= sizeof(WCHAR);
+    }
+    pthread_mutex_unlock(&text_input->mutex);
 }
 
 static void text_input_commit_string(void *data, struct zwp_text_input_v3 *zwp_text_input_v3,
@@ -119,8 +134,12 @@ static void text_input_done(void *data, struct zwp_text_input_v3 *zwp_text_input
     assert(text_input->wl_surface);
     hwnd = wl_surface_get_user_data(text_input->wl_surface);
 
-    post_ime_update(hwnd, 0, NULL, text_input->commit_string);
+    post_ime_update(hwnd, text_input->preedit_cursor_pos, text_input->preedit_string,
+            text_input->commit_string);
 
+    free(text_input->preedit_string);
+    text_input->preedit_string = NULL;
+    text_input->preedit_cursor_pos = 0;
     free(text_input->commit_string);
     text_input->commit_string = NULL;
     pthread_mutex_unlock(&text_input->mutex);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index afc480e6652..5c5ce5bf130 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -115,6 +115,8 @@ struct wayland_pointer
 struct wayland_text_input
 {
     struct zwp_text_input_v3 *zwp_text_input_v3;
+    WCHAR *preedit_string;
+    DWORD preedit_cursor_pos;
     WCHAR *commit_string;
     struct wl_surface *wl_surface;
     pthread_mutex_t mutex;
-- 
2.49.0

From 7b43df6f6650bf31e597140079bb06bf7c777274 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 6 Feb 2025 12:43:39 +0200
Subject: [PATCH 06/78] winewayland: Round the Wayland refresh rate to
 calculate the win32 display frequency.

Round the Wayland refresh rate instead of floor-ing it, to report a more
accurate win32 display frequency. This can slightly improve FPS values
in games that use the reported display frequency to drive their rendering.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=56542
---
 dlls/winewayland.drv/display.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index 5d65fd01c54..851c9638252 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -232,7 +232,8 @@ static void populate_devmode(struct wayland_output_mode *output_mode, DEVMODEW *
     mode->dmBitsPerPel = 32;
     mode->dmPelsWidth = output_mode->width;
     mode->dmPelsHeight = output_mode->height;
-    mode->dmDisplayFrequency = output_mode->refresh / 1000;
+    /* Round the refresh rate to calculate the win32 display frequency. */
+    mode->dmDisplayFrequency = (output_mode->refresh + 500) / 1000;
 }
 
 static void wayland_add_device_modes(const struct gdi_device_manager *device_manager,
-- 
2.49.0

From 6e01aa895b368b3382f292d37ffc34a9c47f40c7 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 7 Feb 2025 13:23:46 +0200
Subject: [PATCH 07/78] winewayland: Implement zwlr_data_control_device_v1
 initialization.

---
 dlls/winewayland.drv/Makefile.in              |   2 +
 dlls/winewayland.drv/wayland.c                |   8 +
 dlls/winewayland.drv/wayland_data_device.c    |  59 ++++
 dlls/winewayland.drv/waylanddrv.h             |  15 +
 dlls/winewayland.drv/waylanddrv_main.c        |   1 +
 .../wlr-data-control-unstable-v1.xml          | 278 ++++++++++++++++++
 6 files changed, 363 insertions(+)
 create mode 100644 dlls/winewayland.drv/wayland_data_device.c
 create mode 100644 dlls/winewayland.drv/wlr-data-control-unstable-v1.xml

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 9129a3f2839..142db22ba9e 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -14,6 +14,7 @@ SOURCES = \
 	viewporter.xml \
 	vulkan.c \
 	wayland.c \
+	wayland_data_device.c \
 	wayland_keyboard.c \
 	wayland_output.c \
 	wayland_pointer.c \
@@ -22,5 +23,6 @@ SOURCES = \
 	waylanddrv_main.c \
 	window.c \
 	window_surface.c \
+	wlr-data-control-unstable-v1.xml \
 	xdg-output-unstable-v1.xml \
 	xdg-shell.xml
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index f4170f6dcc4..2fb0edf8023 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -145,6 +145,9 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         wl_seat_add_listener(seat->wl_seat, &seat_listener, NULL);
         pthread_mutex_unlock(&seat->mutex);
         if (process_wayland.zwp_text_input_manager_v3) wayland_text_input_init();
+        /* Recreate the data device for the new seat. */
+        if (process_wayland.data_device.zwlr_data_control_device_v1)
+            wayland_data_device_init();
     }
     else if (strcmp(interface, "wp_viewporter") == 0)
     {
@@ -172,6 +175,11 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
             wl_registry_bind(registry, id, &zwp_text_input_manager_v3_interface, 1);
         if (process_wayland.seat.wl_seat) wayland_text_input_init();
     }
+    else if (strcmp(interface, "zwlr_data_control_manager_v1") == 0)
+    {
+        process_wayland.zwlr_data_control_manager_v1 =
+            wl_registry_bind(registry, id, &zwlr_data_control_manager_v1_interface, 1);
+    }
 }
 
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
new file mode 100644
index 00000000000..6e53ed4046b
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -0,0 +1,59 @@
+/*
+ * Wayland clipboard
+ *
+ * Copyright 2025 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
+
+void wayland_data_device_init(void)
+{
+    struct wayland_data_device *data_device = &process_wayland.data_device;
+
+    TRACE("\n");
+
+    if (data_device->zwlr_data_control_device_v1)
+        zwlr_data_control_device_v1_destroy(data_device->zwlr_data_control_device_v1);
+    data_device->zwlr_data_control_device_v1 =
+        zwlr_data_control_manager_v1_get_data_device(
+            process_wayland.zwlr_data_control_manager_v1,
+            process_wayland.seat.wl_seat);
+}
+
+LRESULT WAYLAND_ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
+{
+    switch (msg)
+    {
+    case WM_NCCREATE:
+        pthread_mutex_lock(&process_wayland.seat.mutex);
+        if (process_wayland.seat.wl_seat && process_wayland.zwlr_data_control_manager_v1)
+            wayland_data_device_init();
+        pthread_mutex_unlock(&process_wayland.seat.mutex);
+        return TRUE;
+    }
+
+    return NtUserMessageCall(hwnd, msg, wparam, lparam, NULL, NtUserDefWindowProc, FALSE);
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 5c5ce5bf130..12ac686fbd9 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -35,6 +35,7 @@
 #include "viewporter-client-protocol.h"
 #include "xdg-output-unstable-v1-client-protocol.h"
 #include "xdg-shell-client-protocol.h"
+#include "wlr-data-control-unstable-v1-client-protocol.h"
 
 #include "windef.h"
 #include "winbase.h"
@@ -129,6 +130,11 @@ struct wayland_seat
     pthread_mutex_t mutex;
 };
 
+struct wayland_data_device
+{
+    struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1;
+};
+
 struct wayland
 {
     BOOL initialized;
@@ -144,10 +150,12 @@ struct wayland
     struct zwp_pointer_constraints_v1 *zwp_pointer_constraints_v1;
     struct zwp_relative_pointer_manager_v1 *zwp_relative_pointer_manager_v1;
     struct zwp_text_input_manager_v3 *zwp_text_input_manager_v3;
+    struct zwlr_data_control_manager_v1 *zwlr_data_control_manager_v1;
     struct wayland_seat seat;
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
     struct wayland_text_input text_input;
+    struct wayland_data_device data_device;
     struct wl_list output_list;
     /* Protects the output_list and the wayland_output.current states. */
     pthread_mutex_t output_mutex;
@@ -360,6 +368,12 @@ void wayland_pointer_clear_constraint(void);
 void wayland_text_input_init(void);
 void wayland_text_input_deinit(void);
 
+/**********************************************************************
+ *          Wayland data device
+ */
+
+void wayland_data_device_init(void);
+
 /**********************************************************************
  *          OpenGL
  */
@@ -391,6 +405,7 @@ RGNDATA *get_region_data(HRGN region);
  *          USER driver functions
  */
 
+LRESULT WAYLAND_ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam);
 BOOL WAYLAND_ClipCursor(const RECT *clip, BOOL reset);
 LRESULT WAYLAND_DesktopWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
 void WAYLAND_DestroyWindow(HWND hwnd);
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 633b2f4a043..ca7ec47b674 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -35,6 +35,7 @@ char *process_name = NULL;
 
 static const struct user_driver_funcs waylanddrv_funcs =
 {
+    .pClipboardWindowProc = WAYLAND_ClipboardWindowProc,
     .pClipCursor = WAYLAND_ClipCursor,
     .pDesktopWindowProc = WAYLAND_DesktopWindowProc,
     .pDestroyWindow = WAYLAND_DestroyWindow,
diff --git a/dlls/winewayland.drv/wlr-data-control-unstable-v1.xml b/dlls/winewayland.drv/wlr-data-control-unstable-v1.xml
new file mode 100644
index 00000000000..75e8671b0de
--- /dev/null
+++ b/dlls/winewayland.drv/wlr-data-control-unstable-v1.xml
@@ -0,0 +1,278 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="wlr_data_control_unstable_v1">
+  <copyright>
+    Copyright © 2018 Simon Ser
+    Copyright © 2019 Ivan Molodetskikh
+
+    Permission to use, copy, modify, distribute, and sell this
+    software and its documentation for any purpose is hereby granted
+    without fee, provided that the above copyright notice appear in
+    all copies and that both that copyright notice and this permission
+    notice appear in supporting documentation, and that the name of
+    the copyright holders not be used in advertising or publicity
+    pertaining to distribution of the software without specific,
+    written prior permission.  The copyright holders make no
+    representations about the suitability of this software for any
+    purpose.  It is provided "as is" without express or implied
+    warranty.
+
+    THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+    SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+    FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+    SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+    AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+    ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
+    THIS SOFTWARE.
+  </copyright>
+
+  <description summary="control data devices">
+    This protocol allows a privileged client to control data devices. In
+    particular, the client will be able to manage the current selection and take
+    the role of a clipboard manager.
+
+    Warning! The protocol described in this file is experimental and
+    backward incompatible changes may be made. Backward compatible changes
+    may be added together with the corresponding interface version bump.
+    Backward incompatible changes are done by bumping the version number in
+    the protocol and interface names and resetting the interface version.
+    Once the protocol is to be declared stable, the 'z' prefix and the
+    version number in the protocol and interface names are removed and the
+    interface version number is reset.
+  </description>
+
+  <interface name="zwlr_data_control_manager_v1" version="2">
+    <description summary="manager to control data devices">
+      This interface is a manager that allows creating per-seat data device
+      controls.
+    </description>
+
+    <request name="create_data_source">
+      <description summary="create a new data source">
+        Create a new data source.
+      </description>
+      <arg name="id" type="new_id" interface="zwlr_data_control_source_v1"
+        summary="data source to create"/>
+    </request>
+
+    <request name="get_data_device">
+      <description summary="get a data device for a seat">
+        Create a data device that can be used to manage a seat's selection.
+      </description>
+      <arg name="id" type="new_id" interface="zwlr_data_control_device_v1"/>
+      <arg name="seat" type="object" interface="wl_seat"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the manager">
+        All objects created by the manager will still remain valid, until their
+        appropriate destroy request has been called.
+      </description>
+    </request>
+  </interface>
+
+  <interface name="zwlr_data_control_device_v1" version="2">
+    <description summary="manage a data device for a seat">
+      This interface allows a client to manage a seat's selection.
+
+      When the seat is destroyed, this object becomes inert.
+    </description>
+
+    <request name="set_selection">
+      <description summary="copy data to the selection">
+        This request asks the compositor to set the selection to the data from
+        the source on behalf of the client.
+
+        The given source may not be used in any further set_selection or
+        set_primary_selection requests. Attempting to use a previously used
+        source is a protocol error.
+
+        To unset the selection, set the source to NULL.
+      </description>
+      <arg name="source" type="object" interface="zwlr_data_control_source_v1"
+        allow-null="true"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy this data device">
+        Destroys the data device object.
+      </description>
+    </request>
+
+    <event name="data_offer">
+      <description summary="introduce a new wlr_data_control_offer">
+        The data_offer event introduces a new wlr_data_control_offer object,
+        which will subsequently be used in either the
+        wlr_data_control_device.selection event (for the regular clipboard
+        selections) or the wlr_data_control_device.primary_selection event (for
+        the primary clipboard selections). Immediately following the
+        wlr_data_control_device.data_offer event, the new data_offer object
+        will send out wlr_data_control_offer.offer events to describe the MIME
+        types it offers.
+      </description>
+      <arg name="id" type="new_id" interface="zwlr_data_control_offer_v1"/>
+    </event>
+
+    <event name="selection">
+      <description summary="advertise new selection">
+        The selection event is sent out to notify the client of a new
+        wlr_data_control_offer for the selection for this device. The
+        wlr_data_control_device.data_offer and the wlr_data_control_offer.offer
+        events are sent out immediately before this event to introduce the data
+        offer object. The selection event is sent to a client when a new
+        selection is set. The wlr_data_control_offer is valid until a new
+        wlr_data_control_offer or NULL is received. The client must destroy the
+        previous selection wlr_data_control_offer, if any, upon receiving this
+        event.
+
+        The first selection event is sent upon binding the
+        wlr_data_control_device object.
+      </description>
+      <arg name="id" type="object" interface="zwlr_data_control_offer_v1"
+        allow-null="true"/>
+    </event>
+
+    <event name="finished">
+      <description summary="this data control is no longer valid">
+        This data control object is no longer valid and should be destroyed by
+        the client.
+      </description>
+    </event>
+
+    <!-- Version 2 additions -->
+
+    <event name="primary_selection" since="2">
+      <description summary="advertise new primary selection">
+        The primary_selection event is sent out to notify the client of a new
+        wlr_data_control_offer for the primary selection for this device. The
+        wlr_data_control_device.data_offer and the wlr_data_control_offer.offer
+        events are sent out immediately before this event to introduce the data
+        offer object. The primary_selection event is sent to a client when a
+        new primary selection is set. The wlr_data_control_offer is valid until
+        a new wlr_data_control_offer or NULL is received. The client must
+        destroy the previous primary selection wlr_data_control_offer, if any,
+        upon receiving this event.
+
+        If the compositor supports primary selection, the first
+        primary_selection event is sent upon binding the
+        wlr_data_control_device object.
+      </description>
+      <arg name="id" type="object" interface="zwlr_data_control_offer_v1"
+        allow-null="true"/>
+    </event>
+
+    <request name="set_primary_selection" since="2">
+      <description summary="copy data to the primary selection">
+        This request asks the compositor to set the primary selection to the
+        data from the source on behalf of the client.
+
+        The given source may not be used in any further set_selection or
+        set_primary_selection requests. Attempting to use a previously used
+        source is a protocol error.
+
+        To unset the primary selection, set the source to NULL.
+
+        The compositor will ignore this request if it does not support primary
+        selection.
+      </description>
+      <arg name="source" type="object" interface="zwlr_data_control_source_v1"
+        allow-null="true"/>
+    </request>
+
+    <enum name="error" since="2">
+      <entry name="used_source" value="1"
+        summary="source given to set_selection or set_primary_selection was already used before"/>
+    </enum>
+  </interface>
+
+  <interface name="zwlr_data_control_source_v1" version="1">
+    <description summary="offer to transfer data">
+      The wlr_data_control_source object is the source side of a
+      wlr_data_control_offer. It is created by the source client in a data
+      transfer and provides a way to describe the offered data and a way to
+      respond to requests to transfer the data.
+    </description>
+
+    <enum name="error">
+      <entry name="invalid_offer" value="1"
+        summary="offer sent after wlr_data_control_device.set_selection"/>
+    </enum>
+
+    <request name="offer">
+      <description summary="add an offered MIME type">
+        This request adds a MIME type to the set of MIME types advertised to
+        targets. Can be called several times to offer multiple types.
+
+        Calling this after wlr_data_control_device.set_selection is a protocol
+        error.
+      </description>
+      <arg name="mime_type" type="string"
+        summary="MIME type offered by the data source"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy this source">
+        Destroys the data source object.
+      </description>
+    </request>
+
+    <event name="send">
+      <description summary="send the data">
+        Request for data from the client. Send the data as the specified MIME
+        type over the passed file descriptor, then close it.
+      </description>
+      <arg name="mime_type" type="string" summary="MIME type for the data"/>
+      <arg name="fd" type="fd" summary="file descriptor for the data"/>
+    </event>
+
+    <event name="cancelled">
+      <description summary="selection was cancelled">
+        This data source is no longer valid. The data source has been replaced
+        by another data source.
+
+        The client should clean up and destroy this data source.
+      </description>
+    </event>
+  </interface>
+
+  <interface name="zwlr_data_control_offer_v1" version="1">
+    <description summary="offer to transfer data">
+      A wlr_data_control_offer represents a piece of data offered for transfer
+      by another client (the source client). The offer describes the different
+      MIME types that the data can be converted to and provides the mechanism
+      for transferring the data directly from the source client.
+    </description>
+
+    <request name="receive">
+      <description summary="request that the data is transferred">
+        To transfer the offered data, the client issues this request and
+        indicates the MIME type it wants to receive. The transfer happens
+        through the passed file descriptor (typically created with the pipe
+        system call). The source client writes the data in the MIME type
+        representation requested and then closes the file descriptor.
+
+        The receiving client reads from the read end of the pipe until EOF and
+        then closes its end, at which point the transfer is complete.
+
+        This request may happen multiple times for different MIME types.
+      </description>
+      <arg name="mime_type" type="string"
+        summary="MIME type desired by receiver"/>
+      <arg name="fd" type="fd" summary="file descriptor for data transfer"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy this offer">
+        Destroys the data offer object.
+      </description>
+    </request>
+
+    <event name="offer">
+      <description summary="advertise offered MIME type">
+        Sent immediately after creating the wlr_data_control_offer object.
+        One event per offered MIME type.
+      </description>
+      <arg name="mime_type" type="string" summary="offered MIME type"/>
+    </event>
+  </interface>
+</protocol>
-- 
2.49.0

From 8709e7634fb7efd40ef651cfe02a4905d1f169e0 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 7 Feb 2025 14:33:53 +0200
Subject: [PATCH 08/78] winewayland: Support copying text from win32 clipboard
 to native apps.

---
 dlls/winewayland.drv/wayland.c             |   1 +
 dlls/winewayland.drv/wayland_data_device.c | 173 +++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h          |   2 +
 3 files changed, 176 insertions(+)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 2fb0edf8023..ee162d8fe77 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -38,6 +38,7 @@ struct wayland process_wayland =
     .keyboard.mutex = PTHREAD_MUTEX_INITIALIZER,
     .pointer.mutex = PTHREAD_MUTEX_INITIALIZER,
     .text_input.mutex = PTHREAD_MUTEX_INITIALIZER,
+    .data_device.mutex = PTHREAD_MUTEX_INITIALIZER,
     .output_list = {&process_wayland.output_list, &process_wayland.output_list},
     .output_mutex = PTHREAD_MUTEX_INITIALIZER
 };
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 6e53ed4046b..b51f5b25ed4 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -24,23 +24,191 @@
 
 #include "config.h"
 
+#include <errno.h>
+#include <stdlib.h>
+#include <unistd.h>
+
 #include "waylanddrv.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
 
+static HWND clipboard_hwnd;
+
+static void write_all(int fd, const void *buf, size_t count)
+{
+    size_t nwritten = 0;
+    ssize_t ret;
+
+    while (nwritten < count)
+    {
+        ret = write(fd, (const char*)buf + nwritten, count - nwritten);
+        if (ret == -1 && errno != EINTR) break;
+        else if (ret > 0) nwritten += ret;
+    }
+
+    if (nwritten < count)
+    {
+        WARN("Failed to write all clipboard data, had %zu bytes, wrote %zu bytes\n",
+             count, nwritten);
+    }
+}
+
+static void *export_unicode_text(void *data, size_t size, size_t *ret_size)
+{
+    DWORD byte_count;
+    char *bytes;
+
+    /* Wayland apps expect strings to not be zero-terminated, so avoid
+     * zero-terminating the resulting converted string. */
+    if (size >= sizeof(WCHAR) && ((WCHAR *)data)[size / sizeof(WCHAR) - 1] == 0)
+        size -= sizeof(WCHAR);
+
+    RtlUnicodeToUTF8N(NULL, 0, &byte_count, data, size);
+    if (!(bytes = malloc(byte_count))) return NULL;
+    RtlUnicodeToUTF8N(bytes, byte_count, &byte_count, data, size);
+
+    *ret_size = byte_count;
+    return bytes;
+}
+
+/**********************************************************************
+ *          zwlr_data_control_source_v1 handling
+ */
+
+static void wayland_data_source_export(int32_t fd)
+{
+    struct get_clipboard_params params = { .data_only = TRUE, .size = 1024 };
+    void *exported = NULL;
+    size_t exported_size;
+
+    TRACE("\n");
+
+    if (!NtUserOpenClipboard(clipboard_hwnd, 0))
+    {
+        TRACE("failed to open clipboard for export\n");
+        return;
+    }
+
+    for (;;)
+    {
+        if (!(params.data = malloc(params.size))) break;
+        if (NtUserGetClipboardData(CF_UNICODETEXT, &params))
+        {
+            exported = export_unicode_text(params.data, params.size, &exported_size);
+            break;
+        }
+        if (!params.data_size) break;
+        free(params.data);
+        params.size = params.data_size;
+        params.data_size = 0;
+    }
+
+    NtUserCloseClipboard();
+    if (exported) write_all(fd, exported, exported_size);
+
+    free(exported);
+    free(params.data);
+}
+
+static void data_control_source_send(void *data,
+                                     struct zwlr_data_control_source_v1 *source,
+                                     const char *mime_type, int32_t fd)
+{
+    if (!strcmp(mime_type, "text/plain;charset=utf-8"))
+        wayland_data_source_export(fd);
+    close(fd);
+}
+
+static void data_control_source_cancelled(void *data,
+                                          struct zwlr_data_control_source_v1 *source)
+{
+    struct wayland_data_device *data_device = data;
+
+    pthread_mutex_lock(&data_device->mutex);
+    zwlr_data_control_source_v1_destroy(source);
+    if (source == data_device->zwlr_data_control_source_v1)
+        data_device->zwlr_data_control_source_v1 = NULL;
+    pthread_mutex_unlock(&data_device->mutex);
+}
+
+static const struct zwlr_data_control_source_v1_listener data_control_source_listener =
+{
+    data_control_source_send,
+    data_control_source_cancelled,
+};
+
 void wayland_data_device_init(void)
 {
     struct wayland_data_device *data_device = &process_wayland.data_device;
 
     TRACE("\n");
 
+    pthread_mutex_lock(&data_device->mutex);
     if (data_device->zwlr_data_control_device_v1)
         zwlr_data_control_device_v1_destroy(data_device->zwlr_data_control_device_v1);
     data_device->zwlr_data_control_device_v1 =
         zwlr_data_control_manager_v1_get_data_device(
             process_wayland.zwlr_data_control_manager_v1,
             process_wayland.seat.wl_seat);
+    pthread_mutex_unlock(&data_device->mutex);
+}
+
+static void clipboard_update(void)
+{
+    struct wayland_data_device *data_device = &process_wayland.data_device;
+    struct zwlr_data_control_source_v1 *source;
+    UINT *formats, formats_size = 256, i;
+
+    if (!process_wayland.zwlr_data_control_manager_v1) return;
+
+    TRACE("\n");
+
+    source = zwlr_data_control_manager_v1_create_data_source(
+        process_wayland.zwlr_data_control_manager_v1);
+    if (!source)
+    {
+        ERR("failed to create data source\n");
+        return;
+    }
+
+    for (;;)
+    {
+        if (!(formats = malloc(formats_size * sizeof(*formats)))) break;
+        if (NtUserGetUpdatedClipboardFormats(formats, formats_size, &formats_size)) break;
+        free(formats);
+        formats = NULL;
+        if (RtlGetLastWin32Error() != ERROR_INSUFFICIENT_BUFFER) break;
+    }
+
+    if (!formats && formats_size)
+    {
+        ERR("failed to get clipboard formats\n");
+        zwlr_data_control_source_v1_destroy(source);
+        return;
+    }
+
+    for (i = 0; i < formats_size; ++i)
+    {
+        if (formats[i] == CF_UNICODETEXT)
+            zwlr_data_control_source_v1_offer(source, "text/plain;charset=utf-8");
+    }
+
+    free(formats);
+
+    zwlr_data_control_source_v1_add_listener(source, &data_control_source_listener, data_device);
+
+    pthread_mutex_lock(&data_device->mutex);
+    if (data_device->zwlr_data_control_device_v1)
+        zwlr_data_control_device_v1_set_selection(data_device->zwlr_data_control_device_v1, source);
+    /* Destroy any previous source only after setting the new source, to
+     * avoid spurious 'selection(nil)' events. */
+    if (data_device->zwlr_data_control_source_v1)
+        zwlr_data_control_source_v1_destroy(data_device->zwlr_data_control_source_v1);
+    data_device->zwlr_data_control_source_v1 = source;
+    pthread_mutex_unlock(&data_device->mutex);
+
+    wl_display_flush(process_wayland.wl_display);
 }
 
 LRESULT WAYLAND_ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
@@ -48,11 +216,16 @@ LRESULT WAYLAND_ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM l
     switch (msg)
     {
     case WM_NCCREATE:
+        clipboard_hwnd = hwnd;
+        NtUserAddClipboardFormatListener(hwnd);
         pthread_mutex_lock(&process_wayland.seat.mutex);
         if (process_wayland.seat.wl_seat && process_wayland.zwlr_data_control_manager_v1)
             wayland_data_device_init();
         pthread_mutex_unlock(&process_wayland.seat.mutex);
         return TRUE;
+    case WM_CLIPBOARDUPDATE:
+        clipboard_update();
+        break;
     }
 
     return NtUserMessageCall(hwnd, msg, wparam, lparam, NULL, NtUserDefWindowProc, FALSE);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 12ac686fbd9..c8f0ede23ba 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -133,6 +133,8 @@ struct wayland_seat
 struct wayland_data_device
 {
     struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1;
+    struct zwlr_data_control_source_v1 *zwlr_data_control_source_v1;
+    pthread_mutex_t mutex;
 };
 
 struct wayland
-- 
2.49.0

From a960f2a51daca3e50142e7452341a66dde4772c9 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 28 Jan 2025 11:10:30 +0200
Subject: [PATCH 09/78] winewayland: Generalize support for exporting clipboard
 formats.

Introduce the infrastructure to export various clipboard formats in a
table-driven manner, similar to what's used by winex11.
---
 dlls/winewayland.drv/wayland_data_device.c | 62 +++++++++++++++++++---
 1 file changed, 54 insertions(+), 8 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index b51f5b25ed4..77b9f4f7af0 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -33,6 +33,13 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
 
+struct data_device_format
+{
+    const char *mime_type;
+    UINT clipboard_format;
+    void *(*export)(void *data, size_t size, size_t *ret_size);
+};
+
 static HWND clipboard_hwnd;
 
 static void write_all(int fd, const void *buf, size_t count)
@@ -72,17 +79,49 @@ static void *export_unicode_text(void *data, size_t size, size_t *ret_size)
     return bytes;
 }
 
+/* Order is important. When selecting a mime-type for a clipboard format we
+ * will choose the first entry that matches the specified clipboard format. */
+static struct data_device_format supported_formats[] =
+{
+    {"text/plain;charset=utf-8", CF_UNICODETEXT, export_unicode_text},
+    {NULL, 0, NULL},
+};
+
+static struct data_device_format *data_device_format_for_clipboard_format(UINT clipboard_format)
+{
+    struct data_device_format *format;
+
+    for (format = supported_formats; format->mime_type; ++format)
+    {
+        if (format->clipboard_format == clipboard_format) return format;
+    }
+
+    return NULL;
+}
+
+static struct data_device_format *data_device_format_for_mime_type(const char *mime)
+{
+    struct data_device_format *format;
+
+    for (format = supported_formats; format->mime_type; ++format)
+    {
+        if (!strcmp(mime, format->mime_type)) return format;
+    }
+
+    return NULL;
+}
+
 /**********************************************************************
  *          zwlr_data_control_source_v1 handling
  */
 
-static void wayland_data_source_export(int32_t fd)
+static void wayland_data_source_export(struct data_device_format *format, int fd)
 {
     struct get_clipboard_params params = { .data_only = TRUE, .size = 1024 };
     void *exported = NULL;
     size_t exported_size;
 
-    TRACE("\n");
+    TRACE("format=%u => mime=%s\n", format->clipboard_format, format->mime_type);
 
     if (!NtUserOpenClipboard(clipboard_hwnd, 0))
     {
@@ -93,9 +132,9 @@ static void wayland_data_source_export(int32_t fd)
     for (;;)
     {
         if (!(params.data = malloc(params.size))) break;
-        if (NtUserGetClipboardData(CF_UNICODETEXT, &params))
+        if (NtUserGetClipboardData(format->clipboard_format, &params))
         {
-            exported = export_unicode_text(params.data, params.size, &exported_size);
+            exported = format->export(params.data, params.size, &exported_size);
             break;
         }
         if (!params.data_size) break;
@@ -115,8 +154,10 @@ static void data_control_source_send(void *data,
                                      struct zwlr_data_control_source_v1 *source,
                                      const char *mime_type, int32_t fd)
 {
-    if (!strcmp(mime_type, "text/plain;charset=utf-8"))
-        wayland_data_source_export(fd);
+    struct data_device_format *format =
+        data_device_format_for_mime_type(mime_type);
+
+    if (format) wayland_data_source_export(format, fd);
     close(fd);
 }
 
@@ -190,8 +231,13 @@ static void clipboard_update(void)
 
     for (i = 0; i < formats_size; ++i)
     {
-        if (formats[i] == CF_UNICODETEXT)
-            zwlr_data_control_source_v1_offer(source, "text/plain;charset=utf-8");
+        struct data_device_format *format =
+            data_device_format_for_clipboard_format(formats[i]);
+        if (format)
+        {
+            TRACE("offering mime=%s for format=%u\n", format->mime_type, formats[i]);
+            zwlr_data_control_source_v1_offer(source, format->mime_type);
+        }
     }
 
     free(formats);
-- 
2.49.0

From 50949ea3257df2d44d58fab73cfd138f622599c7 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 28 Jan 2025 11:31:48 +0200
Subject: [PATCH 10/78] winewayland: Support exporting various clipboard
 formats.

Add support for some formats commonly used in applications and which
do not require special exporting: RTF, TIFF, PNG, JPEG, GIF, SVG, RIFF, WAV.
---
 dlls/winewayland.drv/wayland_data_device.c | 39 ++++++++++++++++++++--
 1 file changed, 37 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 77b9f4f7af0..1659e9bd6df 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -37,10 +37,16 @@ struct data_device_format
 {
     const char *mime_type;
     UINT clipboard_format;
+    const WCHAR *register_name;
     void *(*export)(void *data, size_t size, size_t *ret_size);
 };
 
 static HWND clipboard_hwnd;
+static const WCHAR rich_text_formatW[] = {'R','i','c','h',' ','T','e','x','t',' ','F','o','r','m','a','t',0};
+static const WCHAR pngW[] = {'P','N','G',0};
+static const WCHAR jfifW[] = {'J','F','I','F',0};
+static const WCHAR gifW[] = {'G','I','F',0};
+static const WCHAR image_svg_xmlW[] = {'i','m','a','g','e','/','s','v','g','+','x','m','l',0};
 
 static void write_all(int fd, const void *buf, size_t count)
 {
@@ -79,11 +85,26 @@ static void *export_unicode_text(void *data, size_t size, size_t *ret_size)
     return bytes;
 }
 
+static void *export_data(void *data, size_t size, size_t *ret_size)
+{
+    *ret_size = size;
+    return data;
+}
+
 /* Order is important. When selecting a mime-type for a clipboard format we
  * will choose the first entry that matches the specified clipboard format. */
 static struct data_device_format supported_formats[] =
 {
-    {"text/plain;charset=utf-8", CF_UNICODETEXT, export_unicode_text},
+    {"text/plain;charset=utf-8", CF_UNICODETEXT, NULL, export_unicode_text},
+    {"text/rtf", 0, rich_text_formatW, export_data},
+    {"image/tiff", CF_TIFF, NULL, export_data},
+    {"image/png", 0, pngW, export_data},
+    {"image/jpeg", 0, jfifW, export_data},
+    {"image/gif", 0, gifW, export_data},
+    {"image/svg+xml", 0, image_svg_xmlW, export_data},
+    {"application/x-riff", CF_RIFF, NULL, export_data},
+    {"audio/wav", CF_WAVE, NULL, export_data},
+    {"audio/x-wav", CF_WAVE, NULL, export_data},
     {NULL, 0, NULL},
 };
 
@@ -111,6 +132,13 @@ static struct data_device_format *data_device_format_for_mime_type(const char *m
     return NULL;
 }
 
+static ATOM register_clipboard_format(const WCHAR *name)
+{
+    ATOM atom;
+    if (NtAddAtom(name, lstrlenW(name) * sizeof(WCHAR), &atom)) return 0;
+    return atom;
+}
+
 /**********************************************************************
  *          zwlr_data_control_source_v1 handling
  */
@@ -146,7 +174,7 @@ static void wayland_data_source_export(struct data_device_format *format, int fd
     NtUserCloseClipboard();
     if (exported) write_all(fd, exported, exported_size);
 
-    free(exported);
+    if (exported != params.data) free(exported);
     free(params.data);
 }
 
@@ -182,6 +210,7 @@ static const struct zwlr_data_control_source_v1_listener data_control_source_lis
 void wayland_data_device_init(void)
 {
     struct wayland_data_device *data_device = &process_wayland.data_device;
+    struct data_device_format *format = supported_formats;
 
     TRACE("\n");
 
@@ -193,6 +222,12 @@ void wayland_data_device_init(void)
             process_wayland.zwlr_data_control_manager_v1,
             process_wayland.seat.wl_seat);
     pthread_mutex_unlock(&data_device->mutex);
+
+    for (; format->mime_type; ++format)
+    {
+        if (format->clipboard_format == 0)
+            format->clipboard_format = register_clipboard_format(format->register_name);
+    }
 }
 
 static void clipboard_update(void)
-- 
2.49.0

From 566833d26aba84d952379255e4f452465b0f06fa Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 29 Jan 2025 10:23:44 +0200
Subject: [PATCH 11/78] winewayland: Support copying data from native clipboard
 to win32 apps.

---
 dlls/winewayland.drv/wayland_data_device.c | 379 ++++++++++++++++++++-
 dlls/winewayland.drv/waylanddrv.h          |   1 +
 2 files changed, 367 insertions(+), 13 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 1659e9bd6df..4018386b97c 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -25,6 +25,7 @@
 #include "config.h"
 
 #include <errno.h>
+#include <fcntl.h>
 #include <stdlib.h>
 #include <unistd.h>
 
@@ -33,12 +34,23 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
 
+/* A special MIME type we mark our data offers with, so we can detect that
+ * they are coming from us. */
+#define WINEWAYLAND_TAG_MIME_TYPE "application/x.winewayland.tag"
+
 struct data_device_format
 {
     const char *mime_type;
     UINT clipboard_format;
     const WCHAR *register_name;
     void *(*export)(void *data, size_t size, size_t *ret_size);
+    void *(*import)(void *data, size_t size, size_t *ret_size);
+};
+
+struct wayland_data_offer
+{
+    struct zwlr_data_control_offer_v1 *zwlr_data_control_offer_v1;
+    struct wl_array types;
 };
 
 static HWND clipboard_hwnd;
@@ -67,6 +79,59 @@ static void write_all(int fd, const void *buf, size_t count)
     }
 }
 
+static void *read_all(int fd, size_t *size_out)
+{
+    size_t buffer_size = 4096;
+    int total = 0;
+    unsigned char *buffer;
+    int nread;
+
+    if (!(buffer = malloc(buffer_size)))
+    {
+        ERR("failed to allocate read buffer\n");
+        goto out;
+    }
+
+    do
+    {
+        nread = read(fd, buffer + total, buffer_size - total);
+        if (nread == -1 && errno != EINTR)
+        {
+            TRACE("failed to read from fd (errno: %d)\n", errno);
+            total = 0;
+            goto out;
+        }
+        else if (nread > 0)
+        {
+            total += nread;
+            if (total == buffer_size)
+            {
+                unsigned char *new_buffer;
+                buffer_size *= 2;
+                new_buffer = realloc(buffer, buffer_size);
+                if (!new_buffer)
+                {
+                    ERR("failed to reallocate read buffer\n");
+                    total = 0;
+                    goto out;
+                }
+                buffer = new_buffer;
+            }
+        }
+    } while (nread > 0);
+
+    TRACE("read %d bytes\n", total);
+
+out:
+    if (total == 0 && buffer != NULL)
+    {
+        free(buffer);
+        buffer = NULL;
+    }
+    *size_out = total;
+    return buffer;
+}
+
 static void *export_unicode_text(void *data, size_t size, size_t *ret_size)
 {
     DWORD byte_count;
@@ -91,30 +156,66 @@ static void *export_data(void *data, size_t size, size_t *ret_size)
     return data;
 }
 
+static void *import_unicode_text(void *data, size_t size, size_t *ret_size)
+{
+    DWORD wsize;
+    WCHAR *ret;
+
+    RtlUTF8ToUnicodeN(NULL, 0, &wsize, data, size);
+    if (!(ret = malloc(wsize + sizeof(WCHAR)))) return NULL;
+    RtlUTF8ToUnicodeN(ret, wsize, &wsize, data, size);
+    ret[wsize / sizeof(WCHAR)] = 0;
+
+    *ret_size = wsize + sizeof(WCHAR);
+
+    return ret;
+}
+
+static void *import_data(void *data, size_t size, size_t *ret_size)
+{
+    *ret_size = size;
+    return data;
+}
+
 /* Order is important. When selecting a mime-type for a clipboard format we
  * will choose the first entry that matches the specified clipboard format. */
 static struct data_device_format supported_formats[] =
 {
-    {"text/plain;charset=utf-8", CF_UNICODETEXT, NULL, export_unicode_text},
-    {"text/rtf", 0, rich_text_formatW, export_data},
-    {"image/tiff", CF_TIFF, NULL, export_data},
-    {"image/png", 0, pngW, export_data},
-    {"image/jpeg", 0, jfifW, export_data},
-    {"image/gif", 0, gifW, export_data},
-    {"image/svg+xml", 0, image_svg_xmlW, export_data},
-    {"application/x-riff", CF_RIFF, NULL, export_data},
-    {"audio/wav", CF_WAVE, NULL, export_data},
-    {"audio/x-wav", CF_WAVE, NULL, export_data},
+    {"text/plain;charset=utf-8", CF_UNICODETEXT, NULL, export_unicode_text, import_unicode_text},
+    {"text/rtf", 0, rich_text_formatW, export_data, import_data},
+    {"image/tiff", CF_TIFF, NULL, export_data, import_data},
+    {"image/png", 0, pngW, export_data, import_data},
+    {"image/jpeg", 0, jfifW, export_data, import_data},
+    {"image/gif", 0, gifW, export_data, import_data},
+    {"image/svg+xml", 0, image_svg_xmlW, export_data, import_data},
+    {"application/x-riff", CF_RIFF, NULL, export_data, import_data},
+    {"audio/wav", CF_WAVE, NULL, export_data, import_data},
+    {"audio/x-wav", CF_WAVE, NULL, export_data, import_data},
     {NULL, 0, NULL},
 };
 
-static struct data_device_format *data_device_format_for_clipboard_format(UINT clipboard_format)
+static BOOL string_array_contains(struct wl_array *array, const char *str)
+{
+    char **p;
+
+    wl_array_for_each(p, array)
+        if (!strcmp(*p, str)) return TRUE;
+
+    return FALSE;
+}
+
+static struct data_device_format *data_device_format_for_clipboard_format(UINT clipboard_format,
+                                                                          struct wl_array *types)
 {
     struct data_device_format *format;
 
     for (format = supported_formats; format->mime_type; ++format)
     {
-        if (format->clipboard_format == clipboard_format) return format;
+        if (format->clipboard_format == clipboard_format &&
+            (!types || string_array_contains(types, format->mime_type)))
+        {
+            return format;
+        }
     }
 
     return NULL;
@@ -207,6 +308,202 @@ static const struct zwlr_data_control_source_v1_listener data_control_source_lis
     data_control_source_cancelled,
 };
 
+/**********************************************************************
+ *          zwlr_data_control_offer_v1 handling
+ */
+
+static void data_control_offer_offer(void *data,
+                                     struct zwlr_data_control_offer_v1 *zwlr_data_control_offer_v1,
+                                     const char *type)
+{
+    struct wayland_data_offer *data_offer = data;
+    const char *type_copy;
+    const char **p;
+
+    if ((type_copy = strdup(type)) &&
+        (p = wl_array_add(&data_offer->types, sizeof *p)))
+    {
+        *p = type_copy;
+    }
+}
+
+static const struct zwlr_data_control_offer_v1_listener data_control_offer_listener =
+{
+    data_control_offer_offer,
+};
+
+static void wayland_data_offer_create(struct zwlr_data_control_offer_v1 *zwlr_data_control_offer_v1)
+{
+    struct wayland_data_offer *data_offer;
+
+    if (!(data_offer = calloc(1, sizeof(*data_offer))))
+    {
+        ERR("Failed to allocate memory for data offer\n");
+        return;
+    }
+
+    data_offer->zwlr_data_control_offer_v1 = zwlr_data_control_offer_v1;
+    wl_array_init(&data_offer->types);
+    zwlr_data_control_offer_v1_add_listener(data_offer->zwlr_data_control_offer_v1,
+                                            &data_control_offer_listener, data_offer);
+}
+
+static void wayland_data_offer_destroy(struct wayland_data_offer *data_offer)
+{
+    char **p;
+
+    zwlr_data_control_offer_v1_destroy(data_offer->zwlr_data_control_offer_v1);
+    wl_array_for_each(p, &data_offer->types)
+        free(*p);
+    wl_array_release(&data_offer->types);
+    free(data_offer);
+}
+
+static int wayland_data_offer_get_import_fd(struct wayland_data_offer *data_offer,
+                                            const char *mime_type)
+{
+    int data_pipe[2];
+
+#if HAVE_PIPE2
+    if (pipe2(data_pipe, O_CLOEXEC) == -1)
+#endif
+    {
+        if (pipe(data_pipe) == -1)
+        {
+            ERR("failed to create clipboard data pipe\n");
+            return -1;
+        }
+        fcntl(data_pipe[0], F_SETFD, FD_CLOEXEC);
+        fcntl(data_pipe[1], F_SETFD, FD_CLOEXEC);
+    }
+
+    zwlr_data_control_offer_v1_receive(data_offer->zwlr_data_control_offer_v1,
+                                       mime_type, data_pipe[1]);
+    close(data_pipe[1]);
+
+    /* Flush to ensure our receive request reaches the server. */
+    wl_display_flush(process_wayland.wl_display);
+
+    return data_pipe[0];
+}
+
+static void *import_format(int fd, struct data_device_format *format, size_t *ret_size)
+{
+    size_t size;
+    void *data, *ret;
+
+    if (!(data = read_all(fd, &size))) return NULL;
+    ret = format->import(data, size, ret_size);
+    if (ret != data) free(data);
+    return ret;
+}
+
+/**********************************************************************
+ *          zwlr_data_control_device_v1 handling
+ */
+
+static void wayland_data_device_destroy_clipboard_data_offer(struct wayland_data_device *data_device)
+{
+    if (data_device->clipboard_zwlr_data_control_offer_v1)
+    {
+        struct wayland_data_offer *data_offer =
+            zwlr_data_control_offer_v1_get_user_data(data_device->clipboard_zwlr_data_control_offer_v1);
+        if (data_offer) wayland_data_offer_destroy(data_offer);
+        data_device->clipboard_zwlr_data_control_offer_v1 = NULL;
+    }
+}
+
+static void data_control_device_data_offer(
+    void *data,
+    struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1,
+    struct zwlr_data_control_offer_v1 *zwlr_data_control_offer_v1)
+{
+    wayland_data_offer_create(zwlr_data_control_offer_v1);
+}
+
+static void clipboard_update(void);
+
+static void data_control_device_selection(
+    void *data,
+    struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1,
+    struct zwlr_data_control_offer_v1 *zwlr_data_control_offer_v1)
+{
+    struct wayland_data_device *data_device = data;
+    struct wayland_data_offer *data_offer = NULL;
+    char **p;
+
+    if (!zwlr_data_control_offer_v1 ||
+        !(data_offer = zwlr_data_control_offer_v1_get_user_data(zwlr_data_control_offer_v1)))
+    {
+        TRACE("empty offer, clearing clipboard\n");
+        if (NtUserOpenClipboard(clipboard_hwnd, 0))
+        {
+            NtUserEmptyClipboard();
+            NtUserCloseClipboard();
+        }
+        goto done;
+    }
+
+    TRACE("updating clipboard from wayland offer\n");
+
+    /* If this offer contains the special winewayland tag mime-type, it was sent
+     * by a winewayland process to notify external wayland clients about a Wine
+     * clipboard update. */
+    wl_array_for_each(p, &data_offer->types)
+    {
+        if (!strcmp(*p, WINEWAYLAND_TAG_MIME_TYPE))
+        {
+            TRACE("offer sent by winewayland, ignoring\n");
+            wayland_data_offer_destroy(data_offer);
+            data_offer = NULL;
+            goto done;
+        }
+    }
+
+    if (!NtUserOpenClipboard(clipboard_hwnd, 0))
+    {
+        TRACE("failed to open clipboard for selection\n");
+        wayland_data_offer_destroy(data_offer);
+        data_offer = NULL;
+        goto done;
+    }
+
+    NtUserEmptyClipboard();
+
+    /* For each mime type, mark that we have available clipboard data. */
+    wl_array_for_each(p, &data_offer->types)
+    {
+        struct data_device_format *format = data_device_format_for_mime_type(*p);
+        if (format)
+        {
+            struct set_clipboard_params params = {0};
+            TRACE("available clipboard format for %s => %u\n",
+                  *p, format->clipboard_format);
+            NtUserSetClipboardData(format->clipboard_format, 0, &params);
+        }
+    }
+
+    NtUserCloseClipboard();
+
+done:
+    pthread_mutex_lock(&data_device->mutex);
+    wayland_data_device_destroy_clipboard_data_offer(data_device);
+    if (data_offer) data_device->clipboard_zwlr_data_control_offer_v1 = zwlr_data_control_offer_v1;
+    pthread_mutex_unlock(&data_device->mutex);
+}
+
+static void data_control_device_finished(
+    void *data, struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1)
+{
+}
+
+static const struct zwlr_data_control_device_v1_listener data_control_device_listener =
+{
+    data_control_device_data_offer,
+    data_control_device_selection,
+    data_control_device_finished,
+};
+
 void wayland_data_device_init(void)
 {
     struct wayland_data_device *data_device = &process_wayland.data_device;
@@ -221,6 +518,12 @@ void wayland_data_device_init(void)
         zwlr_data_control_manager_v1_get_data_device(
             process_wayland.zwlr_data_control_manager_v1,
             process_wayland.seat.wl_seat);
+    if (data_device->zwlr_data_control_device_v1)
+    {
+        zwlr_data_control_device_v1_add_listener(
+            data_device->zwlr_data_control_device_v1, &data_control_device_listener,
+            data_device);
+    }
     pthread_mutex_unlock(&data_device->mutex);
 
     for (; format->mime_type; ++format)
@@ -267,7 +570,7 @@ static void clipboard_update(void)
     for (i = 0; i < formats_size; ++i)
     {
         struct data_device_format *format =
-            data_device_format_for_clipboard_format(formats[i]);
+            data_device_format_for_clipboard_format(formats[i], NULL);
         if (format)
         {
             TRACE("offering mime=%s for format=%u\n", format->mime_type, formats[i]);
@@ -277,6 +580,7 @@ static void clipboard_update(void)
 
     free(formats);
 
+    zwlr_data_control_source_v1_offer(source, WINEWAYLAND_TAG_MIME_TYPE);
     zwlr_data_control_source_v1_add_listener(source, &data_control_source_listener, data_device);
 
     pthread_mutex_lock(&data_device->mutex);
@@ -292,6 +596,48 @@ static void clipboard_update(void)
     wl_display_flush(process_wayland.wl_display);
 }
 
+static void render_format(UINT clipboard_format)
+{
+    struct wayland_data_device *data_device = &process_wayland.data_device;
+    struct wayland_data_offer *data_offer;
+    struct data_device_format *format;
+    int import_fd = -1;
+
+    TRACE("clipboard_format=%u\n", clipboard_format);
+
+    pthread_mutex_lock(&data_device->mutex);
+    if (data_device->clipboard_zwlr_data_control_offer_v1 &&
+        (data_offer = zwlr_data_control_offer_v1_get_user_data(data_device->clipboard_zwlr_data_control_offer_v1)) &&
+        (format = data_device_format_for_clipboard_format(clipboard_format,
+                                                          &data_offer->types)))
+    {
+        import_fd = wayland_data_offer_get_import_fd(data_offer, format->mime_type);
+    }
+    pthread_mutex_unlock(&data_device->mutex);
+
+    if (import_fd >= 0)
+    {
+        struct set_clipboard_params params = {0};
+        if ((params.data = import_format(import_fd, format, &params.size)))
+        {
+            NtUserSetClipboardData(format->clipboard_format, 0, &params);
+            free(params.data);
+        }
+        close(import_fd);
+    }
+}
+
+static void destroy_clipboard(void)
+{
+    struct wayland_data_device *data_device = &process_wayland.data_device;
+
+    TRACE("\n");
+
+    pthread_mutex_lock(&data_device->mutex);
+    wayland_data_device_destroy_clipboard_data_offer(data_device);
+    pthread_mutex_unlock(&data_device->mutex);
+}
+
 LRESULT WAYLAND_ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
 {
     switch (msg)
@@ -305,8 +651,15 @@ LRESULT WAYLAND_ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM l
         pthread_mutex_unlock(&process_wayland.seat.mutex);
         return TRUE;
     case WM_CLIPBOARDUPDATE:
+        if (NtUserGetClipboardOwner() == clipboard_hwnd) break;
         clipboard_update();
         break;
+    case WM_RENDERFORMAT:
+        render_format(wparam);
+        break;
+    case WM_DESTROYCLIPBOARD:
+        destroy_clipboard();
+        break;
     }
 
     return NtUserMessageCall(hwnd, msg, wparam, lparam, NULL, NtUserDefWindowProc, FALSE);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index c8f0ede23ba..c389167c3b7 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -134,6 +134,7 @@ struct wayland_data_device
 {
     struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1;
     struct zwlr_data_control_source_v1 *zwlr_data_control_source_v1;
+    struct zwlr_data_control_offer_v1 *clipboard_zwlr_data_control_offer_v1;
     pthread_mutex_t mutex;
 };
 
-- 
2.49.0

From a0f34766a5fca0e58125e409d0db437317ce1506 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 29 Jan 2025 13:39:02 +0200
Subject: [PATCH 12/78] winewayland: Normalize received MIME type strings.

---
 dlls/winewayland.drv/wayland_data_device.c | 45 +++++++++++++++++++---
 1 file changed, 39 insertions(+), 6 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 4018386b97c..04872df4fcb 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -60,6 +60,35 @@ static const WCHAR jfifW[] = {'J','F','I','F',0};
 static const WCHAR gifW[] = {'G','I','F',0};
 static const WCHAR image_svg_xmlW[] = {'i','m','a','g','e','/','s','v','g','+','x','m','l',0};
 
+/* Normalize the MIME type string by skipping inconsequential characters,
+ * such as spaces and double quotes, and convert to lower case. */
+static const char *normalize_mime_type(const char *mime_type)
+{
+    char *new_mime_type;
+    const char *cur_read;
+    char *cur_write;
+    size_t new_mime_len = 0;
+
+    for (cur_read = mime_type; *cur_read != '\0'; ++cur_read)
+    {
+        if (*cur_read != ' ' && *cur_read != '"')
+            new_mime_len++;
+    }
+
+    new_mime_type = malloc(new_mime_len + 1);
+    if (!new_mime_type) return NULL;
+
+    for (cur_read = mime_type, cur_write = new_mime_type; *cur_read != '\0'; ++cur_read)
+    {
+        if (*cur_read != ' ' && *cur_read != '"')
+            *cur_write++ = tolower(*cur_read);
+    }
+
+    *cur_write = '\0';
+
+    return new_mime_type;
+}
+
 static void write_all(int fd, const void *buf, size_t count)
 {
     size_t nwritten = 0;
@@ -283,10 +312,14 @@ static void data_control_source_send(void *data,
                                      struct zwlr_data_control_source_v1 *source,
                                      const char *mime_type, int32_t fd)
 {
-    struct data_device_format *format =
-        data_device_format_for_mime_type(mime_type);
+    struct data_device_format *format;
+    const char *normalized;
 
-    if (format) wayland_data_source_export(format, fd);
+    if ((normalized = normalize_mime_type(mime_type)) &&
+        (format = data_device_format_for_mime_type(normalized)))
+    {
+        wayland_data_source_export(format, fd);
+    }
     close(fd);
 }
 
@@ -317,13 +350,13 @@ static void data_control_offer_offer(void *data,
                                      const char *type)
 {
     struct wayland_data_offer *data_offer = data;
-    const char *type_copy;
+    const char *normalized;
     const char **p;
 
-    if ((type_copy = strdup(type)) &&
+    if ((normalized = normalize_mime_type(type)) &&
         (p = wl_array_add(&data_offer->types, sizeof *p)))
     {
-        *p = type_copy;
+        *p = normalized;
     }
 }
 
-- 
2.49.0

From fa40f46501829ea3c3d1eddd141676938666d4b4 Mon Sep 17 00:00:00 2001
From: Attila Fidan <dev@print0.net>
Date: Mon, 17 Feb 2025 04:15:35 +0000
Subject: [PATCH 13/78] winewayland: Update locked pointer position hint.

This may be used by the compositor to warp the Wayland pointer to where
the win32 cursor is upon unlock, if it's within surface bounds.
---
 dlls/winewayland.drv/wayland_pointer.c | 30 ++++++++++++++++++++++++--
 1 file changed, 28 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index c20ba170285..52aaa337aac 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -885,27 +885,53 @@ void WAYLAND_SetCursor(HWND hwnd, HCURSOR hcursor)
 BOOL WAYLAND_ClipCursor(const RECT *clip, BOOL reset)
 {
     struct wayland_pointer *pointer = &process_wayland.pointer;
+    HWND hwnd;
     struct wl_surface *wl_surface = NULL;
     struct wayland_surface *surface = NULL;
     struct wayland_win_data *data;
     BOOL covers_vscreen = FALSE;
     RECT confine_rect;
+    POINT cursor_pos;
+    int warp_x, warp_y;
 
     TRACE("clip=%s reset=%d\n", wine_dbgstr_rect(clip), reset);
 
-    if (!(data = wayland_win_data_get(NtUserGetForegroundWindow()))) return FALSE;
+    NtUserGetCursorPos(&cursor_pos);
+    hwnd = NtUserGetForegroundWindow();
+
+    if (!(data = wayland_win_data_get(hwnd))) return FALSE;
     if ((surface = data->wayland_surface))
     {
         wl_surface = surface->wl_surface;
         if (clip) wayland_surface_calc_confine(surface, clip, &confine_rect);
         covers_vscreen = wayland_surface_client_covers_vscreen(surface);
+        wayland_surface_coords_from_window(surface,
+                cursor_pos.x - surface->window.rect.left,
+                cursor_pos.y - surface->window.rect.top,
+                &warp_x, &warp_y);
     }
     wayland_win_data_release(data);
 
+    pthread_mutex_lock(&pointer->mutex);
+    if (wl_surface && hwnd == pointer->constraint_hwnd && pointer->zwp_locked_pointer_v1)
+    {
+        zwp_locked_pointer_v1_set_cursor_position_hint(
+                pointer->zwp_locked_pointer_v1,
+                wl_fixed_from_int(warp_x),
+                wl_fixed_from_int(warp_y));
+        pthread_mutex_unlock(&pointer->mutex);
+
+        data = wayland_win_data_get(hwnd);
+        wl_surface_commit(wl_surface);
+        wayland_win_data_release(data);
+        TRACE("position hint hwnd=%p wayland_xy=%d,%d screen_xy=%d,%d\n",
+                hwnd, warp_x, warp_y, (int)cursor_pos.x, (int)cursor_pos.y);
+        pthread_mutex_lock(&pointer->mutex);
+    }
+
    /* Since we are running in the context of the foreground thread we know
     * that the wl_surface of the foreground HWND will not be invalidated,
     * so we can access it without having the win data lock. */
-    pthread_mutex_lock(&pointer->mutex);
     wayland_pointer_update_constraint(wl_surface,
                                       (clip && wl_surface) ? &confine_rect : NULL,
                                       covers_vscreen);
-- 
2.49.0

From 32b2f772124f299974390cc253823b20e791a3aa Mon Sep 17 00:00:00 2001
From: Attila Fidan <dev@print0.net>
Date: Sun, 16 Feb 2025 10:00:41 +0000
Subject: [PATCH 14/78] winewayland: Implement SetCursorPos via pointer lock.

---
 dlls/winewayland.drv/wayland_pointer.c | 42 ++++++++++++++++++++++----
 dlls/winewayland.drv/waylanddrv.h      |  2 ++
 dlls/winewayland.drv/waylanddrv_main.c |  1 +
 3 files changed, 39 insertions(+), 6 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 52aaa337aac..e2b31e02011 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -745,7 +745,8 @@ static BOOL wayland_surface_client_covers_vscreen(struct wayland_surface *surfac
  */
 static void wayland_pointer_update_constraint(struct wl_surface *wl_surface,
                                               RECT *confine_rect,
-                                              BOOL covers_vscreen)
+                                              BOOL covers_vscreen,
+                                              BOOL force_lock)
 {
     struct wayland_pointer *pointer = &process_wayland.pointer;
     BOOL needs_relative, needs_lock, needs_confine;
@@ -758,9 +759,10 @@ static void wayland_pointer_update_constraint(struct wl_surface *wl_surface,
         return;
     }
 
-    needs_lock = wl_surface && (confine_rect || covers_vscreen) &&
-                 !pointer->cursor.wl_surface;
-    needs_confine = wl_surface && confine_rect && pointer->cursor.wl_surface;
+    needs_lock = wl_surface && (((confine_rect || covers_vscreen) &&
+                 !pointer->cursor.wl_surface) || force_lock);
+    needs_confine = wl_surface && confine_rect && pointer->cursor.wl_surface &&
+                 !force_lock;
 
     if (!needs_confine && pointer->zwp_confined_pointer_v1)
     {
@@ -866,7 +868,7 @@ static void wayland_pointer_update_constraint(struct wl_surface *wl_surface,
 
 void wayland_pointer_clear_constraint(void)
 {
-    wayland_pointer_update_constraint(NULL, NULL, FALSE);
+    wayland_pointer_update_constraint(NULL, NULL, FALSE, FALSE);
 }
 
 /***********************************************************************
@@ -879,6 +881,27 @@ void WAYLAND_SetCursor(HWND hwnd, HCURSOR hcursor)
     wayland_set_cursor(hwnd, hcursor, TRUE);
 }
 
+/***********************************************************************
+ *           WAYLAND_SetCursorPos
+ */
+BOOL WAYLAND_SetCursorPos(INT x, INT y)
+{
+    struct wayland_pointer *pointer = &process_wayland.pointer;
+
+    pthread_mutex_lock(&pointer->mutex);
+    if (pointer->zwp_relative_pointer_v1)
+    {
+        pthread_mutex_unlock(&pointer->mutex);
+        return FALSE;
+    }
+    pointer->pending_warp = TRUE;
+    pthread_mutex_unlock(&pointer->mutex);
+
+    TRACE("warping to %d,%d\n", x, y);
+    reapply_cursor_clipping();
+    return TRUE;
+}
+
 /***********************************************************************
  *	     WAYLAND_ClipCursor
  */
@@ -913,6 +936,12 @@ BOOL WAYLAND_ClipCursor(const RECT *clip, BOOL reset)
     wayland_win_data_release(data);
 
     pthread_mutex_lock(&pointer->mutex);
+    if (wl_surface && pointer->pending_warp)
+    {
+        wayland_pointer_update_constraint(wl_surface, NULL, FALSE, TRUE);
+        pointer->pending_warp = FALSE;
+    }
+
     if (wl_surface && hwnd == pointer->constraint_hwnd && pointer->zwp_locked_pointer_v1)
     {
         zwp_locked_pointer_v1_set_cursor_position_hint(
@@ -934,7 +963,8 @@ BOOL WAYLAND_ClipCursor(const RECT *clip, BOOL reset)
     * so we can access it without having the win data lock. */
     wayland_pointer_update_constraint(wl_surface,
                                       (clip && wl_surface) ? &confine_rect : NULL,
-                                      covers_vscreen);
+                                      covers_vscreen,
+                                      FALSE);
     pthread_mutex_unlock(&pointer->mutex);
 
     wl_display_flush(process_wayland.wl_display);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index c389167c3b7..ead2269b72c 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -107,6 +107,7 @@ struct wayland_pointer
     struct zwp_relative_pointer_v1 *zwp_relative_pointer_v1;
     HWND focused_hwnd;
     HWND constraint_hwnd;
+    BOOL pending_warp;
     uint32_t enter_serial;
     uint32_t button_serial;
     struct wayland_cursor cursor;
@@ -414,6 +415,7 @@ LRESULT WAYLAND_DesktopWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
 void WAYLAND_DestroyWindow(HWND hwnd);
 BOOL WAYLAND_SetIMECompositionRect(HWND hwnd, RECT rect);
 void WAYLAND_SetCursor(HWND hwnd, HCURSOR hcursor);
+BOOL WAYLAND_SetCursorPos(INT x, INT y);
 void WAYLAND_SetWindowText(HWND hwnd, LPCWSTR text);
 LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam, const POINT *pos);
 UINT WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager, void *param);
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index ca7ec47b674..1d4ddeb3425 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -43,6 +43,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pKbdLayerDescriptor = WAYLAND_KbdLayerDescriptor,
     .pReleaseKbdTables = WAYLAND_ReleaseKbdTables,
     .pSetCursor = WAYLAND_SetCursor,
+    .pSetCursorPos = WAYLAND_SetCursorPos,
     .pSetWindowText = WAYLAND_SetWindowText,
     .pSysCommand = WAYLAND_SysCommand,
     .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
-- 
2.49.0

From fae758e3af772ce69296ff1594ffa4c6cb68274e Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 18 Feb 2025 17:32:42 +0200
Subject: [PATCH 15/78] winewayland: Don't crash on text input done events
 without focus.

Some compositors (e.g., kwin) will send a done event for every commit,
regardless of the focus state of the text input. This behavior is
arguably out of spec, but otherwise harmless, so just ignore the new
state in such cases.
---
 dlls/winewayland.drv/wayland_text_input.c | 14 +++++++++-----
 1 file changed, 9 insertions(+), 5 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_text_input.c b/dlls/winewayland.drv/wayland_text_input.c
index 17257634b2e..e0181eb8240 100644
--- a/dlls/winewayland.drv/wayland_text_input.c
+++ b/dlls/winewayland.drv/wayland_text_input.c
@@ -131,11 +131,15 @@ static void text_input_done(void *data, struct zwp_text_input_v3 *zwp_text_input
     TRACE("data %p, text_input %p, serial %u.\n", data, zwp_text_input_v3, serial);
 
     pthread_mutex_lock(&text_input->mutex);
-    assert(text_input->wl_surface);
-    hwnd = wl_surface_get_user_data(text_input->wl_surface);
-
-    post_ime_update(hwnd, text_input->preedit_cursor_pos, text_input->preedit_string,
-            text_input->commit_string);
+    /* Some compositors will send a done event for every commit, regardless of
+     * the focus state of the text input. This behavior is arguably out of spec,
+     * but otherwise harmless, so just ignore the new state in such cases. */
+    if (text_input->wl_surface)
+    {
+        hwnd = wl_surface_get_user_data(text_input->wl_surface);
+        post_ime_update(hwnd, text_input->preedit_cursor_pos, text_input->preedit_string,
+                text_input->commit_string);
+    }
 
     free(text_input->preedit_string);
     text_input->preedit_string = NULL;
-- 
2.49.0

From 3e24f3dc597e79901c36f6dd4bc884d07a475ec0 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 5 Mar 2025 12:15:44 +0200
Subject: [PATCH 16/78] winewayland: Present EGL surfaces opaquely.

Many applications request and use GL configs with alpha, but assume that
the windowing system will present their surfaces opaquely. Wayland
compositors normally respect the alpha channel, which leads to unwanted
translucency effects for such applications, so we use the
EGL_EXT_present_opaque extension to avoid this.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=57800
---
 dlls/winewayland.drv/opengl.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index b8b673f398a..d9a83d49b3e 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -194,6 +194,7 @@ static struct wayland_gl_drawable *wayland_gl_drawable_create(HWND hwnd, int for
     struct wayland_gl_drawable *gl;
     int client_width, client_height;
     RECT client_rect = {0};
+    const EGLint attribs[] = {EGL_PRESENT_OPAQUE_EXT, EGL_TRUE, EGL_NONE};
 
     TRACE("hwnd=%p format=%d\n", hwnd, format);
 
@@ -223,7 +224,7 @@ static struct wayland_gl_drawable *wayland_gl_drawable_create(HWND hwnd, int for
     }
 
     gl->surface = p_eglCreateWindowSurface(egl_display, egl_config_for_format(format),
-                                           gl->wl_egl_window, NULL);
+                                           gl->wl_egl_window, attribs);
     if (!gl->surface)
     {
         ERR("Failed to create EGL surface\n");
@@ -1397,6 +1398,7 @@ static void init_opengl(void)
     REQUIRE_EXT(EGL_KHR_create_context);
     REQUIRE_EXT(EGL_KHR_create_context_no_error);
     REQUIRE_EXT(EGL_KHR_no_config_context);
+    REQUIRE_EXT(EGL_EXT_present_opaque);
 #undef REQUIRE_EXT
 
     has_egl_ext_pixel_format_float = has_extension(egl_exts, "EGL_EXT_pixel_format_float");
-- 
2.49.0

From d151e203edf30d4b0b6dc1cfdbae244a8e4a8f31 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 6 Mar 2025 17:09:58 +0200
Subject: [PATCH 17/78] winewayland: Treat fully transparent cursors as hidden.

SDL 2.0.18 and newer (including SDL 3) set a fully transparent cursor
object when hiding the cursor (instead of using a NULL cursor handle).
Detect this case and treat it as a request to hide the cursor, to make
our locking/relative-motion heuristics work.
---
 dlls/winewayland.drv/wayland_pointer.c | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index e2b31e02011..17139c47b13 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -494,6 +494,17 @@ static BOOL get_icon_info(HICON handle, ICONINFOEXW *ret)
     return TRUE;
 }
 
+static BOOL cursor_buffer_is_transparent(struct wayland_shm_buffer *shm_buffer)
+{
+    uint32_t *pixel = shm_buffer->map_data;
+    uint32_t *end = pixel + shm_buffer->map_size / WINEWAYLAND_BYTES_PER_PIXEL;
+
+    for (; pixel < end; ++pixel)
+        if ((*pixel & 0xff000000) != 0) return FALSE;
+
+    return TRUE;
+}
+
 static void wayland_pointer_update_cursor_buffer(HCURSOR hcursor, double scale)
 {
     struct wayland_cursor *cursor = &process_wayland.pointer.cursor;
@@ -538,6 +549,9 @@ static void wayland_pointer_update_cursor_buffer(HCURSOR hcursor, double scale)
         goto clear_cursor;
     }
 
+    if (cursor_buffer_is_transparent(cursor->shm_buffer))
+        goto clear_cursor;
+
     /* Make sure the hotspot is valid. */
     if (cursor->hotspot_x >= cursor->shm_buffer->width ||
         cursor->hotspot_y >= cursor->shm_buffer->height)
-- 
2.49.0

From 32fcfb25436f4bf33d25e0209e84d0c2ad48dd4b Mon Sep 17 00:00:00 2001
From: Attila Fidan <dev@print0.net>
Date: Thu, 20 Mar 2025 11:45:41 +0000
Subject: [PATCH 18/78] win32u: Return 0 from NtUserGetKeyNameText if there is
 no translation.

---
 dlls/win32u/input.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/win32u/input.c b/dlls/win32u/input.c
index 97e651a7ce5..8b90b78f019 100644
--- a/dlls/win32u/input.c
+++ b/dlls/win32u/input.c
@@ -1283,7 +1283,7 @@ INT WINAPI NtUserGetKeyNameText( LONG lparam, WCHAR *buffer, INT size )
         HKL hkl = NtUserGetKeyboardLayout( 0 );
         vkey = NtUserMapVirtualKeyEx( code & 0xff, MAPVK_VSC_TO_VK, hkl );
         buffer[0] = NtUserMapVirtualKeyEx( vkey, MAPVK_VK_TO_CHAR, hkl );
-        len = 1;
+        len = buffer[0] ? 1 : 0;
     }
     buffer[len] = 0;
 
-- 
2.49.0

From e40d71244075c35bfd9e2cfd180c2b09c9e7cbe2 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 7 Feb 2025 13:23:46 +0200
Subject: [PATCH 19/78] winewayland: Implement wl_data_device initialization.

The data device is initialized once for each process, from within a
dedicated thread and window that handles clipboard events.
---
 dlls/winewayland.drv/Makefile.in           |  1 +
 dlls/winewayland.drv/dllmain.c             | 61 ++++++++++++++++++++++
 dlls/winewayland.drv/unixlib.h             |  1 +
 dlls/winewayland.drv/wayland.c             | 10 +++-
 dlls/winewayland.drv/wayland_data_device.c | 55 ++++++++++++++-----
 dlls/winewayland.drv/waylanddrv.h          | 17 ++++--
 dlls/winewayland.drv/waylanddrv_main.c     | 11 ++++
 7 files changed, 140 insertions(+), 16 deletions(-)

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 142db22ba9e..4141e36c9a8 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -2,6 +2,7 @@ MODULE = winewayland.drv
 UNIXLIB = winewayland.so
 UNIX_CFLAGS = $(EGL_CFLAGS) $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_EGL_CFLAGS) $(XKBCOMMON_CFLAGS) $(XKBREGISTRY_CFLAGS)
 UNIX_LIBS = -lwin32u $(WAYLAND_CLIENT_LIBS) $(WAYLAND_EGL_LIBS) $(XKBCOMMON_LIBS) $(XKBREGISTRY_LIBS) $(PTHREAD_LIBS) -lm
+IMPORTS = user32 win32u
 
 SOURCES = \
 	display.c \
diff --git a/dlls/winewayland.drv/dllmain.c b/dlls/winewayland.drv/dllmain.c
index d040620957b..8055d883ee0 100644
--- a/dlls/winewayland.drv/dllmain.c
+++ b/dlls/winewayland.drv/dllmain.c
@@ -20,6 +20,9 @@
 
 #include "waylanddrv_dll.h"
 
+#include "ntuser.h"
+#include "winuser.h"
+
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
@@ -35,6 +38,61 @@ static DWORD WINAPI wayland_read_events_thread(void *arg)
     return 0;
 }
 
+static LRESULT CALLBACK clipboard_wndproc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
+{
+    switch (msg)
+    {
+    case WM_NCCREATE:
+    case WM_CLIPBOARDUPDATE:
+    case WM_RENDERFORMAT:
+    case WM_TIMER:
+    case WM_DESTROYCLIPBOARD:
+    case WM_USER:
+        return NtUserMessageCall(hwnd, msg, wp, lp, 0, NtUserClipboardWindowProc, FALSE);
+    }
+
+    return DefWindowProcW(hwnd, msg, wp, lp);
+}
+
+static DWORD WINAPI clipboard_thread(void *arg)
+{
+    static const WCHAR clipboard_classname[] = L"__winewayland_clipboard_manager";
+    WNDCLASSW class;
+    ATOM atom;
+    MSG msg;
+    HWND hwnd;
+
+    memset(&class, 0, sizeof(class));
+    class.lpfnWndProc = clipboard_wndproc;
+    class.lpszClassName = clipboard_classname;
+
+    if (!(atom = RegisterClassW(&class)) && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
+    {
+        ERR("could not register clipboard window class err %lu\n", GetLastError());
+        return 0;
+    }
+    /* The HWND_MESSAGE parent window may not have been created yet. It will be
+     * created eventually, so keep trying. */
+    while (!(hwnd = CreateWindowW(clipboard_classname, NULL, 0, 0, 0, 0, 0,
+                                  HWND_MESSAGE, 0, 0, NULL)) &&
+           GetLastError() == ERROR_INVALID_WINDOW_HANDLE)
+    {
+        SwitchToThread();
+    }
+
+    if (!hwnd)
+    {
+        TRACE("failed to create clipboard window err %lu\n", GetLastError());
+        UnregisterClassW(MAKEINTRESOURCEW(atom), NULL);
+        return 0;
+    }
+
+    TRACE("created per-process clipboard window hwnd=%p\n", hwnd);
+
+    while (GetMessageW(&msg, 0, 0, 0)) DispatchMessageW(&msg);
+    return 0;
+}
+
 BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
 {
     DWORD tid;
@@ -49,6 +107,9 @@ BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
 
     /* Read wayland events from a dedicated thread. */
     CloseHandle(CreateThread(NULL, 0, wayland_read_events_thread, NULL, 0, &tid));
+    /* Handle clipboard events in a dedicated thread, if needed. */
+    if (!WAYLANDDRV_UNIX_CALL(init_clipboard, NULL))
+        CloseHandle(CreateThread(NULL, 0, clipboard_thread, NULL, 0, &tid));
 
     return TRUE;
 }
diff --git a/dlls/winewayland.drv/unixlib.h b/dlls/winewayland.drv/unixlib.h
index dc3bfdf8893..d9378fe8248 100644
--- a/dlls/winewayland.drv/unixlib.h
+++ b/dlls/winewayland.drv/unixlib.h
@@ -27,6 +27,7 @@ enum waylanddrv_unix_func
 {
     waylanddrv_unix_func_init,
     waylanddrv_unix_func_read_events,
+    waylanddrv_unix_func_init_clipboard,
     waylanddrv_unix_func_count,
 };
 
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index ee162d8fe77..2a51222fd5f 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -147,8 +147,11 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         pthread_mutex_unlock(&seat->mutex);
         if (process_wayland.zwp_text_input_manager_v3) wayland_text_input_init();
         /* Recreate the data device for the new seat. */
-        if (process_wayland.data_device.zwlr_data_control_device_v1)
+        if (process_wayland.data_device.zwlr_data_control_device_v1 ||
+            process_wayland.data_device.wl_data_device)
+        {
             wayland_data_device_init();
+        }
     }
     else if (strcmp(interface, "wp_viewporter") == 0)
     {
@@ -181,6 +184,11 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         process_wayland.zwlr_data_control_manager_v1 =
             wl_registry_bind(registry, id, &zwlr_data_control_manager_v1_interface, 1);
     }
+    else if (strcmp(interface, "wl_data_device_manager") == 0)
+    {
+        process_wayland.wl_data_device_manager =
+            wl_registry_bind(registry, id, &wl_data_device_manager_interface, 2);
+    }
 }
 
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 04872df4fcb..472df0a2717 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -545,17 +545,29 @@ void wayland_data_device_init(void)
     TRACE("\n");
 
     pthread_mutex_lock(&data_device->mutex);
-    if (data_device->zwlr_data_control_device_v1)
-        zwlr_data_control_device_v1_destroy(data_device->zwlr_data_control_device_v1);
-    data_device->zwlr_data_control_device_v1 =
-        zwlr_data_control_manager_v1_get_data_device(
-            process_wayland.zwlr_data_control_manager_v1,
-            process_wayland.seat.wl_seat);
-    if (data_device->zwlr_data_control_device_v1)
+    if (process_wayland.zwlr_data_control_manager_v1)
+    {
+        if (data_device->zwlr_data_control_device_v1)
+            zwlr_data_control_device_v1_destroy(data_device->zwlr_data_control_device_v1);
+        data_device->zwlr_data_control_device_v1 =
+            zwlr_data_control_manager_v1_get_data_device(
+                process_wayland.zwlr_data_control_manager_v1,
+                process_wayland.seat.wl_seat);
+        if (data_device->zwlr_data_control_device_v1)
+        {
+            zwlr_data_control_device_v1_add_listener(
+                data_device->zwlr_data_control_device_v1, &data_control_device_listener,
+                data_device);
+        }
+    }
+    else if (process_wayland.wl_data_device_manager)
     {
-        zwlr_data_control_device_v1_add_listener(
-            data_device->zwlr_data_control_device_v1, &data_control_device_listener,
-            data_device);
+        if (data_device->wl_data_device)
+            wl_data_device_release(data_device->wl_data_device);
+        data_device->wl_data_device =
+            wl_data_device_manager_get_data_device(
+                process_wayland.wl_data_device_manager,
+                process_wayland.seat.wl_seat);
     }
     pthread_mutex_unlock(&data_device->mutex);
 
@@ -671,16 +683,35 @@ static void destroy_clipboard(void)
     pthread_mutex_unlock(&data_device->mutex);
 }
 
+static BOOL is_winewayland_clipboard_hwnd(HWND hwnd)
+{
+    static const WCHAR clipboard_classnameW[] = {
+        '_','_','w','i','n','e','w','a','y','l','a','n','d','_',
+        'c','l','i','p','b','o','a','r','d','_','m','a','n','a','g','e','r'};
+    WCHAR buffer[64];
+    UNICODE_STRING name = {.Buffer = buffer, .MaximumLength = sizeof(buffer)};
+
+    if (!NtUserGetClassName(hwnd, FALSE, &name)) return FALSE;
+    return !wcscmp(buffer, clipboard_classnameW);
+}
+
 LRESULT WAYLAND_ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
 {
     switch (msg)
     {
     case WM_NCCREATE:
+        /* Disable the default clipboard window in the desktop process if we are
+         * using the core wl_data_device protocol. */
+        if (!process_wayland.zwlr_data_control_manager_v1 &&
+            process_wayland.wl_data_device_manager &&
+            !is_winewayland_clipboard_hwnd(hwnd))
+        {
+            return FALSE;
+        }
         clipboard_hwnd = hwnd;
         NtUserAddClipboardFormatListener(hwnd);
         pthread_mutex_lock(&process_wayland.seat.mutex);
-        if (process_wayland.seat.wl_seat && process_wayland.zwlr_data_control_manager_v1)
-            wayland_data_device_init();
+        if (process_wayland.seat.wl_seat) wayland_data_device_init();
         pthread_mutex_unlock(&process_wayland.seat.mutex);
         return TRUE;
     case WM_CLIPBOARDUPDATE:
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index ead2269b72c..c2fb56dc9bf 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -133,9 +133,19 @@ struct wayland_seat
 
 struct wayland_data_device
 {
-    struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1;
-    struct zwlr_data_control_source_v1 *zwlr_data_control_source_v1;
-    struct zwlr_data_control_offer_v1 *clipboard_zwlr_data_control_offer_v1;
+    union
+    {
+        struct
+        {
+            struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1;
+            struct zwlr_data_control_source_v1 *zwlr_data_control_source_v1;
+            struct zwlr_data_control_offer_v1 *clipboard_zwlr_data_control_offer_v1;
+        };
+        struct
+        {
+            struct wl_data_device *wl_data_device;
+        };
+    };
     pthread_mutex_t mutex;
 };
 
@@ -155,6 +165,7 @@ struct wayland
     struct zwp_relative_pointer_manager_v1 *zwp_relative_pointer_manager_v1;
     struct zwp_text_input_manager_v3 *zwp_text_input_manager_v3;
     struct zwlr_data_control_manager_v1 *zwlr_data_control_manager_v1;
+    struct wl_data_device_manager *wl_data_device_manager;
     struct wayland_seat seat;
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 1d4ddeb3425..dba519b1df1 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -110,10 +110,20 @@ static NTSTATUS waylanddrv_unix_read_events(void *arg)
     return STATUS_UNSUCCESSFUL;
 }
 
+static NTSTATUS waylanddrv_unix_init_clipboard(void *arg)
+{
+    /* If the compositor supports zwlr_data_control_manager_v1, we don't need
+     * per-process clipboard window and handling, we can use the default clipboard
+     * window from the desktop process. */
+    if (process_wayland.zwlr_data_control_manager_v1) return STATUS_UNSUCCESSFUL;
+    return STATUS_SUCCESS;
+}
+
 const unixlib_entry_t __wine_unix_call_funcs[] =
 {
     waylanddrv_unix_init,
     waylanddrv_unix_read_events,
+    waylanddrv_unix_init_clipboard,
 };
 
 C_ASSERT(ARRAYSIZE(__wine_unix_call_funcs) == waylanddrv_unix_func_count);
@@ -124,6 +134,7 @@ const unixlib_entry_t __wine_unix_call_wow64_funcs[] =
 {
     waylanddrv_unix_init,
     waylanddrv_unix_read_events,
+    waylanddrv_unix_init_clipboard,
 };
 
 C_ASSERT(ARRAYSIZE(__wine_unix_call_wow64_funcs) == waylanddrv_unix_func_count);
-- 
2.49.0

From f8712e189bab396c54b63493cb5dde2a91f3fc34 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 14 Mar 2025 10:13:26 +0200
Subject: [PATCH 20/78] winewayland: Support wl_data_device for copies from
 win32 clipboard to native apps.

If the wlr-data-control-unstable-v1 extension is not available use
the core data device protocol.
---
 dlls/winewayland.drv/wayland_data_device.c | 124 ++++++++++++++++++---
 dlls/winewayland.drv/wayland_keyboard.c    |   8 ++
 dlls/winewayland.drv/wayland_pointer.c     |   6 +
 dlls/winewayland.drv/waylanddrv.h          |   2 +
 4 files changed, 126 insertions(+), 14 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index 472df0a2717..c2d5b6e095c 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -537,6 +537,64 @@ static const struct zwlr_data_control_device_v1_listener data_control_device_lis
     data_control_device_finished,
 };
 
+/**********************************************************************
+ *          wl_data_source handling
+ */
+
+static void data_source_target(void *data, struct wl_data_source *source,
+                               const char *mime_type)
+{
+}
+
+static void data_source_send(void *data, struct wl_data_source *source,
+                             const char *mime_type, int32_t fd)
+{
+    struct data_device_format *format;
+    const char *normalized;
+
+    if ((normalized = normalize_mime_type(mime_type)) &&
+        (format = data_device_format_for_mime_type(normalized)))
+    {
+        wayland_data_source_export(format, fd);
+    }
+    close(fd);
+}
+
+static void data_source_cancelled(void *data, struct wl_data_source *source)
+{
+    struct wayland_data_device *data_device = data;
+
+    pthread_mutex_lock(&data_device->mutex);
+    wl_data_source_destroy(source);
+    if (source == data_device->wl_data_source)
+        data_device->wl_data_source = NULL;
+    pthread_mutex_unlock(&data_device->mutex);
+}
+
+static void data_source_dnd_drop_performed(void *data,
+                                           struct wl_data_source *source)
+{
+}
+
+static void data_source_dnd_finished(void *data, struct wl_data_source *source)
+{
+}
+
+static void data_source_action(void *data, struct wl_data_source *source,
+                               uint32_t dnd_action)
+{
+}
+
+static const struct wl_data_source_listener data_source_listener =
+{
+    data_source_target,
+    data_source_send,
+    data_source_cancelled,
+    data_source_dnd_drop_performed,
+    data_source_dnd_finished,
+    data_source_action,
+};
+
 void wayland_data_device_init(void)
 {
     struct wayland_data_device *data_device = &process_wayland.data_device;
@@ -581,16 +639,33 @@ void wayland_data_device_init(void)
 static void clipboard_update(void)
 {
     struct wayland_data_device *data_device = &process_wayland.data_device;
-    struct zwlr_data_control_source_v1 *source;
+    struct zwlr_data_control_source_v1 *zwlr_source = NULL;
+    struct wl_data_source *wl_source = NULL;
     UINT *formats, formats_size = 256, i;
+    uint32_t serial = 0;
 
-    if (!process_wayland.zwlr_data_control_manager_v1) return;
+    if (process_wayland.zwlr_data_control_manager_v1)
+    {
+        zwlr_source = zwlr_data_control_manager_v1_create_data_source(
+            process_wayland.zwlr_data_control_manager_v1);
+    }
+    else
+    {
+        serial = InterlockedCompareExchange(&process_wayland.input_serial, 0, 0);
+        pthread_mutex_lock(&process_wayland.keyboard.mutex);
+        if (!process_wayland.keyboard.focused_hwnd) serial = 0;
+        pthread_mutex_unlock(&process_wayland.keyboard.mutex);
+        if (process_wayland.wl_data_device_manager && serial)
+        {
+            wl_source = wl_data_device_manager_create_data_source(
+                process_wayland.wl_data_device_manager);
+        }
+        else return;
+    }
 
     TRACE("\n");
 
-    source = zwlr_data_control_manager_v1_create_data_source(
-        process_wayland.zwlr_data_control_manager_v1);
-    if (!source)
+    if (!zwlr_source && !wl_source)
     {
         ERR("failed to create data source\n");
         return;
@@ -608,7 +683,8 @@ static void clipboard_update(void)
     if (!formats && formats_size)
     {
         ERR("failed to get clipboard formats\n");
-        zwlr_data_control_source_v1_destroy(source);
+        if (wl_source) wl_data_source_destroy(wl_source);
+        else zwlr_data_control_source_v1_destroy(zwlr_source);
         return;
     }
 
@@ -619,23 +695,43 @@ static void clipboard_update(void)
         if (format)
         {
             TRACE("offering mime=%s for format=%u\n", format->mime_type, formats[i]);
-            zwlr_data_control_source_v1_offer(source, format->mime_type);
+            if (wl_source) wl_data_source_offer(wl_source, format->mime_type);
+            else zwlr_data_control_source_v1_offer(zwlr_source, format->mime_type);
         }
     }
 
     free(formats);
 
-    zwlr_data_control_source_v1_offer(source, WINEWAYLAND_TAG_MIME_TYPE);
-    zwlr_data_control_source_v1_add_listener(source, &data_control_source_listener, data_device);
+    if (wl_source)
+    {
+        wl_data_source_offer(wl_source, WINEWAYLAND_TAG_MIME_TYPE);
+        wl_data_source_add_listener(wl_source, &data_source_listener, data_device);
+    }
+    else
+    {
+        zwlr_data_control_source_v1_offer(zwlr_source, WINEWAYLAND_TAG_MIME_TYPE);
+        zwlr_data_control_source_v1_add_listener(zwlr_source, &data_control_source_listener, data_device);
+    }
 
     pthread_mutex_lock(&data_device->mutex);
-    if (data_device->zwlr_data_control_device_v1)
-        zwlr_data_control_device_v1_set_selection(data_device->zwlr_data_control_device_v1, source);
     /* Destroy any previous source only after setting the new source, to
      * avoid spurious 'selection(nil)' events. */
-    if (data_device->zwlr_data_control_source_v1)
-        zwlr_data_control_source_v1_destroy(data_device->zwlr_data_control_source_v1);
-    data_device->zwlr_data_control_source_v1 = source;
+    if (wl_source)
+    {
+        if (data_device->wl_data_device)
+            wl_data_device_set_selection(data_device->wl_data_device, wl_source, serial);
+        if (data_device->wl_data_source)
+            wl_data_source_destroy(data_device->wl_data_source);
+        data_device->wl_data_source = wl_source;
+    }
+    else
+    {
+        if (data_device->zwlr_data_control_device_v1)
+            zwlr_data_control_device_v1_set_selection(data_device->zwlr_data_control_device_v1, zwlr_source);
+        if (data_device->zwlr_data_control_source_v1)
+            zwlr_data_control_source_v1_destroy(data_device->zwlr_data_control_source_v1);
+        data_device->zwlr_data_control_source_v1 = zwlr_source;
+    }
     pthread_mutex_unlock(&data_device->mutex);
 
     wl_display_flush(process_wayland.wl_display);
diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index 8f7b6dce30f..39b42231b00 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -745,6 +745,8 @@ static void keyboard_handle_enter(void *private, struct wl_keyboard *wl_keyboard
     struct wayland_win_data *data;
     HWND hwnd;
 
+    InterlockedExchange(&process_wayland.input_serial, serial);
+
     if (!wl_surface) return;
 
     /* The wl_surface user data remains valid and immutable for the whole
@@ -780,6 +782,8 @@ static void keyboard_handle_leave(void *data, struct wl_keyboard *wl_keyboard,
     struct wayland_keyboard *keyboard = &process_wayland.keyboard;
     HWND hwnd;
 
+    InterlockedExchange(&process_wayland.input_serial, serial);
+
     if (!wl_surface) return;
 
     /* The wl_surface user data remains valid and immutable for the whole
@@ -817,6 +821,8 @@ static void keyboard_handle_key(void *data, struct wl_keyboard *wl_keyboard,
     INPUT input = {0};
     HWND hwnd;
 
+    InterlockedExchange(&process_wayland.input_serial, serial);
+
     if (!(hwnd = wayland_keyboard_get_focused_hwnd())) return;
 
     TRACE_(key)("serial=%u hwnd=%p key=%d scan=%#x state=%#x\n", serial, hwnd, key, scan, state);
@@ -840,6 +846,8 @@ static void keyboard_handle_modifiers(void *data, struct wl_keyboard *wl_keyboar
 {
     struct wayland_keyboard *keyboard = &process_wayland.keyboard;
 
+    InterlockedExchange(&process_wayland.input_serial, serial);
+
     if (!wayland_keyboard_get_focused_hwnd()) return;
 
     TRACE("serial=%u mods_depressed=%#x mods_latched=%#x mods_locked=%#x xkb_group=%d stub!\n",
diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 17139c47b13..457c3675cf1 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -112,6 +112,8 @@ static void pointer_handle_enter(void *data, struct wl_pointer *wl_pointer,
     struct wayland_pointer *pointer = &process_wayland.pointer;
     HWND hwnd;
 
+    InterlockedExchange(&process_wayland.input_serial, serial);
+
     if (!wl_surface) return;
     /* The wl_surface user data remains valid and immutable for the whole
      * lifetime of the object, so it's safe to access without locking. */
@@ -139,6 +141,8 @@ static void pointer_handle_leave(void *data, struct wl_pointer *wl_pointer,
 {
     struct wayland_pointer *pointer = &process_wayland.pointer;
 
+    InterlockedExchange(&process_wayland.input_serial, serial);
+
     if (!wl_surface) return;
 
     TRACE("hwnd=%p\n", wl_surface_get_user_data(wl_surface));
@@ -157,6 +161,8 @@ static void pointer_handle_button(void *data, struct wl_pointer *wl_pointer,
     INPUT input = {0};
     HWND hwnd;
 
+    InterlockedExchange(&process_wayland.input_serial, serial);
+
     if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
 
     input.type = INPUT_MOUSE;
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index c2fb56dc9bf..1649e0f84f3 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -144,6 +144,7 @@ struct wayland_data_device
         struct
         {
             struct wl_data_device *wl_data_device;
+            struct wl_data_source *wl_data_source;
         };
     };
     pthread_mutex_t mutex;
@@ -174,6 +175,7 @@ struct wayland
     struct wl_list output_list;
     /* Protects the output_list and the wayland_output.current states. */
     pthread_mutex_t output_mutex;
+    LONG input_serial;
 };
 
 struct wayland_output_mode
-- 
2.49.0

From 3c08c7499eeccc5205b0e379eb2259a5d40833a5 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 17 Mar 2025 09:19:43 +0200
Subject: [PATCH 21/78] winewayland: Support wl_data_device for copies from
 native apps to win32 clipboard.

---
 dlls/winewayland.drv/wayland_data_device.c | 177 +++++++++++++++++----
 dlls/winewayland.drv/waylanddrv.h          |   1 +
 2 files changed, 148 insertions(+), 30 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index c2d5b6e095c..e36c0cc9229 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -49,7 +49,11 @@ struct data_device_format
 
 struct wayland_data_offer
 {
-    struct zwlr_data_control_offer_v1 *zwlr_data_control_offer_v1;
+    union
+    {
+        struct zwlr_data_control_offer_v1 *zwlr_data_control_offer_v1;
+        struct wl_data_offer *wl_data_offer;
+    };
     struct wl_array types;
 };
 
@@ -365,7 +369,17 @@ static const struct zwlr_data_control_offer_v1_listener data_control_offer_liste
     data_control_offer_offer,
 };
 
-static void wayland_data_offer_create(struct zwlr_data_control_offer_v1 *zwlr_data_control_offer_v1)
+static void data_offer_offer(void *data, struct wl_data_offer *wl_data_offer, const char *type)
+{
+    data_control_offer_offer(data, NULL, type);
+}
+
+static const struct wl_data_offer_listener data_offer_listener =
+{
+    data_offer_offer,
+};
+
+static void wayland_data_offer_create(void *offer_proxy)
 {
     struct wayland_data_offer *data_offer;
 
@@ -375,17 +389,30 @@ static void wayland_data_offer_create(struct zwlr_data_control_offer_v1 *zwlr_da
         return;
     }
 
-    data_offer->zwlr_data_control_offer_v1 = zwlr_data_control_offer_v1;
     wl_array_init(&data_offer->types);
-    zwlr_data_control_offer_v1_add_listener(data_offer->zwlr_data_control_offer_v1,
-                                            &data_control_offer_listener, data_offer);
+    if (process_wayland.zwlr_data_control_manager_v1)
+    {
+        data_offer->zwlr_data_control_offer_v1 = offer_proxy;
+        zwlr_data_control_offer_v1_add_listener(data_offer->zwlr_data_control_offer_v1,
+                                                &data_control_offer_listener, data_offer);
+    }
+    else
+    {
+        data_offer->wl_data_offer = offer_proxy;
+        wl_data_offer_add_listener(data_offer->wl_data_offer, &data_offer_listener,
+                                   data_offer);
+
+    }
 }
 
 static void wayland_data_offer_destroy(struct wayland_data_offer *data_offer)
 {
     char **p;
 
-    zwlr_data_control_offer_v1_destroy(data_offer->zwlr_data_control_offer_v1);
+    if (process_wayland.zwlr_data_control_manager_v1)
+        zwlr_data_control_offer_v1_destroy(data_offer->zwlr_data_control_offer_v1);
+    else
+        wl_data_offer_destroy(data_offer->wl_data_offer);
     wl_array_for_each(p, &data_offer->types)
         free(*p);
     wl_array_release(&data_offer->types);
@@ -410,8 +437,15 @@ static int wayland_data_offer_get_import_fd(struct wayland_data_offer *data_offe
         fcntl(data_pipe[1], F_SETFD, FD_CLOEXEC);
     }
 
-    zwlr_data_control_offer_v1_receive(data_offer->zwlr_data_control_offer_v1,
-                                       mime_type, data_pipe[1]);
+    if (process_wayland.zwlr_data_control_manager_v1)
+    {
+        zwlr_data_control_offer_v1_receive(data_offer->zwlr_data_control_offer_v1,
+                                           mime_type, data_pipe[1]);
+    }
+    else
+    {
+        wl_data_offer_receive(data_offer->wl_data_offer, mime_type, data_pipe[1]);
+    }
     close(data_pipe[1]);
 
     /* Flush to ensure our receive request reaches the server. */
@@ -431,21 +465,31 @@ static void *import_format(int fd, struct data_device_format *format, size_t *re
     return ret;
 }
 
-/**********************************************************************
- *          zwlr_data_control_device_v1 handling
- */
-
 static void wayland_data_device_destroy_clipboard_data_offer(struct wayland_data_device *data_device)
 {
-    if (data_device->clipboard_zwlr_data_control_offer_v1)
+    struct wayland_data_offer *data_offer = NULL;
+
+    if (process_wayland.zwlr_data_control_manager_v1 &&
+        data_device->clipboard_zwlr_data_control_offer_v1)
     {
-        struct wayland_data_offer *data_offer =
-            zwlr_data_control_offer_v1_get_user_data(data_device->clipboard_zwlr_data_control_offer_v1);
-        if (data_offer) wayland_data_offer_destroy(data_offer);
+        data_offer = zwlr_data_control_offer_v1_get_user_data(
+            data_device->clipboard_zwlr_data_control_offer_v1);
         data_device->clipboard_zwlr_data_control_offer_v1 = NULL;
     }
+    else if (!process_wayland.zwlr_data_control_manager_v1 &&
+             data_device->clipboard_wl_data_offer)
+    {
+        data_offer = wl_data_offer_get_user_data(data_device->clipboard_wl_data_offer);
+        data_device->clipboard_wl_data_offer = NULL;
+    }
+
+    if (data_offer) wayland_data_offer_destroy(data_offer);
 }
 
+/**********************************************************************
+ *          zwlr_data_control_device_v1 handling
+ */
+
 static void data_control_device_data_offer(
     void *data,
     struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1,
@@ -454,19 +498,12 @@ static void data_control_device_data_offer(
     wayland_data_offer_create(zwlr_data_control_offer_v1);
 }
 
-static void clipboard_update(void);
-
-static void data_control_device_selection(
-    void *data,
-    struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1,
-    struct zwlr_data_control_offer_v1 *zwlr_data_control_offer_v1)
+static void handle_selection(struct wayland_data_device *data_device,
+                             struct wayland_data_offer *data_offer)
 {
-    struct wayland_data_device *data_device = data;
-    struct wayland_data_offer *data_offer = NULL;
     char **p;
 
-    if (!zwlr_data_control_offer_v1 ||
-        !(data_offer = zwlr_data_control_offer_v1_get_user_data(zwlr_data_control_offer_v1)))
+    if (!data_offer)
     {
         TRACE("empty offer, clearing clipboard\n");
         if (NtUserOpenClipboard(clipboard_hwnd, 0))
@@ -521,8 +558,26 @@ static void data_control_device_selection(
 done:
     pthread_mutex_lock(&data_device->mutex);
     wayland_data_device_destroy_clipboard_data_offer(data_device);
-    if (data_offer) data_device->clipboard_zwlr_data_control_offer_v1 = zwlr_data_control_offer_v1;
+    if (data_offer)
+    {
+        if (process_wayland.zwlr_data_control_manager_v1)
+            data_device->clipboard_zwlr_data_control_offer_v1 = data_offer->zwlr_data_control_offer_v1;
+        else
+            data_device->clipboard_wl_data_offer = data_offer->wl_data_offer;
+    }
     pthread_mutex_unlock(&data_device->mutex);
+
+}
+
+static void data_control_device_selection(
+    void *data,
+    struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1,
+    struct zwlr_data_control_offer_v1 *zwlr_data_control_offer_v1)
+{
+    handle_selection(data,
+                     zwlr_data_control_offer_v1 ?
+                         zwlr_data_control_offer_v1_get_user_data(zwlr_data_control_offer_v1) :
+                         NULL);
 }
 
 static void data_control_device_finished(
@@ -595,6 +650,52 @@ static const struct wl_data_source_listener data_source_listener =
     data_source_action,
 };
 
+/**********************************************************************
+ *          wl_data_device handling
+ */
+
+static void data_device_data_offer(void *data, struct wl_data_device *wl_data_device,
+                                   struct wl_data_offer *wl_data_offer)
+{
+    wayland_data_offer_create(wl_data_offer);
+}
+
+static void data_device_enter(void *data, struct wl_data_device *wl_data_device,
+                              uint32_t serial, struct wl_surface *wl_surface,
+                              wl_fixed_t x_w, wl_fixed_t y_w,
+                              struct wl_data_offer *wl_data_offer)
+{
+}
+
+static void data_device_leave(void *data, struct wl_data_device *wl_data_device)
+{
+}
+
+static void data_device_motion(void *data, struct wl_data_device *wl_data_device,
+                               uint32_t time, wl_fixed_t x_w, wl_fixed_t y_w)
+{
+}
+
+static void data_device_drop(void *data, struct wl_data_device *wl_data_device)
+{
+}
+
+static void data_device_selection(void *data, struct wl_data_device *wl_data_device,
+                                  struct wl_data_offer *wl_data_offer)
+{
+    handle_selection(data, wl_data_offer ? wl_data_offer_get_user_data(wl_data_offer) : NULL);
+}
+
+static const struct wl_data_device_listener data_device_listener =
+{
+    data_device_data_offer,
+    data_device_enter,
+    data_device_leave,
+    data_device_motion,
+    data_device_drop,
+    data_device_selection,
+};
+
 void wayland_data_device_init(void)
 {
     struct wayland_data_device *data_device = &process_wayland.data_device;
@@ -626,6 +727,11 @@ void wayland_data_device_init(void)
             wl_data_device_manager_get_data_device(
                 process_wayland.wl_data_device_manager,
                 process_wayland.seat.wl_seat);
+        if (data_device->wl_data_device)
+        {
+            wl_data_device_add_listener(data_device->wl_data_device,
+                                        &data_device_listener, data_device);
+        }
     }
     pthread_mutex_unlock(&data_device->mutex);
 
@@ -740,15 +846,26 @@ static void clipboard_update(void)
 static void render_format(UINT clipboard_format)
 {
     struct wayland_data_device *data_device = &process_wayland.data_device;
-    struct wayland_data_offer *data_offer;
+    struct wayland_data_offer *data_offer = NULL;
     struct data_device_format *format;
     int import_fd = -1;
 
     TRACE("clipboard_format=%u\n", clipboard_format);
 
     pthread_mutex_lock(&data_device->mutex);
-    if (data_device->clipboard_zwlr_data_control_offer_v1 &&
-        (data_offer = zwlr_data_control_offer_v1_get_user_data(data_device->clipboard_zwlr_data_control_offer_v1)) &&
+    if (process_wayland.zwlr_data_control_manager_v1 &&
+        data_device->clipboard_zwlr_data_control_offer_v1)
+    {
+        data_offer = zwlr_data_control_offer_v1_get_user_data(
+            data_device->clipboard_zwlr_data_control_offer_v1);
+    }
+    else if (!process_wayland.zwlr_data_control_manager_v1 &&
+             data_device->clipboard_wl_data_offer)
+    {
+        data_offer = wl_data_offer_get_user_data(data_device->clipboard_wl_data_offer);
+    }
+
+    if (data_offer &&
         (format = data_device_format_for_clipboard_format(clipboard_format,
                                                           &data_offer->types)))
     {
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 1649e0f84f3..065d4d31873 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -145,6 +145,7 @@ struct wayland_data_device
         {
             struct wl_data_device *wl_data_device;
             struct wl_data_source *wl_data_source;
+            struct wl_data_offer *clipboard_wl_data_offer;
         };
     };
     pthread_mutex_t mutex;
-- 
2.49.0

From 36165d6389474ea2a7b2a3b2a65ceb88d6415990 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 17 Mar 2025 13:51:39 +0200
Subject: [PATCH 22/78] winewayland: Warn about missing clipboard
 functionality.

---
 dlls/winewayland.drv/wayland.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 2a51222fd5f..7caf33c872e 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -311,6 +311,14 @@ BOOL wayland_process_init(void)
     if (!process_wayland.zwp_text_input_manager_v3)
         ERR("Wayland compositor doesn't support optional zwp_text_input_manager_v3 (host input methods won't work)\n");
 
+    if (!process_wayland.zwlr_data_control_manager_v1)
+    {
+        if (!process_wayland.wl_data_device_manager)
+            ERR("Wayland compositor doesn't support optional wl_data_device_manager (clipboard won't work)\n");
+        else
+            ERR("Wayland compositor doesn't support optional zwlr_data_control_manager_v1 (clipboard functionality will be limited)\n");
+    }
+
     process_wayland.initialized = TRUE;
 
     return TRUE;
-- 
2.49.0

From a248631087d133d596ff7b2407a04d1ec5140e0a Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty <etaash.mathamsetty@gmail.com>
Date: Sun, 1 Dec 2024 13:36:40 -0500
Subject: [PATCH 23/78] winewayland.drv: Implement support for
 xdg-toplevel-icon.

---
 dlls/winewayland.drv/Makefile.in              |   3 +-
 dlls/winewayland.drv/wayland.c                |   8 +
 dlls/winewayland.drv/wayland_pointer.c        |  94 +-------
 dlls/winewayland.drv/wayland_surface.c        | 167 ++++++++++++++
 dlls/winewayland.drv/waylanddrv.h             |  33 ++-
 dlls/winewayland.drv/waylanddrv_main.c        |   1 +
 dlls/winewayland.drv/window.c                 |  69 +++++-
 dlls/winewayland.drv/xdg-toplevel-icon-v1.xml | 205 ++++++++++++++++++
 8 files changed, 473 insertions(+), 107 deletions(-)
 create mode 100644 dlls/winewayland.drv/xdg-toplevel-icon-v1.xml

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 4141e36c9a8..e7b1bfb90eb 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -26,4 +26,5 @@ SOURCES = \
 	window_surface.c \
 	wlr-data-control-unstable-v1.xml \
 	xdg-output-unstable-v1.xml \
-	xdg-shell.xml
+	xdg-shell.xml \
+	xdg-toplevel-icon-v1.xml
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 7caf33c872e..ba09d32ed89 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -189,6 +189,11 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         process_wayland.wl_data_device_manager =
             wl_registry_bind(registry, id, &wl_data_device_manager_interface, 2);
     }
+    else if (strcmp(interface, "xdg_toplevel_icon_manager_v1") == 0)
+    {
+        process_wayland.xdg_toplevel_icon_manager_v1 =
+            wl_registry_bind(registry, id, &xdg_toplevel_icon_manager_v1_interface, 1);
+    }
 }
 
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
@@ -319,6 +324,9 @@ BOOL wayland_process_init(void)
             ERR("Wayland compositor doesn't support optional zwlr_data_control_manager_v1 (clipboard functionality will be limited)\n");
     }
 
+    if (!process_wayland.xdg_toplevel_icon_manager_v1)
+        ERR("Wayland compositor doesn't support xdg_toplevel_icon_manager_v1 (window icons will not be supported)\n");
+
     process_wayland.initialized = TRUE;
 
     return TRUE;
diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 457c3675cf1..6c852292c1d 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -382,98 +382,6 @@ done:
     return shm_buffer;
 }
 
-/***********************************************************************
- *           create_color_cursor_buffer
- *
- * Create a wayland_shm_buffer for a color cursor bitmap.
- *
- * Adapted from wineandroid.drv code.
- */
-static struct wayland_shm_buffer *create_color_cursor_buffer(HDC hdc, HBITMAP color,
-                                                             HBITMAP mask)
-{
-    struct wayland_shm_buffer *shm_buffer = NULL;
-    char buffer[FIELD_OFFSET(BITMAPINFO, bmiColors[256])];
-    BITMAPINFO *info = (BITMAPINFO *)buffer;
-    BITMAP bm;
-    unsigned int *ptr, *bits = NULL;
-    unsigned char *mask_bits = NULL;
-    int i, j;
-    BOOL has_alpha = FALSE;
-
-    if (!NtGdiExtGetObjectW(color, sizeof(bm), &bm)) goto failed;
-
-    shm_buffer = wayland_shm_buffer_create(bm.bmWidth, bm.bmHeight,
-                                           WL_SHM_FORMAT_ARGB8888);
-    if (!shm_buffer) goto failed;
-    bits = shm_buffer->map_data;
-
-    info->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
-    info->bmiHeader.biWidth = bm.bmWidth;
-    info->bmiHeader.biHeight = -bm.bmHeight;
-    info->bmiHeader.biPlanes = 1;
-    info->bmiHeader.biBitCount = 32;
-    info->bmiHeader.biCompression = BI_RGB;
-    info->bmiHeader.biSizeImage = bm.bmWidth * bm.bmHeight * 4;
-    info->bmiHeader.biXPelsPerMeter = 0;
-    info->bmiHeader.biYPelsPerMeter = 0;
-    info->bmiHeader.biClrUsed = 0;
-    info->bmiHeader.biClrImportant = 0;
-
-    if (!NtGdiGetDIBitsInternal(hdc, color, 0, bm.bmHeight, bits, info,
-                                DIB_RGB_COLORS, 0, 0))
-        goto failed;
-
-    for (i = 0; i < bm.bmWidth * bm.bmHeight; i++)
-        if ((has_alpha = (bits[i] & 0xff000000) != 0)) break;
-
-    if (!has_alpha)
-    {
-        unsigned int width_bytes = (bm.bmWidth + 31) / 32 * 4;
-        /* generate alpha channel from the mask */
-        info->bmiHeader.biBitCount = 1;
-        info->bmiHeader.biSizeImage = width_bytes * bm.bmHeight;
-        if (!(mask_bits = malloc(info->bmiHeader.biSizeImage))) goto failed;
-        if (!NtGdiGetDIBitsInternal(hdc, mask, 0, bm.bmHeight, mask_bits,
-                                    info, DIB_RGB_COLORS, 0, 0))
-            goto failed;
-        ptr = bits;
-        for (i = 0; i < bm.bmHeight; i++)
-        {
-            for (j = 0; j < bm.bmWidth; j++, ptr++)
-            {
-                if (!((mask_bits[i * width_bytes + j / 8] << (j % 8)) & 0x80))
-                    *ptr |= 0xff000000;
-            }
-        }
-        free(mask_bits);
-    }
-
-    /* Wayland requires pre-multiplied alpha values */
-    for (ptr = bits, i = 0; i < bm.bmWidth * bm.bmHeight; ptr++, i++)
-    {
-        unsigned char alpha = *ptr >> 24;
-        if (alpha == 0)
-        {
-            *ptr = 0;
-        }
-        else if (alpha != 255)
-        {
-            *ptr = (alpha << 24) |
-                   (((BYTE)(*ptr >> 16) * alpha / 255) << 16) |
-                   (((BYTE)(*ptr >> 8) * alpha / 255) << 8) |
-                   (((BYTE)*ptr * alpha / 255));
-        }
-    }
-
-    return shm_buffer;
-
-failed:
-    if (shm_buffer) wayland_shm_buffer_unref(shm_buffer);
-    free(mask_bits);
-    return NULL;
-}
-
 /***********************************************************************
  *           get_icon_info
  *
@@ -535,7 +443,7 @@ static void wayland_pointer_update_cursor_buffer(HCURSOR hcursor, double scale)
     {
         HDC hdc = NtGdiCreateCompatibleDC(0);
         cursor->shm_buffer =
-            create_color_cursor_buffer(hdc, info.hbmColor, info.hbmMask);
+            wayland_shm_buffer_from_color_bitmaps(hdc, info.hbmColor, info.hbmMask);
         NtGdiDeleteObjectApp(hdc);
     }
     else
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 2178f5431cb..7b5c5eda335 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -324,6 +324,21 @@ void wayland_surface_clear_role(struct wayland_surface *surface)
         break;
 
     case WAYLAND_SURFACE_ROLE_TOPLEVEL:
+        if (surface->xdg_toplevel_icon)
+        {
+            xdg_toplevel_icon_manager_v1_set_icon(
+                process_wayland.xdg_toplevel_icon_manager_v1,
+                surface->xdg_toplevel, NULL);
+            xdg_toplevel_icon_v1_destroy(surface->xdg_toplevel_icon);
+            if (surface->big_icon_buffer)
+                wayland_shm_buffer_unref(surface->big_icon_buffer);
+            if (surface->small_icon_buffer)
+                wayland_shm_buffer_unref(surface->small_icon_buffer);
+            surface->big_icon_buffer = NULL;
+            surface->small_icon_buffer = NULL;
+            surface->xdg_toplevel_icon = NULL;
+        }
+
         if (surface->xdg_toplevel)
         {
             xdg_toplevel_destroy(surface->xdg_toplevel);
@@ -846,6 +861,98 @@ err:
     return NULL;
 }
 
+/***********************************************************************
+ *           wayland_shm_buffer_from_color_bitmaps
+ *
+ * Create a wayland_shm_buffer for a color bitmap.
+ *
+ * Adapted from wineandroid.drv code.
+ */
+struct wayland_shm_buffer *wayland_shm_buffer_from_color_bitmaps(HDC hdc, HBITMAP color,
+                                                                 HBITMAP mask)
+{
+    struct wayland_shm_buffer *shm_buffer = NULL;
+    char buffer[FIELD_OFFSET(BITMAPINFO, bmiColors[256])];
+    BITMAPINFO *info = (BITMAPINFO *)buffer;
+    BITMAP bm;
+    unsigned int *ptr, *bits = NULL;
+    unsigned char *mask_bits = NULL;
+    int i, j;
+    BOOL has_alpha = FALSE;
+
+    if (!NtGdiExtGetObjectW(color, sizeof(bm), &bm)) goto failed;
+
+    shm_buffer = wayland_shm_buffer_create(bm.bmWidth, bm.bmHeight,
+                                           WL_SHM_FORMAT_ARGB8888);
+    if (!shm_buffer) goto failed;
+    bits = shm_buffer->map_data;
+
+    info->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
+    info->bmiHeader.biWidth = bm.bmWidth;
+    info->bmiHeader.biHeight = -bm.bmHeight;
+    info->bmiHeader.biPlanes = 1;
+    info->bmiHeader.biBitCount = 32;
+    info->bmiHeader.biCompression = BI_RGB;
+    info->bmiHeader.biSizeImage = bm.bmWidth * bm.bmHeight * 4;
+    info->bmiHeader.biXPelsPerMeter = 0;
+    info->bmiHeader.biYPelsPerMeter = 0;
+    info->bmiHeader.biClrUsed = 0;
+    info->bmiHeader.biClrImportant = 0;
+
+    if (!NtGdiGetDIBitsInternal(hdc, color, 0, bm.bmHeight, bits, info,
+                                DIB_RGB_COLORS, 0, 0))
+        goto failed;
+
+    for (i = 0; i < bm.bmWidth * bm.bmHeight; i++)
+        if ((has_alpha = (bits[i] & 0xff000000) != 0)) break;
+
+    if (!has_alpha)
+    {
+        unsigned int width_bytes = (bm.bmWidth + 31) / 32 * 4;
+        /* generate alpha channel from the mask */
+        info->bmiHeader.biBitCount = 1;
+        info->bmiHeader.biSizeImage = width_bytes * bm.bmHeight;
+        if (!(mask_bits = malloc(info->bmiHeader.biSizeImage))) goto failed;
+        if (!NtGdiGetDIBitsInternal(hdc, mask, 0, bm.bmHeight, mask_bits,
+                                    info, DIB_RGB_COLORS, 0, 0))
+            goto failed;
+        ptr = bits;
+        for (i = 0; i < bm.bmHeight; i++)
+        {
+            for (j = 0; j < bm.bmWidth; j++, ptr++)
+            {
+                if (!((mask_bits[i * width_bytes + j / 8] << (j % 8)) & 0x80))
+                    *ptr |= 0xff000000;
+            }
+        }
+        free(mask_bits);
+    }
+
+    /* Wayland requires pre-multiplied alpha values */
+    for (ptr = bits, i = 0; i < bm.bmWidth * bm.bmHeight; ptr++, i++)
+    {
+        unsigned char alpha = *ptr >> 24;
+        if (alpha == 0)
+        {
+            *ptr = 0;
+        }
+        else if (alpha != 255)
+        {
+            *ptr = (alpha << 24) |
+                   (((BYTE)(*ptr >> 16) * alpha / 255) << 16) |
+                   (((BYTE)(*ptr >> 8) * alpha / 255) << 8) |
+                   (((BYTE)*ptr * alpha / 255));
+        }
+    }
+
+    return shm_buffer;
+
+failed:
+    if (shm_buffer) wayland_shm_buffer_unref(shm_buffer);
+    free(mask_bits);
+    return NULL;
+}
+
 /**********************************************************************
  *          wayland_surface_coords_from_window
  *
@@ -1076,3 +1183,63 @@ void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR text)
 
     free(utf8);
 }
+
+/**********************************************************************
+ *          wayland_surface_set_icon
+ */
+void wayland_surface_set_icon(struct wayland_surface *surface, UINT type, ICONINFO *ii)
+{
+    HDC hDC;
+    struct wayland_shm_buffer *icon_buf;
+
+    assert(ii);
+    assert(surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL && surface->xdg_toplevel);
+
+    hDC = NtGdiCreateCompatibleDC(0);
+    icon_buf = wayland_shm_buffer_from_color_bitmaps(hDC, ii->hbmColor, ii->hbmMask);
+    NtGdiDeleteObjectApp(hDC);
+
+    if (surface->xdg_toplevel_icon)
+    {
+        xdg_toplevel_icon_manager_v1_set_icon(process_wayland.xdg_toplevel_icon_manager_v1,
+                                              surface->xdg_toplevel, NULL);
+        xdg_toplevel_icon_v1_destroy(surface->xdg_toplevel_icon);
+        if (surface->big_icon_buffer && type == ICON_BIG)
+        {
+            wayland_shm_buffer_unref(surface->big_icon_buffer);
+            surface->big_icon_buffer = NULL;
+        }
+        else if (surface->small_icon_buffer && type != ICON_BIG)
+        {
+            wayland_shm_buffer_unref(surface->small_icon_buffer);
+            surface->small_icon_buffer = NULL;
+        }
+        surface->xdg_toplevel_icon = NULL;
+    }
+
+    if (icon_buf)
+    {
+        surface->xdg_toplevel_icon =
+            xdg_toplevel_icon_manager_v1_create_icon(process_wayland.xdg_toplevel_icon_manager_v1);
+
+        if (type == ICON_BIG) surface->big_icon_buffer = icon_buf;
+        else surface->small_icon_buffer = icon_buf;
+
+        /* FIXME: what to do with scale ? */
+        if (surface->big_icon_buffer)
+        {
+            xdg_toplevel_icon_v1_add_buffer(surface->xdg_toplevel_icon,
+                                            surface->big_icon_buffer->wl_buffer, 1);
+        }
+        if (surface->small_icon_buffer)
+        {
+            xdg_toplevel_icon_v1_add_buffer(surface->xdg_toplevel_icon,
+                                            surface->small_icon_buffer->wl_buffer, 1);
+        }
+
+        xdg_toplevel_icon_v1_set_name(surface->xdg_toplevel_icon, "");
+
+        xdg_toplevel_icon_manager_v1_set_icon(process_wayland.xdg_toplevel_icon_manager_v1,
+                                              surface->xdg_toplevel, surface->xdg_toplevel_icon);
+    }
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 065d4d31873..1ccadcb7647 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -36,6 +36,7 @@
 #include "xdg-output-unstable-v1-client-protocol.h"
 #include "xdg-shell-client-protocol.h"
 #include "wlr-data-control-unstable-v1-client-protocol.h"
+#include "xdg-toplevel-icon-v1-client-protocol.h"
 
 #include "windef.h"
 #include "winbase.h"
@@ -168,6 +169,7 @@ struct wayland
     struct zwp_text_input_manager_v3 *zwp_text_input_manager_v3;
     struct zwlr_data_control_manager_v1 *zwlr_data_control_manager_v1;
     struct wl_data_device_manager *wl_data_device_manager;
+    struct xdg_toplevel_icon_manager_v1 *xdg_toplevel_icon_manager_v1;
     struct wayland_seat seat;
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
@@ -237,6 +239,18 @@ struct wayland_client_surface
     struct wp_viewport *wp_viewport;
 };
 
+struct wayland_shm_buffer
+{
+    struct wl_list link;
+    struct wl_buffer *wl_buffer;
+    int width, height;
+    void *map_data;
+    size_t map_size;
+    BOOL busy;
+    LONG ref;
+    HRGN damage_region;
+};
+
 struct wayland_surface
 {
     HWND hwnd;
@@ -251,6 +265,9 @@ struct wayland_surface
         {
             struct xdg_surface *xdg_surface;
             struct xdg_toplevel *xdg_toplevel;
+            struct xdg_toplevel_icon_v1 *xdg_toplevel_icon;
+            struct wayland_shm_buffer *small_icon_buffer;
+            struct wayland_shm_buffer *big_icon_buffer;
         };
         struct
         {
@@ -266,18 +283,6 @@ struct wayland_surface
     HCURSOR hcursor;
 };
 
-struct wayland_shm_buffer
-{
-    struct wl_list link;
-    struct wl_buffer *wl_buffer;
-    int width, height;
-    void *map_data;
-    size_t map_size;
-    BOOL busy;
-    LONG ref;
-    HRGN damage_region;
-};
-
 /**********************************************************************
  *          Wayland initialization
  */
@@ -321,6 +326,7 @@ void wayland_client_surface_attach(struct wayland_client_surface *client, HWND t
 void wayland_client_surface_detach(struct wayland_client_surface *client);
 void wayland_surface_ensure_contents(struct wayland_surface *surface);
 void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR title);
+void wayland_surface_set_icon(struct wayland_surface *surface, UINT type, ICONINFO *ii);
 
 /**********************************************************************
  *          Wayland SHM buffer
@@ -328,6 +334,8 @@ void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR title);
 
 struct wayland_shm_buffer *wayland_shm_buffer_create(int width, int height,
                                                      enum wl_shm_format format);
+struct wayland_shm_buffer *wayland_shm_buffer_from_color_bitmaps(HDC hdc, HBITMAP color,
+                                                                 HBITMAP mask);
 void wayland_shm_buffer_ref(struct wayland_shm_buffer *shm_buffer);
 void wayland_shm_buffer_unref(struct wayland_shm_buffer *shm_buffer);
 
@@ -430,6 +438,7 @@ void WAYLAND_DestroyWindow(HWND hwnd);
 BOOL WAYLAND_SetIMECompositionRect(HWND hwnd, RECT rect);
 void WAYLAND_SetCursor(HWND hwnd, HCURSOR hcursor);
 BOOL WAYLAND_SetCursorPos(INT x, INT y);
+void WAYLAND_SetWindowIcon(HWND hwnd, UINT type, HICON icon);
 void WAYLAND_SetWindowText(HWND hwnd, LPCWSTR text);
 LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam, const POINT *pos);
 UINT WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager, void *param);
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index dba519b1df1..5486cc934ef 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -44,6 +44,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pReleaseKbdTables = WAYLAND_ReleaseKbdTables,
     .pSetCursor = WAYLAND_SetCursor,
     .pSetCursorPos = WAYLAND_SetCursorPos,
+    .pSetWindowIcon = WAYLAND_SetWindowIcon,
     .pSetWindowText = WAYLAND_SetWindowText,
     .pSysCommand = WAYLAND_SysCommand,
     .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index e80bebdc042..184d09c2ed4 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -422,6 +422,28 @@ BOOL WAYLAND_WindowPosChanging(HWND hwnd, UINT swp_flags, BOOL shaped, const str
     return TRUE;
 }
 
+static HICON get_icon_info(HICON icon, ICONINFO *ii)
+{
+    return icon && NtUserGetIconInfo(icon, ii, NULL, NULL, NULL, 0) ? icon : NULL;
+}
+
+static HICON get_window_icon(HWND hwnd, UINT type, HICON icon, ICONINFO *ret)
+{
+    icon = get_icon_info(icon, ret);
+    if (!icon)
+    {
+        icon = get_icon_info((HICON)send_message(hwnd, WM_GETICON, type, 0), ret);
+        if (!icon)
+            icon = get_icon_info((HICON)NtUserGetClassLongPtrW(hwnd, GCLP_HICON), ret);
+        if (!icon && type == ICON_BIG)
+        {
+            icon = LoadImageW(0, (const WCHAR *)IDI_WINLOGO, IMAGE_ICON, 0, 0,
+                              LR_SHARED | LR_DEFAULTSIZE);
+            icon = get_icon_info(icon, ret);
+        }
+    }
+    return icon;
+}
 
 /***********************************************************************
  *           WAYLAND_WindowPosChanged
@@ -433,7 +455,7 @@ void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, HWND owner_hint, UIN
     struct wayland_surface *toplevel_surface;
     struct wayland_client_surface *client;
     struct wayland_win_data *data, *toplevel_data;
-    BOOL managed;
+    BOOL managed, needs_icon;
 
     TRACE("hwnd %p new_rects %s after %p flags %08x\n", hwnd, debugstr_window_rects(new_rects), insert_after, swp_flags);
 
@@ -471,7 +493,28 @@ void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, HWND owner_hint, UIN
         wayland_win_data_update_wayland_state(data);
     }
 
+    needs_icon = data->wayland_surface && !data->wayland_surface->big_icon_buffer &&
+                 data->wayland_surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
+                 data->wayland_surface->xdg_toplevel &&
+                 process_wayland.xdg_toplevel_icon_manager_v1;
+
     wayland_win_data_release(data);
+
+    if (needs_icon)
+    {
+        HICON big, small;
+        ICONINFO ii, ii_small;
+        big = get_window_icon(hwnd, ICON_BIG, 0, &ii);
+        small = get_window_icon(hwnd, ICON_SMALL, 0, &ii_small);
+
+        if((data = wayland_win_data_get(hwnd)))
+        {
+            if (big) wayland_surface_set_icon(data->wayland_surface, ICON_BIG, &ii);
+            if (small) wayland_surface_set_icon(data->wayland_surface, ICON_SMALL, &ii_small);
+
+            wayland_win_data_release(data);
+        }
+    }
 }
 
 static void wayland_configure_window(HWND hwnd)
@@ -642,6 +685,30 @@ static enum xdg_toplevel_resize_edge hittest_to_resize_edge(WPARAM hittest)
     }
 }
 
+/*****************************************************************
+ *		WAYLAND_SetWindowIcon
+ */
+void WAYLAND_SetWindowIcon(HWND hwnd, UINT type, HICON icon)
+{
+    struct wayland_win_data *data;
+    ICONINFO ii;
+
+    TRACE("hwnd=%p type=%u icon=%p\n", hwnd, type, icon);
+
+    if (process_wayland.xdg_toplevel_icon_manager_v1)
+    {
+        icon = get_window_icon(hwnd, type, icon, &ii);
+        if (icon && (data = wayland_win_data_get(hwnd)))
+        {
+            if (data->wayland_surface &&
+                data->wayland_surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
+                data->wayland_surface->xdg_toplevel)
+                wayland_surface_set_icon(data->wayland_surface, type, &ii);
+            wayland_win_data_release(data);
+        }
+    }
+}
+
 /*****************************************************************
  *		WAYLAND_SetWindowText
  */
diff --git a/dlls/winewayland.drv/xdg-toplevel-icon-v1.xml b/dlls/winewayland.drv/xdg-toplevel-icon-v1.xml
new file mode 100644
index 00000000000..fc409fef7c6
--- /dev/null
+++ b/dlls/winewayland.drv/xdg-toplevel-icon-v1.xml
@@ -0,0 +1,205 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="xdg_toplevel_icon_v1">
+
+  <copyright>
+    Copyright © 2023-2024 Matthias Klumpp
+    Copyright ©      2024 David Edmundson
+
+    Permission is hereby granted, free of charge, to any person obtaining a
+    copy of this software and associated documentation files (the "Software"),
+    to deal in the Software without restriction, including without limitation
+    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+    and/or sell copies of the Software, and to permit persons to whom the
+    Software is furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice (including the next
+    paragraph) shall be included in all copies or substantial portions of the
+    Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+    DEALINGS IN THE SOFTWARE.
+  </copyright>
+
+  <description summary="protocol to assign icons to toplevels">
+    This protocol allows clients to set icons for their toplevel surfaces
+    either via the XDG icon stock (using an icon name), or from pixel data.
+
+    A toplevel icon represents the individual toplevel (unlike the application
+    or launcher icon, which represents the application as a whole), and may be
+    shown in window switchers, window overviews and taskbars that list
+    individual windows.
+
+    This document adheres to RFC 2119 when using words like "must",
+    "should", "may", etc.
+
+    Warning! The protocol described in this file is currently in the testing
+    phase. Backward compatible changes may be added together with the
+    corresponding interface version bump. Backward incompatible changes can
+    only be done by creating a new major version of the extension.
+  </description>
+
+  <interface name="xdg_toplevel_icon_manager_v1" version="1">
+    <description summary="interface to manage toplevel icons">
+      This interface allows clients to create toplevel window icons and set
+      them on toplevel windows to be displayed to the user.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the toplevel icon manager">
+        Destroy the toplevel icon manager.
+        This does not destroy objects created with the manager.
+      </description>
+    </request>
+
+    <request name="create_icon">
+      <description summary="create a new icon instance">
+        Creates a new icon object. This icon can then be attached to a
+        xdg_toplevel via the 'set_icon' request.
+      </description>
+      <arg name="id" type="new_id" interface="xdg_toplevel_icon_v1"/>
+    </request>
+
+    <request name="set_icon">
+      <description summary="set an icon on a toplevel window">
+        This request assigns the icon 'icon' to 'toplevel', or clears the
+        toplevel icon if 'icon' was null.
+        This state is double-buffered and is applied on the next
+        wl_surface.commit of the toplevel.
+
+        After making this call, the xdg_toplevel_icon_v1 provided as 'icon'
+        can be destroyed by the client without 'toplevel' losing its icon.
+        The xdg_toplevel_icon_v1 is immutable from this point, and any
+        future attempts to change it must raise the
+        'xdg_toplevel_icon_v1.immutable' protocol error.
+
+        The compositor must set the toplevel icon from either the pixel data
+        the icon provides, or by loading a stock icon using the icon name.
+        See the description of 'xdg_toplevel_icon_v1' for details.
+
+        If 'icon' is set to null, the icon of the respective toplevel is reset
+        to its default icon (usually the icon of the application, derived from
+        its desktop-entry file, or a placeholder icon).
+        If this request is passed an icon with no pixel buffers or icon name
+        assigned, the icon must be reset just like if 'icon' was null.
+      </description>
+      <arg name="toplevel" type="object" interface="xdg_toplevel" summary="the toplevel to act on"/>
+      <arg name="icon" type="object" interface="xdg_toplevel_icon_v1" allow-null="true"/>
+    </request>
+
+    <event name="icon_size">
+      <description summary="describes a supported &amp; preferred icon size">
+        This event indicates an icon size the compositor prefers to be
+        available if the client has scalable icons and can render to any size.
+
+        When the 'xdg_toplevel_icon_manager_v1' object is created, the
+        compositor may send one or more 'icon_size' events to describe the list
+        of preferred icon sizes. If the compositor has no size preference, it
+        may not send any 'icon_size' event, and it is up to the client to
+        decide a suitable icon size.
+
+        A sequence of 'icon_size' events must be finished with a 'done' event.
+        If the compositor has no size preferences, it must still send the
+        'done' event, without any preceding 'icon_size' events.
+      </description>
+      <arg name="size" type="int"
+	   summary="the edge size of the square icon in surface-local coordinates, e.g. 64"/>
+    </event>
+
+    <event name="done">
+      <description summary="all information has been sent">
+        This event is sent after all 'icon_size' events have been sent.
+      </description>
+    </event>
+  </interface>
+
+  <interface name="xdg_toplevel_icon_v1" version="1">
+    <description summary="a toplevel window icon">
+      This interface defines a toplevel icon.
+      An icon can have a name, and multiple buffers.
+      In order to be applied, the icon must have either a name, or at least
+      one buffer assigned. Applying an empty icon (with no buffer or name) to
+      a toplevel should reset its icon to the default icon.
+
+      It is up to compositor policy whether to prefer using a buffer or loading
+      an icon via its name. See 'set_name' and 'add_buffer' for details.
+    </description>
+
+    <enum name="error">
+      <entry name="invalid_buffer"
+             summary="the provided buffer does not satisfy requirements"
+	     value="1"/>
+      <entry name="immutable"
+             summary="the icon has already been assigned to a toplevel and must not be changed"
+	     value="2"/>
+      <entry name="no_buffer"
+             summary="the provided buffer has been destroyed before the toplevel icon"
+             value="3"/>
+    </enum>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the icon object">
+        Destroys the 'xdg_toplevel_icon_v1' object.
+        The icon must still remain set on every toplevel it was assigned to,
+        until the toplevel icon is reset explicitly.
+      </description>
+    </request>
+
+    <request name="set_name">
+      <description summary="set an icon name">
+        This request assigns an icon name to this icon.
+        Any previously set name is overridden.
+
+        The compositor must resolve 'icon_name' according to the lookup rules
+        described in the XDG icon theme specification[1] using the
+        environment's current icon theme.
+
+        If the compositor does not support icon names or cannot resolve
+        'icon_name' according to the XDG icon theme specification it must
+        fall back to using pixel buffer data instead.
+
+        If this request is made after the icon has been assigned to a toplevel
+        via 'set_icon', a 'immutable' error must be raised.
+
+        [1]: https://specifications.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html
+      </description>
+      <arg name="icon_name" type="string"/>
+    </request>
+
+    <request name="add_buffer">
+      <description summary="add icon data from a pixel buffer">
+        This request adds pixel data supplied as wl_buffer to the icon.
+
+        The client should add pixel data for all icon sizes and scales that
+        it can provide, or which are explicitly requested by the compositor
+        via 'icon_size' events on xdg_toplevel_icon_manager_v1.
+
+        The wl_buffer supplying pixel data as 'buffer' must be backed by wl_shm
+        and must be a square (width and height being equal).
+        If any of these buffer requirements are not fulfilled, a 'invalid_buffer'
+        error must be raised.
+
+        If this icon instance already has a buffer of the same size and scale
+        from a previous 'add_buffer' request, data from the last request
+        overrides the preexisting pixel data.
+
+        The wl_buffer must be kept alive for as long as the xdg_toplevel_icon
+        it is associated with is not destroyed, otherwise a 'no_buffer' error
+        is raised. The buffer contents must not be modified after it was
+        assigned to the icon. As a result, the region of the wl_shm_pool's
+        backing storage used for the wl_buffer must not be modified after this
+        request is sent. The wl_buffer.release event is unused.
+
+        If this request is made after the icon has been assigned to a toplevel
+        via 'set_icon', a 'immutable' error must be raised.
+      </description>
+      <arg name="buffer" type="object" interface="wl_buffer"/>
+      <arg name="scale" type="int"
+	   summary="the scaling factor of the icon, e.g. 1"/>
+    </request>
+  </interface>
+</protocol>
-- 
2.49.0

From c271b809cff2c9d77c82f0470951a6aca31545ad Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty <etaash.mathamsetty@gmail.com>
Date: Sun, 13 Apr 2025 21:21:17 -0400
Subject: [PATCH 24/78] winewayland: Implement relative motion accumulator.

---
 dlls/winewayland.drv/wayland_pointer.c | 43 ++++++++++++++++++++------
 dlls/winewayland.drv/waylanddrv.h      |  2 ++
 2 files changed, 35 insertions(+), 10 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 6c852292c1d..b2af6c0db4a 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -257,6 +257,19 @@ static const struct wl_pointer_listener pointer_listener =
     pointer_handle_axis_discrete
 };
 
+/**********************************************************************
+ *          wayland_motion_delta_to_window
+ *
+ * Converts the surface-local delta to window (logical) coordinate delta.
+ */
+static void wayland_motion_delta_to_window(struct wayland_surface *surface,
+                                           double surface_x, double surface_y,
+                                           double *window_x, double *window_y)
+{
+    *window_x = surface_x * surface->window.scale;
+    *window_y = surface_y * surface->window.scale;
+}
+
 static void relative_pointer_v1_relative_motion(void *private,
                                                 struct zwp_relative_pointer_v1 *zwp_relative_pointer_v1,
                                                 uint32_t utime_hi, uint32_t utime_lo,
@@ -265,28 +278,37 @@ static void relative_pointer_v1_relative_motion(void *private,
 {
     INPUT input = {0};
     HWND hwnd;
-    POINT screen;
     struct wayland_win_data *data;
+    double screen_x = 0.0, screen_y = 0.0;
+    struct wayland_pointer *pointer = &process_wayland.pointer;
 
     if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
     if (!(data = wayland_win_data_get(hwnd))) return;
 
-    wayland_surface_coords_to_window(data->wayland_surface,
-                                     wl_fixed_to_double(dx),
-                                     wl_fixed_to_double(dy),
-                                     (int *)&screen.x, (int *)&screen.y);
-
+    wayland_motion_delta_to_window(data->wayland_surface,
+                                   wl_fixed_to_double(dx),
+                                   wl_fixed_to_double(dy),
+                                   &screen_x, &screen_y);
     wayland_win_data_release(data);
 
+    pthread_mutex_lock(&pointer->mutex);
+
+    pointer->accum_x += screen_x;
+    pointer->accum_y += screen_y;
 
     input.type = INPUT_MOUSE;
-    input.mi.dx = screen.x;
-    input.mi.dy = screen.y;
+    input.mi.dx = round(pointer->accum_x);
+    input.mi.dy = round(pointer->accum_y);
     input.mi.dwFlags = MOUSEEVENTF_MOVE;
 
-    TRACE("hwnd=%p wayland_dxdy=%.2f,%.2f screen_dxdy=%d,%d\n",
+    pointer->accum_x -= input.mi.dx;
+    pointer->accum_y -= input.mi.dy;
+
+    pthread_mutex_unlock(&pointer->mutex);
+
+    TRACE("hwnd=%p wayland_dxdy=%.2f,%.2f accum_dxdy=%d,%d\n",
           hwnd, wl_fixed_to_double(dx), wl_fixed_to_double(dy),
-          (int)screen.x, (int)screen.y);
+          (int)input.mi.dx, (int)input.mi.dy);
 
     NtUserSendHardwareInput(hwnd, 0, &input, 0);
 }
@@ -778,6 +800,7 @@ static void wayland_pointer_update_constraint(struct wl_surface *wl_surface,
 
     if (needs_relative && !pointer->zwp_relative_pointer_v1)
     {
+        pointer->accum_x = pointer->accum_y = 0;
         pointer->zwp_relative_pointer_v1 =
             zwp_relative_pointer_manager_v1_get_relative_pointer(
                 process_wayland.zwp_relative_pointer_manager_v1,
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 1ccadcb7647..3c42272ccde 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -112,6 +112,8 @@ struct wayland_pointer
     uint32_t enter_serial;
     uint32_t button_serial;
     struct wayland_cursor cursor;
+    double accum_x;
+    double accum_y;
     pthread_mutex_t mutex;
 };
 
-- 
2.49.0

From 37d5af380f8ab9b42fb59c07493e40422cb0d50a Mon Sep 17 00:00:00 2001
From: Attila Fidan <dev@print0.net>
Date: Sun, 20 Apr 2025 11:30:03 +0000
Subject: [PATCH 25/78] winewayland: Require wl_pointer for pointer
 constraints.

If ClipCursor is called while the seat doesn't have a pointer and the
call qualifies for locking the pointer, it would have tried to lock a
null wl_pointer.
---
 dlls/winewayland.drv/wayland_pointer.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index b2af6c0db4a..257735dc909 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -710,9 +710,10 @@ static void wayland_pointer_update_constraint(struct wl_surface *wl_surface,
     }
 
     needs_lock = wl_surface && (((confine_rect || covers_vscreen) &&
-                 !pointer->cursor.wl_surface) || force_lock);
+                 !pointer->cursor.wl_surface) || force_lock) &&
+                 pointer->wl_pointer;
     needs_confine = wl_surface && confine_rect && pointer->cursor.wl_surface &&
-                 !force_lock;
+                 !force_lock && pointer->wl_pointer;
 
     if (!needs_confine && pointer->zwp_confined_pointer_v1)
     {
-- 
2.49.0

From f2eb3c1585cc62cdfc82b915e211a6f18c78f59f Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Mon, 5 May 2025 22:08:25 -0400
Subject: [PATCH 26/78] support older EGL headers

---
 dlls/winewayland.drv/opengl.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index d9a83d49b3e..36989b9c745 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -43,6 +43,12 @@ WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 #include "wine/wgl.h"
 #include "wine/wgl_driver.h"
 
+/* Support building on systems with older EGL headers,
+    which may not include the EGL_EXT_present_opaque extension. */
+#ifndef EGL_PRESENT_OPAQUE_EXT
+#define EGL_PRESENT_OPAQUE_EXT 0x31DF
+#endif
+
 static void *egl_handle;
 static struct opengl_funcs opengl_funcs;
 static EGLDisplay egl_display;
-- 
2.49.0

From 67caff5981c4a8d9951ba1c5306152fb81d2d1d7 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 24 Apr 2025 15:28:18 +0300
Subject: [PATCH 27/78] winewayland: Always check the role to determine whether
 a surface is a toplevel.

Since the role objects in the wayland_surface struct are part of a union, we
first need to check whether the surface has the right role before checking
the role objects themselves. Otherwise we risk using a subsurface as a toplevel
or vice-versa.
---
 dlls/winewayland.drv/wayland_surface.c | 10 +++++++---
 dlls/winewayland.drv/window.c          | 10 +++++++---
 2 files changed, 14 insertions(+), 6 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 7b5c5eda335..b7121d5ed96 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -48,7 +48,9 @@ static void xdg_surface_handle_configure(void *private, struct xdg_surface *xdg_
 
     /* Handle this event only if wayland_surface is still associated with
      * the target xdg_surface. */
-    if ((surface = data->wayland_surface) && surface->xdg_surface == xdg_surface)
+    if ((surface = data->wayland_surface) &&
+        surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
+        surface->xdg_surface == xdg_surface)
     {
         /* If we have a previously requested config, we have already sent a
          * WM_WAYLAND_CONFIGURE which hasn't been handled yet. In that case,
@@ -116,7 +118,9 @@ static void xdg_toplevel_handle_configure(void *private,
 
     if (!(data = wayland_win_data_get(hwnd))) return;
 
-    if ((surface = data->wayland_surface) && surface->xdg_toplevel == xdg_toplevel)
+    if ((surface = data->wayland_surface) &&
+        surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
+        surface->xdg_toplevel == xdg_toplevel)
     {
         surface->pending.width = width;
         surface->pending.height = height;
@@ -1167,7 +1171,7 @@ void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR text)
     DWORD utf8_count;
     char *utf8 = NULL;
 
-    assert(surface->xdg_toplevel);
+    assert(surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL && surface->xdg_toplevel);
 
     TRACE("surface=%p hwnd=%p text='%s'\n",
           surface, surface->hwnd, wine_dbgstr_w(text));
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 184d09c2ed4..03dff29a4cc 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -537,7 +537,7 @@ static void wayland_configure_window(HWND hwnd)
         return;
     }
 
-    if (!surface->xdg_toplevel)
+    if (surface->role != WAYLAND_SURFACE_ROLE_TOPLEVEL || !surface->xdg_toplevel)
     {
         TRACE("missing xdg_toplevel, returning\n");
         wayland_win_data_release(data);
@@ -721,7 +721,9 @@ void WAYLAND_SetWindowText(HWND hwnd, LPCWSTR text)
 
     if ((data = wayland_win_data_get(hwnd)))
     {
-        if ((surface = data->wayland_surface) && surface->xdg_toplevel)
+        if ((surface = data->wayland_surface) &&
+            surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
+            surface->xdg_toplevel)
             wayland_surface_set_title(surface, text);
         wayland_win_data_release(data);
     }
@@ -755,7 +757,9 @@ LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam, const POINT
         {
             pthread_mutex_lock(&process_wayland.seat.mutex);
             wl_seat = process_wayland.seat.wl_seat;
-            if (wl_seat && (surface = data->wayland_surface) && surface->xdg_toplevel && button_serial)
+            if (wl_seat && (surface = data->wayland_surface) &&
+                surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
+                surface->xdg_toplevel && button_serial)
             {
                 if (command == SC_MOVE)
                 {
-- 
2.49.0

From 45fadc703af95e2b7c03d16c3bd25edcba3c0614 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 24 Apr 2025 15:46:33 +0300
Subject: [PATCH 28/78] winewayland: Introduce helper to check whether a
 surface is toplevel.

---
 dlls/winewayland.drv/wayland_surface.c | 11 ++++-------
 dlls/winewayland.drv/waylanddrv.h      |  5 +++++
 dlls/winewayland.drv/window.c          | 16 +++++-----------
 3 files changed, 14 insertions(+), 18 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index b7121d5ed96..4daf56d10b3 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -48,8 +48,7 @@ static void xdg_surface_handle_configure(void *private, struct xdg_surface *xdg_
 
     /* Handle this event only if wayland_surface is still associated with
      * the target xdg_surface. */
-    if ((surface = data->wayland_surface) &&
-        surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
+    if ((surface = data->wayland_surface) && wayland_surface_is_toplevel(surface) &&
         surface->xdg_surface == xdg_surface)
     {
         /* If we have a previously requested config, we have already sent a
@@ -118,9 +117,7 @@ static void xdg_toplevel_handle_configure(void *private,
 
     if (!(data = wayland_win_data_get(hwnd))) return;
 
-    if ((surface = data->wayland_surface) &&
-        surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
-        surface->xdg_toplevel == xdg_toplevel)
+    if ((surface = data->wayland_surface) && wayland_surface_is_toplevel(surface))
     {
         surface->pending.width = width;
         surface->pending.height = height;
@@ -1171,7 +1168,7 @@ void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR text)
     DWORD utf8_count;
     char *utf8 = NULL;
 
-    assert(surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL && surface->xdg_toplevel);
+    assert(wayland_surface_is_toplevel(surface));
 
     TRACE("surface=%p hwnd=%p text='%s'\n",
           surface, surface->hwnd, wine_dbgstr_w(text));
@@ -1197,7 +1194,7 @@ void wayland_surface_set_icon(struct wayland_surface *surface, UINT type, ICONIN
     struct wayland_shm_buffer *icon_buf;
 
     assert(ii);
-    assert(surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL && surface->xdg_toplevel);
+    assert(wayland_surface_is_toplevel(surface));
 
     hDC = NtGdiCreateCompatibleDC(0);
     icon_buf = wayland_shm_buffer_from_color_bitmaps(hDC, ii->hbmColor, ii->hbmMask);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 3c42272ccde..b3d3016174a 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -330,6 +330,11 @@ void wayland_surface_ensure_contents(struct wayland_surface *surface);
 void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR title);
 void wayland_surface_set_icon(struct wayland_surface *surface, UINT type, ICONINFO *ii);
 
+static inline BOOL wayland_surface_is_toplevel(struct wayland_surface *surface)
+{
+    return surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL && surface->xdg_toplevel;
+}
+
 /**********************************************************************
  *          Wayland SHM buffer
  */
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 03dff29a4cc..acc34a18218 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -494,8 +494,7 @@ void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, HWND owner_hint, UIN
     }
 
     needs_icon = data->wayland_surface && !data->wayland_surface->big_icon_buffer &&
-                 data->wayland_surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
-                 data->wayland_surface->xdg_toplevel &&
+                 wayland_surface_is_toplevel(data->wayland_surface) &&
                  process_wayland.xdg_toplevel_icon_manager_v1;
 
     wayland_win_data_release(data);
@@ -537,7 +536,7 @@ static void wayland_configure_window(HWND hwnd)
         return;
     }
 
-    if (surface->role != WAYLAND_SURFACE_ROLE_TOPLEVEL || !surface->xdg_toplevel)
+    if (!wayland_surface_is_toplevel(surface))
     {
         TRACE("missing xdg_toplevel, returning\n");
         wayland_win_data_release(data);
@@ -700,9 +699,7 @@ void WAYLAND_SetWindowIcon(HWND hwnd, UINT type, HICON icon)
         icon = get_window_icon(hwnd, type, icon, &ii);
         if (icon && (data = wayland_win_data_get(hwnd)))
         {
-            if (data->wayland_surface &&
-                data->wayland_surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
-                data->wayland_surface->xdg_toplevel)
+            if (data->wayland_surface && wayland_surface_is_toplevel(data->wayland_surface))
                 wayland_surface_set_icon(data->wayland_surface, type, &ii);
             wayland_win_data_release(data);
         }
@@ -721,9 +718,7 @@ void WAYLAND_SetWindowText(HWND hwnd, LPCWSTR text)
 
     if ((data = wayland_win_data_get(hwnd)))
     {
-        if ((surface = data->wayland_surface) &&
-            surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
-            surface->xdg_toplevel)
+        if ((surface = data->wayland_surface) && wayland_surface_is_toplevel(surface))
             wayland_surface_set_title(surface, text);
         wayland_win_data_release(data);
     }
@@ -758,8 +753,7 @@ LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam, const POINT
             pthread_mutex_lock(&process_wayland.seat.mutex);
             wl_seat = process_wayland.seat.wl_seat;
             if (wl_seat && (surface = data->wayland_surface) &&
-                surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL &&
-                surface->xdg_toplevel && button_serial)
+                wayland_surface_is_toplevel(surface) && button_serial)
             {
                 if (command == SC_MOVE)
                 {
-- 
2.49.0

From 36bee86779b5ac2689447048045fd6e1ba56a191 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Tue, 6 May 2025 09:06:03 -0400
Subject: [PATCH 29/78] hack: winewayland: handle fractional scaling

---
 dlls/winewayland.drv/Makefile.in             |   1 +
 dlls/winewayland.drv/fractional-scale-v1.xml | 102 +++++++++++++++++++
 dlls/winewayland.drv/wayland.c               |   8 ++
 dlls/winewayland.drv/wayland_surface.c       |  39 +++++++
 dlls/winewayland.drv/waylanddrv.h            |   5 +
 dlls/winewayland.drv/window.c                |   2 +-
 6 files changed, 156 insertions(+), 1 deletion(-)
 create mode 100644 dlls/winewayland.drv/fractional-scale-v1.xml

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index e7b1bfb90eb..f141c22ee36 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -7,6 +7,7 @@ IMPORTS = user32 win32u
 SOURCES = \
 	display.c \
 	dllmain.c \
+	fractional-scale-v1.xml \
 	opengl.c \
 	pointer-constraints-unstable-v1.xml \
 	relative-pointer-unstable-v1.xml \
diff --git a/dlls/winewayland.drv/fractional-scale-v1.xml b/dlls/winewayland.drv/fractional-scale-v1.xml
new file mode 100644
index 00000000000..350bfc01eaf
--- /dev/null
+++ b/dlls/winewayland.drv/fractional-scale-v1.xml
@@ -0,0 +1,102 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="fractional_scale_v1">
+  <copyright>
+    Copyright © 2022 Kenny Levinsen
+
+    Permission is hereby granted, free of charge, to any person obtaining a
+    copy of this software and associated documentation files (the "Software"),
+    to deal in the Software without restriction, including without limitation
+    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+    and/or sell copies of the Software, and to permit persons to whom the
+    Software is furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice (including the next
+    paragraph) shall be included in all copies or substantial portions of the
+    Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+    DEALINGS IN THE SOFTWARE.
+  </copyright>
+
+  <description summary="Protocol for requesting fractional surface scales">
+    This protocol allows a compositor to suggest for surfaces to render at
+    fractional scales.
+
+    A client can submit scaled content by utilizing wp_viewport. This is done by
+    creating a wp_viewport object for the surface and setting the destination
+    rectangle to the surface size before the scale factor is applied.
+
+    The buffer size is calculated by multiplying the surface size by the
+    intended scale.
+
+    The wl_surface buffer scale should remain set to 1.
+
+    If a surface has a surface-local size of 100 px by 50 px and wishes to
+    submit buffers with a scale of 1.5, then a buffer of 150px by 75 px should
+    be used and the wp_viewport destination rectangle should be 100 px by 50 px.
+
+    For toplevel surfaces, the size is rounded halfway away from zero. The
+    rounding algorithm for subsurface position and size is not defined.
+  </description>
+
+  <interface name="wp_fractional_scale_manager_v1" version="1">
+    <description summary="fractional surface scale information">
+      A global interface for requesting surfaces to use fractional scales.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="unbind the fractional surface scale interface">
+        Informs the server that the client will not be using this protocol
+        object anymore. This does not affect any other objects,
+        wp_fractional_scale_v1 objects included.
+      </description>
+    </request>
+
+    <enum name="error">
+      <entry name="fractional_scale_exists" value="0"
+        summary="the surface already has a fractional_scale object associated"/>
+    </enum>
+
+    <request name="get_fractional_scale">
+      <description summary="extend surface interface for scale information">
+        Create an add-on object for the the wl_surface to let the compositor
+        request fractional scales. If the given wl_surface already has a
+        wp_fractional_scale_v1 object associated, the fractional_scale_exists
+        protocol error is raised.
+      </description>
+      <arg name="id" type="new_id" interface="wp_fractional_scale_v1"
+           summary="the new surface scale info interface id"/>
+      <arg name="surface" type="object" interface="wl_surface"
+           summary="the surface"/>
+    </request>
+  </interface>
+
+  <interface name="wp_fractional_scale_v1" version="1">
+    <description summary="fractional scale interface to a wl_surface">
+      An additional interface to a wl_surface object which allows the compositor
+      to inform the client of the preferred scale.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="remove surface scale information for surface">
+        Destroy the fractional scale object. When this object is destroyed,
+        preferred_scale events will no longer be sent.
+      </description>
+    </request>
+
+    <event name="preferred_scale">
+      <description summary="notify of new preferred scale">
+        Notification of a new preferred scale for this surface that the
+        compositor suggests that the client should use.
+
+        The sent scale is the numerator of a fraction with a denominator of 120.
+      </description>
+      <arg name="scale" type="uint" summary="the new preferred scale"/>
+    </event>
+  </interface>
+</protocol>
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index ba09d32ed89..08cbb8c6979 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -194,6 +194,11 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         process_wayland.xdg_toplevel_icon_manager_v1 =
             wl_registry_bind(registry, id, &xdg_toplevel_icon_manager_v1_interface, 1);
     }
+    else if (strcmp(interface, "wp_fractional_scale_manager_v1") == 0)
+    {
+        process_wayland.wp_fractional_scale_manager_v1 =
+            wl_registry_bind(registry, id, &wp_fractional_scale_manager_v1_interface, 1);
+    }
 }
 
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
@@ -327,6 +332,9 @@ BOOL wayland_process_init(void)
     if (!process_wayland.xdg_toplevel_icon_manager_v1)
         ERR("Wayland compositor doesn't support xdg_toplevel_icon_manager_v1 (window icons will not be supported)\n");
 
+    if (!process_wayland.wp_fractional_scale_manager_v1)
+        ERR("Wayland compositor doesn't support wp_fractional_scale_manager_v1 (fractional scaling will be broken)\n");
+
     process_wayland.initialized = TRUE;
 
     return TRUE;
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 4daf56d10b3..76469a3bce4 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -138,6 +138,25 @@ static const struct xdg_toplevel_listener xdg_toplevel_listener =
     xdg_toplevel_handle_close
 };
 
+void wp_fractional_scale_handle_scale(void* data,
+        struct wp_fractional_scale_v1 *fractional_scale_v1, uint32_t scale)
+{
+    double *data_scale;
+
+    assert(data);
+    data_scale = data;
+
+    /* FIXME: handle locking! */
+    *data_scale = scale / 120.0;
+
+    TRACE("Got scale %lf\n", *data_scale);
+}
+
+static const struct wp_fractional_scale_v1_listener wp_fractional_scale_listener =
+{
+    wp_fractional_scale_handle_scale
+};
+
 /**********************************************************************
  *          wayland_surface_create
  *
@@ -174,8 +193,22 @@ struct wayland_surface *wayland_surface_create(HWND hwnd)
         goto err;
     }
 
+    /* in case we don't get notification */
+    surface->window.fractional_scale = 1.0;
     surface->window.scale = 1.0;
 
+    if (process_wayland.wp_fractional_scale_manager_v1)
+    {
+        surface->wp_fractional_scale_v1 =
+            wp_fractional_scale_manager_v1_get_fractional_scale(
+                process_wayland.wp_fractional_scale_manager_v1,
+                surface->wl_surface);
+        wp_fractional_scale_v1_add_listener(
+            surface->wp_fractional_scale_v1,
+            &wp_fractional_scale_listener,
+            &surface->window.fractional_scale);
+    }
+
     return surface;
 
 err:
@@ -207,6 +240,12 @@ void wayland_surface_destroy(struct wayland_surface *surface)
 
     wayland_surface_clear_role(surface);
 
+    if (surface->wp_fractional_scale_v1)
+    {
+        wp_fractional_scale_v1_destroy(surface->wp_fractional_scale_v1);
+        surface->wp_fractional_scale_v1 = NULL;
+    }
+
     if (surface->wp_viewport)
     {
         wp_viewport_destroy(surface->wp_viewport);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index b3d3016174a..5e04b410202 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -37,6 +37,7 @@
 #include "xdg-shell-client-protocol.h"
 #include "wlr-data-control-unstable-v1-client-protocol.h"
 #include "xdg-toplevel-icon-v1-client-protocol.h"
+#include "fractional-scale-v1-client-protocol.h"
 
 #include "windef.h"
 #include "winbase.h"
@@ -166,6 +167,7 @@ struct wayland
     struct wl_shm *wl_shm;
     struct wp_viewporter *wp_viewporter;
     struct wl_subcompositor *wl_subcompositor;
+    struct wp_fractional_scale_manager_v1 *wp_fractional_scale_manager_v1;
     struct zwp_pointer_constraints_v1 *zwp_pointer_constraints_v1;
     struct zwp_relative_pointer_manager_v1 *zwp_relative_pointer_manager_v1;
     struct zwp_text_input_manager_v3 *zwp_text_input_manager_v3;
@@ -225,6 +227,8 @@ struct wayland_window_config
     RECT rect;
     RECT client_rect;
     enum wayland_surface_config_state state;
+    /* The scaling reported by the compositor */
+    double fractional_scale;
     /* The scale (i.e., normalized dpi) the window is rendering at. */
     double scale;
     BOOL visible;
@@ -259,6 +263,7 @@ struct wayland_surface
 
     struct wl_surface *wl_surface;
     struct wp_viewport *wp_viewport;
+    struct wp_fractional_scale_v1 *wp_fractional_scale_v1;
 
     enum wayland_surface_role role;
     union
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index acc34a18218..648792616af 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -174,7 +174,7 @@ static void wayland_win_data_get_config(struct wayland_win_data *data,
     }
 
     conf->state = window_state;
-    conf->scale = NtUserGetSystemDpiForProcess(0) / 96.0;
+    conf->scale = conf->fractional_scale * NtUserGetSystemDpiForProcess(0) / 96.0;
     conf->visible = (style & WS_VISIBLE) == WS_VISIBLE;
     conf->managed = data->managed;
 }
-- 
2.49.0

From b5f9a85ab4442672906cdb95bbb2c0a02c03b5e7 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Tue, 6 May 2025 21:09:38 -0400
Subject: [PATCH 30/78] cursor shape v1

Co-Authored-By: afrantzis <495575+afrantzis@users.noreply.github.com>
---
 dlls/winewayland.drv/Makefile.in         |    2 +
 dlls/winewayland.drv/cursor-shape-v1.xml |  162 +++
 dlls/winewayland.drv/tablet-v2.xml       | 1297 ++++++++++++++++++++++
 dlls/winewayland.drv/wayland.c           |    6 +
 dlls/winewayland.drv/wayland_pointer.c   |  219 +++-
 dlls/winewayland.drv/waylanddrv.h        |    5 +
 dlls/winewayland.drv/waylanddrv_main.c   |  146 +++
 7 files changed, 1809 insertions(+), 28 deletions(-)
 create mode 100644 dlls/winewayland.drv/cursor-shape-v1.xml
 create mode 100644 dlls/winewayland.drv/tablet-v2.xml

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index f141c22ee36..92db5349568 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -5,12 +5,14 @@ UNIX_LIBS = -lwin32u $(WAYLAND_CLIENT_LIBS) $(WAYLAND_EGL_LIBS) $(XKBCOMMON_LIBS
 IMPORTS = user32 win32u
 
 SOURCES = \
+	cursor-shape-v1.xml \
 	display.c \
 	dllmain.c \
 	fractional-scale-v1.xml \
 	opengl.c \
 	pointer-constraints-unstable-v1.xml \
 	relative-pointer-unstable-v1.xml \
+	tablet-v2.xml \
 	text-input-unstable-v3.xml \
 	version.rc \
 	viewporter.xml \
diff --git a/dlls/winewayland.drv/cursor-shape-v1.xml b/dlls/winewayland.drv/cursor-shape-v1.xml
new file mode 100644
index 00000000000..64b2f9b2c87
--- /dev/null
+++ b/dlls/winewayland.drv/cursor-shape-v1.xml
@@ -0,0 +1,162 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="cursor_shape_v1">
+  <copyright>
+    Copyright 2018 The Chromium Authors
+    Copyright 2023 Simon Ser
+
+    Permission is hereby granted, free of charge, to any person obtaining a
+    copy of this software and associated documentation files (the "Software"),
+    to deal in the Software without restriction, including without limitation
+    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+    and/or sell copies of the Software, and to permit persons to whom the
+    Software is furnished to do so, subject to the following conditions:
+    The above copyright notice and this permission notice (including the next
+    paragraph) shall be included in all copies or substantial portions of the
+    Software.
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+    DEALINGS IN THE SOFTWARE.
+  </copyright>
+
+  <interface name="wp_cursor_shape_manager_v1" version="2">
+    <description summary="cursor shape manager">
+      This global offers an alternative, optional way to set cursor images. This
+      new way uses enumerated cursors instead of a wl_surface like
+      wl_pointer.set_cursor does.
+
+      Warning! The protocol described in this file is currently in the testing
+      phase. Backward compatible changes may be added together with the
+      corresponding interface version bump. Backward incompatible changes can
+      only be done by creating a new major version of the extension.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the manager">
+        Destroy the cursor shape manager.
+      </description>
+    </request>
+
+    <request name="get_pointer">
+      <description summary="manage the cursor shape of a pointer device">
+        Obtain a wp_cursor_shape_device_v1 for a wl_pointer object.
+
+        When the pointer capability is removed from the wl_seat, the
+        wp_cursor_shape_device_v1 object becomes inert.
+      </description>
+      <arg name="cursor_shape_device" type="new_id" interface="wp_cursor_shape_device_v1"/>
+      <arg name="pointer" type="object" interface="wl_pointer"/>
+    </request>
+
+    <request name="get_tablet_tool_v2">
+      <description summary="manage the cursor shape of a tablet tool device">
+        Obtain a wp_cursor_shape_device_v1 for a zwp_tablet_tool_v2 object.
+
+        When the zwp_tablet_tool_v2 is removed, the wp_cursor_shape_device_v1
+        object becomes inert.
+      </description>
+      <arg name="cursor_shape_device" type="new_id" interface="wp_cursor_shape_device_v1"/>
+      <arg name="tablet_tool" type="object" interface="zwp_tablet_tool_v2"/>
+    </request>
+  </interface>
+
+  <interface name="wp_cursor_shape_device_v1" version="2">
+    <description summary="cursor shape for a device">
+      This interface allows clients to set the cursor shape.
+    </description>
+
+    <enum name="shape">
+      <description summary="cursor shapes">
+        This enum describes cursor shapes.
+
+        The names are taken from the CSS W3C specification:
+        https://w3c.github.io/csswg-drafts/css-ui/#cursor
+        with a few additions.
+
+        Note that there are some groups of cursor shapes that are related:
+        The first group is drag-and-drop cursors which are used to indicate
+        the selected action during dnd operations. The second group is resize
+        cursors which are used to indicate resizing and moving possibilities
+        on window borders. It is recommended that the shapes in these groups
+        should use visually compatible images and metaphors.
+      </description>
+      <entry name="default" value="1" summary="default cursor"/>
+      <entry name="context_menu" value="2" summary="a context menu is available for the object under the cursor"/>
+      <entry name="help" value="3" summary="help is available for the object under the cursor"/>
+      <entry name="pointer" value="4" summary="pointer that indicates a link or another interactive element"/>
+      <entry name="progress" value="5" summary="progress indicator"/>
+      <entry name="wait" value="6" summary="program is busy, user should wait"/>
+      <entry name="cell" value="7" summary="a cell or set of cells may be selected"/>
+      <entry name="crosshair" value="8" summary="simple crosshair"/>
+      <entry name="text" value="9" summary="text may be selected"/>
+      <entry name="vertical_text" value="10" summary="vertical text may be selected"/>
+      <entry name="alias" value="11" summary="drag-and-drop: alias of/shortcut to something is to be created"/>
+      <entry name="copy" value="12" summary="drag-and-drop: something is to be copied"/>
+      <entry name="move" value="13" summary="drag-and-drop: something is to be moved"/>
+      <entry name="no_drop" value="14" summary="drag-and-drop: the dragged item cannot be dropped at the current cursor location"/>
+      <entry name="not_allowed" value="15" summary="drag-and-drop: the requested action will not be carried out"/>
+      <entry name="grab" value="16" summary="drag-and-drop: something can be grabbed"/>
+      <entry name="grabbing" value="17" summary="drag-and-drop: something is being grabbed"/>
+      <entry name="e_resize" value="18" summary="resizing: the east border is to be moved"/>
+      <entry name="n_resize" value="19" summary="resizing: the north border is to be moved"/>
+      <entry name="ne_resize" value="20" summary="resizing: the north-east corner is to be moved"/>
+      <entry name="nw_resize" value="21" summary="resizing: the north-west corner is to be moved"/>
+      <entry name="s_resize" value="22" summary="resizing: the south border is to be moved"/>
+      <entry name="se_resize" value="23" summary="resizing: the south-east corner is to be moved"/>
+      <entry name="sw_resize" value="24" summary="resizing: the south-west corner is to be moved"/>
+      <entry name="w_resize" value="25" summary="resizing: the west border is to be moved"/>
+      <entry name="ew_resize" value="26" summary="resizing: the east and west borders are to be moved"/>
+      <entry name="ns_resize" value="27" summary="resizing: the north and south borders are to be moved"/>
+      <entry name="nesw_resize" value="28" summary="resizing: the north-east and south-west corners are to be moved"/>
+      <entry name="nwse_resize" value="29" summary="resizing: the north-west and south-east corners are to be moved"/>
+      <entry name="col_resize" value="30" summary="resizing: that the item/column can be resized horizontally"/>
+      <entry name="row_resize" value="31" summary="resizing: that the item/row can be resized vertically"/>
+      <entry name="all_scroll" value="32" summary="something can be scrolled in any direction"/>
+      <entry name="zoom_in" value="33" summary="something can be zoomed in"/>
+      <entry name="zoom_out" value="34" summary="something can be zoomed out"/>
+      <entry name="dnd_ask" value="35" summary="drag-and-drop: the user will select which action will be carried out (non-css value)" since="2"/>
+      <entry name="all_resize" value="36" summary="resizing: something can be moved or resized in any direction (non-css value)" since="2"/>
+    </enum>
+
+    <enum name="error">
+      <entry name="invalid_shape" value="1"
+        summary="the specified shape value is invalid"/>
+    </enum>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the cursor shape device">
+        Destroy the cursor shape device.
+
+        The device cursor shape remains unchanged.
+      </description>
+    </request>
+
+    <request name="set_shape">
+      <description summary="set device cursor to the shape">
+        Sets the device cursor to the specified shape. The compositor will
+        change the cursor image based on the specified shape.
+
+        The cursor actually changes only if the input device focus is one of
+        the requesting client's surfaces. If any, the previous cursor image
+        (surface or shape) is replaced.
+
+        The "shape" argument must be a valid enum entry, otherwise the
+        invalid_shape protocol error is raised.
+
+        This is similar to the wl_pointer.set_cursor and
+        zwp_tablet_tool_v2.set_cursor requests, but this request accepts a
+        shape instead of contents in the form of a surface. Clients can mix
+        set_cursor and set_shape requests.
+
+        The serial parameter must match the latest wl_pointer.enter or
+        zwp_tablet_tool_v2.proximity_in serial number sent to the client.
+        Otherwise the request will be ignored.
+      </description>
+      <arg name="serial" type="uint" summary="serial number of the enter event"/>
+      <arg name="shape" type="uint" enum="shape"/>
+    </request>
+  </interface>
+</protocol>
diff --git a/dlls/winewayland.drv/tablet-v2.xml b/dlls/winewayland.drv/tablet-v2.xml
new file mode 100644
index 00000000000..e2550435c79
--- /dev/null
+++ b/dlls/winewayland.drv/tablet-v2.xml
@@ -0,0 +1,1297 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="tablet_v2">
+
+  <copyright>
+    Copyright 2014 © Stephen "Lyude" Chandler Paul
+    Copyright 2015-2024 © Red Hat, Inc.
+
+    Permission is hereby granted, free of charge, to any person
+    obtaining a copy of this software and associated documentation files
+    (the "Software"), to deal in the Software without restriction,
+    including without limitation the rights to use, copy, modify, merge,
+    publish, distribute, sublicense, and/or sell copies of the Software,
+    and to permit persons to whom the Software is furnished to do so,
+    subject to the following conditions:
+
+    The above copyright notice and this permission notice (including the
+    next paragraph) shall be included in all copies or substantial
+    portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE.
+  </copyright>
+
+  <description summary="Wayland protocol for graphics tablets">
+    This description provides a high-level overview of the interplay between
+    the interfaces defined this protocol. For details, see the protocol
+    specification.
+
+    More than one tablet may exist, and device-specifics matter. Tablets are
+    not represented by a single virtual device like wl_pointer. A client
+    binds to the tablet manager object which is just a proxy object. From
+    that, the client requests wp_tablet_manager.get_tablet_seat(wl_seat)
+    and that returns the actual interface that has all the tablets. With
+    this indirection, we can avoid merging wp_tablet into the actual Wayland
+    protocol, a long-term benefit.
+
+    The wp_tablet_seat sends a "tablet added" event for each tablet
+    connected. That event is followed by descriptive events about the
+    hardware; currently that includes events for name, vid/pid and
+    a wp_tablet.path event that describes a local path. This path can be
+    used to uniquely identify a tablet or get more information through
+    libwacom. Emulated or nested tablets can skip any of those, e.g. a
+    virtual tablet may not have a vid/pid. The sequence of descriptive
+    events is terminated by a wp_tablet.done event to signal that a client
+    may now finalize any initialization for that tablet.
+
+    Events from tablets require a tool in proximity. Tools are also managed
+    by the tablet seat; a "tool added" event is sent whenever a tool is new
+    to the compositor. That event is followed by a number of descriptive
+    events about the hardware; currently that includes capabilities,
+    hardware id and serial number, and tool type. Similar to the tablet
+    interface, a wp_tablet_tool.done event is sent to terminate that initial
+    sequence.
+
+    Any event from a tool happens on the wp_tablet_tool interface. When the
+    tool gets into proximity of the tablet, a proximity_in event is sent on
+    the wp_tablet_tool interface, listing the tablet and the surface. That
+    event is followed by a motion event with the coordinates. After that,
+    it's the usual motion, axis, button, etc. events. The protocol's
+    serialisation means events are grouped by wp_tablet_tool.frame events.
+
+    Two special events (that don't exist in X) are down and up. They signal
+    "tip touching the surface". For tablets without real proximity
+    detection, the sequence is: proximity_in, motion, down, frame.
+
+    When the tool leaves proximity, a proximity_out event is sent. If any
+    button is still down, a button release event is sent before this
+    proximity event. These button events are sent in the same frame as the
+    proximity event to signal to the client that the buttons were held when
+    the tool left proximity.
+
+    If the tool moves out of the surface but stays in proximity (i.e.
+    between windows), compositor-specific grab policies apply. This usually
+    means that the proximity-out is delayed until all buttons are released.
+
+    Moving a tool physically from one tablet to the other has no real effect
+    on the protocol, since we already have the tool object from the "tool
+    added" event. All the information is already there and the proximity
+    events on both tablets are all a client needs to reconstruct what
+    happened.
+
+    Some extra axes are normalized, i.e. the client knows the range as
+    specified in the protocol (e.g. [0, 65535]), the granularity however is
+    unknown. The current normalized axes are pressure, distance, and slider.
+
+    Other extra axes are in physical units as specified in the protocol.
+    The current extra axes with physical units are tilt, rotation and
+    wheel rotation.
+
+    Since tablets work independently of the pointer controlled by the mouse,
+    the focus handling is independent too and controlled by proximity.
+    The wp_tablet_tool.set_cursor request sets a tool-specific cursor.
+    This cursor surface may be the same as the mouse cursor, and it may be
+    the same across tools but it is possible to be more fine-grained. For
+    example, a client may set different cursors for the pen and eraser.
+
+    Tools are generally independent of tablets and it is
+    compositor-specific policy when a tool can be removed. Common approaches
+    will likely include some form of removing a tool when all tablets the
+    tool was used on are removed.
+  </description>
+
+  <interface name="zwp_tablet_manager_v2" version="2">
+    <description summary="controller object for graphic tablet devices">
+      An object that provides access to the graphics tablets available on this
+      system. All tablets are associated with a seat, to get access to the
+      actual tablets, use wp_tablet_manager.get_tablet_seat.
+    </description>
+
+    <request name="get_tablet_seat">
+      <description summary="get the tablet seat">
+	Get the wp_tablet_seat object for the given seat. This object
+	provides access to all graphics tablets in this seat.
+      </description>
+      <arg name="tablet_seat" type="new_id" interface="zwp_tablet_seat_v2"/>
+      <arg name="seat" type="object" interface="wl_seat" summary="The wl_seat object to retrieve the tablets for" />
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="release the memory for the tablet manager object">
+	Destroy the wp_tablet_manager object. Objects created from this
+	object are unaffected and should be destroyed separately.
+      </description>
+    </request>
+  </interface>
+
+  <interface name="zwp_tablet_seat_v2" version="2">
+    <description summary="controller object for graphic tablet devices of a seat">
+      An object that provides access to the graphics tablets available on this
+      seat. After binding to this interface, the compositor sends a set of
+      wp_tablet_seat.tablet_added and wp_tablet_seat.tool_added events.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="release the memory for the tablet seat object">
+	Destroy the wp_tablet_seat object. Objects created from this
+	object are unaffected and should be destroyed separately.
+      </description>
+    </request>
+
+    <event name="tablet_added">
+      <description summary="new device notification">
+	This event is sent whenever a new tablet becomes available on this
+	seat. This event only provides the object id of the tablet, any
+	static information about the tablet (device name, vid/pid, etc.) is
+	sent through the wp_tablet interface.
+      </description>
+      <arg name="id" type="new_id" interface="zwp_tablet_v2" summary="the newly added graphics tablet"/>
+    </event>
+
+    <event name="tool_added">
+      <description summary="a new tool has been used with a tablet">
+	This event is sent whenever a tool that has not previously been used
+	with a tablet comes into use. This event only provides the object id
+	of the tool; any static information about the tool (capabilities,
+	type, etc.) is sent through the wp_tablet_tool interface.
+      </description>
+      <arg name="id" type="new_id" interface="zwp_tablet_tool_v2" summary="the newly added tablet tool"/>
+    </event>
+
+    <event name="pad_added">
+      <description summary="new pad notification">
+	This event is sent whenever a new pad is known to the system. Typically,
+	pads are physically attached to tablets and a pad_added event is
+	sent immediately after the wp_tablet_seat.tablet_added.
+	However, some standalone pad devices logically attach to tablets at
+	runtime, and the client must wait for wp_tablet_pad.enter to know
+	the tablet a pad is attached to.
+
+	This event only provides the object id of the pad. All further
+	features (buttons, strips, rings) are sent through the wp_tablet_pad
+	interface.
+      </description>
+      <arg name="id" type="new_id" interface="zwp_tablet_pad_v2" summary="the newly added pad"/>
+    </event>
+  </interface>
+
+  <interface name="zwp_tablet_tool_v2" version="2">
+    <description summary="a physical tablet tool">
+      An object that represents a physical tool that has been, or is
+      currently in use with a tablet in this seat. Each wp_tablet_tool
+      object stays valid until the client destroys it; the compositor
+      reuses the wp_tablet_tool object to indicate that the object's
+      respective physical tool has come into proximity of a tablet again.
+
+      A wp_tablet_tool object's relation to a physical tool depends on the
+      tablet's ability to report serial numbers. If the tablet supports
+      this capability, then the object represents a specific physical tool
+      and can be identified even when used on multiple tablets.
+
+      A tablet tool has a number of static characteristics, e.g. tool type,
+      hardware_serial and capabilities. These capabilities are sent in an
+      event sequence after the wp_tablet_seat.tool_added event before any
+      actual events from this tool. This initial event sequence is
+      terminated by a wp_tablet_tool.done event.
+
+      Tablet tool events are grouped by wp_tablet_tool.frame events.
+      Any events received before a wp_tablet_tool.frame event should be
+      considered part of the same hardware state change.
+    </description>
+
+    <request name="set_cursor">
+      <description summary="set the tablet tool's surface">
+	Sets the surface of the cursor used for this tool on the given
+	tablet. This request only takes effect if the tool is in proximity
+	of one of the requesting client's surfaces or the surface parameter
+	is the current pointer surface. If there was a previous surface set
+	with this request it is replaced. If surface is NULL, the cursor
+	image is hidden.
+
+	The parameters hotspot_x and hotspot_y define the position of the
+	pointer surface relative to the pointer location. Its top-left corner
+	is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the
+	coordinates of the pointer location, in surface-local coordinates.
+
+	On surface.attach requests to the pointer surface, hotspot_x and
+	hotspot_y are decremented by the x and y parameters passed to the
+	request. Attach must be confirmed by wl_surface.commit as usual.
+
+	The hotspot can also be updated by passing the currently set pointer
+	surface to this request with new values for hotspot_x and hotspot_y.
+
+	The current and pending input regions of the wl_surface are cleared,
+	and wl_surface.set_input_region is ignored until the wl_surface is no
+	longer used as the cursor. When the use as a cursor ends, the current
+	and pending input regions become undefined, and the wl_surface is
+	unmapped.
+
+	This request gives the surface the role of a wp_tablet_tool cursor. A
+	surface may only ever be used as the cursor surface for one
+	wp_tablet_tool. If the surface already has another role or has
+	previously been used as cursor surface for a different tool, a
+	protocol error is raised.
+      </description>
+      <arg name="serial" type="uint" summary="serial of the proximity_in event"/>
+      <arg name="surface" type="object" interface="wl_surface" allow-null="true"/>
+      <arg name="hotspot_x" type="int" summary="surface-local x coordinate"/>
+      <arg name="hotspot_y" type="int" summary="surface-local y coordinate"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the tool object">
+	This destroys the client's resource for this tool object.
+      </description>
+    </request>
+
+    <enum name="type">
+      <description summary="a physical tool type">
+	Describes the physical type of a tool. The physical type of a tool
+	generally defines its base usage.
+
+	The mouse tool represents a mouse-shaped tool that is not a relative
+	device but bound to the tablet's surface, providing absolute
+	coordinates.
+
+	The lens tool is a mouse-shaped tool with an attached lens to
+	provide precision focus.
+      </description>
+      <entry name="pen" value="0x140" summary="Pen"/>
+      <entry name="eraser" value="0x141" summary="Eraser"/>
+      <entry name="brush" value="0x142" summary="Brush"/>
+      <entry name="pencil" value="0x143" summary="Pencil"/>
+      <entry name="airbrush" value="0x144" summary="Airbrush"/>
+      <entry name="finger" value="0x145" summary="Finger"/>
+      <entry name="mouse" value="0x146" summary="Mouse"/>
+      <entry name="lens" value="0x147" summary="Lens"/>
+    </enum>
+
+    <event name="type">
+      <description summary="tool type">
+	The tool type is the high-level type of the tool and usually decides
+	the interaction expected from this tool.
+
+	This event is sent in the initial burst of events before the
+	wp_tablet_tool.done event.
+      </description>
+      <arg name="tool_type" type="uint" enum="type" summary="the physical tool type"/>
+    </event>
+
+    <event name="hardware_serial">
+      <description summary="unique hardware serial number of the tool">
+	If the physical tool can be identified by a unique 64-bit serial
+	number, this event notifies the client of this serial number.
+
+	If multiple tablets are available in the same seat and the tool is
+	uniquely identifiable by the serial number, that tool may move
+	between tablets.
+
+	Otherwise, if the tool has no serial number and this event is
+	missing, the tool is tied to the tablet it first comes into
+	proximity with. Even if the physical tool is used on multiple
+	tablets, separate wp_tablet_tool objects will be created, one per
+	tablet.
+
+	This event is sent in the initial burst of events before the
+	wp_tablet_tool.done event.
+      </description>
+      <arg name="hardware_serial_hi" type="uint" summary="the unique serial number of the tool, most significant bits"/>
+      <arg name="hardware_serial_lo" type="uint" summary="the unique serial number of the tool, least significant bits"/>
+    </event>
+
+    <event name="hardware_id_wacom">
+      <description summary="hardware id notification in Wacom's format">
+	This event notifies the client of a hardware id available on this tool.
+
+	The hardware id is a device-specific 64-bit id that provides extra
+	information about the tool in use, beyond the wl_tool.type
+	enumeration. The format of the id is specific to tablets made by
+	Wacom Inc. For example, the hardware id of a Wacom Grip
+	Pen (a stylus) is 0x802.
+
+	This event is sent in the initial burst of events before the
+	wp_tablet_tool.done event.
+      </description>
+      <arg name="hardware_id_hi" type="uint" summary="the hardware id, most significant bits"/>
+      <arg name="hardware_id_lo" type="uint" summary="the hardware id, least significant bits"/>
+    </event>
+
+    <enum name="capability">
+      <description summary="capability flags for a tool">
+	Describes extra capabilities on a tablet.
+
+	Any tool must provide x and y values, extra axes are
+	device-specific.
+      </description>
+      <entry name="tilt" value="1" summary="Tilt axes"/>
+      <entry name="pressure" value="2" summary="Pressure axis"/>
+      <entry name="distance" value="3" summary="Distance axis"/>
+      <entry name="rotation" value="4" summary="Z-rotation axis"/>
+      <entry name="slider" value="5" summary="Slider axis"/>
+      <entry name="wheel" value="6" summary="Wheel axis"/>
+    </enum>
+
+    <event name="capability">
+      <description summary="tool capability notification">
+	This event notifies the client of any capabilities of this tool,
+	beyond the main set of x/y axes and tip up/down detection.
+
+	One event is sent for each extra capability available on this tool.
+
+	This event is sent in the initial burst of events before the
+	wp_tablet_tool.done event.
+      </description>
+      <arg name="capability" type="uint" enum="capability" summary="the capability"/>
+    </event>
+
+    <event name="done">
+      <description summary="tool description events sequence complete">
+	This event signals the end of the initial burst of descriptive
+	events. A client may consider the static description of the tool to
+	be complete and finalize initialization of the tool.
+      </description>
+    </event>
+
+    <event name="removed">
+      <description summary="tool removed">
+	This event is sent when the tool is removed from the system and will
+	send no further events. Should the physical tool come back into
+	proximity later, a new wp_tablet_tool object will be created.
+
+	It is compositor-dependent when a tool is removed. A compositor may
+	remove a tool on proximity out, tablet removal or any other reason.
+	A compositor may also keep a tool alive until shutdown.
+
+	If the tool is currently in proximity, a proximity_out event will be
+	sent before the removed event. See wp_tablet_tool.proximity_out for
+	the handling of any buttons logically down.
+
+	When this event is received, the client must wp_tablet_tool.destroy
+	the object.
+      </description>
+    </event>
+
+    <event name="proximity_in">
+      <description summary="proximity in event">
+	Notification that this tool is focused on a certain surface.
+
+	This event can be received when the tool has moved from one surface to
+	another, or when the tool has come back into proximity above the
+	surface.
+
+	If any button is logically down when the tool comes into proximity,
+	the respective button event is sent after the proximity_in event but
+	within the same frame as the proximity_in event.
+      </description>
+      <arg name="serial" type="uint"/>
+      <arg name="tablet" type="object" interface="zwp_tablet_v2" summary="The tablet the tool is in proximity of"/>
+      <arg name="surface" type="object" interface="wl_surface" summary="The current surface the tablet tool is over"/>
+    </event>
+
+    <event name="proximity_out">
+      <description summary="proximity out event">
+	Notification that this tool has either left proximity, or is no
+	longer focused on a certain surface.
+
+	When the tablet tool leaves proximity of the tablet, button release
+	events are sent for each button that was held down at the time of
+	leaving proximity. These events are sent before the proximity_out
+	event but within the same wp_tablet.frame.
+
+	If the tool stays within proximity of the tablet, but the focus
+	changes from one surface to another, a button release event may not
+	be sent until the button is actually released or the tool leaves the
+	proximity of the tablet.
+      </description>
+    </event>
+
+    <event name="down">
+      <description summary="tablet tool is making contact">
+	Sent whenever the tablet tool comes in contact with the surface of the
+	tablet.
+
+	If the tool is already in contact with the tablet when entering the
+	input region, the client owning said region will receive a
+	wp_tablet.proximity_in event, followed by a wp_tablet.down
+	event and a wp_tablet.frame event.
+
+	Note that this event describes logical contact, not physical
+	contact. On some devices, a compositor may not consider a tool in
+	logical contact until a minimum physical pressure threshold is
+	exceeded.
+      </description>
+      <arg name="serial" type="uint"/>
+    </event>
+
+    <event name="up">
+      <description summary="tablet tool is no longer making contact">
+	Sent whenever the tablet tool stops making contact with the surface of
+	the tablet, or when the tablet tool moves out of the input region
+	and the compositor grab (if any) is dismissed.
+
+	If the tablet tool moves out of the input region while in contact
+	with the surface of the tablet and the compositor does not have an
+	ongoing grab on the surface, the client owning said region will
+	receive a wp_tablet.up event, followed by a wp_tablet.proximity_out
+	event and a wp_tablet.frame event. If the compositor has an ongoing
+	grab on this device, this event sequence is sent whenever the grab
+	is dismissed in the future.
+
+	Note that this event describes logical contact, not physical
+	contact. On some devices, a compositor may not consider a tool out
+	of logical contact until physical pressure falls below a specific
+	threshold.
+      </description>
+    </event>
+
+    <event name="motion">
+      <description summary="motion event">
+	Sent whenever a tablet tool moves.
+      </description>
+      <arg name="x" type="fixed" summary="surface-local x coordinate"/>
+      <arg name="y" type="fixed" summary="surface-local y coordinate"/>
+    </event>
+
+    <event name="pressure">
+      <description summary="pressure change event">
+	Sent whenever the pressure axis on a tool changes. The value of this
+	event is normalized to a value between 0 and 65535.
+
+	Note that pressure may be nonzero even when a tool is not in logical
+	contact. See the down and up events for more details.
+      </description>
+      <arg name="pressure" type="uint" summary="The current pressure value"/>
+    </event>
+
+    <event name="distance">
+      <description summary="distance change event">
+	Sent whenever the distance axis on a tool changes. The value of this
+	event is normalized to a value between 0 and 65535.
+
+	Note that distance may be nonzero even when a tool is not in logical
+	contact. See the down and up events for more details.
+      </description>
+      <arg name="distance" type="uint" summary="The current distance value"/>
+    </event>
+
+    <event name="tilt">
+      <description summary="tilt change event">
+	Sent whenever one or both of the tilt axes on a tool change. Each tilt
+	value is in degrees, relative to the z-axis of the tablet.
+	The angle is positive when the top of a tool tilts along the
+	positive x or y axis.
+      </description>
+      <arg name="tilt_x" type="fixed" summary="The current value of the X tilt axis"/>
+      <arg name="tilt_y" type="fixed" summary="The current value of the Y tilt axis"/>
+    </event>
+
+    <event name="rotation">
+      <description summary="z-rotation change event">
+	Sent whenever the z-rotation axis on the tool changes. The
+	rotation value is in degrees clockwise from the tool's
+	logical neutral position.
+      </description>
+      <arg name="degrees" type="fixed" summary="The current rotation of the Z axis"/>
+    </event>
+
+    <event name="slider">
+      <description summary="Slider position change event">
+	Sent whenever the slider position on the tool changes. The
+	value is normalized between -65535 and 65535, with 0 as the logical
+	neutral position of the slider.
+
+	The slider is available on e.g. the Wacom Airbrush tool.
+      </description>
+      <arg name="position" type="int" summary="The current position of slider"/>
+    </event>
+
+    <event name="wheel">
+      <description summary="Wheel delta event">
+	Sent whenever the wheel on the tool emits an event. This event
+	contains two values for the same axis change. The degrees value is
+	in the same orientation as the wl_pointer.vertical_scroll axis. The
+	clicks value is in discrete logical clicks of the mouse wheel. This
+	value may be zero if the movement of the wheel was less
+	than one logical click.
+
+	Clients should choose either value and avoid mixing degrees and
+	clicks. The compositor may accumulate values smaller than a logical
+	click and emulate click events when a certain threshold is met.
+	Thus, wl_tablet_tool.wheel events with non-zero clicks values may
+	have different degrees values.
+      </description>
+      <arg name="degrees" type="fixed" summary="The wheel delta in degrees"/>
+      <arg name="clicks" type="int" summary="The wheel delta in discrete clicks"/>
+    </event>
+
+    <enum name="button_state">
+      <description summary="physical button state">
+	Describes the physical state of a button that produced the button event.
+      </description>
+      <entry name="released" value="0" summary="button is not pressed"/>
+      <entry name="pressed" value="1" summary="button is pressed"/>
+    </enum>
+
+    <event name="button">
+      <description summary="button event">
+	Sent whenever a button on the tool is pressed or released.
+
+	If a button is held down when the tool moves in or out of proximity,
+	button events are generated by the compositor. See
+	wp_tablet_tool.proximity_in and wp_tablet_tool.proximity_out for
+	details.
+      </description>
+      <arg name="serial" type="uint"/>
+      <arg name="button" type="uint" summary="The button whose state has changed"/>
+      <arg name="state" type="uint" enum="button_state" summary="Whether the button was pressed or released"/>
+    </event>
+
+    <event name="frame">
+      <description summary="frame event">
+	Marks the end of a series of axis and/or button updates from the
+	tablet. The Wayland protocol requires axis updates to be sent
+	sequentially, however all events within a frame should be considered
+	one hardware event.
+      </description>
+      <arg name="time" type="uint" summary="The time of the event with millisecond granularity"/>
+    </event>
+
+    <enum name="error">
+      <entry name="role" value="0" summary="given wl_surface has another role"/>
+    </enum>
+  </interface>
+
+  <interface name="zwp_tablet_v2" version="2">
+    <description summary="graphics tablet device">
+      The wp_tablet interface represents one graphics tablet device. The
+      tablet interface itself does not generate events; all events are
+      generated by wp_tablet_tool objects when in proximity above a tablet.
+
+      A tablet has a number of static characteristics, e.g. device name and
+      pid/vid. These capabilities are sent in an event sequence after the
+      wp_tablet_seat.tablet_added event. This initial event sequence is
+      terminated by a wp_tablet.done event.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the tablet object">
+	This destroys the client's resource for this tablet object.
+      </description>
+    </request>
+
+    <event name="name">
+      <description summary="tablet device name">
+        A descriptive name for the tablet device.
+
+	If the device has no descriptive name, this event is not sent.
+
+	This event is sent in the initial burst of events before the
+        wp_tablet.done event.
+      </description>
+      <arg name="name" type="string" summary="the device name"/>
+    </event>
+
+    <event name="id">
+      <description summary="tablet device vendor/product id">
+	The vendor and product IDs for the tablet device.
+
+	The interpretation of the id depends on the wp_tablet.bustype.
+	Prior to version v2 of this protocol, the id was implied to be a USB
+	vendor and product ID. If no wp_tablet.bustype is sent, the ID
+	is to be interpreted as USB vendor and product ID.
+
+	If the device has no vendor/product ID, this event is not sent.
+	This can happen for virtual devices or non-USB devices, for instance.
+
+	This event is sent in the initial burst of events before the
+	wp_tablet.done event.
+      </description>
+      <arg name="vid" type="uint" summary="vendor id"/>
+      <arg name="pid" type="uint" summary="product id"/>
+    </event>
+
+    <event name="path">
+      <description summary="path to the device">
+	A system-specific device path that indicates which device is behind
+	this wp_tablet. This information may be used to gather additional
+	information about the device, e.g. through libwacom.
+
+	A device may have more than one device path. If so, multiple
+	wp_tablet.path events are sent. A device may be emulated and not
+	have a device path, and in that case this event will not be sent.
+
+	The format of the path is unspecified, it may be a device node, a
+	sysfs path, or some other identifier. It is up to the client to
+	identify the string provided.
+
+	This event is sent in the initial burst of events before the
+	wp_tablet.done event.
+      </description>
+      <arg name="path" type="string" summary="path to local device"/>
+    </event>
+
+    <event name="done">
+      <description summary="tablet description events sequence complete">
+	This event is sent immediately to signal the end of the initial
+	burst of descriptive events. A client may consider the static
+	description of the tablet to be complete and finalize initialization
+	of the tablet.
+      </description>
+    </event>
+
+    <event name="removed">
+      <description summary="tablet removed event">
+	Sent when the tablet has been removed from the system. When a tablet
+	is removed, some tools may be removed.
+
+	When this event is received, the client must wp_tablet.destroy
+	the object.
+      </description>
+    </event>
+
+    <!-- Version 2 additions -->
+
+    <enum name="bustype" since="2">
+      <description summary="bus type ">
+	Describes the bus types this tablet is connected to.
+      </description>
+      <entry name="usb" value="3" summary="USB"/>
+      <entry name="bluetooth" value="5" summary="Bluetooth"/>
+      <entry name="virtual" value="6" summary="Virtual"/>
+      <entry name="serial" value="17" summary="Serial"/>
+      <entry name="i2c" value="24" summary="I2C"/>
+    </enum>
+
+    <event name="bustype" since="2">
+      <description summary="tablet device bus type">
+	The bustype argument is one of the BUS_ defines in the Linux kernel's
+	linux/input.h
+
+	If the device has no known bustype or the bustype cannot be
+	queried, this event is not sent.
+
+	This event is sent in the initial burst of events before the
+	wp_tablet.done event.
+      </description>
+      <arg name="bustype" type="uint" enum="bustype" summary="bus type"/>
+    </event>
+  </interface>
+
+  <interface name="zwp_tablet_pad_ring_v2" version="2">
+    <description summary="pad ring">
+      A circular interaction area, such as the touch ring on the Wacom Intuos
+      Pro series tablets.
+
+      Events on a ring are logically grouped by the wl_tablet_pad_ring.frame
+      event.
+    </description>
+
+    <request name="set_feedback">
+      <description summary="set compositor feedback">
+	Request that the compositor use the provided feedback string
+	associated with this ring. This request should be issued immediately
+	after a wp_tablet_pad_group.mode_switch event from the corresponding
+	group is received, or whenever the ring is mapped to a different
+	action. See wp_tablet_pad_group.mode_switch for more details.
+
+	Clients are encouraged to provide context-aware descriptions for
+	the actions associated with the ring; compositors may use this
+	information to offer visual feedback about the button layout
+	(eg. on-screen displays).
+
+	The provided string 'description' is a UTF-8 encoded string to be
+	associated with this ring, and is considered user-visible; general
+	internationalization rules apply.
+
+	The serial argument will be that of the last
+	wp_tablet_pad_group.mode_switch event received for the group of this
+	ring. Requests providing other serials than the most recent one will be
+	ignored.
+      </description>
+      <arg name="description" type="string" summary="ring description"/>
+      <arg name="serial" type="uint" summary="serial of the mode switch event"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the ring object">
+	This destroys the client's resource for this ring object.
+      </description>
+    </request>
+
+    <enum name="source">
+      <description summary="ring axis source">
+	Describes the source types for ring events. This indicates to the
+	client how a ring event was physically generated; a client may
+	adjust the user interface accordingly. For example, events
+	from a "finger" source may trigger kinetic scrolling.
+      </description>
+      <entry name="finger" value="1" summary="finger"/>
+    </enum>
+
+    <event name="source">
+      <description summary="ring event source">
+	Source information for ring events.
+
+	This event does not occur on its own. It is sent before a
+	wp_tablet_pad_ring.frame event and carries the source information
+	for all events within that frame.
+
+	The source specifies how this event was generated. If the source is
+	wp_tablet_pad_ring.source.finger, a wp_tablet_pad_ring.stop event
+	will be sent when the user lifts the finger off the device.
+
+	This event is optional. If the source is unknown for an interaction,
+	no event is sent.
+      </description>
+      <arg name="source" type="uint" enum="source" summary="the event source"/>
+    </event>
+
+    <event name="angle">
+      <description summary="angle changed">
+	Sent whenever the angle on a ring changes.
+
+	The angle is provided in degrees clockwise from the logical
+	north of the ring in the pad's current rotation.
+      </description>
+      <arg name="degrees" type="fixed" summary="the current angle in degrees"/>
+    </event>
+
+    <event name="stop">
+      <description summary="interaction stopped">
+	Stop notification for ring events.
+
+	For some wp_tablet_pad_ring.source types, a wp_tablet_pad_ring.stop
+	event is sent to notify a client that the interaction with the ring
+	has terminated. This enables the client to implement kinetic scrolling.
+	See the wp_tablet_pad_ring.source documentation for information on
+	when this event may be generated.
+
+	Any wp_tablet_pad_ring.angle events with the same source after this
+	event should be considered as the start of a new interaction.
+      </description>
+    </event>
+
+    <event name="frame">
+      <description summary="end of a ring event sequence">
+	Indicates the end of a set of ring events that logically belong
+	together. A client is expected to accumulate the data in all events
+	within the frame before proceeding.
+
+	All wp_tablet_pad_ring events before a wp_tablet_pad_ring.frame event belong
+	logically together. For example, on termination of a finger interaction
+	on a ring the compositor will send a wp_tablet_pad_ring.source event,
+	a wp_tablet_pad_ring.stop event and a wp_tablet_pad_ring.frame event.
+
+	A wp_tablet_pad_ring.frame event is sent for every logical event
+	group, even if the group only contains a single wp_tablet_pad_ring
+	event. Specifically, a client may get a sequence: angle, frame,
+	angle, frame, etc.
+      </description>
+      <arg name="time" type="uint" summary="timestamp with millisecond granularity"/>
+    </event>
+  </interface>
+
+  <interface name="zwp_tablet_pad_strip_v2" version="2">
+    <description summary="pad strip">
+      A linear interaction area, such as the strips found in Wacom Cintiq
+      models.
+
+      Events on a strip are logically grouped by the wl_tablet_pad_strip.frame
+      event.
+    </description>
+
+    <request name="set_feedback">
+      <description summary="set compositor feedback">
+	Requests the compositor to use the provided feedback string
+	associated with this strip. This request should be issued immediately
+	after a wp_tablet_pad_group.mode_switch event from the corresponding
+	group is received, or whenever the strip is mapped to a different
+	action. See wp_tablet_pad_group.mode_switch for more details.
+
+	Clients are encouraged to provide context-aware descriptions for
+	the actions associated with the strip, and compositors may use this
+	information to offer visual feedback about the button layout
+	(eg. on-screen displays).
+
+	The provided string 'description' is a UTF-8 encoded string to be
+	associated with this ring, and is considered user-visible; general
+	internationalization rules apply.
+
+	The serial argument will be that of the last
+	wp_tablet_pad_group.mode_switch event received for the group of this
+	strip. Requests providing other serials than the most recent one will be
+	ignored.
+      </description>
+      <arg name="description" type="string" summary="strip description"/>
+      <arg name="serial" type="uint" summary="serial of the mode switch event"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the strip object">
+	This destroys the client's resource for this strip object.
+      </description>
+    </request>
+
+    <enum name="source">
+      <description summary="strip axis source">
+	Describes the source types for strip events. This indicates to the
+	client how a strip event was physically generated; a client may
+	adjust the user interface accordingly. For example, events
+	from a "finger" source may trigger kinetic scrolling.
+      </description>
+      <entry name="finger" value="1" summary="finger"/>
+    </enum>
+
+    <event name="source">
+      <description summary="strip event source">
+	Source information for strip events.
+
+	This event does not occur on its own. It is sent before a
+	wp_tablet_pad_strip.frame event and carries the source information
+	for all events within that frame.
+
+	The source specifies how this event was generated. If the source is
+	wp_tablet_pad_strip.source.finger, a wp_tablet_pad_strip.stop event
+	will be sent when the user lifts their finger off the device.
+
+	This event is optional. If the source is unknown for an interaction,
+	no event is sent.
+      </description>
+      <arg name="source" type="uint" enum="source" summary="the event source"/>
+    </event>
+
+    <event name="position">
+      <description summary="position changed">
+	Sent whenever the position on a strip changes.
+
+	The position is normalized to a range of [0, 65535], the 0-value
+	represents the top-most and/or left-most position of the strip in
+	the pad's current rotation.
+      </description>
+      <arg name="position" type="uint" summary="the current position"/>
+    </event>
+
+    <event name="stop">
+      <description summary="interaction stopped">
+	Stop notification for strip events.
+
+	For some wp_tablet_pad_strip.source types, a wp_tablet_pad_strip.stop
+	event is sent to notify a client that the interaction with the strip
+	has terminated. This enables the client to implement kinetic
+	scrolling. See the wp_tablet_pad_strip.source documentation for
+	information on when this event may be generated.
+
+	Any wp_tablet_pad_strip.position events with the same source after this
+	event should be considered as the start of a new interaction.
+      </description>
+    </event>
+
+    <event name="frame">
+      <description summary="end of a strip event sequence">
+	Indicates the end of a set of events that represent one logical
+	hardware strip event. A client is expected to accumulate the data
+	in all events within the frame before proceeding.
+
+	All wp_tablet_pad_strip events before a wp_tablet_pad_strip.frame event belong
+	logically together. For example, on termination of a finger interaction
+	on a strip the compositor will send a wp_tablet_pad_strip.source event,
+	a wp_tablet_pad_strip.stop event and a wp_tablet_pad_strip.frame
+	event.
+
+	A wp_tablet_pad_strip.frame event is sent for every logical event
+	group, even if the group only contains a single wp_tablet_pad_strip
+	event. Specifically, a client may get a sequence: position, frame,
+	position, frame, etc.
+      </description>
+      <arg name="time" type="uint" summary="timestamp with millisecond granularity"/>
+    </event>
+  </interface>
+
+  <interface name="zwp_tablet_pad_group_v2" version="2">
+    <description summary="a set of buttons, rings and strips">
+      A pad group describes a distinct (sub)set of buttons, rings and strips
+      present in the tablet. The criteria of this grouping is usually positional,
+      eg. if a tablet has buttons on the left and right side, 2 groups will be
+      presented. The physical arrangement of groups is undisclosed and may
+      change on the fly.
+
+      Pad groups will announce their features during pad initialization. Between
+      the corresponding wp_tablet_pad.group event and wp_tablet_pad_group.done, the
+      pad group will announce the buttons, rings and strips contained in it,
+      plus the number of supported modes.
+
+      Modes are a mechanism to allow multiple groups of actions for every element
+      in the pad group. The number of groups and available modes in each is
+      persistent across device plugs. The current mode is user-switchable, it
+      will be announced through the wp_tablet_pad_group.mode_switch event both
+      whenever it is switched, and after wp_tablet_pad.enter.
+
+      The current mode logically applies to all elements in the pad group,
+      although it is at clients' discretion whether to actually perform different
+      actions, and/or issue the respective .set_feedback requests to notify the
+      compositor. See the wp_tablet_pad_group.mode_switch event for more details.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the pad object">
+	Destroy the wp_tablet_pad_group object. Objects created from this object
+	are unaffected and should be destroyed separately.
+      </description>
+    </request>
+
+    <event name="buttons">
+      <description summary="buttons announced">
+	Sent on wp_tablet_pad_group initialization to announce the available
+	buttons in the group. Button indices start at 0, a button may only be
+	in one group at a time.
+
+	This event is first sent in the initial burst of events before the
+	wp_tablet_pad_group.done event.
+
+	Some buttons are reserved by the compositor. These buttons may not be
+	assigned to any wp_tablet_pad_group. Compositors may broadcast this
+	event in the case of changes to the mapping of these reserved buttons.
+	If the compositor happens to reserve all buttons in a group, this event
+	will be sent with an empty array.
+      </description>
+      <arg name="buttons" type="array" summary="buttons in this group"/>
+    </event>
+
+    <event name="ring">
+      <description summary="ring announced">
+	Sent on wp_tablet_pad_group initialization to announce available rings.
+	One event is sent for each ring available on this pad group.
+
+	This event is sent in the initial burst of events before the
+	wp_tablet_pad_group.done event.
+      </description>
+      <arg name="ring" type="new_id" interface="zwp_tablet_pad_ring_v2"/>
+    </event>
+
+    <event name="strip">
+      <description summary="strip announced">
+	Sent on wp_tablet_pad initialization to announce available strips.
+	One event is sent for each strip available on this pad group.
+
+	This event is sent in the initial burst of events before the
+	wp_tablet_pad_group.done event.
+      </description>
+      <arg name="strip" type="new_id" interface="zwp_tablet_pad_strip_v2"/>
+    </event>
+
+    <event name="modes">
+      <description summary="mode-switch ability announced">
+	Sent on wp_tablet_pad_group initialization to announce that the pad
+	group may switch between modes. A client may use a mode to store a
+	specific configuration for buttons, rings and strips and use the
+	wl_tablet_pad_group.mode_switch event to toggle between these
+	configurations. Mode indices start at 0.
+
+	Switching modes is compositor-dependent. See the
+	wp_tablet_pad_group.mode_switch event for more details.
+
+	This event is sent in the initial burst of events before the
+	wp_tablet_pad_group.done event. This event is only sent when more than
+	more than one mode is available.
+      </description>
+      <arg name="modes" type="uint" summary="the number of modes"/>
+    </event>
+
+    <event name="done">
+      <description summary="tablet group description events sequence complete">
+	This event is sent immediately to signal the end of the initial
+	burst of descriptive events. A client may consider the static
+	description of the tablet to be complete and finalize initialization
+	of the tablet group.
+      </description>
+    </event>
+
+    <event name="mode_switch">
+      <description summary="mode switch event">
+	Notification that the mode was switched.
+
+	A mode applies to all buttons, rings, strips and dials in a group
+	simultaneously, but a client is not required to assign different actions
+	for each mode. For example, a client may have mode-specific button
+	mappings but map the ring to vertical scrolling in all modes. Mode
+	indices start at 0.
+
+	Switching modes is compositor-dependent. The compositor may provide
+	visual cues to the user about the mode, e.g. by toggling LEDs on
+	the tablet device. Mode-switching may be software-controlled or
+	controlled by one or more physical buttons. For example, on a Wacom
+	Intuos Pro, the button inside the ring may be assigned to switch
+	between modes.
+
+	The compositor will also send this event after wp_tablet_pad.enter on
+	each group in order to notify of the current mode. Groups that only
+	feature one mode will use mode=0 when emitting this event.
+
+	If a button action in the new mode differs from the action in the
+	previous mode, the client should immediately issue a
+	wp_tablet_pad.set_feedback request for each changed button.
+
+	If a ring, strip or dial action in the new mode differs from the action
+	in the previous mode, the client should immediately issue a
+	wp_tablet_ring.set_feedback, wp_tablet_strip.set_feedback or
+	wp_tablet_dial.set_feedback request for each changed ring, strip or dial.
+      </description>
+      <arg name="time" type="uint" summary="the time of the event with millisecond granularity"/>
+      <arg name="serial" type="uint"/>
+      <arg name="mode" type="uint" summary="the new mode of the pad"/>
+    </event>
+
+    <!-- Version 2 additions -->
+
+    <event name="dial" since="2">
+      <description summary="dial announced">
+	Sent on wp_tablet_pad initialization to announce available dials.
+	One event is sent for each dial available on this pad group.
+
+	This event is sent in the initial burst of events before the
+	wp_tablet_pad_group.done event.
+      </description>
+      <arg name="dial" type="new_id" interface="zwp_tablet_pad_dial_v2"/>
+    </event>
+  </interface>
+
+  <interface name="zwp_tablet_pad_v2" version="2">
+    <description summary="a set of buttons, rings, strips and dials">
+      A pad device is a set of buttons, rings, strips and dials
+      usually physically present on the tablet device itself. Some
+      exceptions exist where the pad device is physically detached, e.g. the
+      Wacom ExpressKey Remote.
+
+      Pad devices have no axes that control the cursor and are generally
+      auxiliary devices to the tool devices used on the tablet surface.
+
+      A pad device has a number of static characteristics, e.g. the number
+      of rings. These capabilities are sent in an event sequence after the
+      wp_tablet_seat.pad_added event before any actual events from this pad.
+      This initial event sequence is terminated by a wp_tablet_pad.done
+      event.
+
+      All pad features (buttons, rings, strips and dials) are logically divided into
+      groups and all pads have at least one group. The available groups are
+      notified through the wp_tablet_pad.group event; the compositor will
+      emit one event per group before emitting wp_tablet_pad.done.
+
+      Groups may have multiple modes. Modes allow clients to map multiple
+      actions to a single pad feature. Only one mode can be active per group,
+      although different groups may have different active modes.
+    </description>
+
+    <request name="set_feedback">
+      <description summary="set compositor feedback">
+	Requests the compositor to use the provided feedback string
+	associated with this button. This request should be issued immediately
+	after a wp_tablet_pad_group.mode_switch event from the corresponding
+	group is received, or whenever a button is mapped to a different
+	action. See wp_tablet_pad_group.mode_switch for more details.
+
+	Clients are encouraged to provide context-aware descriptions for
+	the actions associated with each button, and compositors may use
+	this information to offer visual feedback on the button layout
+	(e.g. on-screen displays).
+
+	Button indices start at 0. Setting the feedback string on a button
+	that is reserved by the compositor (i.e. not belonging to any
+	wp_tablet_pad_group) does not generate an error but the compositor
+	is free to ignore the request.
+
+	The provided string 'description' is a UTF-8 encoded string to be
+	associated with this ring, and is considered user-visible; general
+	internationalization rules apply.
+
+	The serial argument will be that of the last
+	wp_tablet_pad_group.mode_switch event received for the group of this
+	button. Requests providing other serials than the most recent one will
+	be ignored.
+      </description>
+      <arg name="button" type="uint" summary="button index"/>
+      <arg name="description" type="string" summary="button description"/>
+      <arg name="serial" type="uint" summary="serial of the mode switch event"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the pad object">
+	Destroy the wp_tablet_pad object. Objects created from this object
+	are unaffected and should be destroyed separately.
+      </description>
+    </request>
+
+    <event name="group">
+      <description summary="group announced">
+	Sent on wp_tablet_pad initialization to announce available groups.
+	One event is sent for each pad group available.
+
+	This event is sent in the initial burst of events before the
+	wp_tablet_pad.done event. At least one group will be announced.
+      </description>
+      <arg name="pad_group" type="new_id" interface="zwp_tablet_pad_group_v2"/>
+    </event>
+
+    <event name="path">
+      <description summary="path to the device">
+	A system-specific device path that indicates which device is behind
+	this wp_tablet_pad. This information may be used to gather additional
+	information about the device, e.g. through libwacom.
+
+	The format of the path is unspecified, it may be a device node, a
+	sysfs path, or some other identifier. It is up to the client to
+	identify the string provided.
+
+	This event is sent in the initial burst of events before the
+	wp_tablet_pad.done event.
+      </description>
+      <arg name="path" type="string" summary="path to local device"/>
+    </event>
+
+    <event name="buttons">
+      <description summary="buttons announced">
+	Sent on wp_tablet_pad initialization to announce the available
+	buttons.
+
+	This event is sent in the initial burst of events before the
+	wp_tablet_pad.done event. This event is only sent when at least one
+	button is available.
+      </description>
+      <arg name="buttons" type="uint" summary="the number of buttons"/>
+    </event>
+
+    <event name="done">
+      <description summary="pad description event sequence complete">
+	This event signals the end of the initial burst of descriptive
+	events. A client may consider the static description of the pad to
+	be complete and finalize initialization of the pad.
+      </description>
+    </event>
+
+    <enum name="button_state">
+      <description summary="physical button state">
+	Describes the physical state of a button that caused the button
+	event.
+      </description>
+      <entry name="released" value="0" summary="the button is not pressed"/>
+      <entry name="pressed" value="1" summary="the button is pressed"/>
+    </enum>
+
+    <event name="button">
+      <description summary="physical button state">
+	Sent whenever the physical state of a button changes.
+      </description>
+      <arg name="time" type="uint" summary="the time of the event with millisecond granularity"/>
+      <arg name="button" type="uint" summary="the index of the button that changed state"/>
+      <arg name="state" type="uint" enum="button_state"/>
+    </event>
+
+    <event name="enter">
+      <description summary="enter event">
+	Notification that this pad is focused on the specified surface.
+      </description>
+      <arg name="serial" type="uint" summary="serial number of the enter event"/>
+      <arg name="tablet" type="object" interface="zwp_tablet_v2" summary="the tablet the pad is attached to"/>
+      <arg name="surface" type="object" interface="wl_surface" summary="surface the pad is focused on"/>
+    </event>
+
+    <event name="leave">
+      <description summary="leave event">
+	Notification that this pad is no longer focused on the specified
+	surface.
+      </description>
+      <arg name="serial" type="uint" summary="serial number of the leave event"/>
+      <arg name="surface" type="object" interface="wl_surface" summary="surface the pad is no longer focused on"/>
+    </event>
+
+    <event name="removed">
+      <description summary="pad removed event">
+	Sent when the pad has been removed from the system. When a tablet
+	is removed its pad(s) will be removed too.
+
+	When this event is received, the client must destroy all rings, strips
+	and groups that were offered by this pad, and issue wp_tablet_pad.destroy
+	the pad itself.
+      </description>
+    </event>
+  </interface>
+
+  <interface name="zwp_tablet_pad_dial_v2" version="2">
+    <description summary="pad dial">
+      A rotary control, e.g. a dial or a wheel.
+
+      Events on a dial are logically grouped by the wl_tablet_pad_dial.frame
+      event.
+    </description>
+
+    <request name="set_feedback">
+      <description summary="set compositor feedback">
+	Requests the compositor to use the provided feedback string
+	associated with this dial. This request should be issued immediately
+	after a wp_tablet_pad_group.mode_switch event from the corresponding
+	group is received, or whenever the dial is mapped to a different
+	action. See wp_tablet_pad_group.mode_switch for more details.
+
+	Clients are encouraged to provide context-aware descriptions for
+	the actions associated with the dial, and compositors may use this
+	information to offer visual feedback about the button layout
+	(eg. on-screen displays).
+
+	The provided string 'description' is a UTF-8 encoded string to be
+	associated with this ring, and is considered user-visible; general
+	internationalization rules apply.
+
+	The serial argument will be that of the last
+	wp_tablet_pad_group.mode_switch event received for the group of this
+	dial. Requests providing other serials than the most recent one will be
+	ignored.
+      </description>
+      <arg name="description" type="string" summary="dial description"/>
+      <arg name="serial" type="uint" summary="serial of the mode switch event"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the dial object">
+	This destroys the client's resource for this dial object.
+      </description>
+    </request>
+
+    <event name="delta">
+      <description summary="delta movement">
+	Sent whenever the position on a dial changes.
+
+	This event carries the wheel delta as multiples or fractions
+	of 120 with each multiple of 120 representing one logical wheel detent.
+	For example, an axis_value120 of 30 is one quarter of
+	a logical wheel step in the positive direction, a value120 of
+	-240 are two logical wheel steps in the negative direction within the
+	same hardware event. See the wl_pointer.axis_value120 for more details.
+
+	The value120 must not be zero.
+      </description>
+      <arg name="value120" type="int" summary="rotation distance as fraction of 120"/>
+    </event>
+
+    <event name="frame">
+      <description summary="end of a dial event sequence">
+	Indicates the end of a set of events that represent one logical
+	hardware dial event. A client is expected to accumulate the data
+	in all events within the frame before proceeding.
+
+	All wp_tablet_pad_dial events before a wp_tablet_pad_dial.frame event belong
+	logically together.
+
+	A wp_tablet_pad_dial.frame event is sent for every logical event
+	group, even if the group only contains a single wp_tablet_pad_dial
+	event. Specifically, a client may get a sequence: delta, frame,
+	delta, frame, etc.
+      </description>
+      <arg name="time" type="uint" summary="timestamp with millisecond granularity"/>
+    </event>
+  </interface>
+</protocol>
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 08cbb8c6979..45c768f7917 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -199,6 +199,12 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         process_wayland.wp_fractional_scale_manager_v1 =
             wl_registry_bind(registry, id, &wp_fractional_scale_manager_v1_interface, 1);
     }
+    else if (strcmp(interface, "wp_cursor_shape_manager_v1") == 0)
+    {
+        process_wayland.wp_cursor_shape_manager_v1 =
+            wl_registry_bind(registry, id, &wp_cursor_shape_manager_v1_interface,
+                             version < 2 ? version : 2);
+    }
 }
 
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 257735dc909..ebd09d87b2a 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -29,11 +29,81 @@
 #include <math.h>
 #include <stdlib.h>
 
+#define OEMRESOURCE
+
 #include "waylanddrv.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+struct system_cursors
+{
+    WORD id;
+    enum wp_cursor_shape_device_v1_shape shape;
+};
+
+static const struct system_cursors user32_cursors[] =
+{
+    {OCR_NORMAL,      WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_DEFAULT},
+    {OCR_IBEAM,       WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_TEXT},
+    {OCR_WAIT,        WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_WAIT},
+    {OCR_CROSS,       WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_CROSSHAIR},
+    {OCR_SIZE,        WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ALL_RESIZE},
+    {OCR_SIZENWSE,    WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NWSE_RESIZE},
+    {OCR_SIZENESW,    WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NESW_RESIZE},
+    {OCR_SIZEWE,      WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_EW_RESIZE},
+    {OCR_SIZENS,      WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NS_RESIZE},
+    {OCR_SIZEALL,     WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ALL_RESIZE},
+    {OCR_NO,          WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NOT_ALLOWED},
+    {OCR_HAND,        WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_POINTER},
+    {OCR_APPSTARTING, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_PROGRESS},
+    {OCR_HELP,        WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_HELP},
+    {OCR_RDR2DIM,     WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ALL_SCROLL},
+    {0}
+};
+
+static const struct system_cursors comctl32_cursors[] =
+{
+    {102, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_MOVE},
+    {104, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_COPY},
+    {105, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_DEFAULT},
+    {106, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_COL_RESIZE},
+    {107, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_COL_RESIZE},
+    {108, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_POINTER},
+    {135, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ROW_RESIZE},
+    {0}
+};
+
+static const struct system_cursors ole32_cursors[] =
+{
+    {1, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NO_DROP},
+    {2, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_MOVE},
+    {3, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_COPY},
+    {4, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ALIAS},
+    {0}
+};
+
+static const struct system_cursors riched20_cursors[] =
+{
+    {105, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_POINTER},
+    {109, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_COPY},
+    {110, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_MOVE},
+    {111, WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NO_DROP},
+    {0}
+};
+
+static const struct
+{
+    const struct system_cursors *cursors;
+    WCHAR name[16];
+} module_cursors[] =
+{
+    {user32_cursors, {'u','s','e','r','3','2','.','d','l','l',0}},
+    {comctl32_cursors, {'c','o','m','c','t','l','3','2','.','d','l','l',0}},
+    {ole32_cursors, {'o','l','e','3','2','.','d','l','l',0}},
+    {riched20_cursors, {'r','i','c','h','e','d','2','0','.','d','l','l',0}}
+};
+
 static HWND wayland_pointer_get_focused_hwnd(void)
 {
     struct wayland_pointer *pointer = &process_wayland.pointer;
@@ -350,6 +420,11 @@ void wayland_pointer_deinit(void)
         zwp_relative_pointer_v1_destroy(pointer->zwp_relative_pointer_v1);
         pointer->zwp_relative_pointer_v1 = NULL;
     }
+    if (pointer->wp_cursor_shape_device_v1)
+    {
+        wp_cursor_shape_device_v1_destroy(pointer->wp_cursor_shape_device_v1);
+        pointer->wp_cursor_shape_device_v1 = NULL;
+    }
     wl_pointer_release(pointer->wl_pointer);
     pointer->wl_pointer = NULL;
     pointer->focused_hwnd = NULL;
@@ -509,6 +584,27 @@ clear_cursor:
     }
 }
 
+static void wayland_pointer_clear_cursor_surface(void)
+{
+    struct wayland_cursor *cursor = &process_wayland.pointer.cursor;
+
+    if (cursor->wp_viewport)
+    {
+        wp_viewport_destroy(cursor->wp_viewport);
+        cursor->wp_viewport = NULL;
+    }
+    if (cursor->wl_surface)
+    {
+        wl_surface_destroy(cursor->wl_surface);
+        cursor->wl_surface = NULL;
+    }
+    if (cursor->shm_buffer)
+    {
+        wayland_shm_buffer_unref(cursor->shm_buffer);
+        cursor->shm_buffer = NULL;
+    }
+}
+
 static void wayland_pointer_update_cursor_surface(double scale)
 {
     struct wayland_cursor *cursor = &process_wayland.pointer.cursor;
@@ -557,21 +653,7 @@ static void wayland_pointer_update_cursor_surface(double scale)
     return;
 
 clear_cursor:
-    if (cursor->shm_buffer)
-    {
-        wayland_shm_buffer_unref(cursor->shm_buffer);
-        cursor->shm_buffer = NULL;
-    }
-    if (cursor->wp_viewport)
-    {
-        wp_viewport_destroy(cursor->wp_viewport);
-        cursor->wp_viewport = NULL;
-    }
-    if (cursor->wl_surface)
-    {
-        wl_surface_destroy(cursor->wl_surface);
-        cursor->wl_surface = NULL;
-    }
+    wayland_pointer_clear_cursor_surface();
 }
 
 static void reapply_cursor_clipping(void)
@@ -582,6 +664,77 @@ static void reapply_cursor_clipping(void)
     NtUserSetThreadDpiAwarenessContext(context);
 }
 
+static enum wp_cursor_shape_device_v1_shape cursor_shape_from_info(ICONINFOEXW *info,
+                                                                   uint32_t proto_version)
+{
+    const struct system_cursors *cursors;
+    const WCHAR *module;
+    unsigned int i;
+    enum wp_cursor_shape_device_v1_shape shape = 0;
+
+    if (!info->szModName[0]) return 0;
+    if ((module = wcsrchr(info->szModName, '\\'))) module++;
+    else module = info->szModName;
+    for (i = 0; i < ARRAY_SIZE(module_cursors); i++)
+        if (!wcsicmp(module, module_cursors[i].name)) break;
+    if (i == ARRAY_SIZE(module_cursors)) return 0;
+
+    cursors = module_cursors[i].cursors;
+    for (i = 0; cursors[i].id; i++)
+    {
+        if (cursors[i].id == info->wResID)
+        {
+            shape = cursors[i].shape;
+            break;
+        }
+    }
+
+    if (shape >= WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_DND_ASK && proto_version < 2)
+        shape = 0;
+
+    return shape;
+}
+
+static BOOL wayland_pointer_set_cursor_shape(HCURSOR hcursor)
+{
+    struct wayland_pointer *pointer = &process_wayland.pointer;
+    ICONINFOEXW info = {0};
+    enum wp_cursor_shape_device_v1_shape shape = 0;
+    uint32_t proto_version;
+
+    if (!option_use_system_cursors) return FALSE;
+    if (!process_wayland.wp_cursor_shape_manager_v1) return FALSE;
+    if (!hcursor) return FALSE;
+    if (!get_icon_info(hcursor, &info)) return FALSE;
+    proto_version = wp_cursor_shape_manager_v1_get_version(
+        process_wayland.wp_cursor_shape_manager_v1);
+    if (!(shape = cursor_shape_from_info(&info, proto_version))) return FALSE;
+
+    if (!pointer->wp_cursor_shape_device_v1)
+    {
+        pointer->wp_cursor_shape_device_v1 =
+            wp_cursor_shape_manager_v1_get_pointer(
+                process_wayland.wp_cursor_shape_manager_v1, pointer->wl_pointer);
+        if (!pointer->wp_cursor_shape_device_v1) return FALSE;
+    }
+
+    wp_cursor_shape_device_v1_set_shape(pointer->wp_cursor_shape_device_v1,
+                                        pointer->enter_serial, shape);
+
+    return TRUE;
+}
+
+static void wayland_pointer_clear_cursor_shape(void)
+{
+    struct wayland_pointer *pointer = &process_wayland.pointer;
+
+    if (pointer->wp_cursor_shape_device_v1)
+    {
+        wp_cursor_shape_device_v1_destroy(pointer->wp_cursor_shape_device_v1);
+        pointer->wp_cursor_shape_device_v1 = NULL;
+    }
+}
+
 static void wayland_set_cursor(HWND hwnd, HCURSOR hcursor, BOOL use_hcursor)
 {
     struct wayland_pointer *pointer = &process_wayland.pointer;
@@ -611,13 +764,22 @@ static void wayland_set_cursor(HWND hwnd, HCURSOR hcursor, BOOL use_hcursor)
     pthread_mutex_lock(&pointer->mutex);
     if (pointer->focused_hwnd == hwnd)
     {
-        if (use_hcursor) wayland_pointer_update_cursor_buffer(hcursor, scale);
-        wayland_pointer_update_cursor_surface(scale);
-        wl_pointer_set_cursor(pointer->wl_pointer,
-                              pointer->enter_serial,
-                              pointer->cursor.wl_surface,
-                              pointer->cursor.hotspot_x,
-                              pointer->cursor.hotspot_y);
+        if ((!use_hcursor && pointer->wp_cursor_shape_device_v1) ||
+            (use_hcursor && hcursor && wayland_pointer_set_cursor_shape(hcursor)))
+        {
+            wayland_pointer_clear_cursor_surface();
+        }
+        else
+        {
+            if (use_hcursor) wayland_pointer_update_cursor_buffer(hcursor, scale);
+            wayland_pointer_update_cursor_surface(scale);
+            wl_pointer_set_cursor(pointer->wl_pointer,
+                                  pointer->enter_serial,
+                                  pointer->cursor.wl_surface,
+                                  pointer->cursor.hotspot_x,
+                                  pointer->cursor.hotspot_y);
+            wayland_pointer_clear_cursor_shape();
+        }
         wl_display_flush(process_wayland.wl_display);
         reapply_clip = TRUE;
     }
@@ -700,6 +862,7 @@ static void wayland_pointer_update_constraint(struct wl_surface *wl_surface,
 {
     struct wayland_pointer *pointer = &process_wayland.pointer;
     BOOL needs_relative, needs_lock, needs_confine;
+    BOOL is_visible;
     static unsigned int once;
 
     if (!process_wayland.zwp_pointer_constraints_v1)
@@ -709,11 +872,12 @@ static void wayland_pointer_update_constraint(struct wl_surface *wl_surface,
         return;
     }
 
-    needs_lock = wl_surface && (((confine_rect || covers_vscreen) &&
-                 !pointer->cursor.wl_surface) || force_lock) &&
+    is_visible = pointer->cursor.wl_surface || pointer->wp_cursor_shape_device_v1;
+    needs_lock = wl_surface &&
+                 (((confine_rect || covers_vscreen) && !is_visible) || force_lock) &&
                  pointer->wl_pointer;
-    needs_confine = wl_surface && confine_rect && pointer->cursor.wl_surface &&
-                 !force_lock && pointer->wl_pointer;
+    needs_confine = wl_surface && confine_rect && is_visible && !force_lock &&
+                    pointer->wl_pointer;
 
     if (!needs_confine && pointer->zwp_confined_pointer_v1)
     {
@@ -795,8 +959,7 @@ static void wayland_pointer_update_constraint(struct wl_surface *wl_surface,
         return;
     }
 
-    needs_relative = !pointer->cursor.wl_surface &&
-                     pointer->constraint_hwnd &&
+    needs_relative = !is_visible && pointer->constraint_hwnd &&
                      pointer->constraint_hwnd == pointer->focused_hwnd;
 
     if (needs_relative && !pointer->zwp_relative_pointer_v1)
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 5e04b410202..0848d683ef7 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -38,6 +38,8 @@
 #include "wlr-data-control-unstable-v1-client-protocol.h"
 #include "xdg-toplevel-icon-v1-client-protocol.h"
 #include "fractional-scale-v1-client-protocol.h"
+#include "tablet-v2-client-protocol.h"
+#include "cursor-shape-v1-client-protocol.h"
 
 #include "windef.h"
 #include "winbase.h"
@@ -57,6 +59,7 @@
 
 extern char *process_name;
 extern struct wayland process_wayland;
+extern BOOL option_use_system_cursors;
 
 /**********************************************************************
  *          Definitions for wayland types
@@ -107,6 +110,7 @@ struct wayland_pointer
     struct zwp_confined_pointer_v1 *zwp_confined_pointer_v1;
     struct zwp_locked_pointer_v1 *zwp_locked_pointer_v1;
     struct zwp_relative_pointer_v1 *zwp_relative_pointer_v1;
+    struct wp_cursor_shape_device_v1 *wp_cursor_shape_device_v1;
     HWND focused_hwnd;
     HWND constraint_hwnd;
     BOOL pending_warp;
@@ -174,6 +178,7 @@ struct wayland
     struct zwlr_data_control_manager_v1 *zwlr_data_control_manager_v1;
     struct wl_data_device_manager *wl_data_device_manager;
     struct xdg_toplevel_icon_manager_v1 *xdg_toplevel_icon_manager_v1;
+    struct wp_cursor_shape_manager_v1 *wp_cursor_shape_manager_v1;
     struct wayland_seat seat;
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 5486cc934ef..60d2fc70ff9 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -31,7 +31,11 @@
 
 #include "waylanddrv.h"
 
+#define IS_OPTION_TRUE(ch) \
+    ((ch) == 'y' || (ch) == 'Y' || (ch) == 't' || (ch) == 'T' || (ch) == '1')
+
 char *process_name = NULL;
+BOOL option_use_system_cursors = TRUE;
 
 static const struct user_driver_funcs waylanddrv_funcs =
 {
@@ -56,6 +60,147 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pwine_get_wgl_driver = WAYLAND_wine_get_wgl_driver,
 };
 
+static inline void ascii_to_unicode(WCHAR *dst, const char *src, size_t len)
+{
+    while (len--) *dst++ = (unsigned char)*src++;
+}
+
+static inline UINT asciiz_to_unicode(WCHAR *dst, const char *src)
+{
+    WCHAR *p = dst;
+    while ((*p++ = *src++));
+    return (p - dst) * sizeof(WCHAR);
+}
+
+static HKEY reg_open_key(HKEY root, const WCHAR *name, ULONG name_len)
+{
+    UNICODE_STRING nameW = {name_len, name_len, (WCHAR *)name};
+    OBJECT_ATTRIBUTES attr;
+    HANDLE ret;
+
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = root;
+    attr.ObjectName = &nameW;
+    attr.Attributes = 0;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    return NtOpenKeyEx(&ret, MAXIMUM_ALLOWED, &attr, 0) ? 0 : ret;
+}
+
+static HKEY open_hkcu_key(const char *name)
+{
+    WCHAR bufferW[256];
+    static HKEY hkcu;
+
+    if (!hkcu)
+    {
+        char buffer[256];
+        DWORD_PTR sid_data[(sizeof(TOKEN_USER) + SECURITY_MAX_SID_SIZE) / sizeof(DWORD_PTR)];
+        DWORD i, len = sizeof(sid_data);
+        SID *sid;
+
+        if (NtQueryInformationToken(GetCurrentThreadEffectiveToken(), TokenUser, sid_data, len, &len))
+            return 0;
+
+        sid = ((TOKEN_USER *)sid_data)->User.Sid;
+        len = sprintf(buffer, "\\Registry\\User\\S-%u-%lu", sid->Revision,
+               (unsigned long) MAKELONG(MAKEWORD(sid->IdentifierAuthority.Value[5],
+                                        sid->IdentifierAuthority.Value[4]),
+                               MAKEWORD(sid->IdentifierAuthority.Value[3],
+                                        sid->IdentifierAuthority.Value[2])));
+        for (i = 0; i < sid->SubAuthorityCount; i++)
+            len += sprintf(buffer + len, "-%lu", (unsigned long)sid->SubAuthority[i]);
+
+        ascii_to_unicode(bufferW, buffer, len);
+        hkcu = reg_open_key(NULL, bufferW, len * sizeof(WCHAR));
+    }
+
+    return reg_open_key(hkcu, bufferW, asciiz_to_unicode(bufferW, name) - sizeof(WCHAR));
+}
+
+static ULONG query_reg_value(HKEY hkey, const WCHAR *name,
+                             KEY_VALUE_PARTIAL_INFORMATION *info, ULONG size)
+{
+    unsigned int name_size = name ? lstrlenW(name) * sizeof(WCHAR) : 0;
+    UNICODE_STRING nameW = {name_size, name_size, (WCHAR *)name};
+
+    if (NtQueryValueKey(hkey, &nameW, KeyValuePartialInformation,
+                        info, size, &size))
+        return 0;
+
+    return size - FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data);
+}
+
+static inline DWORD get_config_key(HKEY defkey, HKEY appkey, const char *name,
+                                   WCHAR *buffer, DWORD size)
+{
+    WCHAR nameW[128];
+    char buf[2048];
+    KEY_VALUE_PARTIAL_INFORMATION *info = (void *)buf;
+
+    asciiz_to_unicode(nameW, name);
+
+    if (appkey && query_reg_value(appkey, nameW, info, sizeof(buf)))
+    {
+        size = min(info->DataLength, size - sizeof(WCHAR));
+        memcpy(buffer, info->Data, size);
+        buffer[size / sizeof(WCHAR)] = 0;
+        return 0;
+    }
+
+    if (defkey && query_reg_value(defkey, nameW, info, sizeof(buf)))
+    {
+        size = min(info->DataLength, size - sizeof(WCHAR));
+        memcpy(buffer, info->Data, size);
+        buffer[size / sizeof(WCHAR)] = 0;
+        return 0;
+    }
+
+    return ERROR_FILE_NOT_FOUND;
+}
+
+static void wayland_init_options(void)
+{
+    static const WCHAR waylanddriverW[] = {'\\','W','a','y','l','a','n','d',' ','D','r','i','v','e','r',0};
+    WCHAR buffer[MAX_PATH+16], *p, *appname;
+    HKEY hkey, appkey = 0;
+    DWORD len;
+
+    /* @@ Wine registry key: HKCU\Software\Wine\Wayland Driver */
+    hkey = open_hkcu_key("Software\\Wine\\Wayland Driver");
+
+    /* open the app-specific key */
+    appname = NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer;
+    if ((p = wcsrchr(appname, '/'))) appname = p + 1;
+    if ((p = wcsrchr(appname, '\\'))) appname = p + 1;
+    len = lstrlenW(appname);
+
+    if (len && len < MAX_PATH)
+    {
+        HKEY tmpkey;
+        int i;
+        for (i = 0; appname[i]; i++) buffer[i] = RtlDowncaseUnicodeChar(appname[i]);
+        buffer[i] = 0;
+        appname = buffer;
+        if ((process_name = malloc(len * 3 + 1)))
+            ntdll_wcstoumbs(appname, len + 1, process_name, len * 3 + 1, FALSE);
+        memcpy(appname + i, waylanddriverW, sizeof(waylanddriverW));
+        /* @@ Wine registry key: HKCU\Software\Wine\AppDefaults\app.exe\Wayland Driver */
+        if ((tmpkey = open_hkcu_key("Software\\Wine\\AppDefaults")))
+        {
+            appkey = reg_open_key(tmpkey, appname, lstrlenW(appname) * sizeof(WCHAR));
+            NtClose(tmpkey);
+        }
+    }
+
+    if (!get_config_key(hkey, appkey, "UseSystemCursors", buffer, sizeof(buffer)))
+        option_use_system_cursors = IS_OPTION_TRUE(buffer[0]);
+
+    NtClose(appkey);
+    NtClose(hkey);
+}
+
 static void wayland_init_process_name(void)
 {
     WCHAR *p, *appname;
@@ -91,6 +236,7 @@ static NTSTATUS waylanddrv_unix_init(void *arg)
     __wine_set_user_driver(&waylanddrv_funcs, WINE_GDI_DRIVER_VERSION);
 
     wayland_init_process_name();
+    wayland_init_options();
 
     if (!wayland_process_init()) goto err;
 
-- 
2.49.0

From 9426d6d343ba63e62e58410d663a7c260774ae43 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Wed, 7 May 2025 08:37:02 -0400
Subject: [PATCH 31/78] Avoid long types on the Unix side.

Co-Authored-By: Alexandre Julliard <1130500+julliard@users.noreply.github.com>
---
 dlls/ntdll/unix/signal_arm.c           | 10 +++++-----
 dlls/ntdll/unix/signal_i386.c          | 20 ++++++++++----------
 dlls/winewayland.drv/waylanddrv_main.c |  6 +++---
 include/basetsd.h                      |  4 ++--
 include/ntdef.h                        |  2 +-
 include/verrsrc.h                      |  2 +-
 include/windef.h                       |  4 ++--
 include/winerror.h                     |  2 +-
 include/winnt.h                        |  4 ++--
 9 files changed, 27 insertions(+), 27 deletions(-)

diff --git a/dlls/ntdll/unix/signal_arm.c b/dlls/ntdll/unix/signal_arm.c
index c8b67929aff..7fcd68d24d9 100644
--- a/dlls/ntdll/unix/signal_arm.c
+++ b/dlls/ntdll/unix/signal_arm.c
@@ -785,18 +785,18 @@ static BOOL handle_syscall_fault( ucontext_t *context, EXCEPTION_RECORD *rec )
 
     if (!is_inside_syscall( context )) return FALSE;
 
-    TRACE( "code=%lx flags=%lx addr=%p pc=%08lx\n",
+    TRACE( "code=%x flags=%x addr=%p pc=%08x\n",
            rec->ExceptionCode, rec->ExceptionFlags, rec->ExceptionAddress, (DWORD)PC_sig(context) );
     for (i = 0; i < rec->NumberParameters; i++)
         TRACE( " info[%d]=%08lx\n", i, rec->ExceptionInformation[i] );
 
-    TRACE( " r0=%08lx r1=%08lx r2=%08lx r3=%08lx r4=%08lx r5=%08lx\n",
+    TRACE( " r0=%08x r1=%08x r2=%08x r3=%08x r4=%08x r5=%08x\n",
            (DWORD)REGn_sig(0, context), (DWORD)REGn_sig(1, context), (DWORD)REGn_sig(2, context),
            (DWORD)REGn_sig(3, context), (DWORD)REGn_sig(4, context), (DWORD)REGn_sig(5, context) );
-    TRACE( " r6=%08lx r7=%08lx r8=%08lx r9=%08lx r10=%08lx r11=%08lx\n",
+    TRACE( " r6=%08x r7=%08x r8=%08x r9=%08x r10=%08x r11=%08x\n",
            (DWORD)REGn_sig(6, context), (DWORD)REGn_sig(7, context), (DWORD)REGn_sig(8, context),
            (DWORD)REGn_sig(9, context), (DWORD)REGn_sig(10, context), (DWORD)FP_sig(context) );
-    TRACE( " r12=%08lx sp=%08lx lr=%08lx pc=%08lx cpsr=%08lx\n",
+    TRACE( " r12=%08x sp=%08x lr=%08x pc=%08x cpsr=%08x\n",
            (DWORD)IP_sig(context), (DWORD)SP_sig(context), (DWORD)LR_sig(context),
            (DWORD)PC_sig(context), (DWORD)CPSR_sig(context) );
 
@@ -814,7 +814,7 @@ static BOOL handle_syscall_fault( ucontext_t *context, EXCEPTION_RECORD *rec )
     }
     else
     {
-        TRACE( "returning to user mode ip=%08x ret=%08lx\n", frame->pc, rec->ExceptionCode );
+        TRACE( "returning to user mode ip=%08x ret=%08x\n", frame->pc, rec->ExceptionCode );
         REGn_sig(0, context) = (DWORD)frame;
         REGn_sig(1, context) = rec->ExceptionCode;
         PC_sig(context)      = (DWORD)__wine_syscall_dispatcher_return;
diff --git a/dlls/ntdll/unix/signal_i386.c b/dlls/ntdll/unix/signal_i386.c
index 33958f76ee9..323e2654258 100644
--- a/dlls/ntdll/unix/signal_i386.c
+++ b/dlls/ntdll/unix/signal_i386.c
@@ -1178,16 +1178,16 @@ NTSTATUS WINAPI NtGetContextThread( HANDLE handle, CONTEXT *context )
     }
 
     if (context->ContextFlags & (CONTEXT_INTEGER & ~CONTEXT_i386))
-        TRACE( "%p: eax=%08lx ebx=%08lx ecx=%08lx edx=%08lx esi=%08lx edi=%08lx\n", handle,
+        TRACE( "%p: eax=%08x ebx=%08x ecx=%08x edx=%08x esi=%08x edi=%08x\n", handle,
                context->Eax, context->Ebx, context->Ecx, context->Edx, context->Esi, context->Edi );
     if (context->ContextFlags & (CONTEXT_CONTROL & ~CONTEXT_i386))
-        TRACE( "%p: ebp=%08lx esp=%08lx eip=%08lx cs=%04lx ss=%04lx flags=%08lx\n", handle,
+        TRACE( "%p: ebp=%08x esp=%08x eip=%08x cs=%04x ss=%04x flags=%08x\n", handle,
                context->Ebp, context->Esp, context->Eip, context->SegCs, context->SegSs, context->EFlags );
     if (context->ContextFlags & (CONTEXT_SEGMENTS & ~CONTEXT_i386))
-        TRACE( "%p: ds=%04lx es=%04lx fs=%04lx gs=%04lx\n", handle,
+        TRACE( "%p: ds=%04x es=%04x fs=%04x gs=%04x\n", handle,
                context->SegDs, context->SegEs, context->SegFs, context->SegGs );
     if (context->ContextFlags & (CONTEXT_DEBUG_REGISTERS & ~CONTEXT_i386))
-        TRACE( "%p: dr0=%08lx dr1=%08lx dr2=%08lx dr3=%08lx dr6=%08lx dr7=%08lx\n", handle,
+        TRACE( "%p: dr0=%08x dr1=%08x dr2=%08x dr3=%08x dr6=%08x dr7=%08x\n", handle,
                context->Dr0, context->Dr1, context->Dr2, context->Dr3, context->Dr6, context->Dr7 );
 
     return STATUS_SUCCESS;
@@ -1311,7 +1311,7 @@ static inline BOOL check_invalid_gs( ucontext_t *sigcontext, CONTEXT *context )
         instr++;
         continue;
     case 0x65:  /* %gs: */
-        TRACE( "%04lx/%04x at %p, fixing up\n", context->SegGs, system_gs, instr );
+        TRACE( "%04x/%04x at %p, fixing up\n", context->SegGs, system_gs, instr );
         GS_sig(sigcontext) = system_gs;
         return TRUE;
     default:
@@ -1829,14 +1829,14 @@ static BOOL handle_syscall_fault( ucontext_t *sigcontext, void *stack_ptr,
 
     if (!is_inside_syscall( sigcontext )) return FALSE;
 
-    TRACE( "code=%lx flags=%lx addr=%p ip=%08lx\n",
+    TRACE( "code=%x flags=%x addr=%p ip=%08x\n",
            rec->ExceptionCode, rec->ExceptionFlags, rec->ExceptionAddress, context->Eip );
     for (i = 0; i < rec->NumberParameters; i++)
         TRACE( " info[%d]=%08lx\n", i, rec->ExceptionInformation[i] );
-    TRACE(" eax=%08lx ebx=%08lx ecx=%08lx edx=%08lx esi=%08lx edi=%08lx\n",
+    TRACE(" eax=%08x ebx=%08x ecx=%08x edx=%08x esi=%08x edi=%08x\n",
           context->Eax, context->Ebx, context->Ecx,
           context->Edx, context->Esi, context->Edi );
-    TRACE(" ebp=%08lx esp=%08lx cs=%04lx ds=%04lx es=%04lx fs=%04lx gs=%04lx flags=%08lx\n",
+    TRACE(" ebp=%08x esp=%08x cs=%04x ds=%04x es=%04x fs=%04x gs=%04x flags=%08x\n",
           context->Ebp, context->Esp, context->SegCs, context->SegDs,
           context->SegEs, context->SegFs, context->SegGs, context->EFlags );
 
@@ -1858,10 +1858,10 @@ static BOOL handle_syscall_fault( ucontext_t *sigcontext, void *stack_ptr,
     }
     else
     {
-        WINE_BACKTRACE_LOG( "--- Exception %#lx at %s.\n", rec->ExceptionCode,
+        WINE_BACKTRACE_LOG( "--- Exception %#x at %s.\n", rec->ExceptionCode,
                             wine_debuginfostr_pc( rec->ExceptionAddress ));
 
-        TRACE( "returning to user mode ip=%08x ret=%08lx\n", frame->eip, rec->ExceptionCode );
+        TRACE( "returning to user mode ip=%08x ret=%08x\n", frame->eip, rec->ExceptionCode );
         stack = (UINT *)frame;
         *(--stack) = rec->ExceptionCode;
         *(--stack) = (UINT)frame;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 60d2fc70ff9..640a70be20e 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -104,13 +104,13 @@ static HKEY open_hkcu_key(const char *name)
             return 0;
 
         sid = ((TOKEN_USER *)sid_data)->User.Sid;
-        len = sprintf(buffer, "\\Registry\\User\\S-%u-%lu", sid->Revision,
-               (unsigned long) MAKELONG(MAKEWORD(sid->IdentifierAuthority.Value[5],
+        len = sprintf(buffer, "\\Registry\\User\\S-%u-%u", sid->Revision,
+                      MAKELONG(MAKEWORD(sid->IdentifierAuthority.Value[5],
                                         sid->IdentifierAuthority.Value[4]),
                                MAKEWORD(sid->IdentifierAuthority.Value[3],
                                         sid->IdentifierAuthority.Value[2])));
         for (i = 0; i < sid->SubAuthorityCount; i++)
-            len += sprintf(buffer + len, "-%lu", (unsigned long)sid->SubAuthority[i]);
+            len += sprintf(buffer + len, "-%u", sid->SubAuthority[i]);
 
         ascii_to_unicode(bufferW, buffer, len);
         hkcu = reg_open_key(NULL, bufferW, len * sizeof(WCHAR));
diff --git a/include/basetsd.h b/include/basetsd.h
index 3f1f8557aa4..6eb7656e605 100644
--- a/include/basetsd.h
+++ b/include/basetsd.h
@@ -160,7 +160,7 @@ typedef unsigned int UHALF_PTR, *PUHALF_PTR;
 
 #if !defined(__midl) && !defined(__WIDL__)
 
-#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES)
+#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES) && !defined(WINE_UNIX_LIB)
 
 static inline unsigned long HandleToULong(const void *h)
 {
@@ -206,7 +206,7 @@ static inline int PtrToLong(const void *p)
 }
 
 
-#endif /* !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES) */
+#endif /* !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES) && !defined(WINE_UNIX_LIB) */
 
 static inline void *ULongToHandle(ULONG32 ul)
 {
diff --git a/include/ntdef.h b/include/ntdef.h
index e840bd3f9fe..8f7e8fae826 100644
--- a/include/ntdef.h
+++ b/include/ntdef.h
@@ -55,7 +55,7 @@ typedef enum _WAIT_TYPE {
 #define BASETYPES
 typedef unsigned char UCHAR, *PUCHAR;
 typedef unsigned short USHORT, *PUSHORT;
-#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES)
+#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES) && !defined(WINE_UNIX_LIB)
 typedef unsigned long ULONG, *PULONG;
 #else
 typedef unsigned int ULONG, *PULONG;
diff --git a/include/verrsrc.h b/include/verrsrc.h
index e13165a7d2e..0b9897a5ed1 100644
--- a/include/verrsrc.h
+++ b/include/verrsrc.h
@@ -22,7 +22,7 @@
 
 /* Macro to deal with LP64 <=> LLP64 differences in numeric constants with 'l' modifier */
 #ifndef __MSABI_LONG
-#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES)
+#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES) && !defined(WINE_UNIX_LIB)
 #  define __MSABI_LONG(x)         x ## l
 # else
 #  define __MSABI_LONG(x)         x
diff --git a/include/windef.h b/include/windef.h
index 0a6d308b837..a88e43f5e3f 100644
--- a/include/windef.h
+++ b/include/windef.h
@@ -210,7 +210,7 @@ extern "C" {
 #define BASETYPES
 typedef unsigned char UCHAR, *PUCHAR;
 typedef unsigned short USHORT, *PUSHORT;
-#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES)
+#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES) && !defined(WINE_UNIX_LIB)
 typedef unsigned long ULONG, *PULONG;
 #else
 typedef unsigned int ULONG, *PULONG;
@@ -226,7 +226,7 @@ typedef int             INT,        *PINT,     *LPINT;
 typedef unsigned int    UINT,       *PUINT;
 typedef float           FLOAT,      *PFLOAT;
 typedef char                        *PSZ;
-#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES)
+#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES) && !defined(WINE_UNIX_LIB)
 typedef long                                   *LPLONG;
 typedef unsigned long   DWORD,      *PDWORD,   *LPDWORD;
 #else
diff --git a/include/winerror.h b/include/winerror.h
index 8ef582d2c69..57fede1ab6e 100644
--- a/include/winerror.h
+++ b/include/winerror.h
@@ -199,7 +199,7 @@
 #define __HRESULT_FROM_WIN32(x)   ((HRESULT)(x) > 0 ? ((HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000)) : (HRESULT)(x) )
 #ifndef _HRESULT_DEFINED
 #define _HRESULT_DEFINED
-#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES)
+#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES) && !defined(WINE_UNIX_LIB)
 typedef long HRESULT;
 #else
 typedef int HRESULT;
diff --git a/include/winnt.h b/include/winnt.h
index a361582045a..7e6f8fcc684 100644
--- a/include/winnt.h
+++ b/include/winnt.h
@@ -479,7 +479,7 @@ typedef VOID           *PVOID64;
 typedef BYTE            BOOLEAN,    *PBOOLEAN;
 typedef char            CHAR,       *PCHAR;
 typedef short           SHORT,      *PSHORT;
-#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES)
+#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES) && !defined(WINE_UNIX_LIB)
 typedef long            LONG,       *PLONG;
 #else
 typedef int             LONG,       *PLONG;
@@ -617,7 +617,7 @@ typedef DWORD FLONG;
 
 /* Macro to deal with LP64 <=> LLP64 differences in numeric constants with 'l' modifier */
 #ifndef __MSABI_LONG
-#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES)
+#if !defined(__LP64__) && !defined(WINE_NO_LONG_TYPES) && !defined(WINE_UNIX_LIB)
 #  define __MSABI_LONG(x)         x ## l
 # else
 #  define __MSABI_LONG(x)         x
-- 
2.49.0

From 79a8b3ee6a2ddb4cd4e5da51266d43c77501949b Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Fri, 9 May 2025 08:32:12 -0400
Subject: [PATCH 33/78] winewayland: ensure egl_display is not
 EGL_BAD_PARAMETER

---
 dlls/winewayland.drv/opengl.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 36989b9c745..0d7bf00ea0f 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -1383,7 +1383,7 @@ static void init_opengl(void)
     egl_display = p_eglGetPlatformDisplay(EGL_PLATFORM_WAYLAND_KHR,
                                           process_wayland.wl_display,
                                           NULL);
-    if (egl_display == EGL_NO_DISPLAY)
+    if (egl_display == EGL_NO_DISPLAY || egl_display == (void *)EGL_BAD_PARAMETER)
     {
         ERR("Failed to get EGLDisplay\n");
         goto err;
-- 
2.49.0

From 872e570653759f42c73834e719caee2588943f69 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Fri, 9 May 2025 08:38:26 -0400
Subject: [PATCH 34/78] Add amdxc implementation

---
 .gitignore                        |   1 +
 configure.ac                      |   1 +
 dlls/amdxc64/Makefile.in          |  10 +
 dlls/amdxc64/amdxc64.spec         | 315 +++++++++++++++++++++++++++++
 dlls/amdxc64/amdxc_interfaces.idl |  96 +++++++++
 dlls/amdxc64/dxvk_interfaces.idl  | 153 ++++++++++++++
 dlls/amdxc64/main.c               | 317 ++++++++++++++++++++++++++++++
 7 files changed, 893 insertions(+)
 create mode 100644 dlls/amdxc64/Makefile.in
 create mode 100644 dlls/amdxc64/amdxc64.spec
 create mode 100644 dlls/amdxc64/amdxc_interfaces.idl
 create mode 100644 dlls/amdxc64/dxvk_interfaces.idl
 create mode 100644 dlls/amdxc64/main.c

diff --git a/configure.ac b/configure.ac
index 9acc7ce2845..dff8f27cedc 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2456,6 +2456,7 @@ WINE_CONFIG_MAKEFILE(dlls/advpack)
 WINE_CONFIG_MAKEFILE(dlls/advpack/tests)
 WINE_CONFIG_MAKEFILE(dlls/amsi)
 WINE_CONFIG_MAKEFILE(dlls/amd_ags_x64)
+WINE_CONFIG_MAKEFILE(dlls/amdxc64)
 WINE_CONFIG_MAKEFILE(dlls/amstream)
 WINE_CONFIG_MAKEFILE(dlls/amstream/tests)
 WINE_CONFIG_MAKEFILE(dlls/apisetschema)
diff --git a/dlls/amdxc64/Makefile.in b/dlls/amdxc64/Makefile.in
new file mode 100644
index 00000000000..999a7d043e1
--- /dev/null
+++ b/dlls/amdxc64/Makefile.in
@@ -0,0 +1,10 @@
+MODULE = amdxc64.dll
+IMPORTS = version vulkan-1 user32 gdi32
+IMPORTLIB = amdxc64
+
+EXTRADLLFLAGS = -mno-cygwin
+
+SOURCES = \
+	main.c \
+	dxvk_interfaces.idl \
+	amdxc_interfaces.idl \
diff --git a/dlls/amdxc64/amdxc64.spec b/dlls/amdxc64/amdxc64.spec
new file mode 100644
index 00000000000..2daa1ddbc94
--- /dev/null
+++ b/dlls/amdxc64/amdxc64.spec
@@ -0,0 +1,315 @@
+1 stub ??0?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_IR_MODE_SELECTOR@@@detail@archive@boost@@QEAA@XZ
+2 stub ??0?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_MINIMIZE_VGPRS_STRATEGY@@@detail@archive@boost@@QEAA@XZ
+3 stub ??0?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_NPI_DISABLE@@@detail@archive@boost@@QEAA@XZ
+4 stub ??0?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_THREAD_LATENCY_STRATEGY@@@detail@archive@boost@@QEAA@XZ
+5 stub ??0?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_USE_MORE_D16_SELECTOR@@@detail@archive@boost@@QEAA@XZ
+6 stub ??0?$oserializer@Vsc_xml_oarchive@@T_SC_COMPILE_FLAGS@@@detail@archive@boost@@QEAA@XZ
+7 stub ??0?$oserializer@Vsc_xml_oarchive@@T_SC_LAUNCH_MODE_FLAGS@@@detail@archive@boost@@QEAA@XZ
+8 stub ??0?$oserializer@Vsc_xml_oarchive@@T_SC_SI_GLC_CONTROL@@@detail@archive@boost@@QEAA@XZ
+9 stub ??0?$oserializer@Vsc_xml_oarchive@@T_SC_SI_SLC_CONTROL@@@detail@archive@boost@@QEAA@XZ
+10 stub ??0?$oserializer@Vsc_xml_oarchive@@USC_INPUT@@@detail@archive@boost@@QEAA@XZ
+11 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY@serialization@boost@@@detail@archive@boost@@QEAA@XZ
+12 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_ATOMIC@@@detail@archive@boost@@QEAA@XZ
+13 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_CONTROL@@@detail@archive@boost@@QEAA@XZ
+14 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_READ@@@detail@archive@boost@@QEAA@XZ
+15 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_WRITE@@@detail@archive@boost@@QEAA@XZ
+16 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_CBCONSTVALUES@@@detail@archive@boost@@QEAA@XZ
+17 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_CBRCONSTVALUES@@@detail@archive@boost@@QEAA@XZ
+18 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_CI_TRANSFORM_SHADER_DESC@@@detail@archive@boost@@QEAA@XZ
+19 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_CONSTANTUSAGE@@@detail@archive@boost@@QEAA@XZ
+20 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_CPS_CONFIG@@@detail@archive@boost@@QEAA@XZ
+21 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_FLOAT_CONST@@@detail@archive@boost@@QEAA@XZ
+22 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_INT_CONST@@@detail@archive@boost@@QEAA@XZ
+23 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_CB_OFFSET_LUT@@@detail@archive@boost@@QEAA@XZ
+24 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_CONTROL_FLAGS@@@detail@archive@boost@@QEAA@XZ
+25 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_VPORT_CONTROLS_LUT@@@detail@archive@boost@@QEAA@XZ
+26 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_PS_EXPORT_INFO@@@detail@archive@boost@@QEAA@XZ
+27 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SHADERSTATE@@@detail@archive@boost@@QEAA@XZ
+28 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SI_DATA_IN_OUT@@@detail@archive@boost@@QEAA@XZ
+29 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SI_DESCRIPTOR_VALUES@@@detail@archive@boost@@QEAA@XZ
+30 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SI_OPTIMIZATIONS@@@detail@archive@boost@@QEAA@XZ
+31 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SI_PSSHADERDCL_IN@@@detail@archive@boost@@QEAA@XZ
+32 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SI_PS_ATTR_CH_ENTRY@@@detail@archive@boost@@QEAA@XZ
+33 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@QEAA@XZ
+34 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SI_STREAMIODCL_OUT@@@detail@archive@boost@@QEAA@XZ
+35 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SI_USER_DATA_ELEMENT@@@detail@archive@boost@@QEAA@XZ
+36 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@QEAA@XZ
+37 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@QEAA@XZ
+38 stub ??0?$oserializer@Vsc_xml_oarchive@@U_SC_TXCONSTVALUES@@@detail@archive@boost@@QEAA@XZ
+39 stub ??0?$oserializer@Vsc_xml_oarchive@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@detail@archive@boost@@QEAA@XZ
+40 stub ??0?$singleton@V?$extended_type_info_typeid@T_E_SC_SI_OPT_IR_MODE_SELECTOR@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+41 stub ??0?$singleton@V?$extended_type_info_typeid@T_E_SC_SI_OPT_MINIMIZE_VGPRS_STRATEGY@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+42 stub ??0?$singleton@V?$extended_type_info_typeid@T_E_SC_SI_OPT_NPI_DISABLE@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+43 stub ??0?$singleton@V?$extended_type_info_typeid@T_E_SC_SI_OPT_THREAD_LATENCY_STRATEGY@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+44 stub ??0?$singleton@V?$extended_type_info_typeid@T_E_SC_SI_OPT_USE_MORE_D16_SELECTOR@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+45 stub ??0?$singleton@V?$extended_type_info_typeid@T_SC_COMPILE_FLAGS@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+46 stub ??0?$singleton@V?$extended_type_info_typeid@T_SC_LAUNCH_MODE_FLAGS@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+47 stub ??0?$singleton@V?$extended_type_info_typeid@T_SC_SI_GLC_CONTROL@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+48 stub ??0?$singleton@V?$extended_type_info_typeid@T_SC_SI_SLC_CONTROL@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+49 stub ??0?$singleton@V?$extended_type_info_typeid@USC_INPUT@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+50 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_CACHE_POLICY@serialization@boost@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+51 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_CACHE_POLICY_ATOMIC@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+52 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_CACHE_POLICY_CONTROL@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+53 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_CACHE_POLICY_READ@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+54 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_CACHE_POLICY_WRITE@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+55 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_CBCONSTVALUES@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+56 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_CBRCONSTVALUES@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+57 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_CI_TRANSFORM_SHADER_DESC@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+58 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_CONSTANTUSAGE@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+59 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_CPS_CONFIG@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+60 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_FLOAT_CONST@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+61 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_INT_CONST@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+62 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_PRIMSHADER_CB_OFFSET_LUT@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+63 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_PRIMSHADER_CONTROL_FLAGS@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+64 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_PRIMSHADER_VPORT_CONTROLS_LUT@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+65 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_PS_EXPORT_INFO@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+66 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SHADERSTATE@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+67 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SI_DATA_IN_OUT@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+68 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SI_DESCRIPTOR_VALUES@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+69 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SI_OPTIMIZATIONS@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+70 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SI_PSSHADERDCL_IN@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+71 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SI_PS_ATTR_CH_ENTRY@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+72 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SI_SHADERSTATE@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+73 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SI_STREAMIODCL_OUT@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+74 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SI_USER_DATA_ELEMENT@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+75 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SRCSHADER@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+76 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_SRC_PIPELINE@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+77 stub ??0?$singleton@V?$extended_type_info_typeid@U_SC_TXCONSTVALUES@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+78 stub ??0?$singleton@V?$extended_type_info_typeid@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@serialization@boost@@@serialization@boost@@IEAA@XZ
+79 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@T_E_SC_SI_OPT_IR_MODE_SELECTOR@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@T_E_SC_SI_OPT_IR_MODE_SELECTOR@@@23@XZ
+80 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@T_E_SC_SI_OPT_MINIMIZE_VGPRS_STRATEGY@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@T_E_SC_SI_OPT_MINIMIZE_VGPRS_STRATEGY@@@23@XZ
+81 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@T_E_SC_SI_OPT_NPI_DISABLE@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@T_E_SC_SI_OPT_NPI_DISABLE@@@23@XZ
+82 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@T_E_SC_SI_OPT_THREAD_LATENCY_STRATEGY@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@T_E_SC_SI_OPT_THREAD_LATENCY_STRATEGY@@@23@XZ
+83 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@T_E_SC_SI_OPT_USE_MORE_D16_SELECTOR@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@T_E_SC_SI_OPT_USE_MORE_D16_SELECTOR@@@23@XZ
+84 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@T_SC_COMPILE_FLAGS@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@T_SC_COMPILE_FLAGS@@@23@XZ
+85 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@T_SC_LAUNCH_MODE_FLAGS@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@T_SC_LAUNCH_MODE_FLAGS@@@23@XZ
+86 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@T_SC_SI_GLC_CONTROL@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@T_SC_SI_GLC_CONTROL@@@23@XZ
+87 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@T_SC_SI_SLC_CONTROL@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@T_SC_SI_SLC_CONTROL@@@23@XZ
+88 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@USC_INPUT@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@USC_INPUT@@@23@XZ
+89 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_CACHE_POLICY@serialization@boost@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_CACHE_POLICY@serialization@boost@@@23@XZ
+90 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_CACHE_POLICY_ATOMIC@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_CACHE_POLICY_ATOMIC@@@23@XZ
+91 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_CACHE_POLICY_CONTROL@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_CACHE_POLICY_CONTROL@@@23@XZ
+92 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_CACHE_POLICY_READ@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_CACHE_POLICY_READ@@@23@XZ
+93 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_CACHE_POLICY_WRITE@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_CACHE_POLICY_WRITE@@@23@XZ
+94 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_CBCONSTVALUES@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_CBCONSTVALUES@@@23@XZ
+95 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_CBRCONSTVALUES@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_CBRCONSTVALUES@@@23@XZ
+96 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_CI_TRANSFORM_SHADER_DESC@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_CI_TRANSFORM_SHADER_DESC@@@23@XZ
+97 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_CONSTANTUSAGE@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_CONSTANTUSAGE@@@23@XZ
+98 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_CPS_CONFIG@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_CPS_CONFIG@@@23@XZ
+99 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_FLOAT_CONST@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_FLOAT_CONST@@@23@XZ
+100 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_INT_CONST@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_INT_CONST@@@23@XZ
+101 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_PRIMSHADER_CB_OFFSET_LUT@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_PRIMSHADER_CB_OFFSET_LUT@@@23@XZ
+102 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_PRIMSHADER_CONTROL_FLAGS@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_PRIMSHADER_CONTROL_FLAGS@@@23@XZ
+103 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_PRIMSHADER_VPORT_CONTROLS_LUT@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_PRIMSHADER_VPORT_CONTROLS_LUT@@@23@XZ
+104 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_PS_EXPORT_INFO@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_PS_EXPORT_INFO@@@23@XZ
+105 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SHADERSTATE@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SHADERSTATE@@@23@XZ
+106 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SI_DATA_IN_OUT@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SI_DATA_IN_OUT@@@23@XZ
+107 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SI_DESCRIPTOR_VALUES@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SI_DESCRIPTOR_VALUES@@@23@XZ
+108 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SI_OPTIMIZATIONS@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SI_OPTIMIZATIONS@@@23@XZ
+109 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SI_PSSHADERDCL_IN@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SI_PSSHADERDCL_IN@@@23@XZ
+110 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SI_PS_ATTR_CH_ENTRY@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SI_PS_ATTR_CH_ENTRY@@@23@XZ
+111 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SI_SHADERSTATE@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SI_SHADERSTATE@@@23@XZ
+112 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SI_STREAMIODCL_OUT@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SI_STREAMIODCL_OUT@@@23@XZ
+113 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SI_USER_DATA_ELEMENT@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SI_USER_DATA_ELEMENT@@@23@XZ
+114 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SRCSHADER@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SRCSHADER@@@23@XZ
+115 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_SRC_PIPELINE@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_SRC_PIPELINE@@@23@XZ
+116 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@U_SC_TXCONSTVALUES@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@U_SC_TXCONSTVALUES@@@23@XZ
+117 stub ?get_const_instance@?$singleton@V?$extended_type_info_typeid@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@serialization@boost@@@serialization@boost@@SAAEBV?$extended_type_info_typeid@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@23@XZ
+118 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_IR_MODE_SELECTOR@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_IR_MODE_SELECTOR@@@detail@archive@3@XZ
+119 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_MINIMIZE_VGPRS_STRATEGY@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_MINIMIZE_VGPRS_STRATEGY@@@detail@archive@3@XZ
+120 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_NPI_DISABLE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_NPI_DISABLE@@@detail@archive@3@XZ
+121 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_THREAD_LATENCY_STRATEGY@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_THREAD_LATENCY_STRATEGY@@@detail@archive@3@XZ
+122 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_USE_MORE_D16_SELECTOR@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_USE_MORE_D16_SELECTOR@@@detail@archive@3@XZ
+123 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@T_SC_COMPILE_FLAGS@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@T_SC_COMPILE_FLAGS@@@detail@archive@3@XZ
+124 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@T_SC_LAUNCH_MODE_FLAGS@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@T_SC_LAUNCH_MODE_FLAGS@@@detail@archive@3@XZ
+125 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@T_SC_SI_GLC_CONTROL@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@T_SC_SI_GLC_CONTROL@@@detail@archive@3@XZ
+126 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@T_SC_SI_SLC_CONTROL@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@T_SC_SI_SLC_CONTROL@@@detail@archive@3@XZ
+127 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@USC_INPUT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@USC_INPUT@@@detail@archive@3@XZ
+128 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY@serialization@boost@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY@serialization@boost@@@detail@archive@3@XZ
+129 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_ATOMIC@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_ATOMIC@@@detail@archive@3@XZ
+130 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_CONTROL@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_CONTROL@@@detail@archive@3@XZ
+131 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_READ@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_READ@@@detail@archive@3@XZ
+132 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_WRITE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_WRITE@@@detail@archive@3@XZ
+133 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_CBCONSTVALUES@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_CBCONSTVALUES@@@detail@archive@3@XZ
+134 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_CBRCONSTVALUES@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_CBRCONSTVALUES@@@detail@archive@3@XZ
+135 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_CI_TRANSFORM_SHADER_DESC@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_CI_TRANSFORM_SHADER_DESC@@@detail@archive@3@XZ
+136 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_CONSTANTUSAGE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_CONSTANTUSAGE@@@detail@archive@3@XZ
+137 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_CPS_CONFIG@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_CPS_CONFIG@@@detail@archive@3@XZ
+138 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_FLOAT_CONST@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_FLOAT_CONST@@@detail@archive@3@XZ
+139 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_INT_CONST@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_INT_CONST@@@detail@archive@3@XZ
+140 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_PRIMSHADER_CB_OFFSET_LUT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_PRIMSHADER_CB_OFFSET_LUT@@@detail@archive@3@XZ
+141 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_PRIMSHADER_CONTROL_FLAGS@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_PRIMSHADER_CONTROL_FLAGS@@@detail@archive@3@XZ
+142 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_PRIMSHADER_VPORT_CONTROLS_LUT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_PRIMSHADER_VPORT_CONTROLS_LUT@@@detail@archive@3@XZ
+143 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_PS_EXPORT_INFO@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_PS_EXPORT_INFO@@@detail@archive@3@XZ
+144 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SHADERSTATE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SHADERSTATE@@@detail@archive@3@XZ
+145 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SI_DATA_IN_OUT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SI_DATA_IN_OUT@@@detail@archive@3@XZ
+146 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SI_DESCRIPTOR_VALUES@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SI_DESCRIPTOR_VALUES@@@detail@archive@3@XZ
+147 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SI_OPTIMIZATIONS@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SI_OPTIMIZATIONS@@@detail@archive@3@XZ
+148 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SI_PSSHADERDCL_IN@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SI_PSSHADERDCL_IN@@@detail@archive@3@XZ
+149 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SI_PS_ATTR_CH_ENTRY@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SI_PS_ATTR_CH_ENTRY@@@detail@archive@3@XZ
+150 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@3@XZ
+151 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SI_STREAMIODCL_OUT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SI_STREAMIODCL_OUT@@@detail@archive@3@XZ
+152 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SI_USER_DATA_ELEMENT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SI_USER_DATA_ELEMENT@@@detail@archive@3@XZ
+153 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SRCSHADER@@@detail@archive@3@XZ
+154 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_SRC_PIPELINE@@@detail@archive@3@XZ
+155 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_TXCONSTVALUES@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@U_SC_TXCONSTVALUES@@@detail@archive@3@XZ
+156 stub ?get_const_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$iserializer@Vsc_xml_iarchive@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@detail@archive@3@XZ
+157 stub ?get_const_instance@?$singleton@V?$map@Vsc_xml_iarchive@@@extra_detail@detail@archive@boost@@@serialization@boost@@SAAEBV?$map@Vsc_xml_iarchive@@@extra_detail@detail@archive@3@XZ
+158 stub ?get_const_instance@?$singleton@V?$multiset@PEBVextended_type_info@serialization@boost@@Ukey_compare@detail@23@V?$allocator@PEBVextended_type_info@serialization@boost@@@std@@@std@@@serialization@boost@@SAAEBV?$multiset@PEBVextended_type_info@serialization@boost@@Ukey_compare@detail@23@V?$allocator@PEBVextended_type_info@serialization@boost@@@std@@@std@@XZ
+159 stub ?get_const_instance@?$singleton@V?$multiset@PEBVextended_type_info_typeid_0@typeid_system@serialization@boost@@Utype_compare@234@V?$allocator@PEBVextended_type_info_typeid_0@typeid_system@serialization@boost@@@std@@@std@@@serialization@boost@@SAAEBV?$multiset@PEBVextended_type_info_typeid_0@typeid_system@serialization@boost@@Utype_compare@234@V?$allocator@PEBVextended_type_info_typeid_0@typeid_system@serialization@boost@@@std@@@std@@XZ
+160 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_IR_MODE_SELECTOR@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_IR_MODE_SELECTOR@@@detail@archive@3@XZ
+161 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_MINIMIZE_VGPRS_STRATEGY@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_MINIMIZE_VGPRS_STRATEGY@@@detail@archive@3@XZ
+162 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_NPI_DISABLE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_NPI_DISABLE@@@detail@archive@3@XZ
+163 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_THREAD_LATENCY_STRATEGY@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_THREAD_LATENCY_STRATEGY@@@detail@archive@3@XZ
+164 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_USE_MORE_D16_SELECTOR@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_USE_MORE_D16_SELECTOR@@@detail@archive@3@XZ
+165 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@T_SC_COMPILE_FLAGS@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@T_SC_COMPILE_FLAGS@@@detail@archive@3@XZ
+166 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@T_SC_LAUNCH_MODE_FLAGS@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@T_SC_LAUNCH_MODE_FLAGS@@@detail@archive@3@XZ
+167 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@T_SC_SI_GLC_CONTROL@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@T_SC_SI_GLC_CONTROL@@@detail@archive@3@XZ
+168 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@T_SC_SI_SLC_CONTROL@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@T_SC_SI_SLC_CONTROL@@@detail@archive@3@XZ
+169 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@USC_INPUT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@USC_INPUT@@@detail@archive@3@XZ
+170 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY@serialization@boost@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY@serialization@boost@@@detail@archive@3@XZ
+171 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_ATOMIC@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_ATOMIC@@@detail@archive@3@XZ
+172 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_CONTROL@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_CONTROL@@@detail@archive@3@XZ
+173 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_READ@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_READ@@@detail@archive@3@XZ
+174 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_WRITE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_WRITE@@@detail@archive@3@XZ
+175 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_CBCONSTVALUES@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_CBCONSTVALUES@@@detail@archive@3@XZ
+176 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_CBRCONSTVALUES@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_CBRCONSTVALUES@@@detail@archive@3@XZ
+177 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_CI_TRANSFORM_SHADER_DESC@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_CI_TRANSFORM_SHADER_DESC@@@detail@archive@3@XZ
+178 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_CONSTANTUSAGE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_CONSTANTUSAGE@@@detail@archive@3@XZ
+179 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_CPS_CONFIG@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_CPS_CONFIG@@@detail@archive@3@XZ
+180 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_FLOAT_CONST@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_FLOAT_CONST@@@detail@archive@3@XZ
+181 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_INT_CONST@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_INT_CONST@@@detail@archive@3@XZ
+182 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_CB_OFFSET_LUT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_CB_OFFSET_LUT@@@detail@archive@3@XZ
+183 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_CONTROL_FLAGS@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_CONTROL_FLAGS@@@detail@archive@3@XZ
+184 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_VPORT_CONTROLS_LUT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_VPORT_CONTROLS_LUT@@@detail@archive@3@XZ
+185 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_PS_EXPORT_INFO@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_PS_EXPORT_INFO@@@detail@archive@3@XZ
+186 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SHADERSTATE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SHADERSTATE@@@detail@archive@3@XZ
+187 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SI_DATA_IN_OUT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SI_DATA_IN_OUT@@@detail@archive@3@XZ
+188 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SI_DESCRIPTOR_VALUES@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SI_DESCRIPTOR_VALUES@@@detail@archive@3@XZ
+189 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SI_OPTIMIZATIONS@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SI_OPTIMIZATIONS@@@detail@archive@3@XZ
+190 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SI_PSSHADERDCL_IN@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SI_PSSHADERDCL_IN@@@detail@archive@3@XZ
+191 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SI_PS_ATTR_CH_ENTRY@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SI_PS_ATTR_CH_ENTRY@@@detail@archive@3@XZ
+192 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@3@XZ
+193 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SI_STREAMIODCL_OUT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SI_STREAMIODCL_OUT@@@detail@archive@3@XZ
+194 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SI_USER_DATA_ELEMENT@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SI_USER_DATA_ELEMENT@@@detail@archive@3@XZ
+195 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SRCSHADER@@@detail@archive@3@XZ
+196 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_SRC_PIPELINE@@@detail@archive@3@XZ
+197 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_TXCONSTVALUES@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@U_SC_TXCONSTVALUES@@@detail@archive@3@XZ
+198 stub ?get_const_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$oserializer@Vsc_xml_oarchive@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@detail@archive@3@XZ
+199 stub ?get_const_instance@?$singleton@V?$pointer_iserializer@Vsc_xml_iarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$pointer_iserializer@Vsc_xml_iarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@3@XZ
+200 stub ?get_const_instance@?$singleton@V?$pointer_iserializer@Vsc_xml_iarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$pointer_iserializer@Vsc_xml_iarchive@@U_SC_SRCSHADER@@@detail@archive@3@XZ
+201 stub ?get_const_instance@?$singleton@V?$pointer_iserializer@Vsc_xml_iarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$pointer_iserializer@Vsc_xml_iarchive@@U_SC_SRC_PIPELINE@@@detail@archive@3@XZ
+202 stub ?get_const_instance@?$singleton@V?$pointer_oserializer@Vsc_xml_oarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$pointer_oserializer@Vsc_xml_oarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@3@XZ
+203 stub ?get_const_instance@?$singleton@V?$pointer_oserializer@Vsc_xml_oarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$pointer_oserializer@Vsc_xml_oarchive@@U_SC_SRCSHADER@@@detail@archive@3@XZ
+204 stub ?get_const_instance@?$singleton@V?$pointer_oserializer@Vsc_xml_oarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@@serialization@boost@@SAAEBV?$pointer_oserializer@Vsc_xml_oarchive@@U_SC_SRC_PIPELINE@@@detail@archive@3@XZ
+205 stub ?get_const_instance@?$singleton@V?$set@PEBVvoid_caster@void_cast_detail@serialization@boost@@Uvoid_caster_compare@234@V?$allocator@PEBVvoid_caster@void_cast_detail@serialization@boost@@@std@@@std@@@serialization@boost@@SAAEBV?$set@PEBVvoid_caster@void_cast_detail@serialization@boost@@Uvoid_caster_compare@234@V?$allocator@PEBVvoid_caster@void_cast_detail@serialization@boost@@@std@@@std@@XZ
+206 stub ?get_lock@singleton_module@serialization@boost@@AEAAAEA_NXZ
+207 stub ?get_mutable_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@@serialization@boost@@SAAEAV?$iserializer@Vsc_xml_iarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@3@XZ
+208 stub ?get_mutable_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@@serialization@boost@@SAAEAV?$iserializer@Vsc_xml_iarchive@@U_SC_SRCSHADER@@@detail@archive@3@XZ
+209 stub ?get_mutable_instance@?$singleton@V?$iserializer@Vsc_xml_iarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@@serialization@boost@@SAAEAV?$iserializer@Vsc_xml_iarchive@@U_SC_SRC_PIPELINE@@@detail@archive@3@XZ
+210 stub ?get_mutable_instance@?$singleton@V?$map@Vsc_xml_iarchive@@@extra_detail@detail@archive@boost@@@serialization@boost@@SAAEAV?$map@Vsc_xml_iarchive@@@extra_detail@detail@archive@3@XZ
+211 stub ?get_mutable_instance@?$singleton@V?$map@Vsc_xml_oarchive@@@extra_detail@detail@archive@boost@@@serialization@boost@@SAAEAV?$map@Vsc_xml_oarchive@@@extra_detail@detail@archive@3@XZ
+212 stub ?get_mutable_instance@?$singleton@V?$multiset@PEBVextended_type_info@serialization@boost@@Ukey_compare@detail@23@V?$allocator@PEBVextended_type_info@serialization@boost@@@std@@@std@@@serialization@boost@@SAAEAV?$multiset@PEBVextended_type_info@serialization@boost@@Ukey_compare@detail@23@V?$allocator@PEBVextended_type_info@serialization@boost@@@std@@@std@@XZ
+213 stub ?get_mutable_instance@?$singleton@V?$multiset@PEBVextended_type_info_typeid_0@typeid_system@serialization@boost@@Utype_compare@234@V?$allocator@PEBVextended_type_info_typeid_0@typeid_system@serialization@boost@@@std@@@std@@@serialization@boost@@SAAEAV?$multiset@PEBVextended_type_info_typeid_0@typeid_system@serialization@boost@@Utype_compare@234@V?$allocator@PEBVextended_type_info_typeid_0@typeid_system@serialization@boost@@@std@@@std@@XZ
+214 stub ?get_mutable_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@@serialization@boost@@SAAEAV?$oserializer@Vsc_xml_oarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@3@XZ
+215 stub ?get_mutable_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@@serialization@boost@@SAAEAV?$oserializer@Vsc_xml_oarchive@@U_SC_SRCSHADER@@@detail@archive@3@XZ
+216 stub ?get_mutable_instance@?$singleton@V?$oserializer@Vsc_xml_oarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@@serialization@boost@@SAAEAV?$oserializer@Vsc_xml_oarchive@@U_SC_SRC_PIPELINE@@@detail@archive@3@XZ
+217 stub ?get_mutable_instance@?$singleton@V?$set@PEBVvoid_caster@void_cast_detail@serialization@boost@@Uvoid_caster_compare@234@V?$allocator@PEBVvoid_caster@void_cast_detail@serialization@boost@@@std@@@std@@@serialization@boost@@SAAEAV?$set@PEBVvoid_caster@void_cast_detail@serialization@boost@@Uvoid_caster_compare@234@V?$allocator@PEBVvoid_caster@void_cast_detail@serialization@boost@@@std@@@std@@XZ
+218 stub ?is_destroyed@?$singleton@V?$map@Vsc_xml_iarchive@@@extra_detail@detail@archive@boost@@@serialization@boost@@SA_NXZ
+219 stub ?is_destroyed@?$singleton@V?$map@Vsc_xml_oarchive@@@extra_detail@detail@archive@boost@@@serialization@boost@@SA_NXZ
+220 stub ?is_destroyed@?$singleton@V?$multiset@PEBVextended_type_info@serialization@boost@@Ukey_compare@detail@23@V?$allocator@PEBVextended_type_info@serialization@boost@@@std@@@std@@@serialization@boost@@SA_NXZ
+221 stub ?is_destroyed@?$singleton@V?$multiset@PEBVextended_type_info_typeid_0@typeid_system@serialization@boost@@Utype_compare@234@V?$allocator@PEBVextended_type_info_typeid_0@typeid_system@serialization@boost@@@std@@@std@@@serialization@boost@@SA_NXZ
+222 stub ?is_destroyed@?$singleton@V?$set@PEBVvoid_caster@void_cast_detail@serialization@boost@@Uvoid_caster_compare@234@V?$allocator@PEBVvoid_caster@void_cast_detail@serialization@boost@@@std@@@std@@@serialization@boost@@SA_NXZ
+223 stub ?is_locked@singleton_module@serialization@boost@@QEAA_NXZ
+224 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_IR_MODE_SELECTOR@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+225 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_MINIMIZE_VGPRS_STRATEGY@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+226 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_NPI_DISABLE@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+227 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_THREAD_LATENCY_STRATEGY@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+228 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@T_E_SC_SI_OPT_USE_MORE_D16_SELECTOR@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+229 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@T_SC_COMPILE_FLAGS@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+230 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@T_SC_LAUNCH_MODE_FLAGS@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+231 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@T_SC_SI_GLC_CONTROL@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+232 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@T_SC_SI_SLC_CONTROL@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+233 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@USC_INPUT@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+234 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY@serialization@boost@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+235 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_ATOMIC@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+236 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_CONTROL@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+237 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_READ@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+238 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_CACHE_POLICY_WRITE@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+239 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_CBCONSTVALUES@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+240 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_CBRCONSTVALUES@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+241 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_CI_TRANSFORM_SHADER_DESC@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+242 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_CONSTANTUSAGE@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+243 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_CPS_CONFIG@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+244 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_FLOAT_CONST@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+245 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_INT_CONST@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+246 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_PRIMSHADER_CB_OFFSET_LUT@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+247 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_PRIMSHADER_CONTROL_FLAGS@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+248 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_PRIMSHADER_VPORT_CONTROLS_LUT@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+249 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_PS_EXPORT_INFO@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+250 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SHADERSTATE@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+251 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SI_DATA_IN_OUT@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+252 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SI_DESCRIPTOR_VALUES@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+253 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SI_OPTIMIZATIONS@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+254 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SI_PSSHADERDCL_IN@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+255 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SI_PS_ATTR_CH_ENTRY@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+256 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+257 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SI_STREAMIODCL_OUT@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+258 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SI_USER_DATA_ELEMENT@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+259 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+260 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+261 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@U_SC_TXCONSTVALUES@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+262 stub ?load_object_data@?$iserializer@Vsc_xml_iarchive@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@detail@archive@boost@@UEBAXAEAVbasic_iarchive@234@PEAXI@Z
+263 stub ?load_object_ptr@?$pointer_iserializer@Vsc_xml_iarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@EEBAXAEAVbasic_iarchive@234@PEAXI@Z
+264 stub ?load_object_ptr@?$pointer_iserializer@Vsc_xml_iarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@EEBAXAEAVbasic_iarchive@234@PEAXI@Z
+265 stub ?load_object_ptr@?$pointer_iserializer@Vsc_xml_iarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@EEBAXAEAVbasic_iarchive@234@PEAXI@Z
+266 stub ?lock@?1??get_lock@singleton_module@serialization@boost@@AEAAAEA_NXZ@4_NA
+267 stub ?lock@singleton_module@serialization@boost@@QEAAXXZ
+268 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_IR_MODE_SELECTOR@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+269 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_MINIMIZE_VGPRS_STRATEGY@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+270 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_NPI_DISABLE@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+271 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_THREAD_LATENCY_STRATEGY@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+272 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@T_E_SC_SI_OPT_USE_MORE_D16_SELECTOR@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+273 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@T_SC_COMPILE_FLAGS@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+274 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@T_SC_LAUNCH_MODE_FLAGS@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+275 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@T_SC_SI_GLC_CONTROL@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+276 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@T_SC_SI_SLC_CONTROL@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+277 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@USC_INPUT@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+278 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY@serialization@boost@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+279 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_ATOMIC@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+280 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_CONTROL@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+281 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_READ@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+282 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_CACHE_POLICY_WRITE@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+283 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_CBCONSTVALUES@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+284 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_CBRCONSTVALUES@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+285 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_CI_TRANSFORM_SHADER_DESC@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+286 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_CONSTANTUSAGE@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+287 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_CPS_CONFIG@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+288 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_FLOAT_CONST@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+289 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_INT_CONST@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+290 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_CB_OFFSET_LUT@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+291 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_CONTROL_FLAGS@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+292 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_PRIMSHADER_VPORT_CONTROLS_LUT@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+293 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_PS_EXPORT_INFO@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+294 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SHADERSTATE@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+295 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SI_DATA_IN_OUT@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+296 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SI_DESCRIPTOR_VALUES@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+297 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SI_OPTIMIZATIONS@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+298 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SI_PSSHADERDCL_IN@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+299 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SI_PS_ATTR_CH_ENTRY@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+300 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+301 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SI_STREAMIODCL_OUT@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+302 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SI_USER_DATA_ELEMENT@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+303 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+304 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+305 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@U_SC_TXCONSTVALUES@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+306 stub ?save_object_data@?$oserializer@Vsc_xml_oarchive@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@detail@archive@boost@@UEBAXAEAVbasic_oarchive@234@PEBX@Z
+307 stub ?save_object_ptr@?$pointer_oserializer@Vsc_xml_oarchive@@U_SC_SI_SHADERSTATE@@@detail@archive@boost@@EEBAXAEAVbasic_oarchive@234@PEBX@Z
+308 stub ?save_object_ptr@?$pointer_oserializer@Vsc_xml_oarchive@@U_SC_SRCSHADER@@@detail@archive@boost@@EEBAXAEAVbasic_oarchive@234@PEBX@Z
+309 stub ?save_object_ptr@?$pointer_oserializer@Vsc_xml_oarchive@@U_SC_SRC_PIPELINE@@@detail@archive@boost@@EEBAXAEAVbasic_oarchive@234@PEBX@Z
+310 stub ?unlock@singleton_module@serialization@boost@@QEAAXXZ
+@ cdecl AmdExtD3DCreateInterface(ptr ptr ptr)
+@ stdcall AmdGetDxcModuleHandle()
+313 stub GetSettingsBlobsAll
+314 stub OpenAdapter12
+315 stub OpenShimInterface
diff --git a/dlls/amdxc64/amdxc_interfaces.idl b/dlls/amdxc64/amdxc_interfaces.idl
new file mode 100644
index 00000000000..2c2f568df37
--- /dev/null
+++ b/dlls/amdxc64/amdxc_interfaces.idl
@@ -0,0 +1,96 @@
+/*
+ * Copyright 2025 Etaash Mathamsetty
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+#pragma makedep register
+
+import "wtypes.idl";
+import "unknwn.idl";
+
+/* Structure version 1 for Anti-Lag 2.0: */
+struct APIData_v1
+{
+    unsigned int    uiSize;
+    unsigned int    uiVersion;
+    unsigned int    eMode;
+    const char*     sControlStr;
+    unsigned int    uiControlStrLength;
+    unsigned int    maxFPS;
+};
+
+/* Structure version 2 for Anti-Lag 2.0: */
+struct APIData_v2
+{
+    unsigned int    uiSize;
+    unsigned int    uiVersion;
+    struct Flags
+    {
+        unsigned int unused0               : 1;
+        unsigned int unused1               : 1;
+
+        unsigned int signalFgFrameType     : 1;
+        unsigned int isInterpolatedFrame   : 1;
+
+        unsigned int signalGetUserInputIdx : 1;
+        unsigned int signalEndOfFrameIdx   : 1;
+
+        unsigned int reserved              :26;
+    }               flags;
+    unsigned __int64    iiFrameIdx;
+    unsigned __int64    uiiReserved[19];
+};
+
+[
+    object,
+    uuid(b58d6601-7401-4234-8180-6febfc0e484c),
+    local
+]
+interface IAmdExtFfxApi : IUnknown
+{
+    HRESULT UpdateFfxApiProvider([in, out] void* pData, [in] unsigned int dataSizeInBytes);
+}
+
+[
+    object,
+    uuid(44085fbe-e839-40c5-bf38-0ebc5ab4d0a6),
+    local
+]
+interface IAmdExtAntiLagApi : IUnknown
+{
+    HRESULT UpdateAntiLagState([in, out] void* pData);
+}
+
+[
+    object,
+    uuid(014937ec-9288-446f-a9ac-d75a8e3a984f),
+    local
+]
+interface IAmdExtStub1 : IUnknown
+{
+    HRESULT QueryInterface2([in, out] void* unk, [in] REFIID iid, [in, out] void** out);
+}
+
+[
+    object,
+    uuid(ba019d53-ccab-4cbd-b56a-7230ed4330ad),
+    local
+]
+interface IAmdExtStub2 : IUnknown
+{
+    void stub();
+    void stub2([in] unsigned int unk);
+    void stub3();
+}
diff --git a/dlls/amdxc64/dxvk_interfaces.idl b/dlls/amdxc64/dxvk_interfaces.idl
new file mode 100644
index 00000000000..9e405a32a06
--- /dev/null
+++ b/dlls/amdxc64/dxvk_interfaces.idl
@@ -0,0 +1,153 @@
+/*
+ * Copyright 2023      Paul Gofman for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#pragma makedep register
+
+import "d3d11.idl";
+import "dxgi1_6.idl";
+
+typedef struct VkInstance_T *VkInstance;
+typedef void (__stdcall *PFN_vkVoidFunction)(void);
+typedef PFN_vkVoidFunction (__stdcall *PFN_vkGetInstanceProcAddr)(VkInstance instance, const char* pName);
+
+typedef enum D3D11_VK_EXTENSION
+{
+    D3D11_VK_EXT_MULTI_DRAW_INDIRECT,
+    D3D11_VK_EXT_MULTI_DRAW_INDIRECT_COUNT,
+    D3D11_VK_EXT_DEPTH_BOUNDS,
+    D3D11_VK_EXT_BARRIER_CONTROL,
+    D3D11_VK_NVX_BINARY_IMPORT,
+    D3D11_VK_NVX_IMAGE_VIEW_HANDLE,
+} D3D11_VK_EXTENSION;
+
+typedef enum D3D11_VK_BARRIER_CONTROL
+{
+    D3D11_VK_BARRIER_CONTROL_IGNORE_WRITE_AFTER_WRITE = 0x1,
+    D3D11_VK_BARRIER_CONTROL_IGNORE_GRAPHICS_UAV = 0x2,
+} D3D11_VK_BARRIER_CONTROL;
+
+[
+    object,
+    uuid(bb8a4fb9-3935-4762-b44b-35189a26414a),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtShader : IUnknown
+{
+    HRESULT GetSpirvCode([in, out] SIZE_T *code_size, [out] void *code);
+}
+
+[
+    object,
+    uuid(8a6e3c42-f74c-45b7-8265-a231b677ca17),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtDevice : IUnknown
+{
+    BOOL GetExtensionSupport([in] D3D11_VK_EXTENSION extension);
+}
+
+[
+    object,
+    uuid(cfcf64ef-9586-46d0-bca4-97cf2ca61b06),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtDevice1 : ID3D11VkExtDevice
+{
+    BOOL GetResourceHandleGPUVirtualAddressAndSizeNVX([in] void *object, [out] UINT64 *gpu_va_start,
+            [out] UINT64 *gpu_va_size);
+    BOOL CreateUnorderedAccessViewAndGetDriverHandleNVX([in] ID3D11Resource *resource,
+            [in] const D3D11_UNORDERED_ACCESS_VIEW_DESC *desc, [out] ID3D11UnorderedAccessView **uav,
+            UINT32 *driver_handle);
+    BOOL CreateShaderResourceViewAndGetDriverHandleNVX([in] ID3D11Resource *resource,
+            [in] const D3D11_SHADER_RESOURCE_VIEW_DESC* desc, [out] ID3D11ShaderResourceView **srv,
+            UINT32 *dirver_handle);
+    BOOL CreateSamplerStateAndGetDriverHandleNVX([in] const D3D11_SAMPLER_DESC *sample_desc,
+            [out] ID3D11SamplerState **sample_state, UINT32 *driver_handle);
+    BOOL CreateCubinComputeShaderWithNameNVX([in] const void *cubin, [in] UINT32 size, [in] UINT32 block_x,
+            [in] UINT32 block_y, [in] UINT32 block_z, [in] const char *shader_name, [out] IUnknown **shader);
+    BOOL GetCudaTextureObjectNVX([in] UINT32 srv_driver_hadnle, [in] UINT32 sample_driver_handle,
+            [out] UINT32 *cuda_texture_handle);
+}
+
+[
+    object,
+    uuid(fd0bca13-5cb6-4c3a-987e-4750de2ca791),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtContext : IUnknown
+{
+    void MultiDrawIndirect([in] UINT draw_count, [in] ID3D11Buffer *buffer_for_args, [in] UINT byte_offset_for_args,
+            [in] UINT byte_stride_for_args);
+    void MultiDrawIndexedIndirect([in] UINT draw_count, [in] ID3D11Buffer *buffer_for_args,
+            [in] UINT byte_offset_for_args, [in] UINT byte_stride_for_args);
+    void MultiDrawIndirectCount([in] UINT max_draw_count, [in] ID3D11Buffer *buffer_for_count,
+            [in] UINT byte_offset_for_count, [in] ID3D11Buffer *buffer_for_args,
+            [in] UINT byte_offset_for_args, [in] UINT byte_stride_for_args);
+    void MultiDrawIndexedIndirectCount([in] UINT max_draw_count, [in] ID3D11Buffer *buffer_for_count,
+            [in] UINT byte_offset_for_count, [in] ID3D11Buffer *buffer_for_args,
+            [in] UINT byte_offset_for_args, [in] UINT byte_stride_for_args);
+    void SetDepthBoundsTest([in] BOOL enable, [in] FLOAT min_depth_bounds, [in] FLOAT max_depth_bounds);
+    void SetBarrierControl([in] UINT control_flags);
+}
+
+[
+    object,
+    uuid(874b09b2-ae0b-41d8-8476-5f3b7a0e879d),
+    local,
+    pointer_default(unique)
+]
+interface ID3D11VkExtContext1 : ID3D11VkExtContext
+{
+    BOOL LaunchCubinShaderNVX([in] IUnknown *shader,[in] UINT32 grid_x, [in] UINT32 grid_y, [in] UINT32 grid_z,
+            [in] const void *params, [in] UINT32 param_size, [in] void * const *read_resources,
+            [in] UINT32 read_resource_count, [in] void* const *write_resources, [in] UINT32 write_resources_count);
+}
+
+[
+    object,
+    uuid(4c5e1b0d-b0c8-4131-bfd8-9b2476f7f408),
+    local,
+    pointer_default(unique)
+]
+interface IDXGIVkInteropFactory : IUnknown
+{
+    void GetVulkanInstance(
+          [out] VkInstance *pInstance,
+          [out] PFN_vkGetInstanceProcAddr *ppfnVkGetInstanceProcAddr);
+}
+
+[
+    object,
+    uuid(2a289dbd-2d0a-4a51-89f7-f2adce465cd6),
+    local,
+    pointer_default(unique)
+]
+interface IDXGIVkInteropFactory1 : IDXGIVkInteropFactory
+{
+  HRESULT GetGlobalHDRState(
+          [out] DXGI_COLOR_SPACE_TYPE   *pOutColorSpace,
+          [out] DXGI_HDR_METADATA_HDR10 *ppOutMetadata) = 0;
+
+  HRESULT SetGlobalHDRState(
+          [in] DXGI_COLOR_SPACE_TYPE    ColorSpace,
+    [in] const DXGI_HDR_METADATA_HDR10 *pMetadata) = 0;
+}
diff --git a/dlls/amdxc64/main.c b/dlls/amdxc64/main.c
new file mode 100644
index 00000000000..754e22f914f
--- /dev/null
+++ b/dlls/amdxc64/main.c
@@ -0,0 +1,317 @@
+/*
+ * amdxc implementation
+ *
+ * Copyright 2023 Etaash Mathamsetty
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdarg.h>
+
+#include "ntstatus.h"
+#include "winerror.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winbase.h"
+#include "winternl.h"
+#include "wine/debug.h"
+#include "wine/heap.h"
+
+#include "wine/vulkan.h"
+#include "wine/asm.h"
+
+#define COBJMACROS
+#include "initguid.h"
+#include "d3d11.h"
+#include "d3d12.h"
+
+#include "dxgi1_6.h"
+
+#include "dxvk_interfaces.h"
+#include "amdxc_interfaces.h"
+
+#include <wingdi.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(amdxc);
+
+struct AMDFSR4FFX
+{
+    IAmdExtFfxApi IAmdExtFfxApi_iface;
+    LONG ref;
+};
+
+static struct AMDFSR4FFX* impl_from_IAmdExtFfxApi(IAmdExtFfxApi* iface)
+{
+    return CONTAINING_RECORD(iface, struct AMDFSR4FFX, IAmdExtFfxApi_iface);
+}
+
+ULONG STDMETHODCALLTYPE AMDFSR4FFX_AddRef(IAmdExtFfxApi *iface)
+{
+    struct AMDFSR4FFX* data = impl_from_IAmdExtFfxApi(iface);
+    return InterlockedIncrement(&data->ref);
+}
+
+ULONG STDMETHODCALLTYPE AMDFSR4FFX_Release(IAmdExtFfxApi *iface)
+{
+    struct AMDFSR4FFX* data = impl_from_IAmdExtFfxApi(iface);
+    ULONG ret = InterlockedDecrement(&data->ref);
+    if (!ret) free(data);
+    return ret;
+}
+
+HRESULT STDMETHODCALLTYPE AMDFSR4FFX_QueryInterface(IAmdExtFfxApi *iface, REFIID iid, void **obj)
+{
+    FIXME("%p %s %p", iface, debugstr_guid(iid), obj);
+
+    return E_NOINTERFACE;
+}
+
+typedef HRESULT (__stdcall *updateffxapi_pfn)(void*, unsigned int);
+
+HRESULT STDMETHODCALLTYPE AMDFSR4FFX_UpdateFfxApiProvider(IAmdExtFfxApi *iface, void* data, unsigned int size)
+{
+    updateffxapi_pfn pfn;
+    HMODULE amdffx = LoadLibraryA("amdxcffx64");
+
+    TRACE("%p %p %u\n", iface, data, size);
+
+    if (!amdffx)
+    {
+        ERR("Failed to load FSR4 dll (amdxcffx)!\n");
+        return E_NOINTERFACE;
+    }
+
+    pfn = (updateffxapi_pfn)GetProcAddress(amdffx, "UpdateFfxApiProvider");
+
+    if(pfn && getenv("FSR4_UPGRADE"))
+    {
+        FIXME("replaced fsr3 with fsr4!\n");
+        return pfn(data, size);
+    }
+
+    return E_NOINTERFACE;
+}
+
+static const struct IAmdExtFfxApiVtbl AMDFSR4FFX_vtable = {
+    AMDFSR4FFX_QueryInterface,
+    AMDFSR4FFX_AddRef,
+    AMDFSR4FFX_Release,
+    AMDFSR4FFX_UpdateFfxApiProvider
+};
+
+struct AMDAntiLag2
+{
+    IAmdExtAntiLagApi IAmdExtAntiLagApi_iface;
+    LONG ref;
+};
+
+static struct AMDAntiLag2* impl_from_IAmdExtAntiLagApi(IAmdExtAntiLagApi *iface)
+{
+    return CONTAINING_RECORD(iface, struct AMDAntiLag2, IAmdExtAntiLagApi_iface);
+}
+
+ULONG STDMETHODCALLTYPE AMDAntiLag2_AddRef(IAmdExtAntiLagApi *iface)
+{
+    struct AMDAntiLag2 *data = impl_from_IAmdExtAntiLagApi(iface);
+    return InterlockedIncrement(&data->ref);
+}
+
+ULONG STDMETHODCALLTYPE AMDAntiLag2_Release(IAmdExtAntiLagApi *iface)
+{
+    struct AMDAntiLag2 *data = impl_from_IAmdExtAntiLagApi(iface);
+    ULONG ret = InterlockedDecrement(&data->ref);
+    if (!ret) free(data);
+    return ret;
+}
+
+HRESULT STDMETHODCALLTYPE AMDAntiLag2_QueryInterface(IAmdExtAntiLagApi *iface, REFIID iid, void **out)
+{
+    FIXME("(%p %s %p) stub!\n", iface, debugstr_guid(iid), out);
+    return E_NOINTERFACE;
+}
+
+HRESULT STDMETHODCALLTYPE AMDAntiLag2_UpdateAntiLagState(IAmdExtAntiLagApi *iface, void* data)
+{
+    union {
+        struct APIData_v1 *v1;
+        struct APIData_v2 *v2;
+    } apidata = {data};
+    TRACE("(%p %p)!\n", iface, data);
+
+    if (!data) {
+        /* perform sleep */
+    } else if(apidata.v1->uiVersion == 1) {
+        /* access apidata v1 */
+        if(apidata.v1->uiSize != sizeof(struct APIData_v1)) return E_INVALIDARG;
+    } else if(apidata.v1->uiVersion == 2) {
+        /* access apidata v2 */
+        if(apidata.v2->uiSize != sizeof(struct APIData_v2)) return E_INVALIDARG;
+    }
+
+    return E_NOTIMPL;
+}
+
+static const struct IAmdExtAntiLagApiVtbl AMDANTILAG_vtable = {
+    AMDAntiLag2_QueryInterface,
+    AMDAntiLag2_AddRef,
+    AMDAntiLag2_Release,
+    AMDAntiLag2_UpdateAntiLagState
+};
+
+struct AMDExtStub2
+{
+    IAmdExtStub2 IAmdExtStub2_iface;
+    LONG ref;
+};
+
+struct AMDExtStub2* impl_from_IAMDExtStub2(IAmdExtStub2 *iface)
+{
+    return CONTAINING_RECORD(iface, struct AMDExtStub2, IAmdExtStub2_iface);
+}
+
+ULONG STDMETHODCALLTYPE AMDExtStub2_AddRef(IAmdExtStub2 *iface)
+{
+    struct AMDExtStub2 *this = impl_from_IAMDExtStub2(iface);
+    return InterlockedIncrement(&this->ref);
+}
+
+ULONG STDMETHODCALLTYPE AMDExtStub2_Release(IAmdExtStub2 *iface)
+{
+    struct AMDExtStub2 *this = impl_from_IAMDExtStub2(iface);
+    ULONG ret = InterlockedDecrement(&this->ref);
+    if (!ret) free(this);
+    return ret;
+}
+
+HRESULT STDMETHODCALLTYPE AMDExtStub2_QueryInterface(IAmdExtStub2 *iface, REFIID iid, void **out)
+{
+    FIXME("%p %s %p stub!\n", iface, debugstr_guid(iid), out);
+    return E_NOINTERFACE;
+}
+
+void STDMETHODCALLTYPE AMDExtStub2_stub1(IAmdExtStub2 *iface)
+{
+    FIXME("%p stub!\n", iface);
+}
+
+void STDMETHODCALLTYPE AMDExtStub2_stub2(IAmdExtStub2 *iface, unsigned int unk)
+{
+    FIXME("%p %u stub!\n", iface, unk);
+}
+
+void STDMETHODCALLTYPE AMDExtStub2_stub3(IAmdExtStub2 *iface)
+{
+    FIXME("%p stub!\n", iface);
+}
+
+const static struct IAmdExtStub2Vtbl AMDSTUB2_vtable = {
+    AMDExtStub2_QueryInterface,
+    AMDExtStub2_AddRef,
+    AMDExtStub2_Release,
+    AMDExtStub2_stub1,
+    AMDExtStub2_stub2,
+    AMDExtStub2_stub3
+};
+
+struct AMDExtStub1
+{
+    IAmdExtStub1 IAmdExtStub1_iface;
+    LONG ref;
+};
+
+struct AMDExtStub1* impl_from_IAMDExtStub1(IAmdExtStub1 *iface)
+{
+    return CONTAINING_RECORD(iface, struct AMDExtStub1, IAmdExtStub1_iface);
+}
+
+ULONG STDMETHODCALLTYPE AMDExtStub1_AddRef(IAmdExtStub1 *iface)
+{
+    struct AMDExtStub1 *this = impl_from_IAMDExtStub1(iface);
+    return InterlockedIncrement(&this->ref);
+}
+
+ULONG STDMETHODCALLTYPE AMDExtStub1_Release(IAmdExtStub1 *iface)
+{
+    struct AMDExtStub1 *this = impl_from_IAMDExtStub1(iface);
+    ULONG ret = InterlockedDecrement(&this->ref);
+    if (!ret) free(this);
+    return ret;
+}
+
+HRESULT STDMETHODCALLTYPE AmdExtStub1_QueryInterface2(IAmdExtStub1 *iface, void* unk, REFIID iid, void **out)
+{
+    TRACE("%p %p %s %p\n", iface, unk, debugstr_guid(iid), out);
+
+    if(IsEqualGUID(iid, &IID_IAmdExtStub2))
+    {
+        struct AMDExtStub2 *this = calloc(1, sizeof(struct AMDExtStub2));
+
+        this->IAmdExtStub2_iface.lpVtbl = &AMDSTUB2_vtable;
+        this->ref = 1;
+        *out = &this->IAmdExtStub2_iface;
+        return S_OK;
+    } else {
+        FIXME("unknown guid %s\n", debugstr_guid(iid));
+    }
+
+    return E_NOINTERFACE;
+}
+
+HRESULT STDMETHODCALLTYPE AmdExtStub1_QueryInterface(IAmdExtStub1 *iface, REFIID iid, void **out)
+{
+    return AmdExtStub1_QueryInterface2(iface, NULL, iid, out);
+}
+
+static const struct IAmdExtStub1Vtbl AMDSTUB1_vtable = {
+    AmdExtStub1_QueryInterface,
+    AMDExtStub1_AddRef,
+    AMDExtStub1_Release,
+    AmdExtStub1_QueryInterface2
+};
+
+HRESULT CDECL AmdExtD3DCreateInterface(IUnknown *outer, REFIID iid, void **obj)
+{
+    TRACE("outer %p, iid %s, obj %p\n", outer, debugstr_guid(iid), obj);
+
+    if (IsEqualGUID(iid, &IID_IAmdExtFfxApi))
+    {
+        struct AMDFSR4FFX* ffx = calloc(1, sizeof(struct AMDFSR4FFX));
+        ffx->IAmdExtFfxApi_iface.lpVtbl = &AMDFSR4FFX_vtable;
+        ffx->ref = 1;
+        *obj = &ffx->IAmdExtFfxApi_iface;
+        return S_OK;
+    } else if (IsEqualGUID(iid, &IID_IAmdExtAntiLagApi)) {
+        struct AMDAntiLag2 *out = calloc(1, sizeof(struct AMDAntiLag2));
+        out->IAmdExtAntiLagApi_iface.lpVtbl = &AMDANTILAG_vtable;
+        out->ref = 1;
+        *obj = &out->IAmdExtAntiLagApi_iface;
+        return S_OK;
+    } else if(IsEqualGUID(iid, &IID_IAmdExtStub1)) {
+        struct AMDExtStub1 *this = calloc(1, sizeof(struct AMDExtStub1));
+        this->IAmdExtStub1_iface.lpVtbl = &AMDSTUB1_vtable;
+        this->ref = 1;
+        *obj = &this->IAmdExtStub1_iface;
+        return S_OK;
+    } else {
+        FIXME("unknown guid: %s\n", debugstr_guid(iid));
+    }
+
+    return E_NOINTERFACE;
+}
+
+HMODULE WINAPI AmdGetDxcModuleHandle(void)
+{
+    return GetModuleHandleA(NULL);
+}
-- 
2.49.0

From 622cef8ce24911d2fa5ab756f2b21fe9ffdb504f Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty <etaash.mathamsetty@gmail.com>
Date: Mon, 20 Jan 2025 15:40:46 -0500
Subject: [PATCH 35/78] wine.inf: Don't clobber UBR key.

---
 loader/wine.inf.in | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 30751cc1510..45e0a2b2509 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -2686,7 +2686,7 @@ HKLM,%CurrentVersionNT%,"CurrentMinorVersionNumber",0x10003,0
 HKLM,%CurrentVersionNT%,"CurrentBuild",2,"19045"
 HKLM,%CurrentVersionNT%,"CurrentBuildNumber",2,"19045"
 HKLM,%CurrentVersionNT%,"CurrentType",2,"Multiprocessor Free"
-HKLM,%CurrentVersionNT%,"UBR",0x10001,5796
+HKLM,%CurrentVersionNT%,"UBR",0x10003,5796
 HKLM,%CurrentVersionNT%,"DigitalProductId",2,00,00,00,00,00,00,00,00,00,00,00,\
 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,\
 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,\
-- 
2.49.0

From c2ff98de8065d02410fea98451cf6844599d7d78 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty <etaash.mathamsetty@gmail.com>
Date: Wed, 29 Jan 2025 19:05:17 -0500
Subject: [PATCH 36/78] twinapi.appcore/tests: Fix broken registry query.

---
 dlls/twinapi.appcore/tests/twinapi.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/twinapi.appcore/tests/twinapi.c b/dlls/twinapi.appcore/tests/twinapi.c
index 5ee5c45fc91..e86281b895e 100644
--- a/dlls/twinapi.appcore/tests/twinapi.c
+++ b/dlls/twinapi.appcore/tests/twinapi.c
@@ -164,6 +164,7 @@ static void test_AnalyticsVersionInfo(void)
     WindowsDeleteString( str );
     WindowsDeleteString( expect_str );
 
+    size = sizeof(revision);
     if (RegGetValueW( HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows NT\\CurrentVersion", L"UBR",
                       RRF_RT_REG_DWORD, NULL, &revision, &size ))
         revision = 0;
-- 
2.49.0

From 554f48452260a0262ef54615836c726da4dfaa38 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sat, 10 May 2025 01:23:55 -0400
Subject: [PATCH 37/78] winecfg: Add support for UBR key.

---
 programs/winecfg/appdefaults.c | 47 +++++++++++++++++++---------------
 1 file changed, 27 insertions(+), 20 deletions(-)

diff --git a/programs/winecfg/appdefaults.c b/programs/winecfg/appdefaults.c
index cfb898b1d53..0acb964ef0a 100644
--- a/programs/winecfg/appdefaults.c
+++ b/programs/winecfg/appdefaults.c
@@ -40,6 +40,7 @@ struct win_version
     DWORD        dwMajorVersion;
     DWORD        dwMinorVersion;
     DWORD        dwBuildNumber;
+    DWORD        UBR;
     DWORD        dwPlatformId;
     const WCHAR *szCSDVersion;
     WORD         wServicePackMajor;
@@ -49,26 +50,26 @@ struct win_version
 
 static const struct win_version win_versions[] =
 {
-    { L"win11",     L"Windows 11",      L"6.3", 10,  0, 22000, VER_PLATFORM_WIN32_NT, L"", 0, 0, L"WinNT"},
-    { L"win10",     L"Windows 10",      L"6.3", 10,  0, 19045, VER_PLATFORM_WIN32_NT, L"", 0, 0, L"WinNT"},
-    { L"win81",     L"Windows 8.1",     NULL,    6,  3,  9600, VER_PLATFORM_WIN32_NT, L"", 0, 0, L"WinNT"},
-    { L"win8",      L"Windows 8",       NULL,    6,  2,  9200, VER_PLATFORM_WIN32_NT, L"", 0, 0, L"WinNT"},
-    { L"win2008r2", L"Windows 2008 R2", NULL,    6,  1,  7601, VER_PLATFORM_WIN32_NT, L"Service Pack 1", 1, 0, L"ServerNT"},
-    { L"win7",      L"Windows 7",       NULL,    6,  1,  7601, VER_PLATFORM_WIN32_NT, L"Service Pack 1", 1, 0, L"WinNT"},
-    { L"win2008",   L"Windows 2008",    NULL,    6,  0,  6002, VER_PLATFORM_WIN32_NT, L"Service Pack 2", 2, 0, L"ServerNT"},
-    { L"vista",     L"Windows Vista",   NULL,    6,  0,  6002, VER_PLATFORM_WIN32_NT, L"Service Pack 2", 2, 0, L"WinNT"},
-    { L"win2003",   L"Windows 2003",    NULL,    5,  2,  3790, VER_PLATFORM_WIN32_NT, L"Service Pack 2", 2, 0, L"ServerNT"},
-    { L"winxp64",   L"Windows XP 64",   NULL,    5,  2,  3790, VER_PLATFORM_WIN32_NT, L"Service Pack 2", 2, 0, L"WinNT"},
-    { L"winxp",     L"Windows XP",      NULL,    5,  1,  2600, VER_PLATFORM_WIN32_NT, L"Service Pack 3", 3, 0, L"WinNT"},
-    { L"win2k",     L"Windows 2000",    NULL,    5,  0,  2195, VER_PLATFORM_WIN32_NT, L"Service Pack 4", 4, 0, L"WinNT"},
-    { L"winme",     L"Windows ME",      NULL,    4, 90,  3000, VER_PLATFORM_WIN32_WINDOWS, L" ", 0, 0, L""},
-    { L"win98",     L"Windows 98",      NULL,    4, 10,  2222, VER_PLATFORM_WIN32_WINDOWS, L" A ", 0, 0, L""},
-    { L"win95",     L"Windows 95",      NULL,    4,  0,   950, VER_PLATFORM_WIN32_WINDOWS, L"", 0, 0, L""},
-    { L"nt40",      L"Windows NT 4.0",  NULL,    4,  0,  1381, VER_PLATFORM_WIN32_NT, L"Service Pack 6a", 6, 0, L"WinNT"},
-    { L"nt351",     L"Windows NT 3.51", NULL,    3, 51,  1057, VER_PLATFORM_WIN32_NT, L"Service Pack 5", 5, 0, L"WinNT"},
-    { L"win31",     L"Windows 3.1",     NULL,    3, 10,     0, VER_PLATFORM_WIN32s, L"Win32s 1.3", 0, 0, L""},
-    { L"win30",     L"Windows 3.0",     NULL,    3,  0,     0, VER_PLATFORM_WIN32s, L"Win32s 1.3", 0, 0, L""},
-    { L"win20",     L"Windows 2.0",     NULL,    2,  0,     0, VER_PLATFORM_WIN32s, L"Win32s 1.3", 0, 0, L""}
+    { L"win11",     L"Windows 11",      L"6.3", 10,  0, 22000,  588, VER_PLATFORM_WIN32_NT, L"", 0, 0, L"WinNT"},
+    { L"win10",     L"Windows 10",      L"6.3", 10,  0, 19045, 5796, VER_PLATFORM_WIN32_NT, L"", 0, 0, L"WinNT"},
+    { L"win81",     L"Windows 8.1",     NULL,    6,  3,  9600,    0, VER_PLATFORM_WIN32_NT, L"", 0, 0, L"WinNT"},
+    { L"win8",      L"Windows 8",       NULL,    6,  2,  9200,    0, VER_PLATFORM_WIN32_NT, L"", 0, 0, L"WinNT"},
+    { L"win2008r2", L"Windows 2008 R2", NULL,    6,  1,  7601,    0, VER_PLATFORM_WIN32_NT, L"Service Pack 1", 1, 0, L"ServerNT"},
+    { L"win7",      L"Windows 7",       NULL,    6,  1,  7601,    0, VER_PLATFORM_WIN32_NT, L"Service Pack 1", 1, 0, L"WinNT"},
+    { L"win2008",   L"Windows 2008",    NULL,    6,  0,  6002,    0, VER_PLATFORM_WIN32_NT, L"Service Pack 2", 2, 0, L"ServerNT"},
+    { L"vista",     L"Windows Vista",   NULL,    6,  0,  6002,    0, VER_PLATFORM_WIN32_NT, L"Service Pack 2", 2, 0, L"WinNT"},
+    { L"win2003",   L"Windows 2003",    NULL,    5,  2,  3790,    0, VER_PLATFORM_WIN32_NT, L"Service Pack 2", 2, 0, L"ServerNT"},
+    { L"winxp64",   L"Windows XP 64",   NULL,    5,  2,  3790,    0, VER_PLATFORM_WIN32_NT, L"Service Pack 2", 2, 0, L"WinNT"},
+    { L"winxp",     L"Windows XP",      NULL,    5,  1,  2600,    0, VER_PLATFORM_WIN32_NT, L"Service Pack 3", 3, 0, L"WinNT"},
+    { L"win2k",     L"Windows 2000",    NULL,    5,  0,  2195,    0, VER_PLATFORM_WIN32_NT, L"Service Pack 4", 4, 0, L"WinNT"},
+    { L"winme",     L"Windows ME",      NULL,    4, 90,  3000,    0, VER_PLATFORM_WIN32_WINDOWS, L" ", 0, 0, L""},
+    { L"win98",     L"Windows 98",      NULL,    4, 10,  2222,    0, VER_PLATFORM_WIN32_WINDOWS, L" A ", 0, 0, L""},
+    { L"win95",     L"Windows 95",      NULL,    4,  0,   950,    0, VER_PLATFORM_WIN32_WINDOWS, L"", 0, 0, L""},
+    { L"nt40",      L"Windows NT 4.0",  NULL,    4,  0,  1381,    0, VER_PLATFORM_WIN32_NT, L"Service Pack 6a", 6, 0, L"WinNT"},
+    { L"nt351",     L"Windows NT 3.51", NULL,    3, 51,  1057,    0, VER_PLATFORM_WIN32_NT, L"Service Pack 5", 5, 0, L"WinNT"},
+    { L"win31",     L"Windows 3.1",     NULL,    3, 10,     0,    0, VER_PLATFORM_WIN32s, L"Win32s 1.3", 0, 0, L""},
+    { L"win30",     L"Windows 3.0",     NULL,    3,  0,     0,    0, VER_PLATFORM_WIN32s, L"Win32s 1.3", 0, 0, L""},
+    { L"win20",     L"Windows 2.0",     NULL,    2,  0,     0,    0, VER_PLATFORM_WIN32s, L"Win32s 1.3", 0, 0, L""}
 };
 
 #define DEFAULT_WIN_VERSION   L"win10"
@@ -435,6 +436,7 @@ static void set_winver(const struct win_version *version)
             set_reg_key(HKEY_LOCAL_MACHINE, szKeyNT, L"CurrentBuild", NULL);
             set_reg_key(HKEY_LOCAL_MACHINE, szKeyNT, L"CurrentBuildNumber", NULL);
             set_reg_key(HKEY_LOCAL_MACHINE, szKeyNT, L"ProductName", NULL);
+            set_reg_key(HKEY_LOCAL_MACHINE, szKeyNT, L"UBR", NULL);
             set_reg_key(HKEY_LOCAL_MACHINE, szKeyProdNT, L"ProductType", NULL);
             set_reg_key(HKEY_LOCAL_MACHINE, szKeyWindNT, L"CSDVersion", NULL);
             set_reg_key(HKEY_LOCAL_MACHINE, szKeyEnvNT, L"OS", NULL);
@@ -449,6 +451,10 @@ static void set_winver(const struct win_version *version)
                 swprintf(buffer, ARRAY_SIZE(buffer), L"%d.%d", version->dwMajorVersion, version->dwMinorVersion);
                 set_reg_key(HKEY_LOCAL_MACHINE, szKeyNT, L"CurrentVersion", buffer);
             }
+            if (version->UBR)
+                set_reg_key_dword(HKEY_LOCAL_MACHINE, szKeyNT, L"UBR", version->UBR);
+            else
+                set_reg_key(HKEY_LOCAL_MACHINE, szKeyNT, L"UBR", NULL);
             set_reg_key_dword(HKEY_LOCAL_MACHINE, szKeyNT, L"CurrentMajorVersionNumber", version->dwMajorVersion);
             set_reg_key_dword(HKEY_LOCAL_MACHINE, szKeyNT, L"CurrentMinorVersionNumber", version->dwMinorVersion);
             set_reg_key(HKEY_LOCAL_MACHINE, szKeyNT, L"CSDVersion", version->szCSDVersion);
@@ -481,6 +487,7 @@ static void set_winver(const struct win_version *version)
             set_reg_key(HKEY_LOCAL_MACHINE, szKey9x, L"VersionNumber", NULL);
             set_reg_key(HKEY_LOCAL_MACHINE, szKey9x, L"SubVersionNumber", NULL);
             set_reg_key(HKEY_LOCAL_MACHINE, szKey9x, L"ProductName", NULL);
+            set_reg_key(HKEY_LOCAL_MACHINE, szKeyNT, L"UBR", NULL);
             set_reg_key(config_key, keypath(L""), L"Version", version->szVersion);
             break;
     }
-- 
2.49.0

From 5558f03ddb062854c4f1cd7585325689cf63c3da Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sat, 10 May 2025 01:54:58 -0400
Subject: [PATCH 38/78] winewayland: Don't use a destroyed surface in text
 input.

Co-Authored-By: Attila Fidan <dev@print0.net>
---
 dlls/winewayland.drv/wayland_surface.c    |  5 ++++
 dlls/winewayland.drv/wayland_text_input.c | 35 ++++++++++++-----------
 dlls/winewayland.drv/waylanddrv.h         |  2 +-
 3 files changed, 25 insertions(+), 17 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 76469a3bce4..24913df3234 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -238,6 +238,11 @@ void wayland_surface_destroy(struct wayland_surface *surface)
         process_wayland.keyboard.focused_hwnd = NULL;
     pthread_mutex_unlock(&process_wayland.keyboard.mutex);
 
+    pthread_mutex_lock(&process_wayland.text_input.mutex);
+    if (process_wayland.text_input.focused_hwnd == surface->hwnd)
+        process_wayland.text_input.focused_hwnd = NULL;
+    pthread_mutex_unlock(&process_wayland.text_input.mutex);
+
     wayland_surface_clear_role(surface);
 
     if (surface->wp_fractional_scale_v1)
diff --git a/dlls/winewayland.drv/wayland_text_input.c b/dlls/winewayland.drv/wayland_text_input.c
index e0181eb8240..f8df5fe09cb 100644
--- a/dlls/winewayland.drv/wayland_text_input.c
+++ b/dlls/winewayland.drv/wayland_text_input.c
@@ -61,16 +61,21 @@ static void text_input_enter(void *data, struct zwp_text_input_v3 *zwp_text_inpu
         struct wl_surface *surface)
 {
     struct wayland_text_input *text_input = data;
-    TRACE("data %p, text_input %p, surface %p.\n", data, zwp_text_input_v3, surface);
+    HWND hwnd;
+
+    if (!surface) return;
+
+    hwnd = wl_surface_get_user_data(surface);
+    TRACE("data %p, text_input %p, hwnd %p.\n", data, zwp_text_input_v3, hwnd);
 
     pthread_mutex_lock(&text_input->mutex);
+    text_input->focused_hwnd = hwnd;
     zwp_text_input_v3_enable(text_input->zwp_text_input_v3);
     zwp_text_input_v3_set_content_type(text_input->zwp_text_input_v3,
             ZWP_TEXT_INPUT_V3_CONTENT_HINT_NONE,
             ZWP_TEXT_INPUT_V3_CONTENT_PURPOSE_NORMAL);
     zwp_text_input_v3_set_cursor_rectangle(text_input->zwp_text_input_v3, 0, 0, 0, 0);
     zwp_text_input_v3_commit(text_input->zwp_text_input_v3);
-    text_input->wl_surface = surface;
     pthread_mutex_unlock(&text_input->mutex);
 }
 
@@ -78,16 +83,16 @@ static void text_input_leave(void *data, struct zwp_text_input_v3 *zwp_text_inpu
         struct wl_surface *surface)
 {
     struct wayland_text_input *text_input = data;
-    HWND hwnd;
-    TRACE("data %p, text_input %p, surface %p.\n", data, zwp_text_input_v3, surface);
+    TRACE("data %p, text_input %p.\n", data, zwp_text_input_v3);
 
     pthread_mutex_lock(&text_input->mutex);
     zwp_text_input_v3_disable(text_input->zwp_text_input_v3);
     zwp_text_input_v3_commit(text_input->zwp_text_input_v3);
-    assert(text_input->wl_surface);
-    hwnd = wl_surface_get_user_data(text_input->wl_surface);
-    post_ime_update(hwnd, 0, NULL, NULL);
-    text_input->wl_surface = NULL;
+    if (text_input->focused_hwnd)
+    {
+        post_ime_update(text_input->focused_hwnd, 0, NULL, NULL);
+        text_input->focused_hwnd = NULL;
+    }
     pthread_mutex_unlock(&text_input->mutex);
 }
 
@@ -127,18 +132,16 @@ static void text_input_done(void *data, struct zwp_text_input_v3 *zwp_text_input
         uint32_t serial)
 {
     struct wayland_text_input *text_input = data;
-    HWND hwnd;
     TRACE("data %p, text_input %p, serial %u.\n", data, zwp_text_input_v3, serial);
 
     pthread_mutex_lock(&text_input->mutex);
     /* Some compositors will send a done event for every commit, regardless of
      * the focus state of the text input. This behavior is arguably out of spec,
      * but otherwise harmless, so just ignore the new state in such cases. */
-    if (text_input->wl_surface)
+    if (text_input->focused_hwnd)
     {
-        hwnd = wl_surface_get_user_data(text_input->wl_surface);
-        post_ime_update(hwnd, text_input->preedit_cursor_pos, text_input->preedit_string,
-                text_input->commit_string);
+        post_ime_update(text_input->focused_hwnd, text_input->preedit_cursor_pos,
+                text_input->preedit_string, text_input->commit_string);
     }
 
     free(text_input->preedit_string);
@@ -177,7 +180,7 @@ void wayland_text_input_deinit(void)
     pthread_mutex_lock(&text_input->mutex);
     zwp_text_input_v3_destroy(text_input->zwp_text_input_v3);
     text_input->zwp_text_input_v3 = NULL;
-    text_input->wl_surface = NULL;
+    text_input->focused_hwnd = NULL;
     pthread_mutex_unlock(&text_input->mutex);
 };
 
@@ -194,13 +197,13 @@ BOOL WAYLAND_SetIMECompositionRect(HWND hwnd, RECT rect)
 
     pthread_mutex_lock(&text_input->mutex);
 
-    if (!text_input->zwp_text_input_v3)
+    if (!text_input->zwp_text_input_v3 || hwnd != text_input->focused_hwnd)
         goto err;
 
     if (!(data = wayland_win_data_get(hwnd)))
         goto err;
 
-    if (!(surface = data->wayland_surface) || surface->wl_surface != text_input->wl_surface)
+    if (!(surface = data->wayland_surface))
     {
         wayland_win_data_release(data);
         goto err;
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 0848d683ef7..1c2c29cc181 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -128,7 +128,7 @@ struct wayland_text_input
     WCHAR *preedit_string;
     DWORD preedit_cursor_pos;
     WCHAR *commit_string;
-    struct wl_surface *wl_surface;
+    HWND focused_hwnd;
     pthread_mutex_t mutex;
 };
 
-- 
2.49.0

From ee3f5401bf9f0350216fb156cd6ad372312379b1 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sat, 10 May 2025 12:22:40 -0400
Subject: [PATCH 39/78] hack: win32u: fix opengl applications on winewayland

---
 dlls/win32u/window.c                   | 3 ++-
 dlls/winewayland.drv/waylanddrv.h      | 1 +
 dlls/winewayland.drv/waylanddrv_main.c | 1 +
 dlls/winewayland.drv/window_surface.c  | 8 ++++++++
 4 files changed, 12 insertions(+), 1 deletion(-)

diff --git a/dlls/win32u/window.c b/dlls/win32u/window.c
index 82761d31753..65657fda6c3 100644
--- a/dlls/win32u/window.c
+++ b/dlls/win32u/window.c
@@ -2040,7 +2040,8 @@ static struct window_surface *get_window_surface( HWND hwnd, UINT swp_flags, BOO
     else if (create_layered || is_layered) needs_surface = TRUE;
 
     if (is_opengl && !is_layered && !create_layered
-        && !(!create_opaque && NtUserGetLayeredWindowAttributes( hwnd, NULL, NULL, &layered_flags ) && layered_flags & LWA_COLORKEY))
+        && !(!create_opaque && NtUserGetLayeredWindowAttributes( hwnd, NULL, NULL, &layered_flags ) && layered_flags & LWA_COLORKEY)
+        && !user_driver->pHasWindowManager("waylanddrv"))
     {
         if (new_surface) window_surface_release( new_surface );
         new_surface = NULL;
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 1c2c29cc181..dc069795d68 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -464,6 +464,7 @@ void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, HWND owner_hint, UIN
                               const struct window_rects *new_rects, struct window_surface *surface);
 BOOL WAYLAND_WindowPosChanging(HWND hwnd, UINT swp_flags, BOOL shaped, const struct window_rects *rects);
 BOOL WAYLAND_CreateWindowSurface(HWND hwnd, BOOL layered, const RECT *surface_rect, struct window_surface **surface);
+BOOL WAYLAND_HasWindowManager(const char *name);
 UINT WAYLAND_VulkanInit(UINT version, void *vulkan_handle, const struct vulkan_driver_funcs **driver_funcs);
 struct opengl_funcs *WAYLAND_wine_get_wgl_driver(UINT version);
 
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 640a70be20e..83a60848362 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -56,6 +56,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pWindowPosChanged = WAYLAND_WindowPosChanged,
     .pWindowPosChanging = WAYLAND_WindowPosChanging,
     .pCreateWindowSurface = WAYLAND_CreateWindowSurface,
+    .pHasWindowManager = WAYLAND_HasWindowManager,
     .pVulkanInit = WAYLAND_VulkanInit,
     .pwine_get_wgl_driver = WAYLAND_wine_get_wgl_driver,
 };
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index 36bbb2d4f67..094294fc40b 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -458,3 +458,11 @@ BOOL WAYLAND_CreateWindowSurface(HWND hwnd, BOOL layered, const RECT *surface_re
     wayland_win_data_release(data);
     return TRUE;
 }
+
+/***********************************************************************
+ *           WAYLAND_HasWindowManager
+ */
+BOOL WAYLAND_HasWindowManager(const char *name)
+{
+    return !strcmp("waylanddrv", name);
+}
-- 
2.49.0

From fd4d476bdbf555af221e4eb61bb03dc36d19566e Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sat, 10 May 2025 18:11:35 -0400
Subject: [PATCH 40/78] winewayland: register swap control tear

its up to compositor anyway, just no-op.
---
 dlls/winewayland.drv/opengl.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 0d7bf00ea0f..9d0aba68370 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -1244,6 +1244,7 @@ static BOOL init_opengl_funcs(void)
     opengl_funcs.ext.p_wglCreateContextAttribsARB = wayland_wglCreateContextAttribsARB;
 
     register_extension("WGL_EXT_swap_control");
+    register_extension("WGL_EXT_swap_control_tear");
     opengl_funcs.ext.p_wglGetSwapIntervalEXT = wayland_wglGetSwapIntervalEXT;
     opengl_funcs.ext.p_wglSwapIntervalEXT = wayland_wglSwapIntervalEXT;
 
-- 
2.49.0

From 6eddc313486d23cfb0bda6015d6d39c53dee26e3 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sun, 11 May 2025 21:38:39 -0400
Subject: [PATCH 41/78] check if FSR4_UPGRADE env is nonzero

---
 dlls/amdxc64/main.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/dlls/amdxc64/main.c b/dlls/amdxc64/main.c
index 754e22f914f..d4dd071b0e0 100644
--- a/dlls/amdxc64/main.c
+++ b/dlls/amdxc64/main.c
@@ -82,6 +82,7 @@ typedef HRESULT (__stdcall *updateffxapi_pfn)(void*, unsigned int);
 
 HRESULT STDMETHODCALLTYPE AMDFSR4FFX_UpdateFfxApiProvider(IAmdExtFfxApi *iface, void* data, unsigned int size)
 {
+    const char *env;
     updateffxapi_pfn pfn;
     HMODULE amdffx = LoadLibraryA("amdxcffx64");
 
@@ -94,10 +95,11 @@ HRESULT STDMETHODCALLTYPE AMDFSR4FFX_UpdateFfxApiProvider(IAmdExtFfxApi *iface,
     }
 
     pfn = (updateffxapi_pfn)GetProcAddress(amdffx, "UpdateFfxApiProvider");
+    env = getenv("FSR4_UPGRADE");
 
-    if(pfn && getenv("FSR4_UPGRADE"))
+    if(pfn && env && env[0] != '0')
     {
-        FIXME("replaced fsr3 with fsr4!\n");
+        FIXME("Replaced FSR3 with FSR4!\n");
         return pfn(data, size);
     }
 
-- 
2.49.0

From d55fcc6b1daf895641013cf8a9d10a8daa405861 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sun, 11 May 2025 23:10:42 -0400
Subject: [PATCH 42/78] fixup! winewayland: handle locking with fractional
 scale notification

ruh roh I started using fixup lmao
---
 dlls/winewayland.drv/wayland_surface.c | 25 +++++++++++++++++--------
 1 file changed, 17 insertions(+), 8 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 24913df3234..589016cfb8b 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -138,18 +138,27 @@ static const struct xdg_toplevel_listener xdg_toplevel_listener =
     xdg_toplevel_handle_close
 };
 
-void wp_fractional_scale_handle_scale(void* data,
+void wp_fractional_scale_handle_scale(void* user_data,
         struct wp_fractional_scale_v1 *fractional_scale_v1, uint32_t scale)
 {
-    double *data_scale;
+    struct wayland_win_data *data;
+    struct wayland_surface *surface;
+    HWND hwnd = user_data;
+    assert(hwnd);
 
-    assert(data);
-    data_scale = data;
+    if ((data = wayland_win_data_get(hwnd)))
+    {
+        if((surface = data->wayland_surface))
+        {
+            surface->window.fractional_scale = scale / 120.0;
+            surface->window.scale =
+                surface->window.fractional_scale * NtUserGetSystemDpiForProcess(0) / 96.0;
 
-    /* FIXME: handle locking! */
-    *data_scale = scale / 120.0;
+            TRACE("Got scale %lf\n", surface->window.fractional_scale);
+        }
 
-    TRACE("Got scale %lf\n", *data_scale);
+        wayland_win_data_release(data);
+    }
 }
 
 static const struct wp_fractional_scale_v1_listener wp_fractional_scale_listener =
@@ -206,7 +215,7 @@ struct wayland_surface *wayland_surface_create(HWND hwnd)
         wp_fractional_scale_v1_add_listener(
             surface->wp_fractional_scale_v1,
             &wp_fractional_scale_listener,
-            &surface->window.fractional_scale);
+            hwnd);
     }
 
     return surface;
-- 
2.49.0

From 63a0780b59898362046261e8f968c99b573715d0 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 2 May 2025 16:59:04 +0300
Subject: [PATCH 43/78] winewayland: Use ARGB buffers for shaped windows.

When we detect a shaped window, switch to ARGB buffers in order to
be able to apply the shape (in a follow-up commit).
---
 dlls/winewayland.drv/wayland_surface.c |  1 +
 dlls/winewayland.drv/waylanddrv.h      |  1 +
 dlls/winewayland.drv/window_surface.c  | 66 +++++++++++++++++++-------
 3 files changed, 52 insertions(+), 16 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 589016cfb8b..5fce2b5aa1c 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -850,6 +850,7 @@ struct wayland_shm_buffer *wayland_shm_buffer_create(int width, int height,
     shm_buffer->ref = 1;
     shm_buffer->width = width;
     shm_buffer->height = height;
+    shm_buffer->format = format;
     shm_buffer->map_size = size;
 
     shm_buffer->damage_region = NtGdiCreateRectRgn(0, 0, width, height);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index dc069795d68..b68a217004c 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -255,6 +255,7 @@ struct wayland_shm_buffer
     struct wl_list link;
     struct wl_buffer *wl_buffer;
     int width, height;
+    uint32_t format;
     void *map_data;
     size_t map_size;
     BOOL busy;
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index 094294fc40b..1caff588680 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -38,6 +38,7 @@ struct wayland_buffer_queue
     struct wl_list buffer_list;
     int width;
     int height;
+    uint32_t format;
 };
 
 struct wayland_window_surface
@@ -101,7 +102,8 @@ static void wayland_buffer_queue_destroy(struct wayland_buffer_queue *queue)
  *
  * Creates a buffer queue containing buffers with the specified width and height.
  */
-static struct wayland_buffer_queue *wayland_buffer_queue_create(int width, int height)
+static struct wayland_buffer_queue *wayland_buffer_queue_create(int width, int height,
+                                                                uint32_t format)
 {
     struct wayland_buffer_queue *queue;
 
@@ -112,6 +114,7 @@ static struct wayland_buffer_queue *wayland_buffer_queue_create(int width, int h
     if (!queue->wl_event_queue) goto err;
     queue->width = width;
     queue->height = height;
+    queue->format = format;
 
     wl_list_init(&queue->buffer_list);
 
@@ -153,7 +156,7 @@ static struct wayland_shm_buffer *wayland_buffer_queue_get_free_buffer(struct wa
         if (nbuffers < 3)
         {
             shm_buffer = wayland_shm_buffer_create(queue->width, queue->height,
-                                                   WL_SHM_FORMAT_XRGB8888);
+                                                   queue->format);
             if (shm_buffer)
             {
                 /* Buffer events go to their own queue so that we can dispatch
@@ -241,7 +244,7 @@ RGNDATA *get_region_data(HRGN region)
  */
 static void copy_pixel_region(const char *src_pixels, RECT *src_rect,
                               char *dst_pixels, RECT *dst_rect,
-                              HRGN region)
+                              HRGN region, BOOL force_opaque)
 {
     static const int bpp = WINEWAYLAND_BYTES_PER_PIXEL;
     RGNDATA *rgndata = get_region_data(region);
@@ -261,7 +264,7 @@ static void copy_pixel_region(const char *src_pixels, RECT *src_rect,
     {
         const char *src;
         char *dst;
-        int y, width_bytes, height;
+        int x, y, width, height;
         RECT rc;
 
         TRACE("rect %s\n", wine_dbgstr_rect(rgn_rect));
@@ -271,21 +274,39 @@ static void copy_pixel_region(const char *src_pixels, RECT *src_rect,
 
         src = src_pixels + (rc.top - src_rect->top) * src_stride + (rc.left - src_rect->left) * bpp;
         dst = dst_pixels + (rc.top - dst_rect->top) * dst_stride + (rc.left - dst_rect->left) * bpp;
-        width_bytes = (rc.right - rc.left) * bpp;
+        width = rc.right - rc.left;
         height = rc.bottom - rc.top;
 
         /* Fast path for full width rectangles. */
-        if (width_bytes == src_stride && width_bytes == dst_stride)
+        if (width * bpp == src_stride && src_stride == dst_stride)
         {
-            memcpy(dst, src, height * width_bytes);
+            if (force_opaque)
+            {
+                for (x = 0; x < height * width; ++x)
+                    ((UINT32 *)dst)[x] = ((UINT32 *)src)[x] | 0xff000000;
+            }
+            else memcpy(dst, src, height * width * 4);
             continue;
         }
 
-        for (y = 0; y < height; y++)
+        if (force_opaque)
         {
-            memcpy(dst, src, width_bytes);
-            src += src_stride;
-            dst += dst_stride;
+            for (y = 0; y < height; y++)
+            {
+                for (x = 0; x < width; ++x)
+                    ((UINT32 *)dst)[x] = ((UINT32 *)src)[x] | 0xff000000;
+                src += src_stride;
+                dst += dst_stride;
+            }
+        }
+        else
+        {
+            for (y = 0; y < height; y++)
+            {
+                memcpy(dst, src, width * 4);
+                src += src_stride;
+                dst += dst_stride;
+            }
         }
     }
 
@@ -297,11 +318,11 @@ static void copy_pixel_region(const char *src_pixels, RECT *src_rect,
  */
 static void wayland_shm_buffer_copy_data(struct wayland_shm_buffer *buffer,
                                          const char *bits, RECT *rect,
-                                         HRGN region)
+                                         HRGN region, BOOL force_opaque)
 {
     RECT buffer_rect = {0, 0, buffer->width, buffer->height};
     TRACE("buffer=%p bits=%p rect=%s\n", buffer, bits, wine_dbgstr_rect(rect));
-    copy_pixel_region(bits, rect, buffer->map_data, &buffer_rect, region);
+    copy_pixel_region(bits, rect, buffer->map_data, &buffer_rect, region, force_opaque);
 }
 
 static void wayland_shm_buffer_copy(struct wayland_shm_buffer *src,
@@ -311,7 +332,8 @@ static void wayland_shm_buffer_copy(struct wayland_shm_buffer *src,
     RECT src_rect = {0, 0, src->width, src->height};
     RECT dst_rect = {0, 0, dst->width, dst->height};
     TRACE("src=%p dst=%p\n", src, dst);
-    copy_pixel_region(src->map_data, &src_rect, dst->map_data, &dst_rect, region);
+    copy_pixel_region(src->map_data, &src_rect, dst->map_data, &dst_rect, region,
+                      src->format == WL_SHM_FORMAT_XRGB8888 && dst->format == WL_SHM_FORMAT_ARGB8888);
 }
 
 /***********************************************************************
@@ -327,6 +349,7 @@ static BOOL wayland_window_surface_flush(struct window_surface *window_surface,
     BOOL flushed = FALSE;
     HRGN surface_damage_region = NULL;
     HRGN copy_from_window_region;
+    uint32_t buffer_format;
 
     surface_damage_region = NtGdiCreateRectRgn(rect->left + dirty->left, rect->top + dirty->top,
                                                rect->left + dirty->right, rect->top + dirty->bottom);
@@ -336,6 +359,16 @@ static BOOL wayland_window_surface_flush(struct window_surface *window_surface,
         goto done;
     }
 
+    buffer_format = shape_bits ? WL_SHM_FORMAT_ARGB8888 : WL_SHM_FORMAT_XRGB8888;
+    if (wws->wayland_buffer_queue->format != buffer_format)
+    {
+        int width = wws->wayland_buffer_queue->width;
+        int height = wws->wayland_buffer_queue->height;
+        TRACE("recreating buffer queue with format %d\n", buffer_format);
+        wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
+        wws->wayland_buffer_queue = wayland_buffer_queue_create(width, height, buffer_format);
+    }
+
     wayland_buffer_queue_add_damage(wws->wayland_buffer_queue, surface_damage_region);
 
     shm_buffer = wayland_buffer_queue_get_free_buffer(wws->wayland_buffer_queue);
@@ -377,7 +410,8 @@ static BOOL wayland_window_surface_flush(struct window_surface *window_surface,
         copy_from_window_region = shm_buffer->damage_region;
     }
 
-    wayland_shm_buffer_copy_data(shm_buffer, color_bits, &surface_rect, copy_from_window_region);
+    wayland_shm_buffer_copy_data(shm_buffer, color_bits, &surface_rect, copy_from_window_region,
+                                 !!shape_bits);
     NtGdiSetRectRgn(shm_buffer->damage_region, 0, 0, 0, 0);
 
     flushed = set_window_surface_contents(window_surface->hwnd, shm_buffer, surface_damage_region);
@@ -433,7 +467,7 @@ static struct window_surface *wayland_window_surface_create(HWND hwnd, const REC
     if ((window_surface = window_surface_create(sizeof(*wws), &wayland_window_surface_funcs, hwnd, rect, info, 0)))
     {
         struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
-        wws->wayland_buffer_queue = wayland_buffer_queue_create(width, height);
+        wws->wayland_buffer_queue = wayland_buffer_queue_create(width, height, WL_SHM_FORMAT_XRGB8888);
     }
 
     return window_surface;
-- 
2.49.0

From 95666d3b80e870503ba621a77ebdcb8f121ec1f5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 28 Jun 2024 20:23:44 +0200
Subject: [PATCH 44/78] winewayland: Implement window surface shape and color
 keying.

---
 dlls/winewayland.drv/window_surface.c | 30 +++++++++++++++++++++++++++
 1 file changed, 30 insertions(+)

diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index 1caff588680..408f52f3f77 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -336,6 +336,34 @@ static void wayland_shm_buffer_copy(struct wayland_shm_buffer *src,
                       src->format == WL_SHM_FORMAT_XRGB8888 && dst->format == WL_SHM_FORMAT_ARGB8888);
 }
 
+/**********************************************************************
+ *          wayland_shm_buffer_copy_shape
+ */
+static void wayland_shm_buffer_copy_shape(struct wayland_shm_buffer *buffer, const RECT *dirty,
+                                          const BITMAPINFO *shape_info, const void *shape_bits)
+{
+    RECT dst_rect = {0, 0, buffer->width, buffer->height};
+    UINT32 *color, shape_stride, color_stride, x, y;
+    const BYTE *shape;
+    RECT rect;
+
+    shape_stride = shape_info->bmiHeader.biSizeImage / abs(shape_info->bmiHeader.biHeight);
+    color_stride = dst_rect.right - dst_rect.left;
+
+    if (!intersect_rect(&rect, &dst_rect, dirty)) return;
+
+    color = (UINT32 *)buffer->map_data + rect.top * color_stride;
+    shape = (const BYTE *)shape_bits + rect.top * shape_stride;
+
+    for (y = rect.top; y < rect.bottom; y++, color += color_stride, shape += shape_stride)
+    {
+        for (x = rect.left; x < rect.right; x++)
+        {
+            if (!(shape[x / 8] & (1 << (7 - (x & 7))))) color[x] = 0;
+        }
+    }
+}
+
 /***********************************************************************
  *           wayland_window_surface_flush
  */
@@ -412,6 +440,8 @@ static BOOL wayland_window_surface_flush(struct window_surface *window_surface,
 
     wayland_shm_buffer_copy_data(shm_buffer, color_bits, &surface_rect, copy_from_window_region,
                                  !!shape_bits);
+    if (shape_bits) wayland_shm_buffer_copy_shape(shm_buffer, rect, shape_info, shape_bits);
+
     NtGdiSetRectRgn(shm_buffer->damage_region, 0, 0, 0, 0);
 
     flushed = set_window_surface_contents(window_surface->hwnd, shm_buffer, surface_damage_region);
-- 
2.49.0

From a4ec31738ec1b7b0617ab5e397d7f72fcb41eedb Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Mon, 12 May 2025 08:52:18 -0400
Subject: [PATCH 45/78] minor formatting fix

---
 dlls/winewayland.drv/wayland_surface.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 5fce2b5aa1c..bbf307b982f 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -138,7 +138,7 @@ static const struct xdg_toplevel_listener xdg_toplevel_listener =
     xdg_toplevel_handle_close
 };
 
-void wp_fractional_scale_handle_scale(void* user_data,
+void wp_fractional_scale_handle_scale(void *user_data,
         struct wp_fractional_scale_v1 *fractional_scale_v1, uint32_t scale)
 {
     struct wayland_win_data *data;
-- 
2.49.0

From 05ca0ef0aadcea617b32ee8fec27558e706c006e Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Tue, 13 May 2025 16:29:55 -0400
Subject: [PATCH 46/78] ntdll: remove outdated workaround for rainbow six
 extraction

---
 dlls/ntdll/unix/loader.c | 7 -------
 1 file changed, 7 deletions(-)

diff --git a/dlls/ntdll/unix/loader.c b/dlls/ntdll/unix/loader.c
index 80b17e17b16..f673d96382e 100644
--- a/dlls/ntdll/unix/loader.c
+++ b/dlls/ntdll/unix/loader.c
@@ -2253,13 +2253,6 @@ static void hacks_init(void)
         ERR("HACK: setting LIBGL_ALWAYS_SOFTWARE.\n");
         setenv("LIBGL_ALWAYS_SOFTWARE", "1", 0);
     }
-
-    if (sgi && !strcmp(sgi, "2379390"))
-    {
-        ERR("HACK: setting vk_x11_override_min_image_count, vk_x11_strict_image_count.\n");
-        setenv("vk_x11_override_min_image_count", "2", 0);
-        setenv("vk_x11_strict_image_count", "true", 0);
-    }
 }
 
 /***********************************************************************
-- 
2.49.0

From a4c530c56e18b41c5dab2f1fca17028abee949b4 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Thu, 15 May 2025 10:12:42 -0400
Subject: [PATCH 47/78] HACK: kernelbase: Add Wayland specific workarounds.

---
 dlls/kernelbase/process.c | 38 ++++++++++++++++++++++++++++++++------
 1 file changed, 32 insertions(+), 6 deletions(-)

diff --git a/dlls/kernelbase/process.c b/dlls/kernelbase/process.c
index 7a51dfd231d..78b45e9fca8 100644
--- a/dlls/kernelbase/process.c
+++ b/dlls/kernelbase/process.c
@@ -584,13 +584,14 @@ static int battleye_launcher_redirect_hack( const WCHAR *app_name, WCHAR *new_na
 
 static const WCHAR *hack_append_command_line( const WCHAR *cmd )
 {
-    static const struct
+    struct option
     {
         const WCHAR *exe_name;
         const WCHAR *append;
         const char *steamgameid;
-    }
-    options[] =
+    };
+
+    static const struct option options[] =
     {
         {L"Click&Fight.exe", L" --disable_direct_composition=1"},
         {L"Willful.exe", L" --disable_direct_composition=1"},
@@ -620,8 +621,17 @@ static const WCHAR *hack_append_command_line( const WCHAR *cmd )
         {L"UnrealCEFSubProcess.exe", L" --use-angle=d3d9", "2684500"},
         {L"\\EACefSubProcess.exe", L" --use-angle=vulkan"},
     };
+
+    /* Generally just workarounds for winewayland not supporting cross process rendering (yet) */
+    static const struct option wayland_options[] = {
+        { L"launcher_epic.exe", L" --in-process-gpu"} /* ZZZ EGS */
+    };
+
     unsigned int i;
-    char sgi[64];
+    char sgi[64] = {0};
+    char wayland_hack_enabled[64] = {0};
+
+    GetEnvironmentVariableA("SteamGameId", sgi, sizeof(sgi));
 
     if (!cmd) return NULL;
 
@@ -629,13 +639,29 @@ static const WCHAR *hack_append_command_line( const WCHAR *cmd )
     {
         if (wcsstr( cmd, options[i].exe_name ))
         {
-            if (options[i].steamgameid && !(GetEnvironmentVariableA( "SteamGameId", sgi, sizeof(sgi) )
-                && !strcmp( sgi, options[i].steamgameid )))
+            if (options[i].steamgameid && strcmp( sgi, options[i].steamgameid ))
                 continue;
             FIXME( "HACK: appending %s to command line.\n", debugstr_w(options[i].append) );
             return options[i].append;
         }
     }
+
+    GetEnvironmentVariableA("WINE_WAYLAND_HACKS",
+            wayland_hack_enabled, sizeof(wayland_hack_enabled));
+
+    if (wayland_hack_enabled[0] != '1') return NULL;
+
+    for (i = 0; i < ARRAY_SIZE(wayland_options); ++i)
+    {
+        if (wcsstr( cmd, wayland_options[i].exe_name ))
+        {
+            if (wayland_options[i].steamgameid && strcmp( sgi, wayland_options[i].steamgameid ))
+                continue;
+            FIXME( "HACK: appending %s to command line.\n", debugstr_w(wayland_options[i].append) );
+            return wayland_options[i].append;
+        }
+    }
+
     return NULL;
 }
 
-- 
2.49.0

From 86580c1cd056b752e7770442da61399d60b9a7db Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Thu, 15 May 2025 10:17:06 -0400
Subject: [PATCH 48/78] fixup! kernelbase: Check for wayland hacks first

---
 dlls/kernelbase/process.c | 33 +++++++++++++++++----------------
 1 file changed, 17 insertions(+), 16 deletions(-)

diff --git a/dlls/kernelbase/process.c b/dlls/kernelbase/process.c
index 78b45e9fca8..2c4cc1e5b83 100644
--- a/dlls/kernelbase/process.c
+++ b/dlls/kernelbase/process.c
@@ -635,30 +635,31 @@ static const WCHAR *hack_append_command_line( const WCHAR *cmd )
 
     if (!cmd) return NULL;
 
-    for (i = 0; i < ARRAY_SIZE(options); ++i)
+    GetEnvironmentVariableA("WINE_WAYLAND_HACKS",
+        wayland_hack_enabled, sizeof(wayland_hack_enabled));
+
+    if (wayland_hack_enabled[0] == '1')
     {
-        if (wcsstr( cmd, options[i].exe_name ))
+        for (i = 0; i < ARRAY_SIZE(wayland_options); ++i)
         {
-            if (options[i].steamgameid && strcmp( sgi, options[i].steamgameid ))
-                continue;
-            FIXME( "HACK: appending %s to command line.\n", debugstr_w(options[i].append) );
-            return options[i].append;
+            if (wcsstr( cmd, wayland_options[i].exe_name ))
+            {
+                if (wayland_options[i].steamgameid && strcmp( sgi, wayland_options[i].steamgameid ))
+                    continue;
+                FIXME( "HACK: appending %s to command line.\n", debugstr_w(wayland_options[i].append) );
+                return wayland_options[i].append;
+            }
         }
     }
 
-    GetEnvironmentVariableA("WINE_WAYLAND_HACKS",
-            wayland_hack_enabled, sizeof(wayland_hack_enabled));
-
-    if (wayland_hack_enabled[0] != '1') return NULL;
-
-    for (i = 0; i < ARRAY_SIZE(wayland_options); ++i)
+    for (i = 0; i < ARRAY_SIZE(options); ++i)
     {
-        if (wcsstr( cmd, wayland_options[i].exe_name ))
+        if (wcsstr( cmd, options[i].exe_name ))
         {
-            if (wayland_options[i].steamgameid && strcmp( sgi, wayland_options[i].steamgameid ))
+            if (options[i].steamgameid && strcmp( sgi, options[i].steamgameid ))
                 continue;
-            FIXME( "HACK: appending %s to command line.\n", debugstr_w(wayland_options[i].append) );
-            return wayland_options[i].append;
+            FIXME( "HACK: appending %s to command line.\n", debugstr_w(options[i].append) );
+            return options[i].append;
         }
     }
 
-- 
2.49.0

From fde125c53eb144b070331809ccaec5db7311b240 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Thu, 15 May 2025 11:19:18 -0400
Subject: [PATCH 49/78] formatting fix

---
 dlls/kernelbase/process.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/kernelbase/process.c b/dlls/kernelbase/process.c
index 2c4cc1e5b83..2f609cbba8d 100644
--- a/dlls/kernelbase/process.c
+++ b/dlls/kernelbase/process.c
@@ -624,7 +624,7 @@ static const WCHAR *hack_append_command_line( const WCHAR *cmd )
 
     /* Generally just workarounds for winewayland not supporting cross process rendering (yet) */
     static const struct option wayland_options[] = {
-        { L"launcher_epic.exe", L" --in-process-gpu"} /* ZZZ EGS */
+        {L"launcher_epic.exe", L" --in-process-gpu"}, /* ZZZ EGS */
     };
 
     unsigned int i;
-- 
2.49.0

From a87ca6624de203c6128e637d052c347e3ddce29f Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Thu, 15 May 2025 13:47:59 -0400
Subject: [PATCH 50/78] kernelbase: Enable in-process-gpu for battle.net

---
 dlls/kernelbase/process.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/kernelbase/process.c b/dlls/kernelbase/process.c
index 2f609cbba8d..f0534eff8c0 100644
--- a/dlls/kernelbase/process.c
+++ b/dlls/kernelbase/process.c
@@ -625,16 +625,16 @@ static const WCHAR *hack_append_command_line( const WCHAR *cmd )
     /* Generally just workarounds for winewayland not supporting cross process rendering (yet) */
     static const struct option wayland_options[] = {
         {L"launcher_epic.exe", L" --in-process-gpu"}, /* ZZZ EGS */
+        {L"Battle.net.exe", L" --in-process-gpu"},
     };
 
     unsigned int i;
     char sgi[64] = {0};
     char wayland_hack_enabled[64] = {0};
 
-    GetEnvironmentVariableA("SteamGameId", sgi, sizeof(sgi));
-
     if (!cmd) return NULL;
 
+    GetEnvironmentVariableA("SteamGameId", sgi, sizeof(sgi));
     GetEnvironmentVariableA("WINE_WAYLAND_HACKS",
         wayland_hack_enabled, sizeof(wayland_hack_enabled));
 
-- 
2.49.0

From f05f47d789ae1611d82db331c86ec4409e243750 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Thu, 15 May 2025 16:11:24 -0400
Subject: [PATCH 51/78] kernelbase: Add in-process-gpu for RSI launcher

---
 dlls/kernelbase/process.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/kernelbase/process.c b/dlls/kernelbase/process.c
index f0534eff8c0..4797d30dc8f 100644
--- a/dlls/kernelbase/process.c
+++ b/dlls/kernelbase/process.c
@@ -626,6 +626,7 @@ static const WCHAR *hack_append_command_line( const WCHAR *cmd )
     static const struct option wayland_options[] = {
         {L"launcher_epic.exe", L" --in-process-gpu"}, /* ZZZ EGS */
         {L"Battle.net.exe", L" --in-process-gpu"},
+        {L"RSI Launcher.exe", L" --in-process-gpu"}
     };
 
     unsigned int i;
-- 
2.49.0

From 2e157aa6cd2cfe8e0dcc1c8370181dcbe0d9f7ef Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Thu, 15 May 2025 16:14:54 -0400
Subject: [PATCH 52/78] winewayland: Implement touchpad scrolling support.

I hate this so much, but it's the best we can do I think
---
 dlls/winewayland.drv/wayland_pointer.c | 74 ++++++++++++++++++--------
 dlls/winewayland.drv/waylanddrv.h      |  2 +
 2 files changed, 53 insertions(+), 23 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index ebd09d87b2a..86443e3fd75 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -270,6 +270,57 @@ static void pointer_handle_button(void *data, struct wl_pointer *wl_pointer,
 static void pointer_handle_axis(void *data, struct wl_pointer *wl_pointer,
                                 uint32_t time, uint32_t axis, wl_fixed_t value)
 {
+    HWND hwnd;
+    INPUT input = {0};
+    /*
+        We are given a distance in the surface local coordinate system.
+        However, we need to convert that into a WHEEL_DELTA which represents
+        physical mouse wheel motion. Using default settings on KDE Plasma,
+        I obtained a value of 15 for one mouse wheel click. So that is the
+        value I have chosen for now. However, what do other compositors default to?
+        Additionally, the system's scroll sensitivity now affects winewayland,
+        is that going to cause issues?
+
+        So many unknowns for such a seemingly trivial task :(
+        just because we are trying to support touchpads...
+    */
+    double scroll_value = (wl_fixed_to_double(value) / 15.0) * WHEEL_DELTA;
+    struct wayland_pointer *pointer = &process_wayland.pointer;
+
+    if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
+
+    input.type = INPUT_MOUSE;
+
+    /*
+        Truncation makes the most sense:
+        Imagine a infinite resolution scroll wheel
+        Assume that input axis value is some fraction of a tick
+        Accumulate input axis value * WHEEL_DELTA
+        Truncate to WHEEL_DELTA precision
+        Do subtraction on original value
+        Leftover accumulation is just leftover rotation on the wheel
+    */
+    switch (axis)
+    {
+        case WL_POINTER_AXIS_VERTICAL_SCROLL:
+            input.mi.dwFlags = MOUSEEVENTF_WHEEL;
+            pointer->accum_wheel += -scroll_value;
+            input.mi.mouseData = trunc(pointer->accum_wheel / WHEEL_DELTA) * WHEEL_DELTA;
+            pointer->accum_wheel -= (int)input.mi.mouseData;
+            break;
+        case WL_POINTER_AXIS_HORIZONTAL_SCROLL:
+            input.mi.dwFlags = MOUSEEVENTF_HWHEEL;
+            pointer->accum_wheelH += scroll_value;
+            input.mi.mouseData = trunc(pointer->accum_wheelH / WHEEL_DELTA) * WHEEL_DELTA;
+            pointer->accum_wheelH -= (int)input.mi.mouseData;
+            break;
+        default: break;
+    }
+
+    TRACE("hwnd=%p axis=%u value=%lf out=%d\n", hwnd, axis, scroll_value, (int)input.mi.mouseData);
+
+    if (input.mi.mouseData)
+        NtUserSendHardwareInput(hwnd, 0, &input, 0);
 }
 
 static void pointer_handle_frame(void *data, struct wl_pointer *wl_pointer)
@@ -289,29 +340,6 @@ static void pointer_handle_axis_stop(void *data, struct wl_pointer *wl_pointer,
 static void pointer_handle_axis_discrete(void *data, struct wl_pointer *wl_pointer,
                                          uint32_t axis, int32_t discrete)
 {
-    INPUT input = {0};
-    HWND hwnd;
-
-    if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
-
-    input.type = INPUT_MOUSE;
-
-    switch (axis)
-    {
-    case WL_POINTER_AXIS_VERTICAL_SCROLL:
-        input.mi.dwFlags = MOUSEEVENTF_WHEEL;
-        input.mi.mouseData = -WHEEL_DELTA * discrete;
-        break;
-    case WL_POINTER_AXIS_HORIZONTAL_SCROLL:
-        input.mi.dwFlags = MOUSEEVENTF_HWHEEL;
-        input.mi.mouseData = WHEEL_DELTA * discrete;
-        break;
-    default: break;
-    }
-
-    TRACE("hwnd=%p axis=%u discrete=%d\n", hwnd, axis, discrete);
-
-    NtUserSendHardwareInput(hwnd, 0, &input, 0);
 }
 
 static const struct wl_pointer_listener pointer_listener =
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index b68a217004c..7a800c607ed 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -119,6 +119,8 @@ struct wayland_pointer
     struct wayland_cursor cursor;
     double accum_x;
     double accum_y;
+    double accum_wheel;
+    double accum_wheelH;
     pthread_mutex_t mutex;
 };
 
-- 
2.49.0

From 600f42086f8e03910ec3e2aa6fd7c178db0e094f Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Thu, 15 May 2025 19:22:47 -0400
Subject: [PATCH 53/78] winewayland: Use unaccelerated relative motion.

---
 dlls/winewayland.drv/wayland_pointer.c | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 86443e3fd75..f3e4c51a576 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -383,9 +383,10 @@ static void relative_pointer_v1_relative_motion(void *private,
     if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
     if (!(data = wayland_win_data_get(hwnd))) return;
 
+    /* Use "raw" input by default. However, it's not nessessarily raw */
     wayland_motion_delta_to_window(data->wayland_surface,
-                                   wl_fixed_to_double(dx),
-                                   wl_fixed_to_double(dy),
+                                   wl_fixed_to_double(dx_unaccel),
+                                   wl_fixed_to_double(dy_unaccel),
                                    &screen_x, &screen_y);
     wayland_win_data_release(data);
 
@@ -405,7 +406,7 @@ static void relative_pointer_v1_relative_motion(void *private,
     pthread_mutex_unlock(&pointer->mutex);
 
     TRACE("hwnd=%p wayland_dxdy=%.2f,%.2f accum_dxdy=%d,%d\n",
-          hwnd, wl_fixed_to_double(dx), wl_fixed_to_double(dy),
+          hwnd, wl_fixed_to_double(dx_unaccel), wl_fixed_to_double(dy_unaccel),
           (int)input.mi.dx, (int)input.mi.dy);
 
     NtUserSendHardwareInput(hwnd, 0, &input, 0);
-- 
2.49.0

From 934a57d6f91479233d779e4fc5e4937346dad374 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Thu, 15 May 2025 19:55:01 -0400
Subject: [PATCH 54/78] winewayland: Use discrete event when possible.

---
 dlls/winewayland.drv/wayland_pointer.c | 30 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  1 +
 2 files changed, 31 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index f3e4c51a576..cc1941cece2 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -281,6 +281,9 @@ static void pointer_handle_axis(void *data, struct wl_pointer *wl_pointer,
         Additionally, the system's scroll sensitivity now affects winewayland,
         is that going to cause issues?
 
+        We can alleviate these issues for physical scroll wheels using the discrete
+        event at least.
+
         So many unknowns for such a seemingly trivial task :(
         just because we are trying to support touchpads...
     */
@@ -288,6 +291,7 @@ static void pointer_handle_axis(void *data, struct wl_pointer *wl_pointer,
     struct wayland_pointer *pointer = &process_wayland.pointer;
 
     if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
+    if (InterlockedCompareExchange(&pointer->discrete_event_handled, FALSE, TRUE)) return;
 
     input.type = INPUT_MOUSE;
 
@@ -340,6 +344,32 @@ static void pointer_handle_axis_stop(void *data, struct wl_pointer *wl_pointer,
 static void pointer_handle_axis_discrete(void *data, struct wl_pointer *wl_pointer,
                                          uint32_t axis, int32_t discrete)
 {
+    INPUT input = {0};
+    HWND hwnd;
+    struct wayland_pointer *pointer = &process_wayland.pointer;
+
+    if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
+
+    InterlockedExchange(&pointer->discrete_event_handled, TRUE);
+
+    input.type = INPUT_MOUSE;
+
+    switch (axis)
+    {
+        case WL_POINTER_AXIS_VERTICAL_SCROLL:
+            input.mi.dwFlags = MOUSEEVENTF_WHEEL;
+            input.mi.mouseData = -WHEEL_DELTA * discrete;
+            break;
+        case WL_POINTER_AXIS_HORIZONTAL_SCROLL:
+            input.mi.dwFlags = MOUSEEVENTF_HWHEEL;
+            input.mi.mouseData = WHEEL_DELTA * discrete;
+            break;
+        default: break;
+    }
+
+    TRACE("hwnd=%p axis=%u discrete=%d\n", hwnd, axis, discrete);
+
+    NtUserSendHardwareInput(hwnd, 0, &input, 0);
 }
 
 static const struct wl_pointer_listener pointer_listener =
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 7a800c607ed..26208dae23c 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -121,6 +121,7 @@ struct wayland_pointer
     double accum_y;
     double accum_wheel;
     double accum_wheelH;
+    LONG discrete_event_handled;
     pthread_mutex_t mutex;
 };
 
-- 
2.49.0

From aaaa1bb2de3c52c16c554801decf9a5286ea7732 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sat, 17 May 2025 15:08:08 -0400
Subject: [PATCH 55/78] winewayland: Handle rotated screens.

Some win32u issues with vertical monitors? But works exactly the same as winex11 so I think this is a win
---
 dlls/winewayland.drv/wayland_output.c | 19 +++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h     |  1 +
 2 files changed, 20 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index f76881a1770..ce388d02f21 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -39,6 +39,7 @@ static uint32_t next_output_id = 0;
 #define WAYLAND_OUTPUT_CHANGED_NAME       0x02
 #define WAYLAND_OUTPUT_CHANGED_LOGICAL_XY 0x04
 #define WAYLAND_OUTPUT_CHANGED_LOGICAL_WH 0x08
+#define WAYLAND_OUTPUT_CHANGED_TRANSFORM  0x10
 
 /**********************************************************************
  *          Output handling
@@ -139,6 +140,14 @@ static void wayland_output_done(struct wayland_output *output)
     {
         RB_FOR_EACH_ENTRY(mode, &output->pending.modes, struct wayland_output_mode, entry)
         {
+            /* Need to flip w,h when the output is transformed by 90 or 270 degrees */
+            if (output->pending.transform == WL_OUTPUT_TRANSFORM_270 ||
+                output->pending.transform == WL_OUTPUT_TRANSFORM_90)
+            {
+                const int32_t temp = mode->width;
+                mode->width = mode->height;
+                mode->height = temp;
+            }
             wayland_output_state_add_mode(&output->current,
                                           mode->width, mode->height, mode->refresh,
                                           mode == output->pending.current_mode);
@@ -167,6 +176,11 @@ static void wayland_output_done(struct wayland_output *output)
         output->current.logical_h = output->pending.logical_h;
     }
 
+    if (output->pending_flags & WAYLAND_OUTPUT_CHANGED_TRANSFORM)
+    {
+        output->current.transform = output->pending.transform;
+    }
+
     output->pending_flags = 0;
 
     /* Ensure the logical dimensions have sane values. */
@@ -200,6 +214,11 @@ static void output_handle_geometry(void *data, struct wl_output *wl_output,
                                    const char *make, const char *model,
                                    int32_t output_transform)
 {
+    struct wayland_output *output = data;
+
+    output->pending.transform = output_transform;
+
+    output->pending_flags |= WAYLAND_OUTPUT_CHANGED_TRANSFORM;
 }
 
 static void output_handle_mode(void *data, struct wl_output *wl_output,
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 26208dae23c..b4afe72e1a7 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -209,6 +209,7 @@ struct wayland_output_state
     char *name;
     int logical_x, logical_y;
     int logical_w, logical_h;
+    int transform;
 };
 
 struct wayland_output
-- 
2.49.0

From 7d1378598252b813ff1ca2e430c678d235edf9ad Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Mon, 19 May 2025 20:33:06 -0400
Subject: [PATCH 56/78] winebus: Fix PROTON_ENABLE/DISABLE_HIDRAW.

---
 dlls/winebus.sys/main.c    | 37 ++++++-------------------------------
 dlls/winebus.sys/unixlib.c | 22 ++++++++++++++++++++++
 dlls/winebus.sys/unixlib.h |  9 +++++++++
 3 files changed, 37 insertions(+), 31 deletions(-)

diff --git a/dlls/winebus.sys/main.c b/dlls/winebus.sys/main.c
index 858c89d7d5a..970e12f0810 100644
--- a/dlls/winebus.sys/main.c
+++ b/dlls/winebus.sys/main.c
@@ -433,31 +433,14 @@ static DWORD check_bus_option(const WCHAR *option, DWORD default_value)
     return default_value;
 }
 
-static const WCHAR *wcscasestr(const WCHAR *search, const WCHAR *needle)
-{
-    UNICODE_STRING search_str, needle_str;
-
-    RtlInitUnicodeString(&search_str, search);
-    RtlInitUnicodeString(&needle_str, needle);
-
-    while (needle_str.Length <= search_str.Length)
-    {
-        if (!RtlCompareUnicodeString(&search_str, &needle_str, TRUE)) return search_str.Buffer;
-        search_str.Length -= sizeof(WCHAR);
-        search_str.Buffer += 1;
-    }
-
-    return NULL;
-}
-
 static BOOL is_hidraw_enabled(WORD vid, WORD pid, const USAGE_AND_PAGE *usages, UINT buttons)
 {
     char buffer[FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data[1024])];
     KEY_VALUE_PARTIAL_INFORMATION *info = (KEY_VALUE_PARTIAL_INFORMATION *)buffer;
-    WCHAR vidpid[MAX_PATH], *tmp, value[1024];
+    struct hidraw_enabled_params params = {0};
+    WCHAR vidpid[MAX_PATH], *tmp;
     BOOL prefer_hidraw = FALSE;
     UNICODE_STRING str;
-    SIZE_T len;
     DWORD size;
 
     if (check_bus_option(L"DisableHidraw", FALSE)) return FALSE;
@@ -468,19 +451,11 @@ static BOOL is_hidraw_enabled(WORD vid, WORD pid, const USAGE_AND_PAGE *usages,
         return FALSE;
     }
 
-    if (!RtlQueryEnvironmentVariable(NULL, L"PROTON_DISABLE_HIDRAW", 20, value, ARRAY_SIZE(value) - 1, &len))
-    {
-        value[len] = 0;
-        if (!wcscmp(value, L"1")) return FALSE;
-        swprintf(vidpid, ARRAY_SIZE(vidpid), L"0x%04X/0x%04X", vid, pid);
-        if (wcscasestr(value, vidpid)) return FALSE;
-    }
-    if (!RtlQueryEnvironmentVariable(NULL, L"PROTON_ENABLE_HIDRAW", 20, value, ARRAY_SIZE(value) - 1, &len))
+    params.vid = vid;
+    params.pid = pid;
+    if (!winebus_call(hidraw_enabled, &params) && params.env_set)
     {
-        value[len] = 0;
-        if (!wcscmp(value, L"1")) return TRUE;
-        swprintf(vidpid, ARRAY_SIZE(vidpid), L"0x%04X/0x%04X", vid, pid);
-        if (wcscasestr(value, vidpid)) return TRUE;
+        return params.enabled;
     }
 
     if (usages->UsagePage == HID_USAGE_PAGE_DIGITIZER)
diff --git a/dlls/winebus.sys/unixlib.c b/dlls/winebus.sys/unixlib.c
index bd4351f059c..da5d4502f45 100644
--- a/dlls/winebus.sys/unixlib.c
+++ b/dlls/winebus.sys/unixlib.c
@@ -300,6 +300,27 @@ static NTSTATUS unix_device_set_feature_report(void *args)
     return STATUS_SUCCESS;
 }
 
+static NTSTATUS unix_hidraw_enabled(void *args)
+{
+    char *value;
+    char vidpid[MAX_PATH] = {0};
+    struct hidraw_enabled_params *params = args;
+
+    if ((value = getenv("PROTON_DISABLE_HIDRAW")))
+    {
+        if (!strcmp(value, "1")) { params->enabled = FALSE; params->env_set = TRUE; }
+        snprintf(vidpid, ARRAY_SIZE(vidpid), "0x%04X/0x%04X", params->vid, params->pid);
+        if (strcasestr(value, vidpid)) { params->enabled = FALSE; params->env_set = TRUE; }
+    } else if ((value = getenv("PROTON_ENABLE_HIDRAW")))
+    {
+        if (!strcmp(value, "1")) { params->enabled = TRUE; params->env_set = TRUE; }
+        snprintf(vidpid, ARRAY_SIZE(vidpid), "0x%04X/0x%04X", params->vid, params->pid);
+        if (strcasestr(value, vidpid)) { params->enabled = TRUE; params->env_set = TRUE; }
+    }
+
+    return STATUS_SUCCESS;
+}
+
 const unixlib_entry_t __wine_unix_call_funcs[] =
 {
     sdl_bus_init,
@@ -319,6 +340,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     unix_device_set_output_report,
     unix_device_get_feature_report,
     unix_device_set_feature_report,
+    unix_hidraw_enabled
 };
 
 C_ASSERT(ARRAYSIZE(__wine_unix_call_funcs) == unix_funcs_count);
diff --git a/dlls/winebus.sys/unixlib.h b/dlls/winebus.sys/unixlib.h
index 02e7a1c6953..2b97512106e 100644
--- a/dlls/winebus.sys/unixlib.h
+++ b/dlls/winebus.sys/unixlib.h
@@ -125,6 +125,14 @@ struct device_report_params
     IO_STATUS_BLOCK *io;
 };
 
+struct hidraw_enabled_params
+{
+    unsigned short vid;
+    unsigned short pid;
+    BOOL env_set;
+    BOOL enabled;
+};
+
 enum unix_funcs
 {
     sdl_init,
@@ -144,6 +152,7 @@ enum unix_funcs
     device_set_output_report,
     device_get_feature_report,
     device_set_feature_report,
+    hidraw_enabled,
     unix_funcs_count,
 };
 
-- 
2.49.0

From 276e5f2054e4e84a089e72f3e960b6d063a23afa Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Wed, 21 May 2025 19:43:39 -0400
Subject: [PATCH 57/78] fixup! winewayland: Handle rotated screens.

---
 dlls/winewayland.drv/wayland_output.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index ce388d02f21..dbd51fbc8dc 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -141,8 +141,7 @@ static void wayland_output_done(struct wayland_output *output)
         RB_FOR_EACH_ENTRY(mode, &output->pending.modes, struct wayland_output_mode, entry)
         {
             /* Need to flip w,h when the output is transformed by 90 or 270 degrees */
-            if (output->pending.transform == WL_OUTPUT_TRANSFORM_270 ||
-                output->pending.transform == WL_OUTPUT_TRANSFORM_90)
+            if (output->pending.transform & WL_OUTPUT_TRANSFORM_90)
             {
                 const int32_t temp = mode->width;
                 mode->width = mode->height;
-- 
2.49.0

From aeb55ae95be047f5ce9f7cacb11c16ac7e590ee8 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Thu, 22 May 2025 21:50:42 -0400
Subject: [PATCH 58/78] winewayland: make wp_fractional_scale_handle_scale
 static

---
 dlls/winewayland.drv/wayland_surface.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index bbf307b982f..f07f995a39e 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -138,7 +138,7 @@ static const struct xdg_toplevel_listener xdg_toplevel_listener =
     xdg_toplevel_handle_close
 };
 
-void wp_fractional_scale_handle_scale(void *user_data,
+static void wp_fractional_scale_handle_scale(void *user_data,
         struct wp_fractional_scale_v1 *fractional_scale_v1, uint32_t scale)
 {
     struct wayland_win_data *data;
-- 
2.49.0

From e59be0b6633cee126ce496a28e98cf5b56249096 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Thu, 22 May 2025 21:51:13 -0400
Subject: [PATCH 59/78] winewayland: Place fullscreen windows on associated
 output.

---
 dlls/winewayland.drv/display.c    |  7 ++++++
 dlls/winewayland.drv/waylanddrv.h |  6 +++++
 dlls/winewayland.drv/window.c     | 41 ++++++++++++++++++++++++++++++-
 3 files changed, 53 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index 851c9638252..c5d599efb54 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -180,6 +180,13 @@ static void output_info_array_arrange_physical_coords(struct wl_array *output_in
            ++steps < num_outputs)
         continue;
 
+    /* Initialize resolved coordinates with updated coordinates */
+    wl_array_for_each(info, output_info_array)
+    {
+        info->output->resolved_x = info->x;
+        info->output->resolved_y = info->y;
+    }
+
     /* Now that we have our physical pixel coordinates, sort from physical left
      * to right, but ensure the primary output is first. */
     qsort(output_info_array->data, num_outputs, sizeof(struct output_info),
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index b4afe72e1a7..52a4f1b160c 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -207,6 +207,7 @@ struct wayland_output_state
     struct rb_tree modes;
     struct wayland_output_mode *current_mode;
     char *name;
+    int resolved_x, resolved_y; /* store positions post overlap correction */
     int logical_x, logical_y;
     int logical_w, logical_h;
     int transform;
@@ -442,6 +443,11 @@ static inline BOOL intersect_rect(RECT *dst, const RECT *src1, const RECT *src2)
     return !IsRectEmpty(dst);
 }
 
+static inline LONG area_rect(const RECT *rect)
+{
+    return (rect->bottom - rect->top) * (rect->right - rect->left);
+}
+
 static inline LRESULT send_message(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
 {
     return NtUserMessageCall(hwnd, msg, wparam, lparam, NULL, NtUserSendMessage, FALSE);
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 648792616af..70b3c2080c0 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -239,6 +239,42 @@ static BOOL wayland_win_data_create_wayland_surface(struct wayland_win_data *dat
     return TRUE;
 }
 
+static struct wl_output *wayland_surface_get_best_output(struct wayland_surface *surface)
+{
+    struct wayland_output *output;
+    struct wl_output *best = NULL;
+    RECT output_rect, temp, intersect = {0};
+    const RECT *window_rect = &surface->window.rect;
+
+    wl_list_for_each(output, &process_wayland.output_list, link)
+    {
+        SetRect(&output_rect, 0, 0,
+                output->current.current_mode->width,
+                output->current.current_mode->height);
+        OffsetRect(&output_rect,
+                output->current.resolved_x,
+                output->current.resolved_y);
+
+        TRACE("output %s, %s window %s\n",
+              output->current.name,
+              wine_dbgstr_rect(&output_rect),
+              wine_dbgstr_rect(window_rect));
+
+        if (intersect_rect(&temp, window_rect, &output_rect) &&
+                area_rect(&temp) > area_rect(&intersect))
+        {
+            intersect = temp;
+            best = output->wl_output;
+        }
+    }
+
+    if (!best)
+        WARN("Could not find associated wl_output for rect %s!\n",
+             wine_dbgstr_rect(window_rect));
+
+    return best;
+}
+
 static void wayland_surface_update_state_toplevel(struct wayland_surface *surface)
 {
     BOOL processing_config = surface->processing.serial &&
@@ -274,7 +310,10 @@ static void wayland_surface_update_state_toplevel(struct wayland_surface *surfac
         if ((surface->window.state & WAYLAND_SURFACE_CONFIG_STATE_FULLSCREEN) &&
            !(surface->current.state & WAYLAND_SURFACE_CONFIG_STATE_FULLSCREEN))
         {
-            xdg_toplevel_set_fullscreen(surface->xdg_toplevel, NULL);
+            pthread_mutex_lock(&process_wayland.output_mutex);
+            xdg_toplevel_set_fullscreen(surface->xdg_toplevel,
+                        wayland_surface_get_best_output(surface));
+            pthread_mutex_unlock(&process_wayland.output_mutex);
         }
     }
     else
-- 
2.49.0

From 9932acd3dabc1b59679ed5b81aa0a4490081b015 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Fri, 23 May 2025 14:02:30 -0400
Subject: [PATCH 60/78] HACK: ntdll: Ignore SDL_VIDEODRIVER env

---
 dlls/ntdll/unix/env.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/ntdll/unix/env.c b/dlls/ntdll/unix/env.c
index 3c18484f417..98389c75ca6 100644
--- a/dlls/ntdll/unix/env.c
+++ b/dlls/ntdll/unix/env.c
@@ -347,6 +347,7 @@ static BOOL is_special_env_var( const char *var )
             STARTS_WITH( var, "TMP=" ) ||
             STARTS_WITH( var, "QT_" ) ||
             STARTS_WITH( var, "SDL_AUDIODRIVER=" ) ||
+            STARTS_WITH( var, "SDL_VIDEODRIVER=" ) || /* the only allowed video driver on windows is windows */
             STARTS_WITH( var, "VK_" ) ||
             STARTS_WITH( var, "XR_" ) ||
             STARTS_WITH( var, "XDG_SESSION_TYPE=" ));
-- 
2.49.0

From 8dd186470fe61205cd747c7284e4424ec1a6bc3b Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Fri, 23 May 2025 14:09:14 -0400
Subject: [PATCH 61/78] fixup! winewayland: Place fullscreen windows on
 associated output.

---
 dlls/winewayland.drv/wayland_output.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index dbd51fbc8dc..73b0b8332c5 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -167,6 +167,8 @@ static void wayland_output_done(struct wayland_output *output)
     {
         output->current.logical_x = output->pending.logical_x;
         output->current.logical_y = output->pending.logical_y;
+        output->current.resolved_x = output->current.logical_x;
+        output->current.resolved_y = output->current.logical_y;
     }
 
     if (output->pending_flags & WAYLAND_OUTPUT_CHANGED_LOGICAL_WH)
-- 
2.49.0

From 4a9e6b8a172c279390a9c300c38ca54cbfe5e0bd Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Fri, 23 May 2025 17:45:55 -0400
Subject: [PATCH 62/78] HACK: winewayland: Support output switching

---
 dlls/winewayland.drv/wayland_surface.c | 114 +++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |   2 +
 dlls/winewayland.drv/window.c          |  36 --------
 3 files changed, 116 insertions(+), 36 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index f07f995a39e..3de12a1afe2 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -166,6 +166,66 @@ static const struct wp_fractional_scale_v1_listener wp_fractional_scale_listener
     wp_fractional_scale_handle_scale
 };
 
+static void wl_surface_handle_enter(void *user_data, struct wl_surface *wl_surface, struct wl_output *wl_output)
+{
+    struct wayland_win_data *data;
+    struct wayland_output *output;
+    HWND hwnd = user_data;
+
+    if ((data = wayland_win_data_get(hwnd)))
+    {
+        if (data->wayland_surface)
+        {
+            pthread_mutex_lock(&process_wayland.output_mutex);
+            wl_list_for_each(output, &process_wayland.output_list, link)
+            {
+                if (output->wl_output == wl_output)
+                {
+                    TRACE("Setting output %p for surface %p\n", wl_output, data->wayland_surface);
+                    data->wayland_surface->wl_output = wl_output;
+                    break;
+                }
+            }
+            pthread_mutex_unlock(&process_wayland.output_mutex);
+        }
+
+        wayland_win_data_release(data);
+    }
+}
+
+static void wl_surface_handle_leave(void *user_data, struct wl_surface *surface, struct wl_output *wl_output)
+{
+    struct wayland_win_data *data;
+    struct wayland_output *output;
+    HWND hwnd = user_data;
+
+    if ((data = wayland_win_data_get(hwnd)))
+    {
+        if (data->wayland_surface)
+        {
+            pthread_mutex_lock(&process_wayland.output_mutex);
+            wl_list_for_each(output, &process_wayland.output_list, link)
+            {
+                if (output->wl_output == wl_output)
+                {
+                    TRACE("Clearing output %p for surface %p\n", wl_output, data->wayland_surface);
+                    data->wayland_surface->wl_output = NULL;
+                    break;
+                }
+            }
+            pthread_mutex_unlock(&process_wayland.output_mutex);
+        }
+
+        wayland_win_data_release(data);
+    }
+}
+
+static const struct wl_surface_listener wl_surface_listener =
+{
+    wl_surface_handle_enter,
+    wl_surface_handle_leave
+};
+
 /**********************************************************************
  *          wayland_surface_create
  *
@@ -191,6 +251,7 @@ struct wayland_surface *wayland_surface_create(HWND hwnd)
         ERR("Failed to create wl_surface Wayland surface\n");
         goto err;
     }
+    wl_surface_add_listener(surface->wl_surface, &wl_surface_listener, hwnd);
     wl_surface_set_user_data(surface->wl_surface, hwnd);
 
     surface->wp_viewport =
@@ -550,6 +611,42 @@ static void wayland_surface_get_rect_in_monitor(struct wayland_surface *surface,
     OffsetRect(rect, -surface->window.rect.left, -surface->window.rect.top);
 }
 
+struct wl_output *wayland_surface_get_best_output(struct wayland_surface *surface)
+{
+    struct wayland_output *output;
+    struct wl_output *best = NULL;
+    RECT output_rect, temp, intersect = {0};
+    const RECT *window_rect = &surface->window.rect;
+
+    wl_list_for_each(output, &process_wayland.output_list, link)
+    {
+        SetRect(&output_rect, 0, 0,
+                output->current.current_mode->width,
+                output->current.current_mode->height);
+        OffsetRect(&output_rect,
+                output->current.resolved_x,
+                output->current.resolved_y);
+
+        TRACE("output %s: %s, window %s\n",
+              output->current.name,
+              wine_dbgstr_rect(&output_rect),
+              wine_dbgstr_rect(window_rect));
+
+        if (intersect_rect(&temp, window_rect, &output_rect) &&
+                area_rect(&temp) > area_rect(&intersect))
+        {
+            intersect = temp;
+            best = output->wl_output;
+        }
+    }
+
+    if (!best)
+        WARN("Could not find associated wl_output for rect %s!\n",
+             wine_dbgstr_rect(window_rect));
+
+    return best;
+}
+
 /**********************************************************************
  *          wayland_surface_reconfigure_geometry
  *
@@ -601,6 +698,23 @@ static void wayland_surface_reconfigure_geometry(struct wayland_surface *surface
                                         rect.left, rect.top,
                                         rect.right - rect.left,
                                         rect.bottom - rect.top);
+        /* HACK: reset fullscreen state to ensure surface is on correct output */
+        if (surface->current.state & WAYLAND_SURFACE_CONFIG_STATE_FULLSCREEN
+            && wayland_surface_is_toplevel(surface))
+        {
+            struct wl_output *output;
+            pthread_mutex_lock(&process_wayland.output_mutex);
+            output = wayland_surface_get_best_output(surface);
+            if (output != surface->wl_output)
+            {
+                TRACE("Resetting fullscreen state: output %p surface output %p\n",
+                      output, surface->wl_output);
+                xdg_toplevel_unset_fullscreen(surface->xdg_toplevel);
+                wl_display_flush(process_wayland.wl_display);
+                xdg_toplevel_set_fullscreen(surface->xdg_toplevel, output);
+            }
+            pthread_mutex_unlock(&process_wayland.output_mutex);
+        }
     }
 }
 
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 52a4f1b160c..4537c934077 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -273,6 +273,7 @@ struct wayland_surface
     HWND hwnd;
 
     struct wl_surface *wl_surface;
+    struct wl_output *wl_output;
     struct wp_viewport *wp_viewport;
     struct wp_fractional_scale_v1 *wp_fractional_scale_v1;
 
@@ -345,6 +346,7 @@ void wayland_client_surface_detach(struct wayland_client_surface *client);
 void wayland_surface_ensure_contents(struct wayland_surface *surface);
 void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR title);
 void wayland_surface_set_icon(struct wayland_surface *surface, UINT type, ICONINFO *ii);
+struct wl_output *wayland_surface_get_best_output(struct wayland_surface *surface);
 
 static inline BOOL wayland_surface_is_toplevel(struct wayland_surface *surface)
 {
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 70b3c2080c0..99769dce0b5 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -239,42 +239,6 @@ static BOOL wayland_win_data_create_wayland_surface(struct wayland_win_data *dat
     return TRUE;
 }
 
-static struct wl_output *wayland_surface_get_best_output(struct wayland_surface *surface)
-{
-    struct wayland_output *output;
-    struct wl_output *best = NULL;
-    RECT output_rect, temp, intersect = {0};
-    const RECT *window_rect = &surface->window.rect;
-
-    wl_list_for_each(output, &process_wayland.output_list, link)
-    {
-        SetRect(&output_rect, 0, 0,
-                output->current.current_mode->width,
-                output->current.current_mode->height);
-        OffsetRect(&output_rect,
-                output->current.resolved_x,
-                output->current.resolved_y);
-
-        TRACE("output %s, %s window %s\n",
-              output->current.name,
-              wine_dbgstr_rect(&output_rect),
-              wine_dbgstr_rect(window_rect));
-
-        if (intersect_rect(&temp, window_rect, &output_rect) &&
-                area_rect(&temp) > area_rect(&intersect))
-        {
-            intersect = temp;
-            best = output->wl_output;
-        }
-    }
-
-    if (!best)
-        WARN("Could not find associated wl_output for rect %s!\n",
-             wine_dbgstr_rect(window_rect));
-
-    return best;
-}
-
 static void wayland_surface_update_state_toplevel(struct wayland_surface *surface)
 {
     BOOL processing_config = surface->processing.serial &&
-- 
2.49.0

From 7d44564f6a43e234da61785875e48c324ee32e6f Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sat, 24 May 2025 11:09:03 -0400
Subject: [PATCH 63/78] WIP: winewayland: emulate some edid data.

---
 dlls/winewayland.drv/display.c | 57 ++++++++++++++++++++++++++++++++++
 1 file changed, 57 insertions(+)

diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index c5d599efb54..d85d56f06c2 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -212,6 +212,62 @@ static void wayland_add_device_source(const struct gdi_device_manager *device_ma
     device_manager->add_source(output_info->output->name, state_flags, dpi, param);
 }
 
+/* emulate some edid data */
+static UINT get_edid(const struct output_info *output_info, unsigned char **data_out)
+{
+    unsigned char *data, *p;
+    unsigned int i, mwidth, mheight;
+    unsigned char c;
+    struct wayland_output_mode *mode = output_info->output->current_mode;
+
+    /* assume ~150 dpi */
+    mwidth = mode->width / 60;
+    mheight = mode->height / 60;
+
+    *data_out = calloc( 1, 128 );
+    data = *data_out;
+
+    if (!data) return 0;
+
+    *(uint64_t*)data = 0x00ffffffffffff00;
+    data[18] = 1;
+    data[19] = 4;
+    data[20] = 0xa0; /* FIXME */
+    data[21] = mwidth;
+    data[22] = mheight;
+    data[24] = 0x6;
+
+    p = data + 54;
+
+    *(uint16_t*)&p[0] = 0x0; /* reserved */
+
+    /* assume blanking time is 0 */
+    p[2] = mode->width;
+    p[4] = (((mode->width >> 8) & 0xf) << 4);
+    p[5] = mode->height;
+    p[7] = (((mode->height >> 8) & 0xf) << 4);
+    p[12] = mwidth;
+    p[13] = mheight;
+    p[14] = (((mwidth >> 8) & 0xf) << 4) | ((mheight >> 8) & 0xf);
+
+    p += 18;
+    p[3] = 0xfc;
+    memcpy((char *)p + 5, output_info->output->name,
+             min(strlen(output_info->output->name), 12));
+
+    p += 18;
+    p[3] = 0x10;
+    p += 18;
+    p[3] = 0x10;
+
+    c = 0;
+    for (i = 0; i < 127; ++i)
+        c += data[i];
+    data[127] = 256 - c;
+
+    return 128;
+}
+
 static void wayland_add_device_monitor(const struct gdi_device_manager *device_manager,
                                        void *param, struct output_info *output_info)
 {
@@ -223,6 +279,7 @@ static void wayland_add_device_monitor(const struct gdi_device_manager *device_m
 
     /* We don't have a direct way to get the work area in Wayland. */
     monitor.rc_work = monitor.rc_monitor;
+    monitor.edid_len = get_edid(output_info, &monitor.edid);
 
     TRACE("name=%s rc_monitor=rc_work=%s\n",
           output_info->output->name, wine_dbgstr_rect(&monitor.rc_monitor));
-- 
2.49.0

From 8d27448b180bfc5512e27c4cf1bc84860c15592f Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sat, 24 May 2025 13:26:50 -0400
Subject: [PATCH 64/78] winedmo: Fix double free

---
 dlls/winedmo/unix_demuxer.c           | 4 ++--
 dlls/winedmo/unix_demuxer_mediaconv.c | 3 +++
 2 files changed, 5 insertions(+), 2 deletions(-)

diff --git a/dlls/winedmo/unix_demuxer.c b/dlls/winedmo/unix_demuxer.c
index 24681e2d5df..cceda4d7112 100644
--- a/dlls/winedmo/unix_demuxer.c
+++ b/dlls/winedmo/unix_demuxer.c
@@ -248,10 +248,10 @@ NTSTATUS demuxer_create( void *arg )
     if (!(demuxer->ctx->pb = avio_alloc_context( NULL, 0, 0, params->context, unix_read_callback, NULL, unix_seek_callback ))) goto failed;
 
     if ((ret = avformat_open_input( &demuxer->ctx, NULL, NULL, NULL )) < 0)
-        WARN( "Failed to open input, error %s.\n", debugstr_averr(ret) );
+        ERR( "Failed to open input using avformat, error %s.\n", debugstr_averr(ret) );
     if ((ret = mediaconv_demuxer_open( &demuxer->ctx, params->context ) < 0))
     {
-        ERR( "Failed to open input, error %s.\n", debugstr_averr(ret) );
+        ERR( "Failed to open input using mediaconv, error %s.\n", debugstr_averr(ret) );
         goto failed;
     }
     format = demuxer->ctx->iformat;
diff --git a/dlls/winedmo/unix_demuxer_mediaconv.c b/dlls/winedmo/unix_demuxer_mediaconv.c
index 478df6f2a34..90a629402c4 100644
--- a/dlls/winedmo/unix_demuxer_mediaconv.c
+++ b/dlls/winedmo/unix_demuxer_mediaconv.c
@@ -209,6 +209,7 @@ int mediaconv_demuxer_open( AVFormatContext **ctx, struct stream_context *contex
         WARN( "Failed to find decoder for stream %u, codec %#x %s\n", i, par->codec_id, avcodec_get_name(par->codec_id) );
         avio_context_free( &(*ctx)->pb );
         avformat_free_context( *ctx );
+        *ctx = NULL;
     }
 
     if (!(buffer = calloc( 1, HASH_CHUNK_SIZE ))) return AVERROR(ENOMEM);
@@ -258,6 +259,7 @@ int mediaconv_demuxer_open( AVFormatContext **ctx, struct stream_context *contex
                                                NULL, mediaconv_demuxer_seek_callback )))
         {
             avformat_free_context( *ctx );
+            *ctx = NULL;
             return AVERROR(ENOMEM);
         }
     }
@@ -273,6 +275,7 @@ int mediaconv_demuxer_open( AVFormatContext **ctx, struct stream_context *contex
         if ((ret = avio_open( &(*ctx)->pb, blank_path, AVIO_FLAG_READ )) < 0)
         {
             avformat_free_context( *ctx );
+            *ctx = NULL;
             return ret;
         }
     }
-- 
2.49.0

From d1bd8c8b19faabc055f4675773ee14fa9a7cef8a Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sat, 24 May 2025 14:15:02 -0400
Subject: [PATCH 65/78] winebus: remove duplicated code

---
 dlls/winebus.sys/main.c | 6 ------
 1 file changed, 6 deletions(-)

diff --git a/dlls/winebus.sys/main.c b/dlls/winebus.sys/main.c
index 970e12f0810..ffd329dda9e 100644
--- a/dlls/winebus.sys/main.c
+++ b/dlls/winebus.sys/main.c
@@ -445,12 +445,6 @@ static BOOL is_hidraw_enabled(WORD vid, WORD pid, const USAGE_AND_PAGE *usages,
 
     if (check_bus_option(L"DisableHidraw", FALSE)) return FALSE;
 
-    if (usages->UsagePage == HID_USAGE_PAGE_DIGITIZER)
-    {
-        WARN("Ignoring unsupported %04X:%04X hidraw touchscreen\n", vid, pid);
-        return FALSE;
-    }
-
     params.vid = vid;
     params.pid = pid;
     if (!winebus_call(hidraw_enabled, &params) && params.env_set)
-- 
2.49.0

From 5408252da9343a07f4053ddf42f83bdada7dcb39 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sun, 25 May 2025 20:00:10 -0400
Subject: [PATCH 66/78] winewayland: Set edid chromaticity values

---
 dlls/winewayland.drv/Makefile.in             |    1 +
 dlls/winewayland.drv/color-management-v1.xml | 1631 ++++++++++++++++++
 dlls/winewayland.drv/display.c               |   15 +-
 dlls/winewayland.drv/wayland.c               |    5 +
 dlls/winewayland.drv/wayland_output.c        |  188 ++
 dlls/winewayland.drv/waylanddrv.h            |   20 +
 6 files changed, 1859 insertions(+), 1 deletion(-)
 create mode 100644 dlls/winewayland.drv/color-management-v1.xml

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 92db5349568..fba6b916cee 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -5,6 +5,7 @@ UNIX_LIBS = -lwin32u $(WAYLAND_CLIENT_LIBS) $(WAYLAND_EGL_LIBS) $(XKBCOMMON_LIBS
 IMPORTS = user32 win32u
 
 SOURCES = \
+	color-management-v1.xml \
 	cursor-shape-v1.xml \
 	display.c \
 	dllmain.c \
diff --git a/dlls/winewayland.drv/color-management-v1.xml b/dlls/winewayland.drv/color-management-v1.xml
new file mode 100644
index 00000000000..ee482c5af1a
--- /dev/null
+++ b/dlls/winewayland.drv/color-management-v1.xml
@@ -0,0 +1,1631 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="color_management_v1">
+  <copyright>
+    Copyright 2019 Sebastian Wick
+    Copyright 2019 Erwin Burema
+    Copyright 2020 AMD
+    Copyright 2020-2024 Collabora, Ltd.
+    Copyright 2024 Xaver Hugl
+    Copyright 2022-2025 Red Hat, Inc.
+
+    Permission is hereby granted, free of charge, to any person obtaining a
+    copy of this software and associated documentation files (the "Software"),
+    to deal in the Software without restriction, including without limitation
+    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+    and/or sell copies of the Software, and to permit persons to whom the
+    Software is furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice (including the next
+    paragraph) shall be included in all copies or substantial portions of the
+    Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+    DEALINGS IN THE SOFTWARE.
+  </copyright>
+
+  <description summary="color management protocol">
+    The aim of the color management extension is to allow clients to know
+    the color properties of outputs, and to tell the compositor about the color
+    properties of their content on surfaces. Doing this enables a compositor
+    to perform automatic color management of content for different outputs
+    according to how content is intended to look like.
+
+    The color properties are represented as an image description object which
+    is immutable after it has been created. A wl_output always has an
+    associated image description that clients can observe. A wl_surface
+    always has an associated preferred image description as a hint chosen by
+    the compositor that clients can also observe. Clients can set an image
+    description on a wl_surface to denote the color characteristics of the
+    surface contents.
+
+    An image description includes SDR and HDR colorimetry and encoding, HDR
+    metadata, and viewing environment parameters. An image description does
+    not include the properties set through color-representation extension.
+    It is expected that the color-representation extension is used in
+    conjunction with the color management extension when necessary,
+    particularly with the YUV family of pixel formats.
+
+    Recommendation ITU-T H.273
+    "Coding-independent code points for video signal type identification"
+    shall be referred to as simply H.273 here.
+
+    The color-and-hdr repository
+    (https://gitlab.freedesktop.org/pq/color-and-hdr) contains
+    background information on the protocol design and legacy color management.
+    It also contains a glossary, learning resources for digital color, tools,
+    samples and more.
+
+    The terminology used in this protocol is based on common color science and
+    color encoding terminology where possible. The glossary in the color-and-hdr
+    repository shall be the authority on the definition of terms in this
+    protocol.
+
+    Warning! The protocol described in this file is currently in the testing
+    phase. Backward compatible changes may be added together with the
+    corresponding interface version bump. Backward incompatible changes can
+    only be done by creating a new major version of the extension.
+  </description>
+
+  <interface name="wp_color_manager_v1" version="1">
+    <description summary="color manager singleton">
+      A singleton global interface used for getting color management extensions
+      for wl_surface and wl_output objects, and for creating client defined
+      image description objects. The extension interfaces allow
+      getting the image description of outputs and setting the image
+      description of surfaces.
+
+      Compositors should never remove this global.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the color manager">
+        Destroy the wp_color_manager_v1 object. This does not affect any other
+        objects in any way.
+      </description>
+    </request>
+
+    <enum name="error">
+      <entry name="unsupported_feature" value="0"
+             summary="request not supported"/>
+      <entry name="surface_exists" value="1"
+             summary="color management surface exists already"/>
+    </enum>
+
+    <enum name="render_intent">
+      <description summary="rendering intents">
+        See the ICC.1:2022 specification from the International Color Consortium
+        for more details about rendering intents.
+
+        The principles of ICC defined rendering intents apply with all types of
+        image descriptions, not only those with ICC file profiles.
+
+        Compositors must support the perceptual rendering intent. Other
+        rendering intents are optional.
+      </description>
+
+      <entry name="perceptual" value="0"
+             summary="perceptual"/>
+      <entry name="relative" value="1"
+             summary="media-relative colorimetric"/>
+      <entry name="saturation" value="2"
+             summary="saturation"/>
+      <entry name="absolute" value="3"
+             summary="ICC-absolute colorimetric"/>
+      <entry name="relative_bpc" value="4"
+             summary="media-relative colorimetric + black point compensation"/>
+    </enum>
+
+    <enum name="feature">
+      <description summary="compositor supported features"/>
+
+      <entry name="icc_v2_v4" value="0"
+             summary="create_icc_creator request"/>
+      <entry name="parametric" value="1"
+             summary="create_parametric_creator request"/>
+      <entry name="set_primaries" value="2"
+             summary="parametric set_primaries request"/>
+      <entry name="set_tf_power" value="3"
+             summary="parametric set_tf_power request"/>
+      <entry name="set_luminances" value="4"
+             summary="parametric set_luminances request"/>
+      <entry name="set_mastering_display_primaries" value="5">
+        <description summary="parametric set_mastering_display_primaries request">
+          The compositor supports set_mastering_display_primaries request with a
+          target color volume fully contained inside the primary color volume.
+        </description>
+      </entry>
+      <entry name="extended_target_volume" value="6">
+        <description summary="parametric target exceeds primary color volume">
+          The compositor additionally supports target color volumes that
+          extend outside of the primary color volume.
+
+          This can only be advertised if feature set_mastering_display_primaries
+          is supported as well.
+        </description>
+      </entry>
+      <entry name="windows_scrgb" value="7"
+             summary="create_windows_scrgb request"/>
+    </enum>
+
+    <enum name="primaries">
+      <description summary="named color primaries">
+        Named color primaries used to encode well-known sets of primaries. H.273
+        is the authority, when it comes to the exact values of primaries and
+        authoritative specifications, where an equivalent code point exists.
+
+        A value of 0 is invalid and will never be present in the list of enums.
+
+        Descriptions do list the specifications for convenience.
+      </description>
+
+      <entry name="srgb" value="1">
+        <description summary="Color primaries for the sRGB color space as defined by the BT.709 standard">
+          Color primaries as defined by
+          - Rec. ITU-R BT.709-6
+          - Rec. ITU-R BT.1361-0 conventional colour gamut system and extended
+            colour gamut system (historical)
+          - IEC 61966-2-1 sRGB or sYCC
+          - IEC 61966-2-4
+          - Society of Motion Picture and Television Engineers (SMPTE) RP 177
+            (1993) Annex B
+          Equivalent to H.273 ColourPrimaries code point 1.
+        </description>
+      </entry>
+      <entry name="pal_m" value="2">
+        <description summary="Color primaries for PAL-M as defined by the BT.470 standard">
+          Color primaries as defined by
+          - Rec. ITU-R BT.470-6 System M (historical)
+          - United States National Television System Committee 1953
+            Recommendation for transmission standards for color television
+          - United States Federal Communications Commission (2003) Title 47 Code
+            of Federal Regulations 73.682 (a)(20)
+          Equivalent to H.273 ColourPrimaries code point 4.
+        </description>
+      </entry>
+      <entry name="pal" value="3">
+        <description summary="Color primaries for PAL as defined by the BT.601 standard">
+          Color primaries as defined by
+          - Rec. ITU-R BT.470-6 System B, G (historical)
+          - Rec. ITU-R BT.601-7 625
+          - Rec. ITU-R BT.1358-0 625 (historical)
+          - Rec. ITU-R BT.1700-0 625 PAL and 625 SECAM
+          Equivalent to H.273 ColourPrimaries code point 5.
+        </description>
+      </entry>
+      <entry name="ntsc" value="4">
+        <description summary="Color primaries for NTSC as defined by the BT.601 standard">
+          Color primaries as defined by
+          - Rec. ITU-R BT.601-7 525
+          - Rec. ITU-R BT.1358-1 525 or 625 (historical)
+          - Rec. ITU-R BT.1700-0 NTSC
+          - SMPTE 170M (2004)
+          - SMPTE 240M (1999) (historical)
+          Equivalent to H.273 ColourPrimaries code point 6 and 7.
+        </description>
+      </entry>
+      <entry name="generic_film" value="5">
+        <description summary="Generic film with colour filters using Illuminant C">
+          Color primaries as defined by H.273 for generic film.
+          Equivalent to H.273 ColourPrimaries code point 8.
+        </description>
+      </entry>
+      <entry name="bt2020" value="6">
+        <description summary="Color primaries as defined by the BT.2020 and BT.2100 standard">
+          Color primaries as defined by
+          - Rec. ITU-R BT.2020-2
+          - Rec. ITU-R BT.2100-0
+          Equivalent to H.273 ColourPrimaries code point 9.
+        </description>
+      </entry>
+      <entry name="cie1931_xyz" value="7">
+        <description summary="Color primaries of the full CIE 1931 XYZ color space">
+          Color primaries as defined as the maximum of the CIE 1931 XYZ color
+          space by
+          - SMPTE ST 428-1
+          - (CIE 1931 XYZ as in ISO 11664-1)
+          Equivalent to H.273 ColourPrimaries code point 10.
+        </description>
+      </entry>
+      <entry name="dci_p3" value="8">
+        <description summary="Color primaries of the DCI P3 color space as defined by the SMPTE RP 431 standard">
+          Color primaries as defined by Digital Cinema System and published in
+          SMPTE RP 431-2 (2011). Equivalent to H.273 ColourPrimaries code point
+          11.
+        </description>
+      </entry>
+      <entry name="display_p3" value="9">
+        <description summary="Color primaries of Display P3 variant of the DCI-P3 color space as defined by the SMPTE EG 432 standard">
+          Color primaries as defined by Digital Cinema System and published in
+          SMPTE EG 432-1 (2010).
+          Equivalent to H.273 ColourPrimaries code point 12.
+        </description>
+      </entry>
+      <entry name="adobe_rgb" value="10">
+        <description summary="Color primaries of the Adobe RGB color space as defined by the ISO 12640 standard">
+          Color primaries as defined by Adobe as "Adobe RGB" and later published
+          by ISO 12640-4 (2011).
+        </description>
+      </entry>
+    </enum>
+
+    <enum name="transfer_function">
+      <description summary="named transfer functions">
+        Named transfer functions used to represent well-known transfer
+        characteristics. H.273 is the authority, when it comes to the exact
+        formulas and authoritative specifications, where an equivalent code
+        point exists.
+
+        A value of 0 is invalid and will never be present in the list of enums.
+
+        Descriptions do list the specifications for convenience.
+      </description>
+
+      <entry name="bt1886" value="1">
+        <description summary="BT.1886 display transfer characteristic">
+          Rec. ITU-R BT.1886 is the display transfer characteristic assumed by
+          - Rec. ITU-R BT.601-7 525 and 625
+          - Rec. ITU-R BT.709-6
+          - Rec. ITU-R BT.2020-2
+          These recommendations are referred to by H.273 TransferCharacteristics
+          code points 1, 6, 14, and 15, which are all equivalent.
+
+          This TF implies these default luminances from Rec. ITU-R BT.2035:
+          - primary color volume minimum: 0.01 cd/m²
+          - primary color volume maximum: 100 cd/m²
+          - reference white: 100 cd/m²
+        </description>
+      </entry>
+      <entry name="gamma22" value="2">
+        <description summary="Assumed display gamma 2.2 transfer function">
+          Transfer characteristics as defined by
+          - Rec. ITU-R BT.470-6 System M (historical)
+          - United States National Television System Committee 1953
+            Recommendation for transmission standards for color television
+          - United States Federal Communications Commission (2003) Title 47 Code
+            of Federal Regulations 73.682 (a) (20)
+          - Rec. ITU-R BT.1700-0 625 PAL and 625 SECAM
+          Equivalent to H.273 TransferCharacteristics code point 4.
+        </description>
+      </entry>
+      <entry name="gamma28" value="3">
+        <description summary="Assumed display gamma 2.8 transfer function">
+          Transfer characteristics as defined by
+          - Rec. ITU-R BT.470-6 System B, G (historical)
+          Equivalent to H.273 TransferCharacteristics code point 5.
+        </description>
+      </entry>
+      <entry name="st240" value="4">
+        <description summary="SMPTE ST 240 transfer function">
+          Transfer characteristics as defined by
+          - SMPTE ST 240 (1999)
+          Equivalent to H.273 TransferCharacteristics code point 7.
+        </description>
+      </entry>
+      <entry name="ext_linear" value="5">
+        <description summary="extended linear transfer function">
+          Linear transfer function defined over all real numbers.
+          Normalised electrical values are equal the normalised optical values.
+
+          The differences to H.273 TransferCharacteristics code point 8 are
+          the definition over all real numbers.
+        </description>
+      </entry>
+      <entry name="log_100" value="6">
+        <description summary="logarithmic 100:1 transfer function">
+          Logarithmic transfer characteristic (100:1 range).
+          Equivalent to H.273 TransferCharacteristics code point 9.
+        </description>
+      </entry>
+      <entry name="log_316" value="7">
+        <description summary="logarithmic (100*Sqrt(10) : 1) transfer function">
+          Logarithmic transfer characteristic (100 * Sqrt(10) : 1 range).
+          Equivalent to H.273 TransferCharacteristics code point 10.
+        </description>
+      </entry>
+      <entry name="xvycc" value="8">
+        <description summary="IEC 61966-2-4 transfer function">
+          Transfer characteristics as defined by
+          - IEC 61966-2-4
+          Equivalent to H.273 TransferCharacteristics code point 11.
+        </description>
+      </entry>
+      <entry name="srgb" value="9">
+        <description summary="sRGB piece-wise transfer function">
+          Transfer characteristics as defined by
+          - IEC 61966-2-1 sRGB
+          Equivalent to H.273 TransferCharacteristics code point 13 with
+          MatrixCoefficients set to 0.
+        </description>
+      </entry>
+      <entry name="ext_srgb" value="10">
+        <description summary="Extended sRGB piece-wise transfer function">
+          Transfer characteristics as defined by
+          - IEC 61966-2-1 sYCC
+          Equivalent to H.273 TransferCharacteristics code point 13 with
+          MatrixCoefficients set to anything but 0.
+        </description>
+      </entry>
+      <entry name="st2084_pq" value="11">
+        <description summary="perceptual quantizer transfer function">
+          Transfer characteristics as defined by
+          - SMPTE ST 2084 (2014) for 10-, 12-, 14- and 16-bit systems
+          - Rec. ITU-R BT.2100-2 perceptual quantization (PQ) system
+          Equivalent to H.273 TransferCharacteristics code point 16.
+
+          This TF implies these default luminances
+          - primary color volume minimum: 0.005 cd/m²
+          - primary color volume maximum: 10000 cd/m²
+          - reference white: 203 cd/m²
+
+          The difference between the primary color volume minimum and maximum
+          must be approximately 10000 cd/m² as that is the swing of the EOTF
+          defined by ST 2084 and BT.2100. The default value for the
+          reference white is a protocol addition: it is suggested by
+          Report ITU-R BT.2408-7 and is not part of ST 2084 or BT.2100.
+        </description>
+      </entry>
+      <entry name="st428" value="12">
+        <description summary="SMPTE ST 428 transfer function">
+          Transfer characteristics as defined by
+          - SMPTE ST 428-1 (2019)
+          Equivalent to H.273 TransferCharacteristics code point 17.
+        </description>
+      </entry>
+      <entry name="hlg" value="13">
+        <description summary="hybrid log-gamma transfer function">
+          Transfer characteristics as defined by
+          - ARIB STD-B67 (2015)
+          - Rec. ITU-R BT.2100-2 hybrid log-gamma (HLG) system
+          Equivalent to H.273 TransferCharacteristics code point 18.
+
+          This TF implies these default luminances
+          - primary color volume minimum: 0.005 cd/m²
+          - primary color volume maximum: 1000 cd/m²
+          - reference white: 203 cd/m²
+
+          HLG is a relative display-referred signal with a specified
+          non-linear mapping to the display peak luminance (the HLG OOTF).
+          All absolute luminance values used here for HLG assume a 1000 cd/m²
+          peak display.
+
+          The default value for the reference white is a protocol addition:
+          it is suggested by Report ITU-R BT.2408-7 and is not part of
+          ARIB STD-B67 or BT.2100.
+        </description>
+      </entry>
+    </enum>
+
+    <request name="get_output">
+      <description summary="create a color management interface for a wl_output">
+        This creates a new wp_color_management_output_v1 object for the
+        given wl_output.
+
+        See the wp_color_management_output_v1 interface for more details.
+      </description>
+
+      <arg name="id" type="new_id" interface="wp_color_management_output_v1"/>
+      <arg name="output" type="object" interface="wl_output"/>
+    </request>
+
+    <request name="get_surface">
+      <description summary="create a color management interface for a wl_surface">
+        If a wp_color_management_surface_v1 object already exists for the given
+        wl_surface, the protocol error surface_exists is raised.
+
+        This creates a new color wp_color_management_surface_v1 object for the
+        given wl_surface.
+
+        See the wp_color_management_surface_v1 interface for more details.
+      </description>
+
+      <arg name="id" type="new_id" interface="wp_color_management_surface_v1"/>
+      <arg name="surface" type="object" interface="wl_surface"/>
+    </request>
+
+    <request name="get_surface_feedback">
+      <description summary="create a color management feedback interface">
+        This creates a new color wp_color_management_surface_feedback_v1 object
+        for the given wl_surface.
+
+        See the wp_color_management_surface_feedback_v1 interface for more
+        details.
+      </description>
+
+      <arg name="id" type="new_id"
+           interface="wp_color_management_surface_feedback_v1"/>
+      <arg name="surface" type="object" interface="wl_surface"/>
+    </request>
+
+    <request name="create_icc_creator">
+      <description summary="make a new ICC-based image description creator object">
+        Makes a new ICC-based image description creator object with all
+        properties initially unset. The client can then use the object's
+        interface to define all the required properties for an image description
+        and finally create a wp_image_description_v1 object.
+
+        This request can be used when the compositor advertises
+        wp_color_manager_v1.feature.icc_v2_v4.
+        Otherwise this request raises the protocol error unsupported_feature.
+      </description>
+
+      <arg name="obj"
+           type="new_id" interface="wp_image_description_creator_icc_v1"
+           summary="the new creator object"/>
+    </request>
+
+    <request name="create_parametric_creator">
+      <description summary="make a new parametric image description creator object">
+        Makes a new parametric image description creator object with all
+        properties initially unset. The client can then use the object's
+        interface to define all the required properties for an image description
+        and finally create a wp_image_description_v1 object.
+
+        This request can be used when the compositor advertises
+        wp_color_manager_v1.feature.parametric.
+        Otherwise this request raises the protocol error unsupported_feature.
+      </description>
+
+      <arg name="obj"
+           type="new_id" interface="wp_image_description_creator_params_v1"
+           summary="the new creator object"/>
+    </request>
+
+    <request name="create_windows_scrgb">
+      <description summary="create Windows-scRGB image description object">
+        This creates a pre-defined image description for the so-called
+        Windows-scRGB stimulus encoding. This comes from the Windows 10 handling
+        of its own definition of an scRGB color space for an HDR screen
+        driven in BT.2100/PQ signalling mode.
+
+        Windows-scRGB uses sRGB (BT.709) color primaries and white point.
+        The transfer characteristic is extended linear.
+
+        The nominal color channel value range is extended, meaning it includes
+        negative and greater than 1.0 values. Negative values are used to
+        escape the sRGB color gamut boundaries. To make use of the extended
+        range, the client needs to use a pixel format that can represent those
+        values, e.g. floating-point 16 bits per channel.
+
+        Nominal color value R=G=B=0.0 corresponds to BT.2100/PQ system
+        0 cd/m², and R=G=B=1.0 corresponds to BT.2100/PQ system 80 cd/m².
+        The maximum is R=G=B=125.0 corresponding to 10k cd/m².
+
+        Windows-scRGB is displayed by Windows 10 by converting it to
+        BT.2100/PQ, maintaining the CIE 1931 chromaticity and mapping the
+        luminance as above. No adjustment is made to the signal to account
+        for the viewing conditions.
+
+        The reference white level of Windows-scRGB is unknown. If a
+        reference white level must be assumed for compositor processing, it
+        should be R=G=B=2.5375 corresponding to 203 cd/m² of Report ITU-R
+        BT.2408-7.
+
+        The target color volume of Windows-scRGB is unknown. The color gamut
+        may be anything between sRGB and BT.2100.
+
+        Note: EGL_EXT_gl_colorspace_scrgb_linear definition differs from
+        Windows-scRGB by using R=G=B=1.0 as the reference white level, while
+        Windows-scRGB reference white level is unknown or varies. However,
+        it seems probable that Windows implements both
+        EGL_EXT_gl_colorspace_scrgb_linear and Vulkan
+        VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT as Windows-scRGB.
+
+        This request can be used when the compositor advertises
+        wp_color_manager_v1.feature.windows_scrgb.
+        Otherwise this request raises the protocol error unsupported_feature.
+
+        The resulting image description object does not allow get_information
+        request. The wp_image_description_v1.ready event shall be sent.
+      </description>
+
+      <arg name="image_description"
+           type="new_id" interface="wp_image_description_v1"/>
+    </request>
+
+    <event name="supported_intent">
+      <description summary="supported rendering intent">
+        When this object is created, it shall immediately send this event once
+        for each rendering intent the compositor supports.
+      </description>
+
+      <arg name="render_intent" type="uint" enum="render_intent"
+           summary="rendering intent"/>
+    </event>
+
+    <event name="supported_feature">
+      <description summary="supported features">
+        When this object is created, it shall immediately send this event once
+        for each compositor supported feature listed in the enumeration.
+      </description>
+
+      <arg name="feature" type="uint" enum="feature"
+           summary="supported feature"/>
+    </event>
+
+    <event name="supported_tf_named">
+      <description summary="supported named transfer characteristic">
+        When this object is created, it shall immediately send this event once
+        for each named transfer function the compositor supports with the
+        parametric image description creator.
+      </description>
+
+      <arg name="tf" type="uint" enum="transfer_function"
+           summary="Named transfer function"/>
+    </event>
+
+    <event name="supported_primaries_named">
+      <description summary="supported named primaries">
+        When this object is created, it shall immediately send this event once
+        for each named set of primaries the compositor supports with the
+        parametric image description creator.
+      </description>
+
+      <arg name="primaries" type="uint" enum="primaries"
+           summary="Named color primaries"/>
+    </event>
+
+    <event name="done">
+      <description summary="all features have been sent">
+        This event is sent when all supported rendering intents, features,
+        transfer functions and named primaries have been sent.
+      </description>
+    </event>
+  </interface>
+
+  <interface name="wp_color_management_output_v1" version="1">
+    <description summary="output color properties">
+      A wp_color_management_output_v1 describes the color properties of an
+      output.
+
+      The wp_color_management_output_v1 is associated with the wl_output global
+      underlying the wl_output object. Therefore the client destroying the
+      wl_output object has no impact, but the compositor removing the output
+      global makes the wp_color_management_output_v1 object inert.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the color management output">
+        Destroy the color wp_color_management_output_v1 object. This does not
+        affect any remaining protocol objects.
+      </description>
+    </request>
+
+    <event name="image_description_changed">
+      <description summary="image description changed">
+        This event is sent whenever the image description of the output changed,
+        followed by one wl_output.done event common to output events across all
+        extensions.
+
+        If the client wants to use the updated image description, it needs to do
+        get_image_description again, because image description objects are
+        immutable.
+      </description>
+    </event>
+
+    <request name="get_image_description">
+      <description summary="get the image description of the output">
+        This creates a new wp_image_description_v1 object for the current image
+        description of the output. There always is exactly one image description
+        active for an output so the client should destroy the image description
+        created by earlier invocations of this request. This request is usually
+        sent as a reaction to the image_description_changed event or when
+        creating a wp_color_management_output_v1 object.
+
+        The image description of an output represents the color encoding the
+        output expects. There might be performance and power advantages, as well
+        as improved color reproduction, if a content update matches the image
+        description of the output it is being shown on. If a content update is
+        shown on any other output than the one it matches the image description
+        of, then the color reproduction on those outputs might be considerably
+        worse.
+
+        The created wp_image_description_v1 object preserves the image
+        description of the output from the time the object was created.
+
+        The resulting image description object allows get_information request.
+
+        If this protocol object is inert, the resulting image description object
+        shall immediately deliver the wp_image_description_v1.failed event with
+        the no_output cause.
+
+        If the interface version is inadequate for the output's image
+        description, meaning that the client does not support all the events
+        needed to deliver the crucial information, the resulting image
+        description object shall immediately deliver the
+        wp_image_description_v1.failed event with the low_version cause.
+
+        Otherwise the object shall immediately deliver the ready event.
+      </description>
+
+      <arg name="image_description"
+           type="new_id" interface="wp_image_description_v1"/>
+    </request>
+  </interface>
+
+  <interface name="wp_color_management_surface_v1" version="1">
+    <description summary="color management extension to a surface">
+        A wp_color_management_surface_v1 allows the client to set the color
+        space and HDR properties of a surface.
+
+        If the wl_surface associated with the wp_color_management_surface_v1 is
+        destroyed, the wp_color_management_surface_v1 object becomes inert.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the color management interface for a surface">
+        Destroy the wp_color_management_surface_v1 object and do the same as
+        unset_image_description.
+      </description>
+    </request>
+
+    <enum name="error">
+      <description summary="protocol errors"/>
+      <entry name="render_intent" value="0"
+             summary="unsupported rendering intent"/>
+      <entry name="image_description" value="1"
+             summary="invalid image description"/>
+      <entry name="inert" value="2"
+             summary="forbidden request on inert object"/>
+    </enum>
+
+    <request name="set_image_description">
+      <description summary="set the surface image description">
+        If this protocol object is inert, the protocol error inert is raised.
+
+        Set the image description of the underlying surface. The image
+        description and rendering intent are double-buffered state, see
+        wl_surface.commit.
+
+        It is the client's responsibility to understand the image description
+        it sets on a surface, and to provide content that matches that image
+        description. Compositors might convert images to match their own or any
+        other image descriptions.
+
+        Image descriptions which are not ready (see wp_image_description_v1)
+        are forbidden in this request, and in such case the protocol error
+        image_description is raised.
+
+        All image descriptions which are ready (see wp_image_description_v1)
+        are allowed and must always be accepted by the compositor.
+
+        A rendering intent provides the client's preference on how content
+        colors should be mapped to each output. The render_intent value must
+        be one advertised by the compositor with
+        wp_color_manager_v1.render_intent event, otherwise the protocol error
+        render_intent is raised.
+
+        When an image description is set on a surface, the Transfer
+        Characteristics of the image description defines the valid range of
+        the nominal (real-valued) color channel values. The processing of
+        out-of-range color channel values is undefined, but compositors are
+        recommended to clamp the values to the valid range when possible.
+
+        By default, a surface does not have an associated image description
+        nor a rendering intent. The handling of color on such surfaces is
+        compositor implementation defined. Compositors should handle such
+        surfaces as sRGB, but may handle them differently if they have specific
+        requirements.
+
+        Setting the image description has copy semantics; after this request,
+        the image description can be immediately destroyed without affecting
+        the pending state of the surface.
+      </description>
+
+      <arg name="image_description"
+           type="object" interface="wp_image_description_v1"/>
+      <arg name="render_intent"
+           type="uint" enum="wp_color_manager_v1.render_intent"
+           summary="rendering intent"/>
+    </request>
+
+    <request name="unset_image_description">
+      <description summary="remove the surface image description">
+        If this protocol object is inert, the protocol error inert is raised.
+
+        This request removes any image description from the surface. See
+        set_image_description for how a compositor handles a surface without
+        an image description. This is double-buffered state, see
+        wl_surface.commit.
+      </description>
+    </request>
+  </interface>
+
+  <interface name="wp_color_management_surface_feedback_v1" version="1">
+    <description summary="color management extension to a surface">
+        A wp_color_management_surface_feedback_v1 allows the client to get the
+        preferred image description of a surface.
+
+        If the wl_surface associated with this object is destroyed, the
+        wp_color_management_surface_feedback_v1 object becomes inert.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the color management interface for a surface">
+        Destroy the wp_color_management_surface_feedback_v1 object.
+      </description>
+    </request>
+
+    <enum name="error">
+      <description summary="protocol errors"/>
+      <entry name="inert" value="0"
+             summary="forbidden request on inert object"/>
+      <entry name="unsupported_feature" value="1"
+             summary="attempted to use an unsupported feature"/>
+    </enum>
+
+    <event name="preferred_changed">
+      <description summary="the preferred image description changed">
+        The preferred image description is the one which likely has the most
+        performance and/or quality benefits for the compositor if used by the
+        client for its wl_surface contents. This event is sent whenever the
+        compositor changes the wl_surface's preferred image description.
+
+        This event sends the identity of the new preferred state as the argument,
+        so clients who are aware of the image description already can reuse it.
+        Otherwise, if the client client wants to know what the preferred image
+        description is, it shall use the get_preferred request.
+
+        The preferred image description is not automatically used for anything.
+        It is only a hint, and clients may set any valid image description with
+        set_image_description, but there might be performance and color accuracy
+        improvements by providing the wl_surface contents in the preferred
+        image description. Therefore clients that can, should render according
+        to the preferred image description
+      </description>
+
+      <arg name="identity" type="uint" summary="image description id number"/>
+    </event>
+
+    <request name="get_preferred">
+      <description summary="get the preferred image description">
+        If this protocol object is inert, the protocol error inert is raised.
+
+        The preferred image description represents the compositor's preferred
+        color encoding for this wl_surface at the current time. There might be
+        performance and power advantages, as well as improved color
+        reproduction, if the image description of a content update matches the
+        preferred image description.
+
+        This creates a new wp_image_description_v1 object for the currently
+        preferred image description for the wl_surface. The client should
+        stop using and destroy the image descriptions created by earlier
+        invocations of this request for the associated wl_surface.
+        This request is usually sent as a reaction to the preferred_changed
+        event or when creating a wp_color_management_surface_feedback_v1 object
+        if the client is capable of adapting to image descriptions.
+
+        The created wp_image_description_v1 object preserves the preferred image
+        description of the wl_surface from the time the object was created.
+
+        The resulting image description object allows get_information request.
+
+        If the image description is parametric, the client should set it on its
+        wl_surface only if the image description is an exact match with the
+        client content. Particularly if everything else matches, but the target
+        color volume is greater than what the client needs, the client should
+        create its own parameric image description with its exact parameters.
+
+        If the interface version is inadequate for the preferred image
+        description, meaning that the client does not support all the
+        events needed to deliver the crucial information, the resulting image
+        description object shall immediately deliver the
+        wp_image_description_v1.failed event with the low_version cause,
+        otherwise the object shall immediately deliver the ready event.
+      </description>
+
+      <arg name="image_description"
+           type="new_id" interface="wp_image_description_v1"/>
+    </request>
+
+    <request name="get_preferred_parametric">
+      <description summary="get the preferred image description">
+        The same description as for get_preferred applies, except the returned
+        image description is guaranteed to be parametric. This is meant for
+        clients that can only deal with parametric image descriptions.
+
+        If the compositor doesn't support parametric image descriptions, the
+        unsupported_feature error is emitted.
+      </description>
+
+      <arg name="image_description"
+           type="new_id" interface="wp_image_description_v1"/>
+    </request>
+  </interface>
+
+  <interface name="wp_image_description_creator_icc_v1" version="1">
+    <description summary="holder of image description ICC information">
+      This type of object is used for collecting all the information required
+      to create a wp_image_description_v1 object from an ICC file. A complete
+      set of required parameters consists of these properties:
+      - ICC file
+
+      Each required property must be set exactly once if the client is to create
+      an image description. The set requests verify that a property was not
+      already set. The create request verifies that all required properties are
+      set. There may be several alternative requests for setting each property,
+      and in that case the client must choose one of them.
+
+      Once all properties have been set, the create request must be used to
+      create the image description object, destroying the creator in the
+      process.
+    </description>
+
+    <enum name="error">
+      <description summary="protocol errors"/>
+
+      <entry name="incomplete_set" value="0"
+             summary="incomplete parameter set"/>
+      <entry name="already_set" value="1"
+             summary="property already set"/>
+      <entry name="bad_fd" value="2"
+             summary="fd not seekable and readable"/>
+      <entry name="bad_size" value="3"
+             summary="no or too much data"/>
+      <entry name="out_of_file" value="4"
+             summary="offset + length exceeds file size"/>
+    </enum>
+
+    <request name="create" type="destructor">
+      <description summary="Create the image description object from ICC data">
+        Create an image description object based on the ICC information
+        previously set on this object. A compositor must parse the ICC data in
+        some undefined but finite amount of time.
+
+        The completeness of the parameter set is verified. If the set is not
+        complete, the protocol error incomplete_set is raised. For the
+        definition of a complete set, see the description of this interface.
+
+        If the particular combination of the information is not supported
+        by the compositor, the resulting image description object shall
+        immediately deliver the wp_image_description_v1.failed event with the
+        'unsupported' cause. If a valid image description was created from the
+        information, the wp_image_description_v1.ready event will eventually
+        be sent instead.
+
+        This request destroys the wp_image_description_creator_icc_v1 object.
+
+        The resulting image description object does not allow get_information
+        request.
+      </description>
+
+      <arg name="image_description"
+           type="new_id" interface="wp_image_description_v1"/>
+    </request>
+
+    <request name="set_icc_file">
+      <description summary="set the ICC profile file">
+        Sets the ICC profile file to be used as the basis of the image
+        description.
+
+        The data shall be found through the given fd at the given offset, having
+        the given length. The fd must be seekable and readable. Violating these
+        requirements raises the bad_fd protocol error.
+
+        If reading the data fails due to an error independent of the client, the
+        compositor shall send the wp_image_description_v1.failed event on the
+        created wp_image_description_v1 with the 'operating_system' cause.
+
+        The maximum size of the ICC profile is 32 MB. If length is greater than
+        that or zero, the protocol error bad_size is raised. If offset + length
+        exceeds the file size, the protocol error out_of_file is raised.
+
+        A compositor may read the file at any time starting from this request
+        and only until whichever happens first:
+        - If create request was issued, the wp_image_description_v1 object
+          delivers either failed or ready event; or
+        - if create request was not issued, this
+          wp_image_description_creator_icc_v1 object is destroyed.
+
+        A compositor shall not modify the contents of the file, and the fd may
+        be sealed for writes and size changes. The client must ensure to its
+        best ability that the data does not change while the compositor is
+        reading it.
+
+        The data must represent a valid ICC profile. The ICC profile version
+        must be 2 or 4, it must be a 3 channel profile and the class must be
+        Display or ColorSpace. Violating these requirements will not result in a
+        protocol error, but will eventually send the
+        wp_image_description_v1.failed event on the created
+        wp_image_description_v1 with the 'unsupported' cause.
+
+        See the International Color Consortium specification ICC.1:2022 for more
+        details about ICC profiles.
+
+        If ICC file has already been set on this object, the protocol error
+        already_set is raised.
+      </description>
+
+      <arg name="icc_profile" type="fd"
+           summary="ICC profile"/>
+      <arg name="offset" type="uint"
+           summary="byte offset in fd to start of ICC data"/>
+      <arg name="length" type="uint"
+           summary="length of ICC data in bytes"/>
+    </request>
+  </interface>
+
+  <interface name="wp_image_description_creator_params_v1" version="1">
+    <description summary="holder of image description parameters">
+      This type of object is used for collecting all the parameters required
+      to create a wp_image_description_v1 object. A complete set of required
+      parameters consists of these properties:
+      - transfer characteristic function (tf)
+      - chromaticities of primaries and white point (primary color volume)
+
+      The following properties are optional and have a well-defined default
+      if not explicitly set:
+      - primary color volume luminance range
+      - reference white luminance level
+      - mastering display primaries and white point (target color volume)
+      - mastering luminance range
+
+      The following properties are optional and will be ignored
+      if not explicitly set:
+      - maximum content light level
+      - maximum frame-average light level
+
+      Each required property must be set exactly once if the client is to create
+      an image description. The set requests verify that a property was not
+      already set. The create request verifies that all required properties are
+      set. There may be several alternative requests for setting each property,
+      and in that case the client must choose one of them.
+
+      Once all properties have been set, the create request must be used to
+      create the image description object, destroying the creator in the
+      process.
+    </description>
+
+    <enum name="error">
+      <description summary="protocol errors"/>
+
+      <entry name="incomplete_set" value="0"
+             summary="incomplete parameter set"/>
+      <entry name="already_set" value="1"
+             summary="property already set"/>
+      <entry name="unsupported_feature" value="2"
+             summary="request not supported"/>
+      <entry name="invalid_tf" value="3"
+             summary="invalid transfer characteristic"/>
+      <entry name="invalid_primaries_named" value="4"
+             summary="invalid primaries named"/>
+      <entry name="invalid_luminance" value="5"
+             summary="invalid luminance value or range"/>
+    </enum>
+
+    <request name="create" type="destructor">
+      <description summary="Create the image description object using params">
+        Create an image description object based on the parameters previously
+        set on this object.
+
+        The completeness of the parameter set is verified. If the set is not
+        complete, the protocol error incomplete_set is raised. For the
+        definition of a complete set, see the description of this interface.
+
+        The protocol error invalid_luminance is raised if any of the following
+        requirements is not met:
+        - When max_cll is set, it must be greater than min L and less or equal
+          to max L of the mastering luminance range.
+        - When max_fall is set, it must be greater than min L and less or equal
+          to max L of the mastering luminance range.
+        - When both max_cll and max_fall are set, max_fall must be less or equal
+          to max_cll.
+
+        If the particular combination of the parameter set is not supported
+        by the compositor, the resulting image description object shall
+        immediately deliver the wp_image_description_v1.failed event with the
+        'unsupported' cause. If a valid image description was created from the
+        parameter set, the wp_image_description_v1.ready event will eventually
+        be sent instead.
+
+        This request destroys the wp_image_description_creator_params_v1
+        object.
+
+        The resulting image description object does not allow get_information
+        request.
+      </description>
+
+      <arg name="image_description"
+           type="new_id" interface="wp_image_description_v1"/>
+    </request>
+
+    <request name="set_tf_named">
+      <description summary="named transfer characteristic">
+        Sets the transfer characteristic using explicitly enumerated named
+        functions.
+
+        When the resulting image description is attached to an image, the
+        content should be encoded and decoded according to the industry standard
+        practices for the transfer characteristic.
+
+        Only names advertised with wp_color_manager_v1 event supported_tf_named
+        are allowed. Other values shall raise the protocol error invalid_tf.
+
+        If transfer characteristic has already been set on this object, the
+        protocol error already_set is raised.
+      </description>
+
+      <arg name="tf" type="uint" enum="wp_color_manager_v1.transfer_function"
+           summary="named transfer function"/>
+    </request>
+
+    <request name="set_tf_power">
+      <description summary="transfer characteristic as a power curve">
+        Sets the color component transfer characteristic to a power curve with
+        the given exponent. Negative values are handled by mirroring the
+        positive half of the curve through the origin. The valid domain and
+        range of the curve are all finite real numbers. This curve represents
+        the conversion from electrical to optical color channel values.
+
+        When the resulting image description is attached to an image, the
+        content should be encoded with the inverse of the power curve.
+
+        The curve exponent shall be multiplied by 10000 to get the argument eexp
+        value to carry the precision of 4 decimals.
+
+        The curve exponent must be at least 1.0 and at most 10.0. Otherwise the
+        protocol error invalid_tf is raised.
+
+        If transfer characteristic has already been set on this object, the
+        protocol error already_set is raised.
+
+        This request can be used when the compositor advertises
+        wp_color_manager_v1.feature.set_tf_power. Otherwise this request raises
+        the protocol error unsupported_feature.
+      </description>
+
+      <arg name="eexp" type="uint" summary="the exponent * 10000"/>
+    </request>
+
+    <request name="set_primaries_named">
+      <description summary="named primaries">
+        Sets the color primaries and white point using explicitly named sets.
+        This describes the primary color volume which is the basis for color
+        value encoding.
+
+        Only names advertised with wp_color_manager_v1 event
+        supported_primaries_named are allowed. Other values shall raise the
+        protocol error invalid_primaries_named.
+
+        If primaries have already been set on this object, the protocol error
+        already_set is raised.
+      </description>
+
+      <arg name="primaries" type="uint" enum="wp_color_manager_v1.primaries"
+           summary="named primaries"/>
+    </request>
+
+    <request name="set_primaries">
+      <description summary="primaries as chromaticity coordinates">
+        Sets the color primaries and white point using CIE 1931 xy chromaticity
+        coordinates. This describes the primary color volume which is the basis
+        for color value encoding.
+
+        Each coordinate value is multiplied by 1 million to get the argument
+        value to carry precision of 6 decimals.
+
+        If primaries have already been set on this object, the protocol error
+        already_set is raised.
+
+        This request can be used if the compositor advertises
+        wp_color_manager_v1.feature.set_primaries. Otherwise this request raises
+        the protocol error unsupported_feature.
+      </description>
+
+      <arg name="r_x" type="int" summary="Red x * 1M"/>
+      <arg name="r_y" type="int" summary="Red y * 1M"/>
+      <arg name="g_x" type="int" summary="Green x * 1M"/>
+      <arg name="g_y" type="int" summary="Green y * 1M"/>
+      <arg name="b_x" type="int" summary="Blue x * 1M"/>
+      <arg name="b_y" type="int" summary="Blue y * 1M"/>
+      <arg name="w_x" type="int" summary="White x * 1M"/>
+      <arg name="w_y" type="int" summary="White y * 1M"/>
+    </request>
+
+    <request name="set_luminances">
+      <description summary="primary color volume luminance range and reference white">
+        Sets the primary color volume luminance range and the reference white
+        luminance level. These values include the minimum display emission
+        and ambient flare luminances, assumed to be optically additive and have
+        the chromaticity of the primary color volume white point.
+
+        The default luminances from
+        https://www.color.org/chardata/rgb/srgb.xalter are
+        - primary color volume minimum: 0.2 cd/m²
+        - primary color volume maximum: 80 cd/m²
+        - reference white: 80 cd/m²
+
+        Setting a named transfer characteristic can imply other default
+        luminances.
+
+        The default luminances get overwritten when this request is used.
+        With transfer_function.st2084_pq the given 'max_lum' value is ignored,
+        and 'max_lum' is taken as 'min_lum' + 10000 cd/m².
+
+        'min_lum' and 'max_lum' specify the minimum and maximum luminances of
+        the primary color volume as reproduced by the targeted display.
+
+        'reference_lum' specifies the luminance of the reference white as
+        reproduced by the targeted display, and reflects the targeted viewing
+        environment.
+
+        Compositors should make sure that all content is anchored, meaning that
+        an input signal level of 'reference_lum' on one image description and
+        another input signal level of 'reference_lum' on another image
+        description should produce the same output level, even though the
+        'reference_lum' on both image representations can be different.
+
+        'reference_lum' may be higher than 'max_lum'. In that case reaching
+        the reference white output level in image content requires the
+        'extended_target_volume' feature support.
+
+        If 'max_lum' or 'reference_lum' are less than or equal to 'min_lum',
+        the protocol error invalid_luminance is raised.
+
+        The minimum luminance is multiplied by 10000 to get the argument
+        'min_lum' value and carries precision of 4 decimals. The maximum
+        luminance and reference white luminance values are unscaled.
+
+        If the primary color volume luminance range and the reference white
+        luminance level have already been set on this object, the protocol error
+        already_set is raised.
+
+        This request can be used if the compositor advertises
+        wp_color_manager_v1.feature.set_luminances. Otherwise this request
+        raises the protocol error unsupported_feature.
+      </description>
+
+      <arg name="min_lum" type="uint"
+           summary="minimum luminance (cd/m²) * 10000"/>
+      <arg name="max_lum" type="uint"
+           summary="maximum luminance (cd/m²)"/>
+      <arg name="reference_lum" type="uint"
+           summary="reference white luminance (cd/m²)"/>
+    </request>
+
+    <request name="set_mastering_display_primaries">
+      <description summary="mastering display primaries as chromaticity coordinates">
+        Provides the color primaries and white point of the mastering display
+        using CIE 1931 xy chromaticity coordinates. This is compatible with the
+        SMPTE ST 2086 definition of HDR static metadata.
+
+        The mastering display primaries and mastering display luminances define
+        the target color volume.
+
+        If mastering display primaries are not explicitly set, the target color
+        volume is assumed to have the same primaries as the primary color volume.
+
+        The target color volume is defined by all tristimulus values between 0.0
+        and 1.0 (inclusive) of the color space defined by the given mastering
+        display primaries and white point. The colorimetry is identical between
+        the container color space and the mastering display color space,
+        including that no chromatic adaptation is applied even if the white
+        points differ.
+
+        The target color volume can exceed the primary color volume to allow for
+        a greater color volume with an existing color space definition (for
+        example scRGB). It can be smaller than the primary color volume to
+        minimize gamut and tone mapping distances for big color spaces (HDR
+        metadata).
+
+        To make use of the entire target color volume a suitable pixel format
+        has to be chosen (e.g. floating point to exceed the primary color
+        volume, or abusing limited quantization range as with xvYCC).
+
+        Each coordinate value is multiplied by 1 million to get the argument
+        value to carry precision of 6 decimals.
+
+        If mastering display primaries have already been set on this object, the
+        protocol error already_set is raised.
+
+        This request can be used if the compositor advertises
+        wp_color_manager_v1.feature.set_mastering_display_primaries. Otherwise
+        this request raises the protocol error unsupported_feature. The
+        advertisement implies support only for target color volumes fully
+        contained within the primary color volume.
+
+        If a compositor additionally supports target color volume exceeding the
+        primary color volume, it must advertise
+        wp_color_manager_v1.feature.extended_target_volume. If a client uses
+        target color volume exceeding the primary color volume and the
+        compositor does not support it, the result is implementation defined.
+        Compositors are recommended to detect this case and fail the image
+        description gracefully, but it may as well result in color artifacts.
+      </description>
+
+      <arg name="r_x" type="int" summary="Red x * 1M"/>
+      <arg name="r_y" type="int" summary="Red y * 1M"/>
+      <arg name="g_x" type="int" summary="Green x * 1M"/>
+      <arg name="g_y" type="int" summary="Green y * 1M"/>
+      <arg name="b_x" type="int" summary="Blue x * 1M"/>
+      <arg name="b_y" type="int" summary="Blue y * 1M"/>
+      <arg name="w_x" type="int" summary="White x * 1M"/>
+      <arg name="w_y" type="int" summary="White y * 1M"/>
+    </request>
+
+    <request name="set_mastering_luminance">
+      <description summary="display mastering luminance range">
+        Sets the luminance range that was used during the content mastering
+        process as the minimum and maximum absolute luminance L. These values
+        include the minimum display emission and ambient flare luminances,
+        assumed to be optically additive and have the chromaticity of the
+        primary color volume white point. This should be
+        compatible with the SMPTE ST 2086 definition of HDR static metadata.
+
+        The mastering display primaries and mastering display luminances define
+        the target color volume.
+
+        If mastering luminances are not explicitly set, the target color volume
+        is assumed to have the same min and max luminances as the primary color
+        volume.
+
+        If max L is less than or equal to min L, the protocol error
+        invalid_luminance is raised.
+
+        Min L value is multiplied by 10000 to get the argument min_lum value
+        and carry precision of 4 decimals. Max L value is unscaled for max_lum.
+
+        This request can be used if the compositor advertises
+        wp_color_manager_v1.feature.set_mastering_display_primaries. Otherwise
+        this request raises the protocol error unsupported_feature. The
+        advertisement implies support only for target color volumes fully
+        contained within the primary color volume.
+
+        If a compositor additionally supports target color volume exceeding the
+        primary color volume, it must advertise
+        wp_color_manager_v1.feature.extended_target_volume. If a client uses
+        target color volume exceeding the primary color volume and the
+        compositor does not support it, the result is implementation defined.
+        Compositors are recommended to detect this case and fail the image
+        description gracefully, but it may as well result in color artifacts.
+      </description>
+
+      <arg name="min_lum" type="uint" summary="min L (cd/m²) * 10000"/>
+      <arg name="max_lum" type="uint" summary="max L (cd/m²)"/>
+    </request>
+
+    <request name="set_max_cll">
+      <description summary="maximum content light level">
+        Sets the maximum content light level (max_cll) as defined by CTA-861-H.
+
+        max_cll is undefined by default.
+      </description>
+
+      <arg name="max_cll" type="uint" summary="Maximum content light level (cd/m²)"/>
+    </request>
+
+    <request name="set_max_fall">
+      <description summary="maximum frame-average light level">
+        Sets the maximum frame-average light level (max_fall) as defined by
+        CTA-861-H.
+
+        max_fall is undefined by default.
+      </description>
+
+      <arg name="max_fall" type="uint" summary="Maximum frame-average light level (cd/m²)"/>
+    </request>
+  </interface>
+
+  <interface name="wp_image_description_v1" version="1">
+    <description summary="Colorimetric image description">
+      An image description carries information about the color encoding used on
+      a surface when attached to a wl_surface via
+      wp_color_management_surface_v1.set_image_description. A compositor can use
+      this information to decode pixel values into colorimetrically meaningful
+      quantities.
+
+      Note, that the wp_image_description_v1 object is not ready to be used
+      immediately after creation. The object eventually delivers either the
+      'ready' or the 'failed' event, specified in all requests creating it. The
+      object is deemed "ready" after receiving the 'ready' event.
+
+      An object which is not ready is illegal to use, it can only be destroyed.
+      Any other request in this interface shall result in the 'not_ready'
+      protocol error. Attempts to use an object which is not ready through other
+      interfaces shall raise protocol errors defined there.
+
+      Once created and regardless of how it was created, a
+      wp_image_description_v1 object always refers to one fixed image
+      description. It cannot change after creation.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the image description">
+        Destroy this object. It is safe to destroy an object which is not ready.
+
+        Destroying a wp_image_description_v1 object has no side-effects, not
+        even if a wp_color_management_surface_v1.set_image_description has not
+        yet been followed by a wl_surface.commit.
+      </description>
+    </request>
+
+    <enum name="error">
+      <description summary="protocol errors"/>
+
+      <entry name="not_ready" value="0"
+             summary="attempted to use an object which is not ready"/>
+      <entry name="no_information" value="1"
+             summary="get_information not allowed"/>
+    </enum>
+
+    <enum name="cause">
+      <description summary="generic reason for failure"/>
+
+      <entry name="low_version" value="0"
+             summary="interface version too low"/>
+      <entry name="unsupported" value="1"
+             summary="unsupported image description data"/>
+      <entry name="operating_system" value="2"
+             summary="error independent of the client"/>
+      <entry name="no_output" value="3"
+             summary="the relevant output no longer exists"/>
+    </enum>
+
+    <event name="failed">
+      <description summary="graceful error on creating the image description">
+        If creating a wp_image_description_v1 object fails for a reason that is
+        not defined as a protocol error, this event is sent.
+
+        The requests that create image description objects define whether and
+        when this can occur. Only such creation requests can trigger this event.
+        This event cannot be triggered after the image description was
+        successfully formed.
+
+        Once this event has been sent, the wp_image_description_v1 object will
+        never become ready and it can only be destroyed.
+      </description>
+
+      <arg name="cause" type="uint" enum="cause"
+           summary="generic reason"/>
+      <arg name="msg" type="string"
+           summary="ad hoc human-readable explanation"/>
+    </event>
+
+    <event name="ready">
+      <description summary="indication that the object is ready to be used">
+        Once this event has been sent, the wp_image_description_v1 object is
+        deemed "ready". Ready objects can be used to send requests and can be
+        used through other interfaces.
+
+        Every ready wp_image_description_v1 protocol object refers to an
+        underlying image description record in the compositor. Multiple protocol
+        objects may end up referring to the same record. Clients may identify
+        these "copies" by comparing their id numbers: if the numbers from two
+        protocol objects are identical, the protocol objects refer to the same
+        image description record. Two different image description records
+        cannot have the same id number simultaneously. The id number does not
+        change during the lifetime of the image description record.
+
+        The id number is valid only as long as the protocol object is alive. If
+        all protocol objects referring to the same image description record are
+        destroyed, the id number may be recycled for a different image
+        description record.
+
+        Image description id number is not a protocol object id. Zero is
+        reserved as an invalid id number. It shall not be possible for a client
+        to refer to an image description by its id number in protocol. The id
+        numbers might not be portable between Wayland connections. A compositor
+        shall not send an invalid id number.
+
+        This identity allows clients to de-duplicate image description records
+        and avoid get_information request if they already have the image
+        description information.
+      </description>
+
+      <arg name="identity" type="uint" summary="image description id number"/>
+    </event>
+
+    <request name="get_information">
+      <description summary="get information about the image description">
+        Creates a wp_image_description_info_v1 object which delivers the
+        information that makes up the image description.
+
+        Not all image description protocol objects allow get_information
+        request. Whether it is allowed or not is defined by the request that
+        created the object. If get_information is not allowed, the protocol
+        error no_information is raised.
+      </description>
+
+      <arg name="information"
+           type="new_id" interface="wp_image_description_info_v1"/>
+    </request>
+  </interface>
+
+  <interface name="wp_image_description_info_v1" version="1">
+    <description summary="Colorimetric image description information">
+      Sends all matching events describing an image description object exactly
+      once and finally sends the 'done' event.
+
+      This means
+      - if the image description is parametric, it must send
+        - primaries
+        - named_primaries, if applicable
+        - at least one of tf_power and tf_named, as applicable
+        - luminances
+        - target_primaries
+        - target_luminance
+      - if the image description is parametric, it may send, if applicable,
+        - target_max_cll
+        - target_max_fall
+      - if the image description contains an ICC profile, it must send the
+        icc_file event
+
+      Once a wp_image_description_info_v1 object has delivered a 'done' event it
+      is automatically destroyed.
+
+      Every wp_image_description_info_v1 created from the same
+      wp_image_description_v1 shall always return the exact same data.
+    </description>
+
+    <event name="done" type="destructor">
+      <description summary="end of information">
+        Signals the end of information events and destroys the object.
+      </description>
+    </event>
+
+    <event name="icc_file">
+      <description summary="ICC profile matching the image description">
+        The icc argument provides a file descriptor to the client which may be
+        memory-mapped to provide the ICC profile matching the image description.
+        The fd is read-only, and if mapped then it must be mapped with
+        MAP_PRIVATE by the client.
+
+        The ICC profile version and other details are determined by the
+        compositor. There is no provision for a client to ask for a specific
+        kind of a profile.
+      </description>
+
+      <arg name="icc" type="fd" summary="ICC profile file descriptor"/>
+      <arg name="icc_size" type="uint" summary="ICC profile size, in bytes"/>
+      <!-- Offset always 0, compositor must not expose unnecessary data. -->
+    </event>
+
+    <event name="primaries">
+      <description summary="primaries as chromaticity coordinates">
+        Delivers the primary color volume primaries and white point using CIE
+        1931 xy chromaticity coordinates.
+
+        Each coordinate value is multiplied by 1 million to get the argument
+        value to carry precision of 6 decimals.
+      </description>
+
+      <arg name="r_x" type="int" summary="Red x * 1M"/>
+      <arg name="r_y" type="int" summary="Red y * 1M"/>
+      <arg name="g_x" type="int" summary="Green x * 1M"/>
+      <arg name="g_y" type="int" summary="Green y * 1M"/>
+      <arg name="b_x" type="int" summary="Blue x * 1M"/>
+      <arg name="b_y" type="int" summary="Blue y * 1M"/>
+      <arg name="w_x" type="int" summary="White x * 1M"/>
+      <arg name="w_y" type="int" summary="White y * 1M"/>
+    </event>
+
+    <event name="primaries_named">
+      <description summary="named primaries">
+        Delivers the primary color volume primaries and white point using an
+        explicitly enumerated named set.
+      </description>
+
+      <arg name="primaries" type="uint" enum="wp_color_manager_v1.primaries"
+           summary="named primaries"/>
+    </event>
+
+    <event name="tf_power">
+      <description summary="transfer characteristic as a power curve">
+        The color component transfer characteristic of this image description is
+        a pure power curve. This event provides the exponent of the power
+        function. This curve represents the conversion from electrical to
+        optical pixel or color values.
+
+        The curve exponent has been multiplied by 10000 to get the argument eexp
+        value to carry the precision of 4 decimals.
+      </description>
+
+      <arg name="eexp" type="uint" summary="the exponent * 10000"/>
+    </event>
+
+    <event name="tf_named">
+      <description summary="named transfer characteristic">
+        Delivers the transfer characteristic using an explicitly enumerated
+        named function.
+      </description>
+
+      <arg name="tf" type="uint" enum="wp_color_manager_v1.transfer_function"
+           summary="named transfer function"/>
+    </event>
+
+    <event name="luminances">
+      <description summary="primary color volume luminance range and reference white">
+        Delivers the primary color volume luminance range and the reference
+        white luminance level. These values include the minimum display emission
+        and ambient flare luminances, assumed to be optically additive and have
+        the chromaticity of the primary color volume white point.
+
+        The minimum luminance is multiplied by 10000 to get the argument
+        'min_lum' value and carries precision of 4 decimals. The maximum
+        luminance and reference white luminance values are unscaled.
+      </description>
+
+      <arg name="min_lum" type="uint"
+           summary="minimum luminance (cd/m²) * 10000"/>
+      <arg name="max_lum" type="uint"
+           summary="maximum luminance (cd/m²)"/>
+      <arg name="reference_lum" type="uint"
+           summary="reference white luminance (cd/m²)"/>
+    </event>
+
+    <event name="target_primaries">
+      <description summary="target primaries as chromaticity coordinates">
+        Provides the color primaries and white point of the target color volume
+        using CIE 1931 xy chromaticity coordinates. This is compatible with the
+        SMPTE ST 2086 definition of HDR static metadata for mastering displays.
+
+        While primary color volume is about how color is encoded, the target
+        color volume is the actually displayable color volume. If target color
+        volume is equal to the primary color volume, then this event is not
+        sent.
+
+        Each coordinate value is multiplied by 1 million to get the argument
+        value to carry precision of 6 decimals.
+      </description>
+
+      <arg name="r_x" type="int" summary="Red x * 1M"/>
+      <arg name="r_y" type="int" summary="Red y * 1M"/>
+      <arg name="g_x" type="int" summary="Green x * 1M"/>
+      <arg name="g_y" type="int" summary="Green y * 1M"/>
+      <arg name="b_x" type="int" summary="Blue x * 1M"/>
+      <arg name="b_y" type="int" summary="Blue y * 1M"/>
+      <arg name="w_x" type="int" summary="White x * 1M"/>
+      <arg name="w_y" type="int" summary="White y * 1M"/>
+    </event>
+
+    <event name="target_luminance">
+      <description summary="target luminance range">
+        Provides the luminance range that the image description is targeting as
+        the minimum and maximum absolute luminance L. These values include the
+        minimum display emission and ambient flare luminances, assumed to be
+        optically additive and have the chromaticity of the primary color
+        volume white point. This should be compatible with the SMPTE ST 2086
+        definition of HDR static metadata.
+
+        This luminance range is only theoretical and may not correspond to the
+        luminance of light emitted on an actual display.
+
+        Min L value is multiplied by 10000 to get the argument min_lum value and
+        carry precision of 4 decimals. Max L value is unscaled for max_lum.
+      </description>
+
+      <arg name="min_lum" type="uint" summary="min L (cd/m²) * 10000"/>
+      <arg name="max_lum" type="uint" summary="max L (cd/m²)"/>
+    </event>
+
+    <event name="target_max_cll">
+      <description summary="target maximum content light level">
+        Provides the targeted max_cll of the image description. max_cll is
+        defined by CTA-861-H.
+
+        This luminance is only theoretical and may not correspond to the
+        luminance of light emitted on an actual display.
+      </description>
+
+      <arg name="max_cll" type="uint"
+           summary="Maximum content light-level (cd/m²)"/>
+    </event>
+
+    <event name="target_max_fall">
+      <description summary="target maximum frame-average light level">
+        Provides the targeted max_fall of the image description. max_fall is
+        defined by CTA-861-H.
+
+        This luminance is only theoretical and may not correspond to the
+        luminance of light emitted on an actual display.
+      </description>
+
+      <arg name="max_fall" type="uint"
+           summary="Maximum frame-average light level (cd/m²)"/>
+    </event>
+  </interface>
+</protocol>
diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index d85d56f06c2..cc2cc9283e8 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -219,6 +219,7 @@ static UINT get_edid(const struct output_info *output_info, unsigned char **data
     unsigned int i, mwidth, mheight;
     unsigned char c;
     struct wayland_output_mode *mode = output_info->output->current_mode;
+    const struct wayland_primaries *primaries = &output_info->output->primaries;
 
     /* assume ~150 dpi */
     mwidth = mode->width / 60;
@@ -236,10 +237,22 @@ static UINT get_edid(const struct output_info *output_info, unsigned char **data
     data[21] = mwidth;
     data[22] = mheight;
     data[24] = 0x6;
+    data[25] = ((primaries->r_x & 0x3) << 6) | ((primaries->r_y & 0x3) << 4) |
+               ((primaries->g_x & 0x3) << 2) | (primaries->g_y & 0x3);
+    data[26] = ((primaries->b_x & 0x3) << 6) | ((primaries->b_y & 0x3) << 4) |
+               ((primaries->w_x & 0x3) << 2) | (primaries->w_y & 0x3);
+    data[27] = (primaries->r_x & 0x3fc) >> 2;
+    data[28] = (primaries->r_y & 0x3fc) >> 2;
+    data[29] = (primaries->g_x & 0x3fc) >> 2;
+    data[30] = (primaries->g_y & 0x3fc) >> 2;
+    data[31] = (primaries->b_x & 0x3fc) >> 2;
+    data[32] = (primaries->b_y & 0x3fc) >> 2;
+    data[33] = (primaries->w_x & 0x3fc) >> 2;
+    data[34] = (primaries->w_y & 0x3fc) >> 2;
 
     p = data + 54;
 
-    *(uint16_t*)&p[0] = 0x0; /* reserved */
+    *(uint16_t*)&p[0] = 0x0; /* 0 = reserved */
 
     /* assume blanking time is 0 */
     p[2] = mode->width;
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 45c768f7917..fc0665309a5 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -205,6 +205,11 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
             wl_registry_bind(registry, id, &wp_cursor_shape_manager_v1_interface,
                              version < 2 ? version : 2);
     }
+    else if (strcmp(interface, "wp_color_manager_v1") == 0)
+    {
+        process_wayland.wp_color_manager_v1 =
+            wl_registry_bind(registry, id, &wp_color_manager_v1_interface, 1);
+    }
 }
 
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index 73b0b8332c5..9f414d7540e 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -40,6 +40,8 @@ static uint32_t next_output_id = 0;
 #define WAYLAND_OUTPUT_CHANGED_LOGICAL_XY 0x04
 #define WAYLAND_OUTPUT_CHANGED_LOGICAL_WH 0x08
 #define WAYLAND_OUTPUT_CHANGED_TRANSFORM  0x10
+#define WAYLAND_OUTPUT_CHANGED_PRIMARIES  0x20
+#define WAYLAND_OUTPUT_CHANGED_LUMINANCE  0x40
 
 /**********************************************************************
  *          Output handling
@@ -182,6 +184,19 @@ static void wayland_output_done(struct wayland_output *output)
         output->current.transform = output->pending.transform;
     }
 
+    if (output->pending_flags & WAYLAND_OUTPUT_CHANGED_PRIMARIES)
+    {
+        /* Copy here as well in case this gets called first */
+        output->current.primaries = output->pending.primaries;
+    }
+
+    if (output->pending_flags & WAYLAND_OUTPUT_CHANGED_LUMINANCE)
+    {
+        output->current.max_luminance = output->pending.max_luminance;
+        output->current.min_luminance = output->pending.min_luminance;
+
+    }
+
     output->pending_flags = 0;
 
     /* Ensure the logical dimensions have sane values. */
@@ -319,6 +334,155 @@ static const struct zxdg_output_v1_listener zxdg_output_v1_listener = {
     zxdg_output_v1_handle_description,
 };
 
+static void wp_image_description_info_v1_done(void *data,
+                                              struct wp_image_description_info_v1 *info)
+{
+    struct wayland_output *output = data;
+    pthread_mutex_lock(&process_wayland.output_mutex);
+
+    if (output->pending_flags & WAYLAND_OUTPUT_CHANGED_PRIMARIES)
+    {
+        output->current.primaries = output->pending.primaries;
+        output->pending_flags &= ~WAYLAND_OUTPUT_CHANGED_PRIMARIES;
+    }
+
+    if (output->pending_flags & WAYLAND_OUTPUT_CHANGED_LUMINANCE)
+    {
+        output->current.max_luminance = output->pending.max_luminance;
+        output->current.min_luminance = output->pending.min_luminance;
+        output->pending_flags &= ~WAYLAND_OUTPUT_CHANGED_LUMINANCE;
+    }
+
+    TRACE("%p\n", output);
+
+    pthread_mutex_unlock(&process_wayland.output_mutex);
+
+    maybe_init_display_devices();
+}
+
+static void wp_image_description_info_v1_icc_file(void *data,
+                                                  struct wp_image_description_info_v1 *info,
+                                                  int32_t icc, uint32_t icc_size)
+{
+
+}
+
+static void wp_image_description_info_v1_primaries(void *data,
+                                                   struct wp_image_description_info_v1 *info,
+                                                   int32_t r_x, int32_t r_y, int32_t g_x,
+			                                       int32_t g_y, int32_t b_x, int32_t b_y,
+                                                   int32_t w_x, int32_t w_y)
+{
+    struct wayland_output *output = data;
+
+    pthread_mutex_lock(&process_wayland.output_mutex);
+
+#define COPY(name) output->pending.primaries.name = round((name * 1e-6) * 1024)
+    COPY(r_x);
+    COPY(r_y);
+    COPY(g_x);
+    COPY(g_y);
+    COPY(b_x);
+    COPY(b_y);
+    COPY(w_x);
+    COPY(w_y);
+#undef COPY
+
+    TRACE("primaries: {%lf, %lf, %lf, %lf, %lf, %lf, %lf, %lf}\n",
+        r_x * 1e-6, r_y * 1e-6, g_x * 1e-6, g_y * 1e-6, b_x * 1e-6, b_y * 1e-6, w_x * 1e-6, w_y * 1e-6);
+
+    output->pending_flags |= WAYLAND_OUTPUT_CHANGED_PRIMARIES;
+
+    pthread_mutex_unlock(&process_wayland.output_mutex);
+}
+
+static void wayland_image_description_info_v1_primaries_named(void *data,
+				            struct wp_image_description_info_v1 *info,
+				            uint32_t primaries)
+{
+
+}
+
+static void wayland_image_description_info_v1_tfpower(void *data,
+				            struct wp_image_description_info_v1 *info,
+				            uint32_t power)
+{
+
+}
+
+static void wayland_image_description_info_v1_tfnamed(void *data,
+				            struct wp_image_description_info_v1 *info,
+				            uint32_t named)
+{
+
+}
+
+static void wayland_image_description_info_v1_luminance(void *data,
+                            struct wp_image_description_info_v1 *info,
+                            uint32_t min, uint32_t max, uint32_t ref)
+{
+    struct wayland_output *output = data;
+    pthread_mutex_lock(&process_wayland.output_mutex);
+
+    output->pending.max_luminance = max;
+    output->pending.min_luminance = min;
+    output->pending_flags |= WAYLAND_OUTPUT_CHANGED_LUMINANCE;
+
+    TRACE("min %lf max %u ref %u\n", min * 1e-4, max, ref);
+
+    pthread_mutex_unlock(&process_wayland.output_mutex);
+
+}
+
+static void wayland_image_description_info_v1_target_primaries(void *data,
+				 struct wp_image_description_info_v1 *info,
+				 int32_t r_x,
+				 int32_t r_y,
+				 int32_t g_x,
+				 int32_t g_y,
+				 int32_t b_x,
+				 int32_t b_y,
+				 int32_t w_x,
+				 int32_t w_y)
+{
+
+}
+
+static void wayland_image_description_info_v1_target_luminance(void *data,
+                            struct wp_image_description_info_v1 *info,
+                            uint32_t min, uint32_t max)
+{
+
+}
+
+static void wayland_image_description_info_v1_target_max_cll(void *data,
+				            struct wp_image_description_info_v1 *info,
+				            uint32_t max)
+{
+
+}
+
+static void wayland_image_description_info_v1_target_max_fall(void *data,
+				            struct wp_image_description_info_v1 *info,
+				            uint32_t max)
+{
+
+}
+
+static const struct wp_image_description_info_v1_listener image_description_info_listener = {
+    wp_image_description_info_v1_done,
+    wp_image_description_info_v1_icc_file,
+    wp_image_description_info_v1_primaries,
+    wayland_image_description_info_v1_primaries_named,
+    wayland_image_description_info_v1_tfpower,
+    wayland_image_description_info_v1_tfnamed,
+    wayland_image_description_info_v1_luminance,
+    wayland_image_description_info_v1_target_primaries,
+    wayland_image_description_info_v1_target_luminance,
+    wayland_image_description_info_v1_target_max_cll,
+    wayland_image_description_info_v1_target_max_fall
+};
+
 /**********************************************************************
  *          wayland_output_create
  *
@@ -362,6 +526,24 @@ BOOL wayland_output_create(uint32_t id, uint32_t version)
 
     if (process_wayland.zxdg_output_manager_v1)
         wayland_output_use_xdg_extension(output);
+    if (process_wayland.wp_color_manager_v1)
+    {
+        output->wp_color_management_output_v1 =
+            wp_color_manager_v1_get_output(
+                        process_wayland.wp_color_manager_v1,
+                                     output->wl_output);
+        output->wp_image_description_v1 =
+            wp_color_management_output_v1_get_image_description(
+                output->wp_color_management_output_v1
+            );
+        output->wp_image_description_info_v1 =
+            wp_image_description_v1_get_information(
+                output->wp_image_description_v1
+            );
+        wp_image_description_info_v1_add_listener(
+            output->wp_image_description_info_v1,
+            &image_description_info_listener, output);
+    }
 
     pthread_mutex_lock(&process_wayland.output_mutex);
     wl_list_insert(process_wayland.output_list.prev, &output->link);
@@ -395,6 +577,12 @@ void wayland_output_destroy(struct wayland_output *output)
     wayland_output_state_deinit(&output->current);
     if (output->zxdg_output_v1)
         zxdg_output_v1_destroy(output->zxdg_output_v1);
+    if (output->wp_color_management_output_v1)
+        wp_color_management_output_v1_destroy(output->wp_color_management_output_v1);
+    if (output->wp_image_description_v1)
+        wp_image_description_v1_destroy(output->wp_image_description_v1);
+    if (output->wp_image_description_info_v1)
+        wp_image_description_info_v1_destroy(output->wp_image_description_info_v1);
     wl_output_destroy(output->wl_output);
     free(output);
 
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 4537c934077..33864f6eab1 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -40,6 +40,7 @@
 #include "fractional-scale-v1-client-protocol.h"
 #include "tablet-v2-client-protocol.h"
 #include "cursor-shape-v1-client-protocol.h"
+#include "color-management-v1-client-protocol.h"
 
 #include "windef.h"
 #include "winbase.h"
@@ -182,6 +183,7 @@ struct wayland
     struct wl_data_device_manager *wl_data_device_manager;
     struct xdg_toplevel_icon_manager_v1 *xdg_toplevel_icon_manager_v1;
     struct wp_cursor_shape_manager_v1 *wp_cursor_shape_manager_v1;
+    struct wp_color_manager_v1 *wp_color_manager_v1;
     struct wayland_seat seat;
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
@@ -201,11 +203,26 @@ struct wayland_output_mode
     int32_t refresh;
 };
 
+struct wayland_primaries
+{
+    int32_t r_x;
+    int32_t r_y;
+    int32_t g_x;
+    int32_t g_y;
+    int32_t b_x;
+    int32_t b_y;
+    int32_t w_x;
+    int32_t w_y;
+};
+
 struct wayland_output_state
 {
     int modes_count;
     struct rb_tree modes;
     struct wayland_output_mode *current_mode;
+    struct wayland_primaries primaries;
+    uint32_t max_luminance;
+    uint32_t min_luminance;
     char *name;
     int resolved_x, resolved_y; /* store positions post overlap correction */
     int logical_x, logical_y;
@@ -218,6 +235,9 @@ struct wayland_output
     struct wl_list link;
     struct wl_output *wl_output;
     struct zxdg_output_v1 *zxdg_output_v1;
+    struct wp_color_management_output_v1 *wp_color_management_output_v1;
+    struct wp_image_description_v1 *wp_image_description_v1;
+    struct wp_image_description_info_v1 *wp_image_description_info_v1;
     uint32_t global_id;
     unsigned int pending_flags;
     struct wayland_output_state pending;
-- 
2.49.0

From 8a87d671bc3a8ee485bec4604538601466ed3723 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sun, 25 May 2025 21:37:54 -0400
Subject: [PATCH 67/78] fixup! winewayland: Support output switching.

---
 dlls/winewayland.drv/wayland_surface.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 3de12a1afe2..ea314dea032 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -712,6 +712,10 @@ static void wayland_surface_reconfigure_geometry(struct wayland_surface *surface
                 xdg_toplevel_unset_fullscreen(surface->xdg_toplevel);
                 wl_display_flush(process_wayland.wl_display);
                 xdg_toplevel_set_fullscreen(surface->xdg_toplevel, output);
+                /* In case we don't get enter event from compositor
+                   happens on sway for instance
+                */
+                surface->wl_output = output;
             }
             pthread_mutex_unlock(&process_wayland.output_mutex);
         }
-- 
2.49.0

From eaf3dd8a7d3817fd7f1e406b3228ab03d9e768a1 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sun, 25 May 2025 22:07:01 -0400
Subject: [PATCH 68/78] HACK: winewayland: Add option to offset monitor
 positions.

---
 dlls/winewayland.drv/wayland_output.c | 22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index 9f414d7540e..84eee57714b 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -131,6 +131,27 @@ static void wayland_output_mode_free_rb(struct rb_entry *entry, void *ctx)
     free(RB_ENTRY_VALUE(entry, struct wayland_output_mode, entry));
 }
 
+/* Check environment variables to look for coordinate offset */
+static void apply_user_coord_offset(int *x, int *y)
+{
+    const char *env;
+    int offset;
+
+    env = getenv("WAYLANDDRV_XOFFSET");
+    if (env && sscanf(env, "%d", &offset) == 1)
+    {
+        *x -= offset;
+        TRACE("x offset %d\n", offset);
+    }
+
+    env = getenv("WAYLANDDRV_YOFFSET");
+    if (env && sscanf(env, "%d", &offset) == 1)
+    {
+        *y -= offset;
+        TRACE("y offset %d\n", offset);
+    }
+}
+
 static void wayland_output_done(struct wayland_output *output)
 {
     struct wayland_output_mode *mode;
@@ -169,6 +190,7 @@ static void wayland_output_done(struct wayland_output *output)
     {
         output->current.logical_x = output->pending.logical_x;
         output->current.logical_y = output->pending.logical_y;
+        apply_user_coord_offset(&output->current.logical_x, &output->current.logical_y);
         output->current.resolved_x = output->current.logical_x;
         output->current.resolved_y = output->current.logical_y;
     }
-- 
2.49.0

From 334f334d93b8311e0d4170b99cdc1d2be1c480c9 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sun, 25 May 2025 22:22:17 -0400
Subject: [PATCH 69/78] winewayland: Add error message when wp_color_manager_v1
 is missing.

---
 dlls/winewayland.drv/wayland.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index fc0665309a5..29f3e48645e 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -346,6 +346,9 @@ BOOL wayland_process_init(void)
     if (!process_wayland.wp_fractional_scale_manager_v1)
         ERR("Wayland compositor doesn't support wp_fractional_scale_manager_v1 (fractional scaling will be broken)\n");
 
+    if (!process_wayland.wp_color_manager_v1)
+        ERR("Wayland compositor doesn't support wp_color_manager_v1 (HDR will not be supported)\n");
+
     process_wayland.initialized = TRUE;
 
     return TRUE;
-- 
2.49.0

From 210420dab607ffa3feb268d49fa0306e3b24d6ff Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Mon, 26 May 2025 23:39:19 -0400
Subject: [PATCH 70/78] amdxc: Only load amdxcffx when FSR4 upgrade is enabled.

---
 dlls/amdxc64/main.c | 27 ++++++++++++++++-----------
 1 file changed, 16 insertions(+), 11 deletions(-)

diff --git a/dlls/amdxc64/main.c b/dlls/amdxc64/main.c
index d4dd071b0e0..2cc11a811fc 100644
--- a/dlls/amdxc64/main.c
+++ b/dlls/amdxc64/main.c
@@ -84,23 +84,28 @@ HRESULT STDMETHODCALLTYPE AMDFSR4FFX_UpdateFfxApiProvider(IAmdExtFfxApi *iface,
 {
     const char *env;
     updateffxapi_pfn pfn;
-    HMODULE amdffx = LoadLibraryA("amdxcffx64");
+    HMODULE amdffx;
 
     TRACE("%p %p %u\n", iface, data, size);
 
-    if (!amdffx)
-    {
-        ERR("Failed to load FSR4 dll (amdxcffx)!\n");
-        return E_NOINTERFACE;
-    }
-
-    pfn = (updateffxapi_pfn)GetProcAddress(amdffx, "UpdateFfxApiProvider");
     env = getenv("FSR4_UPGRADE");
 
-    if(pfn && env && env[0] != '0')
+    if(env && env[0] != '0')
     {
-        FIXME("Replaced FSR3 with FSR4!\n");
-        return pfn(data, size);
+        amdffx = LoadLibraryA("amdxcffx64");
+        if (!amdffx)
+        {
+            ERR("Failed to load FSR4 dll (amdxcffx)!\n");
+            return E_NOINTERFACE;
+        }
+
+        pfn = (updateffxapi_pfn)GetProcAddress(amdffx, "UpdateFfxApiProvider");
+
+        if(pfn)
+        {
+            FIXME("Replaced FSR3 with FSR4!\n");
+            return pfn(data, size);
+        }
     }
 
     return E_NOINTERFACE;
-- 
2.49.0

From 048a2ad9513f37f15c054d52ff0bccf7ab444044 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Tue, 27 May 2025 00:08:02 -0400
Subject: [PATCH 71/78] winebus: Ignore steam input virtual controller when
 PROTON_PREFER_SDL is set.

---
 dlls/winebus.sys/bus_udev.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/dlls/winebus.sys/bus_udev.c b/dlls/winebus.sys/bus_udev.c
index 332e79e3ae5..f623f301bc3 100644
--- a/dlls/winebus.sys/bus_udev.c
+++ b/dlls/winebus.sys/bus_udev.c
@@ -1646,6 +1646,13 @@ static void udev_add_device(struct udev_device *dev, int fd)
 
     if (desc.vid == 0x28de && desc.pid == 0x11ff && !strcmp(subsystem, "input"))
     {
+        char *env = getenv("PROTON_PREFER_SDL");
+        if (env && !strcmp(env, "1"))
+        {
+            TRACE("evdev %s: gnoring steam input virtual controller\n", debugstr_a(devnode));
+            close(fd);
+            return;
+        }
         TRACE("evdev %s: detected steam input virtual controller\n", debugstr_a(devnode));
         desc.is_gamepad = TRUE;
         desc.version = 0; /* keep version fixed as 0 so we can hardcode it in ntdll rawinput pipe redirection */
-- 
2.49.0

From 13f805294b63bb2477e08dcbcf4c4aa397532a36 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Wed, 28 May 2025 16:04:21 -0400
Subject: [PATCH 72/78] winewayland: Refactor output selection

---
 dlls/winewayland.drv/display.c         | 64 +++++++++++++++++++++++---
 dlls/winewayland.drv/wayland_output.c  |  2 -
 dlls/winewayland.drv/wayland_surface.c | 38 +--------------
 dlls/winewayland.drv/waylanddrv.h      |  3 +-
 dlls/winewayland.drv/window.c          |  6 ++-
 5 files changed, 63 insertions(+), 50 deletions(-)

diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index cc2cc9283e8..f1eb6be8e46 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -40,6 +40,7 @@ struct output_info
 {
     int x, y;
     struct wayland_output_state *output;
+    struct wl_output *wl_output; /* FIXME: find a better place to store this */
 };
 
 static int output_info_cmp_primary_x_y(const void *va, const void *vb)
@@ -180,13 +181,6 @@ static void output_info_array_arrange_physical_coords(struct wl_array *output_in
            ++steps < num_outputs)
         continue;
 
-    /* Initialize resolved coordinates with updated coordinates */
-    wl_array_for_each(info, output_info_array)
-    {
-        info->output->resolved_x = info->x;
-        info->output->resolved_y = info->y;
-    }
-
     /* Now that we have our physical pixel coordinates, sort from physical left
      * to right, but ensure the primary output is first. */
     qsort(output_info_array->data, num_outputs, sizeof(struct output_info),
@@ -340,6 +334,62 @@ static void wayland_add_device_modes(const struct gdi_device_manager *device_man
     free(modes);
 }
 
+/* Locking is done externally to ensure wl_output remains valid */
+struct wl_output *wayland_get_best_output_for_rect(const RECT *window_rect)
+{
+    struct wayland_output *output;
+    struct wl_output *best = NULL;
+    RECT output_rect, temp, intersect = {0};
+    struct wl_array output_info_array;
+    struct output_info *output_info;
+
+    wl_array_init(&output_info_array);
+
+    wl_list_for_each(output, &process_wayland.output_list, link)
+    {
+        if (!output->current.current_mode) continue;
+        output_info = wl_array_add(&output_info_array, sizeof(*output_info));
+        if (output_info)
+        {
+            output_info->output = &output->current;
+            output_info->wl_output = output->wl_output;
+        }
+        else ERR("Failed to allocate space for output_info\n");
+    }
+
+    output_info_array_arrange_physical_coords(&output_info_array);
+
+    wl_array_for_each(output_info, &output_info_array)
+    {
+        SetRect(&output_rect, 0, 0,
+                output_info->output->current_mode->width,
+                output_info->output->current_mode->height);
+        OffsetRect(&output_rect,
+                output_info->x,
+                output_info->y);
+
+        TRACE("output %s: %s, window %s\n",
+              debugstr_a(output_info->output->name),
+              wine_dbgstr_rect(&output_rect),
+              wine_dbgstr_rect(window_rect));
+
+        if (intersect_rect(&temp, window_rect, &output_rect) &&
+                area_rect(&temp) > area_rect(&intersect))
+        {
+            intersect = temp;
+            best = output_info->wl_output;
+        }
+    }
+
+    wl_array_release(&output_info_array);
+
+    if (!best)
+        WARN("Could not find associated wl_output for rect %s!\n",
+             wine_dbgstr_rect(window_rect));
+
+    return best;
+}
+
 /***********************************************************************
  *      UpdateDisplayDevices (WAYLAND.@)
  */
diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index 84eee57714b..7c1bc4bb264 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -191,8 +191,6 @@ static void wayland_output_done(struct wayland_output *output)
         output->current.logical_x = output->pending.logical_x;
         output->current.logical_y = output->pending.logical_y;
         apply_user_coord_offset(&output->current.logical_x, &output->current.logical_y);
-        output->current.resolved_x = output->current.logical_x;
-        output->current.resolved_y = output->current.logical_y;
     }
 
     if (output->pending_flags & WAYLAND_OUTPUT_CHANGED_LOGICAL_WH)
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index ea314dea032..e0d89ba7cf6 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -611,42 +611,6 @@ static void wayland_surface_get_rect_in_monitor(struct wayland_surface *surface,
     OffsetRect(rect, -surface->window.rect.left, -surface->window.rect.top);
 }
 
-struct wl_output *wayland_surface_get_best_output(struct wayland_surface *surface)
-{
-    struct wayland_output *output;
-    struct wl_output *best = NULL;
-    RECT output_rect, temp, intersect = {0};
-    const RECT *window_rect = &surface->window.rect;
-
-    wl_list_for_each(output, &process_wayland.output_list, link)
-    {
-        SetRect(&output_rect, 0, 0,
-                output->current.current_mode->width,
-                output->current.current_mode->height);
-        OffsetRect(&output_rect,
-                output->current.resolved_x,
-                output->current.resolved_y);
-
-        TRACE("output %s: %s, window %s\n",
-              output->current.name,
-              wine_dbgstr_rect(&output_rect),
-              wine_dbgstr_rect(window_rect));
-
-        if (intersect_rect(&temp, window_rect, &output_rect) &&
-                area_rect(&temp) > area_rect(&intersect))
-        {
-            intersect = temp;
-            best = output->wl_output;
-        }
-    }
-
-    if (!best)
-        WARN("Could not find associated wl_output for rect %s!\n",
-             wine_dbgstr_rect(window_rect));
-
-    return best;
-}
-
 /**********************************************************************
  *          wayland_surface_reconfigure_geometry
  *
@@ -704,7 +668,7 @@ static void wayland_surface_reconfigure_geometry(struct wayland_surface *surface
         {
             struct wl_output *output;
             pthread_mutex_lock(&process_wayland.output_mutex);
-            output = wayland_surface_get_best_output(surface);
+            output = wayland_get_best_output_for_rect(&surface->window.rect);
             if (output != surface->wl_output)
             {
                 TRACE("Resetting fullscreen state: output %p surface output %p\n",
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 33864f6eab1..a8e9d35ba02 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -224,7 +224,6 @@ struct wayland_output_state
     uint32_t max_luminance;
     uint32_t min_luminance;
     char *name;
-    int resolved_x, resolved_y; /* store positions post overlap correction */
     int logical_x, logical_y;
     int logical_w, logical_h;
     int transform;
@@ -335,6 +334,7 @@ BOOL wayland_process_init(void);
 BOOL wayland_output_create(uint32_t id, uint32_t version);
 void wayland_output_destroy(struct wayland_output *output);
 void wayland_output_use_xdg_extension(struct wayland_output *output);
+struct wl_output *wayland_get_best_output_for_rect(const RECT *window_rect);
 
 /**********************************************************************
  *          Wayland surface
@@ -366,7 +366,6 @@ void wayland_client_surface_detach(struct wayland_client_surface *client);
 void wayland_surface_ensure_contents(struct wayland_surface *surface);
 void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR title);
 void wayland_surface_set_icon(struct wayland_surface *surface, UINT type, ICONINFO *ii);
-struct wl_output *wayland_surface_get_best_output(struct wayland_surface *surface);
 
 static inline BOOL wayland_surface_is_toplevel(struct wayland_surface *surface)
 {
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 99769dce0b5..2752ad2a469 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -274,9 +274,11 @@ static void wayland_surface_update_state_toplevel(struct wayland_surface *surfac
         if ((surface->window.state & WAYLAND_SURFACE_CONFIG_STATE_FULLSCREEN) &&
            !(surface->current.state & WAYLAND_SURFACE_CONFIG_STATE_FULLSCREEN))
         {
+            struct wl_output *output;
             pthread_mutex_lock(&process_wayland.output_mutex);
-            xdg_toplevel_set_fullscreen(surface->xdg_toplevel,
-                        wayland_surface_get_best_output(surface));
+            output = wayland_get_best_output_for_rect(&surface->window.rect);
+            xdg_toplevel_set_fullscreen(surface->xdg_toplevel, output);
+            surface->wl_output = output;
             pthread_mutex_unlock(&process_wayland.output_mutex);
         }
     }
-- 
2.49.0

From d7e0460c4fb895f05f295dedb9968952ed273f28 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Wed, 28 May 2025 16:43:23 -0400
Subject: [PATCH 73/78] winebus: PROTON_PREFER_SDL -> PROTON_USE_SDL

More accurately name the env
---
 dlls/winebus.sys/bus_udev.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winebus.sys/bus_udev.c b/dlls/winebus.sys/bus_udev.c
index f623f301bc3..4ea0ce6fec6 100644
--- a/dlls/winebus.sys/bus_udev.c
+++ b/dlls/winebus.sys/bus_udev.c
@@ -1646,7 +1646,7 @@ static void udev_add_device(struct udev_device *dev, int fd)
 
     if (desc.vid == 0x28de && desc.pid == 0x11ff && !strcmp(subsystem, "input"))
     {
-        char *env = getenv("PROTON_PREFER_SDL");
+        char *env = getenv("PROTON_USE_SDL");
         if (env && !strcmp(env, "1"))
         {
             TRACE("evdev %s: gnoring steam input virtual controller\n", debugstr_a(devnode));
-- 
2.49.0

From 7f475257aa54e48f21c603af5adfffddb18d8ee7 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Wed, 28 May 2025 22:20:47 -0400
Subject: [PATCH 74/78] HACK: winewayland: Send relative event with absolute
 event.

---
 dlls/winewayland.drv/wayland_pointer.c | 22 ++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  3 +++
 2 files changed, 25 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index cc1941cece2..a306facf287 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -124,6 +124,7 @@ static void pointer_handle_motion_internal(wl_fixed_t sx, wl_fixed_t sy)
     POINT screen;
     struct wayland_surface *surface;
     struct wayland_win_data *data;
+    struct wayland_pointer *pointer = &process_wayland.pointer;
 
     if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
     if (!(data = wayland_win_data_get(hwnd))) return;
@@ -159,6 +160,25 @@ static void pointer_handle_motion_internal(wl_fixed_t sx, wl_fixed_t sy)
           hwnd, wl_fixed_to_double(sx), wl_fixed_to_double(sy),
           (int)screen.x, (int)screen.y);
 
+    if (InterlockedCompareExchange(&pointer->confinement_updated, FALSE, TRUE))
+    {
+        TRACE("Ignoring, confinement was updated recently!\n");
+        pointer->last_x = screen.x;
+        pointer->last_y = screen.y;
+        return;
+    }
+
+    NtUserSendHardwareInput(hwnd, 0, &input, 0);
+
+    input.mi.dx -= pointer->last_x;
+    input.mi.dy -= pointer->last_y;
+    input.mi.dwFlags = MOUSEEVENTF_MOVE;
+
+    TRACE("relative=%d,%d\n", input.mi.dx, input.mi.dy);
+
+    pointer->last_x = screen.x;
+    pointer->last_y = screen.y;
+
     NtUserSendHardwareInput(hwnd, 0, &input, 0);
 }
 
@@ -1038,6 +1058,8 @@ static void wayland_pointer_update_constraint(struct wl_surface *wl_surface,
         pointer->zwp_relative_pointer_v1 = NULL;
         TRACE("Disabling relative motion\n");
     }
+
+    InterlockedExchange(&pointer->confinement_updated, TRUE);
 }
 
 void wayland_pointer_clear_constraint(void)
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index a8e9d35ba02..30de87faf20 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -115,8 +115,11 @@ struct wayland_pointer
     HWND focused_hwnd;
     HWND constraint_hwnd;
     BOOL pending_warp;
+    BOOL confinement_updated;
     uint32_t enter_serial;
     uint32_t button_serial;
+    LONG last_x;
+    LONG last_y;
     struct wayland_cursor cursor;
     double accum_x;
     double accum_y;
-- 
2.49.0

From 866041dc20e51019f8998301662497bc3c2e1e0b Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Fri, 30 May 2025 11:17:38 -0400
Subject: [PATCH 75/78] winewayland: Update min/max window based on window
 resizability

---
 dlls/winewayland.drv/wayland_surface.c | 70 +++++++++++++++++++-------
 1 file changed, 53 insertions(+), 17 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index e0d89ba7cf6..3d30c37e58a 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -611,6 +611,15 @@ static void wayland_surface_get_rect_in_monitor(struct wayland_surface *surface,
     OffsetRect(rect, -surface->window.rect.left, -surface->window.rect.top);
 }
 
+static BOOL is_window_resizable(struct wayland_surface *surface)
+{
+    DWORD style = NtUserGetWindowLongW(surface->hwnd, GWL_STYLE);
+
+    if (style & WS_THICKFRAME) return TRUE;
+
+    return surface->current.state & WAYLAND_SURFACE_CONFIG_STATE_FULLSCREEN;
+}
+
 /**********************************************************************
  *          wayland_surface_reconfigure_geometry
  *
@@ -662,26 +671,53 @@ static void wayland_surface_reconfigure_geometry(struct wayland_surface *surface
                                         rect.left, rect.top,
                                         rect.right - rect.left,
                                         rect.bottom - rect.top);
-        /* HACK: reset fullscreen state to ensure surface is on correct output */
-        if (surface->current.state & WAYLAND_SURFACE_CONFIG_STATE_FULLSCREEN
-            && wayland_surface_is_toplevel(surface))
+        if (wayland_surface_is_toplevel(surface))
         {
-            struct wl_output *output;
-            pthread_mutex_lock(&process_wayland.output_mutex);
-            output = wayland_get_best_output_for_rect(&surface->window.rect);
-            if (output != surface->wl_output)
+            /* HACK: update min/max size depending on if the window is resizable */
+            if (!is_window_resizable(surface))
             {
-                TRACE("Resetting fullscreen state: output %p surface output %p\n",
-                      output, surface->wl_output);
-                xdg_toplevel_unset_fullscreen(surface->xdg_toplevel);
-                wl_display_flush(process_wayland.wl_display);
-                xdg_toplevel_set_fullscreen(surface->xdg_toplevel, output);
-                /* In case we don't get enter event from compositor
-                   happens on sway for instance
-                */
-                surface->wl_output = output;
+                xdg_toplevel_set_min_size(
+                    surface->xdg_toplevel,
+                    rect.right - rect.left,
+                    rect.bottom - rect.top);
+                xdg_toplevel_set_max_size(
+                    surface->xdg_toplevel,
+                    rect.right - rect.left,
+                    rect.bottom - rect.top
+                );
+            }
+            else
+            {
+                xdg_toplevel_set_min_size(
+                    surface->xdg_toplevel,
+                    0, 0
+                );
+                xdg_toplevel_set_max_size(
+                    surface->xdg_toplevel,
+                    0, 0
+                );
+            }
+
+            /* HACK: reset fullscreen state to ensure surface is on correct output */
+            if (surface->current.state & WAYLAND_SURFACE_CONFIG_STATE_FULLSCREEN)
+            {
+                struct wl_output *output;
+                pthread_mutex_lock(&process_wayland.output_mutex);
+                output = wayland_get_best_output_for_rect(&surface->window.rect);
+                if (output != surface->wl_output)
+                {
+                    TRACE("Resetting fullscreen state: output %p surface output %p\n",
+                        output, surface->wl_output);
+                    xdg_toplevel_unset_fullscreen(surface->xdg_toplevel);
+                    wl_display_flush(process_wayland.wl_display);
+                    xdg_toplevel_set_fullscreen(surface->xdg_toplevel, output);
+                    /* In case we don't get enter event from compositor
+                    happens on sway for instance
+                    */
+                    surface->wl_output = output;
+                }
+                pthread_mutex_unlock(&process_wayland.output_mutex);
             }
-            pthread_mutex_unlock(&process_wayland.output_mutex);
         }
     }
 }
-- 
2.49.0

From 4db7558df22f3ec27b0f835a9b7906b5afcfa788 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sun, 1 Jun 2025 09:45:29 -0400
Subject: [PATCH 76/78] winewayland: add opcode 3 of
 zwlr_data_control_device_v1_listener.

---
 dlls/winewayland.drv/wayland_data_device.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device.c b/dlls/winewayland.drv/wayland_data_device.c
index e36c0cc9229..429baa2f2f8 100644
--- a/dlls/winewayland.drv/wayland_data_device.c
+++ b/dlls/winewayland.drv/wayland_data_device.c
@@ -585,11 +585,19 @@ static void data_control_device_finished(
 {
 }
 
+static void data_control_device_primary_selection(
+    void *data, struct zwlr_data_control_device_v1 *zwlr_data_control_device_v1,
+    struct zwlr_data_control_offer_v1 *id
+)
+{
+}
+
 static const struct zwlr_data_control_device_v1_listener data_control_device_listener =
 {
     data_control_device_data_offer,
     data_control_device_selection,
     data_control_device_finished,
+    data_control_device_primary_selection
 };
 
 /**********************************************************************
-- 
2.49.0

From 6f4be2f69ea29412c8127b9b9116f13f1d263b78 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sun, 1 Jun 2025 18:57:16 -0400
Subject: [PATCH 77/78] winewayland: systray skeleton

---
 dlls/winewayland.drv/Makefile.in       |   3 +-
 dlls/winewayland.drv/wayland_tray.c    | 101 +++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |   4 +
 dlls/winewayland.drv/waylanddrv_main.c |   4 +
 4 files changed, 111 insertions(+), 1 deletion(-)
 create mode 100644 dlls/winewayland.drv/wayland_tray.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index fba6b916cee..ca313b8f7e6 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,6 +1,6 @@
 MODULE = winewayland.drv
 UNIXLIB = winewayland.so
-UNIX_CFLAGS = $(EGL_CFLAGS) $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_EGL_CFLAGS) $(XKBCOMMON_CFLAGS) $(XKBREGISTRY_CFLAGS)
+UNIX_CFLAGS = $(EGL_CFLAGS) $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_EGL_CFLAGS) $(XKBCOMMON_CFLAGS) $(XKBREGISTRY_CFLAGS) $(DBUS_CFLAGS)
 UNIX_LIBS = -lwin32u $(WAYLAND_CLIENT_LIBS) $(WAYLAND_EGL_LIBS) $(XKBCOMMON_LIBS) $(XKBREGISTRY_LIBS) $(PTHREAD_LIBS) -lm
 IMPORTS = user32 win32u
 
@@ -25,6 +25,7 @@ SOURCES = \
 	wayland_pointer.c \
 	wayland_surface.c \
 	wayland_text_input.c \
+	wayland_tray.c \
 	waylanddrv_main.c \
 	window.c \
 	window_surface.c \
diff --git a/dlls/winewayland.drv/wayland_tray.c b/dlls/winewayland.drv/wayland_tray.c
new file mode 100644
index 00000000000..93e737c6949
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_tray.c
@@ -0,0 +1,101 @@
+/*
+ * Wayland system tray
+ *
+ * Copyright 2025 Etaash Mathamsetty
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+
+#ifdef SONAME_LIBDBUS_1
+#include <dbus/dbus.h>
+#endif
+
+WINE_DEFAULT_DEBUG_CHANNEL(systray);
+
+
+#ifdef SONAME_LIBDBUS_1
+
+
+void WAYLAND_SystrayDockInit(HWND hwnd)
+{
+    TRACE("hwnd %p\n", hwnd);
+}
+
+void WAYLAND_SystrayDockClear(HWND hwnd)
+{
+    TRACE("hwnd %p\n", hwnd);
+}
+
+BOOL WAYLAND_SystrayDockInsert(HWND hwnd, UINT cx, UINT cy, void *icon)
+{
+    TRACE("hwnd %p (cx, cy)=(%u, %u) icon %p\n", hwnd, cx, cy, icon);
+
+    return FALSE;
+}
+
+BOOL WAYLAND_SystrayDockRemove(HWND hwnd)
+{
+    TRACE("hwnd %p\n", hwnd);
+
+    return FALSE;
+}
+
+#else
+
+static int once;
+
+void WAYLAND_SystrayDockInit(HWND hwnd)
+{
+    if (!once++)
+        ERR("dbus support was not compiled in!\n");
+}
+
+void WAYLAND_SystrayDockClear(HWND hwnd)
+{
+    if (!once++)
+        ERR("dbus support was not compiled in!\n");
+}
+
+BOOL WAYLAND_SystrayDockRemove(HWND hwnd)
+{
+    if (!once++)
+        ERR("dbus support was not compiled in!\n");
+
+    return FALSE;
+}
+
+BOOL WAYLAND_SystrayDockInsert(HWND hwnd, UINT cx, UINT cy, void *icon)
+{
+    if (!once++)
+        ERR("dbus support was not compiled in!\n");
+
+    return FALSE;
+}
+
+#endif
+
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 30de87faf20..29f692a891e 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -500,6 +500,10 @@ void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, HWND owner_hint, UIN
 BOOL WAYLAND_WindowPosChanging(HWND hwnd, UINT swp_flags, BOOL shaped, const struct window_rects *rects);
 BOOL WAYLAND_CreateWindowSurface(HWND hwnd, BOOL layered, const RECT *surface_rect, struct window_surface **surface);
 BOOL WAYLAND_HasWindowManager(const char *name);
+void WAYLAND_SystrayDockInit(HWND hwnd);
+void WAYLAND_SystrayDockClear(HWND hwnd);
+BOOL WAYLAND_SystrayDockRemove(HWND hwnd);
+BOOL WAYLAND_SystrayDockInsert(HWND hwnd, UINT cx, UINT cy, void *icon);
 UINT WAYLAND_VulkanInit(UINT version, void *vulkan_handle, const struct vulkan_driver_funcs **driver_funcs);
 struct opengl_funcs *WAYLAND_wine_get_wgl_driver(UINT version);
 
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 83a60848362..9da551d13b1 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -57,6 +57,10 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pWindowPosChanging = WAYLAND_WindowPosChanging,
     .pCreateWindowSurface = WAYLAND_CreateWindowSurface,
     .pHasWindowManager = WAYLAND_HasWindowManager,
+    .pSystrayDockInit = WAYLAND_SystrayDockInit,
+    .pSystrayDockInsert = WAYLAND_SystrayDockInsert,
+    .pSystrayDockClear = WAYLAND_SystrayDockClear,
+    .pSystrayDockRemove = WAYLAND_SystrayDockRemove,
     .pVulkanInit = WAYLAND_VulkanInit,
     .pwine_get_wgl_driver = WAYLAND_wine_get_wgl_driver,
 };
-- 
2.49.0

From 067985ce8f2079076f9ccf6bd0c4c94c7908b97e Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sun, 1 Jun 2025 20:42:27 -0400
Subject: [PATCH 78/78] fixup! HACK: winewayland: Send relative event with
 absolute event.

---
 dlls/winewayland.drv/wayland_pointer.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index a306facf287..4dd1fab1c31 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -179,7 +179,7 @@ static void pointer_handle_motion_internal(wl_fixed_t sx, wl_fixed_t sy)
     pointer->last_x = screen.x;
     pointer->last_y = screen.y;
 
-    NtUserSendHardwareInput(hwnd, 0, &input, 0);
+    NtUserSendHardwareInput(hwnd, SEND_HWMSG_NO_MSG, &input, 0);
 }
 
 static void pointer_handle_motion(void *data, struct wl_pointer *wl_pointer,
-- 
2.49.0

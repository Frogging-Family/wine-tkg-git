From 81a2fd72d94e83f8972e32defea996cd4475cd3b Mon Sep 17 00:00:00 2001
From: Tk-Glitch <ti3nou@gmail.com>
Date: Tue, 29 Sep 2020 12:38:36 +0200
Subject: [PATCH 1/1] 01-staging-hotfixes

---
 ...ediag-message-to-show-warning-that-t.patch |   79 +-
 ...-Staging-at-the-end-of-the-version-s.patch |   52 +-
 ...ndline-option-patches-to-show-the-pa.patch |  117 ++
 patches/Staging/definition                    |    1 -
 .../0001-ntdll-Implement-NtFilterToken.patch  |  315 +++++
 ...pi32-Implement-CreateRestrictedToken.patch |  132 ++
 .../advapi32-CreateRestrictedToken/definition |    1 +
 ...mplement-token-elevation-information.patch |   51 +-
 ...rver-Implement-token-integrity-level.patch |   50 +-
 ...on-to-create-new-tokens-for-elevatio.patch |   38 +-
 ...process-token-elevation-through-mani.patch |   36 +-
 ...-support-for-creating-processes-usin.patch |  319 +++++
 ...y-assign-security-labels-for-tokens.patch} |   64 +-
 ...stub-for-TokenLinkedToken-info-class.patch |   35 +-
 .../advapi32-Token_Integrity_Level/definition |    5 +-
 ...-BCryptSecretAgreement-with-libgcryp.patch |   41 +-
 ...dd-the-absolute-RPATH-when-linking-a.patch |   30 +
 patches/configure-Absolute_RPATH/definition   |    1 +
 ...d.drv-winemac.drv-winex11.drv-Store-.patch |    2 +-
 ...ert-to-old-implementation-of-hung-qu.patch |    4 +-
 patches/eventfd_synchronization/definition    |    4 +-
 ...32-Make-K32GetPerformanceInfo-faster.patch |  131 ++
 .../kernel32-K32GetPerformanceInfo/definition |    1 +
 ...ement-some-processor-group-functions.patch |   36 +-
 ...rnel32-Implement-SetProcessDEPPolicy.patch |   22 +-
 ...ernel32-Implement-GetSystemDEPPolicy.patch |   12 +-
 patches/kernelbase-CreateFile2/definition     |    1 +
 ...user32-Improve-GetKeyboardLayoutList.patch |   28 +-
 ...port-for-multiple-parent-directories.patch |   51 +-
 .../0024-mf-Introduce-handler-helper.patch    |    5 +-
 ...-async-fileio-structures-if-possible.patch |   28 +-
 .../0001-ntdll-Add-dummy-apiset-to-PEB.patch  |   30 +-
 patches/ntdll-ApiSetMap/definition            |    2 +-
 ...0001-ntdll-Fix-holes-in-ELF-mappings.patch |   32 +-
 ...-versions-of-RtlEnterCriticalSection.patch |   18 +-
 ...retrieving-DOS-attributes-in-NtQuery.patch |  150 +++
 ...retrieving-DOS-attributes-in-fd_-get.patch |  122 --
 ...retrieving-DOS-attributes-in-NtQuery.patch |   69 ++
 ...storing-DOS-attributes-in-NtSetInfor.patch |  193 +--
 ...storing-DOS-attributes-in-NtCreateFi.patch |  228 ++--
 ...ort-for-Mac-OS-X-style-extended-attr.patch |   73 +-
 ...ort-for-FreeBSD-style-extended-attri.patch |   75 +-
 ...e-Unix-style-hidden-file-check-withi.patch |   83 +-
 ...re-SAMBA_XATTR_DOS_ATTRIB-when-path-.patch |   26 +-
 patches/ntdll-DOS_Attributes/definition       |    1 +
 ...ow-to-allocate-thread-stack-for-curr.patch |   40 +-
 ...e-device-type-when-systemroot-is-loc.patch |   54 +
 .../ntdll-DeviceType_Systemroot/definition    |    1 +
 ...gString-should-throw-the-exception-a.patch |   63 +-
 ...ase-Maintain-FLS-storage-list-in-PEB.patch |   30 +-
 .../definition                                |    1 +
 ...t-for-FileFsFullSizeInformation-clas.patch |  104 +-
 ...tectVirtualMemory-and-NtCreateSectio.patch |   22 +-
 ...h-on-mmap-error-in-try_map_free_area.patch |   35 +
 ...ree-ranges-view-block-size-on-64-bit.patch |   29 -
 ...XED_NOREPLACE-flag-in-try_map_free_a.patch |   51 +
 ...om-up-allocation-order-for-64-bit-ar.patch |   58 +
 ...tively-mapped-areas-from-free-areas-.patch |  256 ----
 ...ep-after-failed-map-attempt-in-try_.patch} |   11 +-
 ...ea-list-for-virtual-memory-allocati.patch} |  375 +++---
 ...y-exclude-natively-mapped-areas-from.patch |   66 +
 ...t-HashLinks-field-in-LDR-module-data.patch |   72 +-
 ...-Improve-heap-allocation-performance.patch |  106 +-
 ...t-for-hiding-wine-version-informatio.patch |   62 +-
 patches/ntdll-Hide_Wine_Exports/definition    |    2 +
 ...tch-windows-int-0x2e-syscall-on-i386.patch |   22 +-
 ...-support-for-junction-point-creation.patch |  485 ++++----
 ...-support-for-reading-junction-points.patch |  151 ++-
 ...support-for-deleting-junction-points.patch |  174 +--
 ...est-for-junction-point-advertisement.patch |    6 +-
 ...dd-support-for-deleting-junction-poi.patch |  107 ++
 ...rt-for-deleting-junction-points-with.patch |  206 ----
 ...upport-for-absolute-symlink-creation.patch |  159 ++-
 ...upport-for-reading-absolute-symlinks.patch |   96 +-
 ...ll-Add-support-for-deleting-symlinks.patch |   32 +-
 ...upport-for-relative-symlink-creation.patch |  304 ++---
 ...upport-for-reading-relative-symlinks.patch |  153 +--
 ...-ntdll-Add-support-for-file-symlinks.patch |  122 +-
 ...tion-of-dangling-reparse-points-to-n.patch |   49 +-
 ...-report-file-symbolic-links-as-files.patch |  114 +-
 ...or-code-when-attempting-to-delete-fi.patch |   29 +-
 ...roperly-handle-file-symlink-deletion.patch |   77 +-
 ...ort-symbolic-links-as-containing-zer.patch |   66 +-
 ...ntdll-Find-dangling-symlinks-quickly.patch |   22 +-
 ...-Add-reparse-support-to-FindNextFile.patch |   45 -
 ...arse-point-type-in-directory-listing.patch |   50 -
 ...se-point-target-in-directory-listing.patch |   72 --
 ...Add-junction-point-support-to-mklink.patch |   86 --
 ...btaining-information-about-a-symlink.patch |  140 ---
 patches/ntdll-Junction_Points/definition      |    3 +-
 ...l32-Advertise-junction-point-support.patch |   45 +-
 ...t-CreateSymbolicLink-A-W-with-ntdll.patch} |  102 +-
 ...valid-paramater-handling-in-NtAccess.patch |   51 +-
 .../0001-ntdll-Add-stub-for-NtContinue.patch  |   63 +
 ...o-continue-execution-after-exception.patch |   82 ++
 patches/ntdll-NtContinue/definition           |    3 +
 ...opening-files-through-nt-device-path.patch |  167 +--
 ...-ntdll-Improve-stub-of-NtQueryEaFile.patch |   81 +-
 patches/ntdll-NtQueryEaFile/definition        |    2 +
 ...NtQueryVirtualMemory-MemorySectionNa.patch |   95 +-
 ...tests-for-NtQueryVirtualMemory-Memor.patch |   21 +-
 ...test-to-ensure-section-name-is-full-.patch |   24 +-
 ...ive-symlinks-before-returning-sectio.patch |   75 +-
 patches/ntdll-NtQueryVirtualMemory/definition |    5 -
 ...0001-ntdll-Implement-NtSetLdtEntries.patch |   10 +-
 ...Allow-to-modify-reserved-LDT-entries.patch |   18 +-
 ...low-special-characters-in-pipe-names.patch |   24 +-
 ...ata-implementation-for-ProcessQuotaL.patch |   38 +-
 ...tlCreateUserThread-into-NtCreateThre.patch |  321 +++++
 patches/ntdll-RtlCreateUserThread/definition  |    2 +
 ...TUS_INVALID_DEVICE_REQUEST-when-tryi.patch |   40 +-
 ...dll-Support-x86_64-syscall-emulation.patch |  178 +--
 patches/ntdll-Syscall_Emulation/definition    |    2 +-
 ...temInformation-support-SystemCodeInt.patch |   43 +-
 ...or-NtQuerySystemInformation-SystemEx.patch |   31 +-
 ...fer-filled-with-random-values-from-S.patch |   39 +
 .../definition                                |    1 +
 ...-LdrQueryProcessModuleInformation-in.patch |   50 +
 ...ll.dll-as-the-first-entry-for-System.patch |   60 +
 ...or-NtQuerySystemInformation-SystemMo.patch |   87 +-
 ...l-handling-for-SystemRoot-to-satisfy.patch |   42 +
 patches/ntdll-SystemRoot_Symlink/definition   |    1 +
 ...rect-values-in-GetThreadTimes-for-al.patch |  163 +++
 ...t-thread-creation-time-for-SystemPro.patch |   74 ++
 ...ll-Fill-process-kernel-and-user-time.patch |  162 +++
 .../0004-ntdll-Set-process-start-time.patch   |   64 +
 ...-thread-times-in-process-enumeration.patch |   82 ++
 ...ss-virtual-memory-counters-in-NtQuer.patch |  105 ++
 patches/ntdll-ThreadTime/definition           |    3 +
 patches/ntdll-Thread_Stack/definition         |    1 +
 ...ondition-when-threads-are-killed-dur.patch |   42 +-
 patches/ntdll-Threading/definition            |    2 -
 ...ite-watches-before-passing-userdata-.patch |   23 +-
 ...mporary-signal-handler-during-proces.patch |  169 +--
 ...andle-PAGE_WRITECOPY-protection.-try.patch |   38 +-
 ...f-a-WRITECOPY-page-has-been-modified.patch |   34 +-
 .../0006-ntdll-Support-WRITECOPY-on-x64.patch |   37 +-
 ...unmodified-WRITECOPY-pages-as-shared.patch |   18 +-
 ...Fallback-to-copy-pages-for-WRITECOPY.patch |   26 +-
 patches/ntdll-WRITECOPY/definition            |    2 +-
 ...01-ntdll-Initialize-mod_name-to-zero.patch |   10 +-
 ...tore-TEB-to-x18-on-aarch-64-on-retur.patch |   32 +-
 ...k-drive_c-as-case-insensitive-when-c.patch |   26 +-
 ...S-segment-prefixes-in-set_full_cpu_c.patch |   18 +-
 ...Ds-to-be-identical-to-SegSs-on-x86_6.patch |   18 +-
 .../0003-nvcuda-First-implementation.patch    |   34 +-
 ...wrap-stream-callbacks-by-forwarding-.patch |   19 +-
 ...lement-cuModuleLoad-wrapper-function.patch |   56 +-
 .../0001-nvcuvid-First-implementation.patch   |   67 +-
 ...001-nvencodeapi-First-implementation.patch |   33 +-
 patches/patchinstall.sh                       | 1083 ++++++++++++-----
 ...-file-which-has-a-memory-mapping-sho.patch |   45 +-
 ...open-files-without-any-permission-bi.patch |   18 +-
 ...-a-helper-function-to-update-the-thr.patch |   30 +-
 ...SystemExtendedHandleInformation-in-N.patch |  166 +--
 ...ObjectTypesInformation-in-NtQueryObj.patch |  211 ++--
 ...server-Register-types-during-startup.patch |   10 +-
 ...dex-for-ObjectTypeInformation-in-NtQ.patch |   53 +-
 ...-type-for-System-Extended-HandleInfo.patch |   76 +-
 ...ct-type-behavior-for-different-windo.patch |  147 ++-
 patches/server-Object_Types/definition        |    3 +-
 ...ing-of-GetMessage-after-previous-Pee.patch |   54 +-
 ...-to-implement-priority-levels-throug.patch |   18 +-
 patches/server-Realtime_Priority/definition   |    1 +
 ...ecessary-wineserver-calls-in-PeekMes.patch |    6 +-
 ...f-wineserver-call-for-GetLastInputIn.patch |    4 +-
 ...ist-of-associated-queues-for-each-th.patch |    9 +-
 patches/server-Shared_Memory/definition       |    2 -
 ...ignal-thread-until-it-is-really-gone.patch |   22 +-
 ...per-function-set_sd_from_token_inter.patch |   34 +-
 ...e-security-attributes-with-extended-.patch |   67 +-
 ...file-security-attributes-with-extend.patch |   47 +-
 ...-handling-of-invert_y-in-DrawTextExW.patch |   20 +-
 ...nitial-implementation-of-GTK-backend.patch |   61 +-
 ...a-drive-serial-number-during-prefix-.patch |    6 +-
 ...-tests-Add-basic-tests-for-fake-dlls.patch |  121 ++
 ...-not-abuse-WOW32Reserved-field-for-1.patch |  660 ++++++++++
 ...ate-syscall-thunks-for-ntdll-exports.patch |  464 +++++++
 ...ltipass-label-system-to-generate-fak.patch |  430 +++++++
 ...uild-Add-stub-functions-in-fake-dlls.patch |  440 +++++++
 ...uild-Add-syscall-thunks-in-fake-dlls.patch |   76 ++
 ...ze-of-relocation-information-in-fake.patch |   27 +
 ...-make-sure-RVA-matches-between-fake-.patch |   99 ++
 ...me-file-alignment-for-fake-and-built.patch |   38 +
 ...ebuild-Add-syscall-thunks-for-64-bit.patch |  490 ++++++++
 ...all-NtOpenFile-through-syscall-thunk.patch |  132 ++
 .../definition                                |    2 +-
 ..._wine_syscall_dispatcher-through-the.patch |   77 --
 ...ice-Load-some-common-drivers-and-fix.patch |   14 +-
 ...ub-implementation-of-Wow64Transition.patch |   44 +-
 patches/wow64cpu-Wow64Transition/definition   |    1 +
 .../0001-wpcap-Load-libpcap-dynamically.patch |   47 +-
 patches/ws2_32-TransmitFile/definition        |    2 -
 194 files changed, 10570 insertions(+), 4952 deletions(-)
 create mode 100644 patches/Staging/0003-loader-Add-commandline-option-patches-to-show-the-pa.patch
 delete mode 100644 patches/Staging/definition
 create mode 100644 patches/advapi32-CreateRestrictedToken/0001-ntdll-Implement-NtFilterToken.patch
 create mode 100644 patches/advapi32-CreateRestrictedToken/0002-advapi32-Implement-CreateRestrictedToken.patch
 create mode 100644 patches/advapi32-CreateRestrictedToken/definition
 create mode 100644 patches/advapi32-Token_Integrity_Level/0010-server-Implement-support-for-creating-processes-usin.patch
 rename patches/advapi32-Token_Integrity_Level/{XX13-server-Correctly-assign-security-labels-for-tokens.patch => 0013-server-Correctly-assign-security-labels-for-tokens.patch} (80%)
 create mode 100644 patches/configure-Absolute_RPATH/0001-configure-Also-add-the-absolute-RPATH-when-linking-a.patch
 create mode 100644 patches/configure-Absolute_RPATH/definition
 create mode 100644 patches/kernel32-K32GetPerformanceInfo/0001-kernel32-Make-K32GetPerformanceInfo-faster.patch
 create mode 100644 patches/kernel32-K32GetPerformanceInfo/definition
 create mode 100644 patches/kernelbase-CreateFile2/definition
 create mode 100644 patches/ntdll-DOS_Attributes/0001-ntdll-Implement-retrieving-DOS-attributes-in-NtQuery.patch
 delete mode 100644 patches/ntdll-DOS_Attributes/0001-ntdll-Implement-retrieving-DOS-attributes-in-fd_-get.patch
 create mode 100644 patches/ntdll-DOS_Attributes/0002-ntdll-Implement-retrieving-DOS-attributes-in-NtQuery.patch
 create mode 100644 patches/ntdll-DeviceType_Systemroot/0001-ntdll-Return-fake-device-type-when-systemroot-is-loc.patch
 create mode 100644 patches/ntdll-DeviceType_Systemroot/definition
 create mode 100644 patches/ntdll-ForceBottomUpAlloc/0001-ntdll-Stop-search-on-mmap-error-in-try_map_free_area.patch
 delete mode 100644 patches/ntdll-ForceBottomUpAlloc/0002-ntdll-Increase-free-ranges-view-block-size-on-64-bit.patch
 create mode 100644 patches/ntdll-ForceBottomUpAlloc/0002-ntdll-Use-MAP_FIXED_NOREPLACE-flag-in-try_map_free_a.patch
 create mode 100644 patches/ntdll-ForceBottomUpAlloc/0003-ntdll-Force-bottom-up-allocation-order-for-64-bit-ar.patch
 delete mode 100644 patches/ntdll-ForceBottomUpAlloc/0004-ntdll-Exclude-natively-mapped-areas-from-free-areas-.patch
 rename patches/ntdll-ForceBottomUpAlloc/{0001-ntdll-Increase-step-after-failed-map-attempt-in-try_.patch => 0004-ntdll-Increase-step-after-failed-map-attempt-in-try_.patch} (56%)
 rename patches/ntdll-ForceBottomUpAlloc/{0003-ntdll-Force-virtual-memory-allocation-order.patch => 0005-ntdll-Use-free-area-list-for-virtual-memory-allocati.patch} (54%)
 create mode 100644 patches/ntdll-ForceBottomUpAlloc/0006-ntdll-Permanently-exclude-natively-mapped-areas-from.patch
 create mode 100644 patches/ntdll-Junction_Points/0005-kernel32-ntdll-Add-support-for-deleting-junction-poi.patch
 delete mode 100644 patches/ntdll-Junction_Points/0005-server-Add-support-for-deleting-junction-points-with.patch
 delete mode 100644 patches/ntdll-Junction_Points/0020-kernel32-Add-reparse-support-to-FindNextFile.patch
 delete mode 100644 patches/ntdll-Junction_Points/0021-wcmd-Display-reparse-point-type-in-directory-listing.patch
 delete mode 100644 patches/ntdll-Junction_Points/0022-wcmd-Show-reparse-point-target-in-directory-listing.patch
 delete mode 100644 patches/ntdll-Junction_Points/0023-wcmd-Add-junction-point-support-to-mklink.patch
 delete mode 100644 patches/ntdll-Junction_Points/0024-server-Fix-obtaining-information-about-a-symlink.patch
 rename patches/ntdll-Junction_Points/{0019-kernel32-Implement-CreateSymbolicLink-A-W-with-ntdll.patch => xx19-kernel32-Implement-CreateSymbolicLink-A-W-with-ntdll.patch} (88%)
 create mode 100644 patches/ntdll-NtContinue/0001-ntdll-Add-stub-for-NtContinue.patch
 create mode 100644 patches/ntdll-NtContinue/0002-Use-NtContinue-to-continue-execution-after-exception.patch
 create mode 100644 patches/ntdll-NtContinue/definition
 create mode 100644 patches/ntdll-RtlCreateUserThread/0001-ntdll-Refactor-RtlCreateUserThread-into-NtCreateThre.patch
 create mode 100644 patches/ntdll-RtlCreateUserThread/definition
 create mode 100644 patches/ntdll-SystemInterruptInformation/0001-ntdll-Return-buffer-filled-with-random-values-from-S.patch
 create mode 100644 patches/ntdll-SystemInterruptInformation/definition
 create mode 100644 patches/ntdll-SystemModuleInformation/0001-ntdll-Don-t-call-LdrQueryProcessModuleInformation-in.patch
 create mode 100644 patches/ntdll-SystemModuleInformation/0002-ntdll-Return-ntdll.dll-as-the-first-entry-for-System.patch
 create mode 100644 patches/ntdll-SystemRoot_Symlink/0001-ntdll-Add-special-handling-for-SystemRoot-to-satisfy.patch
 create mode 100644 patches/ntdll-SystemRoot_Symlink/definition
 create mode 100644 patches/ntdll-ThreadTime/0001-ntdll-Return-correct-values-in-GetThreadTimes-for-al.patch
 create mode 100644 patches/ntdll-ThreadTime/0002-ntdll-Set-correct-thread-creation-time-for-SystemPro.patch
 create mode 100644 patches/ntdll-ThreadTime/0003-ntdll-Fill-process-kernel-and-user-time.patch
 create mode 100644 patches/ntdll-ThreadTime/0004-ntdll-Set-process-start-time.patch
 create mode 100644 patches/ntdll-ThreadTime/0005-ntdll-Fill-out-thread-times-in-process-enumeration.patch
 create mode 100644 patches/ntdll-ThreadTime/0006-ntdll-Fill-process-virtual-memory-counters-in-NtQuer.patch
 create mode 100644 patches/ntdll-ThreadTime/definition
 create mode 100644 patches/winebuild-Fake_Dlls/0001-kernel32-tests-Add-basic-tests-for-fake-dlls.patch
 create mode 100644 patches/winebuild-Fake_Dlls/0002-krnl386.exe16-Do-not-abuse-WOW32Reserved-field-for-1.patch
 create mode 100644 patches/winebuild-Fake_Dlls/0003-winebuild-Generate-syscall-thunks-for-ntdll-exports.patch
 create mode 100644 patches/winebuild-Fake_Dlls/0004-winebuild-Use-multipass-label-system-to-generate-fak.patch
 create mode 100644 patches/winebuild-Fake_Dlls/0005-winebuild-Add-stub-functions-in-fake-dlls.patch
 create mode 100644 patches/winebuild-Fake_Dlls/0006-winebuild-Add-syscall-thunks-in-fake-dlls.patch
 create mode 100644 patches/winebuild-Fake_Dlls/0007-winebuild-Fix-size-of-relocation-information-in-fake.patch
 create mode 100644 patches/winebuild-Fake_Dlls/0008-winebuild-Try-to-make-sure-RVA-matches-between-fake-.patch
 create mode 100644 patches/winebuild-Fake_Dlls/0009-libs-wine-Use-same-file-alignment-for-fake-and-built.patch
 create mode 100644 patches/winebuild-Fake_Dlls/0010-tools-winebuild-Add-syscall-thunks-for-64-bit.patch
 create mode 100644 patches/winebuild-Fake_Dlls/0011-ntdll-Call-NtOpenFile-through-syscall-thunk.patch
 rename patches/{winebuild-pe_syscall_thunks => winebuild-Fake_Dlls}/definition (88%)
 delete mode 100644 patches/winebuild-pe_syscall_thunks/0002-winebuild-Call-__wine_syscall_dispatcher-through-the.patch

diff --git a/patches/Staging/0001-kernel32-Add-winediag-message-to-show-warning-that-t.patch b/patches/Staging/0001-kernel32-Add-winediag-message-to-show-warning-that-t.patch
index 0435418c..e28d9c43 100644
--- a/patches/Staging/0001-kernel32-Add-winediag-message-to-show-warning-that-t.patch
+++ b/patches/Staging/0001-kernel32-Add-winediag-message-to-show-warning-that-t.patch
@@ -1,60 +1,49 @@
-From 700513f28e4844cbfc40b3ebf1b77cf121b71e71 Mon Sep 17 00:00:00 2001
+From aa9cb874b1fb89601d6a5a735b442b8a7aa7b3aa Mon Sep 17 00:00:00 2001
 From: Sebastian Lackner <sebastian@fds-team.de>
 Date: Thu, 2 Oct 2014 19:44:31 +0200
-Subject: [PATCH] ntdll: Print a warning message specifying the wine-staging
- branch name and version.
+Subject: [PATCH] kernel32: Add winediag message to show warning, that this
+ isn't vanilla wine.
 
 ---
- dlls/ntdll/loader.c | 15 +++++++++++++++
- 1 file changed, 15 insertions(+)
+ dlls/kernel32/process.c | 11 +++++++++++
+ 1 file changed, 11 insertions(+)
 
-diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
-index 587c87bbfc0..05b40326d82 100644
---- a/dlls/ntdll/loader.c
-+++ b/dlls/ntdll/loader.c
-@@ -44,6 +44,7 @@ WINE_DECLARE_DEBUG_CHANNEL(relay);
- WINE_DECLARE_DEBUG_CHANNEL(snoop);
- WINE_DECLARE_DEBUG_CHANNEL(loaddll);
- WINE_DECLARE_DEBUG_CHANNEL(imports);
+diff --git a/dlls/kernel32/process.c b/dlls/kernel32/process.c
+index 8f506fcf1320..45bfe7fe7b5d 100644
+--- a/dlls/kernel32/process.c
++++ b/dlls/kernel32/process.c
+@@ -60,6 +60,7 @@
+ 
+ WINE_DEFAULT_DEBUG_CHANNEL(process);
+ WINE_DECLARE_DEBUG_CHANNEL(relay);
 +WINE_DECLARE_DEBUG_CHANNEL(winediag);
  
- #ifdef _WIN64
- #define DEFAULT_SECURITY_COOKIE_64  (((ULONGLONG)0x00002b99 << 32) | 0x2ddfa232)
-@@ -3487,6 +3488,7 @@ static void process_breakpoint(void)
-     __ENDTRY
+ typedef struct
+ {
+@@ -125,6 +126,7 @@ static inline DWORD call_process_entry( PEB *peb, LPTHREAD_START_ROUTINE entry )
  }
+ #endif
  
 +extern const char * CDECL wine_get_version(void);
+ /***********************************************************************
+  *           __wine_start_process
+  *
+@@ -150,6 +152,15 @@ void CDECL __wine_start_process( LPTHREAD_START_ROUTINE entry, PEB *peb )
  
- /******************************************************************
-  *		LdrInitializeThunk (NTDLL.@)
-@@ -3497,6 +3499,9 @@ static void process_breakpoint(void)
- void WINAPI LdrInitializeThunk( CONTEXT *context, ULONG_PTR unknown2, ULONG_PTR unknown3, ULONG_PTR unknown4 )
- {
-     static const unsigned int fls_slot_count = 8 * sizeof(NtCurrentTeb()->Peb->FlsBitmapBits);
-+    OBJECT_ATTRIBUTES staging_event_attr;
-+    UNICODE_STRING staging_event_string;
-+    HANDLE staging_event;
-     static int attach_done;
-     int i;
-     NTSTATUS status;
-@@ -3515,6 +3520,16 @@ void WINAPI LdrInitializeThunk( CONTEXT *context, ULONG_PTR unknown2, ULONG_PTR
-     entry = (void **)&context->u.s.X0;
- #endif
- 
-+    RtlInitUnicodeString( &staging_event_string, L"\\__wine_staging_warn_event" );
-+    InitializeObjectAttributes( &staging_event_attr, &staging_event_string, OBJ_OPENIF, NULL, NULL );
-+    if (NtCreateEvent( &staging_event, EVENT_ALL_ACCESS, &staging_event_attr, NotificationEvent, FALSE ) == STATUS_SUCCESS)
-+    {
-+        FIXME_(winediag)("wine-staging %s is a testing version containing experimental patches.\n", wine_get_version());
-+        FIXME_(winediag)("Please mention your exact version when filing bug reports on winehq.org.\n");
-+    }
-+    else
-+        WARN_(winediag)("wine-staging %s is a testing version containing experimental patches.\n", wine_get_version());
+     __TRY
+     {
++        if (CreateEventA(0, 0, 0, "__winestaging_warn_event") && GetLastError() != ERROR_ALREADY_EXISTS)
++        {
++            FIXME_(winediag)("Wine Staging %s is a testing version containing experimental patches.\n", wine_get_version());
++            FIXME_(winediag)("Please mention your exact version when filing bug reports on winehq.org.\n");
++        }
++        else
++            WARN_(winediag)("Wine Staging %s is a testing version containing experimental patches.\n", wine_get_version());
++
 +
-     if (process_detaching) NtTerminateThread( GetCurrentThread(), 0 );
+         if (!CheckRemoteDebuggerPresent( GetCurrentProcess(), &being_debugged ))
+             being_debugged = FALSE;
  
-     RtlEnterCriticalSection( &loader_section );
 -- 
-2.28.0
+2.26.2
 
diff --git a/patches/Staging/0002-winelib-Append-Staging-at-the-end-of-the-version-s.patch b/patches/Staging/0002-winelib-Append-Staging-at-the-end-of-the-version-s.patch
index 9772c69e..2da78ed8 100644
--- a/patches/Staging/0002-winelib-Append-Staging-at-the-end-of-the-version-s.patch
+++ b/patches/Staging/0002-winelib-Append-Staging-at-the-end-of-the-version-s.patch
@@ -1,35 +1,39 @@
-From ce5e1fc75139e4de9d92dfe27b4a513a96da013c Mon Sep 17 00:00:00 2001
+From c097870c69720ece3874ad4ff987408a8c24ffb2 Mon Sep 17 00:00:00 2001
 From: Sebastian Lackner <sebastian@fds-team.de>
 Date: Thu, 2 Oct 2014 19:53:46 +0200
 Subject: [PATCH] winelib: Append '(Staging)' at the end of the version string.
 
 ---
- Makefile.in            | 2 +-
- dlls/ntdll/Makefile.in | 1 +
- 2 files changed, 2 insertions(+), 1 deletion(-)
+ dlls/ntdll/Makefile.in | 2 +-
+ libs/wine/Makefile.in  | 2 +-
+ 2 files changed, 2 insertions(+), 2 deletions(-)
 
-diff --git a/Makefile.in b/Makefile.in
-index 307a95b3b1a..61019fed949 100644
---- a/Makefile.in
-+++ b/Makefile.in
-@@ -116,7 +116,7 @@ install-manpages:: manpages
- # Rules for generated source files
- 
- dlls/ntdll/unix/version.c: dummy
--	@version=`(GIT_DIR=$(srcdir)/.git git describe HEAD 2>/dev/null || echo "wine-$(PACKAGE_VERSION)") | sed -n -e '$$s/\(.*\)/const char wine_build[] = "\1";/p'` && (echo $$version | cmp -s - $@) || echo $$version >$@ || ($(RM) $@ && exit 1)
-+	@version=`(GIT_DIR=$(srcdir)/.git git describe HEAD 2>/dev/null || echo "wine-$(PACKAGE_VERSION)") | sed -n -e '$$s/\(.*\)/const char wine_build[] = "\1 (Staging)";/p'` && (echo $$version | cmp -s - $@) || echo $$version >$@ || (rm -f $@ && exit 1)
- 
- programs/winetest/build.rc: dummy
- 	@build="STRINGTABLE { 1 \"`GIT_DIR=$(srcdir)/.git git rev-parse HEAD 2>/dev/null`\" }" && (echo $$build | cmp -s - $@) || echo $$build >$@ || (rm -f $@ && exit 1)
 diff --git a/dlls/ntdll/Makefile.in b/dlls/ntdll/Makefile.in
-index f39ffb42c6f..67847bb9392 100644
+index ebf607e9d43..de93445d4e3 100644
 --- a/dlls/ntdll/Makefile.in
 +++ b/dlls/ntdll/Makefile.in
-@@ -79,3 +79,4 @@ unix_loader_EXTRADEFS = \
- 	-DBINDIR=\"${bindir}\" \
- 	-DDLL_TO_BINDIR=\"`${MAKEDEP} -R ${dlldir} ${bindir}`\" \
- 	-DBIN_TO_DATADIR=\"`${MAKEDEP} -R ${bindir} ${datadir}/wine`\"
-+
+@@ -69,7 +69,7 @@ server_EXTRADEFS = \
+ 	-DBIN_TO_DATADIR=\"`$(MAKEDEP) -R ${bindir} ${datadir}/wine`\"
+ 
+ unix/version.c: dummy
+-	version=`(GIT_DIR=$(top_srcdir)/.git git describe HEAD 2>/dev/null || echo "wine-$(PACKAGE_VERSION)") | sed -n -e '$$s/\(.*\)/const char wine_build[] = "\1";/p'` && (echo $$version | cmp -s - $@) || echo $$version >$@ || (rm -f $@ && exit 1)
++	version=`(GIT_DIR=$(top_srcdir)/.git git describe HEAD 2>/dev/null || echo "wine-$(PACKAGE_VERSION)") | sed -n -e '$$s/\(.*\)/const char wine_build[] = "\1 (Staging)";/p'` && (echo $$version | cmp -s - $@) || echo $$version >$@ || (rm -f $@ && exit 1)
+ 
+ dummy:
+ .PHONY: dummy
+diff --git a/libs/wine/Makefile.in b/libs/wine/Makefile.in
+index fe2a2b45e58..1e55a6b1f46 100644
+--- a/libs/wine/Makefile.in
++++ b/libs/wine/Makefile.in
+@@ -100,7 +100,7 @@ libwine_LDFLAGS = $(LIBWINE_LDFLAGS)
+ libwine_DEPS = $(LIBWINE_DEPENDS)
+ 
+ version.c: dummy
+-	version=`(GIT_DIR=$(top_srcdir)/.git git describe HEAD 2>/dev/null || echo "wine-$(PACKAGE_VERSION)") | sed -n -e '$$s/\(.*\)/const char wine_build[] = "\1";/p'` && (echo $$version | cmp -s - $@) || echo $$version >$@ || (rm -f $@ && exit 1)
++	version=`(GIT_DIR=$(top_srcdir)/.git git describe HEAD 2>/dev/null || echo "wine-$(PACKAGE_VERSION)") | sed -n -e '$$s/\(.*\)/const char wine_build[] = "\1  (Staging)";/p'` && (echo $$version | cmp -s - $@) || echo $$version >$@ || (rm -f $@ && exit 1)
+ 
+ dummy:
+ .PHONY: dummy
 -- 
-2.28.0
+2.26.2
 
diff --git a/patches/Staging/0003-loader-Add-commandline-option-patches-to-show-the-pa.patch b/patches/Staging/0003-loader-Add-commandline-option-patches-to-show-the-pa.patch
new file mode 100644
index 00000000..c812a976
--- /dev/null
+++ b/patches/Staging/0003-loader-Add-commandline-option-patches-to-show-the-pa.patch
@@ -0,0 +1,117 @@
+From 599c50c9e339fe04e96fdb665b3d7ccb1a7708b7 Mon Sep 17 00:00:00 2001
+From: Sebastian Lackner <sebastian@fds-team.de>
+Date: Thu, 29 May 2014 23:43:45 +0200
+Subject: [PATCH] loader: Add commandline option --patches to show the patch
+ list.
+
+---
+ include/wine/library.h |  1 +
+ libs/wine/config.c     |  6 ++++++
+ libs/wine/wine.map     |  1 +
+ loader/main.c          | 42 +++++++++++++++++++++++++++++++++++++++++-
+ 4 files changed, 49 insertions(+), 1 deletion(-)
+
+diff --git a/include/wine/library.h b/include/wine/library.h
+index 090b8349559..b8a4a2df576 100644
+--- a/include/wine/library.h
++++ b/include/wine/library.h
+@@ -42,6 +42,7 @@ extern "C" {
+ /* configuration */
+ 
+ extern const char *wine_get_version(void);
++extern const void *wine_get_patches(void);
+ extern const char *wine_get_build_id(void);
+ extern void wine_init_argv0_path( const char *argv0 );
+ extern void wine_exec_wine_binary( const char *name, char **argv, const char *env_var );
+diff --git a/libs/wine/config.c b/libs/wine/config.c
+index f5b4c0de9af..e52739d55ad 100644
+--- a/libs/wine/config.c
++++ b/libs/wine/config.c
+@@ -515,6 +515,12 @@ const char *wine_get_version(void)
+     return PACKAGE_VERSION;
+ }
+ 
++/* return the applied non-standard patches */
++const void *wine_get_patches(void)
++{
++    return NULL;
++}
++
+ /* return the build id string */
+ const char *wine_get_build_id(void)
+ {
+diff --git a/libs/wine/wine.map b/libs/wine/wine.map
+index 1143b129734..55f874d3e74 100644
+--- a/libs/wine/wine.map
++++ b/libs/wine/wine.map
+@@ -13,6 +13,7 @@ WINE_1.0
+     wine_exec_wine_binary;
+     wine_get_build_id;
+     wine_get_version;
++    wine_get_patches;
+     wine_init;
+     wine_init_argv0_path;
+     wine_mmap_add_reserved_area;
+diff --git a/loader/main.c b/loader/main.c
+index 0e6b6f66b50..24bcfff8c4c 100644
+--- a/loader/main.c
++++ b/loader/main.c
+@@ -55,7 +55,8 @@ static void check_command_line( int argc, char *argv[] )
+     static const char usage[] =
+         "Usage: wine PROGRAM [ARGUMENTS...]   Run the specified program\n"
+         "       wine --help                   Display this help and exit\n"
+-        "       wine --version                Output version information and exit";
++        "       wine --version                Output version information and exit\n"
++        "       wine --patches                Output patch information and exit";
+ 
+     if (argc <= 1)
+     {
+@@ -72,6 +73,45 @@ static void check_command_line( int argc, char *argv[] )
+         printf( "%s\n", wine_get_build_id() );
+         exit(0);
+     }
++    if (!strcmp( argv[1], "--patches" ))
++    {
++        const struct
++        {
++            const char *author;
++            const char *subject;
++            int revision;
++        }
++        *next, *cur = wine_get_patches();
++
++        if (!cur)
++        {
++            fprintf( stderr, "Patchlist not available.\n" );
++            exit(1);
++        }
++
++        while (cur->author)
++        {
++            next = cur + 1;
++            while (next->author)
++            {
++                if (strcmp( cur->author, next->author )) break;
++                next++;
++            }
++
++            printf( "%s (%d):\n", cur->author, (int)(next - cur) );
++            while (cur < next)
++            {
++                printf( "      %s", cur->subject );
++                if (cur->revision != 1)
++                    printf( " [rev %d]", cur->revision );
++                printf( "\n" );
++                cur++;
++            }
++            printf( "\n" );
++        }
++
++        exit(0);
++    }
+ }
+ 
+ 
+-- 
+2.26.2
+
diff --git a/patches/Staging/definition b/patches/Staging/definition
deleted file mode 100644
index 29bb50f1..00000000
--- a/patches/Staging/definition
+++ /dev/null
@@ -1 +0,0 @@
-Depends: ntdll-FLS_Callbacks
diff --git a/patches/advapi32-CreateRestrictedToken/0001-ntdll-Implement-NtFilterToken.patch b/patches/advapi32-CreateRestrictedToken/0001-ntdll-Implement-NtFilterToken.patch
new file mode 100644
index 00000000..af044c16
--- /dev/null
+++ b/patches/advapi32-CreateRestrictedToken/0001-ntdll-Implement-NtFilterToken.patch
@@ -0,0 +1,315 @@
+From 1eb8acd819f9eee8fdf154d0ef43881008265916 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
+Date: Fri, 4 Aug 2017 02:33:14 +0200
+Subject: ntdll: Implement NtFilterToken.
+
+---
+ dlls/ntdll/nt.c       | 59 ++++++++++++++++++++++++++++++++++++
+ dlls/ntdll/ntdll.spec |  2 +-
+ include/winnt.h       |  5 +++
+ include/winternl.h    |  1 +
+ server/process.c      |  2 +-
+ server/protocol.def   | 10 ++++++
+ server/security.h     |  4 ++-
+ server/token.c        | 84 +++++++++++++++++++++++++++++++++++++++++++++++++--
+ 8 files changed, 162 insertions(+), 5 deletions(-)
+
+diff --git a/dlls/ntdll/nt.c b/dlls/ntdll/nt.c
+index c3f5df3..59a08de 100644
+--- a/dlls/ntdll/nt.c
++++ b/dlls/ntdll/nt.c
+@@ -119,6 +119,65 @@ NTSTATUS WINAPI NtDuplicateToken(
+ }
+ 
+ /******************************************************************************
++ *  NtFilterToken        [NTDLL.@]
++ *  ZwFilterToken        [NTDLL.@]
++ */
++NTSTATUS WINAPI NtFilterToken( HANDLE token, ULONG flags, TOKEN_GROUPS *disable_sids,
++                               TOKEN_PRIVILEGES *privileges, TOKEN_GROUPS *restrict_sids,
++                               HANDLE *new_token )
++{
++    data_size_t privileges_len = 0;
++    data_size_t sids_len = 0;
++    SID *sids = NULL;
++    NTSTATUS status;
++
++    TRACE( "(%p, 0x%08x, %p, %p, %p, %p)\n", token, flags, disable_sids, privileges,
++           restrict_sids, new_token );
++
++    if (flags)
++        FIXME( "flags %x unsupported\n", flags );
++
++    if (restrict_sids)
++        FIXME( "support for restricting sids not yet implemented\n" );
++
++    if (privileges)
++        privileges_len = privileges->PrivilegeCount * sizeof(LUID_AND_ATTRIBUTES);
++
++    if (disable_sids)
++    {
++        DWORD len, i;
++        BYTE *tmp;
++
++        for (i = 0; i < disable_sids->GroupCount; i++)
++            sids_len += RtlLengthSid( disable_sids->Groups[i].Sid );
++
++        sids = RtlAllocateHeap( GetProcessHeap(), 0, sids_len );
++        if (!sids) return STATUS_NO_MEMORY;
++
++        for (i = 0, tmp = (BYTE *)sids; i < disable_sids->GroupCount; i++, tmp += len)
++        {
++            len = RtlLengthSid( disable_sids->Groups[i].Sid );
++            memcpy( tmp, disable_sids->Groups[i].Sid, len );
++        }
++    }
++
++    SERVER_START_REQ( filter_token )
++    {
++        req->handle          = wine_server_obj_handle( token );
++        req->flags           = flags;
++        req->privileges_size = privileges_len;
++        wine_server_add_data( req, privileges->Privileges, privileges_len );
++        wine_server_add_data( req, sids, sids_len );
++        status = wine_server_call( req );
++        if (!status) *new_token = wine_server_ptr_handle( reply->new_handle );
++    }
++    SERVER_END_REQ;
++
++    RtlFreeHeap( GetProcessHeap(), 0, sids );
++    return status;
++}
++
++/******************************************************************************
+  *  NtOpenProcessToken		[NTDLL.@]
+  *  ZwOpenProcessToken		[NTDLL.@]
+  */
+diff --git a/dlls/ntdll/ntdll.spec b/dlls/ntdll/ntdll.spec
+index c260b0d..3c5e69c 100644
+--- a/dlls/ntdll/ntdll.spec
++++ b/dlls/ntdll/ntdll.spec
+@@ -176,7 +176,7 @@
+ # @ stub NtEnumerateSystemEnvironmentValuesEx
+ @ stdcall NtEnumerateValueKey(long long long ptr long ptr)
+ @ stub NtExtendSection
+-# @ stub NtFilterToken
++@ stdcall NtFilterToken(long long ptr ptr ptr ptr)
+ @ stdcall NtFindAtom(ptr long ptr)
+ @ stdcall NtFlushBuffersFile(long ptr)
+ @ stdcall NtFlushInstructionCache(long ptr long)
+diff --git a/include/winnt.h b/include/winnt.h
+index 16d96d8..4e238f9 100644
+--- a/include/winnt.h
++++ b/include/winnt.h
+@@ -3904,6 +3904,11 @@ typedef enum _TOKEN_INFORMATION_CLASS {
+ 					TOKEN_ADJUST_SESSIONID | \
+ 					TOKEN_ADJUST_DEFAULT )
+ 
++#define DISABLE_MAX_PRIVILEGE 0x1
++#define SANDBOX_INERT         0x2
++#define LUA_TOKEN             0x4
++#define WRITE_RESTRICTED      0x8
++
+ #ifndef _SECURITY_DEFINED
+ #define _SECURITY_DEFINED
+ 
+diff --git a/include/winternl.h b/include/winternl.h
+index c84e6d7..288f93e 100644
+--- a/include/winternl.h
++++ b/include/winternl.h
+@@ -2303,6 +2303,7 @@ NTSYSAPI NTSTATUS  WINAPI NtDuplicateToken(HANDLE,ACCESS_MASK,POBJECT_ATTRIBUTES
+ NTSYSAPI NTSTATUS  WINAPI NtEnumerateKey(HANDLE,ULONG,KEY_INFORMATION_CLASS,void *,DWORD,DWORD *);
+ NTSYSAPI NTSTATUS  WINAPI NtEnumerateValueKey(HANDLE,ULONG,KEY_VALUE_INFORMATION_CLASS,PVOID,ULONG,PULONG);
+ NTSYSAPI NTSTATUS  WINAPI NtExtendSection(HANDLE,PLARGE_INTEGER);
++NTSYSAPI NTSTATUS  WINAPI NtFilterToken(HANDLE,ULONG,TOKEN_GROUPS*,TOKEN_PRIVILEGES*,TOKEN_GROUPS*,HANDLE*);
+ NTSYSAPI NTSTATUS  WINAPI NtFindAtom(const WCHAR*,ULONG,RTL_ATOM*);
+ NTSYSAPI NTSTATUS  WINAPI NtFlushBuffersFile(HANDLE,IO_STATUS_BLOCK*);
+ NTSYSAPI NTSTATUS  WINAPI NtFlushInstructionCache(HANDLE,LPCVOID,SIZE_T);
+diff --git a/server/process.c b/server/process.c
+index f8739d0..71d9d6d 100644
+--- a/server/process.c
++++ b/server/process.c
+@@ -566,7 +566,7 @@ struct thread *create_process( int fd, struct thread *parent_thread, int inherit
+                                        : alloc_handle_table( process, 0 );
+         /* Note: for security reasons, starting a new process does not attempt
+          * to use the current impersonation token for the new process */
+-        process->token = token_duplicate( parent->token, TRUE, 0, NULL );
++        process->token = token_duplicate( parent->token, TRUE, 0, NULL, NULL, 0, NULL, 0 );
+         process->affinity = parent->affinity;
+     }
+     if (!process->handles || !process->token) goto error;
+diff --git a/server/protocol.def b/server/protocol.def
+index 35824ae..6ee6d28 100644
+--- a/server/protocol.def
++++ b/server/protocol.def
+@@ -3356,6 +3356,16 @@ enum caret_state
+     obj_handle_t  new_handle; /* duplicated handle */
+ @END
+ 
++@REQ(filter_token)
++    obj_handle_t  handle;          /* handle to the token to duplicate */
++    unsigned int  flags;           /* flags */
++    data_size_t   privileges_size; /* size of privileges */
++    VARARG(privileges,LUID_AND_ATTRIBUTES,privileges_size); /* privileges to remove from new token */
++    VARARG(disable_sids,SID);      /* array of groups to remove from new token */
++@REPLY
++    obj_handle_t  new_handle;      /* filtered handle */
++@END
++
+ @REQ(access_check)
+     obj_handle_t    handle; /* handle to the token */
+     unsigned int    desired_access; /* desired access to the object */
+diff --git a/server/security.h b/server/security.h
+index 873bbc6..bc4a8f6 100644
+--- a/server/security.h
++++ b/server/security.h
+@@ -55,7 +55,9 @@ extern const PSID security_high_label_sid;
+ extern struct token *token_create_admin(void);
+ extern int token_assign_label( struct token *token, PSID label );
+ extern struct token *token_duplicate( struct token *src_token, unsigned primary,
+-                                      int impersonation_level, const struct security_descriptor *sd );
++                                      int impersonation_level, const struct security_descriptor *sd,
++                                      const LUID_AND_ATTRIBUTES *filter_privileges, unsigned int priv_count,
++                                      const SID *filter_groups, unsigned int group_count );
+ extern int token_check_privileges( struct token *token, int all_required,
+                                    const LUID_AND_ATTRIBUTES *reqprivs,
+                                    unsigned int count, LUID_AND_ATTRIBUTES *usedprivs);
+diff --git a/server/token.c b/server/token.c
+index 0810a61..2f6a467 100644
+--- a/server/token.c
++++ b/server/token.c
+@@ -276,6 +276,19 @@ static int acl_is_valid( const ACL *acl, data_size_t size )
+     return TRUE;
+ }
+ 
++static unsigned int get_sid_count( const SID *sid, data_size_t size )
++{
++    unsigned int count;
++
++    for (count = 0; size >= sizeof(SID) && security_sid_len( sid ) <= size; count++)
++    {
++        size -= security_sid_len( sid );
++        sid = (const SID *)((char *)sid + security_sid_len( sid ));
++    }
++
++    return count;
++}
++
+ /* checks whether all members of a security descriptor fit inside the size
+  * of memory specified */
+ int sd_is_valid( const struct security_descriptor *sd, data_size_t size )
+@@ -619,8 +632,36 @@ static struct token *create_token( unsigned primary, const SID *user,
+     return token;
+ }
+ 
++static int filter_group( struct group *group, const SID *filter, unsigned int count )
++{
++    unsigned int i;
++
++    for (i = 0; i < count; i++)
++    {
++        if (security_equal_sid( &group->sid, filter )) return 1;
++        filter = (const SID *)((char *)filter + security_sid_len( filter ));
++    }
++
++    return 0;
++}
++
++static int filter_privilege( struct privilege *privilege, const LUID_AND_ATTRIBUTES *filter, unsigned int count )
++{
++    unsigned int i;
++
++    for (i = 0; i < count; i++)
++    {
++        if (!memcmp( &privilege->luid, &filter[i].Luid, sizeof(LUID) ))
++            return 1;
++    }
++
++    return 0;
++}
++
+ struct token *token_duplicate( struct token *src_token, unsigned primary,
+-                               int impersonation_level, const struct security_descriptor *sd )
++                               int impersonation_level, const struct security_descriptor *sd,
++                               const LUID_AND_ATTRIBUTES *filter_privileges, unsigned int priv_count,
++                               const SID *filter_groups, unsigned int group_count)
+ {
+     const luid_t *modified_id =
+         primary || (impersonation_level == src_token->impersonation_level) ?
+@@ -656,6 +697,12 @@ struct token *token_duplicate( struct token *src_token, unsigned primary,
+             return NULL;
+         }
+         memcpy( newgroup, group, size );
++        if (filter_group( group, filter_groups, group_count ))
++        {
++            newgroup->enabled = 0;
++            newgroup->def = 0;
++            newgroup->deny_only = 1;
++        }
+         list_add_tail( &token->groups, &newgroup->entry );
+         if (src_token->primary_group == &group->sid)
+         {
+@@ -667,11 +714,14 @@ struct token *token_duplicate( struct token *src_token, unsigned primary,
+ 
+     /* copy privileges */
+     LIST_FOR_EACH_ENTRY( privilege, &src_token->privileges, struct privilege, entry )
++    {
++        if (filter_privilege( privilege, filter_privileges, priv_count )) continue;
+         if (!privilege_add( token, &privilege->luid, privilege->enabled ))
+         {
+             release_object( token );
+             return NULL;
+         }
++    }
+ 
+     if (sd) default_set_sd( &token->obj, sd, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
+                             DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION );
+@@ -1304,7 +1354,7 @@ DECL_HANDLER(duplicate_token)
+                                                      TOKEN_DUPLICATE,
+                                                      &token_ops )))
+     {
+-        struct token *token = token_duplicate( src_token, req->primary, req->impersonation_level, sd );
++        struct token *token = token_duplicate( src_token, req->primary, req->impersonation_level, sd, NULL, 0, NULL, 0 );
+         if (token)
+         {
+             reply->new_handle = alloc_handle_no_access_check( current->process, token, req->access, objattr->attributes );
+@@ -1314,6 +1364,36 @@ DECL_HANDLER(duplicate_token)
+     }
+ }
+ 
++/* creates a restricted version of a token */
++DECL_HANDLER(filter_token)
++{
++    struct token *src_token;
++
++    if ((src_token = (struct token *)get_handle_obj( current->process, req->handle,
++                                                     TOKEN_DUPLICATE,
++                                                     &token_ops )))
++    {
++        const LUID_AND_ATTRIBUTES *filter_privileges = get_req_data();
++        unsigned int priv_count, group_count;
++        const SID *filter_groups;
++        struct token *token;
++
++        priv_count = min( req->privileges_size, get_req_data_size() ) / sizeof(LUID_AND_ATTRIBUTES);
++        filter_groups = (const SID *)((char *)filter_privileges + priv_count * sizeof(LUID_AND_ATTRIBUTES));
++        group_count = get_sid_count( filter_groups, get_req_data_size() - priv_count * sizeof(LUID_AND_ATTRIBUTES) );
++
++        token = token_duplicate( src_token, src_token->primary, src_token->impersonation_level, NULL,
++                                 filter_privileges, priv_count, filter_groups, group_count );
++        if (token)
++        {
++            unsigned int access = get_handle_access( current->process, req->handle );
++            reply->new_handle = alloc_handle_no_access_check( current->process, token, access, 0 );
++            release_object( token );
++        }
++        release_object( src_token );
++    }
++}
++
+ /* checks the specified privileges are held by the token */
+ DECL_HANDLER(check_token_privileges)
+ {
+-- 
+2.7.4
+
diff --git a/patches/advapi32-CreateRestrictedToken/0002-advapi32-Implement-CreateRestrictedToken.patch b/patches/advapi32-CreateRestrictedToken/0002-advapi32-Implement-CreateRestrictedToken.patch
new file mode 100644
index 00000000..0470b487
--- /dev/null
+++ b/patches/advapi32-CreateRestrictedToken/0002-advapi32-Implement-CreateRestrictedToken.patch
@@ -0,0 +1,132 @@
+From 3c1f5962482e7acf531f57f49d923d9c4e5278b1 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
+Date: Fri, 4 Aug 2017 02:51:57 +0200
+Subject: [PATCH] advapi32: Implement CreateRestrictedToken.
+
+---
+ dlls/kernelbase/security.c | 103 ++++++++++++++++++++++++++++++-------
+ 1 file changed, 84 insertions(+), 19 deletions(-)
+
+diff --git a/dlls/kernelbase/security.c b/dlls/kernelbase/security.c
+index 2e75e81ed77..97f6ee6a2fd 100644
+--- a/dlls/kernelbase/security.c
++++ b/dlls/kernelbase/security.c
+@@ -592,31 +592,96 @@ exit:
+     return ret;
+ }
+ 
++static BOOL allocate_groups(TOKEN_GROUPS **groups_ret, SID_AND_ATTRIBUTES *sids, DWORD count)
++{
++    TOKEN_GROUPS *groups;
++    DWORD i;
++
++    if (!count)
++    {
++        *groups_ret = NULL;
++        return TRUE;
++    }
++
++    groups = (TOKEN_GROUPS *)heap_alloc(FIELD_OFFSET(TOKEN_GROUPS, Groups) +
++                                        count * sizeof(SID_AND_ATTRIBUTES));
++    if (!groups)
++    {
++        SetLastError(ERROR_OUTOFMEMORY);
++        return FALSE;
++    }
++
++    groups->GroupCount = count;
++    for (i = 0; i < count; i++)
++        groups->Groups[i] = sids[i];
++
++    *groups_ret = groups;
++    return TRUE;
++}
++
++static BOOL allocate_privileges(TOKEN_PRIVILEGES **privileges_ret, LUID_AND_ATTRIBUTES *privs, DWORD count)
++{
++    TOKEN_PRIVILEGES *privileges;
++    DWORD i;
++
++    if (!count)
++    {
++        *privileges_ret = NULL;
++        return TRUE;
++    }
++
++    privileges = (TOKEN_PRIVILEGES *)heap_alloc(FIELD_OFFSET(TOKEN_PRIVILEGES, Privileges) +
++                                                count * sizeof(LUID_AND_ATTRIBUTES));
++    if (!privileges)
++    {
++        SetLastError(ERROR_OUTOFMEMORY);
++        return FALSE;
++    }
++
++    privileges->PrivilegeCount = count;
++    for (i = 0; i < count; i++)
++        privileges->Privileges[i] = privs[i];
++
++    *privileges_ret = privileges;
++    return TRUE;
++}
++
+ /*************************************************************************
+  * CreateRestrictedToken    (kernelbase.@)
+  */
+-BOOL WINAPI CreateRestrictedToken( HANDLE token, DWORD flags,
+-                                   DWORD disable_count, PSID_AND_ATTRIBUTES disable_sids,
+-                                   DWORD delete_count, PLUID_AND_ATTRIBUTES delete_privs,
+-                                   DWORD restrict_count, PSID_AND_ATTRIBUTES restrict_sids, PHANDLE ret )
++BOOL WINAPI CreateRestrictedToken( HANDLE baseToken, DWORD flags,
++                                   DWORD nDisableSids, PSID_AND_ATTRIBUTES disableSids,
++                                   DWORD nDeletePrivs, PLUID_AND_ATTRIBUTES deletePrivs,
++                                   DWORD nRestrictSids, PSID_AND_ATTRIBUTES restrictSids, PHANDLE newToken )
+ {
+-    TOKEN_TYPE type;
+-    SECURITY_IMPERSONATION_LEVEL level = SecurityAnonymous;
+-    DWORD size;
++    TOKEN_PRIVILEGES *delete_privs = NULL;
++    TOKEN_GROUPS *disable_groups = NULL;
++    TOKEN_GROUPS *restrict_sids = NULL;
++    BOOL ret = FALSE;
+ 
+-    FIXME("(%p, 0x%x, %u, %p, %u, %p, %u, %p, %p): stub\n",
+-          token, flags, disable_count, disable_sids, delete_count, delete_privs,
+-          restrict_count, restrict_sids, ret );
++    TRACE("(%p, 0x%x, %u, %p, %u, %p, %u, %p, %p)\n",
++          baseToken, flags, nDisableSids, disableSids,
++          nDeletePrivs, deletePrivs,
++          nRestrictSids, restrictSids,
++          newToken);
++
++    if (!allocate_groups(&disable_groups, disableSids, nDisableSids))
++        goto done;
++
++    if (!allocate_privileges(&delete_privs, deletePrivs, nDeletePrivs))
++        goto done;
++
++    if (!allocate_groups(&restrict_sids, restrictSids, nRestrictSids))
++        goto done;
++
++    ret = set_ntstatus(NtFilterToken(baseToken, flags, disable_groups, delete_privs, restrict_sids, newToken));
++
++done:
++    heap_free(disable_groups);
++    heap_free(delete_privs);
++    heap_free(restrict_sids);
++    return ret;
+ 
+-    size = sizeof(type);
+-    if (!GetTokenInformation( token, TokenType, &type, size, &size )) return FALSE;
+-    if (type == TokenImpersonation)
+-    {
+-        size = sizeof(level);
+-        if (!GetTokenInformation( token, TokenImpersonationLevel, &level, size, &size ))
+-            return FALSE;
+-    }
+-    return DuplicateTokenEx( token, MAXIMUM_ALLOWED, NULL, level, type, ret );
+ }
+ 
+ /******************************************************************************
+-- 
+2.20.1
+
diff --git a/patches/advapi32-CreateRestrictedToken/definition b/patches/advapi32-CreateRestrictedToken/definition
new file mode 100644
index 00000000..307ab788
--- /dev/null
+++ b/patches/advapi32-CreateRestrictedToken/definition
@@ -0,0 +1 @@
+Fixes: [25834] Implement advapi32.CreateRestrictedToken
diff --git a/patches/advapi32-Token_Integrity_Level/0002-server-Implement-token-elevation-information.patch b/patches/advapi32-Token_Integrity_Level/0002-server-Implement-token-elevation-information.patch
index c06b36f2..146bf79e 100644
--- a/patches/advapi32-Token_Integrity_Level/0002-server-Implement-token-elevation-information.patch
+++ b/patches/advapi32-Token_Integrity_Level/0002-server-Implement-token-elevation-information.patch
@@ -1,39 +1,38 @@
-From d2e98b2054a5af671fd81ded32f2cf60a062312c Mon Sep 17 00:00:00 2001
+From c8dc0ec6406e8449b59c219ede2e9bd88d8a56fa Mon Sep 17 00:00:00 2001
 From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
 Date: Sat, 5 Aug 2017 00:26:03 +0200
 Subject: [PATCH] server: Implement token elevation information.
 
 ---
- dlls/ntdll/unix/security.c | 16 ++++++++++++----
- server/protocol.def        |  8 ++++++++
- server/token.c             | 22 +++++++++++++++++++---
+ dlls/ntdll/nt.c     | 16 ++++++++++++----
+ server/protocol.def |  8 ++++++++
+ server/token.c      | 22 +++++++++++++++++++---
  3 files changed, 39 insertions(+), 7 deletions(-)
 
-diff --git a/dlls/ntdll/unix/security.c b/dlls/ntdll/unix/security.c
-index d063d43d6d4..03a81afa46e 100644
---- a/dlls/ntdll/unix/security.c
-+++ b/dlls/ntdll/unix/security.c
-@@ -390,19 +390,27 @@ NTSTATUS WINAPI NtQueryInformationToken( HANDLE token, TOKEN_INFORMATION_CLASS c
+diff --git a/dlls/ntdll/nt.c b/dlls/ntdll/nt.c
+index cd271fde9c..b1dd999cf5 100644
+--- a/dlls/ntdll/nt.c
++++ b/dlls/ntdll/nt.c
+@@ -625,18 +625,26 @@ NTSTATUS WINAPI NtQueryInformationToken(
+         SERVER_END_REQ;
          break;
- 
      case TokenElevationType:
 +        SERVER_START_REQ( get_token_elevation_type )
          {
-             TOKEN_ELEVATION_TYPE *type = info;
+             TOKEN_ELEVATION_TYPE *elevation_type = tokeninfo;
 -            FIXME("QueryInformationToken( ..., TokenElevationType, ...) semi-stub\n");
--            *type = TokenElevationTypeFull;
+-            *elevation_type = TokenElevationTypeFull;
 +            req->handle = wine_server_obj_handle( token );
 +            status = wine_server_call( req );
 +            if (status == STATUS_SUCCESS)
-+                *type = reply->elevation;
++                *elevation_type = reply->elevation;
          }
 +        SERVER_END_REQ;
          break;
- 
      case TokenElevation:
 +        SERVER_START_REQ( get_token_elevation_type )
          {
-             TOKEN_ELEVATION *elevation = info;
+             TOKEN_ELEVATION *elevation = tokeninfo;
 -            FIXME("QueryInformationToken( ..., TokenElevation, ...) semi-stub\n");
 -            elevation->TokenIsElevated = TRUE;
 +            req->handle = wine_server_obj_handle( token );
@@ -43,13 +42,13 @@ index d063d43d6d4..03a81afa46e 100644
          }
 +        SERVER_END_REQ;
          break;
- 
      case TokenSessionId:
+         {
 diff --git a/server/protocol.def b/server/protocol.def
-index ee07b1eca14..84f0b577d72 100644
+index 90af9df7f4..93afaabca1 100644
 --- a/server/protocol.def
 +++ b/server/protocol.def
-@@ -3566,6 +3566,14 @@ struct handle_info
+@@ -3643,6 +3643,14 @@ struct handle_info
  @END
  
  
@@ -65,10 +64,10 @@ index ee07b1eca14..84f0b577d72 100644
  @REQ(create_completion)
      unsigned int access;          /* desired access to a port */
 diff --git a/server/token.c b/server/token.c
-index 38a4c203d54..14343637af5 100644
+index 6d193603b4..64f20e1b57 100644
 --- a/server/token.c
 +++ b/server/token.c
-@@ -110,6 +110,7 @@ struct token
+@@ -112,6 +112,7 @@ struct token
      ACL           *default_dacl;    /* the default DACL to assign to objects created by this user */
      TOKEN_SOURCE   source;          /* source of the token */
      int            impersonation_level; /* impersonation level this token is capable of if non-primary token */
@@ -76,7 +75,7 @@ index 38a4c203d54..14343637af5 100644
  };
  
  struct privilege
-@@ -552,7 +553,7 @@ static struct token *create_token( unsigned primary, const SID *user,
+@@ -545,7 +546,7 @@ static struct token *create_token( unsigned primary, const SID *user,
                                     const LUID_AND_ATTRIBUTES *privs, unsigned int priv_count,
                                     const ACL *default_dacl, TOKEN_SOURCE source,
                                     const luid_t *modified_id,
@@ -85,7 +84,7 @@ index 38a4c203d54..14343637af5 100644
  {
      struct token *token = alloc_object( &token_ops );
      if (token)
-@@ -574,6 +575,7 @@ static struct token *create_token( unsigned primary, const SID *user,
+@@ -567,6 +568,7 @@ static struct token *create_token( unsigned primary, const SID *user,
              token->impersonation_level = impersonation_level;
          token->default_dacl = NULL;
          token->primary_group = NULL;
@@ -93,7 +92,7 @@ index 38a4c203d54..14343637af5 100644
  
          /* copy user */
          token->user = memdup( user, security_sid_len( user ));
-@@ -689,7 +691,8 @@ struct token *token_duplicate( struct token *src_token, unsigned primary,
+@@ -682,7 +684,8 @@ struct token *token_duplicate( struct token *src_token, unsigned primary,
      token = create_token( primary, src_token->user, NULL, 0,
                            NULL, 0, src_token->default_dacl,
                            src_token->source, modified_id,
@@ -103,7 +102,7 @@ index 38a4c203d54..14343637af5 100644
      if (!token) return token;
  
      /* copy groups */
-@@ -895,7 +898,7 @@ struct token *token_create_admin( void )
+@@ -888,7 +891,7 @@ struct token *token_create_admin( void )
          static const TOKEN_SOURCE admin_source = {"SeMgr", {0, 0}};
          token = create_token( TRUE, user_sid, admin_groups, ARRAY_SIZE( admin_groups ),
                                admin_privs, ARRAY_SIZE( admin_privs ), default_dacl,
@@ -112,7 +111,7 @@ index 38a4c203d54..14343637af5 100644
          /* we really need a primary group */
          assert( token->primary_group );
      }
-@@ -1634,6 +1637,19 @@ DECL_HANDLER(get_token_statistics)
+@@ -1627,6 +1630,19 @@ DECL_HANDLER(get_token_statistics)
      }
  }
  
@@ -133,5 +132,5 @@ index 38a4c203d54..14343637af5 100644
  {
      struct token *token;
 -- 
-2.27.0
+2.19.1
 
diff --git a/patches/advapi32-Token_Integrity_Level/0004-server-Implement-token-integrity-level.patch b/patches/advapi32-Token_Integrity_Level/0004-server-Implement-token-integrity-level.patch
index 858cc344..73a759cf 100644
--- a/patches/advapi32-Token_Integrity_Level/0004-server-Implement-token-integrity-level.patch
+++ b/patches/advapi32-Token_Integrity_Level/0004-server-Implement-token-integrity-level.patch
@@ -1,19 +1,19 @@
-From 6dc1b7d9e533379133857629bb9c09e1045a9020 Mon Sep 17 00:00:00 2001
+From ae503e8e7eb8f4fcb9bf3e642458c2a1bba6ccaa Mon Sep 17 00:00:00 2001
 From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
 Date: Mon, 7 Aug 2017 02:28:35 +0200
 Subject: [PATCH] server: Implement token integrity level.
 
 ---
- dlls/ntdll/unix/security.c | 23 ++++++++++++++---------
- server/protocol.def        |  7 +++++++
- server/token.c             | 30 +++++++++++++++++++++++++++---
+ dlls/ntdll/nt.c     | 23 ++++++++++++++---------
+ server/protocol.def |  7 +++++++
+ server/token.c      | 30 +++++++++++++++++++++++++++---
  3 files changed, 48 insertions(+), 12 deletions(-)
 
-diff --git a/dlls/ntdll/unix/security.c b/dlls/ntdll/unix/security.c
-index 03a81afa46e..f0057116dee 100644
---- a/dlls/ntdll/unix/security.c
-+++ b/dlls/ntdll/unix/security.c
-@@ -172,7 +172,7 @@ NTSTATUS WINAPI NtQueryInformationToken( HANDLE token, TOKEN_INFORMATION_CLASS c
+diff --git a/dlls/ntdll/nt.c b/dlls/ntdll/nt.c
+index ca26ab15..8aab0a48 100644
+--- a/dlls/ntdll/nt.c
++++ b/dlls/ntdll/nt.c
+@@ -400,7 +400,7 @@ NTSTATUS WINAPI NtQueryInformationToken(
          0,    /* TokenAccessInformation */
          0,    /* TokenVirtualizationAllowed */
          sizeof(DWORD), /* TokenVirtualizationEnabled */
@@ -22,9 +22,9 @@ index 03a81afa46e..f0057116dee 100644
          0,    /* TokenUIAccess */
          0,    /* TokenMandatoryPolicy */
          0,    /* TokenLogonSid */
-@@ -428,18 +428,23 @@ NTSTATUS WINAPI NtQueryInformationToken( HANDLE token, TOKEN_INFORMATION_CLASS c
+@@ -659,18 +659,23 @@ NTSTATUS WINAPI NtQueryInformationToken(
+         }
          break;
- 
      case TokenIntegrityLevel:
 +        SERVER_START_REQ( get_token_integrity )
          {
@@ -32,14 +32,14 @@ index 03a81afa46e..f0057116dee 100644
 -            static const SID high_level = {SID_REVISION, 1, {SECURITY_MANDATORY_LABEL_AUTHORITY},
 -                                                            {SECURITY_MANDATORY_HIGH_RID}};
 -
-             TOKEN_MANDATORY_LABEL *tml = info;
+             TOKEN_MANDATORY_LABEL *tml = tokeninfo;
 -            PSID psid = tml + 1;
 +            PSID sid = tml + 1;
-+            DWORD sid_len = length < sizeof(*tml) ? 0 : length - sizeof(*tml);
++            DWORD sid_len = tokeninfolength < sizeof(*tml) ? 0 : tokeninfolength - sizeof(*tml);
  
 -            tml->Label.Sid = psid;
 -            tml->Label.Attributes = SE_GROUP_INTEGRITY | SE_GROUP_INTEGRITY_ENABLED;
--            memcpy( psid, &high_level, sizeof(SID) );
+-            memcpy(psid, &high_level, sizeof(SID));
 +            req->handle = wine_server_obj_handle( token );
 +            wine_server_set_reply( req, sid, sid_len );
 +            status = wine_server_call( req );
@@ -52,13 +52,13 @@ index 03a81afa46e..f0057116dee 100644
          }
 +        SERVER_END_REQ;
          break;
- 
      case TokenAppContainerSid:
+         {
 diff --git a/server/protocol.def b/server/protocol.def
-index 84f0b577d72..4d37a0df348 100644
+index 11221d7d..1bfe3234 100644
 --- a/server/protocol.def
 +++ b/server/protocol.def
-@@ -3296,6 +3296,13 @@ enum caret_state
+@@ -3405,6 +3405,13 @@ enum caret_state
      VARARG(sid,SID);              /* the sid specified by which_sid from the token */
  @END
  
@@ -73,10 +73,10 @@ index 84f0b577d72..4d37a0df348 100644
      obj_handle_t    handle;       /* handle to the token */
  @REPLY
 diff --git a/server/token.c b/server/token.c
-index 7c510fbdad9..d267991f751 100644
+index ccde0c2d..2d81118a 100644
 --- a/server/token.c
 +++ b/server/token.c
-@@ -111,6 +111,7 @@ struct token
+@@ -113,6 +113,7 @@ struct token
      TOKEN_SOURCE   source;          /* source of the token */
      int            impersonation_level; /* impersonation level this token is capable of if non-primary token */
      TOKEN_ELEVATION_TYPE elevation; /* elevation level */
@@ -84,7 +84,7 @@ index 7c510fbdad9..d267991f751 100644
  };
  
  struct privilege
-@@ -553,7 +554,8 @@ static struct token *create_token( unsigned primary, const SID *user,
+@@ -546,7 +547,8 @@ static struct token *create_token( unsigned primary, const SID *user,
                                     const LUID_AND_ATTRIBUTES *privs, unsigned int priv_count,
                                     const ACL *default_dacl, TOKEN_SOURCE source,
                                     const luid_t *modified_id,
@@ -94,7 +94,7 @@ index 7c510fbdad9..d267991f751 100644
  {
      struct token *token = alloc_object( &token_ops );
      if (token)
-@@ -637,6 +639,7 @@ static struct token *create_token( unsigned primary, const SID *user,
+@@ -630,6 +632,7 @@ static struct token *create_token( unsigned primary, const SID *user,
          }
  
          token->source = source;
@@ -102,7 +102,7 @@ index 7c510fbdad9..d267991f751 100644
      }
      return token;
  }
-@@ -692,7 +695,8 @@ struct token *token_duplicate( struct token *src_token, unsigned primary,
+@@ -685,7 +688,8 @@ struct token *token_duplicate( struct token *src_token, unsigned primary,
                            NULL, 0, src_token->default_dacl,
                            src_token->source, modified_id,
                            impersonation_level,
@@ -112,7 +112,7 @@ index 7c510fbdad9..d267991f751 100644
      if (!token) return token;
  
      /* copy groups */
-@@ -898,7 +902,7 @@ struct token *token_create_admin( void )
+@@ -890,7 +894,7 @@ struct token *token_create_admin( void )
          static const TOKEN_SOURCE admin_source = {"SeMgr", {0, 0}};
          token = create_token( TRUE, user_sid, admin_groups, ARRAY_SIZE( admin_groups ),
                                admin_privs, ARRAY_SIZE( admin_privs ), default_dacl,
@@ -121,7 +121,7 @@ index 7c510fbdad9..d267991f751 100644
          /* we really need a primary group */
          assert( token->primary_group );
      }
-@@ -1532,6 +1536,26 @@ DECL_HANDLER(get_token_sid)
+@@ -1524,6 +1528,26 @@ DECL_HANDLER(get_token_sid)
      }
  }
  
@@ -149,5 +149,5 @@ index 7c510fbdad9..d267991f751 100644
  DECL_HANDLER(get_token_groups)
  {
 -- 
-2.27.0
+2.19.1
 
diff --git a/patches/advapi32-Token_Integrity_Level/0006-ntdll-Add-function-to-create-new-tokens-for-elevatio.patch b/patches/advapi32-Token_Integrity_Level/0006-ntdll-Add-function-to-create-new-tokens-for-elevatio.patch
index cfd451ab..08d0b495 100644
--- a/patches/advapi32-Token_Integrity_Level/0006-ntdll-Add-function-to-create-new-tokens-for-elevatio.patch
+++ b/patches/advapi32-Token_Integrity_Level/0006-ntdll-Add-function-to-create-new-tokens-for-elevatio.patch
@@ -1,4 +1,4 @@
-From c47977a8bbd739483589d1f01cfece435be1c100 Mon Sep 17 00:00:00 2001
+From 90474eb9f6583f2e8fe0314cfa0b0dc04797833b Mon Sep 17 00:00:00 2001
 From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
 Date: Sat, 5 Aug 2017 01:45:29 +0200
 Subject: [PATCH] ntdll: Add function to create new tokens for elevation
@@ -14,10 +14,10 @@ Subject: [PATCH] ntdll: Add function to create new tokens for elevation
  6 files changed, 117 insertions(+)
 
 diff --git a/dlls/ntdll/ntdll.spec b/dlls/ntdll/ntdll.spec
-index 0997c310110..8e3786e1972 100644
+index 1ebe07fc08c..7a19674b2f3 100644
 --- a/dlls/ntdll/ntdll.spec
 +++ b/dlls/ntdll/ntdll.spec
-@@ -1600,6 +1600,9 @@
+@@ -1586,6 +1586,9 @@
  # Virtual memory
  @ cdecl __wine_locked_recvmsg(long ptr long)
  
@@ -25,27 +25,27 @@ index 0997c310110..8e3786e1972 100644
 +@ cdecl __wine_create_default_token(long)
 +
  # Version
- @ cdecl wine_get_version()
- @ cdecl wine_get_build_id()
+ @ cdecl wine_get_version() NTDLL_wine_get_version
+ @ cdecl wine_get_build_id() NTDLL_wine_get_build_id
 diff --git a/dlls/ntdll/ntdll_misc.h b/dlls/ntdll/ntdll_misc.h
-index 63ceac42e94..5a98501381b 100644
+index 27e7141bc65..4baf8a3967b 100644
 --- a/dlls/ntdll/ntdll_misc.h
 +++ b/dlls/ntdll/ntdll_misc.h
-@@ -67,6 +67,9 @@ extern void init_user_process_params(void) DECLSPEC_HIDDEN;
- extern NTSTATUS restart_process( RTL_USER_PROCESS_PARAMETERS *params, NTSTATUS status ) DECLSPEC_HIDDEN;
- extern void CDECL DECLSPEC_NORETURN signal_start_thread( CONTEXT *ctx ) DECLSPEC_HIDDEN;
+@@ -107,6 +107,9 @@ extern int __wine_main_argc;
+ extern char **__wine_main_argv;
+ extern WCHAR **__wine_main_wargv;
  
 +/* token */
 +extern HANDLE CDECL __wine_create_default_token(BOOL admin);
 +
  /* server support */
- extern BOOL is_wow64 DECLSPEC_HIDDEN;
- 
+ extern const char *build_dir DECLSPEC_HIDDEN;
+ extern const char *data_dir DECLSPEC_HIDDEN;
 diff --git a/dlls/ntdll/process.c b/dlls/ntdll/process.c
-index 77ba5b371e2..3e91a1fa9c4 100644
+index 6c5f722b2a6..df81e061e7b 100644
 --- a/dlls/ntdll/process.c
 +++ b/dlls/ntdll/process.c
-@@ -72,6 +72,24 @@ HANDLE CDECL __wine_make_process_system(void)
+@@ -119,6 +119,24 @@ HANDLE CDECL __wine_make_process_system(void)
      return ret;
  }
  
@@ -67,14 +67,14 @@ index 77ba5b371e2..3e91a1fa9c4 100644
 +    return ret;
 +}
 +
- /***********************************************************************
-  *           restart_process
-  */
+ static UINT process_error_mode;
+ 
+ #define UNIMPLEMENTED_INFO_CLASS(c) \
 diff --git a/server/protocol.def b/server/protocol.def
-index 30a102d7b82..a9308904afc 100644
+index c53ceb50d50..947a3c971f5 100644
 --- a/server/protocol.def
 +++ b/server/protocol.def
-@@ -3481,6 +3481,14 @@ struct handle_info
+@@ -3755,6 +3755,14 @@ struct handle_info
  @END
  
  
@@ -215,5 +215,5 @@ index c4f1cd943c2..970ed1838da 100644
 +    }
 +}
 -- 
-2.28.0
+2.26.2
 
diff --git a/patches/advapi32-Token_Integrity_Level/0008-ntdll-Implement-process-token-elevation-through-mani.patch b/patches/advapi32-Token_Integrity_Level/0008-ntdll-Implement-process-token-elevation-through-mani.patch
index 9d10e143..6f31eb0c 100644
--- a/patches/advapi32-Token_Integrity_Level/0008-ntdll-Implement-process-token-elevation-through-mani.patch
+++ b/patches/advapi32-Token_Integrity_Level/0008-ntdll-Implement-process-token-elevation-through-mani.patch
@@ -1,4 +1,4 @@
-From 51cde3dff5de27d1aebc964a4802758534d56773 Mon Sep 17 00:00:00 2001
+From 0e9d9a6aa1b65dae1c8dc34d6d5fb27aa73f96ea Mon Sep 17 00:00:00 2001
 From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
 Date: Sat, 5 Aug 2017 03:39:55 +0200
 Subject: [PATCH] ntdll: Implement process token elevation through manifests.
@@ -12,10 +12,10 @@ Subject: [PATCH] ntdll: Implement process token elevation through manifests.
  5 files changed, 67 insertions(+)
 
 diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
-index 6290cbcb4e6..9a8f13901b2 100644
+index 38c893e3eb4..d32b57612d5 100644
 --- a/dlls/ntdll/loader.c
 +++ b/dlls/ntdll/loader.c
-@@ -3489,6 +3489,32 @@ void WINAPI LdrInitializeThunk( CONTEXT *context, void **entry, ULONG_PTR unknow
+@@ -4045,6 +4045,32 @@ void WINAPI LdrInitializeThunk( CONTEXT *context, void **entry, ULONG_PTR unknow
  }
  
  
@@ -48,17 +48,17 @@ index 6290cbcb4e6..9a8f13901b2 100644
  /***********************************************************************
   *           load_global_options
   */
-@@ -3900,6 +3926,7 @@ void __wine_process_init(void)
+@@ -4478,6 +4504,7 @@ void __wine_process_init(void)
+                                       's','y','s','t','e','m','3','2','\\',
                                        'k','e','r','n','e','l','3','2','.','d','l','l',0};
-     void (WINAPI *kernel32_start_process)(LPTHREAD_START_ROUTINE,void*) = NULL;
      RTL_USER_PROCESS_PARAMETERS *params;
 +    ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION runlevel;
      WINE_MODREF *wm;
      NTSTATUS status;
      ANSI_STRING func_name;
-@@ -4021,6 +4048,16 @@ void __wine_process_init(void)
-     }
- #endif
+@@ -4575,6 +4602,16 @@ void __wine_process_init(void)
+ 
+     virtual_set_large_address_space();
  
 +    /* elevate process if necessary */
 +    status = RtlQueryInformationActivationContext( 0, NULL, 0, RunlevelInformationInActivationContext,
@@ -74,11 +74,11 @@ index 6290cbcb4e6..9a8f13901b2 100644
      RemoveEntryList( &wm->ldr.InLoadOrderLinks );
      InsertHeadList( &peb->LdrData->InLoadOrderModuleList, &wm->ldr.InLoadOrderLinks );
 diff --git a/server/process.c b/server/process.c
-index fa8495511e0..df72efdecc8 100644
+index 4c7da9223c1..d6f71a774f3 100644
 --- a/server/process.c
 +++ b/server/process.c
-@@ -1086,6 +1086,14 @@ int set_process_debug_flag( struct process *process, int flag )
-     return write_process_memory( process, process->peb + 2, 1, &data );
+@@ -1107,6 +1107,14 @@ struct process_snapshot *process_snap( int *count )
+     return snapshot;
  }
  
 +/* replace the token of a process */
@@ -93,22 +93,22 @@ index fa8495511e0..df72efdecc8 100644
  DECL_HANDLER(new_process)
  {
 diff --git a/server/process.h b/server/process.h
-index 0fdf070b78e..43e8cc1ad7e 100644
+index 5b83e111a6f..dfe5c4e52d8 100644
 --- a/server/process.h
 +++ b/server/process.h
-@@ -129,6 +129,7 @@ extern void kill_console_processes( struct thread *renderer, int exit_code );
- extern void kill_debugged_processes( struct thread *debugger, int exit_code );
+@@ -139,6 +139,7 @@ extern void kill_debugged_processes( struct thread *debugger, int exit_code );
  extern void detach_debugged_processes( struct thread *debugger );
+ extern struct process_snapshot *process_snap( int *count );
  extern void enum_processes( int (*cb)(struct process*, void*), void *user);
 +extern void replace_process_token( struct process *process, struct token *token );
  
  /* console functions */
- extern obj_handle_t inherit_console( struct thread *parent_thread, obj_handle_t handle,
+ extern void inherit_console( struct thread *parent_thread, struct process *parent,
 diff --git a/server/protocol.def b/server/protocol.def
-index a9308904afc..8c40fba8d0a 100644
+index d8618a5c964..89adc93305c 100644
 --- a/server/protocol.def
 +++ b/server/protocol.def
-@@ -3489,6 +3489,13 @@ struct handle_info
+@@ -3762,6 +3762,13 @@ struct handle_info
  @END
  
  
@@ -145,5 +145,5 @@ index 970ed1838da..1c1d49989b3 100644
 +    }
 +}
 -- 
-2.28.0
+2.26.2
 
diff --git a/patches/advapi32-Token_Integrity_Level/0010-server-Implement-support-for-creating-processes-usin.patch b/patches/advapi32-Token_Integrity_Level/0010-server-Implement-support-for-creating-processes-usin.patch
new file mode 100644
index 00000000..3eafa10d
--- /dev/null
+++ b/patches/advapi32-Token_Integrity_Level/0010-server-Implement-support-for-creating-processes-usin.patch
@@ -0,0 +1,319 @@
+From 51830c6683b199e79cb9e782ee51555054a4da7c Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
+Date: Sun, 6 Aug 2017 02:08:05 +0200
+Subject: [PATCH] server: Implement support for creating processes using a
+ token.
+
+---
+ dlls/kernelbase/process.c | 24 +++++++++++++-----------
+ dlls/ntdll/process.c      |  3 ++-
+ server/process.c          | 39 +++++++++++++++++++++++++++++++++++----
+ server/process.h          |  2 +-
+ server/protocol.def       |  1 +
+ server/request.c          |  2 +-
+ server/security.h         |  2 ++
+ server/token.c            | 11 +++++++++++
+ 8 files changed, 66 insertions(+), 18 deletions(-)
+
+diff --git a/dlls/kernelbase/process.c b/dlls/kernelbase/process.c
+index a07dddb1f..99985ab89 100644
+--- a/dlls/kernelbase/process.c
++++ b/dlls/kernelbase/process.c
+@@ -242,7 +242,7 @@ static RTL_USER_PROCESS_PARAMETERS *create_process_params( const WCHAR *filename
+ /***********************************************************************
+  *           create_nt_process
+  */
+-static NTSTATUS create_nt_process( SECURITY_ATTRIBUTES *psa, SECURITY_ATTRIBUTES *tsa,
++static NTSTATUS create_nt_process( HANDLE token, SECURITY_ATTRIBUTES *psa, SECURITY_ATTRIBUTES *tsa,
+                                    BOOL inherit, DWORD flags, RTL_USER_PROCESS_PARAMETERS *params,
+                                    RTL_USER_PROCESS_INFORMATION *info, HANDLE parent )
+ {
+@@ -257,7 +257,7 @@ static NTSTATUS create_nt_process( SECURITY_ATTRIBUTES *psa, SECURITY_ATTRIBUTES
+         status = RtlCreateUserProcess( &nameW, OBJ_CASE_INSENSITIVE, params,
+                                        psa ? psa->lpSecurityDescriptor : NULL,
+                                        tsa ? tsa->lpSecurityDescriptor : NULL,
+-                                       parent, inherit, 0, 0, info );
++                                       parent, inherit, 0, token, info );
+         RtlFreeUnicodeString( &nameW );
+     }
+     return status;
+@@ -267,7 +267,7 @@ static NTSTATUS create_nt_process( SECURITY_ATTRIBUTES *psa, SECURITY_ATTRIBUTES
+ /***********************************************************************
+  *           create_vdm_process
+  */
+-static NTSTATUS create_vdm_process( SECURITY_ATTRIBUTES *psa, SECURITY_ATTRIBUTES *tsa,
++static NTSTATUS create_vdm_process( HANDLE token, SECURITY_ATTRIBUTES *psa, SECURITY_ATTRIBUTES *tsa,
+                                     BOOL inherit, DWORD flags, RTL_USER_PROCESS_PARAMETERS *params,
+                                     RTL_USER_PROCESS_INFORMATION *info )
+ {
+@@ -288,7 +288,7 @@ static NTSTATUS create_vdm_process( SECURITY_ATTRIBUTES *psa, SECURITY_ATTRIBUTE
+               winevdm, params->ImagePathName.Buffer, params->CommandLine.Buffer );
+     RtlInitUnicodeString( &params->ImagePathName, winevdm );
+     RtlInitUnicodeString( &params->CommandLine, newcmdline );
+-    status = create_nt_process( psa, tsa, inherit, flags, params, info, NULL );
++    status = create_nt_process( token, psa, tsa, inherit, flags, params, info, NULL );
+     HeapFree( GetProcessHeap(), 0, newcmdline );
+     return status;
+ }
+@@ -297,7 +297,7 @@ static NTSTATUS create_vdm_process( SECURITY_ATTRIBUTES *psa, SECURITY_ATTRIBUTE
+ /***********************************************************************
+  *           create_cmd_process
+  */
+-static NTSTATUS create_cmd_process( SECURITY_ATTRIBUTES *psa, SECURITY_ATTRIBUTES *tsa,
++static NTSTATUS create_cmd_process( HANDLE token, SECURITY_ATTRIBUTES *psa, SECURITY_ATTRIBUTES *tsa,
+                                     BOOL inherit, DWORD flags, RTL_USER_PROCESS_PARAMETERS *params,
+                                     RTL_USER_PROCESS_INFORMATION *info )
+ {
+@@ -316,7 +316,7 @@ static NTSTATUS create_cmd_process( SECURITY_ATTRIBUTES *psa, SECURITY_ATTRIBUTE
+     swprintf( newcmdline, len, L"%s /s/c \"%s\"", comspec, params->CommandLine.Buffer );
+     RtlInitUnicodeString( &params->ImagePathName, comspec );
+     RtlInitUnicodeString( &params->CommandLine, newcmdline );
+-    status = create_nt_process( psa, tsa, inherit, flags, params, info, NULL );
++    status = create_nt_process( token, psa, tsa, inherit, flags, params, info, NULL );
+     RtlFreeHeap( GetProcessHeap(), 0, newcmdline );
+     return status;
+ }
+@@ -448,7 +448,9 @@ BOOL WINAPI DECLSPEC_HOTPATCH CreateProcessInternalW( HANDLE token, const WCHAR
+ 
+     TRACE( "app %s cmdline %s\n", debugstr_w(app_name), debugstr_w(cmd_line) );
+ 
+-    if (token) FIXME( "Creating a process with a token is not yet implemented\n" );
++    /* FIXME: Starting a process which requires admin rights should fail
++     * with ERROR_ELEVATION_REQUIRED when no token is passed. */
++
+     if (new_token) FIXME( "No support for returning created process token\n" );
+ 
+     if (app_name)
+@@ -521,7 +523,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH CreateProcessInternalW( HANDLE token, const WCHAR
+         }
+     }
+ 
+-    status = create_nt_process( process_attr, thread_attr, inherit, flags, params, &rtl_info, parent );
++    status = create_nt_process( token, process_attr, thread_attr, inherit, flags, params, &rtl_info, parent );
+     switch (status)
+     {
+     case STATUS_SUCCESS:
+@@ -530,7 +532,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH CreateProcessInternalW( HANDLE token, const WCHAR
+     case STATUS_INVALID_IMAGE_NE_FORMAT:
+     case STATUS_INVALID_IMAGE_PROTECT:
+         TRACE( "starting %s as Win16/DOS binary\n", debugstr_w(app_name) );
+-        status = create_vdm_process( process_attr, thread_attr, inherit, flags, params, &rtl_info );
++        status = create_vdm_process( token, process_attr, thread_attr, inherit, flags, params, &rtl_info );
+         break;
+     case STATUS_INVALID_IMAGE_NOT_MZ:
+         /* check for .com or .bat extension */
+@@ -538,12 +540,12 @@ BOOL WINAPI DECLSPEC_HOTPATCH CreateProcessInternalW( HANDLE token, const WCHAR
+         if (!wcsicmp( p, L".com" ) || !wcsicmp( p, L".pif" ))
+         {
+             TRACE( "starting %s as DOS binary\n", debugstr_w(app_name) );
+-            status = create_vdm_process( process_attr, thread_attr, inherit, flags, params, &rtl_info );
++            status = create_vdm_process( token, process_attr, thread_attr, inherit, flags, params, &rtl_info );
+         }
+         else if (!wcsicmp( p, L".bat" ) || !wcsicmp( p, L".cmd" ))
+         {
+             TRACE( "starting %s as batch binary\n", debugstr_w(app_name) );
+-            status = create_cmd_process( process_attr, thread_attr, inherit, flags, params, &rtl_info );
++            status = create_cmd_process( token, process_attr, thread_attr, inherit, flags, params, &rtl_info );
+         }
+         break;
+     }
+diff --git a/dlls/ntdll/process.c b/dlls/ntdll/process.c
+index f3d9079f8..2fa553091 100644
+--- a/dlls/ntdll/process.c
++++ b/dlls/ntdll/process.c
+@@ -1667,7 +1667,7 @@ NTSTATUS WINAPI RtlCreateUserProcess( UNICODE_STRING *path, ULONG attributes,
+                                       RTL_USER_PROCESS_PARAMETERS *params,
+                                       SECURITY_DESCRIPTOR *process_descr,
+                                       SECURITY_DESCRIPTOR *thread_descr,
+-                                      HANDLE parent, BOOLEAN inherit, HANDLE debug, HANDLE exception,
++                                      HANDLE parent, BOOLEAN inherit, HANDLE debug, HANDLE token,
+                                       RTL_USER_PROCESS_INFORMATION *info )
+ {
+     NTSTATUS status;
+@@ -1735,6 +1735,7 @@ NTSTATUS WINAPI RtlCreateUserProcess( UNICODE_STRING *path, ULONG attributes,
+         req->access         = PROCESS_ALL_ACCESS;
+         req->cpu            = pe_info.cpu;
+         req->info_size      = startup_info_size;
++        req->token          = wine_server_obj_handle( token );
+         wine_server_add_data( req, objattr, attr_len );
+         wine_server_add_data( req, startup_info, startup_info_size );
+         wine_server_add_data( req, params->Environment, env_size );
+diff --git a/server/process.c b/server/process.c
+index d6f71a774..aa66814d8 100644
+--- a/server/process.c
++++ b/server/process.c
+@@ -491,7 +491,7 @@ static void start_sigkill_timer( struct process *process )
+ /* create a new process */
+ /* if the function fails the fd is closed */
+ struct process *create_process( int fd, struct process *parent, int inherit_all,
+-                                const struct security_descriptor *sd )
++                                const struct security_descriptor *sd, struct token *token )
+ {
+     struct process *process;
+ 
+@@ -568,7 +568,7 @@ struct process *create_process( int fd, struct process *parent, int inherit_all,
+                                        : alloc_handle_table( process, 0 );
+         /* Note: for security reasons, starting a new process does not attempt
+          * to use the current impersonation token for the new process */
+-        process->token = token_duplicate( parent->token, TRUE, 0, NULL, NULL, 0, NULL, 0 );
++        process->token = token_duplicate( token ? token : parent->token, TRUE, 0, NULL, NULL, 0, NULL, 0 );
+         process->affinity = parent->affinity;
+     }
+     if (!process->handles || !process->token) goto error;
+@@ -1124,6 +1124,7 @@ DECL_HANDLER(new_process)
+     const struct security_descriptor *sd;
+     const struct object_attributes *objattr = get_req_object_attributes( &sd, &name, NULL );
+     struct process *process = NULL;
++    struct token *token = NULL;
+     struct process *parent;
+     struct thread *parent_thread = current;
+     int socket_fd = thread_get_inflight_fd( current, req->socket_fd );
+@@ -1177,10 +1178,39 @@ DECL_HANDLER(new_process)
+         return;
+     }
+ 
++    if (req->token)
++    {
++        token = get_token_from_handle( req->token, TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY );
++        if (!token)
++        {
++            close( socket_fd );
++            return;
++        }
++        if (!token_is_primary( token ))
++        {
++            set_error( STATUS_BAD_TOKEN_TYPE );
++            release_object( token );
++            close( socket_fd );
++            return;
++        }
++    }
++
++    if (!req->info_size)  /* create an orphaned process */
++    {
++        if ((process = create_process( socket_fd, NULL, 0, sd, token )))
++        {
++            create_thread( -1, process, NULL );
++            release_object( process );
++        }
++        if (token) release_object( token );
++        return;
++    }
++
+     /* build the startup info for a new process */
+     if (!(info = alloc_object( &startup_info_ops )))
+     {
+         close( socket_fd );
++        if (token) release_object( token );
+         release_object( parent );
+         return;
+     }
+@@ -1228,7 +1258,7 @@ DECL_HANDLER(new_process)
+ #undef FIXUP_LEN
+     }
+ 
+-    if (!(process = create_process( socket_fd, parent, req->inherit_all, sd ))) goto done;
++    if (!(process = create_process( socket_fd, parent, req->inherit_all, sd, token ))) goto done;
+ 
+     process->startup_info = (struct startup_info *)grab_object( info );
+ 
+@@ -1289,6 +1319,7 @@ DECL_HANDLER(new_process)
+     reply->handle = alloc_handle_no_access_check( current->process, process, req->access, objattr->attributes );
+ 
+  done:
++    if (token) release_object( token );
+     if (process) release_object( process );
+     release_object( parent );
+     release_object( info );
+@@ -1322,7 +1353,7 @@ DECL_HANDLER(exec_process)
+         close( socket_fd );
+         return;
+     }
+-    if (!(process = create_process( socket_fd, NULL, 0, NULL ))) return;
++    if (!(process = create_process( socket_fd, NULL, 0, NULL, NULL ))) return;
+     create_thread( -1, process, NULL );
+     release_object( process );
+ }
+diff --git a/server/process.h b/server/process.h
+index dfe5c4e52..61b83abf6 100644
+--- a/server/process.h
++++ b/server/process.h
+@@ -118,7 +118,7 @@ extern unsigned int alloc_ptid( void *ptr );
+ extern void free_ptid( unsigned int id );
+ extern void *get_ptid_entry( unsigned int id );
+ extern struct process *create_process( int fd, struct process *parent, int inherit_all,
+-                                       const struct security_descriptor *sd );
++                                       const struct security_descriptor *sd, struct token *token );
+ extern data_size_t init_process( struct thread *thread );
+ extern struct thread *get_process_first_thread( struct process *process );
+ extern struct process *get_process_from_id( process_id_t id );
+diff --git a/server/protocol.def b/server/protocol.def
+index 45ab670ea..c763da4ca 100644
+--- a/server/protocol.def
++++ b/server/protocol.def
+@@ -791,6 +791,7 @@ struct rawinput_device
+     unsigned int access;         /* access rights for process object */
+     client_cpu_t cpu;            /* CPU that the new process will use */
+     data_size_t  info_size;      /* size of startup info */
++    obj_handle_t token;          /* token for the new process */
+     VARARG(objattr,object_attributes);   /* object attributes */
+     VARARG(info,startup_info,info_size); /* startup information */
+     VARARG(env,unicode_str);     /* environment for new process */
+diff --git a/server/request.c b/server/request.c
+index 200c2697d..f743b720a 100644
+--- a/server/request.c
++++ b/server/request.c
+@@ -582,7 +582,7 @@ static void master_socket_poll_event( struct fd *fd, int event )
+         int client = accept( get_unix_fd( master_socket->fd ), (struct sockaddr *) &dummy, &len );
+         if (client == -1) return;
+         fcntl( client, F_SETFL, O_NONBLOCK );
+-        if ((process = create_process( client, NULL, 0, NULL )))
++        if ((process = create_process( client, NULL, 0, NULL, NULL )))
+         {
+             create_thread( -1, process, NULL );
+             release_object( process );
+diff --git a/server/security.h b/server/security.h
+index 21e90ccf2..32dfe5f8d 100644
+--- a/server/security.h
++++ b/server/security.h
+@@ -67,6 +67,8 @@ extern const ACL *token_get_default_dacl( struct token *token );
+ extern const SID *token_get_user( struct token *token );
+ extern const SID *token_get_primary_group( struct token *token );
+ extern int token_sid_present( struct token *token, const SID *sid, int deny);
++extern struct token *get_token_from_handle( obj_handle_t handle, unsigned int access );
++extern int token_is_primary( struct token *token );
+ 
+ static inline const ACE_HEADER *ace_next( const ACE_HEADER *ace )
+ {
+diff --git a/server/token.c b/server/token.c
+index 181219d21..858ec25d7 100644
+--- a/server/token.c
++++ b/server/token.c
+@@ -845,6 +845,12 @@ int token_assign_label( struct token *token, PSID label )
+     return ret;
+ }
+ 
++struct token *get_token_from_handle( obj_handle_t handle, unsigned int access )
++{
++    return (struct token *)get_handle_obj( current->process, handle,
++                                           access, &token_ops );
++}
++
+ struct token *token_create_admin( void )
+ {
+     struct token *token = NULL;
+@@ -1271,6 +1277,11 @@ const SID *token_get_primary_group( struct token *token )
+     return token->primary_group;
+ }
+ 
++int token_is_primary( struct token *token )
++{
++    return token->primary;
++}
++
+ int check_object_access(struct object *obj, unsigned int *access)
+ {
+     GENERIC_MAPPING mapping;
+-- 
+2.24.0
+
diff --git a/patches/advapi32-Token_Integrity_Level/XX13-server-Correctly-assign-security-labels-for-tokens.patch b/patches/advapi32-Token_Integrity_Level/0013-server-Correctly-assign-security-labels-for-tokens.patch
similarity index 80%
rename from patches/advapi32-Token_Integrity_Level/XX13-server-Correctly-assign-security-labels-for-tokens.patch
rename to patches/advapi32-Token_Integrity_Level/0013-server-Correctly-assign-security-labels-for-tokens.patch
index 1e1a9214..b880863d 100644
--- a/patches/advapi32-Token_Integrity_Level/XX13-server-Correctly-assign-security-labels-for-tokens.patch
+++ b/patches/advapi32-Token_Integrity_Level/0013-server-Correctly-assign-security-labels-for-tokens.patch
@@ -1,21 +1,20 @@
-From a8915b8ebd4c06b0216fc82d1ba8d958a677eccf Mon Sep 17 00:00:00 2001
+From 6d8fd34cabbcbc64062675be610fb8704fcdc3ec Mon Sep 17 00:00:00 2001
 From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
 Date: Mon, 7 Aug 2017 03:33:26 +0200
 Subject: [PATCH] server: Correctly assign security labels for tokens.
 
 ---
- dlls/advapi32/tests/security.c | 21 +++++++++--------
- server/named_pipe.c            |  2 +-
- server/process.c               |  8 +------
+ dlls/advapi32/tests/security.c | 21 ++++++++++-----------
+ server/process.c               |  8 +-------
  server/security.h              |  2 +-
- server/token.c                 | 41 ++++++++++++++++++++--------------
- 5 files changed, 37 insertions(+), 37 deletions(-)
+ server/token.c                 | 41 ++++++++++++++++++++++++-----------------
+ 4 files changed, 36 insertions(+), 36 deletions(-)
 
 diff --git a/dlls/advapi32/tests/security.c b/dlls/advapi32/tests/security.c
-index 94f3ea4601a..ab572421a73 100644
+index bf4161c..0610ec7 100644
 --- a/dlls/advapi32/tests/security.c
 +++ b/dlls/advapi32/tests/security.c
-@@ -7105,7 +7105,6 @@ static void test_token_security_descriptor(void)
+@@ -7186,7 +7186,6 @@ static void test_token_security_descriptor(void)
      defaulted = TRUE;
      ret = GetSecurityDescriptorDacl(sd2, &present, &acl2, &defaulted);
      ok(ret, "GetSecurityDescriptorDacl failed with error %u\n", GetLastError());
@@ -23,7 +22,7 @@ index 94f3ea4601a..ab572421a73 100644
      ok(present, "DACL not present\n");
  
      if (present)
-@@ -7226,7 +7225,7 @@ static void test_token_security_descriptor(void)
+@@ -7307,7 +7306,7 @@ static void test_token_security_descriptor(void)
                  ok(ret, "GetAce failed with error %u\n", GetLastError());
                  ok(ace->Header.AceType == SYSTEM_MANDATORY_LABEL_ACE_TYPE,
                     "Unexpected ACE type %#x\n", ace->Header.AceType);
@@ -32,7 +31,7 @@ index 94f3ea4601a..ab572421a73 100644
                     "Expected medium integrity level\n");
              }
  
-@@ -7279,8 +7278,8 @@ static void test_token_security_descriptor(void)
+@@ -7360,8 +7359,8 @@ static void test_token_security_descriptor(void)
              sacl = NULL;
              ret = GetSecurityDescriptorSacl(sd3, &present, &sacl, &defaulted);
              ok(ret, "GetSecurityDescriptorSacl failed with error %u\n", GetLastError());
@@ -43,7 +42,7 @@ index 94f3ea4601a..ab572421a73 100644
  
              if (sacl)
              {
-@@ -7329,8 +7328,8 @@ static void test_token_security_descriptor(void)
+@@ -7410,8 +7409,8 @@ static void test_token_security_descriptor(void)
              sacl = NULL;
              ret = GetSecurityDescriptorSacl(sd3, &present, &sacl, &defaulted);
              ok(ret, "GetSecurityDescriptorSacl failed with error %u\n", GetLastError());
@@ -54,7 +53,7 @@ index 94f3ea4601a..ab572421a73 100644
  
              if (sacl)
              {
-@@ -7394,8 +7393,8 @@ static void test_token_security_descriptor(void)
+@@ -7475,8 +7474,8 @@ static void test_token_security_descriptor(void)
  
          ret = GetSecurityDescriptorSacl(sd3, &present, &sacl, &defaulted);
          ok(ret, "GetSecurityDescriptorSacl failed with error %u\n", GetLastError());
@@ -65,7 +64,7 @@ index 94f3ea4601a..ab572421a73 100644
  
          if (sacl)
          {
-@@ -7432,8 +7431,8 @@ static void test_token_security_descriptor(void)
+@@ -7513,8 +7512,8 @@ static void test_token_security_descriptor(void)
          sacl = NULL;
          ret = GetSecurityDescriptorSacl(sd3, &present, &sacl, &defaulted);
          ok(ret, "GetSecurityDescriptorSacl failed with error %u\n", GetLastError());
@@ -76,7 +75,7 @@ index 94f3ea4601a..ab572421a73 100644
  
          if (sacl)
          {
-@@ -7652,7 +7651,7 @@ static void test_child_token_sd_medium(void)
+@@ -7732,7 +7731,7 @@ static void test_child_token_sd_medium(void)
      ok(ret, "GetAce failed with error %u\n", GetLastError());
      ok(ace_label->Header.AceType == SYSTEM_MANDATORY_LABEL_ACE_TYPE,
         "Unexpected ACE type %#x\n", ace_label->Header.AceType);
@@ -85,24 +84,11 @@ index 94f3ea4601a..ab572421a73 100644
         "Expected medium integrity level\n");
  
      memset(buffer_integrity, 0, sizeof(buffer_integrity));
-diff --git a/server/named_pipe.c b/server/named_pipe.c
-index 4cd4d7dc4a8..06bf8402aea 100644
---- a/server/named_pipe.c
-+++ b/server/named_pipe.c
-@@ -1142,7 +1142,7 @@ static int pipe_server_ioctl( struct fd *fd, ioctl_code_t code, struct async *as
-         if (current->process->token) /* FIXME: use the client token */
-         {
-             struct token *token;
--            if (!(token = token_duplicate( current->process->token, 0, SecurityImpersonation, NULL, NULL, 0, NULL, 0 )))
-+            if (!(token = token_duplicate( current->process->token, 0, SecurityImpersonation, NULL, NULL, 0, NULL, 0, NULL )))
-                 return 0;
-             if (current->token) release_object( current->token );
-             current->token = token;
 diff --git a/server/process.c b/server/process.c
-index 31d5b96a25d..2c485831e33 100644
+index b7c9da3..250f777 100644
 --- a/server/process.c
 +++ b/server/process.c
-@@ -577,17 +577,11 @@ struct process *create_process( int fd, struct process *parent, int inherit_all,
+@@ -562,17 +562,11 @@ struct process *create_process( int fd, struct thread *parent_thread, int inheri
                                         : alloc_handle_table( process, 0 );
          /* Note: for security reasons, starting a new process does not attempt
           * to use the current impersonation token for the new process */
@@ -122,7 +108,7 @@ index 31d5b96a25d..2c485831e33 100644
      return process;
  
 diff --git a/server/security.h b/server/security.h
-index 32dfe5f8db9..87377ccd673 100644
+index 32dfe5f..87377cc 100644
 --- a/server/security.h
 +++ b/server/security.h
 @@ -59,7 +59,7 @@ extern int token_assign_label( struct token *token, PSID label );
@@ -135,10 +121,10 @@ index 32dfe5f8db9..87377ccd673 100644
                                     const LUID_AND_ATTRIBUTES *reqprivs,
                                     unsigned int count, LUID_AND_ATTRIBUTES *usedprivs);
 diff --git a/server/token.c b/server/token.c
-index 2f466aa1b25..23bc1cc13f7 100644
+index 5db97b4..bd251c7 100644
 --- a/server/token.c
 +++ b/server/token.c
-@@ -675,7 +675,7 @@ static int filter_privilege( struct privilege *privilege, const LUID_AND_ATTRIBU
+@@ -668,7 +668,7 @@ static int filter_privilege( struct privilege *privilege, const LUID_AND_ATTRIBU
  struct token *token_duplicate( struct token *src_token, unsigned primary,
                                 int impersonation_level, const struct security_descriptor *sd,
                                 const LUID_AND_ATTRIBUTES *filter_privileges, unsigned int priv_count,
@@ -147,7 +133,7 @@ index 2f466aa1b25..23bc1cc13f7 100644
  {
      const luid_t *modified_id =
          primary || (impersonation_level == src_token->impersonation_level) ?
-@@ -742,6 +742,12 @@ struct token *token_duplicate( struct token *src_token, unsigned primary,
+@@ -735,6 +735,12 @@ struct token *token_duplicate( struct token *src_token, unsigned primary,
      if (sd) default_set_sd( &token->obj, sd, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
                              DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION );
  
@@ -160,7 +146,7 @@ index 2f466aa1b25..23bc1cc13f7 100644
      return token;
  }
  
-@@ -913,6 +919,12 @@ struct token *token_create_admin( void )
+@@ -906,6 +912,12 @@ struct token *token_create_admin( void )
                                admin_source, NULL, -1, TokenElevationTypeFull, &high_label_sid );
          /* we really need a primary group */
          assert( token->primary_group );
@@ -173,7 +159,7 @@ index 2f466aa1b25..23bc1cc13f7 100644
      }
  
      free( logon_sid );
-@@ -971,6 +983,12 @@ static struct token *token_create_limited( void )
+@@ -964,6 +976,12 @@ static struct token *token_create_limited( void )
                                admin_source, NULL, -1, TokenElevationTypeLimited, &medium_label_sid );
          /* we really need a primary group */
          assert( token->primary_group );
@@ -186,7 +172,7 @@ index 2f466aa1b25..23bc1cc13f7 100644
      }
  
      free( logon_sid );
-@@ -1439,7 +1457,8 @@ DECL_HANDLER(duplicate_token)
+@@ -1432,7 +1450,8 @@ DECL_HANDLER(duplicate_token)
                                                       TOKEN_DUPLICATE,
                                                       &token_ops )))
      {
@@ -196,7 +182,7 @@ index 2f466aa1b25..23bc1cc13f7 100644
          if (token)
          {
              unsigned int access = req->access ? req->access : get_handle_access( current->process, req->handle );
-@@ -1469,7 +1488,7 @@ DECL_HANDLER(filter_token)
+@@ -1462,7 +1481,7 @@ DECL_HANDLER(filter_token)
          group_count = get_sid_count( filter_groups, get_req_data_size() - priv_count * sizeof(LUID_AND_ATTRIBUTES) );
  
          token = token_duplicate( src_token, src_token->primary, src_token->impersonation_level, NULL,
@@ -205,7 +191,7 @@ index 2f466aa1b25..23bc1cc13f7 100644
          if (token)
          {
              unsigned int access = get_handle_access( current->process, req->handle );
-@@ -1795,23 +1814,11 @@ DECL_HANDLER(set_token_default_dacl)
+@@ -1788,23 +1807,11 @@ DECL_HANDLER(set_token_default_dacl)
  DECL_HANDLER(create_token)
  {
      struct token *token;
@@ -232,5 +218,5 @@ index 2f466aa1b25..23bc1cc13f7 100644
      }
  }
 -- 
-2.27.0
+2.7.4
 
diff --git a/patches/advapi32-Token_Integrity_Level/0015-ntdll-Add-semi-stub-for-TokenLinkedToken-info-class.patch b/patches/advapi32-Token_Integrity_Level/0015-ntdll-Add-semi-stub-for-TokenLinkedToken-info-class.patch
index 57fc1aef..4cc9dd16 100644
--- a/patches/advapi32-Token_Integrity_Level/0015-ntdll-Add-semi-stub-for-TokenLinkedToken-info-class.patch
+++ b/patches/advapi32-Token_Integrity_Level/0015-ntdll-Add-semi-stub-for-TokenLinkedToken-info-class.patch
@@ -1,25 +1,17 @@
-From e34d019222909281390f83149be755a4145024c4 Mon Sep 17 00:00:00 2001
+From 6d4621ddba8139747345c05f6251bae9b3c68e39 Mon Sep 17 00:00:00 2001
 From: Sebastian Lackner <sebastian@fds-team.de>
 Date: Mon, 7 Aug 2017 15:28:33 +0200
-Subject: [PATCH] ntdll: Add semi-stub for TokenLinkedToken info class.
+Subject: ntdll: Add semi-stub for TokenLinkedToken info class.
 
 ---
- dlls/ntdll/unix/security.c | 30 +++++++++++++++++++++++++++++-
- 1 file changed, 29 insertions(+), 1 deletion(-)
+ dlls/ntdll/nt.c | 28 +++++++++++++++++++++++++++-
+ 1 file changed, 27 insertions(+), 1 deletion(-)
 
-diff --git a/dlls/ntdll/unix/security.c b/dlls/ntdll/unix/security.c
-index f0057116dee..2769e5f6a7b 100644
---- a/dlls/ntdll/unix/security.c
-+++ b/dlls/ntdll/unix/security.c
-@@ -138,6 +138,7 @@ NTSTATUS WINAPI NtDuplicateToken( HANDLE token, ACCESS_MASK access, OBJECT_ATTRI
-     return status;
- }
- 
-+extern HANDLE CDECL __wine_create_default_token(BOOL admin);
- 
- /***********************************************************************
-  *             NtQueryInformationToken  (NTDLL.@)
-@@ -166,7 +167,7 @@ NTSTATUS WINAPI NtQueryInformationToken( HANDLE token, TOKEN_INFORMATION_CLASS c
+diff --git a/dlls/ntdll/nt.c b/dlls/ntdll/nt.c
+index 6f2b24e6ba4..99dba58b426 100644
+--- a/dlls/ntdll/nt.c
++++ b/dlls/ntdll/nt.c
+@@ -366,7 +366,7 @@ NTSTATUS WINAPI NtQueryInformationToken(
          0,    /* TokenAuditPolicy */
          0,    /* TokenOrigin */
          sizeof(TOKEN_ELEVATION_TYPE), /* TokenElevationType */
@@ -28,14 +20,14 @@ index f0057116dee..2769e5f6a7b 100644
          sizeof(TOKEN_ELEVATION), /* TokenElevation */
          0,    /* TokenHasRestrictions */
          0,    /* TokenAccessInformation */
-@@ -401,6 +402,33 @@ NTSTATUS WINAPI NtQueryInformationToken( HANDLE token, TOKEN_INFORMATION_CLASS c
+@@ -607,6 +607,32 @@ NTSTATUS WINAPI NtQueryInformationToken(
+         }
          SERVER_END_REQ;
          break;
- 
 +    case TokenLinkedToken:
 +        SERVER_START_REQ( get_token_elevation_type )
 +        {
-+            TOKEN_LINKED_TOKEN *linked_token = info;
++            TOKEN_LINKED_TOKEN *linked_token = tokeninfo;
 +            req->handle = wine_server_obj_handle( token );
 +            status = wine_server_call( req );
 +            if (status == STATUS_SUCCESS)
@@ -58,10 +50,9 @@ index f0057116dee..2769e5f6a7b 100644
 +        }
 +        SERVER_END_REQ;
 +        break;
-+
      case TokenElevation:
          SERVER_START_REQ( get_token_elevation_type )
          {
 -- 
-2.27.0
+2.13.1
 
diff --git a/patches/advapi32-Token_Integrity_Level/definition b/patches/advapi32-Token_Integrity_Level/definition
index d867c64b..76031efe 100644
--- a/patches/advapi32-Token_Integrity_Level/definition
+++ b/patches/advapi32-Token_Integrity_Level/definition
@@ -1,7 +1,4 @@
 Fixes: [40613] Basic implementation for token integrity levels and UAC handling
 Fixes: [39262] Run explorer.exe as unevaluated process
+Depends: advapi32-CreateRestrictedToken
 Depends: Staging
-# Broken due to ntdll.so <- ntdll.dll imports. This isn't particularly difficult
-# to fix, but it was already broken for some more obscure reason, and the whole
-# patch set needs to be rewritten anyway.
-Disabled: true
diff --git a/patches/bcrypt-ECDHSecretAgreement/0001-bcrypt-Implement-BCryptSecretAgreement-with-libgcryp.patch b/patches/bcrypt-ECDHSecretAgreement/0001-bcrypt-Implement-BCryptSecretAgreement-with-libgcryp.patch
index b5516951..19818418 100644
--- a/patches/bcrypt-ECDHSecretAgreement/0001-bcrypt-Implement-BCryptSecretAgreement-with-libgcryp.patch
+++ b/patches/bcrypt-ECDHSecretAgreement/0001-bcrypt-Implement-BCryptSecretAgreement-with-libgcryp.patch
@@ -1,4 +1,4 @@
-From 7fcdf1faa257c90d6452f26ad3a68daca1dd96d1 Mon Sep 17 00:00:00 2001
+From 2674bbd626b4a9e46e5ab729cb47c81950efefea Mon Sep 17 00:00:00 2001
 From: Derek Lesho <dlesho@codeweavers.com>
 Date: Tue, 7 Jan 2020 14:22:49 -0600
 Subject: [PATCH] bcrypt: Implement BCryptSecretAgreement with libgcrypt.
@@ -9,15 +9,15 @@ Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
  dlls/bcrypt/Makefile.in       |   1 +
  dlls/bcrypt/bcrypt_internal.h |   6 +
  dlls/bcrypt/bcrypt_main.c     |  54 ++++++-
- dlls/bcrypt/gcrypt.c          | 263 ++++++++++++++++++++++++++++++++++
+ dlls/bcrypt/gcrypt.c          | 264 ++++++++++++++++++++++++++++++++++
  dlls/bcrypt/gnutls.c          |   9 ++
  dlls/bcrypt/macos.c           |   6 +
  dlls/bcrypt/tests/bcrypt.c    |   2 +-
- 8 files changed, 349 insertions(+), 6 deletions(-)
+ 8 files changed, 350 insertions(+), 6 deletions(-)
  create mode 100644 dlls/bcrypt/gcrypt.c
 
 diff --git a/configure.ac b/configure.ac
-index 006087e05ec..b50737a766e 100644
+index 928f8ebd1b1..f9db147e7d5 100644
 --- a/configure.ac
 +++ b/configure.ac
 @@ -47,6 +47,7 @@ AC_ARG_WITH(faudio,    AS_HELP_STRING([--without-faudio],[do not use FAudio (XAu
@@ -28,7 +28,7 @@ index 006087e05ec..b50737a766e 100644
  AC_ARG_WITH(gettext,   AS_HELP_STRING([--without-gettext],[do not use gettext]))
  AC_ARG_WITH(gettextpo, AS_HELP_STRING([--with-gettextpo],[use the GetTextPO library to rebuild po files]),
              [if test "x$withval" = "xno"; then ac_cv_header_gettext_po_h=no; fi])
-@@ -2044,6 +2045,19 @@ WINE_NOTICE_WITH(vkd3d,[test "x$ac_cv_lib_soname_vkd3d" = "x"],
+@@ -2033,6 +2034,19 @@ WINE_NOTICE_WITH(vkd3d,[test "x$ac_cv_lib_soname_vkd3d" = "x"],
                   [vkd3d ${notice_platform}development files not found (or too old), Direct3D 12 won't be supported.])
  test "x$ac_cv_lib_soname_vkd3d" != "x" || enable_d3d12=${enable_d3d12:-no}
  
@@ -92,10 +92,10 @@ index 43be170d77f..6c93ed78389 100644
  BOOL is_zero_vector( const UCHAR *, ULONG ) DECLSPEC_HIDDEN;
  BOOL is_equal_vector( const UCHAR *, ULONG, const UCHAR *, ULONG ) DECLSPEC_HIDDEN;
 diff --git a/dlls/bcrypt/bcrypt_main.c b/dlls/bcrypt/bcrypt_main.c
-index cd3b746e295..7b2a3393902 100644
+index bea2001a677..65c28ca63e2 100644
 --- a/dlls/bcrypt/bcrypt_main.c
 +++ b/dlls/bcrypt/bcrypt_main.c
-@@ -1425,6 +1425,12 @@ NTSTATUS key_import_ecc( struct key *key, UCHAR *input, ULONG len )
+@@ -1421,6 +1421,12 @@ NTSTATUS key_import_ecc( struct key *key, UCHAR *input, ULONG len )
      ERR( "support for keys not available at build time\n" );
      return STATUS_NOT_IMPLEMENTED;
  }
@@ -108,7 +108,7 @@ index cd3b746e295..7b2a3393902 100644
  #endif
  
  NTSTATUS WINAPI BCryptGenerateSymmetricKey( BCRYPT_ALG_HANDLE algorithm, BCRYPT_KEY_HANDLE *handle,
-@@ -1842,8 +1848,9 @@ NTSTATUS WINAPI BCryptSecretAgreement(BCRYPT_KEY_HANDLE privatekey, BCRYPT_KEY_H
+@@ -1838,8 +1844,9 @@ NTSTATUS WINAPI BCryptSecretAgreement(BCRYPT_KEY_HANDLE privatekey, BCRYPT_KEY_H
      struct key *privkey = privatekey;
      struct key *pubkey = publickey;
      struct secret *secret;
@@ -119,7 +119,7 @@ index cd3b746e295..7b2a3393902 100644
  
      if (!privkey || privkey->hdr.magic != MAGIC_KEY) return STATUS_INVALID_HANDLE;
      if (!pubkey || pubkey->hdr.magic != MAGIC_KEY) return STATUS_INVALID_HANDLE;
-@@ -1852,7 +1859,16 @@ NTSTATUS WINAPI BCryptSecretAgreement(BCRYPT_KEY_HANDLE privatekey, BCRYPT_KEY_H
+@@ -1848,7 +1855,16 @@ NTSTATUS WINAPI BCryptSecretAgreement(BCRYPT_KEY_HANDLE privatekey, BCRYPT_KEY_H
      if (!(secret = heap_alloc_zero( sizeof(*secret) ))) return STATUS_NO_MEMORY;
      secret->hdr.magic = MAGIC_SECRET;
  
@@ -137,7 +137,7 @@ index cd3b746e295..7b2a3393902 100644
      return STATUS_SUCCESS;
  }
  
-@@ -1860,10 +1876,11 @@ NTSTATUS WINAPI BCryptDestroySecret(BCRYPT_SECRET_HANDLE handle)
+@@ -1856,10 +1872,11 @@ NTSTATUS WINAPI BCryptDestroySecret(BCRYPT_SECRET_HANDLE handle)
  {
      struct secret *secret = handle;
  
@@ -150,7 +150,7 @@ index cd3b746e295..7b2a3393902 100644
      heap_free( secret );
      return STATUS_SUCCESS;
  }
-@@ -1873,12 +1890,33 @@ NTSTATUS WINAPI BCryptDeriveKey(BCRYPT_SECRET_HANDLE handle, LPCWSTR kdf, BCrypt
+@@ -1869,12 +1886,33 @@ NTSTATUS WINAPI BCryptDeriveKey(BCRYPT_SECRET_HANDLE handle, LPCWSTR kdf, BCrypt
  {
      struct secret *secret = handle;
  
@@ -186,7 +186,7 @@ index cd3b746e295..7b2a3393902 100644
  }
  
  BOOL WINAPI DllMain( HINSTANCE hinst, DWORD reason, LPVOID reserved )
-@@ -1890,6 +1928,9 @@ BOOL WINAPI DllMain( HINSTANCE hinst, DWORD reason, LPVOID reserved )
+@@ -1886,6 +1924,9 @@ BOOL WINAPI DllMain( HINSTANCE hinst, DWORD reason, LPVOID reserved )
          DisableThreadLibraryCalls( hinst );
  #ifdef HAVE_GNUTLS_CIPHER_INIT
          gnutls_initialize();
@@ -196,7 +196,7 @@ index cd3b746e295..7b2a3393902 100644
  #endif
          break;
  
-@@ -1897,6 +1938,9 @@ BOOL WINAPI DllMain( HINSTANCE hinst, DWORD reason, LPVOID reserved )
+@@ -1893,6 +1934,9 @@ BOOL WINAPI DllMain( HINSTANCE hinst, DWORD reason, LPVOID reserved )
          if (reserved) break;
  #ifdef HAVE_GNUTLS_CIPHER_INIT
          gnutls_uninitialize();
@@ -208,10 +208,10 @@ index cd3b746e295..7b2a3393902 100644
      }
 diff --git a/dlls/bcrypt/gcrypt.c b/dlls/bcrypt/gcrypt.c
 new file mode 100644
-index 00000000000..4e0386a3dda
+index 00000000000..f882d61def8
 --- /dev/null
 +++ b/dlls/bcrypt/gcrypt.c
-@@ -0,0 +1,263 @@
+@@ -0,0 +1,264 @@
 +#include "config.h"
 +#include "wine/port.h"
 +
@@ -235,6 +235,7 @@ index 00000000000..4e0386a3dda
 +
 +#include "wine/debug.h"
 +#include "wine/heap.h"
++#include "wine/library.h"
 +#include "wine/unicode.h"
 +
 +#if defined(HAVE_GNUTLS_CIPHER_INIT) &&  defined(SONAME_LIBGCRYPT)
@@ -476,10 +477,10 @@ index 00000000000..4e0386a3dda
 +}
 +#endif
 diff --git a/dlls/bcrypt/gnutls.c b/dlls/bcrypt/gnutls.c
-index 7acf8198626..8e5481aecc3 100644
+index 19a00e2ee25..1e075fe9994 100644
 --- a/dlls/bcrypt/gnutls.c
 +++ b/dlls/bcrypt/gnutls.c
-@@ -1606,4 +1606,13 @@ NTSTATUS key_destroy( struct key *key )
+@@ -1585,4 +1585,13 @@ NTSTATUS key_destroy( struct key *key )
      heap_free( key );
      return STATUS_SUCCESS;
  }
@@ -509,10 +510,10 @@ index 7f902535b8f..6c2a41a0725 100644
 +}
  #endif
 diff --git a/dlls/bcrypt/tests/bcrypt.c b/dlls/bcrypt/tests/bcrypt.c
-index 7fdc0ac7fb2..5701a0a30ce 100644
+index eb7a72e0ff4..a351aacf1f5 100644
 --- a/dlls/bcrypt/tests/bcrypt.c
 +++ b/dlls/bcrypt/tests/bcrypt.c
-@@ -2115,7 +2115,7 @@ static void test_ECDH(void)
+@@ -2068,7 +2068,7 @@ static void test_ECDH(void)
          goto raw_secret_end;
      }
  
@@ -522,5 +523,5 @@ index 7fdc0ac7fb2..5701a0a30ce 100644
      if (status != STATUS_SUCCESS)
      {
 -- 
-2.28.0
+2.27.0
 
diff --git a/patches/configure-Absolute_RPATH/0001-configure-Also-add-the-absolute-RPATH-when-linking-a.patch b/patches/configure-Absolute_RPATH/0001-configure-Also-add-the-absolute-RPATH-when-linking-a.patch
new file mode 100644
index 00000000..6d89e574
--- /dev/null
+++ b/patches/configure-Absolute_RPATH/0001-configure-Also-add-the-absolute-RPATH-when-linking-a.patch
@@ -0,0 +1,30 @@
+From 38d4fa059ffd4ecba4e7d04e2a5edd2bcff3c7df Mon Sep 17 00:00:00 2001
+From: Sebastian Lackner <sebastian@fds-team.de>
+Date: Wed, 27 Aug 2014 00:31:23 +0200
+Subject: [PATCH] configure: Also add the absolute RPATH when linking against
+ libwine.
+
+---
+ configure.ac | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/configure.ac b/configure.ac
+index c88013910af..a7f1866bf0d 100644
+--- a/configure.ac
++++ b/configure.ac
+@@ -969,10 +969,10 @@ case $host_os in
+       WINEPRELOADER_LDFLAGS="-static -nostartfiles -nodefaultlibs -Wl,-Ttext=0x7d400000"
+ 
+       WINE_TRY_CFLAGS([-Wl,--rpath,\$ORIGIN/../lib],
+-                      [LDRPATH_INSTALL="-Wl,--rpath,\\\$\$ORIGIN/\`\$(MAKEDEP) -R \${bindir} \${libdir}\`"
++                      [LDRPATH_INSTALL="-Wl,--rpath,\\\$\$ORIGIN/\`\$(MAKEDEP) -R \${bindir} \${libdir}\`:\$(DESTDIR)\${libdir}"
+                        LDRPATH_LOCAL="-Wl,--rpath,\\\$\$ORIGIN/\$(top_builddir)/libs/wine"],
+           [WINE_TRY_CFLAGS([-Wl,-R,\$ORIGIN/../lib],
+-                           [LDRPATH_INSTALL="-Wl,-R,\\\$\$ORIGIN/\`\$(MAKEDEP) -R \${bindir} \${libdir}\`"
++                           [LDRPATH_INSTALL="-Wl,-R,\\\$\$ORIGIN/\`\$(MAKEDEP) -R \${bindir} \${libdir}\`:\$(DESTDIR)\${libdir}"
+                             LDRPATH_LOCAL="-Wl,-R,\\\$\$ORIGIN/\$(top_builddir)/libs/wine"])])
+ 
+       WINE_TRY_CFLAGS([-Wl,--enable-new-dtags],
+-- 
+2.27.0
+
diff --git a/patches/configure-Absolute_RPATH/definition b/patches/configure-Absolute_RPATH/definition
new file mode 100644
index 00000000..ffa3d2c3
--- /dev/null
+++ b/patches/configure-Absolute_RPATH/definition
@@ -0,0 +1 @@
+Fixes: [26256] Support for setcap on wine-preloader
diff --git a/patches/eventfd_synchronization/0023-ntdll-wineandroid.drv-winemac.drv-winex11.drv-Store-.patch b/patches/eventfd_synchronization/0023-ntdll-wineandroid.drv-winemac.drv-winex11.drv-Store-.patch
index 0e0e1e1f..76cd66e3 100644
--- a/patches/eventfd_synchronization/0023-ntdll-wineandroid.drv-winemac.drv-winex11.drv-Store-.patch
+++ b/patches/eventfd_synchronization/0023-ntdll-wineandroid.drv-winemac.drv-winex11.drv-Store-.patch
@@ -46,7 +46,7 @@ index 44a65711c908..c24d4c807348 100644
 +
  # Server interface
  @ cdecl -norelay wine_server_call(ptr)
- @ cdecl wine_server_close_fds_by_type(long)
+ @ cdecl wine_server_fd_to_handle(long long long ptr)
 diff --git a/dlls/ntdll/ntdll_misc.h b/dlls/ntdll/ntdll_misc.h
 index dd5db3f18f32..e9262de93da9 100644
 --- a/dlls/ntdll/ntdll_misc.h
diff --git a/patches/eventfd_synchronization/0079-ntdll-server-Revert-to-old-implementation-of-hung-qu.patch b/patches/eventfd_synchronization/0079-ntdll-server-Revert-to-old-implementation-of-hung-qu.patch
index 7518ef57..f7f44a94 100644
--- a/patches/eventfd_synchronization/0079-ntdll-server-Revert-to-old-implementation-of-hung-qu.patch
+++ b/patches/eventfd_synchronization/0079-ntdll-server-Revert-to-old-implementation-of-hung-qu.patch
@@ -178,8 +178,8 @@ index c365eacb9e0..2b780deb112 100644
      if (!(msg = mem_alloc( sizeof(*msg) ))) return 0;
  
 @@ -3432,3 +3442,14 @@ DECL_HANDLER(get_rawinput_devices)
- 
-     set_reply_data_ptr( devices, device_count * sizeof (*devices) );
+     e = find_rawinput_device( 1, 6 );
+     current->process->rawinput_kbd   = e ? &e->device : NULL;
  }
 +
 +DECL_HANDLER(esync_msgwait)
diff --git a/patches/eventfd_synchronization/definition b/patches/eventfd_synchronization/definition
index f32566c3..21edef9d 100644
--- a/patches/eventfd_synchronization/definition
+++ b/patches/eventfd_synchronization/definition
@@ -2,8 +2,8 @@ Fixes: [36692] Many multi-threaded applications have poor performance due to hea
 # Note: the following dependencies are essentially artificial; in particular
 # these patches do not make use of the Staging shared memory infrastructure.
 Depends: server-Shared_Memory
+Depends: ntdll-RtlCreateUserThread
 Depends: server-Realtime_Priority
 Depends: advapi32-Token_Integrity_Level
 Depends: ntdll-Junction_Points
-Depends: user32-rawinput-mouse
-Disabled: true
\ No newline at end of file
+Depends: kernel32-K32GetPerformanceInfo
diff --git a/patches/kernel32-K32GetPerformanceInfo/0001-kernel32-Make-K32GetPerformanceInfo-faster.patch b/patches/kernel32-K32GetPerformanceInfo/0001-kernel32-Make-K32GetPerformanceInfo-faster.patch
new file mode 100644
index 00000000..6d992a41
--- /dev/null
+++ b/patches/kernel32-K32GetPerformanceInfo/0001-kernel32-Make-K32GetPerformanceInfo-faster.patch
@@ -0,0 +1,131 @@
+From 223addb60e053484eaa77df434898419683e926b Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
+Date: Sun, 19 Feb 2017 05:38:40 +0100
+Subject: [PATCH] kernel32: Make K32GetPerformanceInfo faster.
+
+---
+ dlls/kernelbase/debug.c | 44 ++++++++++++++---------------------------
+ server/process.c        | 18 +++++++++++++++++
+ server/protocol.def     |  8 ++++++++
+ 3 files changed, 41 insertions(+), 29 deletions(-)
+
+diff --git a/dlls/kernelbase/debug.c b/dlls/kernelbase/debug.c
+index 6acdf0f1ea95..8f021ebb0d21 100644
+--- a/dlls/kernelbase/debug.c
++++ b/dlls/kernelbase/debug.c
+@@ -1449,7 +1449,6 @@ BOOL WINAPI DECLSPEC_HOTPATCH K32GetPerformanceInfo( PPERFORMANCE_INFORMATION in
+ {
+     SYSTEM_PERFORMANCE_INFORMATION perf;
+     SYSTEM_BASIC_INFORMATION basic;
+-    SYSTEM_PROCESS_INFORMATION *process, *spi;
+     DWORD info_size;
+     NTSTATUS status;
+ 
+@@ -1462,9 +1461,9 @@ BOOL WINAPI DECLSPEC_HOTPATCH K32GetPerformanceInfo( PPERFORMANCE_INFORMATION in
+     }
+ 
+     status = NtQuerySystemInformation( SystemPerformanceInformation, &perf, sizeof(perf), NULL );
+-    if (!set_ntstatus( status )) return FALSE;
++    if (status) goto err;
+     status = NtQuerySystemInformation( SystemBasicInformation, &basic, sizeof(basic), NULL );
+-    if (!set_ntstatus( status )) return FALSE;
++    if (status) goto err;
+ 
+     info->cb                 = sizeof(*info);
+     info->CommitTotal        = perf.TotalCommittedPages;
+@@ -1478,37 +1477,24 @@ BOOL WINAPI DECLSPEC_HOTPATCH K32GetPerformanceInfo( PPERFORMANCE_INFORMATION in
+     info->KernelNonpaged     = perf.NonPagedPoolUsage;
+     info->PageSize           = basic.PageSize;
+ 
+-    /* fields from SYSTEM_PROCESS_INFORMATION */
+-    NtQuerySystemInformation( SystemProcessInformation, NULL, 0, &info_size );
+-    for (;;)
++    SERVER_START_REQ( get_system_info )
+     {
+-        process = HeapAlloc( GetProcessHeap(), 0, info_size );
+-        if (!process)
++        status = wine_server_call( req );
++        if (!status)
+         {
+-            SetLastError( ERROR_OUTOFMEMORY );
+-            return FALSE;
+-        }
+-        status = NtQuerySystemInformation( SystemProcessInformation, process, info_size, &info_size );
+-        if (!status) break;
+-        HeapFree( GetProcessHeap(), 0, process );
+-        if (status != STATUS_INFO_LENGTH_MISMATCH)
+-        {
+-            SetLastError( RtlNtStatusToDosError( status ) );
+-            return FALSE;
++            info->ProcessCount = reply->processes;
++            info->HandleCount = reply->handles;
++            info->ThreadCount = reply->threads;
+         }
+     }
+-    info->HandleCount = info->ProcessCount = info->ThreadCount = 0;
+-    spi = process;
+-    for (;;)
+-    {
+-        info->ProcessCount++;
+-        info->HandleCount += spi->HandleCount;
+-        info->ThreadCount += spi->dwThreadCount;
+-        if (spi->NextEntryOffset == 0) break;
+-        spi = (SYSTEM_PROCESS_INFORMATION *)((char *)spi + spi->NextEntryOffset);
+-    }
+-    HeapFree( GetProcessHeap(), 0, process );
++    SERVER_END_REQ;
++
++    if (status) goto err;
+     return TRUE;
++
++err:
++    SetLastError( RtlNtStatusToDosError( status ) );
++    return FALSE;
+ }
+ 
+ 
+diff --git a/server/process.c b/server/process.c
+index 3156e1bc82a5..da5c55e5368a 100644
+--- a/server/process.c
++++ b/server/process.c
+@@ -1830,3 +1830,21 @@ DECL_HANDLER(resume_process)
+         release_object( process );
+     }
+ }
++
++/* Retrieve process, thread and handle count */
++DECL_HANDLER(get_system_info)
++{
++    struct process *process;
++
++    reply->processes = 0;
++    reply->threads = 0;
++    reply->handles = 0;
++
++    LIST_FOR_EACH_ENTRY( process, &process_list, struct process, entry )
++    {
++        if (!process->running_threads) continue;
++        reply->processes++;
++        reply->threads += process->running_threads;
++        reply->handles += get_handle_table_count( process );
++    }
++}
+diff --git a/server/protocol.def b/server/protocol.def
+index ef10b5e1438c..ca34c9dc1b4b 100644
+--- a/server/protocol.def
++++ b/server/protocol.def
+@@ -3992,3 +3992,11 @@ struct handle_info
+ @REQ(resume_process)
+     obj_handle_t handle;       /* process handle */
+ @END
++
++/* Return system information values */
++@REQ(get_system_info)
++@REPLY
++    unsigned int processes;   /* number of processes */
++    unsigned int threads;     /* number of threads */
++    unsigned int handles;     /* number of handles */
++@END
+-- 
+2.26.2
+
diff --git a/patches/kernel32-K32GetPerformanceInfo/definition b/patches/kernel32-K32GetPerformanceInfo/definition
new file mode 100644
index 00000000..7c05e9ab
--- /dev/null
+++ b/patches/kernel32-K32GetPerformanceInfo/definition
@@ -0,0 +1 @@
+Fixes: Use separate wineserver call for kernel32.K32GetPerformanceInfo
diff --git a/patches/kernel32-Processor_Group/0001-kernel32-Implement-some-processor-group-functions.patch b/patches/kernel32-Processor_Group/0001-kernel32-Implement-some-processor-group-functions.patch
index 380756c9..67feff74 100644
--- a/patches/kernel32-Processor_Group/0001-kernel32-Implement-some-processor-group-functions.patch
+++ b/patches/kernel32-Processor_Group/0001-kernel32-Implement-some-processor-group-functions.patch
@@ -1,4 +1,4 @@
-From c37ee83fb56f540a9fcb04c800ca3a6e94295e29 Mon Sep 17 00:00:00 2001
+From da0da9472013ed502f5f0aabcca5b8359ffdc1c4 Mon Sep 17 00:00:00 2001
 From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
 Date: Sat, 4 Feb 2017 16:20:37 +0100
 Subject: [PATCH] kernel32: Implement some processor group functions.
@@ -12,7 +12,7 @@ Subject: [PATCH] kernel32: Implement some processor group functions.
  5 files changed, 48 insertions(+), 7 deletions(-)
 
 diff --git a/dlls/api-ms-win-core-kernel32-legacy-l1-1-0/api-ms-win-core-kernel32-legacy-l1-1-0.spec b/dlls/api-ms-win-core-kernel32-legacy-l1-1-0/api-ms-win-core-kernel32-legacy-l1-1-0.spec
-index e653ac6d212..b6af37ab0aa 100644
+index e653ac6d2122..b6af37ab0aa2 100644
 --- a/dlls/api-ms-win-core-kernel32-legacy-l1-1-0/api-ms-win-core-kernel32-legacy-l1-1-0.spec
 +++ b/dlls/api-ms-win-core-kernel32-legacy-l1-1-0/api-ms-win-core-kernel32-legacy-l1-1-0.spec
 @@ -21,7 +21,7 @@
@@ -25,7 +25,7 @@ index e653ac6d212..b6af37ab0aa 100644
  @ stdcall GetNamedPipeServerProcessId(long ptr) kernel32.GetNamedPipeServerProcessId
  @ stdcall GetShortPathNameA(str ptr long) kernel32.GetShortPathNameA
 diff --git a/dlls/api-ms-win-core-kernel32-legacy-l1-1-1/api-ms-win-core-kernel32-legacy-l1-1-1.spec b/dlls/api-ms-win-core-kernel32-legacy-l1-1-1/api-ms-win-core-kernel32-legacy-l1-1-1.spec
-index 4998af04d9b..5ce8e24713b 100644
+index 4998af04d9bc..5ce8e24713b5 100644
 --- a/dlls/api-ms-win-core-kernel32-legacy-l1-1-1/api-ms-win-core-kernel32-legacy-l1-1-1.spec
 +++ b/dlls/api-ms-win-core-kernel32-legacy-l1-1-1/api-ms-win-core-kernel32-legacy-l1-1-1.spec
 @@ -26,7 +26,7 @@
@@ -38,10 +38,10 @@ index 4998af04d9b..5ce8e24713b 100644
  @ stdcall GetNamedPipeServerProcessId(long ptr) kernel32.GetNamedPipeServerProcessId
  @ stdcall GetNumaAvailableMemoryNodeEx(long ptr) kernel32.GetNumaAvailableMemoryNodeEx
 diff --git a/dlls/kernel32/kernel32.spec b/dlls/kernel32/kernel32.spec
-index 4b09f359b97..c1bb03080c7 100644
+index 1a6fdbab0185..6a1381b7c322 100644
 --- a/dlls/kernel32/kernel32.spec
 +++ b/dlls/kernel32/kernel32.spec
-@@ -719,7 +719,7 @@
+@@ -717,7 +717,7 @@
  @ stdcall -import GetLongPathNameW(wstr ptr long)
  @ stdcall GetMailslotInfo(long ptr ptr ptr ptr)
  @ stdcall GetMaximumProcessorCount(long)
@@ -51,10 +51,10 @@ index 4b09f359b97..c1bb03080c7 100644
  @ stdcall -import GetModuleFileNameW(long ptr long)
  @ stdcall -import GetModuleHandleA(str)
 diff --git a/dlls/kernel32/process.c b/dlls/kernel32/process.c
-index ff4e79ff2b7..c0d1d8b9294 100644
+index 8f506fcf1320..2f7ebb5edd25 100644
 --- a/dlls/kernel32/process.c
 +++ b/dlls/kernel32/process.c
-@@ -624,7 +624,9 @@ HRESULT WINAPI RegisterApplicationRecoveryCallback(APPLICATION_RECOVERY_CALLBACK
+@@ -706,7 +706,9 @@ HRESULT WINAPI RegisterApplicationRecoveryCallback(APPLICATION_RECOVERY_CALLBACK
   */
  WORD WINAPI GetActiveProcessorGroupCount(void)
  {
@@ -65,7 +65,7 @@ index ff4e79ff2b7..c0d1d8b9294 100644
      return 1;
  }
  
-@@ -633,10 +635,14 @@ WORD WINAPI GetActiveProcessorGroupCount(void)
+@@ -715,10 +717,14 @@ WORD WINAPI GetActiveProcessorGroupCount(void)
   */
  DWORD WINAPI GetActiveProcessorCount(WORD group)
  {
@@ -83,7 +83,7 @@ index ff4e79ff2b7..c0d1d8b9294 100644
  }
  
  /***********************************************************************
-@@ -650,6 +656,18 @@ DWORD WINAPI GetMaximumProcessorCount(WORD group)
+@@ -732,6 +738,18 @@ DWORD WINAPI GetMaximumProcessorCount(WORD group)
      return cpus;
  }
  
@@ -100,13 +100,13 @@ index ff4e79ff2b7..c0d1d8b9294 100644
 +
 +
  /***********************************************************************
-  *           GetFirmwareEnvironmentVariableA     (KERNEL32.@)
+  *           GetEnabledXStateFeatures (KERNEL32.@)
   */
 diff --git a/dlls/kernel32/tests/process.c b/dlls/kernel32/tests/process.c
-index 109322d6844..bdcbd4329b8 100644
+index 32818042337b..da649eff62ed 100644
 --- a/dlls/kernel32/tests/process.c
 +++ b/dlls/kernel32/tests/process.c
-@@ -90,6 +90,7 @@ static SIZE_T (WINAPI *pGetLargePageMinimum)(void);
+@@ -92,6 +92,7 @@ static SIZE_T (WINAPI *pGetLargePageMinimum)(void);
  static BOOL   (WINAPI *pInitializeProcThreadAttributeList)(struct _PROC_THREAD_ATTRIBUTE_LIST*, DWORD, DWORD, SIZE_T*);
  static BOOL   (WINAPI *pUpdateProcThreadAttribute)(struct _PROC_THREAD_ATTRIBUTE_LIST*, DWORD, DWORD_PTR, void *,SIZE_T,void*,SIZE_T*);
  static void   (WINAPI *pDeleteProcThreadAttributeList)(struct _PROC_THREAD_ATTRIBUTE_LIST*);
@@ -114,7 +114,7 @@ index 109322d6844..bdcbd4329b8 100644
  
  /* ############################### */
  static char     base[MAX_PATH];
-@@ -270,6 +271,7 @@ static BOOL init(void)
+@@ -274,6 +275,7 @@ static BOOL init(void)
      pInitializeProcThreadAttributeList = (void *)GetProcAddress(hkernel32, "InitializeProcThreadAttributeList");
      pUpdateProcThreadAttribute = (void *)GetProcAddress(hkernel32, "UpdateProcThreadAttribute");
      pDeleteProcThreadAttributeList = (void *)GetProcAddress(hkernel32, "DeleteProcThreadAttributeList");
@@ -122,8 +122,8 @@ index 109322d6844..bdcbd4329b8 100644
  
      return TRUE;
  }
-@@ -4139,6 +4141,26 @@ static void test_handle_list_attribute(BOOL child, HANDLE handle1, HANDLE handle
-     CloseHandle(pipe[1]);
+@@ -3955,6 +3957,26 @@ void test_parent_process_attribute(unsigned int level, HANDLE read_pipe)
+     }
  }
  
 +static void test_GetActiveProcessorCount(void)
@@ -148,8 +148,8 @@ index 109322d6844..bdcbd4329b8 100644
 +
  START_TEST(process)
  {
-     HANDLE job, hproc, h, h2;
-@@ -4254,6 +4276,7 @@ START_TEST(process)
+     HANDLE job;
+@@ -4065,6 +4087,7 @@ START_TEST(process)
      test_GetNumaProcessorNode();
      test_session_info();
      test_GetLogicalProcessorInformationEx();
@@ -158,5 +158,5 @@ index 109322d6844..bdcbd4329b8 100644
      test_ProcThreadAttributeList();
      test_SuspendProcessState();
 -- 
-2.28.0
+2.26.2
 
diff --git a/patches/kernel32-SetProcessDEPPolicy/0001-kernel32-Implement-SetProcessDEPPolicy.patch b/patches/kernel32-SetProcessDEPPolicy/0001-kernel32-Implement-SetProcessDEPPolicy.patch
index c67fc012..232a4090 100644
--- a/patches/kernel32-SetProcessDEPPolicy/0001-kernel32-Implement-SetProcessDEPPolicy.patch
+++ b/patches/kernel32-SetProcessDEPPolicy/0001-kernel32-Implement-SetProcessDEPPolicy.patch
@@ -1,4 +1,4 @@
-From 9a269d58ea099e115857ffe72700fdb7d5948ad5 Mon Sep 17 00:00:00 2001
+From 9d11c18b9b5a40114d28445a01347950de0d7df2 Mon Sep 17 00:00:00 2001
 From: "Olivier F. R. Dierick" <o.dierick@piezo-forte.be>
 Date: Tue, 19 Apr 2016 07:25:39 +0200
 Subject: [PATCH] kernel32: Implement SetProcessDEPPolicy().
@@ -8,10 +8,10 @@ Subject: [PATCH] kernel32: Implement SetProcessDEPPolicy().
  1 file changed, 32 insertions(+), 4 deletions(-)
 
 diff --git a/dlls/kernel32/process.c b/dlls/kernel32/process.c
-index ff4e79ff2b7..5c25920ba5b 100644
+index 71d6800f547..5423adced3c 100644
 --- a/dlls/kernel32/process.c
 +++ b/dlls/kernel32/process.c
-@@ -68,6 +68,8 @@ typedef struct
+@@ -71,6 +71,8 @@ typedef struct
      DWORD dwReserved;
  } LOADPARMS32;
  
@@ -20,23 +20,23 @@ index ff4e79ff2b7..5c25920ba5b 100644
  HMODULE kernel32_handle = 0;
  SYSTEM_BASIC_INFORMATION system_info = { 0 };
  
-@@ -83,6 +85,7 @@ const WCHAR DIR_System[] = {'C',':','\\','w','i','n','d','o','w','s',
+@@ -86,6 +88,7 @@ const WCHAR DIR_System[] = {'C',':','\\','w','i','n','d','o','w','s',
  #define PDB32_FILE_APIS_OEM 0x0040  /* File APIs are OEM */
  #define PDB32_WIN32S_PROC   0x8000  /* Win32s process */
  
 +static DEP_SYSTEM_POLICY_TYPE system_DEP_policy = OptIn;
  
- /***********************************************************************
-  *           wait_input_idle
-@@ -201,7 +204,6 @@ DWORD WINAPI LoadModule( LPCSTR name, LPVOID paramBlock )
-     return ret;
+ #ifdef __i386__
+ extern DWORD call_process_entry( PEB *peb, LPTHREAD_START_ROUTINE entry );
+@@ -177,7 +180,6 @@ void CDECL __wine_start_process( LPTHREAD_START_ROUTINE entry, PEB *peb )
+     abort();  /* should not be reached */
  }
  
 -
  /***********************************************************************
-  *           ExitProcess   (KERNEL32.@)
+  *           wait_input_idle
   *
-@@ -586,9 +588,35 @@ DEP_SYSTEM_POLICY_TYPE WINAPI GetSystemDEPPolicy(void)
+@@ -872,9 +874,35 @@ DEP_SYSTEM_POLICY_TYPE WINAPI GetSystemDEPPolicy(void)
   */
  BOOL WINAPI SetProcessDEPPolicy(DWORD newDEP)
  {
@@ -76,5 +76,5 @@ index ff4e79ff2b7..5c25920ba5b 100644
  
  /**********************************************************************
 -- 
-2.28.0
+2.17.1
 
diff --git a/patches/kernel32-SetProcessDEPPolicy/0002-kernel32-Implement-GetSystemDEPPolicy.patch b/patches/kernel32-SetProcessDEPPolicy/0002-kernel32-Implement-GetSystemDEPPolicy.patch
index b94b54ea..1481c516 100644
--- a/patches/kernel32-SetProcessDEPPolicy/0002-kernel32-Implement-GetSystemDEPPolicy.patch
+++ b/patches/kernel32-SetProcessDEPPolicy/0002-kernel32-Implement-GetSystemDEPPolicy.patch
@@ -1,4 +1,4 @@
-From aedc3b18250733d5390e88ba451ee58d517eff3b Mon Sep 17 00:00:00 2001
+From e31513df269b2ba58f0dc11cc5494b9db1e05cd4 Mon Sep 17 00:00:00 2001
 From: "Olivier F. R. Dierick" <o.dierick@piezo-forte.be>
 Date: Tue, 19 Apr 2016 07:33:32 +0200
 Subject: [PATCH] kernel32: Implement GetSystemDEPPolicy().
@@ -8,18 +8,18 @@ Subject: [PATCH] kernel32: Implement GetSystemDEPPolicy().
  1 file changed, 68 insertions(+), 2 deletions(-)
 
 diff --git a/dlls/kernel32/process.c b/dlls/kernel32/process.c
-index e8e1e61b354..639c39460d9 100644
+index cf97affd6faf..78f80c5210f0 100644
 --- a/dlls/kernel32/process.c
 +++ b/dlls/kernel32/process.c
-@@ -33,6 +33,7 @@
- #include "winnls.h"
+@@ -51,6 +51,7 @@
+ #include "winbase.h"
  #include "wincon.h"
  #include "kernel_private.h"
 +#include "winreg.h"
  #include "psapi.h"
  #include "wine/exception.h"
  #include "wine/server.h"
-@@ -560,8 +561,73 @@ DWORD WINAPI WTSGetActiveConsoleSessionId(void)
+@@ -671,8 +672,73 @@ DWORD WINAPI WTSGetActiveConsoleSessionId(void)
   */
  DEP_SYSTEM_POLICY_TYPE WINAPI GetSystemDEPPolicy(void)
  {
@@ -96,5 +96,5 @@ index e8e1e61b354..639c39460d9 100644
  
  /**********************************************************************
 -- 
-2.28.0
+2.26.2
 
diff --git a/patches/kernelbase-CreateFile2/definition b/patches/kernelbase-CreateFile2/definition
new file mode 100644
index 00000000..42764e82
--- /dev/null
+++ b/patches/kernelbase-CreateFile2/definition
@@ -0,0 +1 @@
+Fixes: [49740] kernelbase: Also pass CreateFile2 flags to CreateFileW.
diff --git a/patches/loader-KeyboardLayouts/0002-user32-Improve-GetKeyboardLayoutList.patch b/patches/loader-KeyboardLayouts/0002-user32-Improve-GetKeyboardLayoutList.patch
index 29421d6f..8c23b8a3 100644
--- a/patches/loader-KeyboardLayouts/0002-user32-Improve-GetKeyboardLayoutList.patch
+++ b/patches/loader-KeyboardLayouts/0002-user32-Improve-GetKeyboardLayoutList.patch
@@ -1,4 +1,4 @@
-From 5a1737e74415871fd5b0646ece31f191fa74bb69 Mon Sep 17 00:00:00 2001
+From 7595b344c4fc7d03f07a163b3f2f0b38123f7264 Mon Sep 17 00:00:00 2001
 From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
 Date: Tue, 9 Jul 2019 14:13:28 +1000
 Subject: [PATCH] user32: Improve GetKeyboardLayoutList
@@ -6,15 +6,15 @@ Subject: [PATCH] user32: Improve GetKeyboardLayoutList
 This function returns the current list of *installed* Keyboard layouts
 not the complete list from the registry.
 ---
- dlls/user32/driver.c      | 26 --------------------------
+ dlls/user32/driver.c      | 27 ---------------------------
  dlls/user32/tests/input.c | 35 +++++++++++++++++++++++++++++++++++
- 2 files changed, 35 insertions(+), 26 deletions(-)
+ 2 files changed, 35 insertions(+), 27 deletions(-)
 
 diff --git a/dlls/user32/driver.c b/dlls/user32/driver.c
-index 8ff6b0a817e..ddf00cfd7b5 100644
+index 6d916c7d65d..b9e0dc60e7c 100644
 --- a/dlls/user32/driver.c
 +++ b/dlls/user32/driver.c
-@@ -198,8 +198,6 @@ static void CDECL nulldrv_Beep(void)
+@@ -210,12 +210,9 @@ static void CDECL nulldrv_Beep(void)
  
  static UINT CDECL nulldrv_GetKeyboardLayoutList( INT size, HKL *layouts )
  {
@@ -23,12 +23,16 @@ index 8ff6b0a817e..ddf00cfd7b5 100644
      INT count = 0;
      ULONG_PTR baselayout;
      LANGID langid;
-@@ -211,30 +209,6 @@ static UINT CDECL nulldrv_GetKeyboardLayoutList( INT size, HKL *layouts )
+-    static const WCHAR szKeyboardReg[] = {'S','y','s','t','e','m','\\','C','u','r','r','e','n','t','C','o','n','t','r','o','l','S','e','t','\\','C','o','n','t','r','o','l','\\','K','e','y','b','o','a','r','d',' ','L','a','y','o','u','t','s',0};
+ 
+     baselayout = GetUserDefaultLCID();
+     langid = PRIMARYLANGID(LANGIDFROMLCID(baselayout));
+@@ -224,30 +221,6 @@ static UINT CDECL nulldrv_GetKeyboardLayoutList( INT size, HKL *layouts )
      else
          baselayout |= baselayout << 16;
  
 -    /* Enumerate the Registry */
--    rc = RegOpenKeyW(HKEY_LOCAL_MACHINE,L"System\\CurrentControlSet\\Control\\Keyboard Layouts",&hKeyKeyboard);
+-    rc = RegOpenKeyW(HKEY_LOCAL_MACHINE,szKeyboardReg,&hKeyKeyboard);
 -    if (rc == ERROR_SUCCESS)
 -    {
 -        do {
@@ -37,7 +41,7 @@ index 8ff6b0a817e..ddf00cfd7b5 100644
 -            rc = RegEnumKeyW(hKeyKeyboard, count, szKeyName, 9);
 -            if (rc == ERROR_SUCCESS)
 -            {
--                layout = (HKL)(ULONG_PTR)wcstoul(szKeyName,NULL,16);
+-                layout = (HKL)(ULONG_PTR)strtoulW(szKeyName,NULL,16);
 -                if (baselayout != 0 && layout == (HKL)baselayout)
 -                    baselayout = 0; /* found in the registry do not add again */
 -                if (size && layouts)
@@ -55,10 +59,10 @@ index 8ff6b0a817e..ddf00cfd7b5 100644
      if (baselayout != 0)
      {
 diff --git a/dlls/user32/tests/input.c b/dlls/user32/tests/input.c
-index 1809c147cbd..fd8f26e9ee4 100644
+index bab0fd97536..ea0cac6d18a 100644
 --- a/dlls/user32/tests/input.c
 +++ b/dlls/user32/tests/input.c
-@@ -3791,6 +3791,40 @@ static void test_UnregisterDeviceNotification(void)
+@@ -3706,6 +3706,40 @@ static void test_UnregisterDeviceNotification(void)
      ok(ret == FALSE, "Unregistering NULL Device Notification returned: %d\n", ret);
  }
  
@@ -99,7 +103,7 @@ index 1809c147cbd..fd8f26e9ee4 100644
  START_TEST(input)
  {
      char **argv;
-@@ -3826,6 +3860,7 @@ START_TEST(input)
+@@ -3741,6 +3775,7 @@ START_TEST(input)
      test_GetRawInputBuffer();
      test_RegisterRawInputDevices();
      test_rawinput(argv[0]);
@@ -108,5 +112,5 @@ index 1809c147cbd..fd8f26e9ee4 100644
      if(pGetMouseMovePointsEx)
          test_GetMouseMovePointsEx();
 -- 
-2.28.0
+2.27.0
 
diff --git a/patches/mfplat-streaming-support/0023-tools-Add-support-for-multiple-parent-directories.patch b/patches/mfplat-streaming-support/0023-tools-Add-support-for-multiple-parent-directories.patch
index 3e938090..98a2ed48 100644
--- a/patches/mfplat-streaming-support/0023-tools-Add-support-for-multiple-parent-directories.patch
+++ b/patches/mfplat-streaming-support/0023-tools-Add-support-for-multiple-parent-directories.patch
@@ -1,19 +1,19 @@
-From 0093ef3bc7c0a236b3450423529ecbf66746b6bc Mon Sep 17 00:00:00 2001
+From 7824e15960e00ffb11adae1a1e683aa1487f6317 Mon Sep 17 00:00:00 2001
 From: Derek Lesho <dlesho@codeweavers.com>
 Date: Wed, 29 Jan 2020 15:37:39 -0600
-Subject: [PATCH] tools: Add support for multiple parent directories.
+Subject: [PATCH 23/52] tools: Add support for multiple parent directories.
 
 Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
 ---
  tools/make_makefiles | 45 +++++++++++++++++++++++++++-----------------
- tools/makedep.c      | 26 +++++++++++++++++--------
- 2 files changed, 46 insertions(+), 25 deletions(-)
+ tools/makedep.c      | 30 ++++++++++++++++++++---------
+ 2 files changed, 49 insertions(+), 26 deletions(-)
 
 diff --git a/tools/make_makefiles b/tools/make_makefiles
-index a92987c2ab5..6bc1b47ca5d 100755
+index c18fa90e2d3..1e34a280a40 100755
 --- a/tools/make_makefiles
 +++ b/tools/make_makefiles
-@@ -230,14 +230,14 @@ sub parse_makefile($)
+@@ -231,14 +231,14 @@ sub parse_makefile($)
          {
              die "Configure substitution is not allowed in $file" unless $file eq "Makefile";
          }
@@ -30,7 +30,7 @@ index a92987c2ab5..6bc1b47ca5d 100755
          {
              my $var = $1;
              my @list = split(/\s+/, $2);
-@@ -292,19 +292,27 @@ sub get_makedep_flags($)
+@@ -293,19 +293,27 @@ sub get_makedep_flags($)
      return %flags;
  }
  
@@ -66,7 +66,7 @@ index a92987c2ab5..6bc1b47ca5d 100755
  }
  
  # preserve shared source files that are listed in the existing makefile
-@@ -409,13 +417,16 @@ sub assign_sources_to_makefiles(@)
+@@ -410,13 +418,16 @@ sub assign_sources_to_makefiles(@)
      foreach my $file (@makefiles)
      {
          my $make = $makefiles{$file};
@@ -91,25 +91,28 @@ index a92987c2ab5..6bc1b47ca5d 100755
  }
  
 diff --git a/tools/makedep.c b/tools/makedep.c
-index df3805591ea..df07eec5ab7 100644
+index 4bd20d469d6..a67add38afa 100644
 --- a/tools/makedep.c
 +++ b/tools/makedep.c
-@@ -184,11 +184,11 @@ struct makefile
+@@ -184,6 +184,7 @@ struct makefile
      struct strarray install_dev;
      struct strarray extra_targets;
      struct strarray extra_imports;
 +    struct strarray parent_dirs;
      struct list     sources;
      struct list     includes;
-     const char     *src_dir;
+     const char     *base_dir;
+@@ -191,7 +192,6 @@ struct makefile
      const char     *obj_dir;
+     const char     *top_src_dir;
+     const char     *top_obj_dir;
 -    const char     *parent_dir;
      const char     *module;
      const char     *testdll;
      const char     *sharedlib;
-@@ -1382,14 +1382,21 @@ static struct file *open_local_file( const struct makefile *make, const char *pa
+@@ -1376,15 +1376,24 @@ static struct file *open_local_file( const struct makefile *make, const char *pa
  {
-     char *src_path = src_dir_path( make, path );
+     char *src_path = root_dir_path( base_dir_path( make, path ));
      struct file *ret = load_file( src_path );
 +    unsigned int i;
  
@@ -122,19 +125,23 @@ index df3805591ea..df07eec5ab7 100644
 +
          free( src_path );
 -        path = strmake( "%s/%s", make->parent_dir, path );
--        src_path = src_dir_path( make, path );
+-        src_path = root_dir_path( base_dir_path( make, path ));
 +        new_path = strmake( "%s/%s", make->parent_dirs.str[i], path );
-+        src_path = src_dir_path( make, new_path );
++        src_path = root_dir_path( base_dir_path( make, new_path ));
          ret = load_file( src_path );
+-        if (ret) ret->flags |= FLAG_PARENTDIR;
 +        if (ret)
++        {
++            ret->flags |= FLAG_PARENTDIR;
 +            path = new_path;
++        }
 +        else
 +            free(new_path);
      }
  
-     if (ret) *filename = src_path;
-@@ -4119,13 +4126,13 @@ static void load_sources( struct makefile *make )
-     strarray_set_value( &make->vars, "top_srcdir", root_src_dir_path( "" ));
+     if (ret) *filename = src_dir_path( make, path );
+@@ -4275,13 +4284,13 @@ static void load_sources( struct makefile *make )
+     strarray_set_value( &make->vars, "top_srcdir", top_src_dir_path( make, "" ));
      strarray_set_value( &make->vars, "srcdir", src_dir_path( make, "" ));
  
 -    make->parent_dir    = get_expanded_make_variable( make, "PARENTSRC" );
@@ -148,7 +155,7 @@ index df3805591ea..df07eec5ab7 100644
      make->programs      = get_expanded_make_var_array( make, "PROGRAMS" );
      make->scripts       = get_expanded_make_var_array( make, "SCRIPTS" );
      make->imports       = get_expanded_make_var_array( make, "IMPORTS" );
-@@ -4170,8 +4177,11 @@ static void load_sources( struct makefile *make )
+@@ -4326,8 +4335,11 @@ static void load_sources( struct makefile *make )
      strarray_add( &make->include_args, strmake( "-I%s", obj_dir_path( make, "" )));
      if (make->src_dir)
          strarray_add( &make->include_args, strmake( "-I%s", make->src_dir ));
@@ -159,9 +166,9 @@ index df3805591ea..df07eec5ab7 100644
 +        for (i = 0; i < make->parent_dirs.count; i++)
 +            strarray_add( &make->include_args, strmake( "-I%s", src_dir_path( make, make->parent_dirs.str[i] )));
 +    }
-     strarray_add( &make->include_args, "-Iinclude" );
-     if (root_src_dir) strarray_add( &make->include_args, strmake( "-I%s", root_src_dir_path( "include" )));
- 
+     strarray_add( &make->include_args, strmake( "-I%s", top_obj_dir_path( make, "include" )));
+     if (make->top_src_dir)
+         strarray_add( &make->include_args, strmake( "-I%s", top_src_dir_path( make, "include" )));
 -- 
 2.28.0
 
diff --git a/patches/mfplat-streaming-support/0024-mf-Introduce-handler-helper.patch b/patches/mfplat-streaming-support/0024-mf-Introduce-handler-helper.patch
index 2cb89b5a..3866bba6 100644
--- a/patches/mfplat-streaming-support/0024-mf-Introduce-handler-helper.patch
+++ b/patches/mfplat-streaming-support/0024-mf-Introduce-handler-helper.patch
@@ -978,7 +978,7 @@ index 86100d7ff2a..e47c4b5a4e1 100644
  static HRESULT WINAPI winegstreamer_stream_handler_QueryInterface(IMFByteStreamHandler *iface, REFIID riid, void **obj)
  {
      TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), obj);
-@@ -1618,247 +1604,47 @@ static ULONG WINAPI winegstreamer_stream_handler_AddRef(IMFByteStreamHandler *if
+@@ -1618,248 +1604,47 @@ static ULONG WINAPI winegstreamer_stream_handler_AddRef(IMFByteStreamHandler *if
  
  static ULONG WINAPI winegstreamer_stream_handler_Release(IMFByteStreamHandler *iface)
  {
@@ -1062,7 +1062,8 @@ index 86100d7ff2a..e47c4b5a4e1 100644
 -            IPropertyStore_Release(context->props);
 -        if (context->stream)
 -            IMFByteStream_Release(context->stream);
--        heap_free(context->url);
+-        if (context->url)
+-            heap_free(context->url);
 -        heap_free(context);
 +        handler_destruct(&this->handler);
 +        heap_free(this);
diff --git a/patches/ntdll-APC_Performance/0001-ntdll-Reuse-old-async-fileio-structures-if-possible.patch b/patches/ntdll-APC_Performance/0001-ntdll-Reuse-old-async-fileio-structures-if-possible.patch
index 636c6215..73073282 100644
--- a/patches/ntdll-APC_Performance/0001-ntdll-Reuse-old-async-fileio-structures-if-possible.patch
+++ b/patches/ntdll-APC_Performance/0001-ntdll-Reuse-old-async-fileio-structures-if-possible.patch
@@ -1,4 +1,4 @@
-From 4a46bc2a1bf83744f8f5ad97594328986edd693e Mon Sep 17 00:00:00 2001
+From b03e8c0e0097e3dfd2c30f1f53f13abaa731b858 Mon Sep 17 00:00:00 2001
 From: Sebastian Lackner <sebastian@fds-team.de>
 Date: Tue, 3 Mar 2015 03:39:12 +0100
 Subject: [PATCH] ntdll: Reuse old async fileio structures if possible.
@@ -7,14 +7,14 @@ This should speed up apps which heavily rely on async io stuff. Some
 tests (using the kernel and ntdll wine tests) show that it is very
 often possible to reuse old fileio structures.
 ---
- dlls/ntdll/unix/file.c | 24 ++++++++++++++++++------
+ dlls/ntdll/file.c | 24 ++++++++++++++++++------
  1 file changed, 18 insertions(+), 6 deletions(-)
 
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index a10c4bf81aa..370dfe95471 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -4553,6 +4553,7 @@ struct async_fileio
+diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
+index 45660b47ec2e..083a413aac5f 100644
+--- a/dlls/ntdll/file.c
++++ b/dlls/ntdll/file.c
+@@ -387,6 +387,7 @@ struct async_fileio
  {
      async_callback_t    *callback; /* must be the first field */
      struct async_fileio *next;
@@ -22,10 +22,10 @@ index a10c4bf81aa..370dfe95471 100644
      HANDLE               handle;
  };
  
-@@ -4604,18 +4605,29 @@ static void release_fileio( struct async_fileio *io )
- static struct async_fileio *alloc_fileio( DWORD size, async_callback_t callback, HANDLE handle )
+@@ -430,18 +431,29 @@ static struct async_fileio *alloc_fileio( DWORD size, async_callback_t callback,
  {
      /* first free remaining previous fileinfos */
+ 
 -    struct async_fileio *io = InterlockedExchangePointer( (void **)&fileio_freelist, NULL );
 +    struct async_fileio *old_io = InterlockedExchangePointer( (void **)&fileio_freelist, NULL );
 +    struct async_fileio *io = NULL;
@@ -34,7 +34,7 @@ index a10c4bf81aa..370dfe95471 100644
 +    while (old_io)
      {
 -        struct async_fileio *next = io->next;
--        free( io );
+-        RtlFreeHeap( GetProcessHeap(), 0, io );
 -        io = next;
 +        if (!io && old_io->size >= size && old_io->size <= max(4096, 4 * size))
 +        {
@@ -45,13 +45,13 @@ index a10c4bf81aa..370dfe95471 100644
 +        else
 +        {
 +            struct async_fileio *next = old_io->next;
-+            free( old_io );
++            RtlFreeHeap( GetProcessHeap(), 0, old_io );
 +            old_io = next;
 +        }
      }
  
--    if ((io = malloc( size )))
-+    if (io || (io = malloc( size )))
+-    if ((io = RtlAllocateHeap( GetProcessHeap(), 0, size )))
++    if (io || (io = RtlAllocateHeap( GetProcessHeap(), 0, size )))
      {
          io->callback = callback;
 +        io->size     = size;
@@ -59,5 +59,5 @@ index a10c4bf81aa..370dfe95471 100644
      }
      return io;
 -- 
-2.27.0
+2.26.2
 
diff --git a/patches/ntdll-ApiSetMap/0001-ntdll-Add-dummy-apiset-to-PEB.patch b/patches/ntdll-ApiSetMap/0001-ntdll-Add-dummy-apiset-to-PEB.patch
index aa1d626e..ce6fcc1d 100644
--- a/patches/ntdll-ApiSetMap/0001-ntdll-Add-dummy-apiset-to-PEB.patch
+++ b/patches/ntdll-ApiSetMap/0001-ntdll-Add-dummy-apiset-to-PEB.patch
@@ -1,38 +1,38 @@
-From 803d1e468279ef5efc5f8f872e2fb9db2466cd75 Mon Sep 17 00:00:00 2001
+From 708e627172f61b5d0744135e31d4e9e3f7b32536 Mon Sep 17 00:00:00 2001
 From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
 Date: Mon, 3 Apr 2017 01:06:26 +0200
 Subject: [PATCH] ntdll: Add dummy apiset to PEB.
 
 ---
- dlls/ntdll/loader.c |  2 ++
+ dlls/ntdll/thread.c |  2 ++
  include/Makefile.in |  1 +
  include/apiset.h    | 37 +++++++++++++++++++++++++++++++++++++
  include/winternl.h  |  3 ++-
  4 files changed, 42 insertions(+), 1 deletion(-)
  create mode 100644 include/apiset.h
 
-diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
-index bd19474e844..00a146278a5 100644
---- a/dlls/ntdll/loader.c
-+++ b/dlls/ntdll/loader.c
-@@ -166,6 +166,7 @@ static PEB_LDR_DATA ldr = { sizeof(ldr), TRUE };
+diff --git a/dlls/ntdll/thread.c b/dlls/ntdll/thread.c
+index ca8b5e2bf8a..565dea14b39 100644
+--- a/dlls/ntdll/thread.c
++++ b/dlls/ntdll/thread.c
+@@ -75,6 +75,7 @@ static PEB_LDR_DATA ldr;
  static RTL_BITMAP tls_bitmap;
  static RTL_BITMAP tls_expansion_bitmap;
  static RTL_BITMAP fls_bitmap;
 +static API_SET_NAMESPACE_ARRAY apiset_map;
+ static int nb_threads = 1;
  
- static CRITICAL_SECTION fls_section;
- static CRITICAL_SECTION_DEBUG fls_critsect_debug =
-@@ -4016,6 +4017,7 @@ void __wine_process_init(void)
- 
-     peb->LdrData            = &ldr;
+ static RTL_CRITICAL_SECTION peb_lock;
+@@ -300,6 +301,7 @@ TEB *thread_init(void)
+     teb = virtual_alloc_first_teb();
+     peb = teb->Peb;
      peb->FastPebLock        = &peb_lock;
 +    peb->ApiSetMap          = &apiset_map;
      peb->TlsBitmap          = &tls_bitmap;
      peb->TlsExpansionBitmap = &tls_expansion_bitmap;
      peb->FlsBitmap          = &fls_bitmap;
 diff --git a/include/Makefile.in b/include/Makefile.in
-index 90fb873f203..015ad7c6942 100644
+index 9796dd8e5d9..2bc410f4308 100644
 --- a/include/Makefile.in
 +++ b/include/Makefile.in
 @@ -15,6 +15,7 @@ SOURCES = \
@@ -87,7 +87,7 @@ index 00000000000..6801cd5f509
 +
 +#endif
 diff --git a/include/winternl.h b/include/winternl.h
-index 9a70a2014f1..1d3ef1f5adb 100644
+index f362790dbca..b33e346885f 100644
 --- a/include/winternl.h
 +++ b/include/winternl.h
 @@ -23,6 +23,7 @@
@@ -108,5 +108,5 @@ index 9a70a2014f1..1d3ef1f5adb 100644
      PRTL_BITMAP                  TlsBitmap;                         /* 040/078 */
      ULONG                        TlsBitmapBits[2];                  /* 044/080 */
 -- 
-2.27.0
+2.26.2
 
diff --git a/patches/ntdll-ApiSetMap/definition b/patches/ntdll-ApiSetMap/definition
index 617c1fef..3bf50f08 100644
--- a/patches/ntdll-ApiSetMap/definition
+++ b/patches/ntdll-ApiSetMap/definition
@@ -1,2 +1,2 @@
 Fixes: [44658] Add dummy apiset to PEB struct
-Depends: ntdll-FLS_Callbacks
+Depends: ntdll-ThreadTime
diff --git a/patches/ntdll-Builtin_Prot/0001-ntdll-Fix-holes-in-ELF-mappings.patch b/patches/ntdll-Builtin_Prot/0001-ntdll-Fix-holes-in-ELF-mappings.patch
index 1376d9a2..cef9bed6 100644
--- a/patches/ntdll-Builtin_Prot/0001-ntdll-Fix-holes-in-ELF-mappings.patch
+++ b/patches/ntdll-Builtin_Prot/0001-ntdll-Fix-holes-in-ELF-mappings.patch
@@ -1,19 +1,19 @@
-From a1b46c58e7663a0c17d5dd2fbb3cc82fde40a06c Mon Sep 17 00:00:00 2001
+From ce12fa75ca18eeea3f0ec53788353d07ec683e95 Mon Sep 17 00:00:00 2001
 From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
 Date: Thu, 1 Jun 2017 06:04:53 +0200
 Subject: [PATCH] ntdll: Fix holes in ELF mappings. (v2)
 
 Based on a patch by Andrew Wesie.
 ---
- dlls/ntdll/unix/virtual.c     | 23 +++++++++++++++++++++++
+ dlls/ntdll/virtual.c          | 23 +++++++++++++++++++++++
  dlls/psapi/tests/psapi_main.c | 14 +++++++++++++-
  2 files changed, 36 insertions(+), 1 deletion(-)
 
-diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
-index 209a2647d16..2fbb5922359 100644
---- a/dlls/ntdll/unix/virtual.c
-+++ b/dlls/ntdll/unix/virtual.c
-@@ -1021,6 +1021,16 @@ static inline BOOL is_write_watch_range( const void *addr, size_t size )
+diff --git a/dlls/ntdll/virtual.c b/dlls/ntdll/virtual.c
+index 6cb47f2cae8..2ba116c4e92 100644
+--- a/dlls/ntdll/virtual.c
++++ b/dlls/ntdll/virtual.c
+@@ -485,6 +485,16 @@ static inline BOOL is_write_watch_range( const void *addr, size_t size )
  }
  
  
@@ -22,7 +22,7 @@ index 209a2647d16..2fbb5922359 100644
 + */
 +static inline BOOL is_system_range( const void *addr, size_t size )
 +{
-+    struct file_view *view = find_view( addr, size );
++    struct file_view *view = VIRTUAL_FindView( addr, size );
 +    return view && (view->protect & VPROT_SYSTEM);
 +}
 +
@@ -30,28 +30,28 @@ index 209a2647d16..2fbb5922359 100644
  /***********************************************************************
   *           find_view_range
   *
-@@ -3051,6 +3061,19 @@ NTSTATUS virtual_handle_fault( void *addr, DWORD err, void *stack )
+@@ -2386,6 +2396,19 @@ NTSTATUS virtual_handle_fault( LPCVOID addr, DWORD err, BOOL on_signal_stack )
          /* ignore fault if page is writable now */
-         if (get_unix_prot( get_page_vprot( page ) ) & PROT_WRITE) ret = STATUS_SUCCESS;
+         if (VIRTUAL_GetUnixProt( get_page_vprot( page )) & PROT_WRITE) ret = STATUS_SUCCESS;
      }
-+    else if (!err && (get_unix_prot( vprot ) & PROT_READ) && is_system_range( page, page_size ))
++    else if (!err && (VIRTUAL_GetUnixProt( vprot ) & PROT_READ) && is_system_range( page, page_size ))
 +    {
-+        int unix_prot = get_unix_prot( vprot );
++        int unix_prot = VIRTUAL_GetUnixProt( vprot );
 +        unsigned char vec;
 +
 +        mprotect_range( page, page_size, 0, 0 );
 +        if (!mincore( page, page_size, &vec ) && (vec & 1))
 +            ret = STATUS_SUCCESS;
-+        else if (anon_mmap_fixed( page, page_size, unix_prot, 0 ) == page)
++        else if (wine_anon_mmap( page, page_size, unix_prot, MAP_FIXED ) == page)
 +            ret = STATUS_SUCCESS;
 +        else
 +            set_page_vprot_bits( page, page_size, 0, VPROT_READ | VPROT_EXEC );
 +    }
-     mutex_unlock( &virtual_mutex );
+     server_leave_uninterrupted_section( &csVirtual, &sigset );
      return ret;
  }
 diff --git a/dlls/psapi/tests/psapi_main.c b/dlls/psapi/tests/psapi_main.c
-index d85099455aa..be12af58311 100644
+index eb52fc690cf..178f5605a23 100644
 --- a/dlls/psapi/tests/psapi_main.c
 +++ b/dlls/psapi/tests/psapi_main.c
 @@ -195,6 +195,7 @@ todo_wine
@@ -86,5 +86,5 @@ index d85099455aa..be12af58311 100644
  
  static BOOL check_with_margin(SIZE_T perf, SIZE_T sysperf, int margin)
 -- 
-2.28.0
+2.26.2
 
diff --git a/patches/ntdll-CriticalSection/0002-ntdll-Add-inline-versions-of-RtlEnterCriticalSection.patch b/patches/ntdll-CriticalSection/0002-ntdll-Add-inline-versions-of-RtlEnterCriticalSection.patch
index 5ee1a6a7..0b626cc0 100644
--- a/patches/ntdll-CriticalSection/0002-ntdll-Add-inline-versions-of-RtlEnterCriticalSection.patch
+++ b/patches/ntdll-CriticalSection/0002-ntdll-Add-inline-versions-of-RtlEnterCriticalSection.patch
@@ -1,18 +1,18 @@
-From fea92ad5c12ddb8d0a4d2363f21afe9c199359d1 Mon Sep 17 00:00:00 2001
+From bb92d36109c9d4931051c69c0ab789b5c1396e66 Mon Sep 17 00:00:00 2001
 From: Sebastian Lackner <sebastian@fds-team.de>
 Date: Sat, 5 Aug 2017 03:38:38 +0200
 Subject: [PATCH] ntdll: Add inline versions of RtlEnterCriticalSection /
  RtlLeaveCriticalSections.
 
 ---
- dlls/ntdll/ntdll_misc.h | 34 ++++++++++++++++++++++++++++++++++
- 1 file changed, 34 insertions(+)
+ dlls/ntdll/ntdll_misc.h | 38 ++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 38 insertions(+)
 
 diff --git a/dlls/ntdll/ntdll_misc.h b/dlls/ntdll/ntdll_misc.h
-index 92fcde95a8a..51a9069e290 100644
+index 27e7141bc65..d1fe4ba99d0 100644
 --- a/dlls/ntdll/ntdll_misc.h
 +++ b/dlls/ntdll/ntdll_misc.h
-@@ -26,6 +26,7 @@
+@@ -28,6 +28,7 @@
  #include "winnt.h"
  #include "winternl.h"
  #include "unixlib.h"
@@ -20,10 +20,12 @@ index 92fcde95a8a..51a9069e290 100644
  #include "wine/server.h"
  #include "wine/asm.h"
  
-@@ -103,6 +104,39 @@ extern int ntdll_wcstoumbs( const WCHAR* src, DWORD srclen, char* dst, DWORD dst
+@@ -237,6 +238,43 @@ extern int ntdll_wcstoumbs( const WCHAR* src, DWORD srclen, char* dst, DWORD dst
  extern int CDECL NTDLL__vsnprintf( char *str, SIZE_T len, const char *format, __ms_va_list args ) DECLSPEC_HIDDEN;
  extern int CDECL NTDLL__vsnwprintf( WCHAR *str, SIZE_T len, const WCHAR *format, __ms_va_list args ) DECLSPEC_HIDDEN;
  
++#ifdef __WINE_WINE_PORT_H
++
 +/* inline version of RtlEnterCriticalSection */
 +static inline void enter_critical_section( RTL_CRITICAL_SECTION *crit )
 +{
@@ -56,10 +58,12 @@ index 92fcde95a8a..51a9069e290 100644
 +            RtlpUnWaitCriticalSection( crit );
 +    }
 +}
++
++#endif  /* __WINE_WINE_PORT_H */
 +
  /* load order */
  
  enum loadorder
 -- 
-2.27.0
+2.26.2
 
diff --git a/patches/ntdll-DOS_Attributes/0001-ntdll-Implement-retrieving-DOS-attributes-in-NtQuery.patch b/patches/ntdll-DOS_Attributes/0001-ntdll-Implement-retrieving-DOS-attributes-in-NtQuery.patch
new file mode 100644
index 00000000..2fc8ee32
--- /dev/null
+++ b/patches/ntdll-DOS_Attributes/0001-ntdll-Implement-retrieving-DOS-attributes-in-NtQuery.patch
@@ -0,0 +1,150 @@
+From 74693bc85e3dbc1f757cfea348dc385b4badeb89 Mon Sep 17 00:00:00 2001
+From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
+Date: Tue, 19 Aug 2014 22:10:49 -0600
+Subject: [PATCH] ntdll: Implement retrieving DOS attributes in
+ NtQueryInformationFile.
+
+---
+ configure.ac          | 12 ++++++++++++
+ dlls/ntdll/file.c     | 16 ++++++++++++++++
+ include/wine/port.h   |  8 ++++++++
+ libs/port/Makefile.in |  3 ++-
+ libs/port/xattr.c     | 39 +++++++++++++++++++++++++++++++++++++++
+ 5 files changed, 77 insertions(+), 1 deletion(-)
+ create mode 100644 libs/port/xattr.c
+
+diff --git a/configure.ac b/configure.ac
+index 180d958fc4ef..1e3d2e0d4ef0 100644
+--- a/configure.ac
++++ b/configure.ac
+@@ -89,6 +89,7 @@ AC_ARG_WITH(usb,       AS_HELP_STRING([--without-usb],[do not use the libusb lib
+ AC_ARG_WITH(v4l2,      AS_HELP_STRING([--without-v4l2],[do not use v4l2 (video capture)]))
+ AC_ARG_WITH(vkd3d,     AS_HELP_STRING([--without-vkd3d],[do not use vkd3d (Direct3D 12 support)]))
+ AC_ARG_WITH(vulkan,    AS_HELP_STRING([--without-vulkan],[do not use Vulkan]))
++AC_ARG_WITH(xattr,     AS_HELP_STRING([--without-xattr],[do not use xattr (security attributes support)]))
+ AC_ARG_WITH(xcomposite,AS_HELP_STRING([--without-xcomposite],[do not use the Xcomposite extension]),
+             [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_Xcomposite_h=no; fi])
+ AC_ARG_WITH(xcursor,   AS_HELP_STRING([--without-xcursor],[do not use the Xcursor extension]),
+@@ -709,6 +710,17 @@ AC_CHECK_HEADERS([libprocstat.h],,,
+ #include <sys/socket.h>
+ #endif])
+ 
++if test "x$with_xattr" != "xno"
++then
++    AC_CHECK_HEADERS(attr/xattr.h, [HAVE_XATTR=1])
++fi
++if test "x$with_xattr" = "xyes"
++then
++    WINE_ERROR_WITH(xattr,[test "x$HAVE_XATTR" = "x"],[xattr ${notice_platform}development files \
++not found. Wine will be built without extended attribute support, which probably isn't what you \
++want. You will need to install ${notice_platform}development packages of libattr at the very least.])
++fi
++
+ dnl **** Check for working dll ****
+ 
+ AC_SUBST(DLLFLAGS,"-D_REENTRANT")
+diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
+index 9a9acfdb623b..5536e61db2e4 100644
+--- a/dlls/ntdll/file.c
++++ b/dlls/ntdll/file.c
+@@ -126,6 +126,22 @@ mode_t FILE_umask = 0;
+ NTSTATUS FILE_DecodeSymlink(const char *unix_src, char *unix_dest, USHORT *unix_dest_len,
+                             DWORD *tag, ULONG *flags, BOOL *is_dir);
+ 
++/* Match the Samba conventions for storing DOS file attributes */
++#define SAMBA_XATTR_DOS_ATTRIB XATTR_USER_PREFIX "DOSATTRIB"
++/* We are only interested in some attributes, the others have corresponding Unix attributes */
++#define XATTR_ATTRIBS_MASK     (FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_SYSTEM)
++
++/* decode the xattr-stored DOS attributes */
++static inline int get_file_xattr( char *hexattr, int attrlen )
++{
++    if (attrlen > 2 && hexattr[0] == '0' && hexattr[1] == 'x')
++    {
++        hexattr[attrlen] = 0;
++        return strtol( hexattr+2, NULL, 16 ) & XATTR_ATTRIBS_MASK;
++    }
++    return 0;
++}
++
+ /* fetch the attributes of a file */
+ static inline ULONG get_file_attributes( const struct stat *st )
+ {
+diff --git a/include/wine/port.h b/include/wine/port.h
+index e8434c73cca2..f0507efcc7e7 100644
+--- a/include/wine/port.h
++++ b/include/wine/port.h
+@@ -361,6 +361,14 @@ int usleep (unsigned int useconds);
+ 
+ extern int mkstemps(char *template, int suffix_len);
+ 
++/* Extended attribute functions */
++
++#ifndef XATTR_USER_PREFIX
++# define XATTR_USER_PREFIX "user."
++#endif
++
++extern int xattr_fget( int filedes, const char *name, void *value, size_t size );
++
+ #else /* NO_LIBWINE_PORT */
+ 
+ #define __WINE_NOT_PORTABLE(func) func##_is_not_portable func##_is_not_portable
+diff --git a/libs/port/Makefile.in b/libs/port/Makefile.in
+index 1963afe24232..4b1ecab7516b 100644
+--- a/libs/port/Makefile.in
++++ b/libs/port/Makefile.in
+@@ -22,4 +22,5 @@ C_SRCS = \
+ 	strnlen.c \
+ 	symlink.c \
+ 	usleep.c \
+-	wctype.c
++	wctype.c \
++	xattr.c
+diff --git a/libs/port/xattr.c b/libs/port/xattr.c
+new file mode 100644
+index 000000000000..94b77132bbf2
+--- /dev/null
++++ b/libs/port/xattr.c
+@@ -0,0 +1,39 @@
++/*
++ * extended attributes functions
++ *
++ * Copyright 2014 Erich E. Hoover
++ *
++ * This library is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU Lesser General Public
++ * License as published by the Free Software Foundation; either
++ * version 2.1 of the License, or (at your option) any later version.
++ *
++ * This library is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * Lesser General Public License for more details.
++ *
++ * You should have received a copy of the GNU Lesser General Public
++ * License along with this library; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
++ */
++
++#include "config.h"
++#include "wine/port.h"
++
++#if defined(HAVE_ATTR_XATTR_H)
++# include <attr/xattr.h>
++#endif
++
++#include <ctype.h>
++#include <errno.h>
++
++int xattr_fget( int filedes, const char *name, void *value, size_t size )
++{
++#if defined(HAVE_ATTR_XATTR_H)
++    return fgetxattr( filedes, name, value, size );
++#else
++    errno = ENOSYS;
++    return -1;
++#endif
++}
+-- 
+2.26.2
+
diff --git a/patches/ntdll-DOS_Attributes/0001-ntdll-Implement-retrieving-DOS-attributes-in-fd_-get.patch b/patches/ntdll-DOS_Attributes/0001-ntdll-Implement-retrieving-DOS-attributes-in-fd_-get.patch
deleted file mode 100644
index 195a84d7..00000000
--- a/patches/ntdll-DOS_Attributes/0001-ntdll-Implement-retrieving-DOS-attributes-in-fd_-get.patch
+++ /dev/null
@@ -1,122 +0,0 @@
-From 80247bc4566977f67a1851f46facba226fbd93df Mon Sep 17 00:00:00 2001
-From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
-Date: Tue, 19 Aug 2014 22:10:49 -0600
-Subject: [PATCH] ntdll: Implement retrieving DOS attributes in
- [fd_]get_file_info().
-
----
- configure.ac           | 12 ++++++++++++
- dlls/ntdll/unix/file.c | 39 ++++++++++++++++++++++++++++++++++++++-
- 2 files changed, 50 insertions(+), 1 deletion(-)
-
-diff --git a/configure.ac b/configure.ac
-index f60cd593549..cca97ee403b 100644
---- a/configure.ac
-+++ b/configure.ac
-@@ -89,6 +89,7 @@ AC_ARG_WITH(usb,       AS_HELP_STRING([--without-usb],[do not use the libusb lib
- AC_ARG_WITH(v4l2,      AS_HELP_STRING([--without-v4l2],[do not use v4l2 (video capture)]))
- AC_ARG_WITH(vkd3d,     AS_HELP_STRING([--without-vkd3d],[do not use vkd3d (Direct3D 12 support)]))
- AC_ARG_WITH(vulkan,    AS_HELP_STRING([--without-vulkan],[do not use Vulkan]))
-+AC_ARG_WITH(xattr,     AS_HELP_STRING([--without-xattr],[do not use xattr (security attributes support)]))
- AC_ARG_WITH(xcomposite,AS_HELP_STRING([--without-xcomposite],[do not use the Xcomposite extension]),
-             [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_Xcomposite_h=no; fi])
- AC_ARG_WITH(xcursor,   AS_HELP_STRING([--without-xcursor],[do not use the Xcursor extension]),
-@@ -698,6 +699,17 @@ AC_CHECK_HEADERS([libprocstat.h],,,
- #include <sys/socket.h>
- #endif])
- 
-+if test "x$with_xattr" != "xno"
-+then
-+    AC_CHECK_HEADERS(attr/xattr.h, [HAVE_XATTR=1])
-+fi
-+if test "x$with_xattr" = "xyes"
-+then
-+    WINE_ERROR_WITH(xattr,[test "x$HAVE_XATTR" = "x"],[xattr ${notice_platform}development files \
-+not found. Wine will be built without extended attribute support, which probably isn't what you \
-+want. You will need to install ${notice_platform}development packages of libattr at the very least.])
-+fi
-+
- dnl **** Check for working dll ****
- 
- AC_SUBST(DLLFLAGS,"-D_REENTRANT")
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index 03e92a5c59e..da8f65af7b3 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -105,6 +105,9 @@
- #ifdef HAVE_SYS_STATFS_H
- #include <sys/statfs.h>
- #endif
-+#ifdef HAVE_ATTR_XATTR_H
-+#include <attr/xattr.h>
-+#endif
- #include <time.h>
- #ifdef HAVE_UNISTD_H
- # include <unistd.h>
-@@ -369,6 +372,20 @@ NTSTATUS errno_to_status( int err )
-     }
- }
- 
-+#ifndef XATTR_USER_PREFIX
-+#define XATTR_USER_PREFIX "user."
-+#endif
-+
-+static int xattr_get( const char *path, const char *name, void *value, size_t size )
-+{
-+#if defined(HAVE_ATTR_XATTR_H)
-+    return getxattr( path, name, value, size );
-+#else
-+    errno = ENOSYS;
-+    return -1;
-+#endif
-+}
-+
- /* get space from the current directory data buffer, allocating a new one if necessary */
- static void *get_dir_data_space( struct dir_data *data, unsigned int size )
- {
-@@ -1448,6 +1465,22 @@ static BOOL append_entry( struct dir_data *data, const char *long_name,
- }
- 
- 
-+/* Match the Samba conventions for storing DOS file attributes */
-+#define SAMBA_XATTR_DOS_ATTRIB XATTR_USER_PREFIX "DOSATTRIB"
-+/* We are only interested in some attributes, the others have corresponding Unix attributes */
-+#define XATTR_ATTRIBS_MASK     (FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_SYSTEM)
-+
-+/* decode the xattr-stored DOS attributes */
-+static inline int get_file_xattr( char *hexattr, int attrlen )
-+{
-+    if (attrlen > 2 && hexattr[0] == '0' && hexattr[1] == 'x')
-+    {
-+        hexattr[attrlen] = 0;
-+        return strtol( hexattr+2, NULL, 16 ) & XATTR_ATTRIBS_MASK;
-+    }
-+    return 0;
-+}
-+
- /* fetch the attributes of a file */
- static inline ULONG get_file_attributes( const struct stat *st )
- {
-@@ -1491,7 +1524,8 @@ static int fd_get_file_info( int fd, unsigned int options, struct stat *st, ULON
- static int get_file_info( const char *path, struct stat *st, ULONG *attr )
- {
-     char *parent_path;
--    int ret;
-+    char hexattr[11];
-+    int len, ret;
- 
-     *attr = 0;
-     ret = lstat( path, st );
-@@ -1517,6 +1551,9 @@ static int get_file_info( const char *path, struct stat *st, ULONG *attr )
-         free( parent_path );
-     }
-     *attr |= get_file_attributes( st );
-+    len = xattr_get( path, SAMBA_XATTR_DOS_ATTRIB, hexattr, sizeof(hexattr)-1 );
-+    if (len == -1) return ret;
-+    *attr |= get_file_xattr( hexattr, len );
-     return ret;
- }
- 
--- 
-2.28.0
-
diff --git a/patches/ntdll-DOS_Attributes/0002-ntdll-Implement-retrieving-DOS-attributes-in-NtQuery.patch b/patches/ntdll-DOS_Attributes/0002-ntdll-Implement-retrieving-DOS-attributes-in-NtQuery.patch
new file mode 100644
index 00000000..21d2eb2f
--- /dev/null
+++ b/patches/ntdll-DOS_Attributes/0002-ntdll-Implement-retrieving-DOS-attributes-in-NtQuery.patch
@@ -0,0 +1,69 @@
+From 34ed49d7dbff7c5f0da8553330c3378b574429fc Mon Sep 17 00:00:00 2001
+From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
+Date: Wed, 20 Aug 2014 16:04:34 -0600
+Subject: [PATCH] ntdll: Implement retrieving DOS attributes in
+ NtQuery[Full]AttributesFile and NtQueryDirectoryFile.
+
+---
+ dlls/ntdll/file.c   |  6 +++++-
+ include/wine/port.h |  1 +
+ libs/port/xattr.c   | 10 ++++++++++
+ 3 files changed, 16 insertions(+), 1 deletion(-)
+
+diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
+index 5536e61db2e4..2fd62ebfb802 100644
+--- a/dlls/ntdll/file.c
++++ b/dlls/ntdll/file.c
+@@ -182,7 +182,8 @@ int fd_get_file_info( int fd, unsigned int options, struct stat *st, ULONG *attr
+ int get_file_info( const char *path, struct stat *st, ULONG *attr )
+ {
+     char *parent_path;
+-    int ret;
++    char hexattr[11];
++    int len, ret;
+ 
+     *attr = 0;
+     ret = lstat( path, st );
+@@ -215,6 +216,9 @@ int get_file_info( const char *path, struct stat *st, ULONG *attr )
+         RtlFreeHeap( GetProcessHeap(), 0, parent_path );
+     }
+     *attr |= get_file_attributes( st );
++    len = xattr_get( path, SAMBA_XATTR_DOS_ATTRIB, hexattr, sizeof(hexattr)-1 );
++    if (len == -1) return ret;
++    *attr |= get_file_xattr( hexattr, len );
+     return ret;
+ }
+ 
+diff --git a/include/wine/port.h b/include/wine/port.h
+index f0507efcc7e7..6e81cb71a76d 100644
+--- a/include/wine/port.h
++++ b/include/wine/port.h
+@@ -368,6 +368,7 @@ extern int mkstemps(char *template, int suffix_len);
+ #endif
+ 
+ extern int xattr_fget( int filedes, const char *name, void *value, size_t size );
++extern int xattr_get( const char *path, const char *name, void *value, size_t size );
+ 
+ #else /* NO_LIBWINE_PORT */
+ 
+diff --git a/libs/port/xattr.c b/libs/port/xattr.c
+index 94b77132bbf2..88e900dac6d4 100644
+--- a/libs/port/xattr.c
++++ b/libs/port/xattr.c
+@@ -37,3 +37,13 @@ int xattr_fget( int filedes, const char *name, void *value, size_t size )
+     return -1;
+ #endif
+ }
++
++int xattr_get( const char *path, const char *name, void *value, size_t size )
++{
++#if defined(HAVE_ATTR_XATTR_H)
++    return getxattr( path, name, value, size );
++#else
++    errno = ENOSYS;
++    return -1;
++#endif
++}
+-- 
+2.26.2
+
diff --git a/patches/ntdll-DOS_Attributes/0003-ntdll-Implement-storing-DOS-attributes-in-NtSetInfor.patch b/patches/ntdll-DOS_Attributes/0003-ntdll-Implement-storing-DOS-attributes-in-NtSetInfor.patch
index 577babdf..62aac115 100644
--- a/patches/ntdll-DOS_Attributes/0003-ntdll-Implement-storing-DOS-attributes-in-NtSetInfor.patch
+++ b/patches/ntdll-DOS_Attributes/0003-ntdll-Implement-storing-DOS-attributes-in-NtSetInfor.patch
@@ -1,96 +1,31 @@
-From 6bbf7676b4b7887a54f47b43929b8f3f1d7e77ae Mon Sep 17 00:00:00 2001
+From 1a04bc9a0ef3cf03b89d50becee9240f8a195873 Mon Sep 17 00:00:00 2001
 From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
 Date: Wed, 20 Aug 2014 00:08:52 -0600
 Subject: [PATCH] ntdll: Implement storing DOS attributes in
  NtSetInformationFile.
 
 ---
- dlls/ntdll/tests/file.c |  8 ++---
- dlls/ntdll/unix/file.c  | 74 ++++++++++++++++++++++++++++++-----------
- 2 files changed, 58 insertions(+), 24 deletions(-)
+ dlls/ntdll/file.c       | 54 ++++++++++++++++++++++++++---------------
+ dlls/ntdll/tests/file.c |  8 +++---
+ include/wine/port.h     |  2 ++
+ libs/port/xattr.c       | 20 +++++++++++++++
+ 4 files changed, 60 insertions(+), 24 deletions(-)
 
-diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
-index 8b9ec4f624d..6d2c8d2fc94 100644
---- a/dlls/ntdll/tests/file.c
-+++ b/dlls/ntdll/tests/file.c
-@@ -1389,7 +1389,7 @@ static void test_file_basic_information(void)
-     memset(&fbi, 0, sizeof(fbi));
-     res = pNtQueryInformationFile(h, &io, &fbi, sizeof fbi, FileBasicInformation);
-     ok ( res == STATUS_SUCCESS, "can't get attributes\n");
--    todo_wine ok ( (fbi.FileAttributes & attrib_mask) == FILE_ATTRIBUTE_SYSTEM, "attribute %x not FILE_ATTRIBUTE_SYSTEM\n", fbi.FileAttributes );
-+    ok ( (fbi.FileAttributes & attrib_mask) == FILE_ATTRIBUTE_SYSTEM, "attribute %x not FILE_ATTRIBUTE_SYSTEM (ok in old linux without xattr)\n", fbi.FileAttributes );
- 
-     /* Then HIDDEN */
-     memset(&fbi, 0, sizeof(fbi));
-@@ -1402,7 +1402,7 @@ static void test_file_basic_information(void)
-     memset(&fbi, 0, sizeof(fbi));
-     res = pNtQueryInformationFile(h, &io, &fbi, sizeof fbi, FileBasicInformation);
-     ok ( res == STATUS_SUCCESS, "can't get attributes\n");
--    todo_wine ok ( (fbi.FileAttributes & attrib_mask) == FILE_ATTRIBUTE_HIDDEN, "attribute %x not FILE_ATTRIBUTE_HIDDEN\n", fbi.FileAttributes );
-+    ok ( (fbi.FileAttributes & attrib_mask) == FILE_ATTRIBUTE_HIDDEN, "attribute %x not FILE_ATTRIBUTE_HIDDEN (ok in old linux without xattr)\n", fbi.FileAttributes );
- 
-     /* Check NORMAL last of all (to make sure we can clear attributes) */
-     memset(&fbi, 0, sizeof(fbi));
-@@ -1459,7 +1459,7 @@ static void test_file_all_information(void)
-     memset(&fai_buf.fai, 0, sizeof(fai_buf.fai));
-     res = pNtQueryInformationFile(h, &io, &fai_buf.fai, sizeof fai_buf, FileAllInformation);
-     ok ( res == STATUS_SUCCESS, "can't get attributes, res %x\n", res);
--    todo_wine ok ( (fai_buf.fai.BasicInformation.FileAttributes & attrib_mask) == FILE_ATTRIBUTE_SYSTEM, "attribute %x not FILE_ATTRIBUTE_SYSTEM\n", fai_buf.fai.BasicInformation.FileAttributes );
-+    ok ( (fai_buf.fai.BasicInformation.FileAttributes & attrib_mask) == FILE_ATTRIBUTE_SYSTEM, "attribute %x not FILE_ATTRIBUTE_SYSTEM (ok in old linux without xattr)\n", fai_buf.fai.BasicInformation.FileAttributes );
- 
-     /* Then HIDDEN */
-     memset(&fai_buf.fai.BasicInformation, 0, sizeof(fai_buf.fai.BasicInformation));
-@@ -1472,7 +1472,7 @@ static void test_file_all_information(void)
-     memset(&fai_buf.fai, 0, sizeof(fai_buf.fai));
-     res = pNtQueryInformationFile(h, &io, &fai_buf.fai, sizeof fai_buf, FileAllInformation);
-     ok ( res == STATUS_SUCCESS, "can't get attributes\n");
--    todo_wine ok ( (fai_buf.fai.BasicInformation.FileAttributes & attrib_mask) == FILE_ATTRIBUTE_HIDDEN, "attribute %x not FILE_ATTRIBUTE_HIDDEN\n", fai_buf.fai.BasicInformation.FileAttributes );
-+    ok ( (fai_buf.fai.BasicInformation.FileAttributes & attrib_mask) == FILE_ATTRIBUTE_HIDDEN, "attribute %x not FILE_ATTRIBUTE_HIDDEN (ok in old linux without xattr)\n", fai_buf.fai.BasicInformation.FileAttributes );
- 
-     /* Check NORMAL last of all (to make sure we can clear attributes) */
-     memset(&fai_buf.fai.BasicInformation, 0, sizeof(fai_buf.fai.BasicInformation));
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index da8f65af7b3..0a326a7a1bd 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -376,6 +376,26 @@ NTSTATUS errno_to_status( int err )
- #define XATTR_USER_PREFIX "user."
- #endif
- 
-+static int xattr_fremove( int filedes, const char *name )
-+{
-+#if defined(HAVE_ATTR_XATTR_H)
-+    return fremovexattr( filedes, name );
-+#else
-+    errno = ENOSYS;
-+    return -1;
-+#endif
-+}
-+
-+static int xattr_fset( int filedes, const char *name, void *value, size_t size )
-+{
-+#if defined(HAVE_ATTR_XATTR_H)
-+    return fsetxattr( filedes, name, value, size, 0 );
-+#else
-+    errno = ENOSYS;
-+    return -1;
-+#endif
-+}
-+
- static int xattr_get( const char *path, const char *name, void *value, size_t size )
- {
- #if defined(HAVE_ATTR_XATTR_H)
-@@ -1520,6 +1540,39 @@ static int fd_get_file_info( int fd, unsigned int options, struct stat *st, ULON
+diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
+index 2fd62ebfb802..c077add9769e 100644
+--- a/dlls/ntdll/file.c
++++ b/dlls/ntdll/file.c
+@@ -178,6 +178,39 @@ int fd_get_file_info( int fd, unsigned int options, struct stat *st, ULONG *attr
+     return ret;
  }
  
- 
 +/* set the stat info and file attributes for a file (by file descriptor) */
 +NTSTATUS fd_set_file_info( int fd, ULONG attr )
 +{
 +    char hexattr[11];
 +    struct stat st;
 +
-+    if (fstat( fd, &st ) == -1) return errno_to_status( errno );
++    if (fstat( fd, &st ) == -1) return FILE_GetNtStatus();
 +    if (attr & FILE_ATTRIBUTE_READONLY)
 +    {
 +        if (S_ISDIR( st.st_mode))
@@ -101,9 +36,9 @@ index da8f65af7b3..0a326a7a1bd 100644
 +    else
 +    {
 +        /* add write permission only where we already have read permission */
-+        st.st_mode |= (0600 | ((st.st_mode & 044) >> 1)) & (~start_umask);
++        st.st_mode |= (0600 | ((st.st_mode & 044) >> 1)) & (~FILE_umask);
 +    }
-+    if (fchmod( fd, st.st_mode ) == -1) return errno_to_status( errno );
++    if (fchmod( fd, st.st_mode ) == -1) return FILE_GetNtStatus();
 +    attr &= ~FILE_ATTRIBUTE_NORMAL; /* do not store everything, but keep everything Samba can use */
 +    if (attr != 0)
 +    {
@@ -118,9 +53,9 @@ index da8f65af7b3..0a326a7a1bd 100644
 +}
 +
  /* get the stat info and file attributes for a file (by name) */
- static int get_file_info( const char *path, struct stat *st, ULONG *attr )
+ int get_file_info( const char *path, struct stat *st, ULONG *attr )
  {
-@@ -4139,7 +4192,6 @@ NTSTATUS WINAPI NtSetInformationFile( HANDLE handle, IO_STATUS_BLOCK *io,
+@@ -3240,7 +3273,6 @@ NTSTATUS WINAPI NtSetInformationFile(HANDLE handle, PIO_STATUS_BLOCK io,
      case FileBasicInformation:
          if (len >= sizeof(FILE_BASIC_INFORMATION))
          {
@@ -128,12 +63,12 @@ index da8f65af7b3..0a326a7a1bd 100644
              const FILE_BASIC_INFORMATION *info = ptr;
              LARGE_INTEGER mtime, atime;
  
-@@ -4153,25 +4205,7 @@ NTSTATUS WINAPI NtSetInformationFile( HANDLE handle, IO_STATUS_BLOCK *io,
+@@ -3254,25 +3286,7 @@ NTSTATUS WINAPI NtSetInformationFile(HANDLE handle, PIO_STATUS_BLOCK io,
                  io->u.Status = set_file_times( fd, &mtime, &atime );
  
              if (io->u.Status == STATUS_SUCCESS && info->FileAttributes)
 -            {
--                if (fstat( fd, &st ) == -1) io->u.Status = errno_to_status( errno );
+-                if (fstat( fd, &st ) == -1) io->u.Status = FILE_GetNtStatus();
 -                else
 -                {
 -                    if (info->FileAttributes & FILE_ATTRIBUTE_READONLY)
@@ -146,15 +81,99 @@ index da8f65af7b3..0a326a7a1bd 100644
 -                    else
 -                    {
 -                        /* add write permission only where we already have read permission */
--                        st.st_mode |= (0600 | ((st.st_mode & 044) >> 1)) & (~start_umask);
+-                        st.st_mode |= (0600 | ((st.st_mode & 044) >> 1)) & (~FILE_umask);
 -                    }
--                    if (fchmod( fd, st.st_mode ) == -1) io->u.Status = errno_to_status( errno );
+-                    if (fchmod( fd, st.st_mode ) == -1) io->u.Status = FILE_GetNtStatus();
 -                }
 -            }
 +                io->u.Status = fd_set_file_info( fd, info->FileAttributes );
  
              if (needs_close) close( fd );
          }
+diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
+index 0b05c39685cd..b49a9a4dbbda 100644
+--- a/dlls/ntdll/tests/file.c
++++ b/dlls/ntdll/tests/file.c
+@@ -1365,7 +1365,7 @@ static void test_file_basic_information(void)
+     memset(&fbi, 0, sizeof(fbi));
+     res = pNtQueryInformationFile(h, &io, &fbi, sizeof fbi, FileBasicInformation);
+     ok ( res == STATUS_SUCCESS, "can't get attributes\n");
+-    todo_wine ok ( (fbi.FileAttributes & attrib_mask) == FILE_ATTRIBUTE_SYSTEM, "attribute %x not FILE_ATTRIBUTE_SYSTEM\n", fbi.FileAttributes );
++    ok ( (fbi.FileAttributes & attrib_mask) == FILE_ATTRIBUTE_SYSTEM, "attribute %x not FILE_ATTRIBUTE_SYSTEM (ok in old linux without xattr)\n", fbi.FileAttributes );
+ 
+     /* Then HIDDEN */
+     memset(&fbi, 0, sizeof(fbi));
+@@ -1378,7 +1378,7 @@ static void test_file_basic_information(void)
+     memset(&fbi, 0, sizeof(fbi));
+     res = pNtQueryInformationFile(h, &io, &fbi, sizeof fbi, FileBasicInformation);
+     ok ( res == STATUS_SUCCESS, "can't get attributes\n");
+-    todo_wine ok ( (fbi.FileAttributes & attrib_mask) == FILE_ATTRIBUTE_HIDDEN, "attribute %x not FILE_ATTRIBUTE_HIDDEN\n", fbi.FileAttributes );
++    ok ( (fbi.FileAttributes & attrib_mask) == FILE_ATTRIBUTE_HIDDEN, "attribute %x not FILE_ATTRIBUTE_HIDDEN (ok in old linux without xattr)\n", fbi.FileAttributes );
+ 
+     /* Check NORMAL last of all (to make sure we can clear attributes) */
+     memset(&fbi, 0, sizeof(fbi));
+@@ -1435,7 +1435,7 @@ static void test_file_all_information(void)
+     memset(&fai_buf.fai, 0, sizeof(fai_buf.fai));
+     res = pNtQueryInformationFile(h, &io, &fai_buf.fai, sizeof fai_buf, FileAllInformation);
+     ok ( res == STATUS_SUCCESS, "can't get attributes, res %x\n", res);
+-    todo_wine ok ( (fai_buf.fai.BasicInformation.FileAttributes & attrib_mask) == FILE_ATTRIBUTE_SYSTEM, "attribute %x not FILE_ATTRIBUTE_SYSTEM\n", fai_buf.fai.BasicInformation.FileAttributes );
++    ok ( (fai_buf.fai.BasicInformation.FileAttributes & attrib_mask) == FILE_ATTRIBUTE_SYSTEM, "attribute %x not FILE_ATTRIBUTE_SYSTEM (ok in old linux without xattr)\n", fai_buf.fai.BasicInformation.FileAttributes );
+ 
+     /* Then HIDDEN */
+     memset(&fai_buf.fai.BasicInformation, 0, sizeof(fai_buf.fai.BasicInformation));
+@@ -1448,7 +1448,7 @@ static void test_file_all_information(void)
+     memset(&fai_buf.fai, 0, sizeof(fai_buf.fai));
+     res = pNtQueryInformationFile(h, &io, &fai_buf.fai, sizeof fai_buf, FileAllInformation);
+     ok ( res == STATUS_SUCCESS, "can't get attributes\n");
+-    todo_wine ok ( (fai_buf.fai.BasicInformation.FileAttributes & attrib_mask) == FILE_ATTRIBUTE_HIDDEN, "attribute %x not FILE_ATTRIBUTE_HIDDEN\n", fai_buf.fai.BasicInformation.FileAttributes );
++    ok ( (fai_buf.fai.BasicInformation.FileAttributes & attrib_mask) == FILE_ATTRIBUTE_HIDDEN, "attribute %x not FILE_ATTRIBUTE_HIDDEN (ok in old linux without xattr)\n", fai_buf.fai.BasicInformation.FileAttributes );
+ 
+     /* Check NORMAL last of all (to make sure we can clear attributes) */
+     memset(&fai_buf.fai.BasicInformation, 0, sizeof(fai_buf.fai.BasicInformation));
+diff --git a/include/wine/port.h b/include/wine/port.h
+index 6e81cb71a76d..f90396727d6d 100644
+--- a/include/wine/port.h
++++ b/include/wine/port.h
+@@ -368,6 +368,8 @@ extern int mkstemps(char *template, int suffix_len);
+ #endif
+ 
+ extern int xattr_fget( int filedes, const char *name, void *value, size_t size );
++extern int xattr_fremove( int filedes, const char *name );
++extern int xattr_fset( int filedes, const char *name, void *value, size_t size );
+ extern int xattr_get( const char *path, const char *name, void *value, size_t size );
+ 
+ #else /* NO_LIBWINE_PORT */
+diff --git a/libs/port/xattr.c b/libs/port/xattr.c
+index 88e900dac6d4..6918c9956cc6 100644
+--- a/libs/port/xattr.c
++++ b/libs/port/xattr.c
+@@ -38,6 +38,26 @@ int xattr_fget( int filedes, const char *name, void *value, size_t size )
+ #endif
+ }
+ 
++int xattr_fremove( int filedes, const char *name )
++{
++#if defined(HAVE_ATTR_XATTR_H)
++    return fremovexattr( filedes, name );
++#else
++    errno = ENOSYS;
++    return -1;
++#endif
++}
++
++int xattr_fset( int filedes, const char *name, void *value, size_t size )
++{
++#if defined(HAVE_ATTR_XATTR_H)
++    return fsetxattr( filedes, name, value, size, 0 );
++#else
++    errno = ENOSYS;
++    return -1;
++#endif
++}
++
+ int xattr_get( const char *path, const char *name, void *value, size_t size )
+ {
+ #if defined(HAVE_ATTR_XATTR_H)
 -- 
-2.28.0
+2.26.2
 
diff --git a/patches/ntdll-DOS_Attributes/0004-ntdll-Implement-storing-DOS-attributes-in-NtCreateFi.patch b/patches/ntdll-DOS_Attributes/0004-ntdll-Implement-storing-DOS-attributes-in-NtCreateFi.patch
index a5da6caa..66bb9082 100644
--- a/patches/ntdll-DOS_Attributes/0004-ntdll-Implement-storing-DOS-attributes-in-NtCreateFi.patch
+++ b/patches/ntdll-DOS_Attributes/0004-ntdll-Implement-storing-DOS-attributes-in-NtCreateFi.patch
@@ -1,15 +1,136 @@
-From 92aeb076183fd7311b5fa05b33af0304d897361d Mon Sep 17 00:00:00 2001
+From 8fde8af21e169d9a48bab50bac4d6e24238141b6 Mon Sep 17 00:00:00 2001
 From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
 Date: Wed, 20 Aug 2014 15:28:00 -0600
 Subject: [PATCH] ntdll: Implement storing DOS attributes in NtCreateFile.
 
 ---
- dlls/ntdll/tests/directory.c | 24 ++++++++---------
- dlls/ntdll/unix/file.c       | 51 ++++++++++++++++++++++++++++++++----
- 2 files changed, 57 insertions(+), 18 deletions(-)
+ dlls/ntdll/file.c            | 76 +++++++++++++++++++++++-------------
+ dlls/ntdll/tests/directory.c | 24 ++++++------
+ include/wine/port.h          |  2 +
+ libs/port/xattr.c            | 20 ++++++++++
+ 4 files changed, 82 insertions(+), 40 deletions(-)
 
+diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
+index c077add9769e..a596afed72e7 100644
+--- a/dlls/ntdll/file.c
++++ b/dlls/ntdll/file.c
+@@ -255,6 +255,21 @@ int get_file_info( const char *path, struct stat *st, ULONG *attr )
+     return ret;
+ }
+ 
++NTSTATUS set_file_info( const char *path, ULONG attr )
++{
++    char hexattr[11];
++    int len;
++
++    /* Note: unix mode already set when called this way */
++    attr &= ~FILE_ATTRIBUTE_NORMAL; /* do not store everything, but keep everything Samba can use */
++    len = sprintf( hexattr, "0x%x", attr );
++    if (attr != 0)
++        xattr_set( path, SAMBA_XATTR_DOS_ATTRIB, hexattr, len );
++    else
++        xattr_remove( path, SAMBA_XATTR_DOS_ATTRIB );
++    return STATUS_SUCCESS;
++}
++
+ /**************************************************************************
+  *                 FILE_CreateFile                    (internal)
+  * Open a file.
+@@ -266,6 +281,10 @@ static NTSTATUS FILE_CreateFile( PHANDLE handle, ACCESS_MASK access, POBJECT_ATT
+                                  ULONG attributes, ULONG sharing, ULONG disposition,
+                                  ULONG options, PVOID ea_buffer, ULONG ea_length )
+ {
++    static UNICODE_STRING empty_string;
++    OBJECT_ATTRIBUTES unix_attr;
++    data_size_t len;
++    struct object_attributes *objattr;
+     ANSI_STRING unix_name;
+     BOOL created = FALSE;
+ 
+@@ -309,37 +328,34 @@ static NTSTATUS FILE_CreateFile( PHANDLE handle, ACCESS_MASK access, POBJECT_ATT
+         io->u.Status = STATUS_SUCCESS;
+     }
+ 
+-    if (io->u.Status == STATUS_SUCCESS)
++    if (io->u.Status != STATUS_SUCCESS)
+     {
+-        static UNICODE_STRING empty_string;
+-        OBJECT_ATTRIBUTES unix_attr = *attr;
+-        data_size_t len;
+-        struct object_attributes *objattr;
+-
+-        unix_attr.ObjectName = &empty_string;  /* we send the unix name instead */
+-        if ((io->u.Status = alloc_object_attributes( &unix_attr, &objattr, &len )))
+-        {
+-            RtlFreeAnsiString( &unix_name );
+-            return io->u.Status;
+-        }
++        WARN("%s not found (%x)\n", debugstr_us(attr->ObjectName), io->u.Status );
++        return io->u.Status;
++    }
+ 
+-        SERVER_START_REQ( create_file )
+-        {
+-            req->access     = access;
+-            req->sharing    = sharing;
+-            req->create     = disposition;
+-            req->options    = options;
+-            req->attrs      = attributes;
+-            wine_server_add_data( req, objattr, len );
+-            wine_server_add_data( req, unix_name.Buffer, unix_name.Length );
+-            io->u.Status = wine_server_call( req );
+-            *handle = wine_server_ptr_handle( reply->handle );
+-        }
+-        SERVER_END_REQ;
+-        RtlFreeHeap( GetProcessHeap(), 0, objattr );
++    unix_attr = *attr;
++    unix_attr.ObjectName = &empty_string;  /* we send the unix name instead */
++    if ((io->u.Status = alloc_object_attributes( &unix_attr, &objattr, &len )))
++    {
+         RtlFreeAnsiString( &unix_name );
++        return io->u.Status;
+     }
+-    else WARN("%s not found (%x)\n", debugstr_us(attr->ObjectName), io->u.Status );
++
++    SERVER_START_REQ( create_file )
++    {
++        req->access     = access;
++        req->sharing    = sharing;
++        req->create     = disposition;
++        req->options    = options;
++        req->attrs      = attributes;
++        wine_server_add_data( req, objattr, len );
++        wine_server_add_data( req, unix_name.Buffer, unix_name.Length );
++        io->u.Status = wine_server_call( req );
++        *handle = wine_server_ptr_handle( reply->handle );
++    }
++    SERVER_END_REQ;
++    RtlFreeHeap( GetProcessHeap(), 0, objattr );
+ 
+     if (io->u.Status == STATUS_SUCCESS)
+     {
+@@ -361,6 +377,11 @@ static NTSTATUS FILE_CreateFile( PHANDLE handle, ACCESS_MASK access, POBJECT_ATT
+             io->Information = FILE_OVERWRITTEN;
+             break;
+         }
++        if (io->Information == FILE_CREATED)
++        {
++            /* set any DOS extended attributes */
++            set_file_info( unix_name.Buffer, attributes );
++        }
+     }
+     else if (io->u.Status == STATUS_TOO_MANY_OPENED_FILES)
+     {
+@@ -368,6 +389,7 @@ static NTSTATUS FILE_CreateFile( PHANDLE handle, ACCESS_MASK access, POBJECT_ATT
+         if (!once++) ERR_(winediag)( "Too many open files, ulimit -n probably needs to be increased\n" );
+     }
+ 
++    RtlFreeAnsiString( &unix_name );
+     return io->u.Status;
+ }
+ 
 diff --git a/dlls/ntdll/tests/directory.c b/dlls/ntdll/tests/directory.c
-index d21a2e64f8e..dc4f09729ac 100644
+index 4618f4eaff2b..44933c2153df 100644
 --- a/dlls/ntdll/tests/directory.c
 +++ b/dlls/ntdll/tests/directory.c
 @@ -55,7 +55,6 @@ static NTSTATUS (WINAPI *pRtlWow64EnableFsRedirectionEx)( ULONG disable, ULONG *
@@ -57,15 +178,29 @@ index d21a2e64f8e..dc4f09729ac 100644
              testfiles[i].attr_done = TRUE;
          }
          testfiles[i].nfound++;
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index 0a326a7a1bd..a72d95f8378 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -406,6 +406,26 @@ static int xattr_get( const char *path, const char *name, void *value, size_t si
+diff --git a/include/wine/port.h b/include/wine/port.h
+index f90396727d6d..7d2c73887073 100644
+--- a/include/wine/port.h
++++ b/include/wine/port.h
+@@ -371,6 +371,8 @@ extern int xattr_fget( int filedes, const char *name, void *value, size_t size )
+ extern int xattr_fremove( int filedes, const char *name );
+ extern int xattr_fset( int filedes, const char *name, void *value, size_t size );
+ extern int xattr_get( const char *path, const char *name, void *value, size_t size );
++extern int xattr_remove( const char *path, const char *name );
++extern int xattr_set( const char *path, const char *name, void *value, size_t size );
+ 
+ #else /* NO_LIBWINE_PORT */
+ 
+diff --git a/libs/port/xattr.c b/libs/port/xattr.c
+index 6918c9956cc6..683e7a615e2b 100644
+--- a/libs/port/xattr.c
++++ b/libs/port/xattr.c
+@@ -67,3 +67,23 @@ int xattr_get( const char *path, const char *name, void *value, size_t size )
+     return -1;
  #endif
  }
- 
-+static int xattr_remove( const char *path, const char *name )
++
++int xattr_remove( const char *path, const char *name )
 +{
 +#if defined(HAVE_ATTR_XATTR_H)
 +    return removexattr( path, name );
@@ -75,7 +210,7 @@ index 0a326a7a1bd..a72d95f8378 100644
 +#endif
 +}
 +
-+static int xattr_set( const char *path, const char *name, void *value, size_t size )
++int xattr_set( const char *path, const char *name, void *value, size_t size )
 +{
 +#if defined(HAVE_ATTR_XATTR_H)
 +    return setxattr( path, name, value, size, 0 );
@@ -84,71 +219,6 @@ index 0a326a7a1bd..a72d95f8378 100644
 +    return -1;
 +#endif
 +}
-+
- /* get space from the current directory data buffer, allocating a new one if necessary */
- static void *get_dir_data_space( struct dir_data *data, unsigned int size )
- {
-@@ -3582,6 +3602,20 @@ void CDECL set_show_dot_files( BOOL enable )
-     show_dot_files = enable;
- }
- 
-+NTSTATUS set_file_info( const char *path, ULONG attr )
-+{
-+    char hexattr[11];
-+    int len;
-+
-+    /* Note: unix mode already set when called this way */
-+    attr &= ~FILE_ATTRIBUTE_NORMAL; /* do not store everything, but keep everything Samba can use */
-+    len = sprintf( hexattr, "0x%x", attr );
-+    if (attr != 0)
-+        xattr_set( path, SAMBA_XATTR_DOS_ATTRIB, hexattr, len );
-+    else
-+        xattr_remove( path, SAMBA_XATTR_DOS_ATTRIB );
-+    return STATUS_SUCCESS;
-+}
- 
- /******************************************************************************
-  *              open_unix_file
-@@ -3669,13 +3703,14 @@ NTSTATUS WINAPI NtCreateFile( HANDLE *handle, ACCESS_MASK access, OBJECT_ATTRIBU
-         io->u.Status = STATUS_SUCCESS;
-     }
- 
--    if (io->u.Status == STATUS_SUCCESS)
-+    if (io->u.Status != STATUS_SUCCESS)
-     {
--        io->u.Status = open_unix_file( handle, unix_name, access, attr, attributes,
--                                       sharing, disposition, options, ea_buffer, ea_length );
--        free( unix_name );
-+        WARN( "%s not found (%x)\n", debugstr_us(attr->ObjectName), io->u.Status );
-+        return io->u.Status;
-     }
--    else WARN( "%s not found (%x)\n", debugstr_us(attr->ObjectName), io->u.Status );
-+
-+    io->u.Status = open_unix_file( handle, unix_name, access, attr, attributes,
-+                                   sharing, disposition, options, ea_buffer, ea_length );
- 
-     if (io->u.Status == STATUS_SUCCESS)
-     {
-@@ -3697,6 +3732,11 @@ NTSTATUS WINAPI NtCreateFile( HANDLE *handle, ACCESS_MASK access, OBJECT_ATTRIBU
-             io->Information = FILE_OVERWRITTEN;
-             break;
-         }
-+        if (io->Information == FILE_CREATED)
-+        {
-+            /* set any DOS extended attributes */
-+            set_file_info( unix_name, attributes );
-+        }
-     }
-     else if (io->u.Status == STATUS_TOO_MANY_OPENED_FILES)
-     {
-@@ -3704,6 +3744,7 @@ NTSTATUS WINAPI NtCreateFile( HANDLE *handle, ACCESS_MASK access, OBJECT_ATTRIBU
-         if (!once++) ERR_(winediag)( "Too many open files, ulimit -n probably needs to be increased\n" );
-     }
- 
-+    free( unix_name );
-     return io->u.Status;
- }
- 
 -- 
-2.28.0
+2.26.2
 
diff --git a/patches/ntdll-DOS_Attributes/0005-libport-Add-support-for-Mac-OS-X-style-extended-attr.patch b/patches/ntdll-DOS_Attributes/0005-libport-Add-support-for-Mac-OS-X-style-extended-attr.patch
index 9acd3fca..90562cd4 100644
--- a/patches/ntdll-DOS_Attributes/0005-libport-Add-support-for-Mac-OS-X-style-extended-attr.patch
+++ b/patches/ntdll-DOS_Attributes/0005-libport-Add-support-for-Mac-OS-X-style-extended-attr.patch
@@ -1,18 +1,18 @@
-From 65442c83060ee1980900cc5fe38978ef8c29eba4 Mon Sep 17 00:00:00 2001
+From f083b503de5dd5ae1805e633e191532a10896eab Mon Sep 17 00:00:00 2001
 From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
 Date: Mon, 6 Oct 2014 14:21:11 -0600
-Subject: [PATCH] libport: Add support for Mac OS X style extended attributes.
+Subject: libport: Add support for Mac OS X style extended attributes.
 
 ---
- configure.ac           |  3 +++
- dlls/ntdll/unix/file.c | 23 ++++++++++++++++++-----
- 2 files changed, 21 insertions(+), 5 deletions(-)
+ configure.ac      |  3 +++
+ libs/port/xattr.c | 27 +++++++++++++++++++++------
+ 2 files changed, 24 insertions(+), 6 deletions(-)
 
 diff --git a/configure.ac b/configure.ac
-index cca97ee403b..5e33bfacf91 100644
+index 3c91af3..68dca0a 100644
 --- a/configure.ac
 +++ b/configure.ac
-@@ -702,6 +702,9 @@ AC_CHECK_HEADERS([libprocstat.h],,,
+@@ -671,6 +671,9 @@ AC_CHECK_HEADERS([libprocstat.h],,,
  if test "x$with_xattr" != "xno"
  then
      AC_CHECK_HEADERS(attr/xattr.h, [HAVE_XATTR=1])
@@ -22,24 +22,35 @@ index cca97ee403b..5e33bfacf91 100644
  fi
  if test "x$with_xattr" = "xyes"
  then
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index a72d95f8378..5e0ac914e1c 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -106,7 +106,10 @@
- #include <sys/statfs.h>
- #endif
- #ifdef HAVE_ATTR_XATTR_H
-+#undef XATTR_ADDITIONAL_OPTIONS
- #include <attr/xattr.h>
+diff --git a/libs/port/xattr.c b/libs/port/xattr.c
+index 683e7a6..efc65c5 100644
+--- a/libs/port/xattr.c
++++ b/libs/port/xattr.c
+@@ -22,7 +22,10 @@
+ #include "wine/port.h"
+ 
+ #if defined(HAVE_ATTR_XATTR_H)
++# undef XATTR_ADDITIONAL_OPTIONS
+ # include <attr/xattr.h>
 +#elif defined(HAVE_SYS_XATTR_H)
-+#include <sys/xattr.h>
++# include <sys/xattr.h>
  #endif
- #include <time.h>
- #ifdef HAVE_UNISTD_H
-@@ -378,7 +381,9 @@ NTSTATUS errno_to_status( int err )
  
- static int xattr_fremove( int filedes, const char *name )
+ #include <ctype.h>
+@@ -30,7 +33,9 @@
+ 
+ int xattr_fget( int filedes, const char *name, void *value, size_t size )
+ {
+-#if defined(HAVE_ATTR_XATTR_H)
++#if defined(XATTR_ADDITIONAL_OPTIONS)
++    return fgetxattr( filedes, name, value, size, 0, 0 );
++#elif defined(HAVE_SYS_XATTR_H) || defined(HAVE_ATTR_XATTR_H)
+     return fgetxattr( filedes, name, value, size );
+ #else
+     errno = ENOSYS;
+@@ -40,7 +45,9 @@ int xattr_fget( int filedes, const char *name, void *value, size_t size )
+ 
+ int xattr_fremove( int filedes, const char *name )
  {
 -#if defined(HAVE_ATTR_XATTR_H)
 +#if defined(XATTR_ADDITIONAL_OPTIONS)
@@ -48,9 +59,9 @@ index a72d95f8378..5e0ac914e1c 100644
      return fremovexattr( filedes, name );
  #else
      errno = ENOSYS;
-@@ -388,7 +393,9 @@ static int xattr_fremove( int filedes, const char *name )
+@@ -50,7 +57,9 @@ int xattr_fremove( int filedes, const char *name )
  
- static int xattr_fset( int filedes, const char *name, void *value, size_t size )
+ int xattr_fset( int filedes, const char *name, void *value, size_t size )
  {
 -#if defined(HAVE_ATTR_XATTR_H)
 +#if defined(XATTR_ADDITIONAL_OPTIONS)
@@ -59,9 +70,9 @@ index a72d95f8378..5e0ac914e1c 100644
      return fsetxattr( filedes, name, value, size, 0 );
  #else
      errno = ENOSYS;
-@@ -398,7 +405,9 @@ static int xattr_fset( int filedes, const char *name, void *value, size_t size )
+@@ -60,7 +69,9 @@ int xattr_fset( int filedes, const char *name, void *value, size_t size )
  
- static int xattr_get( const char *path, const char *name, void *value, size_t size )
+ int xattr_get( const char *path, const char *name, void *value, size_t size )
  {
 -#if defined(HAVE_ATTR_XATTR_H)
 +#if defined(XATTR_ADDITIONAL_OPTIONS)
@@ -70,9 +81,9 @@ index a72d95f8378..5e0ac914e1c 100644
      return getxattr( path, name, value, size );
  #else
      errno = ENOSYS;
-@@ -408,7 +417,9 @@ static int xattr_get( const char *path, const char *name, void *value, size_t si
+@@ -70,7 +81,9 @@ int xattr_get( const char *path, const char *name, void *value, size_t size )
  
- static int xattr_remove( const char *path, const char *name )
+ int xattr_remove( const char *path, const char *name )
  {
 -#if defined(HAVE_ATTR_XATTR_H)
 +#if defined(XATTR_ADDITIONAL_OPTIONS)
@@ -81,9 +92,9 @@ index a72d95f8378..5e0ac914e1c 100644
      return removexattr( path, name );
  #else
      errno = ENOSYS;
-@@ -418,7 +429,9 @@ static int xattr_remove( const char *path, const char *name )
+@@ -80,7 +93,9 @@ int xattr_remove( const char *path, const char *name )
  
- static int xattr_set( const char *path, const char *name, void *value, size_t size )
+ int xattr_set( const char *path, const char *name, void *value, size_t size )
  {
 -#if defined(HAVE_ATTR_XATTR_H)
 +#if defined(XATTR_ADDITIONAL_OPTIONS)
@@ -93,5 +104,5 @@ index a72d95f8378..5e0ac914e1c 100644
  #else
      errno = ENOSYS;
 -- 
-2.28.0
+1.9.1
 
diff --git a/patches/ntdll-DOS_Attributes/0006-libport-Add-support-for-FreeBSD-style-extended-attri.patch b/patches/ntdll-DOS_Attributes/0006-libport-Add-support-for-FreeBSD-style-extended-attri.patch
index d175436a..98e669d0 100644
--- a/patches/ntdll-DOS_Attributes/0006-libport-Add-support-for-FreeBSD-style-extended-attri.patch
+++ b/patches/ntdll-DOS_Attributes/0006-libport-Add-support-for-FreeBSD-style-extended-attri.patch
@@ -1,18 +1,18 @@
-From f4caa19ffcac13201c0c9bd45d3d93d44cb24980 Mon Sep 17 00:00:00 2001
+From 64708643d4dc9454faaccd720ab9b8a53b5aecf9 Mon Sep 17 00:00:00 2001
 From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
 Date: Mon, 6 Oct 2014 14:26:24 -0600
-Subject: [PATCH] libport: Add support for FreeBSD style extended attributes.
+Subject: libport: Add support for FreeBSD style extended attributes.
 
 ---
- configure.ac           |  2 +-
- dlls/ntdll/unix/file.c | 18 ++++++++++++++++++
- 2 files changed, 19 insertions(+), 1 deletion(-)
+ configure.ac      |  2 +-
+ libs/port/xattr.c | 41 +++++++++++++++++++++++++++++++++++++++++
+ 2 files changed, 42 insertions(+), 1 deletion(-)
 
 diff --git a/configure.ac b/configure.ac
-index 5e33bfacf91..aef00416461 100644
+index 68dca0a..3b0da05 100644
 --- a/configure.ac
 +++ b/configure.ac
-@@ -701,7 +701,7 @@ AC_CHECK_HEADERS([libprocstat.h],,,
+@@ -670,7 +670,7 @@ AC_CHECK_HEADERS([libprocstat.h],,,
  
  if test "x$with_xattr" != "xno"
  then
@@ -21,11 +21,52 @@ index 5e33bfacf91..aef00416461 100644
      AC_CHECK_HEADERS(sys/xattr.h, [HAVE_XATTR=1]
          [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <sys/xattr.h>]], [[getxattr("", "", "", 0, 0, 0);]])],
              [AC_DEFINE(XATTR_ADDITIONAL_OPTIONS, 1, [Define if xattr functions take additional arguments (Mac OS X)])])])
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index 5e0ac914e1c..c4d5f9c9028 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -385,6 +385,9 @@ static int xattr_fremove( int filedes, const char *name )
+diff --git a/libs/port/xattr.c b/libs/port/xattr.c
+index efc65c5..92a717e 100644
+--- a/libs/port/xattr.c
++++ b/libs/port/xattr.c
+@@ -26,17 +26,40 @@
+ # include <attr/xattr.h>
+ #elif defined(HAVE_SYS_XATTR_H)
+ # include <sys/xattr.h>
++#elif defined(HAVE_SYS_EXTATTR_H)
++# undef XATTR_ADDITIONAL_OPTIONS
++# include <sys/extattr.h>
+ #endif
+ 
+ #include <ctype.h>
+ #include <errno.h>
+ 
++#ifndef XATTR_USER_PREFIX_LEN
++# define XATTR_USER_PREFIX_LEN (sizeof(XATTR_USER_PREFIX) - 1)
++#endif
++
++#ifdef HAVE_SYS_EXTATTR_H
++static inline int xattr_valid_namespace( const char *name )
++{
++    if (strncmp( XATTR_USER_PREFIX, name, XATTR_USER_PREFIX_LEN ) != 0)
++    {
++        errno = EPERM;
++        return 0;
++    }
++    return 1;
++}
++#endif
++
+ int xattr_fget( int filedes, const char *name, void *value, size_t size )
+ {
+ #if defined(XATTR_ADDITIONAL_OPTIONS)
+     return fgetxattr( filedes, name, value, size, 0, 0 );
+ #elif defined(HAVE_SYS_XATTR_H) || defined(HAVE_ATTR_XATTR_H)
+     return fgetxattr( filedes, name, value, size );
++#elif defined(HAVE_SYS_EXTATTR_H)
++    if (!xattr_valid_namespace( name )) return -1;
++    return extattr_get_fd( filedes, EXTATTR_NAMESPACE_USER, &name[XATTR_USER_PREFIX_LEN],
++                           value, size );
+ #else
+     errno = ENOSYS;
+     return -1;
+@@ -49,6 +72,9 @@ int xattr_fremove( int filedes, const char *name )
      return fremovexattr( filedes, name, 0 );
  #elif defined(HAVE_SYS_XATTR_H) || defined(HAVE_ATTR_XATTR_H)
      return fremovexattr( filedes, name );
@@ -35,7 +76,7 @@ index 5e0ac914e1c..c4d5f9c9028 100644
  #else
      errno = ENOSYS;
      return -1;
-@@ -397,6 +400,10 @@ static int xattr_fset( int filedes, const char *name, void *value, size_t size )
+@@ -61,6 +87,10 @@ int xattr_fset( int filedes, const char *name, void *value, size_t size )
      return fsetxattr( filedes, name, value, size, 0, 0 );
  #elif defined(HAVE_SYS_XATTR_H) || defined(HAVE_ATTR_XATTR_H)
      return fsetxattr( filedes, name, value, size, 0 );
@@ -46,7 +87,7 @@ index 5e0ac914e1c..c4d5f9c9028 100644
  #else
      errno = ENOSYS;
      return -1;
-@@ -409,6 +416,10 @@ static int xattr_get( const char *path, const char *name, void *value, size_t si
+@@ -73,6 +103,10 @@ int xattr_get( const char *path, const char *name, void *value, size_t size )
      return getxattr( path, name, value, size, 0, 0 );
  #elif defined(HAVE_SYS_XATTR_H) || defined(HAVE_ATTR_XATTR_H)
      return getxattr( path, name, value, size );
@@ -57,7 +98,7 @@ index 5e0ac914e1c..c4d5f9c9028 100644
  #else
      errno = ENOSYS;
      return -1;
-@@ -421,6 +432,9 @@ static int xattr_remove( const char *path, const char *name )
+@@ -85,6 +119,9 @@ int xattr_remove( const char *path, const char *name )
      return removexattr( path, name, 0 );
  #elif defined(HAVE_SYS_XATTR_H) || defined(HAVE_ATTR_XATTR_H)
      return removexattr( path, name );
@@ -67,7 +108,7 @@ index 5e0ac914e1c..c4d5f9c9028 100644
  #else
      errno = ENOSYS;
      return -1;
-@@ -433,6 +447,10 @@ static int xattr_set( const char *path, const char *name, void *value, size_t si
+@@ -97,6 +134,10 @@ int xattr_set( const char *path, const char *name, void *value, size_t size )
      return setxattr( path, name, value, size, 0, 0 );
  #elif defined(HAVE_SYS_XATTR_H) || defined(HAVE_ATTR_XATTR_H)
      return setxattr( path, name, value, size, 0 );
@@ -79,5 +120,5 @@ index 5e0ac914e1c..c4d5f9c9028 100644
      errno = ENOSYS;
      return -1;
 -- 
-2.28.0
+1.9.1
 
diff --git a/patches/ntdll-DOS_Attributes/0007-ntdll-Perform-the-Unix-style-hidden-file-check-withi.patch b/patches/ntdll-DOS_Attributes/0007-ntdll-Perform-the-Unix-style-hidden-file-check-withi.patch
index cd06918f..7351d7b6 100644
--- a/patches/ntdll-DOS_Attributes/0007-ntdll-Perform-the-Unix-style-hidden-file-check-withi.patch
+++ b/patches/ntdll-DOS_Attributes/0007-ntdll-Perform-the-Unix-style-hidden-file-check-withi.patch
@@ -1,27 +1,31 @@
-From 3f308239ced2e9fa2ac0b298eeb1ad5dde330840 Mon Sep 17 00:00:00 2001
+From e1e41f084c6cdeba3cb44aaa6753b13bc1411df8 Mon Sep 17 00:00:00 2001
 From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
 Date: Wed, 20 Aug 2014 11:26:48 -0600
 Subject: [PATCH] ntdll: Perform the Unix-style hidden file check within the
  unified file info grabbing routine.
 
 ---
- dlls/ntdll/unix/file.c | 23 +++++++++--------------
- 1 file changed, 9 insertions(+), 14 deletions(-)
+ dlls/ntdll/directory.c  | 15 +++++----------
+ dlls/ntdll/file.c       | 10 ++++------
+ dlls/ntdll/ntdll_misc.h |  2 +-
+ 3 files changed, 10 insertions(+), 17 deletions(-)
 
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index 7c737edd22c..c6b4928bd53 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -1213,15 +1213,15 @@ static BOOLEAN get_dir_case_sensitivity( const char *dir )
+diff --git a/dlls/ntdll/directory.c b/dlls/ntdll/directory.c
+index ba50aa1b807..d6bf1354a5b 100644
+--- a/dlls/ntdll/directory.c
++++ b/dlls/ntdll/directory.c
+@@ -1274,17 +1274,17 @@ static DWORD WINAPI init_options( RTL_RUN_ONCE *once, void *param, void **contex
   *
   * Check if the specified file should be hidden based on its name and the show dot files option.
   */
--static BOOL is_hidden_file( const UNICODE_STRING *name )
-+static BOOL is_hidden_file( const char *name )
+-BOOL DIR_is_hidden_file( const UNICODE_STRING *name )
++BOOL DIR_is_hidden_file( const char *name )
  {
 -    WCHAR *p, *end;
 +    char *p, *end;
  
+     RtlRunOnceExecuteOnce( &init_once, init_options, NULL, NULL );
+ 
      if (show_dot_files) return FALSE;
  
 -    end = p = name->Buffer + name->Length/sizeof(WCHAR);
@@ -33,18 +37,7 @@ index 7c737edd22c..c6b4928bd53 100644
      if (p == end || *p != '.') return FALSE;
      /* make sure it isn't '.' or '..' */
      if (p + 1 == end) return FALSE;
-@@ -1567,6 +1567,10 @@ static int get_file_info( const char *path, struct stat *st, ULONG *attr )
-         free( parent_path );
-     }
-     *attr |= get_file_attributes( st );
-+    /* convert Unix-style hidden files to a DOS hidden file attribute */
-+    if (is_hidden_file( path ))
-+        *attr |= FILE_ATTRIBUTE_HIDDEN;
-+    /* retrieve any stored DOS attributes */
-     len = xattr_get( path, SAMBA_XATTR_DOS_ATTRIB, hexattr, sizeof(hexattr)-1 );
-     if (len == -1) return ret;
-     *attr |= get_file_xattr( hexattr, len );
-@@ -2077,11 +2081,6 @@ static NTSTATUS get_dir_data_entry( struct dir_data *dir_data, void *info_ptr, I
+@@ -1532,11 +1532,6 @@ static NTSTATUS get_dir_data_entry( struct dir_data *dir_data, void *info_ptr, I
      if (class != FileNamesInformation)
      {
          if (st.st_dev != dir_data->id.dev) st.st_ino = 0;  /* ignore inode if on a different device */
@@ -56,25 +49,55 @@ index 7c737edd22c..c6b4928bd53 100644
          fill_file_info( &st, attributes, info, class );
      }
  
-@@ -3838,7 +3837,6 @@ NTSTATUS WINAPI NtQueryFullAttributesFile( const OBJECT_ATTRIBUTES *attr,
+diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
+index 6a935044f46..a0e54c27198 100644
+--- a/dlls/ntdll/file.c
++++ b/dlls/ntdll/file.c
+@@ -250,6 +250,10 @@ int get_file_info( const char *path, struct stat *st, ULONG *attr )
+         RtlFreeHeap( GetProcessHeap(), 0, parent_path );
+     }
+     *attr |= get_file_attributes( st );
++    /* convert Unix-style hidden files to a DOS hidden file attribute */
++    if (DIR_is_hidden_file( path ))
++        *attr |= FILE_ATTRIBUTE_HIDDEN;
++    /* retrieve any stored DOS attributes */
+     len = xattr_get( path, SAMBA_XATTR_DOS_ATTRIB, hexattr, sizeof(hexattr)-1 );
+     if (len == -1) return ret;
+     *attr |= get_file_xattr( hexattr, len );
+@@ -3489,8 +3493,6 @@ NTSTATUS WINAPI NtQueryFullAttributesFile( const OBJECT_ATTRIBUTES *attr,
              info->AllocationSize = std.AllocationSize;
              info->EndOfFile      = std.EndOfFile;
              info->FileAttributes = basic.FileAttributes;
--            if (is_hidden_file( attr->ObjectName )) info->FileAttributes |= FILE_ATTRIBUTE_HIDDEN;
+-            if (DIR_is_hidden_file( attr->ObjectName ))
+-                info->FileAttributes |= FILE_ATTRIBUTE_HIDDEN;
          }
-         free( unix_name );
+         RtlFreeAnsiString( &unix_name );
      }
-@@ -3865,10 +3863,7 @@ NTSTATUS WINAPI NtQueryAttributesFile( const OBJECT_ATTRIBUTES *attr, FILE_BASIC
+@@ -3518,11 +3520,7 @@ NTSTATUS WINAPI NtQueryAttributesFile( const OBJECT_ATTRIBUTES *attr, FILE_BASIC
          else if (!S_ISREG(st.st_mode) && !S_ISDIR(st.st_mode))
              status = STATUS_INVALID_INFO_CLASS;
          else
 -        {
              status = fill_file_info( &st, attributes, info, FileBasicInformation );
--            if (is_hidden_file( attr->ObjectName )) info->FileAttributes |= FILE_ATTRIBUTE_HIDDEN;
+-            if (DIR_is_hidden_file( attr->ObjectName ))
+-                info->FileAttributes |= FILE_ATTRIBUTE_HIDDEN;
 -        }
-         free( unix_name );
+         RtlFreeAnsiString( &unix_name );
      }
-     else WARN( "%s not found (%x)\n", debugstr_us(attr->ObjectName), status );
+     else WARN("%s not found (%x)\n", debugstr_us(attr->ObjectName), status );
+diff --git a/dlls/ntdll/ntdll_misc.h b/dlls/ntdll/ntdll_misc.h
+index aeed9b857c2..b1cb9aa6843 100644
+--- a/dlls/ntdll/ntdll_misc.h
++++ b/dlls/ntdll/ntdll_misc.h
+@@ -168,7 +168,7 @@ extern NTSTATUS fill_file_info( const struct stat *st, ULONG attr, void *ptr,
+                                 FILE_INFORMATION_CLASS class ) DECLSPEC_HIDDEN;
+ extern NTSTATUS server_get_unix_name( HANDLE handle, ANSI_STRING *unix_name ) DECLSPEC_HIDDEN;
+ extern void init_directories(void) DECLSPEC_HIDDEN;
+-extern BOOL DIR_is_hidden_file( const UNICODE_STRING *name ) DECLSPEC_HIDDEN;
++extern BOOL DIR_is_hidden_file( const char *name ) DECLSPEC_HIDDEN;
+ extern NTSTATUS DIR_unmount_device( HANDLE handle ) DECLSPEC_HIDDEN;
+ extern NTSTATUS DIR_get_unix_cwd( char **cwd ) DECLSPEC_HIDDEN;
+ extern unsigned int DIR_get_drives_info( struct drive_info info[MAX_DOS_DRIVES] ) DECLSPEC_HIDDEN;
 -- 
-2.27.0
+2.25.1
 
diff --git a/patches/ntdll-DOS_Attributes/0008-ntdll-Always-store-SAMBA_XATTR_DOS_ATTRIB-when-path-.patch b/patches/ntdll-DOS_Attributes/0008-ntdll-Always-store-SAMBA_XATTR_DOS_ATTRIB-when-path-.patch
index f87c79e8..a8116b97 100644
--- a/patches/ntdll-DOS_Attributes/0008-ntdll-Always-store-SAMBA_XATTR_DOS_ATTRIB-when-path-.patch
+++ b/patches/ntdll-DOS_Attributes/0008-ntdll-Always-store-SAMBA_XATTR_DOS_ATTRIB-when-path-.patch
@@ -1,23 +1,23 @@
-From dd02380fff84cbef2a6df7b6f82b271e0e9d732f Mon Sep 17 00:00:00 2001
+From 08ece1e8da040d80c13348c2ffeb56052779dc53 Mon Sep 17 00:00:00 2001
 From: Sebastian Lackner <sebastian@fds-team.de>
 Date: Thu, 14 Jan 2016 23:09:19 +0100
 Subject: [PATCH] ntdll: Always store SAMBA_XATTR_DOS_ATTRIB when path could be
  interpreted as hidden.
 
 ---
- dlls/ntdll/unix/file.c | 13 ++++++++-----
+ dlls/ntdll/file.c | 13 ++++++++-----
  1 file changed, 8 insertions(+), 5 deletions(-)
 
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index c6b4928bd53..3bf82b1d45d 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -1567,12 +1567,15 @@ static int get_file_info( const char *path, struct stat *st, ULONG *attr )
-         free( parent_path );
+diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
+index a0e54c27198..61b417ef678 100644
+--- a/dlls/ntdll/file.c
++++ b/dlls/ntdll/file.c
+@@ -250,12 +250,15 @@ int get_file_info( const char *path, struct stat *st, ULONG *attr )
+         RtlFreeHeap( GetProcessHeap(), 0, parent_path );
      }
      *attr |= get_file_attributes( st );
 -    /* convert Unix-style hidden files to a DOS hidden file attribute */
--    if (is_hidden_file( path ))
+-    if (DIR_is_hidden_file( path ))
 -        *attr |= FILE_ATTRIBUTE_HIDDEN;
      /* retrieve any stored DOS attributes */
      len = xattr_get( path, SAMBA_XATTR_DOS_ATTRIB, hexattr, sizeof(hexattr)-1 );
@@ -25,22 +25,22 @@ index c6b4928bd53..3bf82b1d45d 100644
 +    if (len == -1)
 +    {
 +        /* convert Unix-style hidden files to a DOS hidden file attribute */
-+        if (is_hidden_file( path ))
++        if (DIR_is_hidden_file( path ))
 +            *attr |= FILE_ATTRIBUTE_HIDDEN;
 +        return ret;
 +    }
      *attr |= get_file_xattr( hexattr, len );
      return ret;
  }
-@@ -3556,7 +3559,7 @@ NTSTATUS set_file_info( const char *path, ULONG attr )
+@@ -268,7 +271,7 @@ NTSTATUS set_file_info( const char *path, ULONG attr )
      /* Note: unix mode already set when called this way */
      attr &= ~FILE_ATTRIBUTE_NORMAL; /* do not store everything, but keep everything Samba can use */
      len = sprintf( hexattr, "0x%x", attr );
 -    if (attr != 0)
-+    if (attr != 0 || is_hidden_file( path ))
++    if (attr != 0 || DIR_is_hidden_file( path ))
          xattr_set( path, SAMBA_XATTR_DOS_ATTRIB, hexattr, len );
      else
          xattr_remove( path, SAMBA_XATTR_DOS_ATTRIB );
 -- 
-2.27.0
+2.25.1
 
diff --git a/patches/ntdll-DOS_Attributes/definition b/patches/ntdll-DOS_Attributes/definition
index 7a1a3aeb..274963b7 100644
--- a/patches/ntdll-DOS_Attributes/definition
+++ b/patches/ntdll-DOS_Attributes/definition
@@ -1,3 +1,4 @@
 Fixes: [9158] Support for DOS hidden/system file attributes
 Fixes: [15679] cygwin symlinks not working in wine
 # Depends: ntdll-Syscall_Wrappers
+Depends: ntdll-Junction_Points
diff --git a/patches/ntdll-Dealloc_Thread_Stack/0001-ntdll-Do-not-allow-to-allocate-thread-stack-for-curr.patch b/patches/ntdll-Dealloc_Thread_Stack/0001-ntdll-Do-not-allow-to-allocate-thread-stack-for-curr.patch
index d5d9705c..55dd42cd 100644
--- a/patches/ntdll-Dealloc_Thread_Stack/0001-ntdll-Do-not-allow-to-allocate-thread-stack-for-curr.patch
+++ b/patches/ntdll-Dealloc_Thread_Stack/0001-ntdll-Do-not-allow-to-allocate-thread-stack-for-curr.patch
@@ -1,40 +1,40 @@
-From 1d56beba1aeb7acb135db5333c2f61f40988b23f Mon Sep 17 00:00:00 2001
+From a01aaa21d4709e52a01198167b49c9519090a4e3 Mon Sep 17 00:00:00 2001
 From: Sebastian Lackner <sebastian@fds-team.de>
 Date: Fri, 21 Aug 2015 06:39:47 +0800
 Subject: [PATCH] ntdll: Do not allow to deallocate thread stack for current
  thread.
 
 ---
- dlls/ntdll/unix/unix_private.h |  1 +
- dlls/ntdll/unix/virtual.c      | 12 ++++++++++++
+ dlls/ntdll/ntdll_misc.h |  1 +
+ dlls/ntdll/virtual.c    | 12 ++++++++++++
  2 files changed, 13 insertions(+)
 
-diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
-index 0714d9ff898..5ea9664edcf 100644
---- a/dlls/ntdll/unix/unix_private.h
-+++ b/dlls/ntdll/unix/unix_private.h
-@@ -58,6 +58,7 @@ struct ntdll_thread_data
-     int                reply_fd;      /* fd for receiving server replies */
+diff --git a/dlls/ntdll/ntdll_misc.h b/dlls/ntdll/ntdll_misc.h
+index f847503307b..2d037e0d7cb 100644
+--- a/dlls/ntdll/ntdll_misc.h
++++ b/dlls/ntdll/ntdll_misc.h
+@@ -240,6 +240,7 @@ struct ntdll_thread_data
      int                wait_fd[2];    /* fd for sleeping server requests */
+     BOOL               wow64_redir;   /* Wow64 filesystem redirection flag */
      pthread_t          pthread_id;    /* pthread thread id */
 +    void              *pthread_stack; /* pthread stack */
-     struct list        entry;         /* entry in TEB list */
-     PRTL_THREAD_START_ROUTINE start;  /* thread entry point */
-     void              *param;         /* thread entry point parameter */
-diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
-index 9b1ca761e9b..cb5db2891c6 100644
---- a/dlls/ntdll/unix/virtual.c
-+++ b/dlls/ntdll/unix/virtual.c
-@@ -2804,6 +2804,8 @@ NTSTATUS virtual_alloc_thread_stack( INITIAL_TEB *stack, SIZE_T reserve_size, SI
+ };
+ 
+ C_ASSERT( sizeof(struct ntdll_thread_data) <= sizeof(((TEB *)0)->GdiTebBatch) );
+diff --git a/dlls/ntdll/virtual.c b/dlls/ntdll/virtual.c
+index 5c12d87d297..f7bac9eac91 100644
+--- a/dlls/ntdll/virtual.c
++++ b/dlls/ntdll/virtual.c
+@@ -1986,6 +1986,8 @@ NTSTATUS virtual_alloc_thread_stack( INITIAL_TEB *stack, SIZE_T reserve_size, SI
      stack->DeallocationStack = view->base;
      stack->StackBase = (char *)view->base + view->size;
      stack->StackLimit = (char *)view->base + 2 * page_size;
 +    ((struct ntdll_thread_data *)&NtCurrentTeb()->GdiTebBatch)->pthread_stack = view->base;
 +
  done:
-     server_leave_uninterrupted_section( &virtual_mutex, &sigset );
+     server_leave_uninterrupted_section( &csVirtual, &sigset );
      return status;
-@@ -3594,6 +3596,16 @@ NTSTATUS WINAPI NtFreeVirtualMemory( HANDLE process, PVOID *addr_ptr, SIZE_T *si
+@@ -2703,6 +2705,16 @@ NTSTATUS WINAPI NtFreeVirtualMemory( HANDLE process, PVOID *addr_ptr, SIZE_T *si
          /* Free the pages */
  
          if (size || (base != view->base)) status = STATUS_INVALID_PARAMETER;
@@ -52,5 +52,5 @@ index 9b1ca761e9b..cb5db2891c6 100644
          {
              delete_view( view );
 -- 
-2.27.0
+2.26.2
 
diff --git a/patches/ntdll-DeviceType_Systemroot/0001-ntdll-Return-fake-device-type-when-systemroot-is-loc.patch b/patches/ntdll-DeviceType_Systemroot/0001-ntdll-Return-fake-device-type-when-systemroot-is-loc.patch
new file mode 100644
index 00000000..839ac7a7
--- /dev/null
+++ b/patches/ntdll-DeviceType_Systemroot/0001-ntdll-Return-fake-device-type-when-systemroot-is-loc.patch
@@ -0,0 +1,54 @@
+From 28b58832717d9c6a8032a555b0fb1035ac9fd710 Mon Sep 17 00:00:00 2001
+From: Sebastian Lackner <sebastian@fds-team.de>
+Date: Fri, 29 May 2015 19:57:22 +0200
+Subject: ntdll: Return fake device type when systemroot is located on virtual
+ disk.
+
+---
+ dlls/ntdll/file.c | 27 +++++++++++++++++++++++++++
+ 1 file changed, 27 insertions(+)
+
+diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
+index d081750..45b61fb 100644
+--- a/dlls/ntdll/file.c
++++ b/dlls/ntdll/file.c
+@@ -3126,9 +3126,36 @@ NTSTATUS WINAPI NtQueryVolumeInformationFile( HANDLE handle, PIO_STATUS_BLOCK io
+         else
+         {
+             FILE_FS_DEVICE_INFORMATION *info = buffer;
++            ANSI_STRING unix_name;
+ 
+             if ((io->u.Status = get_device_info( fd, info )) == STATUS_SUCCESS)
++            {
+                 io->Information = sizeof(*info);
++
++                /* Some MSI installers complain when the SystemRoot is located
++                 * on a virtual disk. Fake return values for compatibility. */
++                if (info->DeviceType == FILE_DEVICE_VIRTUAL_DISK &&
++                    user_shared_data->NtSystemRoot[1] == ':' &&
++                    !server_get_unix_name( handle, &unix_name ))
++                {
++                    UNICODE_STRING nt_name;
++                    if (!wine_unix_to_nt_file_name( &unix_name, &nt_name ))
++                    {
++                        WCHAR *buf = nt_name.Buffer;
++                        if (nt_name.Length >= 6 * sizeof(WCHAR) &&
++                            buf[0] == '\\' && buf[1] == '?' && buf[2] == '?' && buf[3] == '\\' &&
++                            buf[4] == user_shared_data->NtSystemRoot[0] && buf[5] == ':')
++                        {
++                            WARN( "returning fake disk type for %s\n",
++                                  debugstr_wn(buf, nt_name.Length/sizeof(WCHAR)) );
++                            info->DeviceType = FILE_DEVICE_DISK_FILE_SYSTEM;
++                        }
++                        RtlFreeUnicodeString( &nt_name );
++                    }
++                    RtlFreeAnsiString( &unix_name );
++                }
++
++            }
+         }
+         break;
+     case FileFsAttributeInformation:
+-- 
+2.4.2
+
diff --git a/patches/ntdll-DeviceType_Systemroot/definition b/patches/ntdll-DeviceType_Systemroot/definition
new file mode 100644
index 00000000..d7368f66
--- /dev/null
+++ b/patches/ntdll-DeviceType_Systemroot/definition
@@ -0,0 +1 @@
+Fixes: [36546] Return fake device type when systemroot is located on virtual disk
diff --git a/patches/ntdll-Exception/0002-ntdll-OutputDebugString-should-throw-the-exception-a.patch b/patches/ntdll-Exception/0002-ntdll-OutputDebugString-should-throw-the-exception-a.patch
index 63d4a62a..67e33891 100644
--- a/patches/ntdll-Exception/0002-ntdll-OutputDebugString-should-throw-the-exception-a.patch
+++ b/patches/ntdll-Exception/0002-ntdll-OutputDebugString-should-throw-the-exception-a.patch
@@ -1,19 +1,19 @@
-From 5345a66f9403133fc7cdd9ec8273c7bb3d19020d Mon Sep 17 00:00:00 2001
+From bf3b9244f374b9926db04b63b29f77139280b44a Mon Sep 17 00:00:00 2001
 From: Sebastian Lackner <sebastian@fds-team.de>
 Date: Sun, 28 Sep 2014 23:39:51 +0200
-Subject: [PATCH] ntdll: OutputDebugString should throw the exception a second
- time, if a debugger is attached.
+Subject: ntdll: OutputDebugString should throw the exception a second time, if
+ a debugger is attached.
 
 ---
  dlls/kernelbase/debug.c      | 17 +++++++++++++++++
- dlls/ntdll/tests/exception.c |  9 ++++-----
- 2 files changed, 21 insertions(+), 5 deletions(-)
+ dlls/ntdll/tests/exception.c | 11 +++++------
+ 2 files changed, 22 insertions(+), 6 deletions(-)
 
 diff --git a/dlls/kernelbase/debug.c b/dlls/kernelbase/debug.c
-index 6acdf0f1ea9..edb95eace3f 100644
+index 016c21109..a3d14d340 100644
 --- a/dlls/kernelbase/debug.c
 +++ b/dlls/kernelbase/debug.c
-@@ -213,6 +213,23 @@ void WINAPI DECLSPEC_HOTPATCH OutputDebugStringA( LPCSTR str )
+@@ -210,6 +210,23 @@ void WINAPI DECLSPEC_HOTPATCH OutputDebugStringA( LPCSTR str )
      __ENDTRY
      if (caught_by_dbg) return;
  
@@ -38,10 +38,10 @@ index 6acdf0f1ea9..edb95eace3f 100644
      if (!mutex_inited)
      {
 diff --git a/dlls/ntdll/tests/exception.c b/dlls/ntdll/tests/exception.c
-index 7ee191469ec..561ccf966d9 100644
+index 0a9dae138..b7b0f0e70 100644
 --- a/dlls/ntdll/tests/exception.c
 +++ b/dlls/ntdll/tests/exception.c
-@@ -4532,7 +4532,7 @@ static LONG CALLBACK outputdebugstring_vectored_handler(EXCEPTION_POINTERS *Exce
+@@ -2751,7 +2751,7 @@ static LONG CALLBACK outputdebugstring_vectored_handler(EXCEPTION_POINTERS *Exce
      return EXCEPTION_CONTINUE_SEARCH;
  }
  
@@ -50,7 +50,7 @@ index 7ee191469ec..561ccf966d9 100644
  {
      PVOID vectored_handler;
  
-@@ -4548,7 +4548,6 @@ static void test_outputdebugstring(DWORD numexc, BOOL todo)
+@@ -2767,7 +2767,6 @@ static void test_outputdebugstring(DWORD numexc, BOOL todo)
      outputdebugstring_exceptions = 0;
      OutputDebugStringA("Hello World");
  
@@ -58,27 +58,36 @@ index 7ee191469ec..561ccf966d9 100644
      ok(outputdebugstring_exceptions == numexc, "OutputDebugStringA generated %d exceptions, expected %d\n",
         outputdebugstring_exceptions, numexc);
  
-@@ -5148,9 +5147,9 @@ START_TEST(exception)
-         else skip( "RtlRaiseException not found\n" );
- #endif
-         test_stage = 3;
--        test_outputdebugstring(0, FALSE);
-+        test_outputdebugstring(0);
-         test_stage = 4;
--        test_outputdebugstring(2, TRUE); /* is this a Windows bug? */
-+        test_outputdebugstring(2);
-         test_stage = 5;
-         test_ripevent(0);
-         test_stage = 6;
-@@ -5226,7 +5225,7 @@ START_TEST(exception)
+@@ -3448,9 +3447,9 @@ START_TEST(exception)
+             run_rtlraiseexception_test(EXCEPTION_BREAKPOINT);
+             run_rtlraiseexception_test(EXCEPTION_INVALID_HANDLE);
+             test_stage = 3;
+-            test_outputdebugstring(0, FALSE);
++            test_outputdebugstring(0);
+             test_stage = 4;
+-            test_outputdebugstring(2, TRUE); /* is this a Windows bug? */
++            test_outputdebugstring(2);
+             test_stage = 5;
+             test_ripevent(0);
+             test_stage = 6;
+@@ -3481,7 +3480,7 @@ START_TEST(exception)
+     test_exceptions();
+     test_rtlraiseexception();
+     test_debug_registers();
+-    test_outputdebugstring(1, FALSE);
++    test_outputdebugstring(1);
+     test_ripevent(1);
+     test_debug_service(1);
+     test_breakpoint(1);
+@@ -3519,7 +3518,7 @@ START_TEST(exception)
+                                                                  "_setjmp" );
  
-     test_debugger();
-     test_thread_context();
+     test_debug_registers();
 -    test_outputdebugstring(1, FALSE);
 +    test_outputdebugstring(1);
      test_ripevent(1);
+     test_debug_service(1);
      test_breakpoint(1);
-     test_closehandle(0, (HANDLE)0xdeadbeef);
 -- 
-2.27.0
+2.23.0
 
diff --git a/patches/ntdll-FLS_Callbacks/0001-kernelbase-Maintain-FLS-storage-list-in-PEB.patch b/patches/ntdll-FLS_Callbacks/0001-kernelbase-Maintain-FLS-storage-list-in-PEB.patch
index 52878a9c..6f439f70 100644
--- a/patches/ntdll-FLS_Callbacks/0001-kernelbase-Maintain-FLS-storage-list-in-PEB.patch
+++ b/patches/ntdll-FLS_Callbacks/0001-kernelbase-Maintain-FLS-storage-list-in-PEB.patch
@@ -1,4 +1,4 @@
-From b0225150b6721f7c75124c534b8841aa1a8039bd Mon Sep 17 00:00:00 2001
+From 96a5e54b5f72d99a9c3d03ac4c5800fe324e44c0 Mon Sep 17 00:00:00 2001
 From: Paul Gofman <pgofman@codeweavers.com>
 Date: Thu, 23 Apr 2020 14:32:23 +0300
 Subject: [PATCH] kernelbase: Maintain FLS storage list in PEB.
@@ -73,10 +73,10 @@ index 7501165dc87..2bcc3ee60c4 100644
       * FlsFree should fail
       * FlsGetValue and FlsSetValue should succeed
 diff --git a/dlls/kernel32/tests/thread.c b/dlls/kernel32/tests/thread.c
-index bd9fe7fecef..79e2736bd9e 100644
+index b91d279e327..924f19703bf 100644
 --- a/dlls/kernel32/tests/thread.c
 +++ b/dlls/kernel32/tests/thread.c
-@@ -2483,7 +2483,6 @@ START_TEST(thread)
+@@ -2445,7 +2445,6 @@ START_TEST(thread)
         }
         return;
     }
@@ -84,7 +84,7 @@ index bd9fe7fecef..79e2736bd9e 100644
     test_thread_info();
     test_reserved_tls();
     test_CreateRemoteThread();
-@@ -2511,6 +2510,5 @@ START_TEST(thread)
+@@ -2473,6 +2472,5 @@ START_TEST(thread)
     test_thread_fpu_cw();
     test_thread_actctx();
     test_thread_description();
@@ -233,12 +233,12 @@ index f44f2ff6538..3423fe8c727 100644
  }
  
 diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
-index d3ade9555b3..84811217474 100644
+index b884b43b154..c0a18669590 100644
 --- a/dlls/ntdll/loader.c
 +++ b/dlls/ntdll/loader.c
-@@ -168,6 +168,15 @@ static RTL_BITMAP tls_bitmap;
- static RTL_BITMAP tls_expansion_bitmap;
- static RTL_BITMAP fls_bitmap;
+@@ -153,6 +153,15 @@ static CRITICAL_SECTION_DEBUG dlldir_critsect_debug =
+ };
+ static CRITICAL_SECTION dlldir_section = { &dlldir_critsect_debug, -1, 0, 0, 0, 0 };
  
 +static CRITICAL_SECTION fls_section;
 +static CRITICAL_SECTION_DEBUG fls_critsect_debug =
@@ -252,7 +252,7 @@ index d3ade9555b3..84811217474 100644
  static WINE_MODREF *cached_modref;
  static WINE_MODREF *current_modref;
  static WINE_MODREF *last_failed_modref;
-@@ -208,6 +217,16 @@ static RTL_UNLOAD_EVENT_TRACE unload_traces[RTL_UNLOAD_EVENT_TRACE_NUMBER];
+@@ -193,6 +202,16 @@ static RTL_UNLOAD_EVENT_TRACE unload_traces[RTL_UNLOAD_EVENT_TRACE_NUMBER];
  static RTL_UNLOAD_EVENT_TRACE *unload_trace_ptr;
  static unsigned int unload_trace_seq;
  
@@ -269,7 +269,7 @@ index d3ade9555b3..84811217474 100644
  static void module_push_unload_trace( const LDR_DATA_TABLE_ENTRY *ldr )
  {
      RTL_UNLOAD_EVENT_TRACE *ptr = &unload_traces[unload_trace_seq];
-@@ -3203,6 +3222,13 @@ void WINAPI LdrShutdownThread(void)
+@@ -3187,6 +3206,13 @@ void WINAPI LdrShutdownThread(void)
      /* don't do any detach calls if process is exiting */
      if (process_detaching) return;
  
@@ -283,15 +283,15 @@ index d3ade9555b3..84811217474 100644
      RtlEnterCriticalSection( &loader_section );
      wm = get_modref( NtCurrentTeb()->Peb->ImageBaseAddress );
  
-@@ -3416,6 +3442,7 @@ PIMAGE_NT_HEADERS WINAPI RtlImageNtHeader(HMODULE hModule)
+@@ -3400,6 +3426,7 @@ PIMAGE_NT_HEADERS WINAPI RtlImageNtHeader(HMODULE hModule)
   */
- void WINAPI LdrInitializeThunk( CONTEXT *context, ULONG_PTR unknown2, ULONG_PTR unknown3, ULONG_PTR unknown4 )
+ void WINAPI LdrInitializeThunk( CONTEXT *context, void **entry, ULONG_PTR unknown3, ULONG_PTR unknown4 )
  {
 +    static const unsigned int fls_slot_count = 8 * sizeof(NtCurrentTeb()->Peb->FlsBitmapBits);
+     static const LARGE_INTEGER zero;
      static int attach_done;
      int i;
-     NTSTATUS status;
-@@ -3466,6 +3493,25 @@ void WINAPI LdrInitializeThunk( CONTEXT *context, ULONG_PTR unknown2, ULONG_PTR
+@@ -3435,6 +3462,25 @@ void WINAPI LdrInitializeThunk( CONTEXT *context, void **entry, ULONG_PTR unknow
      InsertHeadList( &tls_links, &NtCurrentTeb()->TlsLinks );
      RtlReleasePebLock();
  
@@ -318,5 +318,5 @@ index d3ade9555b3..84811217474 100644
      {
          attach_done = 1;
 -- 
-2.28.0
+2.27.0
 
diff --git a/patches/ntdll-FileDispositionInformation/definition b/patches/ntdll-FileDispositionInformation/definition
index 6db46c84..b139e548 100644
--- a/patches/ntdll-FileDispositionInformation/definition
+++ b/patches/ntdll-FileDispositionInformation/definition
@@ -1,3 +1,4 @@
 # Fixes: [30397] Support for NtSetInformationFile class FileDispositionInformation
 # Fixes: [30399] Support for NtSetInformationFile class FileRenameInformation
 # Fixes: Support for NtSetInformationFile class FileLinkInformation
+Depends: server-File_Permissions
diff --git a/patches/ntdll-FileFsFullSizeInformation/0001-ntdll-Add-support-for-FileFsFullSizeInformation-clas.patch b/patches/ntdll-FileFsFullSizeInformation/0001-ntdll-Add-support-for-FileFsFullSizeInformation-clas.patch
index 3b4e6f7b..1cdd0f73 100644
--- a/patches/ntdll-FileFsFullSizeInformation/0001-ntdll-Add-support-for-FileFsFullSizeInformation-clas.patch
+++ b/patches/ntdll-FileFsFullSizeInformation/0001-ntdll-Add-support-for-FileFsFullSizeInformation-clas.patch
@@ -1,58 +1,21 @@
-From f4f37eddd1eb809cf491ae3a0029f3850021d69d Mon Sep 17 00:00:00 2001
+From 8cdd24c7d9aa7a007ffe437efc8d22f4413e4187 Mon Sep 17 00:00:00 2001
 From: Jianqiu Zhang <zhangjianqiu_133@yeah.net>
 Date: Fri, 17 Apr 2015 14:33:41 +0800
-Subject: [PATCH] ntdll: Add support for FileFsFullSizeInformation class in
+Subject: ntdll: Add support for FileFsFullSizeInformation class in
  NtQueryVolumeInformationFile(try 2)
 
 ---
- dlls/ntdll/tests/file.c |  8 +-----
- dlls/ntdll/unix/file.c  | 54 ++++++++++++++++++++++++++++++++++++++++-
+ dlls/ntdll/file.c       | 54 ++++++++++++++++++++++++++++++++++++++++++++++++-
+ dlls/ntdll/tests/file.c |  8 +-------
  2 files changed, 54 insertions(+), 8 deletions(-)
 
-diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
-index 184b7cdad59..2ef8b451457 100644
---- a/dlls/ntdll/tests/file.c
-+++ b/dlls/ntdll/tests/file.c
-@@ -1265,7 +1265,7 @@ static void test_file_full_size_information(void)
- 
-     /* Assume No Quota Settings configured on Wine Testbot */
-     res = pNtQueryVolumeInformationFile(h, &io, &ffsi, sizeof ffsi, FileFsFullSizeInformation);
--    todo_wine ok(res == STATUS_SUCCESS, "cannot get attributes, res %x\n", res);
-+    ok(res == STATUS_SUCCESS, "cannot get attributes, res %x\n", res);
-     res = pNtQueryVolumeInformationFile(h, &io, &fsi, sizeof fsi, FileFsSizeInformation);
-     ok(res == STATUS_SUCCESS, "cannot get attributes, res %x\n", res);
- 
-@@ -1281,8 +1281,6 @@ static void test_file_full_size_information(void)
-     ok(fsi.BytesPerSector == 512, "[fsi] BytesPerSector expected 512, got %d\n",fsi.BytesPerSector);
-     ok(fsi.SectorsPerAllocationUnit == 8, "[fsi] SectorsPerAllocationUnit expected 8, got %d\n",fsi.SectorsPerAllocationUnit);
- 
--    todo_wine
--    {
-     ok(ffsi.TotalAllocationUnits.QuadPart > 0,
-         "[ffsi] TotalAllocationUnits expected positive, got negative value 0x%s\n",
-         wine_dbgstr_longlong(ffsi.TotalAllocationUnits.QuadPart));
-@@ -1300,14 +1298,10 @@ static void test_file_full_size_information(void)
-         "[ffsi] CallerAvailableAllocationUnits error fsi:0x%s, ffsi: 0x%s\n",
-         wine_dbgstr_longlong(fsi.AvailableAllocationUnits.QuadPart),
-         wine_dbgstr_longlong(ffsi.CallerAvailableAllocationUnits.QuadPart));
--    }
- 
-     /* Assume file system is NTFS */
--    todo_wine
--    {
-     ok(ffsi.BytesPerSector == 512, "[ffsi] BytesPerSector expected 512, got %d\n",ffsi.BytesPerSector);
-     ok(ffsi.SectorsPerAllocationUnit == 8, "[ffsi] SectorsPerAllocationUnit expected 8, got %d\n",ffsi.SectorsPerAllocationUnit);
--    }
- 
-     CloseHandle( h );
- }
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index ca6899b50f5..389470804ee 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -6271,7 +6271,59 @@ NTSTATUS WINAPI NtQueryVolumeInformationFile( HANDLE handle, IO_STATUS_BLOCK *io
+diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
+index 1cb34d3545d..0785e482be1 100644
+--- a/dlls/ntdll/file.c
++++ b/dlls/ntdll/file.c
+@@ -3374,7 +3374,59 @@ NTSTATUS WINAPI NtQueryVolumeInformationFile( HANDLE handle, PIO_STATUS_BLOCK io
+         FIXME( "%p: control info not supported\n", handle );
          break;
- 
      case FileFsFullSizeInformation:
 -        FIXME( "%p: full size info not supported\n", handle );
 +        if(length < sizeof(FILE_FS_FULL_SIZE_INFORMATION))
@@ -63,7 +26,7 @@ index ca6899b50f5..389470804ee 100644
 +
 +            if (fstat( fd, &st ) < 0)
 +            {
-+                io->u.Status = errno_to_status( errno );
++                io->u.Status = FILE_GetNtStatus();
 +                break;
 +            }
 +            if(!S_ISREG(st.st_mode) && !S_ISDIR(st.st_mode))
@@ -78,7 +41,7 @@ index ca6899b50f5..389470804ee 100644
 +
 +                if(fstatvfs( fd, &stfs ) < 0)
 +                {
-+                    io->u.Status = errno_to_status( errno );
++                    io->u.Status = FILE_GetNtStatus();
 +                    break;
 +                }
 +                bsize = stfs.f_frsize;
@@ -86,7 +49,7 @@ index ca6899b50f5..389470804ee 100644
 +                struct statfs stfs;
 +                if(fstatfs( fd, &stfs ) < 0)
 +                {
-+                    io->u.Status = errno_to_status( errno );
++                    io->u.Status = FILE_GetNtStatus();
 +                    break;
 +                }
 +                bsize = stfs.f_bsize;
@@ -109,8 +72,45 @@ index ca6899b50f5..389470804ee 100644
 +            }
 +        }
          break;
- 
      case FileFsObjectIdInformation:
+         FIXME( "%p: object id info not supported\n", handle );
+diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
+index 18b0e5d3921..aa0d8a47f5a 100644
+--- a/dlls/ntdll/tests/file.c
++++ b/dlls/ntdll/tests/file.c
+@@ -1117,7 +1117,7 @@ static void test_file_full_size_information(void)
+ 
+     /* Assume No Quota Settings configured on Wine Testbot */
+     res = pNtQueryVolumeInformationFile(h, &io, &ffsi, sizeof ffsi, FileFsFullSizeInformation);
+-    todo_wine ok(res == STATUS_SUCCESS, "cannot get attributes, res %x\n", res);
++    ok(res == STATUS_SUCCESS, "cannot get attributes, res %x\n", res);
+     res = pNtQueryVolumeInformationFile(h, &io, &fsi, sizeof fsi, FileFsSizeInformation);
+     ok(res == STATUS_SUCCESS, "cannot get attributes, res %x\n", res);
+ 
+@@ -1133,8 +1133,6 @@ static void test_file_full_size_information(void)
+     ok(fsi.BytesPerSector == 512, "[fsi] BytesPerSector expected 512, got %d\n",fsi.BytesPerSector);
+     ok(fsi.SectorsPerAllocationUnit == 8, "[fsi] SectorsPerAllocationUnit expected 8, got %d\n",fsi.SectorsPerAllocationUnit);
+ 
+-    todo_wine
+-    {
+     ok(ffsi.TotalAllocationUnits.QuadPart > 0,
+         "[ffsi] TotalAllocationUnits expected positive, got negative value 0x%s\n",
+         wine_dbgstr_longlong(ffsi.TotalAllocationUnits.QuadPart));
+@@ -1152,14 +1150,10 @@ static void test_file_full_size_information(void)
+         "[ffsi] CallerAvailableAllocationUnits error fsi:0x%s, ffsi: 0x%s\n",
+         wine_dbgstr_longlong(fsi.AvailableAllocationUnits.QuadPart),
+         wine_dbgstr_longlong(ffsi.CallerAvailableAllocationUnits.QuadPart));
+-    }
+ 
+     /* Assume file system is NTFS */
+-    todo_wine
+-    {
+     ok(ffsi.BytesPerSector == 512, "[ffsi] BytesPerSector expected 512, got %d\n",ffsi.BytesPerSector);
+     ok(ffsi.SectorsPerAllocationUnit == 8, "[ffsi] SectorsPerAllocationUnit expected 8, got %d\n",ffsi.SectorsPerAllocationUnit);
+-    }
+ 
+     CloseHandle( h );
+ }
 -- 
-2.27.0
+2.13.1
 
diff --git a/patches/ntdll-Fix_Alignment/0001-ntdll-Move-NtProtectVirtualMemory-and-NtCreateSectio.patch b/patches/ntdll-Fix_Alignment/0001-ntdll-Move-NtProtectVirtualMemory-and-NtCreateSectio.patch
index f62b97a0..eedde034 100644
--- a/patches/ntdll-Fix_Alignment/0001-ntdll-Move-NtProtectVirtualMemory-and-NtCreateSectio.patch
+++ b/patches/ntdll-Fix_Alignment/0001-ntdll-Move-NtProtectVirtualMemory-and-NtCreateSectio.patch
@@ -1,20 +1,20 @@
-From 9a7a3037b16670d121465036e7da2c4db6f18182 Mon Sep 17 00:00:00 2001
+From 89a4ee827b74d8e4d63ca3e1354d89d75cc0fc19 Mon Sep 17 00:00:00 2001
 From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
 Date: Wed, 20 Aug 2014 19:21:18 +0200
-Subject: [PATCH] ntdll: Move NtProtectVirtualMemory and NtCreateSection to
- separate pages on x86. (try 2)
+Subject: ntdll: Move NtProtectVirtualMemory and NtCreateSection to separate
+ pages on x86. (try 2)
 
 ---
- dlls/ntdll/unix/virtual.c | 8 ++++++++
+ dlls/ntdll/virtual.c | 8 ++++++++
  1 file changed, 8 insertions(+)
 
-diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
-index 0346d0d9753..ab321a989dd 100644
---- a/dlls/ntdll/unix/virtual.c
-+++ b/dlls/ntdll/unix/virtual.c
-@@ -660,6 +660,14 @@ static void free_ranges_remove_view( struct file_view *view )
- }
- 
+diff --git a/dlls/ntdll/virtual.c b/dlls/ntdll/virtual.c
+index ce2469829b0..eb2dbe8a2cd 100644
+--- a/dlls/ntdll/virtual.c
++++ b/dlls/ntdll/virtual.c
+@@ -168,6 +168,14 @@ static void *preload_reserve_end;
+ static BOOL use_locks;
+ static BOOL force_exec_prot;  /* whether to force PROT_EXEC on all PROT_READ mmaps */
  
 +#if defined(__i386__)
 +NTSTATUS WINAPI NtProtectVirtualMemory( HANDLE process, PVOID *addr_ptr, SIZE_T *size_ptr,
diff --git a/patches/ntdll-ForceBottomUpAlloc/0001-ntdll-Stop-search-on-mmap-error-in-try_map_free_area.patch b/patches/ntdll-ForceBottomUpAlloc/0001-ntdll-Stop-search-on-mmap-error-in-try_map_free_area.patch
new file mode 100644
index 00000000..579f6562
--- /dev/null
+++ b/patches/ntdll-ForceBottomUpAlloc/0001-ntdll-Stop-search-on-mmap-error-in-try_map_free_area.patch
@@ -0,0 +1,35 @@
+From 980ca40adb1f4d268b42f434c353dc461df19b49 Mon Sep 17 00:00:00 2001
+From: Paul Gofman <gofmanp@gmail.com>
+Date: Thu, 9 Jan 2020 15:05:09 +0300
+Subject: [PATCH] ntdll: Stop search on mmap() error in try_map_free_area().
+
+The anon mmap errors do not depend on start address hint. Ignoring them
+makes the search take incredible time until it fails.
+---
+ dlls/ntdll/unix/virtual.c | 10 ++++++++--
+ 1 file changed, 8 insertions(+), 2 deletions(-)
+
+diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
+index 04889113c339..088e73b17b34 100644
+--- a/dlls/ntdll/unix/virtual.c
++++ b/dlls/ntdll/unix/virtual.c
+@@ -1063,8 +1063,14 @@ static void* try_map_free_area( void *base, void *end, ptrdiff_t step,
+             return start;
+         TRACE( "Found free area is already mapped, start %p.\n", start );
+ 
+-        if (ptr != (void *)-1)
+-            munmap( ptr, size );
++        if (ptr == (void *)-1)
++        {
++            ERR("wine_anon_mmap() error %s, start %p, size %p, unix_prot %#x.\n",
++                    strerror(errno), start, (void *)size, unix_prot);
++            return NULL;
++        }
++
++        munmap( ptr, size );
+ 
+         if ((step > 0 && (char *)end - (char *)start < step) ||
+             (step < 0 && (char *)start - (char *)base < -step) ||
+-- 
+2.26.2
+
diff --git a/patches/ntdll-ForceBottomUpAlloc/0002-ntdll-Increase-free-ranges-view-block-size-on-64-bit.patch b/patches/ntdll-ForceBottomUpAlloc/0002-ntdll-Increase-free-ranges-view-block-size-on-64-bit.patch
deleted file mode 100644
index 326980d2..00000000
--- a/patches/ntdll-ForceBottomUpAlloc/0002-ntdll-Increase-free-ranges-view-block-size-on-64-bit.patch
+++ /dev/null
@@ -1,29 +0,0 @@
-From 01730a2261a59a2826a652360b69dd3c74917fa6 Mon Sep 17 00:00:00 2001
-From: Paul Gofman <pgofman@codeweavers.com>
-Date: Thu, 23 Jul 2020 18:40:39 +0300
-Subject: [PATCH] ntdll: Increase free ranges view block size on 64 bit.
-
-Signed-off-by: Paul Gofman <pgofman@codeweavers.com>
----
- dlls/ntdll/unix/virtual.c | 4 ++++
- 1 file changed, 4 insertions(+)
-
-diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
-index f7eab895f58..54ad53ea088 100644
---- a/dlls/ntdll/unix/virtual.c
-+++ b/dlls/ntdll/unix/virtual.c
-@@ -183,7 +183,11 @@ static BYTE *pages_vprot;
- #endif
- 
- static struct file_view *view_block_start, *view_block_end, *next_free_view;
-+#ifdef _WIN64
-+static const size_t view_block_size = 0x200000;
-+#else
- static const size_t view_block_size = 0x100000;
-+#endif
- static void *preload_reserve_start;
- static void *preload_reserve_end;
- static BOOL force_exec_prot;  /* whether to force PROT_EXEC on all PROT_READ mmaps */
--- 
-2.28.0
-
diff --git a/patches/ntdll-ForceBottomUpAlloc/0002-ntdll-Use-MAP_FIXED_NOREPLACE-flag-in-try_map_free_a.patch b/patches/ntdll-ForceBottomUpAlloc/0002-ntdll-Use-MAP_FIXED_NOREPLACE-flag-in-try_map_free_a.patch
new file mode 100644
index 00000000..ac2fc4b5
--- /dev/null
+++ b/patches/ntdll-ForceBottomUpAlloc/0002-ntdll-Use-MAP_FIXED_NOREPLACE-flag-in-try_map_free_a.patch
@@ -0,0 +1,51 @@
+From 1aa1c57302aef175849799185f324e461161f9eb Mon Sep 17 00:00:00 2001
+From: Paul Gofman <gofmanp@gmail.com>
+Date: Thu, 16 Jan 2020 16:09:24 +0300
+Subject: [PATCH] ntdll: Use MAP_FIXED_NOREPLACE flag in try_map_free_area() if
+ available.
+
+Avoids actual mapping followed by unmapping back if the memory range is
+already mapped.
+---
+ dlls/ntdll/unix/virtual.c | 12 +++++++++---
+ 1 file changed, 9 insertions(+), 3 deletions(-)
+
+diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
+index 088e73b17b34..3907b0db70a9 100644
+--- a/dlls/ntdll/unix/virtual.c
++++ b/dlls/ntdll/unix/virtual.c
+@@ -1055,22 +1055,28 @@ static struct wine_rb_entry *find_view_inside_range( void **base_ptr, void **end
+ static void* try_map_free_area( void *base, void *end, ptrdiff_t step,
+                                 void *start, size_t size, int unix_prot )
+ {
++#ifdef MAP_FIXED_NOREPLACE
++    static int flags = MAP_FIXED_NOREPLACE;
++#else
++    static int flags = 0;
++#endif
+     void *ptr;
+ 
+     while (start && base <= start && (char*)start + size <= (char*)end)
+     {
+-        if ((ptr = wine_anon_mmap( start, size, unix_prot, 0 )) == start)
++        if ((ptr = wine_anon_mmap( start, size, unix_prot, flags )) == start)
+             return start;
+         TRACE( "Found free area is already mapped, start %p.\n", start );
+ 
+-        if (ptr == (void *)-1)
++        if (ptr == (void *)-1 && errno != EEXIST)
+         {
+             ERR("wine_anon_mmap() error %s, start %p, size %p, unix_prot %#x.\n",
+                     strerror(errno), start, (void *)size, unix_prot);
+             return NULL;
+         }
+ 
+-        munmap( ptr, size );
++        if (ptr != (void *)-1)
++            munmap( ptr, size );
+ 
+         if ((step > 0 && (char *)end - (char *)start < step) ||
+             (step < 0 && (char *)start - (char *)base < -step) ||
+-- 
+2.26.2
+
diff --git a/patches/ntdll-ForceBottomUpAlloc/0003-ntdll-Force-bottom-up-allocation-order-for-64-bit-ar.patch b/patches/ntdll-ForceBottomUpAlloc/0003-ntdll-Force-bottom-up-allocation-order-for-64-bit-ar.patch
new file mode 100644
index 00000000..2fbdf31b
--- /dev/null
+++ b/patches/ntdll-ForceBottomUpAlloc/0003-ntdll-Force-bottom-up-allocation-order-for-64-bit-ar.patch
@@ -0,0 +1,58 @@
+From c9f4923096e5c6dcb1591355e3cdab63167448d4 Mon Sep 17 00:00:00 2001
+From: Paul Gofman <gofmanp@gmail.com>
+Date: Mon, 25 Nov 2019 12:19:20 +0300
+Subject: [PATCH] ntdll: Force bottom up allocation order for 64 bit arch
+ unless top down is requested.
+
+Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=48175
+Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=46568
+---
+ dlls/ntdll/unix/virtual.c | 12 ++++++++++--
+ 1 file changed, 10 insertions(+), 2 deletions(-)
+
+diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
+index 3907b0db70a9..4b8942b1b53b 100644
+--- a/dlls/ntdll/unix/virtual.c
++++ b/dlls/ntdll/unix/virtual.c
+@@ -1775,13 +1775,19 @@ static NTSTATUS map_view( struct file_view **view_ret, void *base, size_t size,
+     }
+     else
+     {
+-        size_t view_size = size + granularity_mask + 1;
+         struct alloc_area alloc;
++        size_t view_size;
+ 
+         alloc.size = size;
+         alloc.top_down = top_down;
+         alloc.limit = (void*)(get_zero_bits_64_mask( zero_bits_64 ) & (UINT_PTR)user_space_limit);
+ 
++        if (is_win64 && !top_down)
++        {
++            /* Ditch 0x7ffffe000000 - 0x7fffffff0000 reserved area. */
++            alloc.limit = min(alloc.limit, (void *)0x7ffffe000000);
++        }
++
+         if (mmap_enum_reserved_areas( alloc_reserved_area_callback, &alloc, top_down ))
+         {
+             ptr = alloc.result;
+@@ -1791,7 +1797,7 @@ static NTSTATUS map_view( struct file_view **view_ret, void *base, size_t size,
+             goto done;
+         }
+ 
+-        if (zero_bits_64)
++        if (is_win64 || zero_bits_64)
+         {
+             if (!(ptr = map_free_area( address_space_start, alloc.limit, size,
+                                        top_down, get_unix_prot(vprot) )))
+@@ -1800,6 +1806,8 @@ static NTSTATUS map_view( struct file_view **view_ret, void *base, size_t size,
+             goto done;
+         }
+ 
++        view_size = size + granularity_mask + 1;
++
+         for (;;)
+         {
+             if ((ptr = wine_anon_mmap( NULL, view_size, get_unix_prot(vprot), 0 )) == (void *)-1)
+-- 
+2.26.2
+
diff --git a/patches/ntdll-ForceBottomUpAlloc/0004-ntdll-Exclude-natively-mapped-areas-from-free-areas-.patch b/patches/ntdll-ForceBottomUpAlloc/0004-ntdll-Exclude-natively-mapped-areas-from-free-areas-.patch
deleted file mode 100644
index 3a6882ef..00000000
--- a/patches/ntdll-ForceBottomUpAlloc/0004-ntdll-Exclude-natively-mapped-areas-from-free-areas-.patch
+++ /dev/null
@@ -1,256 +0,0 @@
-From 479dfa05cc83b7ae8ab0f40862e74efedd98df48 Mon Sep 17 00:00:00 2001
-From: Paul Gofman <pgofman@codeweavers.com>
-Date: Tue, 2 Jun 2020 21:06:33 +0300
-Subject: [PATCH 4/4] ntdll: Exclude natively mapped areas from free areas
- list.
-
-Signed-off-by: Paul Gofman <pgofman@codeweavers.com>
----
- dlls/ntdll/unix/virtual.c | 130 ++++++++++++++++++++++++++++++--------
- 1 file changed, 103 insertions(+), 27 deletions(-)
-
-diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
-index e7dfc516538..dad12b5a9f2 100644
---- a/dlls/ntdll/unix/virtual.c
-+++ b/dlls/ntdll/unix/virtual.c
-@@ -103,6 +103,7 @@ struct file_view
- #define VPROT_WRITEWATCH 0x40
- /* per-mapping protection flags */
- #define VPROT_SYSTEM     0x0200  /* system view (underlying mmap not under our control) */
-+#define VPROT_NATIVE     0x0400
- 
- /* Conversion from VPROT_* to Win32 flags */
- static const BYTE VIRTUAL_Win32Flags[16] =
-@@ -877,7 +878,9 @@ static void dump_view( struct file_view *view )
-     BYTE prot = get_page_vprot( addr );
- 
-     TRACE( "View: %p - %p", addr, addr + view->size - 1 );
--    if (view->protect & VPROT_SYSTEM)
-+    if (view->protect & VPROT_NATIVE)
-+        TRACE(" (native)\n");
-+    else if (view->protect & VPROT_SYSTEM)
-         TRACE( " (builtin image)\n" );
-     else if (view->protect & SEC_IMAGE)
-         TRACE( " (image)\n" );
-@@ -1019,6 +1022,16 @@ static struct file_view *find_view_range( const void *addr, size_t size )
-     return NULL;
- }
- 
-+struct alloc_area
-+{
-+    char *map_area_start, *map_area_end, *result;
-+    size_t size;
-+    ptrdiff_t step;
-+    int unix_prot;
-+    BOOL top_down;
-+    char *native_mapped;
-+    size_t native_mapped_size;
-+};
- 
- /***********************************************************************
-  *           try_map_free_area
-@@ -1026,21 +1039,27 @@ static struct file_view *find_view_range( const void *addr, size_t size )
-  * Try mmaping some expected free memory region, eventually stepping and
-  * retrying inside it, and return where it actually succeeded, or NULL.
-  */
--static void* try_map_free_area( void *base, void *end, ptrdiff_t step,
--                                void *start, size_t size, int unix_prot )
-+static void* try_map_free_area( struct alloc_area *area, void *base, void *end, void *start )
- {
-+    ptrdiff_t step = area->step;
-     void *ptr;
- 
--    while (start && base <= start && (char*)start + size <= (char*)end)
-+    while (start && base <= start && (char*)start + area->size <= (char*)end)
-     {
--        if ((ptr = anon_mmap_tryfixed( start, size, unix_prot, 0 )) != MAP_FAILED) return start;
-+        if ((ptr = anon_mmap_tryfixed( start, area->size, area->unix_prot, 0 ))  != MAP_FAILED) return start;
-         TRACE( "Found free area is already mapped, start %p.\n", start );
-         if (errno != EEXIST)
-         {
-             ERR( "mmap() error %s, range %p-%p, unix_prot %#x.\n",
--                 strerror(errno), start, (char *)start + size, unix_prot );
-+                 strerror(errno), start, (char *)start + area->size, area->unix_prot );
-             return NULL;
-         }
-+        if (!area->native_mapped && step)
-+        {
-+            area->native_mapped = start;
-+            area->native_mapped_size = step > 0 ? step : -step;
-+            area->native_mapped_size = min(area->native_mapped_size, (char *)end - (char *)start);
-+        }
-         if ((step > 0 && (char *)end - (char *)start < step) ||
-             (step < 0 && (char *)start - (char *)base < -step) ||
-             step == 0)
-@@ -1502,15 +1521,6 @@ static inline void *unmap_extra_space( void *ptr, size_t total_size, size_t want
-     return ptr;
- }
- 
--struct alloc_area
--{
--    char *map_area_start, *map_area_end, *result;
--    size_t size;
--    ptrdiff_t step;
--    int unix_prot;
--    BOOL top_down;
--};
--
- static int CDECL alloc_area_in_reserved_or_between_callback( void *start, SIZE_T size, void *arg )
- {
-     char *intersect_start, *intersect_end;
-@@ -1536,8 +1546,8 @@ static int CDECL alloc_area_in_reserved_or_between_callback( void *start, SIZE_T
- 
-         if (alloc_start >= intersect_end)
-         {
--            if ((area->result = try_map_free_area( area->map_area_start, alloc_start + size, area->step,
--                    alloc_start, area->size, area->unix_prot )))
-+            if ((area->result = try_map_free_area( area, area->map_area_start,
-+                    alloc_start + size, alloc_start )))
-                 return 1;
-         }
- 
-@@ -1571,8 +1581,8 @@ static int CDECL alloc_area_in_reserved_or_between_callback( void *start, SIZE_T
- 
-         if (intersect_start - area->map_area_start >= area->size)
-         {
--            if ((area->result = try_map_free_area( area->map_area_start, intersect_start, area->step,
--                    area->map_area_start, area->size, area->unix_prot )))
-+            if ((area->result = try_map_free_area( area, area->map_area_start,
-+                    intersect_start, area->map_area_start )))
-                 return 1;
-         }
- 
-@@ -1627,8 +1637,7 @@ static void *alloc_free_area_in_range( struct alloc_area *area, char *base, char
-         if (start >= area->map_area_end || start < area->map_area_start)
-             return NULL;
- 
--        return try_map_free_area( area->map_area_start, start + area->size, area->step,
--                start, area->size, area->unix_prot );
-+        return try_map_free_area( area, area->map_area_start, start + area->size, start );
-     }
-     else
-     {
-@@ -1637,8 +1646,7 @@ static void *alloc_free_area_in_range( struct alloc_area *area, char *base, char
-                 || area->map_area_end - start < area->size)
-             return NULL;
- 
--        return try_map_free_area( start, area->map_area_end, area->step,
--                start, area->size, area->unix_prot );
-+        return try_map_free_area( area, start, area->map_area_end, start );
-     }
- }
- 
-@@ -1648,6 +1656,7 @@ static void *alloc_free_area( void *limit, size_t size, BOOL top_down, int unix_
-     char *reserve_start, *reserve_end;
-     struct alloc_area area;
-     char *base, *end;
-+    NTSTATUS status;
-     int ranges_inc;
- 
-     TRACE("limit %p, size %p, top_down %#x.\n", limit, (void *)size, top_down);
-@@ -1703,16 +1712,67 @@ static void *alloc_free_area( void *limit, size_t size, BOOL top_down, int unix_
-             {
-                 /* range is split in two by the preloader reservation, try first part. */
-                 if ((area.result = alloc_free_area_in_range( &area, base, reserve_start )))
--                    return area.result;
-+                    break;
-                 /* then fall through to try second part. */
-                 base = reserve_end;
-             }
-         }
- 
-         if ((area.result = alloc_free_area_in_range( &area, base, end )))
--            return area.result;
-+            break;
-     }
--    return NULL;
-+
-+    if (area.native_mapped)
-+    {
-+        char *native_mapped_start, *native_mapped_end;
-+
-+        TRACE("Excluding %p - %p from free list.\n",
-+                area.native_mapped, (char *)area.native_mapped + area.native_mapped_size );
-+
-+        native_mapped_start = ROUND_ADDR(area.native_mapped, granularity_mask);
-+        native_mapped_end = ROUND_ADDR((char *)area.native_mapped + area.native_mapped_size + granularity_mask,
-+                granularity_mask);
-+
-+        if (area.result >= native_mapped_end || area.result + size < native_mapped_start)
-+        /* In case of top down allocation try_map_free_area() result area can overlap the
-+         * area previously marked as native if the latter was unmapped behind our back. */
-+        {
-+            struct file_view *prev, *next;
-+
-+            prev = find_view_range( native_mapped_start - 1, native_mapped_end - native_mapped_start + 2 );
-+            if (prev && (char *)prev->base >= native_mapped_end)
-+            {
-+                next = prev;
-+                prev = WINE_RB_ENTRY_VALUE( wine_rb_prev( &next->entry ), struct file_view, entry );
-+            }
-+            else if (prev)
-+            {
-+                next = WINE_RB_ENTRY_VALUE( wine_rb_next( &prev->entry ), struct file_view, entry );
-+            }
-+            else
-+            {
-+                next = NULL;
-+            }
-+
-+            if (prev && prev->protect & VPROT_NATIVE && (char *)prev->base + prev->size >= native_mapped_start)
-+            {
-+                assert( (char *)prev->base + prev->size == native_mapped_start );
-+                native_mapped_start = prev->base;
-+                delete_view( prev );
-+            }
-+            if (next && next->protect & VPROT_NATIVE && native_mapped_end >= (char *)next->base)
-+            {
-+                assert( native_mapped_end == (char *)next->base );
-+                native_mapped_end = (char *)next->base + next->size;
-+                delete_view( next );
-+            }
-+            if ((status = create_view( &next, native_mapped_start, native_mapped_end - native_mapped_start,
-+                    VPROT_SYSTEM | VPROT_NATIVE )))
-+                ERR("Could not cretae view for natively mapped area, status %#x.\n", status);
-+        }
-+    }
-+
-+    return area.result;
- }
- 
- /***********************************************************************
-@@ -1766,6 +1826,17 @@ static NTSTATUS map_fixed_area( void *base, size_t size, unsigned int vprot )
-     return STATUS_SUCCESS;
- }
- 
-+static void clear_native_views(void)
-+{
-+    struct file_view *view, *next_view;
-+
-+    WINE_RB_FOR_EACH_ENTRY_DESTRUCTOR( view, next_view, &views_tree, struct file_view, entry )
-+    {
-+        if (view->protect & VPROT_NATIVE)
-+            delete_view( view );
-+    }
-+}
-+
- /***********************************************************************
-  *           map_view
-  *
-@@ -1789,7 +1860,12 @@ static NTSTATUS map_view( struct file_view **view_ret, void *base, size_t size,
-     else if (!(ptr = alloc_free_area( (void*)(get_zero_bits_64_mask( zero_bits_64 )
-             & (UINT_PTR)user_space_limit), size, top_down, get_unix_prot( vprot ) )))
-     {
--        return STATUS_NO_MEMORY;
-+        WARN("Allocation failed, clearing native views.\n");
-+
-+        clear_native_views();
-+        if (!(ptr = alloc_free_area( (void*)(get_zero_bits_64_mask( zero_bits_64 )
-+                & (UINT_PTR)user_space_limit), size, top_down, get_unix_prot( vprot ) )))
-+            return STATUS_NO_MEMORY;
-     }
-     status = create_view( view_ret, ptr, size, vprot );
-     if (status != STATUS_SUCCESS) unmap_area( ptr, size );
--- 
-2.26.2
-
diff --git a/patches/ntdll-ForceBottomUpAlloc/0001-ntdll-Increase-step-after-failed-map-attempt-in-try_.patch b/patches/ntdll-ForceBottomUpAlloc/0004-ntdll-Increase-step-after-failed-map-attempt-in-try_.patch
similarity index 56%
rename from patches/ntdll-ForceBottomUpAlloc/0001-ntdll-Increase-step-after-failed-map-attempt-in-try_.patch
rename to patches/ntdll-ForceBottomUpAlloc/0004-ntdll-Increase-step-after-failed-map-attempt-in-try_.patch
index 8abaf03e..241ebebf 100644
--- a/patches/ntdll-ForceBottomUpAlloc/0001-ntdll-Increase-step-after-failed-map-attempt-in-try_.patch
+++ b/patches/ntdll-ForceBottomUpAlloc/0004-ntdll-Increase-step-after-failed-map-attempt-in-try_.patch
@@ -1,19 +1,18 @@
-From ff02cbe4aea411563e0a9d22ed832acc2747d5b7 Mon Sep 17 00:00:00 2001
-From: Paul Gofman <pgofman@codeweavers.com>
+From 0e03dab87634938bf9b6462a3e7dce1def1289c9 Mon Sep 17 00:00:00 2001
+From: Paul Gofman <gofmanp@gmail.com>
 Date: Tue, 14 Jan 2020 21:39:23 +0300
-Subject: [PATCH 1/4] ntdll: Increase step after failed map attempt in
+Subject: [PATCH] ntdll: Increase step after failed map attempt in
  try_map_free_area().
 
-Signed-off-by: Paul Gofman <pgofman@codeweavers.com>
 ---
  dlls/ntdll/unix/virtual.c | 1 +
  1 file changed, 1 insertion(+)
 
 diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
-index b469e9df4a1..52915e07323 100644
+index 4b8942b1b53b..f4dba39cb160 100644
 --- a/dlls/ntdll/unix/virtual.c
 +++ b/dlls/ntdll/unix/virtual.c
-@@ -1080,6 +1080,7 @@ static void* try_map_free_area( void *base, void *end, ptrdiff_t step,
+@@ -1083,6 +1083,7 @@ static void* try_map_free_area( void *base, void *end, ptrdiff_t step,
              step == 0)
              break;
          start = (char *)start + step;
diff --git a/patches/ntdll-ForceBottomUpAlloc/0003-ntdll-Force-virtual-memory-allocation-order.patch b/patches/ntdll-ForceBottomUpAlloc/0005-ntdll-Use-free-area-list-for-virtual-memory-allocati.patch
similarity index 54%
rename from patches/ntdll-ForceBottomUpAlloc/0003-ntdll-Force-virtual-memory-allocation-order.patch
rename to patches/ntdll-ForceBottomUpAlloc/0005-ntdll-Use-free-area-list-for-virtual-memory-allocati.patch
index 55309fee..19d09a62 100644
--- a/patches/ntdll-ForceBottomUpAlloc/0003-ntdll-Force-virtual-memory-allocation-order.patch
+++ b/patches/ntdll-ForceBottomUpAlloc/0005-ntdll-Use-free-area-list-for-virtual-memory-allocati.patch
@@ -1,26 +1,76 @@
-From 1823294e18c99c17f3085486f12dcd2c6f8555b6 Mon Sep 17 00:00:00 2001
+From 93e4ba286e3eee3cb846d05014cea4e92bee6c1b Mon Sep 17 00:00:00 2001
 From: Paul Gofman <pgofman@codeweavers.com>
-Date: Mon, 25 Nov 2019 12:19:20 +0300
-Subject: [PATCH 3/4] ntdll: Force virtual memory allocation order.
+Date: Tue, 14 Jan 2020 21:42:21 +0300
+Subject: [PATCH] ntdll: Use free area list for virtual memory allocation.
 
-Windows allocates virtual memory strictly bottom up or
-top down depending on the requested flags. Modern Linux
-VM allocator always allocates memory top down. Some
-applications break if the allocated memory addresses
-are from higher memory than they expect.
-
-Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=48175
-Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=46568
-Signed-off-by: Paul Gofman <pgofman@codeweavers.com>
 ---
- dlls/ntdll/unix/virtual.c | 417 ++++++++++++++++++--------------------
- 1 file changed, 201 insertions(+), 216 deletions(-)
+ dlls/ntdll/unix/virtual.c | 342 +++++++++++++++++++++++++-------------
+ 1 file changed, 230 insertions(+), 112 deletions(-)
 
 diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
-index 924dff973ce..e7dfc516538 100644
+index f4dba39cb160..4827a1d785a4 100644
 --- a/dlls/ntdll/unix/virtual.c
 +++ b/dlls/ntdll/unix/virtual.c
-@@ -1020,44 +1020,6 @@ static struct file_view *find_view_range( const void *addr, size_t size )
+@@ -195,7 +195,11 @@ static BYTE *pages_vprot;
+ #endif
+ 
+ static struct file_view *view_block_start, *view_block_end, *next_free_view;
++#ifdef _WIN64
++static const size_t view_block_size = 0x200000;
++#else
+ static const size_t view_block_size = 0x100000;
++#endif
+ static void *preload_reserve_start;
+ static void *preload_reserve_end;
+ static BOOL use_locks;
+@@ -546,13 +550,13 @@ static struct range_entry *free_ranges_lower_bound( void *addr )
+  *
+  * Updates the free_ranges after a new view has been created.
+  */
+-static void free_ranges_insert_view( struct file_view *view )
++static void free_ranges_remove_range( void *view_base, void *view_end, void *view_base_unaligned )
+ {
+-    void *view_base = ROUND_ADDR( view->base, granularity_mask );
+-    void *view_end = ROUND_ADDR( (char *)view->base + view->size + granularity_mask, granularity_mask );
+     struct range_entry *range = free_ranges_lower_bound( view_base );
+     struct range_entry *next = range + 1;
+ 
++    TRACE("view %p-%p (%p).\n", view_base, view_end, view_base_unaligned);
++
+     /* free_ranges initial value is such that the view is either inside range or before another one. */
+     assert( range != free_ranges_end );
+     assert( range->end > view_base || next != free_ranges_end );
+@@ -563,7 +567,7 @@ static void free_ranges_insert_view( struct file_view *view )
+         (range->end == view_base && next->base >= view_end))
+     {
+         /* on Win64, assert that it's correctly aligned so we're not going to be in trouble later */
+-        assert( (!is_win64 && !is_wow64) || view->base == view_base );
++        assert( (!is_win64 && !is_wow64) || view_base_unaligned == view_base );
+         WARN( "range %p - %p is already mapped\n", view_base, view_end );
+         return;
+     }
+@@ -603,6 +607,12 @@ static void free_ranges_insert_view( struct file_view *view )
+     }
+ }
+ 
++static void free_ranges_insert_view( struct file_view *view )
++{
++    free_ranges_remove_range(ROUND_ADDR(view->base, granularity_mask),
++            ROUND_ADDR((char *)view->base + view->size + granularity_mask, granularity_mask),
++            view->base);
++}
+ 
+ /***********************************************************************
+  *           free_ranges_remove_view
+@@ -633,6 +643,7 @@ static void free_ranges_remove_view( struct file_view *view )
+         return;
+     }
+ #endif
++    TRACE("view %p-%p.\n", view_base, view_end);
+ 
+     /* free_ranges initial value is such that the view is either inside range or before another one. */
+     assert( range != free_ranges_end );
+@@ -1008,44 +1019,6 @@ static struct file_view *find_view_range( const void *addr, size_t size )
  }
  
  
@@ -28,7 +78,7 @@ index 924dff973ce..e7dfc516538 100644
 - *           find_view_inside_range
 - *
 - * Find first (resp. last, if top_down) view inside a range.
-- * virtual_mutex must be held by caller.
+- * The csVirtual section must be held by caller.
 - */
 -static struct wine_rb_entry *find_view_inside_range( void **base_ptr, void **end_ptr, int top_down )
 -{
@@ -65,7 +115,7 @@ index 924dff973ce..e7dfc516538 100644
  /***********************************************************************
   *           try_map_free_area
   *
-@@ -1090,110 +1052,6 @@ static void* try_map_free_area( void *base, void *end, ptrdiff_t step,
+@@ -1089,65 +1062,11 @@ static void* try_map_free_area( void *base, void *end, ptrdiff_t step,
      return NULL;
  }
  
@@ -74,7 +124,7 @@ index 924dff973ce..e7dfc516538 100644
 - *           map_free_area
 - *
 - * Find a free area between views inside the specified range and map it.
-- * virtual_mutex must be held by caller.
+- * The csVirtual section must be held by caller.
 - */
 -static void *map_free_area( void *base, void *end, size_t size, int top_down, int unix_prot )
 -{
@@ -121,62 +171,17 @@ index 924dff973ce..e7dfc516538 100644
 -    return start;
 -}
 -
--
--/***********************************************************************
-- *           find_reserved_free_area
-- *
-- * Find a free area between views inside the specified range.
-- * virtual_mutex must be held by caller.
-- * The range must be inside the preloader reserved range.
-- */
--static void *find_reserved_free_area( void *base, void *end, size_t size, int top_down )
--{
--    struct range_entry *range;
--    void *start;
--
--    base = ROUND_ADDR( (char *)base + granularity_mask, granularity_mask );
--    end = (char *)ROUND_ADDR( (char *)end - size, granularity_mask ) + size;
--
--    if (top_down)
--    {
--        start = (char *)end - size;
--        range = free_ranges_lower_bound( start );
--        assert(range != free_ranges_end && range->end >= start);
--
--        if ((char *)range->end - (char *)start < size) start = ROUND_ADDR( (char *)range->end - size, granularity_mask );
--        do
--        {
--            if (start >= end || start < base || (char *)end - (char *)start < size) return NULL;
--            if (start < range->end && start >= range->base && (char *)range->end - (char *)start >= size) break;
--            if (--range < free_ranges) return NULL;
--            start = ROUND_ADDR( (char *)range->end - size, granularity_mask );
--        }
--        while (1);
--    }
--    else
--    {
--        start = base;
--        range = free_ranges_lower_bound( start );
--        assert(range != free_ranges_end && range->end >= start);
--
--        if (start < range->base) start = ROUND_ADDR( (char *)range->base + granularity_mask, granularity_mask );
--        do
--        {
--            if (start >= end || start < base || (char *)end - (char *)start < size) return NULL;
--            if (start < range->end && start >= range->base && (char *)range->end - (char *)start >= size) break;
--            if (++range == free_ranges_end) return NULL;
--            start = ROUND_ADDR( (char *)range->base + granularity_mask, granularity_mask );
--        }
--        while (1);
--    }
--    return start;
--}
--
 -
  /***********************************************************************
-  *           add_reserved_area
+  *           find_reserved_free_area
   *
-@@ -1351,8 +1209,7 @@ static void delete_view( struct file_view *view ) /* [in] View */
+  * Find a free area between views inside the specified range.
+  * The csVirtual section must be held by caller.
+- * The range must be inside the preloader reserved range.
+  */
+ static void *find_reserved_free_area( void *base, void *end, size_t size, int top_down )
+ {
+@@ -1361,8 +1280,7 @@ static void delete_view( struct file_view *view ) /* [in] View */
  {
      if (!(view->protect & VPROT_SYSTEM)) unmap_area( view->base, view->size );
      set_page_vprot( view->base, view->size, 0 );
@@ -186,7 +191,7 @@ index 924dff973ce..e7dfc516538 100644
      wine_rb_remove( &views_tree, &view->entry );
      *(struct file_view **)view = next_free_view;
      next_free_view = view;
-@@ -1400,8 +1257,7 @@ static NTSTATUS create_view( struct file_view **view_ret, void *base, size_t siz
+@@ -1410,8 +1328,7 @@ static NTSTATUS create_view( struct file_view **view_ret, void *base, size_t siz
      set_page_vprot( base, size, vprot );
  
      wine_rb_put( &views_tree, view->base, &view->entry );
@@ -196,47 +201,36 @@ index 924dff973ce..e7dfc516538 100644
  
      *view_ret = view;
  
-@@ -1646,54 +1502,219 @@ static inline void *unmap_extra_space( void *ptr, size_t total_size, size_t want
-     return ptr;
+@@ -1656,6 +1573,7 @@ struct alloc_area
+     int    top_down;
+     void  *limit;
+     void  *result;
++    int    unix_prot;
+ };
+ 
+ /***********************************************************************
+@@ -1697,6 +1615,210 @@ static int CDECL alloc_reserved_area_callback( void *start, SIZE_T size, void *a
+     return 0;
  }
  
--
- struct alloc_area
- {
++struct area_alloc_reserved
++{
 +    char *map_area_start, *map_area_end, *result;
-     size_t size;
--    int    top_down;
--    void  *limit;
--    void  *result;
++    size_t size;
 +    ptrdiff_t step;
 +    int unix_prot;
 +    BOOL top_down;
- };
- 
--/***********************************************************************
-- *           alloc_reserved_area_callback
-- *
-- * Try to map some space inside a reserved area. Callback for mmap_enum_reserved_areas.
-- */
--static int CDECL alloc_reserved_area_callback( void *start, SIZE_T size, void *arg )
++};
++
 +static int CDECL alloc_area_in_reserved_or_between_callback( void *start, SIZE_T size, void *arg )
- {
--    struct alloc_area *alloc = arg;
--    void *end = (char *)start + size;
--
--    if (start < address_space_start) start = address_space_start;
--    if (is_beyond_limit( start, size, alloc->limit )) end = alloc->limit;
--    if (start >= end) return 0;
-+    char *intersect_start, *intersect_end;
++{
++    struct area_alloc_reserved *area = arg;
 +    char *end = (char *)start + size;
-+    struct alloc_area *area = arg;
++    char *intersect_start, *intersect_end;
 +    char *alloc_start;
- 
--    /* make sure we don't touch the preloader reserved range */
--    if (preload_reserve_end >= start)
++
 +    if (area->top_down)
-     {
--        if (preload_reserve_end >= end)
++    {
 +        if (area->map_area_start >= end)
 +            return 1;
 +
@@ -252,24 +246,16 @@ index 924dff973ce..e7dfc516538 100644
 +        alloc_start = ROUND_ADDR( (char *)area->map_area_end - size, granularity_mask );
 +
 +        if (alloc_start >= intersect_end)
-         {
--            if (preload_reserve_start <= start) return 0;  /* no space in that area */
--            if (preload_reserve_start < end) end = preload_reserve_start;
++        {
 +            if ((area->result = try_map_free_area( area->map_area_start, alloc_start + size, area->step,
 +                    alloc_start, area->size, area->unix_prot )))
 +                return 1;
-         }
--        else if (preload_reserve_start <= start) start = preload_reserve_end;
--        else
++        }
 +
 +        alloc_start = ROUND_ADDR( intersect_end - area->size, granularity_mask );
 +        if (alloc_start >= intersect_start)
-         {
--            /* range is split in two by the preloader reservation, try first part */
--            if ((alloc->result = find_reserved_free_area( start, preload_reserve_start, alloc->size,
--                                                          alloc->top_down )))
-+            if ((area->result = anon_mmap_fixed( alloc_start, area->size,
-+                    area->unix_prot, 0 )) != alloc_start)
++        {
++            if ((area->result = wine_anon_mmap( alloc_start, area->size, area->unix_prot, MAP_FIXED )) != alloc_start)
 +                ERR("Could not map in reserved area, alloc_start %p, size %p.\n",
 +                        alloc_start, (void *)area->size);
 +            return 1;
@@ -297,14 +283,12 @@ index 924dff973ce..e7dfc516538 100644
 +        {
 +            if ((area->result = try_map_free_area( area->map_area_start, intersect_start, area->step,
 +                    area->map_area_start, area->size, area->unix_prot )))
-                 return 1;
--            /* then fall through to try second part */
--            start = preload_reserve_end;
-         }
++                return 1;
++        }
 +
 +        if (intersect_end - intersect_start >= area->size)
 +        {
-+            if ((area->result = anon_mmap_fixed( intersect_start, area->size, area->unix_prot, 0 ))
++            if ((area->result = wine_anon_mmap( intersect_start, area->size, area->unix_prot, MAP_FIXED ))
 +                    != intersect_start)
 +                ERR("Could not map in reserved area.\n");
 +            return 1;
@@ -312,69 +296,66 @@ index 924dff973ce..e7dfc516538 100644
 +        area->map_area_start = intersect_end;
 +        if (area->map_area_end - area->map_area_start < area->size)
 +            return 1;
-     }
--    if ((alloc->result = find_reserved_free_area( start, end, alloc->size, alloc->top_down )))
--        return 1;
- 
-     return 0;
- }
- 
-+static void *alloc_free_area_in_range( struct alloc_area *area, char *base, char *end )
++    }
++
++    return 0;
++}
++
++static void *alloc_free_area_in_range(struct area_alloc_reserved *area, char *base, char *end,
++        size_t size, int top_down, int unix_prot)
 +{
 +    char *start;
 +
 +    TRACE("range %p-%p.\n", base, end);
 +
-+    if (base >= end)
-+        return NULL;
++    if (base >= end) return NULL;
 +
 +    area->map_area_start = base;
 +    area->map_area_end = end;
 +
-+    if (area->top_down)
++    if (top_down)
 +    {
-+        start = ROUND_ADDR( end - area->size, granularity_mask );
++        start = ROUND_ADDR( end - size, granularity_mask );
 +        if (start >= end || start < base)
 +            return NULL;
 +    }
 +    else
 +    {
 +        start = ROUND_ADDR( base + granularity_mask, granularity_mask );
-+        if (!start || start >= end || (char *)end - (char *)start < area->size)
++        if (!start || start >= end || (char *)end - (char *)start < size)
 +            return NULL;
 +    }
 +
-+    mmap_enum_reserved_areas( alloc_area_in_reserved_or_between_callback, area, area->top_down );
-+
++    mmap_enum_reserved_areas( alloc_area_in_reserved_or_between_callback, area, top_down );
 +    if (area->result)
 +        return area->result;
 +
-+    if (area->top_down)
++    if (top_down)
 +    {
-+        start = ROUND_ADDR( area->map_area_end - area->size, granularity_mask );
++        start = ROUND_ADDR( area->map_area_end - size, granularity_mask );
 +        if (start >= area->map_area_end || start < area->map_area_start)
 +            return NULL;
 +
-+        return try_map_free_area( area->map_area_start, start + area->size, area->step,
-+                start, area->size, area->unix_prot );
++        return try_map_free_area( area->map_area_start, start + size, area->step,
++                start, size, unix_prot );
 +    }
 +    else
 +    {
 +        start = ROUND_ADDR( area->map_area_start + granularity_mask, granularity_mask );
 +        if (!start || start >= area->map_area_end
-+                || area->map_area_end - start < area->size)
++                || area->map_area_end - start < size)
 +            return NULL;
 +
 +        return try_map_free_area( start, area->map_area_end, area->step,
-+                start, area->size, area->unix_prot );
++                start, size, unix_prot );
 +    }
 +}
 +
-+static void *alloc_free_area( void *limit, size_t size, BOOL top_down, int unix_prot )
++static void *alloc_free_area(void *limit, size_t size, BOOL top_down, int unix_prot)
 +{
 +    struct range_entry *range, *ranges_start, *ranges_end;
 +    char *reserve_start, *reserve_end;
-+    struct alloc_area area;
++    struct area_alloc_reserved area;
 +    char *base, *end;
 +    int ranges_inc;
 +
@@ -393,14 +374,14 @@ index 924dff973ce..e7dfc516538 100644
 +        ranges_inc = 1;
 +    }
 +
-+    memset( &area, 0, sizeof(area) );
++    memset(&area, 0, sizeof(area));
 +    area.step = top_down ? -(granularity_mask + 1) : (granularity_mask + 1);
 +    area.size = size;
 +    area.top_down = top_down;
 +    area.unix_prot = unix_prot;
 +
-+    reserve_start = ROUND_ADDR( (char *)preload_reserve_start, granularity_mask );
-+    reserve_end = ROUND_ADDR( (char *)preload_reserve_end + granularity_mask, granularity_mask );
++    reserve_start = ROUND_ADDR((char *)preload_reserve_start, granularity_mask);
++    reserve_end = ROUND_ADDR((char *)preload_reserve_end + granularity_mask, granularity_mask);
 +
 +    for (range = ranges_start; range != ranges_end; range += ranges_inc)
 +    {
@@ -409,35 +390,28 @@ index 924dff973ce..e7dfc516538 100644
 +
 +        TRACE("range %p-%p.\n", base, end);
 +
-+        if (base < (char *)address_space_start)
-+            base = (char *)address_space_start;
-+        if (end > (char *)ROUND_ADDR( limit, granularity_mask ))
-+            end = ROUND_ADDR( limit, granularity_mask );
++        if (base < (char *)address_space_start) base = (char *)address_space_start;
++        if (end > (char *)ROUND_ADDR(limit, granularity_mask)) end = ROUND_ADDR(limit, granularity_mask);
 +
 +        if (reserve_end >= base)
 +        {
 +            if (reserve_end >= end)
 +            {
-+                if (reserve_start <= base)
-+                    continue;  /* no space in that area */
-+                if (reserve_start < end)
-+                    end = reserve_start;
-+            }
-+            else if (reserve_start <= base)
-+            {
-+                base = reserve_end;
++                if (reserve_start <= base) continue;  /* no space in that area */
++                if (reserve_start < end) end = reserve_start;
 +            }
++            else if (reserve_start <= base) base = reserve_end;
 +            else
 +            {
-+                /* range is split in two by the preloader reservation, try first part. */
-+                if ((area.result = alloc_free_area_in_range( &area, base, reserve_start )))
++                /* range is split in two by the preloader reservation, try first part */
++                if ((area.result = alloc_free_area_in_range(&area, base, reserve_start, size, top_down, unix_prot)))
 +                    return area.result;
-+                /* then fall through to try second part. */
++                /* then fall through to try second part */
 +                base = reserve_end;
 +            }
 +        }
 +
-+        if ((area.result = alloc_free_area_in_range( &area, base, end )))
++        if ((area.result = alloc_free_area_in_range(&area, base, end, size, top_down, unix_prot)))
 +            return area.result;
 +    }
 +    return NULL;
@@ -446,31 +420,30 @@ index 924dff973ce..e7dfc516538 100644
  /***********************************************************************
   *           map_fixed_area
   *
-@@ -1765,48 +1786,11 @@ static NTSTATUS map_view( struct file_view **view_ret, void *base, size_t size,
-         if (status != STATUS_SUCCESS) return status;
-         ptr = base;
-     }
--    else
-+    else if (!(ptr = alloc_free_area( (void*)(get_zero_bits_64_mask( zero_bits_64 )
-+            & (UINT_PTR)user_space_limit), size, top_down, get_unix_prot( vprot ) )))
-     {
--        size_t view_size = size + granularity_mask + 1;
--        struct alloc_area alloc;
--
--        alloc.size = size;
--        alloc.top_down = top_down;
--        alloc.limit = (void*)(get_zero_bits_64_mask( zero_bits_64 ) & (UINT_PTR)user_space_limit);
--
--        if (mmap_enum_reserved_areas( alloc_reserved_area_callback, &alloc, top_down ))
--        {
--            ptr = alloc.result;
--            TRACE( "got mem in reserved area %p-%p\n", ptr, (char *)ptr + size );
--            if (anon_mmap_fixed( ptr, size, get_unix_prot(vprot), 0 ) != ptr)
--                return STATUS_INVALID_PARAMETER;
--            goto done;
--        }
--
--        if (zero_bits_64)
+@@ -1782,11 +1904,15 @@ static NTSTATUS map_view( struct file_view **view_ret, void *base, size_t size,
+         alloc.size = size;
+         alloc.top_down = top_down;
+         alloc.limit = (void*)(get_zero_bits_64_mask( zero_bits_64 ) & (UINT_PTR)user_space_limit);
++        alloc.unix_prot = get_unix_prot( vprot );
+ 
+-        if (is_win64 && !top_down)
++        if (is_win64 || zero_bits_64)
+         {
+-            /* Ditch 0x7ffffe000000 - 0x7fffffff0000 reserved area. */
+-            alloc.limit = min(alloc.limit, (void *)0x7ffffe000000);
++            if (!(ptr = alloc_free_area( alloc.limit, alloc.size, top_down, alloc.unix_prot)))
++                return STATUS_NO_MEMORY;
++
++            TRACE( "got mem in free area %p-%p\n", ptr, (char *)ptr + size );
++            goto done;
+         }
+ 
+         if (mmap_enum_reserved_areas( alloc_reserved_area_callback, &alloc, top_down ))
+@@ -1798,15 +1924,6 @@ static NTSTATUS map_view( struct file_view **view_ret, void *base, size_t size,
+             goto done;
+         }
+ 
+-        if (is_win64 || zero_bits_64)
 -        {
 -            if (!(ptr = map_free_area( address_space_start, alloc.limit, size,
 -                                       top_down, get_unix_prot(vprot) )))
@@ -479,33 +452,17 @@ index 924dff973ce..e7dfc516538 100644
 -            goto done;
 -        }
 -
--        for (;;)
--        {
--            if ((ptr = anon_mmap_alloc( view_size, get_unix_prot(vprot) )) == MAP_FAILED)
--            {
--                if (errno == ENOMEM) return STATUS_NO_MEMORY;
--                return STATUS_INVALID_PARAMETER;
--            }
--            TRACE( "got mem with anon mmap %p-%p\n", ptr, (char *)ptr + size );
--            /* if we got something beyond the user limit, unmap it and retry */
--            if (is_beyond_limit( ptr, view_size, user_space_limit )) add_reserved_area( ptr, view_size );
--            else break;
--        }
--        ptr = unmap_extra_space( ptr, view_size, size );
-+        return STATUS_NO_MEMORY;
-     }
--done:
-     status = create_view( view_ret, ptr, size, vprot );
-     if (status != STATUS_SUCCESS) unmap_area( ptr, size );
-     return status;
-@@ -2453,6 +2437,7 @@ void virtual_init(void)
+         view_size = size + granularity_mask + 1;
+ 
+         for (;;)
+@@ -2500,6 +2617,7 @@ void virtual_init(void)
              if (preload_reserve_start)
                  address_space_start = min( address_space_start, preload_reserve_start );
          }
 +        TRACE("preload reserve %p-%p.\n", preload_reserve_start, preload_reserve_end);
      }
  
-     /* try to find space in a reserved area for the views and pages protection table */
+     size = ROUND_SIZE( 0, sizeof(TEB) ) + max( MINSIGSTKSZ, 8192 );
 -- 
 2.26.2
 
diff --git a/patches/ntdll-ForceBottomUpAlloc/0006-ntdll-Permanently-exclude-natively-mapped-areas-from.patch b/patches/ntdll-ForceBottomUpAlloc/0006-ntdll-Permanently-exclude-natively-mapped-areas-from.patch
new file mode 100644
index 00000000..cc9507c9
--- /dev/null
+++ b/patches/ntdll-ForceBottomUpAlloc/0006-ntdll-Permanently-exclude-natively-mapped-areas-from.patch
@@ -0,0 +1,66 @@
+From 957fc1577fb1b1f3184cb9d7710f7e9a2afebdb1 Mon Sep 17 00:00:00 2001
+From: Paul Gofman <pgofman@codeweavers.com>
+Date: Tue, 2 Jun 2020 21:06:33 +0300
+Subject: [PATCH] ntdll: Permanently exclude natively mapped areas from free
+ areas list.
+
+---
+ dlls/ntdll/unix/virtual.c | 25 +++++++++++++++++++++++++
+ 1 file changed, 25 insertions(+)
+
+diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
+index 4827a1d785a4..ef5c5dafe8fb 100644
+--- a/dlls/ntdll/unix/virtual.c
++++ b/dlls/ntdll/unix/virtual.c
+@@ -124,6 +124,9 @@ static const BYTE VIRTUAL_Win32Flags[16] =
+ 
+ static struct wine_rb_tree views_tree;
+ 
++static void *last_already_mapped;
++static size_t last_already_mapped_size;
++
+ static RTL_CRITICAL_SECTION csVirtual;
+ static RTL_CRITICAL_SECTION_DEBUG critsect_debug =
+ {
+@@ -1051,6 +1054,13 @@ static void* try_map_free_area( void *base, void *end, ptrdiff_t step,
+         if (ptr != (void *)-1)
+             munmap( ptr, size );
+ 
++        if (!last_already_mapped && step)
++        {
++            last_already_mapped = start;
++            last_already_mapped_size = step > 0 ? step : -step;
++            last_already_mapped_size = min(last_already_mapped_size, (char *)end - (char *)start);
++        }
++
+         if ((step > 0 && (char *)end - (char *)start < step) ||
+             (step < 0 && (char *)start - (char *)base < -step) ||
+             step == 0)
+@@ -1908,9 +1918,24 @@ static NTSTATUS map_view( struct file_view **view_ret, void *base, size_t size,
+ 
+         if (is_win64 || zero_bits_64)
+         {
++            last_already_mapped = NULL;
++
+             if (!(ptr = alloc_free_area( alloc.limit, alloc.size, top_down, alloc.unix_prot)))
+                 return STATUS_NO_MEMORY;
+ 
++            if (last_already_mapped)
++            {
++                void *last_mapped_start, *last_mapped_end;
++
++                TRACE("Permanently excluding %p - %p from free list.\n",
++                        last_already_mapped, (char *)last_already_mapped + last_already_mapped_size - 1);
++                last_mapped_start = ROUND_ADDR(last_already_mapped, granularity_mask);
++                last_mapped_end = ROUND_ADDR((char *)last_already_mapped + last_already_mapped_size + granularity_mask,
++                        granularity_mask);
++                if (ptr > last_mapped_end || (char *)ptr + size < (char *)last_mapped_start)
++                    free_ranges_remove_range(last_mapped_start, last_mapped_end, last_already_mapped);
++            }
++
+             TRACE( "got mem in free area %p-%p\n", ptr, (char *)ptr + size );
+             goto done;
+         }
+-- 
+2.26.2
+
diff --git a/patches/ntdll-HashLinks/0001-ntdll-Implement-HashLinks-field-in-LDR-module-data.patch b/patches/ntdll-HashLinks/0001-ntdll-Implement-HashLinks-field-in-LDR-module-data.patch
index 09494f25..0669eac8 100644
--- a/patches/ntdll-HashLinks/0001-ntdll-Implement-HashLinks-field-in-LDR-module-data.patch
+++ b/patches/ntdll-HashLinks/0001-ntdll-Implement-HashLinks-field-in-LDR-module-data.patch
@@ -1,16 +1,16 @@
-From da42137e7187fddc47862f435f3f238c687dc109 Mon Sep 17 00:00:00 2001
+From 875ab1e7ff6b708f15b07537a91406fe83dec681 Mon Sep 17 00:00:00 2001
 From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
 Date: Mon, 3 Apr 2017 05:30:27 +0200
 Subject: [PATCH] ntdll: Implement HashLinks field in LDR module data.
 
 ---
- dlls/kernel32/tests/loader.c | 75 ++++++++++++++++++++++++++++++++++++
- dlls/ntdll/loader.c          | 65 +++++++++++++++++++++++++++++++
+ dlls/kernel32/tests/loader.c | 76 ++++++++++++++++++++++++++++++++++++
+ dlls/ntdll/loader.c          | 65 ++++++++++++++++++++++++++++++
  include/winternl.h           |  2 +-
- 3 files changed, 141 insertions(+), 1 deletion(-)
+ 3 files changed, 142 insertions(+), 1 deletion(-)
 
 diff --git a/dlls/kernel32/tests/loader.c b/dlls/kernel32/tests/loader.c
-index ca6afcbe051..2b6f51d55ba 100644
+index 5474d543248..2d382d4f326 100644
 --- a/dlls/kernel32/tests/loader.c
 +++ b/dlls/kernel32/tests/loader.c
 @@ -30,6 +30,7 @@
@@ -21,7 +21,7 @@ index ca6afcbe051..2b6f51d55ba 100644
  #include "wine/test.h"
  #include "delayloadhandler.h"
  
-@@ -3945,6 +3946,79 @@ static void test_LoadPackagedLibrary(void)
+@@ -3934,6 +3935,79 @@ static void test_LoadPackagedLibrary(void)
              h, GetLastError());
  }
  
@@ -101,7 +101,7 @@ index ca6afcbe051..2b6f51d55ba 100644
  START_TEST(loader)
  {
      int argc;
-@@ -4017,6 +4091,7 @@ START_TEST(loader)
+@@ -4006,10 +4080,12 @@ START_TEST(loader)
      test_InMemoryOrderModuleList();
      test_LoadPackagedLibrary();
      test_wow64_redirection();
@@ -109,21 +109,26 @@ index ca6afcbe051..2b6f51d55ba 100644
      test_dll_file( "ntdll.dll" );
      test_dll_file( "kernel32.dll" );
      test_dll_file( "advapi32.dll" );
+     test_dll_file( "user32.dll" );
++
+     /* loader test must be last, it can corrupt the internal loader state on Windows */
+     test_Loader();
+ }
 diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
-index 55588774b29..06f4571a008 100644
+index 35dc7e1eaa4..d1e5fdeb5b8 100644
 --- a/dlls/ntdll/loader.c
 +++ b/dlls/ntdll/loader.c
-@@ -124,6 +124,9 @@ struct file_id
-     BYTE ObjectId[16];
- };
+@@ -120,6 +120,9 @@ static const char * const reason_names[] =
+ 
+ static const WCHAR dllW[] = {'.','d','l','l',0};
  
 +#define HASH_MAP_SIZE 32
 +static LIST_ENTRY hash_table[HASH_MAP_SIZE];
 +
- /* internal representation of loaded modules */
+ /* internal representation of 32bit modules. per process. */
  typedef struct _wine_modref
  {
-@@ -484,6 +487,52 @@ static void call_ldr_notifications( ULONG reason, LDR_DATA_TABLE_ENTRY *module )
+@@ -460,6 +463,52 @@ static void call_ldr_notifications( ULONG reason, LDR_DATA_TABLE_ENTRY *module )
      }
  }
  
@@ -189,7 +194,15 @@ index 55588774b29..06f4571a008 100644
  
      if (!(nt->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_NX_COMPAT))
      {
-@@ -1956,6 +2010,7 @@ static NTSTATUS build_module( LPCWSTR load_path, const UNICODE_STRING *nt_name,
+@@ -1850,6 +1904,7 @@ static NTSTATUS build_so_dll_module( const WCHAR *load_path, const UNICODE_STRIN
+             /* the module has only been inserted in the load & memory order lists */
+             RemoveEntryList(&wm->ldr.InLoadOrderLinks);
+             RemoveEntryList(&wm->ldr.InMemoryOrderLinks);
++            RemoveEntryList(&wm->ldr.HashLinks);
+             /* FIXME: free the modref */
+             return status;
+         }
+@@ -2393,6 +2448,7 @@ static NTSTATUS load_native_dll( LPCWSTR load_path, const UNICODE_STRING *nt_nam
              /* the module has only be inserted in the load & memory order lists */
              RemoveEntryList(&wm->ldr.InLoadOrderLinks);
              RemoveEntryList(&wm->ldr.InMemoryOrderLinks);
@@ -197,7 +210,7 @@ index 55588774b29..06f4571a008 100644
  
              /* FIXME: there are several more dangling references
               * left. Including dlls loaded by this dll before the
-@@ -3330,6 +3385,7 @@ static void free_modref( WINE_MODREF *wm )
+@@ -3609,6 +3665,7 @@ static void free_modref( WINE_MODREF *wm )
  {
      RemoveEntryList(&wm->ldr.InLoadOrderLinks);
      RemoveEntryList(&wm->ldr.InMemoryOrderLinks);
@@ -205,15 +218,15 @@ index 55588774b29..06f4571a008 100644
      if (wm->ldr.InInitializationOrderLinks.Flink)
          RemoveEntryList(&wm->ldr.InInitializationOrderLinks);
  
-@@ -4091,6 +4147,7 @@ static NTSTATUS process_init(void)
-     INITIAL_TEB stack;
-     TEB *teb = NtCurrentTeb();
-     PEB *peb = teb->Peb;
+@@ -4333,6 +4390,7 @@ void __wine_process_init(void)
+     SIZE_T info_size;
+     TEB *teb;
+     PEB *peb;
 +    DWORD i;
  
-     peb->LdrData            = &ldr;
-     peb->FastPebLock        = &peb_lock;
-@@ -4130,6 +4187,10 @@ static NTSTATUS process_init(void)
+     if (!unix_funcs) load_ntdll_so( ntdll_module, &__wine_spec_nt_header );
+ 
+@@ -4360,6 +4418,10 @@ void __wine_process_init(void)
      load_global_options();
      version_init();
  
@@ -223,23 +236,22 @@ index 55588774b29..06f4571a008 100644
 +
      /* setup the load callback and create ntdll modref */
      RtlInitUnicodeString( &nt_name, ntdllW );
-     NtQueryVirtualMemory( GetCurrentProcess(), process_init, MemoryBasicInformation,
-@@ -4223,6 +4284,10 @@ static NTSTATUS process_init(void)
-     teb->Tib.StackBase = stack.StackBase;
+     status = build_so_dll_module( params->DllPath.Buffer, &nt_name, ntdll_module, 0, &wm );
+@@ -4435,6 +4497,9 @@ void __wine_process_init(void)
      teb->Tib.StackLimit = stack.StackLimit;
      teb->DeallocationStack = stack.DeallocationStack;
-+
+ 
 +    /* the windows version was not set yet when ntdll and kernel32 were loaded */
 +    recompute_hash_map();
 +
-     return STATUS_SUCCESS;
+     server_init_process_done();
  }
  
 diff --git a/include/winternl.h b/include/winternl.h
-index 62395bbce38..2511fa37c05 100644
+index 9df1f0bb800..8625b192cf1 100644
 --- a/include/winternl.h
 +++ b/include/winternl.h
-@@ -2680,8 +2680,8 @@ typedef struct _LDR_DATA_TABLE_ENTRY
+@@ -2330,8 +2330,8 @@ typedef struct _LDR_DATA_TABLE_ENTRY
      ULONG               Flags;
      SHORT               LoadCount;
      SHORT               TlsIndex;
@@ -250,5 +262,5 @@ index 62395bbce38..2511fa37c05 100644
      HANDLE              ActivationContext;
      void*               Lock;
 -- 
-2.28.0
+2.26.2
 
diff --git a/patches/ntdll-Heap_Improvements/0002-ntdll-Improve-heap-allocation-performance.patch b/patches/ntdll-Heap_Improvements/0002-ntdll-Improve-heap-allocation-performance.patch
index 27e53ada..950be1b4 100644
--- a/patches/ntdll-Heap_Improvements/0002-ntdll-Improve-heap-allocation-performance.patch
+++ b/patches/ntdll-Heap_Improvements/0002-ntdll-Improve-heap-allocation-performance.patch
@@ -1,14 +1,35 @@
-From 1b79a7d8eb8c813cca81916eda14090a15b93290 Mon Sep 17 00:00:00 2001
+From d7997c1fffbf407f08fc18464c2fe3f17a3038a4 Mon Sep 17 00:00:00 2001
 From: Sebastian Lackner <sebastian@fds-team.de>
 Date: Sat, 22 Jul 2017 07:21:45 +0200
 Subject: [PATCH] ntdll: Improve heap allocation performance. (v2)
 
 ---
- dlls/ntdll/heap.c | 306 +++++++++++++++++++++++++++++++---------------
- 1 file changed, 210 insertions(+), 96 deletions(-)
+ configure.ac      |   9 ++
+ dlls/ntdll/heap.c | 321 ++++++++++++++++++++++++++++++++--------------
+ 2 files changed, 234 insertions(+), 96 deletions(-)
 
+diff --git a/configure.ac b/configure.ac
+index 0ce3cb5c573..2fa1c7d4223 100644
+--- a/configure.ac
++++ b/configure.ac
+@@ -2790,6 +2790,15 @@ AC_CHECK_FUNCS(\
+ )
+ LIBS="$ac_save_LIBS"
+ 
++dnl Check for __builtin_ctzl
++AC_CACHE_CHECK([for __builtin_ctzl], ac_cv_have___builtin_ctzl,
++               AC_LINK_IFELSE([AC_LANG_PROGRAM(,[[return __builtin_ctzl(1)]])],
++               [ac_cv_have___builtin_ctzl="yes"], [ac_cv_have___builtin_ctzl="no"]))
++if test "$ac_cv_have___builtin_ctzl" = "yes"
++then
++    AC_DEFINE(HAVE___BUILTIN_CTZL, 1, [Define to 1 if you have the `__builtin_ctzl' built-in function.])
++fi
++
+ dnl Check for __builtin_popcount
+ AC_CACHE_CHECK([for __builtin_popcount], ac_cv_have___builtin_popcount,
+                AC_LINK_IFELSE([AC_LANG_PROGRAM(,[[return __builtin_popcount(1)]])],
 diff --git a/dlls/ntdll/heap.c b/dlls/ntdll/heap.c
-index 4fe11fe2b48..de33fcce4bb 100644
+index db5c039bb76..f51dc63f371 100644
 --- a/dlls/ntdll/heap.c
 +++ b/dlls/ntdll/heap.c
 @@ -3,6 +3,7 @@
@@ -19,7 +40,7 @@ index 4fe11fe2b48..de33fcce4bb 100644
   *
   * This library is free software; you can redistribute it and/or
   * modify it under the terms of the GNU Lesser General Public
-@@ -35,6 +36,7 @@
+@@ -41,6 +42,7 @@
  #include "winternl.h"
  #include "ntdll_misc.h"
  #include "wine/list.h"
@@ -27,7 +48,7 @@ index 4fe11fe2b48..de33fcce4bb 100644
  #include "wine/debug.h"
  #include "wine/server.h"
  
-@@ -56,7 +58,11 @@ typedef struct tagARENA_FREE
+@@ -62,7 +64,11 @@ typedef struct tagARENA_FREE
  {
      DWORD                 size;     /* Block size; must be the first field */
      DWORD                 magic;    /* Magic number */
@@ -40,7 +61,7 @@ index 4fe11fe2b48..de33fcce4bb 100644
  } ARENA_FREE;
  
  typedef struct
-@@ -69,9 +75,11 @@ typedef struct
+@@ -75,9 +81,11 @@ typedef struct
      DWORD                 magic;      /* these must remain at the end of the structure */
  } ARENA_LARGE;
  
@@ -55,7 +76,7 @@ index 4fe11fe2b48..de33fcce4bb 100644
  #define ARENA_LARGE_SIZE       0xfedcba90  /* magic value for 'size' field in large blocks */
  
  /* Value for arena 'magic' field */
-@@ -89,6 +97,8 @@ typedef struct
+@@ -95,6 +103,8 @@ typedef struct
  #define LARGE_ALIGNMENT        16  /* large blocks have stricter alignment */
  #define ARENA_OFFSET           (ALIGNMENT - sizeof(ARENA_INUSE))
  
@@ -64,7 +85,7 @@ index 4fe11fe2b48..de33fcce4bb 100644
  C_ASSERT( sizeof(ARENA_LARGE) % LARGE_ALIGNMENT == 0 );
  
  #define ROUND_SIZE(size)       ((((size) + ALIGNMENT - 1) & ~(ALIGNMENT-1)) + ARENA_OFFSET)
-@@ -97,9 +107,7 @@ C_ASSERT( sizeof(ARENA_LARGE) % LARGE_ALIGNMENT == 0 );
+@@ -103,9 +113,7 @@ C_ASSERT( sizeof(ARENA_LARGE) % LARGE_ALIGNMENT == 0 );
  #define NOISY                  0           /* Report all errors  */
  
  /* minimum data size (without arenas) of an allocated block */
@@ -75,7 +96,7 @@ index 4fe11fe2b48..de33fcce4bb 100644
  /* minimum size that must remain to shrink an allocated block */
  #define HEAP_MIN_SHRINK_SIZE  (HEAP_MIN_DATA_SIZE+sizeof(ARENA_FREE))
  /* minimum size to start allocating large blocks */
-@@ -108,23 +116,14 @@ C_ASSERT( sizeof(ARENA_LARGE) % LARGE_ALIGNMENT == 0 );
+@@ -114,23 +122,14 @@ C_ASSERT( sizeof(ARENA_LARGE) % LARGE_ALIGNMENT == 0 );
  #define HEAP_TAIL_EXTRA_SIZE(flags) \
      ((flags & HEAP_TAIL_CHECKING_ENABLED) || RUNNING_ON_VALGRIND ? ALIGNMENT : 0)
  
@@ -87,7 +108,7 @@ index 4fe11fe2b48..de33fcce4bb 100644
 -/* Max size of the blocks on the free lists above HEAP_MAX_SMALL_FREE_LIST */
 -static const SIZE_T HEAP_freeListSizes[] =
 -{
--    0x200, 0x400, 0x1000, ~(SIZE_T)0
+-    0x200, 0x400, 0x1000, ~0UL
 -};
 -#define HEAP_NB_FREE_LISTS (ARRAY_SIZE( HEAP_freeListSizes ) + HEAP_NB_SMALL_FREE_LISTS)
 -
@@ -107,17 +128,17 @@ index 4fe11fe2b48..de33fcce4bb 100644
  
  struct tagHEAP;
  
-@@ -157,9 +156,17 @@ typedef struct tagHEAP
+@@ -163,9 +162,17 @@ typedef struct tagHEAP
      DWORD            pending_pos;   /* Position in pending free requests ring */
      ARENA_INUSE    **pending_free;  /* Ring buffer for pending free requests */
      RTL_CRITICAL_SECTION critSection; /* Critical section for serialization */
 -    FREE_LIST_ENTRY *freeList;      /* Free lists */
 +    struct list     *freeList;      /* Free lists */
 +    struct wine_rb_tree freeTree;   /* Free tree */
-+    DWORD            freeMask[HEAP_NB_FREE_LISTS / (8 * sizeof(DWORD))];
++    unsigned long    freeMask[HEAP_NB_FREE_LISTS / (8 * sizeof(unsigned long))];
  } HEAP;
  
-+#define HEAP_FREEMASK_BLOCK    (8 * sizeof(DWORD))
++#define HEAP_FREEMASK_BLOCK    (8 * sizeof(unsigned long))
 +#define HEAP_FREEMASK_INDEX(x) ((x) / HEAP_FREEMASK_BLOCK)
 +#define HEAP_FREEMASK_BIT(x)   (1UL << ((x) & (HEAP_FREEMASK_BLOCK - 1)))
 +
@@ -126,7 +147,7 @@ index 4fe11fe2b48..de33fcce4bb 100644
  #define HEAP_MAGIC       ((DWORD)('H' | ('E'<<8) | ('A'<<16) | ('P'<<24)))
  
  #define HEAP_DEF_SIZE        0x110000   /* Default heap size = 1Mb + 64Kb */
-@@ -176,6 +183,13 @@ static HEAP *processHeap;  /* main process heap */
+@@ -182,6 +189,30 @@ static HEAP *processHeap;  /* main process heap */
  
  static BOOL HEAP_IsRealArena( HEAP *heapPtr, DWORD flags, LPCVOID block, BOOL quiet );
  
@@ -136,11 +157,28 @@ index 4fe11fe2b48..de33fcce4bb 100644
 +    ARENA_FREE *arena = WINE_RB_ENTRY_VALUE( entry, ARENA_FREE, entry.tree );
 +    return (arena->size & ARENA_SIZE_MASK);
 +}
++
++/* return number of trailing 0-bits in x */
++static inline int ctzl(unsigned long x)
++{
++#ifdef HAVE___BUILTIN_CTZL
++    return __builtin_ctzl(x);
++#else
++    int c = 1;
++    if (!(x & 0xffffffff)) { x >>= 32; c += 32; }
++    if (!(x & 0x0000ffff)) { x >>= 16; c += 16; }
++    if (!(x & 0x000000ff)) { x >>=  8; c +=  8; }
++    if (!(x & 0x0000000f)) { x >>=  4; c +=  4; }
++    if (!(x & 0x00000003)) { x >>=  2; c +=  2; }
++    c -= (x & 0x00000001);
++    return c;
++#endif
++}
 +
  /* mark a block of memory as free for debugging purposes */
  static inline void mark_block_free( void *ptr, SIZE_T size, DWORD flags )
  {
-@@ -297,20 +311,6 @@ static void subheap_notify_free_all(SUBHEAP const *subheap)
+@@ -303,20 +334,6 @@ static void subheap_notify_free_all(SUBHEAP const *subheap)
  #endif
  }
  
@@ -161,7 +199,7 @@ index 4fe11fe2b48..de33fcce4bb 100644
  /* get the memory protection type to use for a given heap */
  static inline ULONG get_protection_type( DWORD flags )
  {
-@@ -338,13 +338,31 @@ static void HEAP_Dump( HEAP *heap )
+@@ -344,13 +361,31 @@ static void HEAP_Dump( HEAP *heap )
      TRACE( "Next: %p  Sub-heaps:", LIST_ENTRY( heap->entry.next, HEAP, entry ) );
      LIST_FOR_EACH_ENTRY( subheap, &heap->subheap_list, SUBHEAP, entry ) TRACE( " %p", subheap );
  
@@ -199,7 +237,7 @@ index 4fe11fe2b48..de33fcce4bb 100644
  
      LIST_FOR_EACH_ENTRY( subheap, &heap->subheap_list, SUBHEAP, entry )
      {
-@@ -359,11 +377,32 @@ static void HEAP_Dump( HEAP *heap )
+@@ -365,11 +400,32 @@ static void HEAP_Dump( HEAP *heap )
              if (*(DWORD *)ptr & ARENA_FLAG_FREE)
              {
                  ARENA_FREE *pArena = (ARENA_FREE *)ptr;
@@ -237,7 +275,7 @@ index 4fe11fe2b48..de33fcce4bb 100644
                  ptr += sizeof(*pArena) + (pArena->size & ARENA_SIZE_MASK);
                  arenaSize += sizeof(ARENA_FREE);
                  freeSize += pArena->size & ARENA_SIZE_MASK;
-@@ -471,20 +510,19 @@ static HEAP *HEAP_GetPtr(
+@@ -477,20 +533,19 @@ static HEAP *HEAP_GetPtr(
   */
  static inline void HEAP_InsertFreeBlock( HEAP *heap, ARENA_FREE *pArena, BOOL last )
  {
@@ -266,7 +304,7 @@ index 4fe11fe2b48..de33fcce4bb 100644
  }
  
  
-@@ -495,7 +533,19 @@ static inline void HEAP_InsertFreeBlock( HEAP *heap, ARENA_FREE *pArena, BOOL la
+@@ -501,7 +556,19 @@ static inline void HEAP_InsertFreeBlock( HEAP *heap, ARENA_FREE *pArena, BOOL la
   */
  static inline void HEAP_DeleteFreeBlock( HEAP *heap, ARENA_FREE *pArena )
  {
@@ -287,7 +325,7 @@ index 4fe11fe2b48..de33fcce4bb 100644
  }
  
  
-@@ -875,6 +925,15 @@ static BOOL validate_large_arena( HEAP *heap, const ARENA_LARGE *arena, BOOL qui
+@@ -880,6 +947,15 @@ static BOOL validate_large_arena( HEAP *heap, const ARENA_LARGE *arena, BOOL qui
  }
  
  
@@ -303,7 +341,7 @@ index 4fe11fe2b48..de33fcce4bb 100644
  /***********************************************************************
   *           HEAP_CreateSubHeap
   */
-@@ -882,7 +941,6 @@ static SUBHEAP *HEAP_CreateSubHeap( HEAP *heap, LPVOID address, DWORD flags,
+@@ -887,7 +963,6 @@ static SUBHEAP *HEAP_CreateSubHeap( HEAP *heap, LPVOID address, DWORD flags,
                                      SIZE_T commitSize, SIZE_T totalSize )
  {
      SUBHEAP *subheap;
@@ -311,7 +349,7 @@ index 4fe11fe2b48..de33fcce4bb 100644
      unsigned int i;
  
      if (!address)
-@@ -943,17 +1001,21 @@ static SUBHEAP *HEAP_CreateSubHeap( HEAP *heap, LPVOID address, DWORD flags,
+@@ -948,17 +1023,21 @@ static SUBHEAP *HEAP_CreateSubHeap( HEAP *heap, LPVOID address, DWORD flags,
          subheap->headerSize = ROUND_SIZE( sizeof(HEAP) );
          list_add_head( &heap->subheap_list, &subheap->entry );
  
@@ -338,12 +376,12 @@ index 4fe11fe2b48..de33fcce4bb 100644
 +
 +        /* Initialize the free mask */
 +
-+        for (i = 0; i < ARRAY_SIZE(heap->freeMask); i++)
++        for (i = 0; i < sizeof(heap->freeMask) / sizeof(heap->freeMask[0]); i++)
 +            heap->freeMask[i] = 0;
  
          /* Initialize critical section */
  
-@@ -996,6 +1058,34 @@ static SUBHEAP *HEAP_CreateSubHeap( HEAP *heap, LPVOID address, DWORD flags,
+@@ -1001,6 +1080,34 @@ static SUBHEAP *HEAP_CreateSubHeap( HEAP *heap, LPVOID address, DWORD flags,
  }
  
  
@@ -378,12 +416,12 @@ index 4fe11fe2b48..de33fcce4bb 100644
  /***********************************************************************
   *           HEAP_FindFreeBlock
   *
-@@ -1005,26 +1095,41 @@ static SUBHEAP *HEAP_CreateSubHeap( HEAP *heap, LPVOID address, DWORD flags,
+@@ -1010,26 +1117,39 @@ static SUBHEAP *HEAP_CreateSubHeap( HEAP *heap, LPVOID address, DWORD flags,
  static ARENA_FREE *HEAP_FindFreeBlock( HEAP *heap, SIZE_T size,
                                         SUBHEAP **ppSubHeap )
  {
 +    struct wine_rb_entry *ptr;
-+    DWORD mask;
++    unsigned long mask;
 +    ARENA_FREE *arena;
      SUBHEAP *subheap;
 -    struct list *ptr;
@@ -407,9 +445,7 @@ index 4fe11fe2b48..de33fcce4bb 100644
          {
 -            subheap = HEAP_FindSubHeap( heap, pArena );
 -            if (!HEAP_Commit( subheap, (ARENA_INUSE *)pArena, size )) return NULL;
-+            DWORD ctz;
-+            BitScanForward( &ctz, mask );
-+            index = (index & ~(HEAP_FREEMASK_BLOCK - 1)) | ctz;
++            index = (index & ~(HEAP_FREEMASK_BLOCK - 1)) | ctzl( mask );
 +            arena = LIST_ENTRY( heap->freeList[index].next, ARENA_FREE, entry.list );
 +            subheap = HEAP_FindSubHeap( heap, arena );
 +            if (!HEAP_Commit( subheap, (ARENA_INUSE *)arena, size )) return NULL;
@@ -432,7 +468,7 @@ index 4fe11fe2b48..de33fcce4bb 100644
      }
  
      /* If no block was found, attempt to grow the heap */
-@@ -1070,13 +1175,10 @@ static ARENA_FREE *HEAP_FindFreeBlock( HEAP *heap, SIZE_T size,
+@@ -1075,13 +1195,10 @@ static ARENA_FREE *HEAP_FindFreeBlock( HEAP *heap, SIZE_T size,
   */
  static BOOL HEAP_IsValidArenaPtr( const HEAP *heap, const ARENA_FREE *ptr )
  {
@@ -446,7 +482,7 @@ index 4fe11fe2b48..de33fcce4bb 100644
      return FALSE;
  }
  
-@@ -1088,7 +1190,7 @@ static BOOL HEAP_ValidateFreeArena( SUBHEAP *subheap, ARENA_FREE *pArena )
+@@ -1093,7 +1210,7 @@ static BOOL HEAP_ValidateFreeArena( SUBHEAP *subheap, ARENA_FREE *pArena )
  {
      DWORD flags = subheap->heap->flags;
      SIZE_T size;
@@ -455,7 +491,7 @@ index 4fe11fe2b48..de33fcce4bb 100644
      char *heapEnd = (char *)subheap->base + subheap->size;
  
      /* Check for unaligned pointers */
-@@ -1105,7 +1207,8 @@ static BOOL HEAP_ValidateFreeArena( SUBHEAP *subheap, ARENA_FREE *pArena )
+@@ -1110,7 +1227,8 @@ static BOOL HEAP_ValidateFreeArena( SUBHEAP *subheap, ARENA_FREE *pArena )
          return FALSE;
      }
      /* Check size flags */
@@ -465,7 +501,7 @@ index 4fe11fe2b48..de33fcce4bb 100644
          (pArena->size & ARENA_FLAG_PREV_FREE))
      {
          ERR("Heap %p: bad flags %08x for free arena %p\n",
-@@ -1119,34 +1222,45 @@ static BOOL HEAP_ValidateFreeArena( SUBHEAP *subheap, ARENA_FREE *pArena )
+@@ -1124,34 +1242,45 @@ static BOOL HEAP_ValidateFreeArena( SUBHEAP *subheap, ARENA_FREE *pArena )
          ERR("Heap %p: bad size %08lx for free arena %p\n", subheap->heap, size, pArena );
          return FALSE;
      }
@@ -520,5 +556,5 @@ index 4fe11fe2b48..de33fcce4bb 100644
              subheap->heap, prev, pArena );
          return FALSE;
 -- 
-2.27.0
+2.24.0.rc1
 
diff --git a/patches/ntdll-Hide_Wine_Exports/0001-ntdll-Add-support-for-hiding-wine-version-informatio.patch b/patches/ntdll-Hide_Wine_Exports/0001-ntdll-Add-support-for-hiding-wine-version-informatio.patch
index a7987234..717be1db 100644
--- a/patches/ntdll-Hide_Wine_Exports/0001-ntdll-Add-support-for-hiding-wine-version-informatio.patch
+++ b/patches/ntdll-Hide_Wine_Exports/0001-ntdll-Add-support-for-hiding-wine-version-informatio.patch
@@ -1,19 +1,27 @@
-From 7bbbf2acdaa6229c58b42001fa01465e2e0cdbb5 Mon Sep 17 00:00:00 2001
+From 6c463b0bd58fb0830271582e5dd916f936084daf Mon Sep 17 00:00:00 2001
 From: Sebastian Lackner <sebastian@fds-team.de>
 Date: Sat, 30 May 2015 02:23:15 +0200
 Subject: [PATCH] ntdll: Add support for hiding wine version information from
  applications.
 
 ---
- dlls/ntdll/loader.c     | 99 ++++++++++++++++++++++++++++++++++++++++-
- dlls/ntdll/ntdll_misc.h |  5 +++
- 2 files changed, 103 insertions(+), 1 deletion(-)
+ dlls/ntdll/loader.c     | 100 +++++++++++++++++++++++++++++++++++++++-
+ dlls/ntdll/ntdll_misc.h |   5 ++
+ 2 files changed, 104 insertions(+), 1 deletion(-)
 
 diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
-index bff0bda1bed..fc8c815fb39 100644
+index 926098ebf50a..4cf7fed9e1b2 100644
 --- a/dlls/ntdll/loader.c
 +++ b/dlls/ntdll/loader.c
-@@ -82,6 +82,9 @@ static const WCHAR system_path[] =
+@@ -78,6 +78,7 @@ const WCHAR system_dir[] = {'C',':','\\','w','i','n','d','o','w','s','\\',
+ const WCHAR syswow64_dir[] = {'C',':','\\','w','i','n','d','o','w','s','\\',
+                               's','y','s','w','o','w','6','4','\\',0};
+ 
++
+ /* system search path */
+ static const WCHAR system_path[] =
+     {'C',':','\\','w','i','n','d','o','w','s','\\','s','y','s','t','e','m','3','2',';',
+@@ -85,6 +86,9 @@ static const WCHAR system_path[] =
  
  static const WCHAR dotW[] = {'.',0};
  
@@ -23,7 +31,7 @@ index bff0bda1bed..fc8c815fb39 100644
  static BOOL imports_fixup_done = FALSE;  /* set once the imports have been fixed up, before attaching them */
  static BOOL process_detaching = FALSE;  /* set on process detach to avoid deadlocks with thread detach */
  static int free_lib_count;   /* recursion depth of LdrUnloadDll calls */
-@@ -98,6 +101,8 @@ struct dll_dir_entry
+@@ -101,6 +105,8 @@ struct dll_dir_entry
  
  static struct list dll_dir_list = LIST_INIT( dll_dir_list );  /* extra dirs from LdrAddDllDirectory */
  
@@ -32,7 +40,7 @@ index bff0bda1bed..fc8c815fb39 100644
  struct ldr_notification
  {
      struct list                    entry;
-@@ -1809,6 +1814,96 @@ NTSTATUS WINAPI LdrUnlockLoaderLock( ULONG flags, ULONG_PTR magic )
+@@ -1872,6 +1878,96 @@ NTSTATUS WINAPI LdrUnlockLoaderLock( ULONG flags, ULONG_PTR magic )
  }
  
  
@@ -120,16 +128,16 @@ index bff0bda1bed..fc8c815fb39 100644
 + */
 +static BOOL is_hidden_export( void *proc )
 +{
-+    return hide_wine_exports && (proc == &wine_get_version ||
-+                                 proc == &wine_get_build_id ||
-+                                 proc == &wine_get_host_version);
++    return hide_wine_exports && (proc == &NTDLL_wine_get_version ||
++                                 proc == &NTDLL_wine_get_build_id ||
++                                 proc == &NTDLL_wine_get_host_version);
 +}
 +
 +
  /******************************************************************
   *		LdrGetProcedureAddress  (NTDLL.@)
   */
-@@ -1829,7 +1924,7 @@ NTSTATUS WINAPI LdrGetProcedureAddress(HMODULE module, const ANSI_STRING *name,
+@@ -1892,7 +1988,7 @@ NTSTATUS WINAPI LdrGetProcedureAddress(HMODULE module, const ANSI_STRING *name,
          LPCWSTR load_path = NtCurrentTeb()->Peb->ProcessParameters->DllPath.Buffer;
          void *proc = name ? find_named_export( module, exports, exp_size, name->Buffer, -1, load_path )
                            : find_ordinal_export( module, exports, exp_size, ord - exports->Base, load_path );
@@ -138,31 +146,31 @@ index bff0bda1bed..fc8c815fb39 100644
          {
              *address = proc;
              ret = STATUS_SUCCESS;
-@@ -4261,6 +4356,8 @@ static NTSTATUS process_init(void)
+@@ -4739,6 +4835,8 @@ void __wine_process_init(void)
          NtTerminateProcess( GetCurrentProcess(), status );
      }
  
 +    hidden_exports_init( wm->ldr.FullDllName.Buffer );
 +
- #ifndef _WIN64
-     if (NtCurrentTeb64())
-     {
+     virtual_set_large_address_space();
+ 
+     /* elevate process if necessary */
 diff --git a/dlls/ntdll/ntdll_misc.h b/dlls/ntdll/ntdll_misc.h
-index 1f7226a3ac8..56d26bfe005 100644
+index 7d631cb33ddb..8256ec710a00 100644
 --- a/dlls/ntdll/ntdll_misc.h
 +++ b/dlls/ntdll/ntdll_misc.h
-@@ -155,6 +155,11 @@ static inline TEB64 *NtCurrentTeb64(void) { return (TEB64 *)NtCurrentTeb()->GdiB
- 
- NTSTATUS WINAPI RtlHashUnicodeString(PCUNICODE_STRING,BOOLEAN,ULONG,ULONG*);
+@@ -347,6 +347,11 @@ void     WINAPI LdrInitializeThunk(CONTEXT*,void**,ULONG_PTR,ULONG_PTR);
+ #define InterlockedCompareExchange64(dest,xchg,cmp) RtlInterlockedCompareExchange64(dest,xchg,cmp)
+ #endif
  
 +/* version */
-+extern const char * CDECL wine_get_version(void);
-+extern const char * CDECL wine_get_build_id(void);
-+extern void CDECL wine_get_host_version( const char **sysname, const char **release );
++extern const char * CDECL NTDLL_wine_get_version(void);
++extern const char * CDECL NTDLL_wine_get_build_id(void);
++extern void CDECL NTDLL_wine_get_host_version( const char **sysname, const char **release );
 +
- /* convert from straight ASCII to Unicode without depending on the current codepage */
- static inline void ascii_to_unicode( WCHAR *dst, const char *src, size_t len )
- {
+ /* process / thread time */
+ extern BOOL read_process_time(int unix_pid, int unix_tid, unsigned long clk_tck,
+                               LARGE_INTEGER *kernel, LARGE_INTEGER *user) DECLSPEC_HIDDEN;
 -- 
-2.28.0
+2.26.2
 
diff --git a/patches/ntdll-Hide_Wine_Exports/definition b/patches/ntdll-Hide_Wine_Exports/definition
index e799d1a4..52e3041b 100644
--- a/patches/ntdll-Hide_Wine_Exports/definition
+++ b/patches/ntdll-Hide_Wine_Exports/definition
@@ -1 +1,3 @@
 Fixes: [38656] Add support for hiding wine version information from applications
+Depends: ntdll-ThreadTime
+Depends: advapi32-Token_Integrity_Level
diff --git a/patches/ntdll-Interrupt-0x2e/0001-ntdll-Catch-windows-int-0x2e-syscall-on-i386.patch b/patches/ntdll-Interrupt-0x2e/0001-ntdll-Catch-windows-int-0x2e-syscall-on-i386.patch
index 9b7aab80..ef159570 100644
--- a/patches/ntdll-Interrupt-0x2e/0001-ntdll-Catch-windows-int-0x2e-syscall-on-i386.patch
+++ b/patches/ntdll-Interrupt-0x2e/0001-ntdll-Catch-windows-int-0x2e-syscall-on-i386.patch
@@ -1,22 +1,22 @@
-From a35e75bfe3a6358885e756396c8597d7b60be6e5 Mon Sep 17 00:00:00 2001
+From f15c706847288555a76b3827b09691b23d7ec57d Mon Sep 17 00:00:00 2001
 From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
 Date: Sun, 19 Mar 2017 19:08:34 +0100
 Subject: [PATCH] ntdll: Catch windows int 0x2e syscall on i386.
 
 ---
- dlls/ntdll/unix/signal_i386.c | 5 +++++
+ dlls/ntdll/signal_i386.c | 5 +++++
  1 file changed, 5 insertions(+)
 
-diff --git a/dlls/ntdll/unix/signal_i386.c b/dlls/ntdll/unix/signal_i386.c
-index 60a47d53ba8..5cc92ab0ced 100644
---- a/dlls/ntdll/unix/signal_i386.c
-+++ b/dlls/ntdll/unix/signal_i386.c
-@@ -1749,6 +1749,11 @@ static BOOL handle_interrupt( unsigned int interrupt, ucontext_t *sigcontext, vo
-         rec->ExceptionInformation[2] = context->Edx;
-         setup_raise_exception( sigcontext, stack, rec, xcontext );
+diff --git a/dlls/ntdll/signal_i386.c b/dlls/ntdll/signal_i386.c
+index 8d1c59150..ca2c67333 100644
+--- a/dlls/ntdll/signal_i386.c
++++ b/dlls/ntdll/signal_i386.c
+@@ -1946,6 +1946,11 @@ static BOOL handle_interrupt( unsigned int interrupt, ucontext_t *sigcontext, st
+         stack->rec.ExceptionInformation[2] = stack->context.Edx;
+         setup_raise_exception( sigcontext, stack );
          return TRUE;
 +    case 0x2e:
-+        FIXME("unimplemented syscall handler for %#x\n", context->Eax);
++        FIXME("unimplemented syscall handler for %#lx\n", stack->context.Eax);
 +        EAX_sig(sigcontext) = STATUS_INVALID_SYSTEM_SERVICE;
 +        EIP_sig(sigcontext) += 2;
 +        return TRUE;
@@ -24,5 +24,5 @@ index 60a47d53ba8..5cc92ab0ced 100644
          return FALSE;
      }
 -- 
-2.28.0
+2.26.2
 
diff --git a/patches/ntdll-Junction_Points/0001-ntdll-Add-support-for-junction-point-creation.patch b/patches/ntdll-Junction_Points/0001-ntdll-Add-support-for-junction-point-creation.patch
index 8c82c0ad..b985908e 100644
--- a/patches/ntdll-Junction_Points/0001-ntdll-Add-support-for-junction-point-creation.patch
+++ b/patches/ntdll-Junction_Points/0001-ntdll-Add-support-for-junction-point-creation.patch
@@ -1,4 +1,4 @@
-From d81e8108c6c13eb865b9588eca19a777b6e22986 Mon Sep 17 00:00:00 2001
+From e171bdbabedaeaafc0181ee156bf08ef180809da Mon Sep 17 00:00:00 2001
 From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
 Date: Thu, 16 Jan 2014 20:56:49 -0700
 Subject: [PATCH] ntdll: Add support for junction point creation.
@@ -6,18 +6,22 @@ Subject: [PATCH] ntdll: Add support for junction point creation.
 Signed-off-by: Erich E. Hoover <erich.e.hoover@gmail.com>
 ---
  configure.ac            |   2 +
- dlls/ntdll/tests/file.c | 101 +++++++++++++++++++++++++
- dlls/ntdll/unix/file.c  | 159 ++++++++++++++++++++++++++++++++++++++++
+ dlls/ntdll/file.c       | 118 ++++++++++++++++++++++++++++++++++++++++
+ dlls/ntdll/tests/file.c | 101 ++++++++++++++++++++++++++++++++++
  include/Makefile.in     |   1 +
- include/ntifs.h         |  42 +++++++++++
- 5 files changed, 305 insertions(+)
+ include/ntifs.h         |  42 ++++++++++++++
+ include/wine/port.h     |   9 +++
+ libs/port/Makefile.in   |   1 +
+ libs/port/renameat2.c   |  55 +++++++++++++++++++
+ 8 files changed, 329 insertions(+)
  create mode 100644 include/ntifs.h
+ create mode 100644 libs/port/renameat2.c
 
 diff --git a/configure.ac b/configure.ac
-index cf3df03cc9..ed2ebcd653 100644
+index 816e3684510..a1b6096b9b7 100644
 --- a/configure.ac
 +++ b/configure.ac
-@@ -2210,6 +2210,8 @@ AC_CHECK_FUNCS(\
+@@ -2202,6 +2202,8 @@ AC_CHECK_FUNCS(\
  	pwrite \
  	readdir \
  	readlink \
@@ -26,8 +30,158 @@ index cf3df03cc9..ed2ebcd653 100644
  	sched_yield \
  	select \
  	setproctitle \
+diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
+index 013706889bb..37dca75651c 100644
+--- a/dlls/ntdll/file.c
++++ b/dlls/ntdll/file.c
+@@ -21,6 +21,7 @@
+ 
+ #include <stdlib.h>
+ #include <string.h>
++#include <libgen.h>
+ #include <stdio.h>
+ #include <errno.h>
+ #include <assert.h>
+@@ -109,6 +110,7 @@
+ #include "ddk/ntddser.h"
+ #define WINE_MOUNTMGR_EXTENSIONS
+ #include "ddk/mountmgr.h"
++#include "ntifs.h"
+ 
+ WINE_DEFAULT_DEBUG_CHANNEL(ntdll);
+ WINE_DECLARE_DEBUG_CHANNEL(winediag);
+@@ -1663,6 +1665,104 @@ NTSTATUS WINAPI NtDeviceIoControlFile(HANDLE handle, HANDLE event,
+ }
+ 
+ 
++/*
++ * Retrieve the unix name corresponding to a file handle, remove that directory, and then symlink the
++ * requested directory to the location of the old directory.
++ */
++NTSTATUS FILE_CreateSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer)
++{
++    BOOL src_allocated = FALSE, dest_allocated = FALSE, tempdir_created = FALSE;
++    int dest_len = buffer->MountPointReparseBuffer.SubstituteNameLength;
++    int offset = buffer->MountPointReparseBuffer.SubstituteNameOffset;
++    WCHAR *dest = &buffer->MountPointReparseBuffer.PathBuffer[offset];
++    char tmpdir[PATH_MAX], tmplink[PATH_MAX], *d;
++    ANSI_STRING unix_src, unix_dest;
++    char magic_dest[PATH_MAX];
++    int dest_fd, needs_close;
++    UNICODE_STRING nt_dest;
++    NTSTATUS status;
++    int i;
++
++    if ((status = server_get_unix_fd( handle, FILE_SPECIAL_ACCESS, &dest_fd, &needs_close, NULL, NULL )))
++        return status;
++
++    if ((status = server_get_unix_name( handle, &unix_src )))
++        goto cleanup;
++    src_allocated = TRUE;
++    nt_dest.Buffer = dest;
++    nt_dest.Length = dest_len;
++    status = wine_nt_to_unix_file_name( &nt_dest, &unix_dest, 0, FALSE );
++    if (status != STATUS_SUCCESS && status != STATUS_NO_SUCH_FILE)
++        goto cleanup;
++    dest_allocated = TRUE;
++
++    TRACE("Linking %s to %s\n", unix_src.Buffer, unix_dest.Buffer);
++
++    /* Encode the reparse tag into the symlink */
++    strcpy( magic_dest, "/" );
++    for (i = 0; i < sizeof(ULONG)*8; i++)
++    {
++        if ((buffer->ReparseTag >> i) & 1)
++            strcat( magic_dest, "." );
++        strcat( magic_dest, "/" );
++    }
++    strcat( magic_dest, unix_dest.Buffer );
++
++    /* Produce the link in a temporary location in the same folder */
++    strcpy( tmpdir, unix_src.Buffer );
++    d = dirname( tmpdir);
++    if (d != tmpdir) strcpy( tmpdir, d );
++    strcat( tmpdir, "/.winelink.XXXXXX" );
++    if (mkdtemp( tmpdir ) == NULL)
++    {
++        status = FILE_GetNtStatus();
++        goto cleanup;
++    }
++    tempdir_created = TRUE;
++    strcpy( tmplink, tmpdir );
++    strcat( tmplink, "/tmplink" );
++    if (symlink( magic_dest, tmplink ))
++    {
++        status = FILE_GetNtStatus();
++        goto cleanup;
++    }
++    /* Atomically move the link into position */
++    if (!renameat2( -1, tmplink, -1, unix_src.Buffer, RENAME_EXCHANGE ))
++    {
++        /* success: link and folder have switched locations */
++        rmdir( tmplink ); /* remove the folder (at link location) */
++    }
++    else if (errno == ENOSYS)
++    {
++        FIXME( "Atomic exchange of directory with symbolic link unsupported on this system, "
++               "using unsafe exchange instead.\n" );
++        if (rmdir( unix_src.Buffer ))
++        {
++            status = FILE_GetNtStatus();
++            goto cleanup;
++        }
++        if (rename( tmplink, unix_src.Buffer ))
++        {
++            status = FILE_GetNtStatus();
++            goto cleanup; /* not moved, orignal file/folder at destination is orphaned */
++        }
++    }
++    else
++    {
++        status = FILE_GetNtStatus();
++        goto cleanup;
++    }
++    status = STATUS_SUCCESS;
++
++cleanup:
++    if (tempdir_created) rmdir( tmpdir );
++    if (dest_allocated) RtlFreeAnsiString( &unix_dest );
++    if (src_allocated) RtlFreeAnsiString( &unix_src );
++    if (needs_close) close( dest_fd );
++    return status;
++}
++
++
+ /**************************************************************************
+  *              NtFsControlFile                 [NTDLL.@]
+  *              ZwFsControlFile                 [NTDLL.@]
+@@ -1747,6 +1847,24 @@ NTSTATUS WINAPI NtFsControlFile(HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc
+         io->Information = 0;
+         status = STATUS_SUCCESS;
+         break;
++
++    case FSCTL_SET_REPARSE_POINT:
++    {
++        REPARSE_DATA_BUFFER *buffer = (REPARSE_DATA_BUFFER *)in_buffer;
++
++        switch(buffer->ReparseTag)
++        {
++        case IO_REPARSE_TAG_MOUNT_POINT:
++            status = FILE_CreateSymlink( handle, buffer );
++            break;
++        default:
++            FIXME("stub: FSCTL_SET_REPARSE_POINT(%x)\n", buffer->ReparseTag);
++            status = STATUS_NOT_IMPLEMENTED;
++            break;
++        }
++        break;
++    }
++
+     default:
+         return server_ioctl_file( handle, event, apc, apc_context, io, code,
+                                   in_buffer, in_size, out_buffer, out_size );
 diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
-index 1492797b0c..10bdef5d81 100644
+index 31c18454f0e..046b49c2d2b 100644
 --- a/dlls/ntdll/tests/file.c
 +++ b/dlls/ntdll/tests/file.c
 @@ -38,6 +38,7 @@
@@ -38,8 +192,8 @@ index 1492797b0c..10bdef5d81 100644
  
  #ifndef IO_COMPLETION_ALL_ACCESS
  #define IO_COMPLETION_ALL_ACCESS 0x001F0003
-@@ -5141,6 +5142,105 @@ static void test_mailslot_name(void)
-     CloseHandle( device );
+@@ -4953,6 +4954,105 @@ static void test_file_readonly_access(void)
+     DeleteFileW(path);
  }
  
 +static INT build_reparse_buffer(const WCHAR *filename, REPARSE_DATA_BUFFER **pbuffer)
@@ -144,223 +298,17 @@ index 1492797b0c..10bdef5d81 100644
  START_TEST(file)
  {
      HMODULE hkernel32 = GetModuleHandleA("kernel32.dll");
-@@ -5213,5 +5313,6 @@ START_TEST(file)
+@@ -5023,4 +5123,5 @@ START_TEST(file)
+     test_query_attribute_information_file();
      test_ioctl();
-     test_query_ea();
      test_flush_buffers_file();
 +    test_reparse_points();
-     test_mailslot_name();
- }
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index 290e18e54c..c0a3dee181 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -36,6 +36,7 @@
- #include <string.h>
- #include <stdlib.h>
- #include <stdio.h>
-+#include <libgen.h>
- #include <limits.h>
- #ifdef HAVE_MNTENT_H
- #include <mntent.h>
-@@ -132,6 +133,7 @@
- #include "wine/list.h"
- #include "wine/debug.h"
- #include "unix_private.h"
-+#include "ntifs.h"
- 
- WINE_DEFAULT_DEBUG_CHANNEL(file);
- WINE_DECLARE_DEBUG_CHANNEL(winediag);
-@@ -146,6 +148,10 @@ WINE_DECLARE_DEBUG_CHANNEL(winediag);
- #undef EXT2_IOC_GETFLAGS
- #undef EXT4_CASEFOLD_FL
- 
-+#ifndef RENAME_EXCHANGE
-+#define RENAME_EXCHANGE		(1 << 1)
-+#endif
-+
- #ifdef linux
- 
- /* We want the real kernel dirent structure, not the libc one */
-@@ -457,6 +463,32 @@ static int xattr_set( const char *path, const char *name, void *value, size_t si
- #endif
- }
- 
-+#ifndef HAVE_RENAMEAT
-+int renameat( int olddirfd, const char *oldpath, int newdirfd, const char *newpath )
-+{
-+    errno = ENOSYS;
-+    return -1;
-+}
-+#endif
-+
-+#ifndef HAVE_RENAMEAT2
-+int renameat2( int olddirfd, const char *oldpath, int newdirfd, const char *newpath,
-+               unsigned int flags )
-+{
-+    if (flags == 0)
-+        return renameat( olddirfd, oldpath, newdirfd, newpath );
-+#if defined(__NR_renameat2)
-+    return syscall( __NR_renameat2, olddirfd, oldpath, newdirfd, newpath, flags );
-+#elif defined(RENAME_SWAP)
-+    return renameatx_np(olddirfd, oldpath, newdirfd, newpath,
-+                        (flags & RENAME_EXCHANGE ? RENAME_SWAP : 0));
-+#else
-+    errno = ENOSYS;
-+    return -1;
-+#endif
-+}
-+#endif /* HAVE_RENAMEAT2 */
-+
- /* get space from the current directory data buffer, allocating a new one if necessary */
- static void *get_dir_data_space( struct dir_data *data, unsigned int size )
- {
-@@ -5731,6 +5763,116 @@ static void ignore_server_ioctl_struct_holes( ULONG code, const void *in_buffer,
  }
- 
- 
-+/*
-+ * Retrieve the unix name corresponding to a file handle, remove that directory, and then symlink
-+ * the requested directory to the location of the old directory.
-+ */
-+NTSTATUS FILE_CreateSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer)
-+{
-+    BOOL src_allocated = FALSE, dest_allocated = FALSE, tempdir_created = FALSE;
-+    int dest_len = buffer->MountPointReparseBuffer.SubstituteNameLength;
-+    int offset = buffer->MountPointReparseBuffer.SubstituteNameOffset;
-+    WCHAR *dest = &buffer->MountPointReparseBuffer.PathBuffer[offset];
-+    char tmpdir[PATH_MAX], tmplink[PATH_MAX], *d;
-+    SIZE_T unix_dest_len = PATH_MAX;
-+    char *unix_src, *unix_dest;
-+    char magic_dest[PATH_MAX];
-+    int dest_fd, needs_close;
-+    UNICODE_STRING nt_dest;
-+    NTSTATUS status;
-+    int i;
-+
-+    if ((status = server_get_unix_fd( handle, FILE_SPECIAL_ACCESS, &dest_fd, &needs_close, NULL, NULL )))
-+        return status;
-+
-+    if ((status = server_get_unix_name( handle, &unix_src )))
-+        goto cleanup;
-+    src_allocated = TRUE;
-+    nt_dest.Buffer = dest;
-+    nt_dest.Length = dest_len;
-+    for (;;)
-+    {
-+        unix_dest = malloc( unix_dest_len );
-+        if (!unix_dest)
-+        {
-+            status = STATUS_NO_MEMORY;
-+            goto cleanup;
-+        }
-+        status = wine_nt_to_unix_file_name( &nt_dest, unix_dest, &unix_dest_len, FALSE );
-+        if (status != STATUS_BUFFER_TOO_SMALL) break;
-+        free( unix_dest );
-+    }
-+    if (status != STATUS_SUCCESS && status != STATUS_NO_SUCH_FILE)
-+        goto cleanup;
-+    dest_allocated = TRUE;
-+
-+    TRACE( "Linking %s to %s\n", unix_src, unix_dest );
-+
-+    /* Encode the reparse tag into the symlink */
-+    strcpy( magic_dest, "/" );
-+    for (i = 0; i < sizeof(ULONG)*8; i++)
-+    {
-+        if ((buffer->ReparseTag >> i) & 1)
-+            strcat( magic_dest, "." );
-+        strcat( magic_dest, "/" );
-+    }
-+    strcat( magic_dest, unix_dest );
-+
-+    /* Produce the link in a temporary location in the same folder */
-+    strcpy( tmpdir, unix_src );
-+    d = dirname( tmpdir);
-+    if (d != tmpdir) strcpy( tmpdir, d );
-+    strcat( tmpdir, "/.winelink.XXXXXX" );
-+    if (mkdtemp( tmpdir ) == NULL)
-+    {
-+        status = errno_to_status( errno );
-+        goto cleanup;
-+    }
-+    tempdir_created = TRUE;
-+    strcpy( tmplink, tmpdir );
-+    strcat( tmplink, "/tmplink" );
-+    if (symlink( magic_dest, tmplink ))
-+    {
-+        status = errno_to_status( errno );
-+        goto cleanup;
-+    }
-+    /* Atomically move the link into position */
-+    if (!renameat2( -1, tmplink, -1, unix_src, RENAME_EXCHANGE ))
-+    {
-+        /* success: link and folder have switched locations */
-+        rmdir( tmplink ); /* remove the folder (at link location) */
-+    }
-+    else if (errno == ENOSYS)
-+    {
-+        FIXME( "Atomic exchange of directory with symbolic link unsupported on this system, "
-+               "using unsafe exchange instead.\n" );
-+        if (rmdir( unix_src ))
-+        {
-+            status = errno_to_status( errno );
-+            goto cleanup;
-+        }
-+        if (rename( tmplink, unix_src ))
-+        {
-+            status = errno_to_status( errno );
-+            goto cleanup; /* not moved, orignal file/folder at destination is orphaned */
-+        }
-+    }
-+    else
-+    {
-+        status = errno_to_status( errno );
-+        goto cleanup;
-+    }
-+    status = STATUS_SUCCESS;
-+
-+cleanup:
-+    if (tempdir_created) rmdir( tmpdir );
-+    if (dest_allocated) free( unix_dest );
-+    if (src_allocated) free( unix_src );
-+    if (needs_close) close( dest_fd );
-+    return status;
-+}
-+
-+
- /******************************************************************************
-  *              NtFsControlFile   (NTDLL.@)
-  */
-@@ -5813,6 +5955,23 @@ NTSTATUS WINAPI NtFsControlFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE ap
-         break;
-     }
- 
-+    case FSCTL_SET_REPARSE_POINT:
-+    {
-+        REPARSE_DATA_BUFFER *buffer = (REPARSE_DATA_BUFFER *)in_buffer;
-+
-+        switch(buffer->ReparseTag)
-+        {
-+        case IO_REPARSE_TAG_MOUNT_POINT:
-+            status = FILE_CreateSymlink( handle, buffer );
-+            break;
-+        default:
-+            FIXME("stub: FSCTL_SET_REPARSE_POINT(%x)\n", buffer->ReparseTag);
-+            status = STATUS_NOT_IMPLEMENTED;
-+            break;
-+        }
-+        break;
-+    }
-+
-     case FSCTL_SET_SPARSE:
-         TRACE("FSCTL_SET_SPARSE: Ignoring request\n");
-         io->Information = 0;
 diff --git a/include/Makefile.in b/include/Makefile.in
-index 91a02645c3..9345b75c00 100644
+index 9796dd8e5d9..410ae718e99 100644
 --- a/include/Makefile.in
 +++ b/include/Makefile.in
-@@ -523,6 +523,7 @@ SOURCES = \
+@@ -517,6 +517,7 @@ SOURCES = \
  	ntddvdeo.h \
  	ntdef.h \
  	ntdsapi.h \
@@ -370,7 +318,7 @@ index 91a02645c3..9345b75c00 100644
  	ntsecapi.h \
 diff --git a/include/ntifs.h b/include/ntifs.h
 new file mode 100644
-index 0000000000..21d42e1732
+index 00000000000..21d42e17325
 --- /dev/null
 +++ b/include/ntifs.h
 @@ -0,0 +1,42 @@
@@ -416,6 +364,99 @@ index 0000000000..21d42e1732
 +} REPARSE_DATA_BUFFER, *PREPARSE_DATA_BUFFER;
 +
 +#endif /* __WINE_NTIFS_H */
+diff --git a/include/wine/port.h b/include/wine/port.h
+index 928730a41d7..e8434c73cca 100644
+--- a/include/wine/port.h
++++ b/include/wine/port.h
+@@ -334,6 +334,15 @@ double rint(double x);
+ float rintf(float x);
+ #endif
+ 
++#ifndef RENAME_EXCHANGE
++#define RENAME_EXCHANGE (1 << 1)
++#endif /* RENAME_EXCHANGE */
++
++#ifndef HAVE_RENAMEAT2
++int renameat2( int olddirfd, const char *oldpath, int newdirfd, const char *newpath,
++               unsigned int flags );
++#endif /* HAVE_RENAMEAT2 */
++
+ #ifndef HAVE_STATVFS
+ int statvfs( const char *path, struct statvfs *buf );
+ #endif
+diff --git a/libs/port/Makefile.in b/libs/port/Makefile.in
+index 7bc67fa3fee..1963afe2423 100644
+--- a/libs/port/Makefile.in
++++ b/libs/port/Makefile.in
+@@ -14,6 +14,7 @@ C_SRCS = \
+ 	pread.c \
+ 	pwrite.c \
+ 	readlink.c \
++	renameat2.c \
+ 	rint.c \
+ 	spawn.c \
+ 	statvfs.c \
+diff --git a/libs/port/renameat2.c b/libs/port/renameat2.c
+new file mode 100644
+index 00000000000..f46f407ec71
+--- /dev/null
++++ b/libs/port/renameat2.c
+@@ -0,0 +1,55 @@
++/*
++ * renameat2 function
++ *
++ * Copyright 2015-2019 Erich E. Hoover
++ *
++ * This library is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU Lesser General Public
++ * License as published by the Free Software Foundation; either
++ * version 2.1 of the License, or (at your option) any later version.
++ *
++ * This library is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * Lesser General Public License for more details.
++ *
++ * You should have received a copy of the GNU Lesser General Public
++ * License along with this library; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
++ */
++
++#include "config.h"
++#include "wine/port.h"
++
++#ifdef HAVE_SYS_SYSCALL_H
++# include <sys/syscall.h>
++#endif
++
++#include <errno.h>
++#include <stdio.h>
++
++#ifndef HAVE_RENAMEAT
++int renameat( int olddirfd, const char *oldpath, int newdirfd, const char *newpath )
++{
++    errno = ENOSYS;
++    return -1;
++}
++#endif
++
++#ifndef HAVE_RENAMEAT2
++int renameat2( int olddirfd, const char *oldpath, int newdirfd, const char *newpath,
++               unsigned int flags )
++{
++    if (flags == 0)
++        return renameat( olddirfd, oldpath, newdirfd, newpath );
++#if defined(__NR_renameat2)
++    return syscall( __NR_renameat2, olddirfd, oldpath, newdirfd, newpath, flags );
++#elif defined(RENAME_SWAP)
++    return renameatx_np(olddirfd, oldpath, newdirfd, newpath,
++                        (flags & RENAME_EXCHANGE ? RENAME_SWAP : 0));
++#else
++    errno = ENOSYS;
++    return -1;
++#endif
++}
++#endif /* HAVE_RENAMEAT2 */
 -- 
-2.28.0
+2.26.2
 
diff --git a/patches/ntdll-Junction_Points/0002-ntdll-Add-support-for-reading-junction-points.patch b/patches/ntdll-Junction_Points/0002-ntdll-Add-support-for-reading-junction-points.patch
index 7e7cdee5..87435fe7 100644
--- a/patches/ntdll-Junction_Points/0002-ntdll-Add-support-for-reading-junction-points.patch
+++ b/patches/ntdll-Junction_Points/0002-ntdll-Add-support-for-reading-junction-points.patch
@@ -1,53 +1,19 @@
-From 1c6eed5d7c8a60fb7f6a9ada5345ef2dc0c6e9ad Mon Sep 17 00:00:00 2001
+From daf6a4fc8ae19ab9f9df39f958109c09232b5426 Mon Sep 17 00:00:00 2001
 From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
 Date: Thu, 16 Jan 2014 20:57:57 -0700
-Subject: ntdll: Add support for reading junction points.
+Subject: [PATCH] ntdll: Add support for reading junction points.
 
 Signed-off-by: Erich E. Hoover <erich.e.hoover@gmail.com>
 ---
- dlls/ntdll/tests/file.c |  14 ++++-
- dlls/ntdll/unix/file.c  | 119 ++++++++++++++++++++++++++++++++++++++++
- 2 files changed, 132 insertions(+), 1 deletion(-)
+ dlls/ntdll/file.c       | 106 ++++++++++++++++++++++++++++++++++++++++
+ dlls/ntdll/tests/file.c |  14 +++++-
+ 2 files changed, 119 insertions(+), 1 deletion(-)
 
-diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
-index 43cf99e8e74..4fe94f58bf1 100644
---- a/dlls/ntdll/tests/file.c
-+++ b/dlls/ntdll/tests/file.c
-@@ -5009,9 +5009,10 @@ static void test_reparse_points(void)
-     static const WCHAR dotW[] = {'.',0};
-     REPARSE_DATA_BUFFER *buffer = NULL;
-     DWORD dwret, dwLen, dwFlags;
-+    INT buffer_len, string_len;
-     UNICODE_STRING nameW;
--    INT buffer_len;
-     HANDLE handle;
-+    WCHAR *dest;
-     BOOL bret;
- 
-     /* Create a temporary folder for the junction point tests */
-@@ -5059,6 +5060,17 @@ static void test_reparse_points(void)
-     buffer_len = build_reparse_buffer(nameW.Buffer, &buffer);
-     bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
-     ok(bret, "Failed to create junction point! (0x%x)\n", GetLastError());
-+
-+    /* Read back the junction point */
-+    HeapFree(GetProcessHeap(), 0, buffer);
-+    buffer_len = sizeof(*buffer) + MAX_PATH*sizeof(WCHAR);
-+    buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, buffer_len);
-+    bret = DeviceIoControl(handle, FSCTL_GET_REPARSE_POINT, NULL, 0, (LPVOID)buffer, buffer_len, &dwret, 0);
-+    ok(bret, "Failed to read junction point!\n");
-+    string_len = buffer->MountPointReparseBuffer.SubstituteNameLength;
-+    dest = &buffer->MountPointReparseBuffer.PathBuffer[buffer->MountPointReparseBuffer.SubstituteNameOffset/sizeof(WCHAR)];
-+    ok((memcmp(dest, nameW.Buffer, string_len) == 0), "Junction point destination does not match ('%s' != '%s')!\n",
-+                                                      wine_dbgstr_w(dest), wine_dbgstr_w(nameW.Buffer));
-     CloseHandle(handle);
- 
- cleanup:
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index 48e4c38b7ba..cd523dcd313 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -5704,6 +5704,119 @@ cleanup:
+diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
+index 37dca75651c..5a05217102d 100644
+--- a/dlls/ntdll/file.c
++++ b/dlls/ntdll/file.c
+@@ -1763,6 +1763,106 @@ cleanup:
  }
  
  
@@ -57,15 +23,13 @@ index 48e4c38b7ba..cd523dcd313 100644
 + */
 +NTSTATUS FILE_GetSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer, ULONG out_size)
 +{
-+    char *unix_src, unix_dest[PATH_MAX];
++    ANSI_STRING unix_src, unix_dest;
 +    VOID *subst_name, *print_name;
-+    SIZE_T nt_dest_len = PATH_MAX;
 +    BOOL dest_allocated = FALSE;
 +    int dest_fd, needs_close;
-+    int unix_dest_len;
++    UNICODE_STRING nt_dest;
 +    DWORD max_length;
 +    NTSTATUS status;
-+    WCHAR *nt_dest;
 +    INT prefix_len;
 +    ssize_t ret;
 +    char *p;
@@ -77,16 +41,19 @@ index 48e4c38b7ba..cd523dcd313 100644
 +    if ((status = server_get_unix_name( handle, &unix_src )))
 +        goto cleanup;
 +
-+    ret = readlink( unix_src, unix_dest, sizeof(unix_dest) );
++    unix_dest.Buffer = RtlAllocateHeap( GetProcessHeap(), 0, PATH_MAX );
++    unix_dest.MaximumLength = PATH_MAX;
++    dest_allocated = TRUE;
++    ret = readlink( unix_src.Buffer, unix_dest.Buffer, unix_dest.MaximumLength );
 +    if (ret < 0)
 +    {
-+        status = errno_to_status( errno );
++        status = FILE_GetNtStatus();
 +        goto cleanup;
 +    }
-+    unix_dest_len = ret;
++    unix_dest.Length = ret;
 +
 +    /* Decode the reparse tag from the symlink */
-+    p = unix_dest;
++    p = unix_dest.Buffer;
 +    if (*p++ != '/')
 +    {
 +        status = STATUS_NOT_IMPLEMENTED;
@@ -109,25 +76,11 @@ index 48e4c38b7ba..cd523dcd313 100644
 +        }
 +        buffer->ReparseTag |= (val << i);
 +    }
-+    unix_dest_len -= (p - unix_dest);
-+    memmove(unix_dest, p, unix_dest_len);
++    unix_dest.Length -= (p - unix_dest.Buffer);
++    memmove(unix_dest.Buffer, p, unix_dest.Length);
 +
-+    for (;;)
-+    {
-+        nt_dest = malloc( nt_dest_len * sizeof(WCHAR) );
-+        if (!nt_dest)
-+        {
-+            status = STATUS_NO_MEMORY;
-+            goto cleanup;
-+        }
-+        status = wine_unix_to_nt_file_name( unix_dest, nt_dest, &nt_dest_len );
-+        if (status != STATUS_BUFFER_TOO_SMALL) break;
-+        free( nt_dest );
-+    }
-+    dest_allocated = TRUE;
-+    if (status != STATUS_SUCCESS)
++    if ((status = wine_unix_to_nt_file_name( &unix_dest, &nt_dest )))
 +        goto cleanup;
-+    nt_dest_len *= sizeof(WCHAR);
 +
 +    prefix_len = strlen("\\??\\");
 +    switch(buffer->ReparseTag)
@@ -135,10 +88,10 @@ index 48e4c38b7ba..cd523dcd313 100644
 +    case IO_REPARSE_TAG_MOUNT_POINT:
 +        max_length = out_size-FIELD_OFFSET(typeof(*buffer), MountPointReparseBuffer.PathBuffer[1]);
 +        buffer->MountPointReparseBuffer.SubstituteNameOffset = 0;
-+        buffer->MountPointReparseBuffer.SubstituteNameLength = nt_dest_len;
++        buffer->MountPointReparseBuffer.SubstituteNameLength = nt_dest.Length;
 +        subst_name = &buffer->MountPointReparseBuffer.PathBuffer[buffer->MountPointReparseBuffer.SubstituteNameOffset/sizeof(WCHAR)];
-+        buffer->MountPointReparseBuffer.PrintNameOffset = nt_dest_len + sizeof(WCHAR);
-+        buffer->MountPointReparseBuffer.PrintNameLength = nt_dest_len - prefix_len*sizeof(WCHAR);
++        buffer->MountPointReparseBuffer.PrintNameOffset = nt_dest.Length + sizeof(WCHAR);
++        buffer->MountPointReparseBuffer.PrintNameLength = nt_dest.Length - prefix_len*sizeof(WCHAR);
 +        print_name = &buffer->MountPointReparseBuffer.PathBuffer[buffer->MountPointReparseBuffer.PrintNameOffset/sizeof(WCHAR)];
 +        break;
 +    default:
@@ -147,29 +100,29 @@ index 48e4c38b7ba..cd523dcd313 100644
 +        status = STATUS_NOT_IMPLEMENTED;
 +        goto cleanup;
 +    }
-+    if (nt_dest_len > max_length)
++    if (nt_dest.Length > max_length)
 +    {
 +        status = STATUS_BUFFER_TOO_SMALL;
 +        goto cleanup;
 +    }
 +
-+    memcpy( subst_name, nt_dest, nt_dest_len );
-+    memcpy( print_name, &nt_dest[prefix_len], nt_dest_len - prefix_len*sizeof(WCHAR) );
++    memcpy( subst_name, nt_dest.Buffer, nt_dest.Length );
++    memcpy( print_name, &nt_dest.Buffer[prefix_len], nt_dest.Length - prefix_len*sizeof(WCHAR) );
 +    status = STATUS_SUCCESS;
 +
 +cleanup:
-+    if (dest_allocated) free( nt_dest );
++    if (dest_allocated) RtlFreeAnsiString( &unix_dest );
 +    if (needs_close) close( dest_fd );
 +    return status;
 +}
 +
 +
- /******************************************************************************
-  *              NtFsControlFile   (NTDLL.@)
-  */
-@@ -5786,6 +5899,12 @@ NTSTATUS WINAPI NtFsControlFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE ap
+ /**************************************************************************
+  *              NtFsControlFile                 [NTDLL.@]
+  *              ZwFsControlFile                 [NTDLL.@]
+@@ -1848,6 +1948,12 @@ NTSTATUS WINAPI NtFsControlFile(HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc
+         status = STATUS_SUCCESS;
          break;
-     }
  
 +    case FSCTL_GET_REPARSE_POINT:
 +    {
@@ -180,6 +133,40 @@ index 48e4c38b7ba..cd523dcd313 100644
      case FSCTL_SET_REPARSE_POINT:
      {
          REPARSE_DATA_BUFFER *buffer = (REPARSE_DATA_BUFFER *)in_buffer;
+diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
+index 046b49c2d2b..9197a234703 100644
+--- a/dlls/ntdll/tests/file.c
++++ b/dlls/ntdll/tests/file.c
+@@ -4990,9 +4990,10 @@ static void test_reparse_points(void)
+     static const WCHAR dotW[] = {'.',0};
+     REPARSE_DATA_BUFFER *buffer = NULL;
+     DWORD dwret, dwLen, dwFlags;
++    INT buffer_len, string_len;
+     UNICODE_STRING nameW;
+-    INT buffer_len;
+     HANDLE handle;
++    WCHAR *dest;
+     BOOL bret;
+ 
+     /* Create a temporary folder for the junction point tests */
+@@ -5040,6 +5041,17 @@ static void test_reparse_points(void)
+     buffer_len = build_reparse_buffer(nameW.Buffer, &buffer);
+     bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
+     ok(bret, "Failed to create junction point! (0x%x)\n", GetLastError());
++
++    /* Read back the junction point */
++    HeapFree(GetProcessHeap(), 0, buffer);
++    buffer_len = sizeof(*buffer) + MAX_PATH*sizeof(WCHAR);
++    buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, buffer_len);
++    bret = DeviceIoControl(handle, FSCTL_GET_REPARSE_POINT, NULL, 0, (LPVOID)buffer, buffer_len, &dwret, 0);
++    ok(bret, "Failed to read junction point!\n");
++    string_len = buffer->MountPointReparseBuffer.SubstituteNameLength;
++    dest = &buffer->MountPointReparseBuffer.PathBuffer[buffer->MountPointReparseBuffer.SubstituteNameOffset/sizeof(WCHAR)];
++    ok((memcmp(dest, nameW.Buffer, string_len) == 0), "Junction point destination does not match ('%s' != '%s')!\n",
++                                                      wine_dbgstr_w(dest), wine_dbgstr_w(nameW.Buffer));
+     CloseHandle(handle);
+ 
+ cleanup:
 -- 
-2.17.1
+2.26.2
 
diff --git a/patches/ntdll-Junction_Points/0003-ntdll-Add-support-for-deleting-junction-points.patch b/patches/ntdll-Junction_Points/0003-ntdll-Add-support-for-deleting-junction-points.patch
index 262b29ba..6ebb2d30 100644
--- a/patches/ntdll-Junction_Points/0003-ntdll-Add-support-for-deleting-junction-points.patch
+++ b/patches/ntdll-Junction_Points/0003-ntdll-Add-support-for-deleting-junction-points.patch
@@ -1,81 +1,20 @@
-From 17713b3abdd15d7a76ffec8e6376f2424829ecfa Mon Sep 17 00:00:00 2001
+From 10508a815ca734c8a94472f82e6c0f5ebe5fbbd9 Mon Sep 17 00:00:00 2001
 From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
 Date: Thu, 16 Jan 2014 21:00:21 -0700
-Subject: ntdll: Add support for deleting junction points.
+Subject: [PATCH] ntdll: Add support for deleting junction points.
 
 Signed-off-by: Erich E. Hoover <erich.e.hoover@gmail.com>
 ---
+ dlls/ntdll/file.c       | 97 +++++++++++++++++++++++++++++++++++++++++
  dlls/ntdll/tests/file.c | 23 +++++++++-
- dlls/ntdll/unix/file.c  | 97 +++++++++++++++++++++++++++++++++++++++++
  include/ntifs.h         | 12 +++++
  3 files changed, 131 insertions(+), 1 deletion(-)
 
-diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
-index 4fe94f58bf1..9da353bbbd2 100644
---- a/dlls/ntdll/tests/file.c
-+++ b/dlls/ntdll/tests/file.c
-@@ -5004,12 +5004,15 @@ static void test_reparse_points(void)
-     static const WCHAR reparseW[] = {'\\','r','e','p','a','r','s','e',0};
-     WCHAR path[MAX_PATH], reparse_path[MAX_PATH], target_path[MAX_PATH];
-     static const WCHAR targetW[] = {'\\','t','a','r','g','e','t',0};
-+    FILE_BASIC_INFORMATION old_attrib, new_attrib;
-     static const WCHAR fooW[] = {'f','o','o',0};
-     static WCHAR volW[] = {'c',':','\\',0};
-+    REPARSE_GUID_DATA_BUFFER guid_buffer;
-     static const WCHAR dotW[] = {'.',0};
-     REPARSE_DATA_BUFFER *buffer = NULL;
-     DWORD dwret, dwLen, dwFlags;
-     INT buffer_len, string_len;
-+    IO_STATUS_BLOCK iosb;
-     UNICODE_STRING nameW;
-     HANDLE handle;
-     WCHAR *dest;
-@@ -5057,6 +5060,8 @@ static void test_reparse_points(void)
-         win_skip("Failed to open junction point directory handle (0x%x).\n", GetLastError());
-         goto cleanup;
-     }
-+    dwret = NtQueryInformationFile(handle, &iosb, &old_attrib, sizeof(old_attrib), FileBasicInformation);
-+    ok(dwret == STATUS_SUCCESS, "Failed to get junction point folder's attributes (0x%x).\n", dwret);
-     buffer_len = build_reparse_buffer(nameW.Buffer, &buffer);
-     bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
-     ok(bret, "Failed to create junction point! (0x%x)\n", GetLastError());
-@@ -5071,6 +5076,22 @@ static void test_reparse_points(void)
-     dest = &buffer->MountPointReparseBuffer.PathBuffer[buffer->MountPointReparseBuffer.SubstituteNameOffset/sizeof(WCHAR)];
-     ok((memcmp(dest, nameW.Buffer, string_len) == 0), "Junction point destination does not match ('%s' != '%s')!\n",
-                                                       wine_dbgstr_w(dest), wine_dbgstr_w(nameW.Buffer));
-+
-+    /* Delete the junction point */
-+    memset(&old_attrib, 0x00, sizeof(old_attrib));
-+    old_attrib.LastAccessTime.QuadPart = 0x200deadcafebeef;
-+    dwret = NtSetInformationFile(handle, &iosb, &old_attrib, sizeof(old_attrib), FileBasicInformation);
-+    ok(dwret == STATUS_SUCCESS, "Failed to set junction point folder's attributes (0x%x).\n", dwret);
-+    memset(&guid_buffer, 0x00, sizeof(guid_buffer));
-+    guid_buffer.ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
-+    bret = DeviceIoControl(handle, FSCTL_DELETE_REPARSE_POINT, (LPVOID)&guid_buffer,
-+                           REPARSE_GUID_DATA_BUFFER_HEADER_SIZE, NULL, 0, &dwret, 0);
-+    ok(bret, "Failed to delete junction point! (0x%x)\n", GetLastError());
-+    memset(&new_attrib, 0x00, sizeof(new_attrib));
-+    dwret = NtQueryInformationFile(handle, &iosb, &new_attrib, sizeof(new_attrib), FileBasicInformation);
-+    ok(dwret == STATUS_SUCCESS, "Failed to get junction point folder's attributes (0x%x).\n", dwret);
-+    ok(old_attrib.LastAccessTime.QuadPart == new_attrib.LastAccessTime.QuadPart,
-+       "Junction point folder's access time does not match.\n");
-     CloseHandle(handle);
- 
- cleanup:
-@@ -5078,7 +5099,7 @@ cleanup:
-     pRtlFreeUnicodeString(&nameW);
-     HeapFree(GetProcessHeap(), 0, buffer);
-     bret = RemoveDirectoryW(reparse_path);
--    todo_wine ok(bret, "Failed to remove temporary reparse point directory!\n");
-+    ok(bret, "Failed to remove temporary reparse point directory!\n");
-     bret = RemoveDirectoryW(target_path);
-     ok(bret, "Failed to remove temporary target directory!\n");
-     RemoveDirectoryW(path);
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index cd523dcd313..3f6dcc6ab41 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -5817,6 +5817,87 @@ cleanup:
+diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
+index 5a05217102d..98f37af8793 100644
+--- a/dlls/ntdll/file.c
++++ b/dlls/ntdll/file.c
+@@ -1863,6 +1863,87 @@ cleanup:
  }
  
  
@@ -88,8 +27,8 @@ index cd523dcd313..3f6dcc6ab41 100644
 +    char tmpdir[PATH_MAX], tmpfile[PATH_MAX], *d;
 +    BOOL tempdir_created = FALSE;
 +    int dest_fd, needs_close;
++    ANSI_STRING unix_name;
 +    NTSTATUS status;
-+    char *unix_name;
 +    struct stat st;
 +
 +    if ((status = server_get_unix_fd( handle, FILE_SPECIAL_ACCESS, &dest_fd, &needs_close, NULL, NULL )))
@@ -98,21 +37,21 @@ index cd523dcd313..3f6dcc6ab41 100644
 +    if ((status = server_get_unix_name( handle, &unix_name )))
 +        goto cleanup;
 +
-+    TRACE( "Deleting symlink %s\n", unix_name );
++    TRACE("Deleting symlink %s\n", unix_name.Buffer);
 +
 +    /* Produce the directory in a temporary location in the same folder */
 +    if (fstat( dest_fd, &st ) == -1)
 +    {
-+        status = errno_to_status( errno );
++        status = FILE_GetNtStatus();
 +        goto cleanup;
 +    }
-+    strcpy( tmpdir, unix_name );
++    strcpy( tmpdir, unix_name.Buffer );
 +    d = dirname( tmpdir);
 +    if (d != tmpdir) strcpy( tmpdir, d );
 +    strcat( tmpdir, "/.winelink.XXXXXX" );
 +    if (mkdtemp( tmpdir ) == NULL)
 +    {
-+        status = errno_to_status( errno );
++        status = FILE_GetNtStatus();
 +        goto cleanup;
 +    }
 +    tempdir_created = TRUE;
@@ -120,13 +59,13 @@ index cd523dcd313..3f6dcc6ab41 100644
 +    strcat( tmpfile, "/tmpfile" );
 +    if (mkdir( tmpfile, st.st_mode ))
 +    {
-+        status = errno_to_status( errno );
++        status = FILE_GetNtStatus();
 +        goto cleanup;
 +    }
 +    /* attemp to retain the ownership (if possible) */
 +    lchown( tmpfile, st.st_uid, st.st_gid );
 +    /* Atomically move the directory into position */
-+    if (!renameat2( -1, tmpfile, -1, unix_name, RENAME_EXCHANGE ))
++    if (!renameat2( -1, tmpfile, -1, unix_name.Buffer, RENAME_EXCHANGE ))
 +    {
 +        /* success: link and folder have switched locations */
 +        unlink( tmpfile ); /* remove the link (at folder location) */
@@ -135,20 +74,20 @@ index cd523dcd313..3f6dcc6ab41 100644
 +    {
 +        FIXME( "Atomic exchange of directory with symbolic link unsupported on this system, "
 +               "using unsafe exchange instead.\n" );
-+        if (unlink( unix_name ))
++        if (unlink( unix_name.Buffer ))
 +        {
-+            status = errno_to_status( errno );
++            status = FILE_GetNtStatus();
 +            goto cleanup;
 +        }
-+        if (rename( tmpfile, unix_name ))
++        if (rename( tmpfile, unix_name.Buffer ))
 +        {
-+            status = errno_to_status( errno );
++            status = FILE_GetNtStatus();
 +            goto cleanup; /* not moved, orignal file/folder at destination is orphaned */
 +        }
 +    }
 +    else
 +    {
-+        status = errno_to_status( errno );
++        status = FILE_GetNtStatus();
 +        goto cleanup;
 +    }
 +    status = STATUS_SUCCESS;
@@ -160,12 +99,12 @@ index cd523dcd313..3f6dcc6ab41 100644
 +}
 +
 +
- /******************************************************************************
-  *              NtFsControlFile   (NTDLL.@)
-  */
-@@ -5899,6 +5980,22 @@ NTSTATUS WINAPI NtFsControlFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE ap
+ /**************************************************************************
+  *              NtFsControlFile                 [NTDLL.@]
+  *              ZwFsControlFile                 [NTDLL.@]
+@@ -1948,6 +2029,22 @@ NTSTATUS WINAPI NtFsControlFile(HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc
+         status = STATUS_SUCCESS;
          break;
-     }
  
 +    case FSCTL_DELETE_REPARSE_POINT:
 +    {
@@ -186,6 +125,67 @@ index cd523dcd313..3f6dcc6ab41 100644
      case FSCTL_GET_REPARSE_POINT:
      {
          REPARSE_DATA_BUFFER *buffer = (REPARSE_DATA_BUFFER *)out_buffer;
+diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
+index 9197a234703..6f6a49afd46 100644
+--- a/dlls/ntdll/tests/file.c
++++ b/dlls/ntdll/tests/file.c
+@@ -4985,12 +4985,15 @@ static void test_reparse_points(void)
+     static const WCHAR reparseW[] = {'\\','r','e','p','a','r','s','e',0};
+     WCHAR path[MAX_PATH], reparse_path[MAX_PATH], target_path[MAX_PATH];
+     static const WCHAR targetW[] = {'\\','t','a','r','g','e','t',0};
++    FILE_BASIC_INFORMATION old_attrib, new_attrib;
+     static const WCHAR fooW[] = {'f','o','o',0};
+     static WCHAR volW[] = {'c',':','\\',0};
++    REPARSE_GUID_DATA_BUFFER guid_buffer;
+     static const WCHAR dotW[] = {'.',0};
+     REPARSE_DATA_BUFFER *buffer = NULL;
+     DWORD dwret, dwLen, dwFlags;
+     INT buffer_len, string_len;
++    IO_STATUS_BLOCK iosb;
+     UNICODE_STRING nameW;
+     HANDLE handle;
+     WCHAR *dest;
+@@ -5038,6 +5041,8 @@ static void test_reparse_points(void)
+         win_skip("Failed to open junction point directory handle (0x%x).\n", GetLastError());
+         goto cleanup;
+     }
++    dwret = NtQueryInformationFile(handle, &iosb, &old_attrib, sizeof(old_attrib), FileBasicInformation);
++    ok(dwret == STATUS_SUCCESS, "Failed to get junction point folder's attributes (0x%x).\n", dwret);
+     buffer_len = build_reparse_buffer(nameW.Buffer, &buffer);
+     bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
+     ok(bret, "Failed to create junction point! (0x%x)\n", GetLastError());
+@@ -5052,6 +5057,22 @@ static void test_reparse_points(void)
+     dest = &buffer->MountPointReparseBuffer.PathBuffer[buffer->MountPointReparseBuffer.SubstituteNameOffset/sizeof(WCHAR)];
+     ok((memcmp(dest, nameW.Buffer, string_len) == 0), "Junction point destination does not match ('%s' != '%s')!\n",
+                                                       wine_dbgstr_w(dest), wine_dbgstr_w(nameW.Buffer));
++
++    /* Delete the junction point */
++    memset(&old_attrib, 0x00, sizeof(old_attrib));
++    old_attrib.LastAccessTime.QuadPart = 0x200deadcafebeef;
++    dwret = NtSetInformationFile(handle, &iosb, &old_attrib, sizeof(old_attrib), FileBasicInformation);
++    ok(dwret == STATUS_SUCCESS, "Failed to set junction point folder's attributes (0x%x).\n", dwret);
++    memset(&guid_buffer, 0x00, sizeof(guid_buffer));
++    guid_buffer.ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
++    bret = DeviceIoControl(handle, FSCTL_DELETE_REPARSE_POINT, (LPVOID)&guid_buffer,
++                           REPARSE_GUID_DATA_BUFFER_HEADER_SIZE, NULL, 0, &dwret, 0);
++    ok(bret, "Failed to delete junction point! (0x%x)\n", GetLastError());
++    memset(&new_attrib, 0x00, sizeof(new_attrib));
++    dwret = NtQueryInformationFile(handle, &iosb, &new_attrib, sizeof(new_attrib), FileBasicInformation);
++    ok(dwret == STATUS_SUCCESS, "Failed to get junction point folder's attributes (0x%x).\n", dwret);
++    ok(old_attrib.LastAccessTime.QuadPart == new_attrib.LastAccessTime.QuadPart,
++       "Junction point folder's access time does not match.\n");
+     CloseHandle(handle);
+ 
+ cleanup:
+@@ -5059,7 +5080,7 @@ cleanup:
+     pRtlFreeUnicodeString(&nameW);
+     HeapFree(GetProcessHeap(), 0, buffer);
+     bret = RemoveDirectoryW(reparse_path);
+-    todo_wine ok(bret, "Failed to remove temporary reparse point directory!\n");
++    ok(bret, "Failed to remove temporary reparse point directory!\n");
+     bret = RemoveDirectoryW(target_path);
+     ok(bret, "Failed to remove temporary target directory!\n");
+     RemoveDirectoryW(path);
 diff --git a/include/ntifs.h b/include/ntifs.h
 index 21d42e17325..4539b89d583 100644
 --- a/include/ntifs.h
@@ -208,5 +208,5 @@ index 21d42e17325..4539b89d583 100644
 +
  #endif /* __WINE_NTIFS_H */
 -- 
-2.17.1
+2.26.2
 
diff --git a/patches/ntdll-Junction_Points/0004-ntdll-Add-a-test-for-junction-point-advertisement.patch b/patches/ntdll-Junction_Points/0004-ntdll-Add-a-test-for-junction-point-advertisement.patch
index d01defda..9767741c 100644
--- a/patches/ntdll-Junction_Points/0004-ntdll-Add-a-test-for-junction-point-advertisement.patch
+++ b/patches/ntdll-Junction_Points/0004-ntdll-Add-a-test-for-junction-point-advertisement.patch
@@ -1,4 +1,4 @@
-From 4b5123561e8260ed4b1421b0cf127468ac7c131f Mon Sep 17 00:00:00 2001
+From c86d6453694ed2723e5eaa1c55f9e53e1b9946d8 Mon Sep 17 00:00:00 2001
 From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
 Date: Thu, 16 Jan 2014 21:01:25 -0700
 Subject: ntdll: Add a test for junction point advertisement.
@@ -9,10 +9,10 @@ Signed-off-by: Erich E. Hoover <erich.e.hoover@gmail.com>
  1 file changed, 5 insertions(+)
 
 diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
-index 9da353bbbd2..051237dd494 100644
+index bc6961bc61..e1f216370d 100644
 --- a/dlls/ntdll/tests/file.c
 +++ b/dlls/ntdll/tests/file.c
-@@ -5066,6 +5066,11 @@ static void test_reparse_points(void)
+@@ -4925,6 +4925,11 @@ static void test_reparse_points(void)
      bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
      ok(bret, "Failed to create junction point! (0x%x)\n", GetLastError());
  
diff --git a/patches/ntdll-Junction_Points/0005-kernel32-ntdll-Add-support-for-deleting-junction-poi.patch b/patches/ntdll-Junction_Points/0005-kernel32-ntdll-Add-support-for-deleting-junction-poi.patch
new file mode 100644
index 00000000..ddf87cee
--- /dev/null
+++ b/patches/ntdll-Junction_Points/0005-kernel32-ntdll-Add-support-for-deleting-junction-poi.patch
@@ -0,0 +1,107 @@
+From b53336eeca65aa2dbf11c2d80a731ca904fe81de Mon Sep 17 00:00:00 2001
+From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
+Date: Thu, 16 Jan 2014 21:02:11 -0700
+Subject: [PATCH] kernel32,ntdll: Add support for deleting junction points with
+ RemoveDirectory.
+
+Signed-off-by: Erich E. Hoover <erich.e.hoover@gmail.com>
+---
+ dlls/kernel32/path.c    | 19 +++++++++++++------
+ dlls/ntdll/tests/file.c | 34 +++++++++++++++++++++++++++++++++-
+ 2 files changed, 46 insertions(+), 7 deletions(-)
+
+diff --git a/dlls/kernel32/path.c b/dlls/kernel32/path.c
+index b580e367561..9fa7d4c9f27 100644
+--- a/dlls/kernel32/path.c
++++ b/dlls/kernel32/path.c
+@@ -1058,6 +1058,7 @@ BOOL WINAPI CreateDirectoryExA( LPCSTR template, LPCSTR path, LPSECURITY_ATTRIBU
+  */
+ BOOL WINAPI RemoveDirectoryW( LPCWSTR path )
+ {
++    FILE_BASIC_INFORMATION info;
+     OBJECT_ATTRIBUTES attr;
+     UNICODE_STRING nt_name;
+     ANSI_STRING unix_name;
+@@ -1089,15 +1090,21 @@ BOOL WINAPI RemoveDirectoryW( LPCWSTR path )
+     }
+ 
+     status = wine_nt_to_unix_file_name( &nt_name, &unix_name, FILE_OPEN, FALSE );
+-    RtlFreeUnicodeString( &nt_name );
+-    if (!set_ntstatus( status ))
++    if (status == STATUS_SUCCESS)
+     {
+-        NtClose( handle );
+-        return FALSE;
++        status = NtQueryAttributesFile( &attr, &info );
++        if (status == STATUS_SUCCESS && (info.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) &&
++                                        (info.FileAttributes & FILE_ATTRIBUTE_DIRECTORY))
++            ret = (unlink( unix_name.Buffer ) != -1);
++        else
++            ret = (rmdir( unix_name.Buffer ) != -1);
++        if (!ret) FILE_SetDosError();
++        RtlFreeAnsiString( &unix_name );
+     }
++    else
++        set_ntstatus( status );
++    RtlFreeUnicodeString( &nt_name );
+ 
+-    if (!(ret = (rmdir( unix_name.Buffer ) != -1))) FILE_SetDosError();
+-    RtlFreeAnsiString( &unix_name );
+     NtClose( handle );
+     return ret;
+ }
+diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
+index d7b2f9aa0d9..e8cdb661772 100644
+--- a/dlls/ntdll/tests/file.c
++++ b/dlls/ntdll/tests/file.c
+@@ -4938,7 +4938,7 @@ static void test_reparse_points(void)
+     REPARSE_GUID_DATA_BUFFER guid_buffer;
+     static const WCHAR dotW[] = {'.',0};
+     REPARSE_DATA_BUFFER *buffer = NULL;
+-    DWORD dwret, dwLen, dwFlags;
++    DWORD dwret, dwLen, dwFlags, err;
+     INT buffer_len, string_len;
+     IO_STATUS_BLOCK iosb;
+     UNICODE_STRING nameW;
+@@ -5027,6 +5027,38 @@ static void test_reparse_points(void)
+        "Junction point folder's access time does not match.\n");
+     CloseHandle(handle);
+ 
++    /* Check deleting a junction point as if it were a directory */
++    HeapFree(GetProcessHeap(), 0, buffer);
++    handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
++                            FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
++    buffer_len = build_reparse_buffer(nameW.Buffer, &buffer);
++    bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
++    ok(bret, "Failed to create junction point! (0x%x)\n", GetLastError());
++    CloseHandle(handle);
++    bret = RemoveDirectoryW(reparse_path);
++    ok(bret, "Failed to delete junction point as directory!\n");
++    dwret = GetFileAttributesW(reparse_path);
++    ok(dwret == (DWORD)~0, "Junction point still exists (attributes: 0x%x)!\n", dwret);
++
++    /* Check deleting a junction point as if it were a file */
++    HeapFree(GetProcessHeap(), 0, buffer);
++    bret = CreateDirectoryW(reparse_path, NULL);
++    ok(bret, "Failed to create junction point target directory.\n");
++    handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
++                         FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
++    buffer_len = build_reparse_buffer(nameW.Buffer, &buffer);
++    bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
++    ok(bret, "Failed to create junction point! (0x%x)\n", GetLastError());
++    CloseHandle(handle);
++    bret = DeleteFileW(reparse_path);
++    ok(!bret, "Succeeded in deleting junction point as file!\n");
++    err = GetLastError();
++    ok(err == ERROR_ACCESS_DENIED, "Expected last error 0x%x for DeleteFile on junction point (actually 0x%x)!\n",
++                                   ERROR_ACCESS_DENIED, err);
++    dwret = GetFileAttributesW(reparse_path);
++    ok(dwret != (DWORD)~0, "Junction point doesn't exist (attributes: 0x%x)!\n", dwret);
++    ok(dwret & FILE_ATTRIBUTE_REPARSE_POINT, "File is not a junction point! (attributes: 0x%x)\n", dwret);
++
+ cleanup:
+     /* Cleanup */
+     pRtlFreeUnicodeString(&nameW);
+-- 
+2.23.0
+
diff --git a/patches/ntdll-Junction_Points/0005-server-Add-support-for-deleting-junction-points-with.patch b/patches/ntdll-Junction_Points/0005-server-Add-support-for-deleting-junction-points-with.patch
deleted file mode 100644
index 955c1041..00000000
--- a/patches/ntdll-Junction_Points/0005-server-Add-support-for-deleting-junction-points-with.patch
+++ /dev/null
@@ -1,206 +0,0 @@
-From 46d3165f1d7103851a5c15ed69d94be897186093 Mon Sep 17 00:00:00 2001
-From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
-Date: Thu, 16 Jan 2014 21:02:11 -0700
-Subject: [PATCH] server: Add support for deleting junction points with
- RemoveDirectory.
-
-Signed-off-by: Erich E. Hoover <erich.e.hoover@gmail.com>
----
- dlls/ntdll/tests/file.c | 34 +++++++++++++++++++++++++++++++++-
- server/fd.c             | 37 ++++++++++++++++++++++++++++---------
- 2 files changed, 61 insertions(+), 10 deletions(-)
-
-diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
-index 96fbe4501bc..2ac30551cf6 100644
---- a/dlls/ntdll/tests/file.c
-+++ b/dlls/ntdll/tests/file.c
-@@ -5240,7 +5240,7 @@ static void test_reparse_points(void)
-     REPARSE_GUID_DATA_BUFFER guid_buffer;
-     static const WCHAR dotW[] = {'.',0};
-     REPARSE_DATA_BUFFER *buffer = NULL;
--    DWORD dwret, dwLen, dwFlags;
-+    DWORD dwret, dwLen, dwFlags, err;
-     INT buffer_len, string_len;
-     IO_STATUS_BLOCK iosb;
-     UNICODE_STRING nameW;
-@@ -5329,6 +5329,38 @@ static void test_reparse_points(void)
-        "Junction point folder's access time does not match.\n");
-     CloseHandle(handle);
- 
-+    /* Check deleting a junction point as if it were a directory */
-+    HeapFree(GetProcessHeap(), 0, buffer);
-+    handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
-+                            FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
-+    buffer_len = build_reparse_buffer(nameW.Buffer, &buffer);
-+    bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
-+    ok(bret, "Failed to create junction point! (0x%x)\n", GetLastError());
-+    CloseHandle(handle);
-+    bret = RemoveDirectoryW(reparse_path);
-+    ok(bret, "Failed to delete junction point as directory!\n");
-+    dwret = GetFileAttributesW(reparse_path);
-+    ok(dwret == (DWORD)~0, "Junction point still exists (attributes: 0x%x)!\n", dwret);
-+
-+    /* Check deleting a junction point as if it were a file */
-+    HeapFree(GetProcessHeap(), 0, buffer);
-+    bret = CreateDirectoryW(reparse_path, NULL);
-+    ok(bret, "Failed to create junction point target directory.\n");
-+    handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
-+                         FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
-+    buffer_len = build_reparse_buffer(nameW.Buffer, &buffer);
-+    bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
-+    ok(bret, "Failed to create junction point! (0x%x)\n", GetLastError());
-+    CloseHandle(handle);
-+    bret = DeleteFileW(reparse_path);
-+    ok(!bret, "Succeeded in deleting junction point as file!\n");
-+    err = GetLastError();
-+    ok(err == ERROR_ACCESS_DENIED, "Expected last error 0x%x for DeleteFile on junction point (actually 0x%x)!\n",
-+                                   ERROR_ACCESS_DENIED, err);
-+    dwret = GetFileAttributesW(reparse_path);
-+    ok(dwret != (DWORD)~0, "Junction point doesn't exist (attributes: 0x%x)!\n", dwret);
-+    ok(dwret & FILE_ATTRIBUTE_REPARSE_POINT, "File is not a junction point! (attributes: 0x%x)\n", dwret);
-+
- cleanup:
-     /* Cleanup */
-     pRtlFreeUnicodeString(&nameW);
-diff --git a/server/fd.c b/server/fd.c
-index bca4f20d8ef..08d080ecd32 100644
---- a/server/fd.c
-+++ b/server/fd.c
-@@ -169,7 +169,8 @@ struct closed_fd
-     struct list entry;       /* entry in inode closed list */
-     int         unix_fd;     /* the unix file descriptor */
-     int         unlink;      /* whether to unlink on close: -1 - implicit FILE_DELETE_ON_CLOSE, 1 - explicit disposition */
--    char       *unix_name;   /* name to unlink on close, points to parent fd unix_name */
-+    char       *unlink_name; /* name to unlink on close, points to parent fd unix_name */
-+    char       *unix_name;   /* name to real file path, points to parent fd unix_name */
- };
- 
- struct fd
-@@ -184,6 +185,7 @@ struct fd
-     unsigned int         access;      /* file access (FILE_READ_DATA etc.) */
-     unsigned int         options;     /* file options (FILE_DELETE_ON_CLOSE, FILE_SYNCHRONOUS...) */
-     unsigned int         sharing;     /* file sharing mode */
-+    char                *unlink_name; /* file name to unlink on close */
-     char                *unix_name;   /* unix file name */
-     int                  unix_fd;     /* unix file descriptor */
-     unsigned int         no_fd_status;/* status to return when unix_fd is -1 */
-@@ -1113,6 +1115,7 @@ static void inode_close_pending( struct inode *inode, int keep_unlinks )
-         if (!keep_unlinks || !fd->unlink)  /* get rid of it unless there's an unlink pending on that file */
-         {
-             list_remove( ptr );
-+            free( fd->unlink_name );
-             free( fd->unix_name );
-             free( fd );
-         }
-@@ -1147,12 +1150,13 @@ static void inode_destroy( struct object *obj )
-         {
-             /* make sure it is still the same file */
-             struct stat st;
--            if (!stat( fd->unix_name, &st ) && st.st_dev == inode->device->dev && st.st_ino == inode->ino)
-+            if (!lstat( fd->unlink_name, &st ) && st.st_dev == inode->device->dev && st.st_ino == inode->ino)
-             {
--                if (S_ISDIR(st.st_mode)) rmdir( fd->unix_name );
--                else unlink( fd->unix_name );
-+                if (S_ISDIR(st.st_mode)) rmdir( fd->unlink_name );
-+                else unlink( fd->unlink_name );
-             }
-         }
-+        free( fd->unlink_name );
-         free( fd->unix_name );
-         free( fd );
-     }
-@@ -1572,6 +1576,7 @@ static void fd_destroy( struct object *obj )
-     else  /* no inode, close it right away */
-     {
-         if (fd->unix_fd != -1) close( fd->unix_fd );
-+        free( fd->unlink_name );
-         free( fd->unix_name );
-     }
- }
-@@ -1681,6 +1686,7 @@ static struct fd *alloc_fd_object(void)
-     fd->options    = 0;
-     fd->sharing    = 0;
-     fd->unix_fd    = -1;
-+    fd->unlink_name  = NULL;
-     fd->unix_name  = NULL;
-     fd->cacheable  = 0;
-     fd->signaled   = 1;
-@@ -1716,6 +1722,7 @@ struct fd *alloc_pseudo_fd( const struct fd_ops *fd_user_ops, struct object *use
-     fd->access     = 0;
-     fd->options    = options;
-     fd->sharing    = 0;
-+    fd->unlink_name  = NULL;
-     fd->unix_name  = NULL;
-     fd->unix_fd    = -1;
-     fd->cacheable  = 0;
-@@ -1750,6 +1757,12 @@ struct fd *dup_fd_object( struct fd *orig, unsigned int access, unsigned int sha
-         strcpy( fd->unix_name, orig->unix_name );
-     }
- 
-+    if (orig->unlink_name)
-+    {
-+        if (!(fd->unlink_name = mem_alloc( strlen(orig->unlink_name) + 1 ))) goto failed;
-+        strcpy( fd->unlink_name, orig->unlink_name );
-+    }
-+
-     if (orig->inode)
-     {
-         struct closed_fd *closed = mem_alloc( sizeof(*closed) );
-@@ -1762,6 +1775,7 @@ struct fd *dup_fd_object( struct fd *orig, unsigned int access, unsigned int sha
-         }
-         closed->unix_fd = fd->unix_fd;
-         closed->unlink = 0;
-+        closed->unlink_name = fd->unlink_name;
-         closed->unix_name = fd->unix_name;
-         fd->closed = closed;
-         fd->inode = (struct inode *)grab_object( orig->inode );
-@@ -1903,18 +1917,19 @@ struct fd *open_fd( struct fd *root, const char *name, int flags, mode_t *mode,
-     fd->unix_name = NULL;
-     if ((path = dup_fd_name( root, name )))
-     {
-+        fd->unlink_name = path;
-         fd->unix_name = realpath( path, NULL );
--        free( path );
-     }
- 
-     closed_fd->unix_fd = fd->unix_fd;
-     closed_fd->unlink = 0;
-+    closed_fd->unlink_name = fd->unlink_name;
-     closed_fd->unix_name = fd->unix_name;
--    fstat( fd->unix_fd, &st );
-+    lstat( fd->unlink_name, &st );
-     *mode = st.st_mode;
- 
-     /* only bother with an inode for normal files and directories */
--    if (S_ISREG(st.st_mode) || S_ISDIR(st.st_mode))
-+    if (S_ISREG(st.st_mode) || S_ISDIR(st.st_mode) || S_ISLNK(st.st_mode))
-     {
-         unsigned int err;
-         struct inode *inode = get_inode( st.st_dev, st.st_ino, fd->unix_fd );
-@@ -1932,6 +1947,9 @@ struct fd *open_fd( struct fd *root, const char *name, int flags, mode_t *mode,
-         list_add_head( &inode->open, &fd->inode_entry );
-         closed_fd = NULL;
- 
-+        fstat( fd->unix_fd, &st );
-+        *mode = st.st_mode;
-+
-         /* check directory options */
-         if ((options & FILE_DIRECTORY_FILE) && !S_ISDIR(st.st_mode))
-         {
-@@ -2569,10 +2587,11 @@ static void set_fd_name( struct fd *fd, struct fd *root, const char *nameptr,
-         fchmod( fd->unix_fd, st.st_mode );
-     }
- 
-+    free( fd->unlink_name );
-     free( fd->unix_name );
-+    fd->closed->unlink_name = fd->unlink_name = name;
-     fd->closed->unix_name = fd->unix_name = realpath( name, NULL );
--    free( name );
--    if (!fd->unix_name)
-+    if (!fd->unlink_name || !fd->unix_name)
-         set_error( STATUS_NO_MEMORY );
-     return;
- 
--- 
-2.17.1
-
diff --git a/patches/ntdll-Junction_Points/0007-ntdll-Add-support-for-absolute-symlink-creation.patch b/patches/ntdll-Junction_Points/0007-ntdll-Add-support-for-absolute-symlink-creation.patch
index f691f13f..e30a0e01 100644
--- a/patches/ntdll-Junction_Points/0007-ntdll-Add-support-for-absolute-symlink-creation.patch
+++ b/patches/ntdll-Junction_Points/0007-ntdll-Add-support-for-absolute-symlink-creation.patch
@@ -1,21 +1,89 @@
-From 78fe8add28f8385a2d2aae635ff16c027f6240f7 Mon Sep 17 00:00:00 2001
+From d1024118fbb0a73abd19ef937d13d4378a61992b Mon Sep 17 00:00:00 2001
 From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
 Date: Thu, 16 Jan 2014 21:06:24 -0700
 Subject: [PATCH] ntdll: Add support for absolute symlink creation.
 
 Signed-off-by: Erich E. Hoover <erich.e.hoover@gmail.com>
 ---
+ dlls/ntdll/file.c       |  35 ++++++++++--
  dlls/ntdll/tests/file.c | 117 ++++++++++++++++++++++++++++++++++------
- dlls/ntdll/unix/file.c  |  35 ++++++++++--
  include/ntifs.h         |  10 ++++
  3 files changed, 143 insertions(+), 19 deletions(-)
 
+diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
+index 98f37af8793..825344dab86 100644
+--- a/dlls/ntdll/file.c
++++ b/dlls/ntdll/file.c
+@@ -1672,17 +1672,33 @@ NTSTATUS WINAPI NtDeviceIoControlFile(HANDLE handle, HANDLE event,
+ NTSTATUS FILE_CreateSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer)
+ {
+     BOOL src_allocated = FALSE, dest_allocated = FALSE, tempdir_created = FALSE;
+-    int dest_len = buffer->MountPointReparseBuffer.SubstituteNameLength;
+-    int offset = buffer->MountPointReparseBuffer.SubstituteNameOffset;
+-    WCHAR *dest = &buffer->MountPointReparseBuffer.PathBuffer[offset];
+     char tmpdir[PATH_MAX], tmplink[PATH_MAX], *d;
+     ANSI_STRING unix_src, unix_dest;
+     char magic_dest[PATH_MAX];
+     int dest_fd, needs_close;
+     UNICODE_STRING nt_dest;
++    int dest_len, offset;
+     NTSTATUS status;
++    struct stat st;
++    WCHAR *dest;
+     int i;
+ 
++    switch(buffer->ReparseTag)
++    {
++    case IO_REPARSE_TAG_MOUNT_POINT:
++        dest_len = buffer->MountPointReparseBuffer.SubstituteNameLength;
++        offset = buffer->MountPointReparseBuffer.SubstituteNameOffset;
++        dest = &buffer->MountPointReparseBuffer.PathBuffer[offset];
++        break;
++    case IO_REPARSE_TAG_SYMLINK:
++        dest_len = buffer->SymbolicLinkReparseBuffer.SubstituteNameLength;
++        offset = buffer->SymbolicLinkReparseBuffer.SubstituteNameOffset;
++        dest = &buffer->SymbolicLinkReparseBuffer.PathBuffer[offset];
++        break;
++    default:
++        return STATUS_NOT_IMPLEMENTED;
++    }
++
+     if ((status = server_get_unix_fd( handle, FILE_SPECIAL_ACCESS, &dest_fd, &needs_close, NULL, NULL )))
+         return status;
+ 
+@@ -1682,6 +1698,18 @@ NTSTATUS FILE_CreateSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer)
+             strcat( magic_dest, "." );
+         strcat( magic_dest, "/" );
+     }
++    /* Encode the type (file or directory) if NT symlink */
++    if (buffer->ReparseTag == IO_REPARSE_TAG_SYMLINK)
++    {
++        if (fstat( dest_fd, &st ) == -1)
++        {
++            status = FILE_GetNtStatus();
++            goto cleanup;
++        }
++        if (S_ISDIR(st.st_mode))
++            strcat( magic_dest, "." );
++        strcat( magic_dest, "/" );
++    }
+     strcat( magic_dest, unix_dest.Buffer );
+ 
+     /* Produce the link in a temporary location in the same folder */
+@@ -2058,6 +2086,7 @@ NTSTATUS WINAPI NtFsControlFile(HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc
+         switch(buffer->ReparseTag)
+         {
+         case IO_REPARSE_TAG_MOUNT_POINT:
++        case IO_REPARSE_TAG_SYMLINK:
+             status = FILE_CreateSymlink( handle, buffer );
+             break;
+         default:
 diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
-index 2953c77f0ad..81fa9592e3d 100644
+index 89f291536b2..92f03ab3d34 100644
 --- a/dlls/ntdll/tests/file.c
 +++ b/dlls/ntdll/tests/file.c
-@@ -5205,26 +5205,50 @@ static void test_mailslot_name(void)
-     CloseHandle( device );
+@@ -4954,26 +4954,50 @@ static void test_file_readonly_access(void)
+     DeleteFileW(path);
  }
  
 -static INT build_reparse_buffer(const WCHAR *filename, REPARSE_DATA_BUFFER **pbuffer)
@@ -73,7 +141,7 @@ index 2953c77f0ad..81fa9592e3d 100644
      lstrcpyW(subst_dest, filename);
      lstrcpyW(print_dest, &filename[prefix_len]);
      *pbuffer = buffer;
-@@ -5244,10 +5268,12 @@ static void test_reparse_points(void)
+@@ -4993,10 +5017,12 @@ static void test_reparse_points(void)
      REPARSE_DATA_BUFFER *buffer = NULL;
      DWORD dwret, dwLen, dwFlags, err;
      INT buffer_len, string_len;
@@ -87,7 +155,7 @@ index 2953c77f0ad..81fa9592e3d 100644
      BOOL bret;
  
      /* Create a temporary folder for the junction point tests */
-@@ -5294,7 +5320,7 @@ static void test_reparse_points(void)
+@@ -5043,7 +5069,7 @@ static void test_reparse_points(void)
      }
      dwret = NtQueryInformationFile(handle, &iosb, &old_attrib, sizeof(old_attrib), FileBasicInformation);
      ok(dwret == STATUS_SUCCESS, "Failed to get junction point folder's attributes (0x%x).\n", dwret);
@@ -96,7 +164,7 @@ index 2953c77f0ad..81fa9592e3d 100644
      bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
      ok(bret, "Failed to create junction point! (0x%x)\n", GetLastError());
  
-@@ -5335,7 +5361,7 @@ static void test_reparse_points(void)
+@@ -5084,7 +5110,7 @@ static void test_reparse_points(void)
      HeapFree(GetProcessHeap(), 0, buffer);
      handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
                              FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
@@ -105,7 +173,7 @@ index 2953c77f0ad..81fa9592e3d 100644
      bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
      ok(bret, "Failed to create junction point! (0x%x)\n", GetLastError());
      CloseHandle(handle);
-@@ -5350,7 +5376,7 @@ static void test_reparse_points(void)
+@@ -5099,7 +5125,7 @@ static void test_reparse_points(void)
      ok(bret, "Failed to create junction point target directory.\n");
      handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
                           FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
@@ -114,7 +182,7 @@ index 2953c77f0ad..81fa9592e3d 100644
      bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
      ok(bret, "Failed to create junction point! (0x%x)\n", GetLastError());
      CloseHandle(handle);
-@@ -5363,14 +5389,73 @@ static void test_reparse_points(void)
+@@ -5112,14 +5138,73 @@ static void test_reparse_points(void)
      ok(dwret != (DWORD)~0, "Junction point doesn't exist (attributes: 0x%x)!\n", dwret);
      ok(dwret & FILE_ATTRIBUTE_REPARSE_POINT, "File is not a junction point! (attributes: 0x%x)\n", dwret);
  
@@ -192,75 +260,6 @@ index 2953c77f0ad..81fa9592e3d 100644
      RemoveDirectoryW(path);
  }
  
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index 9ad0d7dcb39..7150099f750 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -5664,18 +5664,34 @@ static void ignore_server_ioctl_struct_holes( ULONG code, const void *in_buffer,
- NTSTATUS FILE_CreateSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer)
- {
-     BOOL src_allocated = FALSE, dest_allocated = FALSE, tempdir_created = FALSE;
--    int dest_len = buffer->MountPointReparseBuffer.SubstituteNameLength;
--    int offset = buffer->MountPointReparseBuffer.SubstituteNameOffset;
--    WCHAR *dest = &buffer->MountPointReparseBuffer.PathBuffer[offset];
-     char tmpdir[PATH_MAX], tmplink[PATH_MAX], *d;
-     SIZE_T unix_dest_len = PATH_MAX;
-     char *unix_src, *unix_dest;
-     char magic_dest[PATH_MAX];
-     int dest_fd, needs_close;
-     UNICODE_STRING nt_dest;
-+    int dest_len, offset;
-     NTSTATUS status;
-+    struct stat st;
-+    WCHAR *dest;
-     int i;
- 
-+    switch(buffer->ReparseTag)
-+    {
-+    case IO_REPARSE_TAG_MOUNT_POINT:
-+        dest_len = buffer->MountPointReparseBuffer.SubstituteNameLength;
-+        offset = buffer->MountPointReparseBuffer.SubstituteNameOffset;
-+        dest = &buffer->MountPointReparseBuffer.PathBuffer[offset];
-+        break;
-+    case IO_REPARSE_TAG_SYMLINK:
-+        dest_len = buffer->SymbolicLinkReparseBuffer.SubstituteNameLength;
-+        offset = buffer->SymbolicLinkReparseBuffer.SubstituteNameOffset;
-+        dest = &buffer->SymbolicLinkReparseBuffer.PathBuffer[offset];
-+        break;
-+    default:
-+        return STATUS_NOT_IMPLEMENTED;
-+    }
-+
-     if ((status = server_get_unix_fd( handle, FILE_SPECIAL_ACCESS, &dest_fd, &needs_close, NULL, NULL )))
-         return status;
- 
-@@ -5710,6 +5726,18 @@ NTSTATUS FILE_CreateSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer)
-             strcat( magic_dest, "." );
-         strcat( magic_dest, "/" );
-     }
-+    /* Encode the type (file or directory) if NT symlink */
-+    if (buffer->ReparseTag == IO_REPARSE_TAG_SYMLINK)
-+    {
-+        if (fstat( dest_fd, &st ) == -1)
-+        {
-+            status = errno_to_status( errno );
-+            goto cleanup;
-+        }
-+        if (S_ISDIR(st.st_mode))
-+            strcat( magic_dest, "." );
-+        strcat( magic_dest, "/" );
-+    }
-     strcat( magic_dest, unix_dest );
- 
-     /* Produce the link in a temporary location in the same folder */
-@@ -6072,6 +6100,7 @@ NTSTATUS WINAPI NtFsControlFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE ap
-         switch(buffer->ReparseTag)
-         {
-         case IO_REPARSE_TAG_MOUNT_POINT:
-+        case IO_REPARSE_TAG_SYMLINK:
-             status = FILE_CreateSymlink( handle, buffer );
-             break;
-         default:
 diff --git a/include/ntifs.h b/include/ntifs.h
 index 4539b89d583..ab3273d3f81 100644
 --- a/include/ntifs.h
@@ -295,5 +294,5 @@ index 4539b89d583..ab3273d3f81 100644
  typedef struct _REPARSE_GUID_DATA_BUFFER {
      DWORD ReparseTag;
 -- 
-2.27.0
+2.26.2
 
diff --git a/patches/ntdll-Junction_Points/0008-ntdll-Add-support-for-reading-absolute-symlinks.patch b/patches/ntdll-Junction_Points/0008-ntdll-Add-support-for-reading-absolute-symlinks.patch
index 55244146..7e77364b 100644
--- a/patches/ntdll-Junction_Points/0008-ntdll-Add-support-for-reading-absolute-symlinks.patch
+++ b/patches/ntdll-Junction_Points/0008-ntdll-Add-support-for-reading-absolute-symlinks.patch
@@ -1,58 +1,27 @@
-From 3595e892dbf4d5b123ce641b6ce72490cc3d782f Mon Sep 17 00:00:00 2001
+From b4c166f821e7254737bf0920c3f0ea62e0646846 Mon Sep 17 00:00:00 2001
 From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
 Date: Wed, 13 Mar 2019 12:55:20 -0600
 Subject: ntdll: Add support for reading absolute symlinks.
 
 Signed-off-by: Erich E. Hoover <erich.e.hoover@gmail.com>
 ---
+ dlls/ntdll/file.c       | 22 ++++++++++++++++++++++
  dlls/ntdll/tests/file.c | 13 ++++++++++++-
- dlls/ntdll/unix/file.c  | 22 ++++++++++++++++++++++
  2 files changed, 34 insertions(+), 1 deletion(-)
 
-diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
-index 986468a1495..5b7bdf7ddfd 100644
---- a/dlls/ntdll/tests/file.c
-+++ b/dlls/ntdll/tests/file.c
-@@ -5208,7 +5208,6 @@ static void test_reparse_points(void)
-     ok(dwret == STATUS_SUCCESS, "Failed to get symlink folder's attributes (0x%x).\n", dwret);
-     buffer_len = build_reparse_buffer(nameW.Buffer, IO_REPARSE_TAG_SYMLINK, &buffer);
-     bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
--    CloseHandle(handle);
-     ok(bret, "Failed to create symlink! (0x%x)\n", GetLastError());
- 
-     /* Check the file attributes of the symlink */
-@@ -5216,6 +5215,18 @@ static void test_reparse_points(void)
-     ok(dwret != (DWORD)~0, "Symlink doesn't exist (attributes: 0x%x)!\n", dwret);
-     ok(dwret & FILE_ATTRIBUTE_REPARSE_POINT, "File is not a symlink! (attributes: %d)\n", dwret);
- 
-+    /* Read back the symlink */
-+    HeapFree(GetProcessHeap(), 0, buffer);
-+    buffer_len = sizeof(*buffer) + MAX_PATH*sizeof(WCHAR);
-+    buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, buffer_len);
-+    bret = DeviceIoControl(handle, FSCTL_GET_REPARSE_POINT, NULL, 0, (LPVOID)buffer, buffer_len, &dwret, 0);
-+    string_len = buffer->SymbolicLinkReparseBuffer.SubstituteNameLength;
-+    dest = &buffer->SymbolicLinkReparseBuffer.PathBuffer[buffer->SymbolicLinkReparseBuffer.SubstituteNameOffset/sizeof(WCHAR)];
-+    ok(bret, "Failed to read symlink!\n");
-+    ok((memcmp(dest, nameW.Buffer, string_len) == 0), "Symlink destination does not match ('%s' != '%s')!\n",
-+                                                      wine_dbgstr_w(dest), wine_dbgstr_w(nameW.Buffer));
-+    CloseHandle(handle);
-+
- cleanup:
-     /* Cleanup */
-     pRtlFreeUnicodeString(&nameW);
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index b8dc02127ba..cd14a2e24c3 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -5746,6 +5746,7 @@ NTSTATUS FILE_GetSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer, ULONG out_s
-     int unix_dest_len;
+diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
+index 62941774ec..84da022325 100644
+--- a/dlls/ntdll/file.c
++++ b/dlls/ntdll/file.c
+@@ -1780,6 +1780,7 @@ NTSTATUS FILE_GetSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer, ULONG out_s
+     UNICODE_STRING nt_dest;
      DWORD max_length;
      NTSTATUS status;
 +    ULONG flags = 0;
-     WCHAR *nt_dest;
      INT prefix_len;
      ssize_t ret;
-@@ -5790,6 +5791,17 @@ NTSTATUS FILE_GetSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer, ULONG out_s
+     char *p;
+@@ -1826,6 +1827,17 @@ NTSTATUS FILE_GetSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer, ULONG out_s
          }
          buffer->ReparseTag |= (val << i);
      }
@@ -67,26 +36,57 @@ index b8dc02127ba..cd14a2e24c3 100644
 +            goto cleanup;
 +        }
 +    }
-     unix_dest_len -= (p - unix_dest);
-     memmove(unix_dest, p, unix_dest_len);
+     unix_dest.Length -= (p - unix_dest.Buffer);
+     memmove(unix_dest.Buffer, p, unix_dest.Length);
  
-@@ -5822,6 +5834,16 @@ NTSTATUS FILE_GetSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer, ULONG out_s
-         buffer->MountPointReparseBuffer.PrintNameLength = nt_dest_len - prefix_len*sizeof(WCHAR);
+@@ -1844,6 +1856,16 @@ NTSTATUS FILE_GetSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer, ULONG out_s
+         buffer->MountPointReparseBuffer.PrintNameLength = nt_dest.Length - prefix_len*sizeof(WCHAR);
          print_name = &buffer->MountPointReparseBuffer.PathBuffer[buffer->MountPointReparseBuffer.PrintNameOffset/sizeof(WCHAR)];
          break;
 +    case IO_REPARSE_TAG_SYMLINK:
 +        max_length = out_size-FIELD_OFFSET(typeof(*buffer), SymbolicLinkReparseBuffer.PathBuffer[1]);
 +        buffer->SymbolicLinkReparseBuffer.SubstituteNameOffset = 0;
-+        buffer->SymbolicLinkReparseBuffer.SubstituteNameLength = nt_dest_len;
++        buffer->SymbolicLinkReparseBuffer.SubstituteNameLength = nt_dest.Length;
 +        subst_name = &buffer->SymbolicLinkReparseBuffer.PathBuffer[buffer->SymbolicLinkReparseBuffer.SubstituteNameOffset/sizeof(WCHAR)];
-+        buffer->SymbolicLinkReparseBuffer.PrintNameOffset = nt_dest_len + sizeof(WCHAR);
-+        buffer->SymbolicLinkReparseBuffer.PrintNameLength = nt_dest_len - prefix_len*sizeof(WCHAR);
++        buffer->SymbolicLinkReparseBuffer.PrintNameOffset = nt_dest.Length + sizeof(WCHAR);
++        buffer->SymbolicLinkReparseBuffer.PrintNameLength = nt_dest.Length - prefix_len*sizeof(WCHAR);
 +        print_name = &buffer->SymbolicLinkReparseBuffer.PathBuffer[buffer->SymbolicLinkReparseBuffer.PrintNameOffset/sizeof(WCHAR)];
 +        buffer->SymbolicLinkReparseBuffer.Flags = flags;
 +        break;
      default:
          /* unrecognized (regular) files should probably be treated as symlinks */
          WARN("unrecognized symbolic link\n");
+diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
+index 05ba0fc57e..526bd8a85a 100644
+--- a/dlls/ntdll/tests/file.c
++++ b/dlls/ntdll/tests/file.c
+@@ -5067,7 +5067,6 @@ static void test_reparse_points(void)
+     ok(dwret == STATUS_SUCCESS, "Failed to get symlink folder's attributes (0x%x).\n", dwret);
+     buffer_len = build_reparse_buffer(nameW.Buffer, IO_REPARSE_TAG_SYMLINK, &buffer);
+     bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
+-    CloseHandle(handle);
+     ok(bret, "Failed to create symlink! (0x%x)\n", GetLastError());
+ 
+     /* Check the file attributes of the symlink */
+@@ -5075,6 +5074,18 @@ static void test_reparse_points(void)
+     ok(dwret != (DWORD)~0, "Symlink doesn't exist (attributes: 0x%x)!\n", dwret);
+     ok(dwret & FILE_ATTRIBUTE_REPARSE_POINT, "File is not a symlink! (attributes: %d)\n", dwret);
+ 
++    /* Read back the symlink */
++    HeapFree(GetProcessHeap(), 0, buffer);
++    buffer_len = sizeof(*buffer) + MAX_PATH*sizeof(WCHAR);
++    buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, buffer_len);
++    bret = DeviceIoControl(handle, FSCTL_GET_REPARSE_POINT, NULL, 0, (LPVOID)buffer, buffer_len, &dwret, 0);
++    string_len = buffer->SymbolicLinkReparseBuffer.SubstituteNameLength;
++    dest = &buffer->SymbolicLinkReparseBuffer.PathBuffer[buffer->SymbolicLinkReparseBuffer.SubstituteNameOffset/sizeof(WCHAR)];
++    ok(bret, "Failed to read symlink!\n");
++    ok((memcmp(dest, nameW.Buffer, string_len) == 0), "Symlink destination does not match ('%s' != '%s')!\n",
++                                                      wine_dbgstr_w(dest), wine_dbgstr_w(nameW.Buffer));
++    CloseHandle(handle);
++
+ cleanup:
+     /* Cleanup */
+     pRtlFreeUnicodeString(&nameW);
 -- 
 2.17.1
 
diff --git a/patches/ntdll-Junction_Points/0009-ntdll-Add-support-for-deleting-symlinks.patch b/patches/ntdll-Junction_Points/0009-ntdll-Add-support-for-deleting-symlinks.patch
index 2aa197c1..9fb157ec 100644
--- a/patches/ntdll-Junction_Points/0009-ntdll-Add-support-for-deleting-symlinks.patch
+++ b/patches/ntdll-Junction_Points/0009-ntdll-Add-support-for-deleting-symlinks.patch
@@ -1,19 +1,31 @@
-From 248faa7fd14b6ff0028c7762edd0bb8ad564b9ca Mon Sep 17 00:00:00 2001
+From 2ee26355e8261f4065b3e5e933a81ce0bfd1a1c6 Mon Sep 17 00:00:00 2001
 From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
 Date: Wed, 13 Mar 2019 13:02:22 -0600
 Subject: ntdll: Add support for deleting symlinks.
 
 Signed-off-by: Erich E. Hoover <erich.e.hoover@gmail.com>
 ---
+ dlls/ntdll/file.c       |  1 +
  dlls/ntdll/tests/file.c | 16 ++++++++++++++++
- dlls/ntdll/unix/file.c  |  1 +
  2 files changed, 17 insertions(+)
 
+diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
+index 84da022325..c3e171ab19 100644
+--- a/dlls/ntdll/file.c
++++ b/dlls/ntdll/file.c
+@@ -2062,6 +2062,7 @@ NTSTATUS WINAPI NtFsControlFile(HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc
+         switch(buffer->ReparseTag)
+         {
+         case IO_REPARSE_TAG_MOUNT_POINT:
++        case IO_REPARSE_TAG_SYMLINK:
+             status = FILE_RemoveSymlink( handle, buffer );
+             break;
+         default:
 diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
-index 5b7bdf7ddfd..b6a58c3f2a7 100644
+index 526bd8a85a..f0545feb5c 100644
 --- a/dlls/ntdll/tests/file.c
 +++ b/dlls/ntdll/tests/file.c
-@@ -5225,6 +5225,22 @@ static void test_reparse_points(void)
+@@ -5084,6 +5084,22 @@ static void test_reparse_points(void)
      ok(bret, "Failed to read symlink!\n");
      ok((memcmp(dest, nameW.Buffer, string_len) == 0), "Symlink destination does not match ('%s' != '%s')!\n",
                                                        wine_dbgstr_w(dest), wine_dbgstr_w(nameW.Buffer));
@@ -36,18 +48,6 @@ index 5b7bdf7ddfd..b6a58c3f2a7 100644
      CloseHandle(handle);
  
  cleanup:
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index cd14a2e24c3..232cbb36f42 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -6037,6 +6037,7 @@ NTSTATUS WINAPI NtFsControlFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE ap
-         switch(buffer->ReparseTag)
-         {
-         case IO_REPARSE_TAG_MOUNT_POINT:
-+        case IO_REPARSE_TAG_SYMLINK:
-             status = FILE_RemoveSymlink( handle, buffer );
-             break;
-         default:
 -- 
 2.17.1
 
diff --git a/patches/ntdll-Junction_Points/0010-ntdll-Add-support-for-relative-symlink-creation.patch b/patches/ntdll-Junction_Points/0010-ntdll-Add-support-for-relative-symlink-creation.patch
index fd2e3cfc..1eafd77b 100644
--- a/patches/ntdll-Junction_Points/0010-ntdll-Add-support-for-relative-symlink-creation.patch
+++ b/patches/ntdll-Junction_Points/0010-ntdll-Add-support-for-relative-symlink-creation.patch
@@ -1,120 +1,29 @@
-From bcd9d5db2f28b626854ef463cc9615ccfc853b44 Mon Sep 17 00:00:00 2001
+From cea567a0f38794b66e8da0f252d1f4864c299987 Mon Sep 17 00:00:00 2001
 From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
 Date: Thu, 11 Apr 2019 12:16:49 -0600
 Subject: [PATCH] ntdll: Add support for relative symlink creation.
 
 Signed-off-by: Erich E. Hoover <erich.e.hoover@gmail.com>
 ---
- dlls/ntdll/tests/file.c | 30 +++++++++++---
- dlls/ntdll/unix/file.c  | 92 +++++++++++++++++++++++++++++++++++++----
- include/ntifs.h         |  2 +
- 3 files changed, 111 insertions(+), 13 deletions(-)
+ dlls/ntdll/file.c       | 58 ++++++++++++++++++++++++++++++++++++-----
+ dlls/ntdll/tests/file.c | 30 ++++++++++++++++-----
+ include/ntifs.h         |  2 ++
+ 3 files changed, 77 insertions(+), 13 deletions(-)
 
-diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
-index 5352ff034b7..7e9b214eb63 100644
---- a/dlls/ntdll/tests/file.c
-+++ b/dlls/ntdll/tests/file.c
-@@ -5142,7 +5142,8 @@ static void test_mailslot_name(void)
-     CloseHandle( device );
- }
- 
--static INT build_reparse_buffer(const WCHAR *filename, ULONG tag, REPARSE_DATA_BUFFER **pbuffer)
-+static INT build_reparse_buffer(const WCHAR *filename, ULONG tag, ULONG flags,
-+                                REPARSE_DATA_BUFFER **pbuffer)
- {
-     static INT header_size = offsetof(REPARSE_DATA_BUFFER, GenericReparseBuffer);
-     INT buffer_size, struct_size, data_size, string_len, prefix_len;
-@@ -5160,7 +5161,7 @@ static INT build_reparse_buffer(const WCHAR *filename, ULONG tag, REPARSE_DATA_B
-     default:
-         return 0;
-     }
--    prefix_len = strlen("\\??\\");
-+    prefix_len = (flags == SYMLINK_FLAG_RELATIVE) ? 0 : strlen("\\??\\");
-     string_len = lstrlenW(&filename[prefix_len]);
-     data_size = (prefix_len + 2 * string_len + 2) * sizeof(WCHAR);
-     buffer_size = struct_size + data_size;
-@@ -5180,6 +5181,7 @@ static INT build_reparse_buffer(const WCHAR *filename, ULONG tag, REPARSE_DATA_B
-         buffer->SymbolicLinkReparseBuffer.SubstituteNameLength = (prefix_len + string_len) * sizeof(WCHAR);
-         buffer->SymbolicLinkReparseBuffer.PrintNameOffset = (prefix_len + string_len + 1) * sizeof(WCHAR);
-         buffer->SymbolicLinkReparseBuffer.PrintNameLength = string_len * sizeof(WCHAR);
-+        buffer->SymbolicLinkReparseBuffer.Flags = flags;
-         subst_dest = &buffer->SymbolicLinkReparseBuffer.PathBuffer[0];
-         print_dest = &buffer->SymbolicLinkReparseBuffer.PathBuffer[prefix_len + string_len + 1];
-         break;
-@@ -5257,7 +5259,7 @@ static void test_reparse_points(void)
-     }
-     dwret = NtQueryInformationFile(handle, &iosb, &old_attrib, sizeof(old_attrib), FileBasicInformation);
-     ok(dwret == STATUS_SUCCESS, "Failed to get junction point folder's attributes (0x%x).\n", dwret);
--    buffer_len = build_reparse_buffer(nameW.Buffer, IO_REPARSE_TAG_MOUNT_POINT, &buffer);
-+    buffer_len = build_reparse_buffer(nameW.Buffer, IO_REPARSE_TAG_MOUNT_POINT, 0, &buffer);
-     bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
-     ok(bret, "Failed to create junction point! (0x%x)\n", GetLastError());
- 
-@@ -5298,7 +5300,7 @@ static void test_reparse_points(void)
-     HeapFree(GetProcessHeap(), 0, buffer);
-     handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
-                             FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
--    buffer_len = build_reparse_buffer(nameW.Buffer, IO_REPARSE_TAG_MOUNT_POINT, &buffer);
-+    buffer_len = build_reparse_buffer(nameW.Buffer, IO_REPARSE_TAG_MOUNT_POINT, 0, &buffer);
-     bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
-     ok(bret, "Failed to create junction point! (0x%x)\n", GetLastError());
-     CloseHandle(handle);
-@@ -5313,7 +5315,7 @@ static void test_reparse_points(void)
-     ok(bret, "Failed to create junction point target directory.\n");
-     handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
-                          FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
--    buffer_len = build_reparse_buffer(nameW.Buffer, IO_REPARSE_TAG_MOUNT_POINT, &buffer);
-+    buffer_len = build_reparse_buffer(nameW.Buffer, IO_REPARSE_TAG_MOUNT_POINT, 0, &buffer);
-     bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
-     ok(bret, "Failed to create junction point! (0x%x)\n", GetLastError());
-     CloseHandle(handle);
-@@ -5375,7 +5377,7 @@ static void test_reparse_points(void)
-     }
-     dwret = NtQueryInformationFile(handle, &iosb, &old_attrib, sizeof(old_attrib), FileBasicInformation);
-     ok(dwret == STATUS_SUCCESS, "Failed to get symlink folder's attributes (0x%x).\n", dwret);
--    buffer_len = build_reparse_buffer(nameW.Buffer, IO_REPARSE_TAG_SYMLINK, &buffer);
-+    buffer_len = build_reparse_buffer(nameW.Buffer, IO_REPARSE_TAG_SYMLINK, 0, &buffer);
-     bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
-     ok(bret, "Failed to create symlink! (0x%x)\n", GetLastError());
- 
-@@ -5412,6 +5414,22 @@ static void test_reparse_points(void)
-        "Symlink folder's access time does not match.\n");
-     CloseHandle(handle);
- 
-+    /* Create a relative directory symlink */
-+    HeapFree(GetProcessHeap(), 0, buffer);
-+    handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
-+                         FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
-+    if (handle == INVALID_HANDLE_VALUE)
-+    {
-+        win_skip("Failed to open symlink directory handle (0x%x).\n", GetLastError());
-+        goto cleanup;
-+    }
-+    dwret = NtQueryInformationFile(handle, &iosb, &old_attrib, sizeof(old_attrib), FileBasicInformation);
-+    ok(dwret == STATUS_SUCCESS, "Failed to get symlink folder's attributes (0x%x).\n", dwret);
-+    buffer_len = build_reparse_buffer(targetW, IO_REPARSE_TAG_SYMLINK, SYMLINK_FLAG_RELATIVE, &buffer);
-+    bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
-+    CloseHandle(handle);
-+    ok(bret, "Failed to create symlink! (0x%x)\n", GetLastError());
-+
- cleanup:
-     /* Cleanup */
-     pRtlFreeUnicodeString(&nameW);
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index 097adfb5572..9dd65de2de6 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -5651,17 +5651,20 @@ static void ignore_server_ioctl_struct_holes( ULONG code, const void *in_buffer,
+diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
+index 3d2b874e2ee..ec8050982b0 100644
+--- a/dlls/ntdll/file.c
++++ b/dlls/ntdll/file.c
+@@ -1671,16 +1671,19 @@ NTSTATUS WINAPI NtDeviceIoControlFile(HANDLE handle, HANDLE event,
   */
  NTSTATUS FILE_CreateSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer)
  {
 -    BOOL src_allocated = FALSE, dest_allocated = FALSE, tempdir_created = FALSE;
 +    BOOL src_allocated = FALSE, path_allocated = FALSE, dest_allocated = FALSE;
 +    BOOL nt_dest_allocated = FALSE, tempdir_created = FALSE;
-+    char *unix_src, *unix_dest, *unix_path = NULL;
      char tmpdir[PATH_MAX], tmplink[PATH_MAX], *d;
-     SIZE_T unix_dest_len = PATH_MAX;
--    char *unix_src, *unix_dest;
+-    ANSI_STRING unix_src, unix_dest;
++    ANSI_STRING unix_src, unix_dest, unix_path;
      char magic_dest[PATH_MAX];
      int dest_fd, needs_close;
 +    int relative_offset = 0;
@@ -127,7 +36,7 @@ index 097adfb5572..9dd65de2de6 100644
      int i;
  
      switch(buffer->ReparseTag)
-@@ -5670,11 +5673,13 @@ NTSTATUS FILE_CreateSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer)
+@@ -1689,11 +1692,13 @@ NTSTATUS FILE_CreateSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer)
          dest_len = buffer->MountPointReparseBuffer.SubstituteNameLength;
          offset = buffer->MountPointReparseBuffer.SubstituteNameOffset;
          dest = &buffer->MountPointReparseBuffer.PathBuffer[offset];
@@ -141,7 +50,7 @@ index 097adfb5572..9dd65de2de6 100644
          break;
      default:
          return STATUS_NOT_IMPLEMENTED;
-@@ -5686,8 +5691,66 @@ NTSTATUS FILE_CreateSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer)
+@@ -1705,17 +1710,54 @@ NTSTATUS FILE_CreateSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer)
      if ((status = server_get_unix_name( handle, &unix_src )))
          goto cleanup;
      src_allocated = TRUE;
@@ -149,84 +58,47 @@ index 097adfb5572..9dd65de2de6 100644
 -    nt_dest.Length = dest_len;
 +    if (flags == SYMLINK_FLAG_RELATIVE)
 +    {
-+        SIZE_T nt_path_len = PATH_MAX, unix_path_len = PATH_MAX;
-+        WCHAR *nt_path;
++        UNICODE_STRING nt_path;
 +
-+        /* resolve the NT path of the source */
-+        unix_path = malloc( strlen(unix_src) + 2 );
++        unix_path.MaximumLength = strlen(unix_src.Buffer) + 2;
++        unix_path.Buffer = RtlAllocateHeap( GetProcessHeap(), 0, unix_path.MaximumLength );
 +        path_allocated = TRUE;
-+        strcpy( unix_path, unix_src );
-+        d = dirname( unix_path );
-+        if (d != unix_path) strcpy( unix_path, d );
-+        strcat( unix_path, "/");
-+        for (;;)
-+        {
-+            nt_path = malloc( nt_path_len * sizeof(WCHAR) );
-+            if (!nt_path)
-+            {
-+                status = STATUS_NO_MEMORY;
-+                goto cleanup;
-+            }
-+            status = wine_unix_to_nt_file_name( unix_path, nt_path, &nt_path_len );
-+            if (status != STATUS_BUFFER_TOO_SMALL) break;
-+            free( nt_path );
-+        }
-+        if (status != STATUS_SUCCESS)
++        strcpy( unix_path.Buffer, unix_src.Buffer );
++        d = dirname( unix_path.Buffer );
++        if (d != unix_path.Buffer) strcpy( unix_path.Buffer, d );
++        strcat( unix_path.Buffer, "/");
++        unix_path.Length = strlen( unix_path.Buffer );
++        if ((status = wine_unix_to_nt_file_name( &unix_path, &nt_path )))
 +            goto cleanup;
-+        free(unix_path);
-+        /* re-resolve the unix path for the source */
-+        for (;;)
-+        {
-+            UNICODE_STRING nt_path_tmp;
-+            unix_path = malloc( unix_path_len );
-+            if (!unix_path)
-+            {
-+                status = STATUS_NO_MEMORY;
-+                goto cleanup;
-+            }
-+            nt_path_tmp.Buffer = nt_path;
-+            nt_path_tmp.Length = wcslen(nt_path) * sizeof(WCHAR);
-+            status = wine_nt_to_unix_file_name( &nt_path_tmp, unix_path, &unix_path_len, FALSE );
-+            if (status != STATUS_BUFFER_TOO_SMALL) break;
-+            free( unix_path );
-+        }
-+        /* append the destination */
-+        nt_dest.MaximumLength = dest_len + (wcslen( nt_path ) + 1) * sizeof(WCHAR);
-+        nt_dest.Buffer = malloc( nt_dest.MaximumLength );
-+        wcscpy( nt_dest.Buffer, nt_path );
-+        free( nt_path );
++        nt_dest.MaximumLength = dest_len + (wcslen( nt_path.Buffer ) + 1) * sizeof(WCHAR);
++        nt_dest.Buffer = RtlAllocateHeap( GetProcessHeap(), 0, nt_dest.MaximumLength );
++        wcscpy( nt_dest.Buffer, nt_path.Buffer );
++        RtlFreeUnicodeString( &nt_path );
 +        memcpy( &nt_dest.Buffer[wcslen(nt_dest.Buffer)], dest, dest_len + sizeof(WCHAR));
 +        nt_dest.Length = wcslen( nt_dest.Buffer ) * sizeof(WCHAR);
 +    }
 +    else
 +    {
-+        nt_dest.MaximumLength = (wcslen( dest ) + 1) * sizeof(WCHAR);
-+        nt_dest.Buffer = malloc( nt_dest.MaximumLength );
-+        wcscpy( nt_dest.Buffer, dest );
++        RtlCreateUnicodeString( &nt_dest, dest );
 +        nt_dest.Length = dest_len;
 +    }
 +    nt_dest_allocated = TRUE;
-+    /* resolve the NT path of the destination */
-     for (;;)
-     {
-         unix_dest = malloc( unix_dest_len );
-@@ -5703,11 +5766,24 @@ NTSTATUS FILE_CreateSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer)
+     status = wine_nt_to_unix_file_name( &nt_dest, &unix_dest, 0, FALSE );
      if (status != STATUS_SUCCESS && status != STATUS_NO_SUCH_FILE)
          goto cleanup;
      dest_allocated = TRUE;
-+    /* check that the source and destination paths are the same up to the relative path */
 +    if (flags == SYMLINK_FLAG_RELATIVE)
 +    {
-+        relative_offset = strlen(unix_path);
-+        if (strncmp( unix_path, unix_dest, relative_offset ) != 0)
++        relative_offset = strlen(unix_path.Buffer);
++        if (strncmp( unix_path.Buffer, unix_dest.Buffer, relative_offset ) != 0)
 +        {
 +            status = STATUS_IO_REPARSE_DATA_INVALID;
 +            goto cleanup;
 +        }
 +    }
  
--    TRACE( "Linking %s to %s\n", unix_src, unix_dest );
-+    TRACE( "Linking %s to %s\n", unix_src, &unix_dest[relative_offset] );
+-    TRACE("Linking %s to %s\n", unix_src.Buffer, unix_dest.Buffer);
++    TRACE("Linking %s to %s\n", unix_src.Buffer, &unix_dest.Buffer[relative_offset]);
  
      /* Encode the reparse tag into the symlink */
 -    strcpy( magic_dest, "/" );
@@ -237,25 +109,115 @@ index 097adfb5572..9dd65de2de6 100644
      for (i = 0; i < sizeof(ULONG)*8; i++)
      {
          if ((buffer->ReparseTag >> i) & 1)
-@@ -5726,7 +5802,7 @@ NTSTATUS FILE_CreateSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer)
+@@ -1734,7 +1776,7 @@ NTSTATUS FILE_CreateSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer)
              strcat( magic_dest, "." );
          strcat( magic_dest, "/" );
      }
--    strcat( magic_dest, unix_dest );
-+    strcat( magic_dest, &unix_dest[relative_offset] );
+-    strcat( magic_dest, unix_dest.Buffer );
++    strcat( magic_dest, &unix_dest.Buffer[relative_offset] );
  
      /* Produce the link in a temporary location in the same folder */
-     strcpy( tmpdir, unix_src );
-@@ -5776,7 +5852,9 @@ NTSTATUS FILE_CreateSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer)
+     strcpy( tmpdir, unix_src.Buffer );
+@@ -1784,7 +1826,9 @@ NTSTATUS FILE_CreateSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer)
  
  cleanup:
      if (tempdir_created) rmdir( tmpdir );
-+    if (path_allocated) free( unix_path );
-     if (dest_allocated) free( unix_dest );
-+    if (nt_dest_allocated) free( nt_dest.Buffer );
-     if (src_allocated) free( unix_src );
++    if (path_allocated) RtlFreeAnsiString( &unix_path );
+     if (dest_allocated) RtlFreeAnsiString( &unix_dest );
++    if (nt_dest_allocated) RtlFreeUnicodeString( &nt_dest );
+     if (src_allocated) RtlFreeAnsiString( &unix_src );
      if (needs_close) close( dest_fd );
      return status;
+diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
+index dc273734719..4d67a46fea6 100644
+--- a/dlls/ntdll/tests/file.c
++++ b/dlls/ntdll/tests/file.c
+@@ -4955,7 +4955,8 @@ static void test_file_readonly_access(void)
+     DeleteFileW(path);
+ }
+ 
+-static INT build_reparse_buffer(const WCHAR *filename, ULONG tag, REPARSE_DATA_BUFFER **pbuffer)
++static INT build_reparse_buffer(const WCHAR *filename, ULONG tag, ULONG flags,
++                                REPARSE_DATA_BUFFER **pbuffer)
+ {
+     static INT header_size = offsetof(REPARSE_DATA_BUFFER, GenericReparseBuffer);
+     INT buffer_size, struct_size, data_size, string_len, prefix_len;
+@@ -4973,7 +4974,7 @@ static INT build_reparse_buffer(const WCHAR *filename, ULONG tag, REPARSE_DATA_B
+     default:
+         return 0;
+     }
+-    prefix_len = strlen("\\??\\");
++    prefix_len = (flags == SYMLINK_FLAG_RELATIVE) ? 0 : strlen("\\??\\");
+     string_len = lstrlenW(&filename[prefix_len]);
+     data_size = (prefix_len + 2 * string_len + 2) * sizeof(WCHAR);
+     buffer_size = struct_size + data_size;
+@@ -4993,6 +4994,7 @@ static INT build_reparse_buffer(const WCHAR *filename, ULONG tag, REPARSE_DATA_B
+         buffer->SymbolicLinkReparseBuffer.SubstituteNameLength = (prefix_len + string_len) * sizeof(WCHAR);
+         buffer->SymbolicLinkReparseBuffer.PrintNameOffset = (prefix_len + string_len + 1) * sizeof(WCHAR);
+         buffer->SymbolicLinkReparseBuffer.PrintNameLength = string_len * sizeof(WCHAR);
++        buffer->SymbolicLinkReparseBuffer.Flags = flags;
+         subst_dest = &buffer->SymbolicLinkReparseBuffer.PathBuffer[0];
+         print_dest = &buffer->SymbolicLinkReparseBuffer.PathBuffer[prefix_len + string_len + 1];
+         break;
+@@ -5070,7 +5072,7 @@ static void test_reparse_points(void)
+     }
+     dwret = NtQueryInformationFile(handle, &iosb, &old_attrib, sizeof(old_attrib), FileBasicInformation);
+     ok(dwret == STATUS_SUCCESS, "Failed to get junction point folder's attributes (0x%x).\n", dwret);
+-    buffer_len = build_reparse_buffer(nameW.Buffer, IO_REPARSE_TAG_MOUNT_POINT, &buffer);
++    buffer_len = build_reparse_buffer(nameW.Buffer, IO_REPARSE_TAG_MOUNT_POINT, 0, &buffer);
+     bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
+     ok(bret, "Failed to create junction point! (0x%x)\n", GetLastError());
+ 
+@@ -5111,7 +5113,7 @@ static void test_reparse_points(void)
+     HeapFree(GetProcessHeap(), 0, buffer);
+     handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
+                             FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
+-    buffer_len = build_reparse_buffer(nameW.Buffer, IO_REPARSE_TAG_MOUNT_POINT, &buffer);
++    buffer_len = build_reparse_buffer(nameW.Buffer, IO_REPARSE_TAG_MOUNT_POINT, 0, &buffer);
+     bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
+     ok(bret, "Failed to create junction point! (0x%x)\n", GetLastError());
+     CloseHandle(handle);
+@@ -5126,7 +5128,7 @@ static void test_reparse_points(void)
+     ok(bret, "Failed to create junction point target directory.\n");
+     handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
+                          FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
+-    buffer_len = build_reparse_buffer(nameW.Buffer, IO_REPARSE_TAG_MOUNT_POINT, &buffer);
++    buffer_len = build_reparse_buffer(nameW.Buffer, IO_REPARSE_TAG_MOUNT_POINT, 0, &buffer);
+     bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
+     ok(bret, "Failed to create junction point! (0x%x)\n", GetLastError());
+     CloseHandle(handle);
+@@ -5188,7 +5190,7 @@ static void test_reparse_points(void)
+     }
+     dwret = NtQueryInformationFile(handle, &iosb, &old_attrib, sizeof(old_attrib), FileBasicInformation);
+     ok(dwret == STATUS_SUCCESS, "Failed to get symlink folder's attributes (0x%x).\n", dwret);
+-    buffer_len = build_reparse_buffer(nameW.Buffer, IO_REPARSE_TAG_SYMLINK, &buffer);
++    buffer_len = build_reparse_buffer(nameW.Buffer, IO_REPARSE_TAG_SYMLINK, 0, &buffer);
+     bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
+     ok(bret, "Failed to create symlink! (0x%x)\n", GetLastError());
+ 
+@@ -5225,6 +5227,22 @@ static void test_reparse_points(void)
+        "Symlink folder's access time does not match.\n");
+     CloseHandle(handle);
+ 
++    /* Create a relative directory symlink */
++    HeapFree(GetProcessHeap(), 0, buffer);
++    handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
++                         FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
++    if (handle == INVALID_HANDLE_VALUE)
++    {
++        win_skip("Failed to open symlink directory handle (0x%x).\n", GetLastError());
++        goto cleanup;
++    }
++    dwret = NtQueryInformationFile(handle, &iosb, &old_attrib, sizeof(old_attrib), FileBasicInformation);
++    ok(dwret == STATUS_SUCCESS, "Failed to get symlink folder's attributes (0x%x).\n", dwret);
++    buffer_len = build_reparse_buffer(targetW, IO_REPARSE_TAG_SYMLINK, SYMLINK_FLAG_RELATIVE, &buffer);
++    bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
++    CloseHandle(handle);
++    ok(bret, "Failed to create symlink! (0x%x)\n", GetLastError());
++
+ cleanup:
+     /* Cleanup */
+     pRtlFreeUnicodeString(&nameW);
 diff --git a/include/ntifs.h b/include/ntifs.h
 index ab3273d3f81..0d02225bc4f 100644
 --- a/include/ntifs.h
@@ -268,5 +230,5 @@ index ab3273d3f81..0d02225bc4f 100644
 +
  #endif /* __WINE_NTIFS_H */
 -- 
-2.28.0
+2.25.1
 
diff --git a/patches/ntdll-Junction_Points/0011-ntdll-Add-support-for-reading-relative-symlinks.patch b/patches/ntdll-Junction_Points/0011-ntdll-Add-support-for-reading-relative-symlinks.patch
index 7afe8a5b..60b986da 100644
--- a/patches/ntdll-Junction_Points/0011-ntdll-Add-support-for-reading-relative-symlinks.patch
+++ b/patches/ntdll-Junction_Points/0011-ntdll-Add-support-for-reading-relative-symlinks.patch
@@ -1,56 +1,30 @@
-From 5658e73f218d01b0e11bc4575cf0502b8235ec2c Mon Sep 17 00:00:00 2001
+From 6e8b35c8a5c0d0dd1bd55d21c156b3ced65d376c Mon Sep 17 00:00:00 2001
 From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
 Date: Thu, 11 Apr 2019 12:31:16 -0600
-Subject: ntdll: Add support for reading relative symlinks.
+Subject: [PATCH] ntdll: Add support for reading relative symlinks.
 
 Signed-off-by: Erich E. Hoover <erich.e.hoover@gmail.com>
 ---
- dlls/ntdll/tests/file.c | 13 ++++++++-
- dlls/ntdll/unix/file.c  | 61 ++++++++++++++++++++++++++++++++++++++++-
- 2 files changed, 72 insertions(+), 2 deletions(-)
+ dlls/ntdll/file.c       | 44 ++++++++++++++++++++++++++++++++++++++++-
+ dlls/ntdll/tests/file.c | 13 +++++++++++-
+ 2 files changed, 55 insertions(+), 2 deletions(-)
 
-diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
-index 9b510fe9057..0db7372a0c8 100644
---- a/dlls/ntdll/tests/file.c
-+++ b/dlls/ntdll/tests/file.c
-@@ -5258,9 +5258,20 @@ static void test_reparse_points(void)
-     ok(dwret == STATUS_SUCCESS, "Failed to get symlink folder's attributes (0x%x).\n", dwret);
-     buffer_len = build_reparse_buffer(targetW, IO_REPARSE_TAG_SYMLINK, SYMLINK_FLAG_RELATIVE, &buffer);
-     bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
--    CloseHandle(handle);
-     ok(bret, "Failed to create symlink! (0x%x)\n", GetLastError());
- 
-+    /* Read back the relative symlink */
-+    HeapFree(GetProcessHeap(), 0, buffer);
-+    buffer_len = sizeof(*buffer) + MAX_PATH*sizeof(WCHAR);
-+    buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, buffer_len);
-+    bret = DeviceIoControl(handle, FSCTL_GET_REPARSE_POINT, NULL, 0, (LPVOID)buffer, buffer_len, &dwret, 0);
-+    ok(bret, "Failed to read relative symlink!\n");
-+    string_len = buffer->SymbolicLinkReparseBuffer.SubstituteNameLength;
-+    dest = &buffer->SymbolicLinkReparseBuffer.PathBuffer[buffer->SymbolicLinkReparseBuffer.SubstituteNameOffset/sizeof(WCHAR)];
-+    ok((memcmp(dest, targetW, string_len) == 0), "Symlink destination does not match ('%s' != '%s')!\n",
-+                                                 wine_dbgstr_w(dest), wine_dbgstr_w(targetW));
-+    CloseHandle(handle);
-+
- cleanup:
-     /* Cleanup */
-     pRtlFreeUnicodeString(&nameW);
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index 3652fbb1a0d..e62a2529bb2 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -5820,6 +5820,7 @@ NTSTATUS FILE_GetSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer, ULONG out_s
+diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
+index 3001b22ff30..780d65c0e96 100644
+--- a/dlls/ntdll/file.c
++++ b/dlls/ntdll/file.c
+@@ -1846,6 +1846,7 @@ NTSTATUS FILE_GetSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer, ULONG out_s
      BOOL dest_allocated = FALSE;
      int dest_fd, needs_close;
-     int unix_dest_len;
+     UNICODE_STRING nt_dest;
 +    int path_len = 0;
      DWORD max_length;
      NTSTATUS status;
      ULONG flags = 0;
-@@ -5845,6 +5846,11 @@ NTSTATUS FILE_GetSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer, ULONG out_s
+@@ -1873,6 +1874,11 @@ NTSTATUS FILE_GetSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer, ULONG out_s
  
      /* Decode the reparse tag from the symlink */
-     p = unix_dest;
+     p = unix_dest.Buffer;
 +    if (*p == '.')
 +    {
 +        flags = SYMLINK_FLAG_RELATIVE;
@@ -59,75 +33,80 @@ index 3652fbb1a0d..e62a2529bb2 100644
      if (*p++ != '/')
      {
          status = STATUS_NOT_IMPLEMENTED;
-@@ -5881,6 +5887,25 @@ NTSTATUS FILE_GetSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer, ULONG out_s
-     unix_dest_len -= (p - unix_dest);
-     memmove(unix_dest, p, unix_dest_len);
+@@ -1909,10 +1915,46 @@ NTSTATUS FILE_GetSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer, ULONG out_s
+     unix_dest.Length -= (p - unix_dest.Buffer);
+     memmove(unix_dest.Buffer, p, unix_dest.Length);
  
 +    /* convert the relative path into an absolute path */
 +    if (flags == SYMLINK_FLAG_RELATIVE)
 +    {
-+        int unix_src_len = strlen(unix_src);
-+        int offset = unix_src_len + 2;
++        int offset = unix_src.Length + 2;
 +        char *d;
-+
-+        memcpy( &unix_dest[offset], unix_dest, unix_dest_len );
-+        unix_dest[offset+unix_dest_len] = 0;
-+        memcpy( unix_dest, unix_src, unix_src_len );
-+        unix_dest[unix_src_len] = 0;
-+        d = dirname( unix_dest );
-+        if (d != unix_dest) strcpy( unix_dest, d );
-+        strcat( unix_dest, "/" );
-+        path_len = strlen( unix_dest );
-+        memmove( &unix_dest[path_len], &unix_dest[offset], unix_dest_len + 1 );
-+        unix_dest_len = strlen( unix_dest );
++        memcpy( &unix_dest.Buffer[offset], unix_dest.Buffer, unix_dest.Length );
++        unix_dest.Buffer[offset+unix_dest.Length] = 0;
++        memcpy( unix_dest.Buffer, unix_src.Buffer, unix_src.Length );
++        unix_dest.Buffer[unix_src.Length] = 0;
++        d = dirname( unix_dest.Buffer );
++        if (d != unix_dest.Buffer) strcpy( unix_dest.Buffer, d );
++        strcat( unix_dest.Buffer, "/" );
++        path_len = strlen( unix_dest.Buffer );
++        memmove( &unix_dest.Buffer[path_len], &unix_dest.Buffer[offset], unix_dest.Length + 1 );
++        unix_dest.Length = strlen( unix_dest.Buffer );
 +    }
-+    /* resolve the NT path */
-     for (;;)
-     {
-         nt_dest = malloc( nt_dest_len * sizeof(WCHAR) );
-@@ -5898,7 +5923,41 @@ NTSTATUS FILE_GetSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer, ULONG out_s
+     if ((status = wine_unix_to_nt_file_name( &unix_dest, &nt_dest )))
          goto cleanup;
-     nt_dest_len *= sizeof(WCHAR);
- 
--    prefix_len = strlen("\\??\\");
 +    /* remove the relative path from the NT path */
 +    if (flags == SYMLINK_FLAG_RELATIVE)
 +    {
-+        SIZE_T nt_path_len = PATH_MAX;
++        UNICODE_STRING nt_path;
 +        int relative_offset;
-+        WCHAR *nt_path;
 +
-+        unix_dest_len = path_len;
-+        for (;;)
-+        {
-+            nt_path = malloc( nt_path_len * sizeof(WCHAR) );
-+            if (!nt_path)
-+            {
-+                status = STATUS_NO_MEMORY;
-+                goto cleanup;
-+            }
-+            status = wine_unix_to_nt_file_name( unix_dest, nt_path, &nt_path_len );
-+            if (status != STATUS_BUFFER_TOO_SMALL) break;
-+            free( nt_path );
-+        }
-+        if (status != STATUS_SUCCESS)
++        unix_dest.Length = path_len;
++        if ((status = wine_unix_to_nt_file_name( &unix_dest, &nt_path )))
 +            goto cleanup;
-+        relative_offset = lstrlenW( nt_path );
-+        if (wcsnicmp( nt_path, nt_dest, relative_offset ) != 0)
++        relative_offset = wcslen( nt_path.Buffer );
++        if (wcsncmp( nt_path.Buffer, nt_dest.Buffer, relative_offset ) != 0)
 +        {
-+            free( nt_path );
++            RtlFreeUnicodeString( &nt_path );
 +            status = STATUS_IO_REPARSE_DATA_INVALID;
 +            goto cleanup;
 +        }
-+        free( nt_path );
-+        nt_dest_len = lstrlenW( &nt_dest[relative_offset] ) * sizeof(WCHAR);
-+        memmove( nt_dest, &nt_dest[relative_offset], nt_dest_len + sizeof(WCHAR) );
++        RtlFreeUnicodeString( &nt_path );
++        nt_dest.Length = wcslen( &nt_dest.Buffer[relative_offset] ) * sizeof(WCHAR);
++        memmove( nt_dest.Buffer, &nt_dest.Buffer[relative_offset], nt_dest.Length + sizeof(WCHAR) );
 +    }
-+
+ 
+-    prefix_len = strlen("\\??\\");
 +    prefix_len = (flags == SYMLINK_FLAG_RELATIVE) ? 0 : strlen("\\??\\");
      switch(buffer->ReparseTag)
      {
      case IO_REPARSE_TAG_MOUNT_POINT:
+diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
+index 4d67a46fea6..35e674e817c 100644
+--- a/dlls/ntdll/tests/file.c
++++ b/dlls/ntdll/tests/file.c
+@@ -5240,9 +5240,20 @@ static void test_reparse_points(void)
+     ok(dwret == STATUS_SUCCESS, "Failed to get symlink folder's attributes (0x%x).\n", dwret);
+     buffer_len = build_reparse_buffer(targetW, IO_REPARSE_TAG_SYMLINK, SYMLINK_FLAG_RELATIVE, &buffer);
+     bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
+-    CloseHandle(handle);
+     ok(bret, "Failed to create symlink! (0x%x)\n", GetLastError());
+ 
++    /* Read back the relative symlink */
++    HeapFree(GetProcessHeap(), 0, buffer);
++    buffer_len = sizeof(*buffer) + MAX_PATH*sizeof(WCHAR);
++    buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, buffer_len);
++    bret = DeviceIoControl(handle, FSCTL_GET_REPARSE_POINT, NULL, 0, (LPVOID)buffer, buffer_len, &dwret, 0);
++    ok(bret, "Failed to read relative symlink!\n");
++    string_len = buffer->SymbolicLinkReparseBuffer.SubstituteNameLength;
++    dest = &buffer->SymbolicLinkReparseBuffer.PathBuffer[buffer->SymbolicLinkReparseBuffer.SubstituteNameOffset/sizeof(WCHAR)];
++    ok((memcmp(dest, targetW, string_len) == 0), "Symlink destination does not match ('%s' != '%s')!\n",
++                                                 wine_dbgstr_w(dest), wine_dbgstr_w(targetW));
++    CloseHandle(handle);
++
+ cleanup:
+     /* Cleanup */
+     pRtlFreeUnicodeString(&nameW);
 -- 
-2.17.1
+2.25.1
 
diff --git a/patches/ntdll-Junction_Points/0012-ntdll-Add-support-for-file-symlinks.patch b/patches/ntdll-Junction_Points/0012-ntdll-Add-support-for-file-symlinks.patch
index 5b6dd9e4..b9b349be 100644
--- a/patches/ntdll-Junction_Points/0012-ntdll-Add-support-for-file-symlinks.patch
+++ b/patches/ntdll-Junction_Points/0012-ntdll-Add-support-for-file-symlinks.patch
@@ -1,59 +1,19 @@
-From d98202d50cdb09fe199414b8a313fcf954725e2d Mon Sep 17 00:00:00 2001
+From 824e8fa59621da5b509297d25a95cad8d4562e68 Mon Sep 17 00:00:00 2001
 From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
 Date: Thu, 11 Apr 2019 17:57:53 -0600
 Subject: ntdll: Add support for file symlinks.
 
 Signed-off-by: Erich E. Hoover <erich.e.hoover@gmail.com>
 ---
+ dlls/ntdll/file.c       | 27 ++++++++++++++++++++++-----
  dlls/ntdll/tests/file.c | 29 +++++++++++++++++++++++++++++
- dlls/ntdll/unix/file.c  | 27 ++++++++++++++++++++++-----
  2 files changed, 51 insertions(+), 5 deletions(-)
 
-diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
-index 0db7372a0c8..58fec76bec4 100644
---- a/dlls/ntdll/tests/file.c
-+++ b/dlls/ntdll/tests/file.c
-@@ -5191,6 +5191,35 @@ static void test_reparse_points(void)
-     /* Delete the junction point directory and create a blank slate for symlink tests */
-     bret = RemoveDirectoryW(reparse_path);
-     ok(bret, "Failed to delete junction point!\n");
-+
-+    /* Create the file symlink */
-+    HeapFree(GetProcessHeap(), 0, buffer);
-+    handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, CREATE_NEW,
-+                         FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
-+    ok(handle != INVALID_HANDLE_VALUE, "Failed to create symlink file.\n");
-+    dwret = NtQueryInformationFile(handle, &iosb, &old_attrib, sizeof(old_attrib), FileBasicInformation);
-+    ok(dwret == STATUS_SUCCESS, "Failed to get symlink file's attributes (0x%x).\n", dwret);
-+    buffer_len = build_reparse_buffer(nameW.Buffer, IO_REPARSE_TAG_SYMLINK, 0, &buffer);
-+    bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
-+    ok(bret, "Failed to create symlink! (0x%x)\n", GetLastError());
-+    CloseHandle(handle);
-+
-+    /* Check deleting a file symlink as if it were a directory */
-+    bret = RemoveDirectoryW(reparse_path);
-+    todo_wine ok(!bret, "Succeeded in deleting file symlink as a directory!\n");
-+    err = GetLastError();
-+    todo_wine ok(err == ERROR_DIRECTORY,
-+                 "Expected last error 0x%x for RemoveDirectory on file symlink (actually 0x%x)!\n",
-+                 ERROR_DIRECTORY, err);
-+    dwret = GetFileAttributesW(reparse_path);
-+    todo_wine ok(dwret != (DWORD)~0, "Symlink doesn't exist (attributes: 0x%x)!\n", dwret);
-+    ok(dwret & FILE_ATTRIBUTE_REPARSE_POINT, "File is not a symlink! (attributes: 0x%x)\n", dwret);
-+
-+    /* Delete the symlink as a file */
-+    bret = DeleteFileW(reparse_path);
-+    todo_wine ok(bret, "Failed to delete symlink as a file!\n");
-+
-+    /* Create a blank slate for directory symlink tests */
-     bret = CreateDirectoryW(reparse_path, NULL);
-     ok(bret, "Failed to create junction point directory.\n");
-     dwret = GetFileAttributesW(reparse_path);
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index e62a2529bb2..242d344e1f5 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -5610,6 +5610,7 @@ NTSTATUS FILE_CreateSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer)
+diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
+index 7af9c6635a..2f10472eeb 100644
+--- a/dlls/ntdll/file.c
++++ b/dlls/ntdll/file.c
+@@ -1656,6 +1656,7 @@ NTSTATUS FILE_CreateSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer)
      int relative_offset = 0;
      UNICODE_STRING nt_dest;
      int dest_len, offset;
@@ -61,8 +21,8 @@ index e62a2529bb2..242d344e1f5 100644
      NTSTATUS status;
      struct stat st;
      WCHAR *dest;
-@@ -5745,7 +5746,8 @@ NTSTATUS FILE_CreateSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer)
-             status = errno_to_status( errno );
+@@ -1748,7 +1749,8 @@ NTSTATUS FILE_CreateSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer)
+             status = FILE_GetNtStatus();
              goto cleanup;
          }
 -        if (S_ISDIR(st.st_mode))
@@ -71,9 +31,9 @@ index e62a2529bb2..242d344e1f5 100644
              strcat( magic_dest, "." );
          strcat( magic_dest, "/" );
      }
-@@ -5772,8 +5774,11 @@ NTSTATUS FILE_CreateSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer)
+@@ -1775,8 +1777,11 @@ NTSTATUS FILE_CreateSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer)
      /* Atomically move the link into position */
-     if (!renameat2( -1, tmplink, -1, unix_src, RENAME_EXCHANGE ))
+     if (!renameat2( -1, tmplink, -1, unix_src.Buffer, RENAME_EXCHANGE ))
      {
 -        /* success: link and folder have switched locations */
 -        rmdir( tmplink ); /* remove the folder (at link location) */
@@ -85,37 +45,37 @@ index e62a2529bb2..242d344e1f5 100644
      }
      else if (errno == ENOSYS)
      {
-@@ -6011,6 +6016,7 @@ NTSTATUS FILE_RemoveSymlink(HANDLE handle, REPARSE_GUID_DATA_BUFFER *buffer)
-     char tmpdir[PATH_MAX], tmpfile[PATH_MAX], *d;
+@@ -1985,6 +1990,7 @@ NTSTATUS FILE_RemoveSymlink(HANDLE handle, REPARSE_GUID_DATA_BUFFER *buffer)
      BOOL tempdir_created = FALSE;
      int dest_fd, needs_close;
+     ANSI_STRING unix_name;
 +    BOOL is_dir = TRUE;
      NTSTATUS status;
-     char *unix_name;
      struct stat st;
-@@ -6023,12 +6029,13 @@ NTSTATUS FILE_RemoveSymlink(HANDLE handle, REPARSE_GUID_DATA_BUFFER *buffer)
  
-     TRACE( "Deleting symlink %s\n", unix_name );
+@@ -1996,12 +2002,13 @@ NTSTATUS FILE_RemoveSymlink(HANDLE handle, REPARSE_GUID_DATA_BUFFER *buffer)
+ 
+     TRACE("Deleting symlink %s\n", unix_name.Buffer);
  
 -    /* Produce the directory in a temporary location in the same folder */
 +    /* Produce the file/directory in a temporary location in the same folder */
      if (fstat( dest_fd, &st ) == -1)
      {
-         status = errno_to_status( errno );
+         status = FILE_GetNtStatus();
          goto cleanup;
      }
 +    is_dir = S_ISDIR(st.st_mode);
-     strcpy( tmpdir, unix_name );
+     strcpy( tmpdir, unix_name.Buffer );
      d = dirname( tmpdir);
      if (d != tmpdir) strcpy( tmpdir, d );
-@@ -6041,11 +6048,21 @@ NTSTATUS FILE_RemoveSymlink(HANDLE handle, REPARSE_GUID_DATA_BUFFER *buffer)
+@@ -2014,11 +2021,21 @@ NTSTATUS FILE_RemoveSymlink(HANDLE handle, REPARSE_GUID_DATA_BUFFER *buffer)
      tempdir_created = TRUE;
      strcpy( tmpfile, tmpdir );
      strcat( tmpfile, "/tmpfile" );
 -    if (mkdir( tmpfile, st.st_mode ))
 +    if (is_dir && mkdir( tmpfile, st.st_mode ))
      {
-         status = errno_to_status( errno );
+         status = FILE_GetNtStatus();
          goto cleanup;
      }
 +    else if (!is_dir)
@@ -123,7 +83,7 @@ index e62a2529bb2..242d344e1f5 100644
 +        int fd = open( tmpfile, O_CREAT|O_WRONLY|O_TRUNC, st.st_mode );
 +        if (fd < 0)
 +            {
-+            status = errno_to_status( errno );
++            status = FILE_GetNtStatus();
 +            goto cleanup;
 +        }
 +        close( fd );
@@ -131,6 +91,46 @@ index e62a2529bb2..242d344e1f5 100644
      /* attemp to retain the ownership (if possible) */
      lchown( tmpfile, st.st_uid, st.st_gid );
      /* Atomically move the directory into position */
+diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
+index a17e792ae0..b904bc1f2d 100644
+--- a/dlls/ntdll/tests/file.c
++++ b/dlls/ntdll/tests/file.c
+@@ -5050,6 +5050,35 @@ static void test_reparse_points(void)
+     /* Delete the junction point directory and create a blank slate for symlink tests */
+     bret = RemoveDirectoryW(reparse_path);
+     ok(bret, "Failed to delete junction point!\n");
++
++    /* Create the file symlink */
++    HeapFree(GetProcessHeap(), 0, buffer);
++    handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, CREATE_NEW,
++                         FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
++    ok(handle != INVALID_HANDLE_VALUE, "Failed to create symlink file.\n");
++    dwret = NtQueryInformationFile(handle, &iosb, &old_attrib, sizeof(old_attrib), FileBasicInformation);
++    ok(dwret == STATUS_SUCCESS, "Failed to get symlink file's attributes (0x%x).\n", dwret);
++    buffer_len = build_reparse_buffer(nameW.Buffer, IO_REPARSE_TAG_SYMLINK, 0, &buffer);
++    bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
++    ok(bret, "Failed to create symlink! (0x%x)\n", GetLastError());
++    CloseHandle(handle);
++
++    /* Check deleting a file symlink as if it were a directory */
++    bret = RemoveDirectoryW(reparse_path);
++    todo_wine ok(!bret, "Succeeded in deleting file symlink as a directory!\n");
++    err = GetLastError();
++    todo_wine ok(err == ERROR_DIRECTORY,
++                 "Expected last error 0x%x for RemoveDirectory on file symlink (actually 0x%x)!\n",
++                 ERROR_DIRECTORY, err);
++    dwret = GetFileAttributesW(reparse_path);
++    todo_wine ok(dwret != (DWORD)~0, "Symlink doesn't exist (attributes: 0x%x)!\n", dwret);
++    ok(dwret & FILE_ATTRIBUTE_REPARSE_POINT, "File is not a symlink! (attributes: 0x%x)\n", dwret);
++
++    /* Delete the symlink as a file */
++    bret = DeleteFileW(reparse_path);
++    todo_wine ok(bret, "Failed to delete symlink as a file!\n");
++
++    /* Create a blank slate for directory symlink tests */
+     bret = CreateDirectoryW(reparse_path, NULL);
+     ok(bret, "Failed to create junction point directory.\n");
+     dwret = GetFileAttributesW(reparse_path);
 -- 
 2.17.1
 
diff --git a/patches/ntdll-Junction_Points/0013-ntdll-Allow-creation-of-dangling-reparse-points-to-n.patch b/patches/ntdll-Junction_Points/0013-ntdll-Allow-creation-of-dangling-reparse-points-to-n.patch
index 9555993b..57e40156 100644
--- a/patches/ntdll-Junction_Points/0013-ntdll-Allow-creation-of-dangling-reparse-points-to-n.patch
+++ b/patches/ntdll-Junction_Points/0013-ntdll-Allow-creation-of-dangling-reparse-points-to-n.patch
@@ -1,20 +1,21 @@
-From 767c81a6bb76f0f852f4ba7260dc0c1b26b45e09 Mon Sep 17 00:00:00 2001
+From 5b9831bcc26ab81b428b9c8f996c50b50c195a5d Mon Sep 17 00:00:00 2001
 From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
 Date: Tue, 30 Apr 2019 16:24:54 -0600
-Subject: ntdll: Allow creation of dangling reparse points to non-existent
- paths.
+Subject: [PATCH] ntdll: Allow creation of dangling reparse points to
+ non-existent paths.
 
 Signed-off-by: Erich E. Hoover <erich.e.hoover@gmail.com>
 ---
- dlls/ntdll/unix/file.c | 15 ++++++++++++++-
+ dlls/ntdll/directory.c | 13 +++++++++++++
+ dlls/ntdll/file.c      |  3 ++-
  include/winternl.h     |  1 +
- 2 files changed, 15 insertions(+), 1 deletion(-)
+ 3 files changed, 16 insertions(+), 1 deletion(-)
 
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index 242d344e1f5..248bda3d3ce 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -3154,6 +3154,19 @@ static NTSTATUS lookup_unix_name( const WCHAR *name, int name_len, char **buffer
+diff --git a/dlls/ntdll/directory.c b/dlls/ntdll/directory.c
+index 7b0627cd3d..669fd56cbe 100644
+--- a/dlls/ntdll/directory.c
++++ b/dlls/ntdll/directory.c
+@@ -2644,6 +2644,19 @@ static NTSTATUS lookup_unix_name( const WCHAR *name, int name_len, char **buffer
                  status = STATUS_OBJECT_NAME_COLLISION;
              }
          }
@@ -34,20 +35,26 @@ index 242d344e1f5..248bda3d3ce 100644
  
          if (status != STATUS_SUCCESS) break;
  
-@@ -5707,7 +5720,7 @@ NTSTATUS FILE_CreateSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer)
-             status = STATUS_NO_MEMORY;
-             goto cleanup;
-         }
--        status = wine_nt_to_unix_file_name( &nt_dest, unix_dest, &unix_dest_len, FALSE );
-+        status = wine_nt_to_unix_file_name( &nt_dest, unix_dest, &unix_dest_len, FILE_WINE_PATH );
-         if (status != STATUS_BUFFER_TOO_SMALL) break;
-         free( unix_dest );
+diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
+index e27382adf7..22764f05f3 100644
+--- a/dlls/ntdll/file.c
++++ b/dlls/ntdll/file.c
+@@ -1714,8 +1714,9 @@ NTSTATUS FILE_CreateSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer)
+         RtlCreateUnicodeString( &nt_dest, dest );
+         nt_dest.Length = dest_len;
      }
++
+     nt_dest_allocated = TRUE;
+-    status = wine_nt_to_unix_file_name( &nt_dest, &unix_dest, 0, FALSE );
++    status = wine_nt_to_unix_file_name( &nt_dest, &unix_dest, FILE_WINE_PATH, FALSE );
+     if (status != STATUS_SUCCESS && status != STATUS_NO_SUCH_FILE)
+         goto cleanup;
+     dest_allocated = TRUE;
 diff --git a/include/winternl.h b/include/winternl.h
-index b3fbb90feff..221c8e39e84 100644
+index e0a827a11c..b71e456b53 100644
 --- a/include/winternl.h
 +++ b/include/winternl.h
-@@ -1869,6 +1869,7 @@ typedef struct _RTL_HANDLE_TABLE
+@@ -1816,6 +1816,7 @@ typedef struct _RTL_HANDLE_TABLE
  #define FILE_OVERWRITE                  4
  #define FILE_OVERWRITE_IF               5
  #define FILE_MAXIMUM_DISPOSITION        5
@@ -56,5 +63,5 @@ index b3fbb90feff..221c8e39e84 100644
  /* Characteristics of a File System */
  #define FILE_REMOVABLE_MEDIA                      0x00000001
 -- 
-2.17.1
+2.24.1
 
diff --git a/patches/ntdll-Junction_Points/0014-ntdll-Correctly-report-file-symbolic-links-as-files.patch b/patches/ntdll-Junction_Points/0014-ntdll-Correctly-report-file-symbolic-links-as-files.patch
index d50713c0..1d4171eb 100644
--- a/patches/ntdll-Junction_Points/0014-ntdll-Correctly-report-file-symbolic-links-as-files.patch
+++ b/patches/ntdll-Junction_Points/0014-ntdll-Correctly-report-file-symbolic-links-as-files.patch
@@ -1,28 +1,29 @@
-From dcb3180f1f1569626956e51aa35b032271399390 Mon Sep 17 00:00:00 2001
+From 22a440051f4dd3b63977a384735cf60fad7f28f5 Mon Sep 17 00:00:00 2001
 From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
 Date: Sat, 30 Mar 2019 12:00:51 -0600
 Subject: [PATCH] ntdll: Correctly report file symbolic links as files.
 
 Signed-off-by: Erich E. Hoover <erich.e.hoover@gmail.com>
 ---
- dlls/ntdll/unix/file.c | 115 +++++++++++++++++++++++++++--------------
- 1 file changed, 77 insertions(+), 38 deletions(-)
+ dlls/ntdll/file.c       | 120 ++++++++++++++++++++++++++--------------
+ dlls/ntdll/tests/file.c |   8 +--
+ 2 files changed, 84 insertions(+), 44 deletions(-)
 
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index af964cf1334..205adafcd8f 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -1466,6 +1466,9 @@ static inline int get_file_xattr( char *hexattr, int attrlen )
-     return 0;
- }
+diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
+index 74df2aed687..7483c71a8db 100644
+--- a/dlls/ntdll/file.c
++++ b/dlls/ntdll/file.c
+@@ -123,6 +123,9 @@ mode_t FILE_umask = 0;
+ #define FILE_WRITE_TO_END_OF_FILE      ((LONGLONG)-1)
+ #define FILE_USE_FILE_POINTER_POSITION ((LONGLONG)-2)
  
-+NTSTATUS FILE_DecodeSymlink(const char *unix_src, char *unix_dest, int *unix_dest_len,
++NTSTATUS FILE_DecodeSymlink(const char *unix_src, char *unix_dest, USHORT *unix_dest_len,
 +                            DWORD *tag, ULONG *flags, BOOL *is_dir);
 +
  /* fetch the attributes of a file */
  static inline ULONG get_file_attributes( const struct stat *st )
  {
-@@ -1550,10 +1553,15 @@ static int get_file_info( const char *path, struct stat *st, ULONG *attr )
+@@ -170,10 +173,15 @@ int get_file_info( const char *path, struct stat *st, ULONG *attr )
      if (ret == -1) return ret;
      if (S_ISLNK( st->st_mode ))
      {
@@ -40,9 +41,9 @@ index af964cf1334..205adafcd8f 100644
 +        if (FILE_DecodeSymlink( path, NULL, NULL, NULL, NULL, &is_dir ) == STATUS_SUCCESS)
 +            st->st_mode = (st->st_mode & ~S_IFMT) | (is_dir ? S_IFDIR : S_IFREG);
      }
-     else if (S_ISDIR( st->st_mode ) && (parent_path = malloc( strlen(path) + 4 )))
+     else if (S_ISDIR( st->st_mode ) && (parent_path = RtlAllocateHeap( GetProcessHeap(), 0, strlen(path) + 4 )))
      {
-@@ -5879,47 +5887,34 @@ cleanup:
+@@ -1841,48 +1849,33 @@ cleanup:
  }
  
  
@@ -51,22 +52,20 @@ index af964cf1334..205adafcd8f 100644
 - * symlink corresponding to that file handle.
 - */
 -NTSTATUS FILE_GetSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer, ULONG out_size)
-+NTSTATUS FILE_DecodeSymlink(const char *unix_src, char *unix_dest, int *unix_dest_len,
++NTSTATUS FILE_DecodeSymlink(const char *unix_src, char *unix_dest, USHORT *unix_dest_len,
 +                            DWORD *tag, ULONG *flags, BOOL *is_dir)
  {
--    char *unix_src, unix_dest[PATH_MAX];
+-    ANSI_STRING unix_src, unix_dest;
 -    VOID *subst_name, *print_name;
--    SIZE_T nt_dest_len = PATH_MAX;
 -    BOOL dest_allocated = FALSE;
 -    int dest_fd, needs_close;
--    int unix_dest_len;
+-    UNICODE_STRING nt_dest;
 -    int path_len = 0;
 -    DWORD max_length;
-+    int len = MAX_PATH;
++    USHORT len = MAX_PATH;
 +    DWORD reparse_tag;
      NTSTATUS status;
 -    ULONG flags = 0;
--    WCHAR *nt_dest;
 -    INT prefix_len;
 +    BOOL dir_flag;
 +    char *p, *tmp;
@@ -80,23 +79,26 @@ index af964cf1334..205adafcd8f 100644
 -    if ((status = server_get_unix_name( handle, &unix_src )))
 -        goto cleanup;
 -
--    ret = readlink( unix_src, unix_dest, sizeof(unix_dest) );
+-    unix_dest.Buffer = RtlAllocateHeap( GetProcessHeap(), 0, PATH_MAX );
+-    unix_dest.MaximumLength = PATH_MAX;
+-    dest_allocated = TRUE;
+-    ret = readlink( unix_src.Buffer, unix_dest.Buffer, unix_dest.MaximumLength );
 -    if (ret < 0)
 +    if (unix_dest_len) len = *unix_dest_len;
 +    if (!unix_dest)
-+        tmp = malloc( len );
++        tmp = RtlAllocateHeap( GetProcessHeap(), 0, len );
 +    else
 +        tmp = unix_dest;
 +    if ((ret = readlink( unix_src, tmp, len )) < 0)
      {
-         status = errno_to_status( errno );
+         status = FILE_GetNtStatus();
          goto cleanup;
      }
--    unix_dest_len = ret;
+-    unix_dest.Length = ret;
+-
 +    len = ret;
- 
      /* Decode the reparse tag from the symlink */
--    p = unix_dest;
+-    p = unix_dest.Buffer;
 +    p = tmp;
      if (*p == '.')
      {
@@ -105,7 +107,7 @@ index af964cf1334..205adafcd8f 100644
          p++;
      }
      if (*p++ != '/')
-@@ -5927,7 +5922,7 @@ NTSTATUS FILE_GetSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer, ULONG out_s
+@@ -1890,7 +1883,7 @@ NTSTATUS FILE_GetSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer, ULONG out_s
          status = STATUS_NOT_IMPLEMENTED;
          goto cleanup;
      }
@@ -114,7 +116,7 @@ index af964cf1334..205adafcd8f 100644
      for (i = 0; i < sizeof(ULONG)*8; i++)
      {
          char c = *p++;
-@@ -5942,21 +5937,65 @@ NTSTATUS FILE_GetSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer, ULONG out_s
+@@ -1905,21 +1898,68 @@ NTSTATUS FILE_GetSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer, ULONG out_s
              status = STATUS_NOT_IMPLEMENTED;
              goto cleanup;
          }
@@ -138,19 +140,19 @@ index af964cf1334..205adafcd8f 100644
              goto cleanup;
          }
      }
--    unix_dest_len -= (p - unix_dest);
--    memmove(unix_dest, p, unix_dest_len);
+-    unix_dest.Length -= (p - unix_dest.Buffer);
+-    memmove(unix_dest.Buffer, p, unix_dest.Length);
 +    else
 +        dir_flag = TRUE;
 +    len -= (p - tmp);
 +    if (tag) *tag = reparse_tag;
 +    if (is_dir) *is_dir = dir_flag;
-+    if (unix_dest) memmove(unix_dest, p, len + 1);
++    if (unix_dest) memmove(unix_dest, p, len);
 +    if (unix_dest_len) *unix_dest_len = len;
 +    status = STATUS_SUCCESS;
 +
 +cleanup:
-+    if (!unix_dest) free( tmp );
++    if (!unix_dest) RtlFreeHeap( GetProcessHeap(), 0, tmp );
 +    return status;
 +}
 +
@@ -161,17 +163,15 @@ index af964cf1334..205adafcd8f 100644
 + */
 +NTSTATUS FILE_GetSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer, ULONG out_size)
 +{
-+    char *unix_src, unix_dest[PATH_MAX];
++    ANSI_STRING unix_src, unix_dest;
 +    VOID *subst_name, *print_name;
-+    SIZE_T nt_dest_len = PATH_MAX;
-+    int unix_dest_len = PATH_MAX;
 +    BOOL dest_allocated = FALSE;
 +    int dest_fd, needs_close;
++    UNICODE_STRING nt_dest;
 +    int path_len = 0;
 +    DWORD max_length;
 +    NTSTATUS status;
 +    ULONG flags = 0;
-+    WCHAR *nt_dest;
 +    INT prefix_len;
 +
 +    if ((status = server_get_unix_fd( handle, FILE_ANY_ACCESS, &dest_fd, &needs_close, NULL, NULL )))
@@ -180,11 +180,49 @@ index af964cf1334..205adafcd8f 100644
 +    if ((status = server_get_unix_name( handle, &unix_src )))
 +        goto cleanup;
 +
-+    if ((status = FILE_DecodeSymlink( unix_src, unix_dest, &unix_dest_len, &buffer->ReparseTag, &flags, NULL )))
++    unix_dest.MaximumLength = PATH_MAX;
++    unix_dest.Buffer = RtlAllocateHeap( GetProcessHeap(), 0, unix_dest.MaximumLength );
++    unix_dest.Length = unix_dest.MaximumLength;
++    dest_allocated = TRUE;
++    if ((status = FILE_DecodeSymlink( unix_src.Buffer, unix_dest.Buffer, &unix_dest.Length,
++                                      &buffer->ReparseTag, &flags, NULL )))
 +        goto cleanup;
  
      /* convert the relative path into an absolute path */
      if (flags == SYMLINK_FLAG_RELATIVE)
+diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
+index e0116491eee..7f983583268 100644
+--- a/dlls/ntdll/tests/file.c
++++ b/dlls/ntdll/tests/file.c
+@@ -5187,13 +5187,13 @@ static void test_reparse_points(void)
+ 
+     /* Check deleting a file symlink as if it were a directory */
+     bret = RemoveDirectoryW(reparse_path);
+-    todo_wine ok(!bret, "Succeeded in deleting file symlink as a directory!\n");
++    ok(!bret, "Succeeded in deleting file symlink as a directory!\n");
+     err = GetLastError();
+     todo_wine ok(err == ERROR_DIRECTORY,
+                  "Expected last error 0x%x for RemoveDirectory on file symlink (actually 0x%x)!\n",
+                  ERROR_DIRECTORY, err);
+     dwret = GetFileAttributesW(reparse_path);
+-    todo_wine ok(dwret != (DWORD)~0, "Symlink doesn't exist (attributes: 0x%x)!\n", dwret);
++    ok(dwret != (DWORD)~0, "Symlink doesn't exist (attributes: 0x%x)!\n", dwret);
+     ok(dwret & FILE_ATTRIBUTE_REPARSE_POINT, "File is not a symlink! (attributes: 0x%x)\n", dwret);
+ 
+     /* Delete the symlink as a file */
+@@ -5202,10 +5202,10 @@ static void test_reparse_points(void)
+ 
+     /* Create a blank slate for directory symlink tests */
+     bret = CreateDirectoryW(reparse_path, NULL);
+-    ok(bret, "Failed to create junction point directory.\n");
++    todo_wine ok(bret, "Failed to create junction point directory.\n");
+     dwret = GetFileAttributesW(reparse_path);
+     ok(dwret != (DWORD)~0, "Path doesn't exist (attributes: 0x%x)!\n", dwret);
+-    ok(!(dwret & FILE_ATTRIBUTE_REPARSE_POINT), "File is already a reparse point! (attributes: %d)\n", dwret);
++    todo_wine ok(!(dwret & FILE_ATTRIBUTE_REPARSE_POINT), "File is already a reparse point! (attributes: %d)\n", dwret);
+ 
+     /* Create the directory symlink */
+     HeapFree(GetProcessHeap(), 0, buffer);
 -- 
-2.27.0
+2.26.2
 
diff --git a/patches/ntdll-Junction_Points/0015-kernel32-Set-error-code-when-attempting-to-delete-fi.patch b/patches/ntdll-Junction_Points/0015-kernel32-Set-error-code-when-attempting-to-delete-fi.patch
index 0cd169ae..4434acd2 100644
--- a/patches/ntdll-Junction_Points/0015-kernel32-Set-error-code-when-attempting-to-delete-fi.patch
+++ b/patches/ntdll-Junction_Points/0015-kernel32-Set-error-code-when-attempting-to-delete-fi.patch
@@ -1,4 +1,4 @@
-From 3a96350814cd7fd9d620352e252b02aede20d1cf Mon Sep 17 00:00:00 2001
+From 95288f8fe17bf7c8f772c863fe49a85c117a71eb Mon Sep 17 00:00:00 2001
 From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
 Date: Sat, 30 Mar 2019 12:01:50 -0600
 Subject: kernel32: Set error code when attempting to delete file symlinks as
@@ -6,16 +6,33 @@ Subject: kernel32: Set error code when attempting to delete file symlinks as
 
 Signed-off-by: Erich E. Hoover <erich.e.hoover@gmail.com>
 ---
+ dlls/kernel32/path.c    | 5 ++++-
  dlls/ntdll/tests/file.c | 6 +++---
- 1 file changed, 3 insertions(+), 3 deletions(-)
+ 2 files changed, 7 insertions(+), 4 deletions(-)
 
+diff --git a/dlls/kernel32/path.c b/dlls/kernel32/path.c
+index 5ef66b5913..227473f71a 100644
+--- a/dlls/kernel32/path.c
++++ b/dlls/kernel32/path.c
+@@ -1738,7 +1738,10 @@ BOOL WINAPI RemoveDirectoryW( LPCWSTR path )
+             ret = (unlink( unix_name.Buffer ) != -1);
+         else
+             ret = (rmdir( unix_name.Buffer ) != -1);
+-        if (!ret) FILE_SetDosError();
++        if (status == STATUS_SUCCESS && (info.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) &&
++                                        !(info.FileAttributes & FILE_ATTRIBUTE_DIRECTORY))
++            SetLastError( ERROR_DIRECTORY );
++        else if (!ret) FILE_SetDosError();
+         RtlFreeAnsiString( &unix_name );
+     }
+     else
 diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
-index 58fec76bec4..7f69a9116f2 100644
+index fbd824fd10..0041a41b6d 100644
 --- a/dlls/ntdll/tests/file.c
 +++ b/dlls/ntdll/tests/file.c
-@@ -5208,9 +5208,9 @@ static void test_reparse_points(void)
+@@ -5067,9 +5067,9 @@ static void test_reparse_points(void)
      bret = RemoveDirectoryW(reparse_path);
-     todo_wine ok(!bret, "Succeeded in deleting file symlink as a directory!\n");
+     ok(!bret, "Succeeded in deleting file symlink as a directory!\n");
      err = GetLastError();
 -    todo_wine ok(err == ERROR_DIRECTORY,
 -                 "Expected last error 0x%x for RemoveDirectory on file symlink (actually 0x%x)!\n",
@@ -24,7 +41,7 @@ index 58fec76bec4..7f69a9116f2 100644
 +       "Expected last error 0x%x for RemoveDirectory on file symlink (actually 0x%x)!\n",
 +       ERROR_DIRECTORY, err);
      dwret = GetFileAttributesW(reparse_path);
-     todo_wine ok(dwret != (DWORD)~0, "Symlink doesn't exist (attributes: 0x%x)!\n", dwret);
+     ok(dwret != (DWORD)~0, "Symlink doesn't exist (attributes: 0x%x)!\n", dwret);
      ok(dwret & FILE_ATTRIBUTE_REPARSE_POINT, "File is not a symlink! (attributes: 0x%x)\n", dwret);
 -- 
 2.17.1
diff --git a/patches/ntdll-Junction_Points/0016-server-Properly-handle-file-symlink-deletion.patch b/patches/ntdll-Junction_Points/0016-server-Properly-handle-file-symlink-deletion.patch
index 729694ed..63221ab4 100644
--- a/patches/ntdll-Junction_Points/0016-server-Properly-handle-file-symlink-deletion.patch
+++ b/patches/ntdll-Junction_Points/0016-server-Properly-handle-file-symlink-deletion.patch
@@ -1,32 +1,19 @@
-From a936bfbd369e1199723b0e5f2fa1329c084561db Mon Sep 17 00:00:00 2001
+From 9ac3c75b53eeeee76fcf4e1c1a5546ae5fc3b58a Mon Sep 17 00:00:00 2001
 From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
 Date: Sat, 30 Mar 2019 13:41:07 -0600
-Subject: server: Properly handle file symlink deletion.
+Subject: [PATCH] server: Properly handle file symlink deletion.
 
 Signed-off-by: Erich E. Hoover <erich.e.hoover@gmail.com>
 ---
  dlls/ntdll/tests/file.c |  6 ++--
- server/fd.c             | 69 +++++++++++++++++++++++++++++++++++++++--
- 2 files changed, 70 insertions(+), 5 deletions(-)
+ server/fd.c             | 76 ++++++++++++++++++++++++++++++++++++++---
+ 2 files changed, 74 insertions(+), 8 deletions(-)
 
 diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
-index 7f69a9116f2..ddd3d693659 100644
+index 0b7e9e230227..a6085d8de75c 100644
 --- a/dlls/ntdll/tests/file.c
 +++ b/dlls/ntdll/tests/file.c
-@@ -5206,18 +5206,18 @@ static void test_reparse_points(void)
- 
-     /* Check deleting a file symlink as if it were a directory */
-     bret = RemoveDirectoryW(reparse_path);
--    todo_wine ok(!bret, "Succeeded in deleting file symlink as a directory!\n");
-+    ok(!bret, "Succeeded in deleting file symlink as a directory!\n");
-     err = GetLastError();
-     ok(err == ERROR_DIRECTORY,
-        "Expected last error 0x%x for RemoveDirectory on file symlink (actually 0x%x)!\n",
-        ERROR_DIRECTORY, err);
-     dwret = GetFileAttributesW(reparse_path);
--    todo_wine ok(dwret != (DWORD)~0, "Symlink doesn't exist (attributes: 0x%x)!\n", dwret);
-+    ok(dwret != (DWORD)~0, "Symlink doesn't exist (attributes: 0x%x)!\n", dwret);
-     ok(dwret & FILE_ATTRIBUTE_REPARSE_POINT, "File is not a symlink! (attributes: 0x%x)\n", dwret);
+@@ -5198,14 +5198,14 @@ static void test_reparse_points(void)
  
      /* Delete the symlink as a file */
      bret = DeleteFileW(reparse_path);
@@ -35,11 +22,20 @@ index 7f69a9116f2..ddd3d693659 100644
  
      /* Create a blank slate for directory symlink tests */
      bret = CreateDirectoryW(reparse_path, NULL);
+-    todo_wine ok(bret, "Failed to create junction point directory.\n");
++    ok(bret, "Failed to create junction point directory.\n");
+     dwret = GetFileAttributesW(reparse_path);
+     ok(dwret != (DWORD)~0, "Path doesn't exist (attributes: 0x%x)!\n", dwret);
+-    todo_wine ok(!(dwret & FILE_ATTRIBUTE_REPARSE_POINT), "File is already a reparse point! (attributes: %d)\n", dwret);
++    ok(!(dwret & FILE_ATTRIBUTE_REPARSE_POINT), "File is already a reparse point! (attributes: %d)\n", dwret);
+ 
+     /* Create the directory symlink */
+     HeapFree(GetProcessHeap(), 0, buffer);
 diff --git a/server/fd.c b/server/fd.c
-index c0d35e2fa4c..9e087917c0d 100644
+index 06d1d81bdb08..df0caa483827 100644
 --- a/server/fd.c
 +++ b/server/fd.c
-@@ -107,6 +107,10 @@
+@@ -106,6 +106,10 @@
  #include "winioctl.h"
  #include "ddk/wdm.h"
  
@@ -50,7 +46,16 @@ index c0d35e2fa4c..9e087917c0d 100644
  #if defined(HAVE_SYS_EPOLL_H) && defined(HAVE_EPOLL_CREATE)
  # include <sys/epoll.h>
  # define USE_EPOLL
-@@ -1829,6 +1833,55 @@ char *dup_fd_name( struct fd *root, const char *name )
+@@ -1146,7 +1150,7 @@ static void inode_destroy( struct object *obj )
+         {
+             /* make sure it is still the same file */
+             struct stat st;
+-            if (!stat( fd->unix_name, &st ) && st.st_dev == inode->device->dev && st.st_ino == inode->ino)
++            if (!lstat( fd->unix_name, &st ) && st.st_dev == inode->device->dev && st.st_ino == inode->ino)
+             {
+                 if (S_ISDIR(st.st_mode)) rmdir( fd->unix_name );
+                 else unlink( fd->unix_name );
+@@ -1824,6 +1828,53 @@ char *dup_fd_name( struct fd *root, const char *name )
      return ret;
  }
  
@@ -61,8 +66,6 @@ index c0d35e2fa4c..9e087917c0d 100644
 +    int len, i;
 +
 +    len = readlink( name, link, sizeof(link) );
-+    if (len == -1)
-+        return;
 +    link[len] = 0;
 +    p = link;
 +    /* skip past relative/absolute indication */
@@ -106,7 +109,7 @@ index c0d35e2fa4c..9e087917c0d 100644
  /* open() wrapper that returns a struct fd with no fd user set */
  struct fd *open_fd( struct fd *root, const char *name, int flags, mode_t *mode, unsigned int access,
                      unsigned int sharing, unsigned int options )
-@@ -1896,6 +1949,13 @@ struct fd *open_fd( struct fd *root, const char *name, int flags, mode_t *mode,
+@@ -1891,6 +1942,13 @@ struct fd *open_fd( struct fd *root, const char *name, int flags, mode_t *mode,
              if ((access & FILE_UNIX_WRITE_ACCESS) || (flags & O_CREAT))
                  fd->unix_fd = open( name, O_RDONLY | (flags & ~(O_TRUNC | O_CREAT | O_EXCL)), *mode );
          }
@@ -120,7 +123,17 @@ index c0d35e2fa4c..9e087917c0d 100644
  
          if (fd->unix_fd == -1)
          {
-@@ -1923,6 +1983,7 @@ struct fd *open_fd( struct fd *root, const char *name, int flags, mode_t *mode,
+@@ -1909,14 +1967,15 @@ struct fd *open_fd( struct fd *root, const char *name, int flags, mode_t *mode,
+     closed_fd->unix_fd = fd->unix_fd;
+     closed_fd->unlink = 0;
+     closed_fd->unix_name = fd->unix_name;
+-    fstat( fd->unix_fd, &st );
++    lstat( fd->unix_name, &st );
+     *mode = st.st_mode;
+ 
+     /* only bother with an inode for normal files and directories */
+-    if (S_ISREG(st.st_mode) || S_ISDIR(st.st_mode))
++    if (S_ISREG(st.st_mode) || S_ISDIR(st.st_mode) || S_ISLNK(st.st_mode))
      {
          unsigned int err;
          struct inode *inode = get_inode( st.st_dev, st.st_ino, fd->unix_fd );
@@ -128,17 +141,17 @@ index c0d35e2fa4c..9e087917c0d 100644
  
          if (!inode)
          {
-@@ -1937,16 +1998,20 @@ struct fd *open_fd( struct fd *root, const char *name, int flags, mode_t *mode,
+@@ -1931,13 +1990,20 @@ struct fd *open_fd( struct fd *root, const char *name, int flags, mode_t *mode,
          list_add_head( &inode->open, &fd->inode_entry );
          closed_fd = NULL;
  
 +        /* decode symlink type */
-         fstat( fd->unix_fd, &st );
-         *mode = st.st_mode;
++        fstat( fd->unix_fd, &st );
++        *mode = st.st_mode;
 +        is_dir = S_ISDIR(st.st_mode);
 +        if (is_link)
-+            decode_symlink(fd->unlink_name, &is_dir);
- 
++            decode_symlink(fd->unix_name, &is_dir);
++
          /* check directory options */
 -        if ((options & FILE_DIRECTORY_FILE) && !S_ISDIR(st.st_mode))
 +        if ((options & FILE_DIRECTORY_FILE) && !is_dir)
@@ -152,5 +165,5 @@ index c0d35e2fa4c..9e087917c0d 100644
              set_error( STATUS_FILE_IS_A_DIRECTORY );
              goto error;
 -- 
-2.17.1
+2.26.2
 
diff --git a/patches/ntdll-Junction_Points/0017-ntdll-Always-report-symbolic-links-as-containing-zer.patch b/patches/ntdll-Junction_Points/0017-ntdll-Always-report-symbolic-links-as-containing-zer.patch
index c2179c6e..9caa16ea 100644
--- a/patches/ntdll-Junction_Points/0017-ntdll-Always-report-symbolic-links-as-containing-zer.patch
+++ b/patches/ntdll-Junction_Points/0017-ntdll-Always-report-symbolic-links-as-containing-zer.patch
@@ -1,20 +1,32 @@
-From ceb069628acc263e5c1a9ed274f8d00eeb9c4dd8 Mon Sep 17 00:00:00 2001
+From 4df537eadbf20772213e02eb65d51fc1c016981e Mon Sep 17 00:00:00 2001
 From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
 Date: Wed, 1 May 2019 12:06:20 -0600
 Subject: ntdll: Always report symbolic links as containing zero bytes.
 
 Signed-off-by: Erich E. Hoover <erich.e.hoover@gmail.com>
 ---
+ dlls/ntdll/file.c       |  2 ++
  dlls/ntdll/tests/file.c | 46 +++++++++++++++++++++++++++++++++++++++--
- dlls/ntdll/unix/file.c  |  2 ++
- server/fd.c             |  3 ++-
- 3 files changed, 48 insertions(+), 3 deletions(-)
+ 2 files changed, 46 insertions(+), 2 deletions(-)
 
+diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
+index be594ea517..6bb45f34f3 100644
+--- a/dlls/ntdll/file.c
++++ b/dlls/ntdll/file.c
+@@ -167,6 +167,8 @@ int get_file_info( const char *path, struct stat *st, ULONG *attr )
+ 
+         /* return information about the destination (unless this is a dangling symlink) */
+         stat( path, st );
++        /* symbolic links always report size 0 */
++        st->st_size = 0;
+         /* symbolic links (either junction points or NT symlinks) are "reparse points" */
+         *attr |= FILE_ATTRIBUTE_REPARSE_POINT;
+         /* whether a reparse point is a file or a directory is stored inside the link target */
 diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
-index ddd3d693659..e0a6e3b3143 100644
+index f2c273e901..d776d12329 100644
 --- a/dlls/ntdll/tests/file.c
 +++ b/dlls/ntdll/tests/file.c
-@@ -5037,7 +5037,9 @@ static void test_reparse_points(void)
+@@ -4896,7 +4896,9 @@ static void test_reparse_points(void)
      static const WCHAR dotW[] = {'.',0};
      REPARSE_DATA_BUFFER *buffer = NULL;
      DWORD dwret, dwLen, dwFlags, err;
@@ -24,7 +36,7 @@ index ddd3d693659..e0a6e3b3143 100644
      HANDLE handle, token;
      IO_STATUS_BLOCK iosb;
      UNICODE_STRING nameW;
-@@ -5165,8 +5167,6 @@ static void test_reparse_points(void)
+@@ -5024,8 +5026,6 @@ static void test_reparse_points(void)
         "Unexpected junction point attributes (0x%x != 0x410)!\n", dwret);
      bret = RemoveDirectoryW(target_path);
      ok(bret, "Failed to delete junction point target!\n");
@@ -33,7 +45,7 @@ index ddd3d693659..e0a6e3b3143 100644
  
      /* Establish permissions for symlink creation */
      bret = OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &token);
-@@ -5191,6 +5191,13 @@ static void test_reparse_points(void)
+@@ -5050,6 +5050,13 @@ static void test_reparse_points(void)
      /* Delete the junction point directory and create a blank slate for symlink tests */
      bret = RemoveDirectoryW(reparse_path);
      ok(bret, "Failed to delete junction point!\n");
@@ -47,7 +59,7 @@ index ddd3d693659..e0a6e3b3143 100644
  
      /* Create the file symlink */
      HeapFree(GetProcessHeap(), 0, buffer);
-@@ -5204,6 +5211,37 @@ static void test_reparse_points(void)
+@@ -5063,6 +5070,37 @@ static void test_reparse_points(void)
      ok(bret, "Failed to create symlink! (0x%x)\n", GetLastError());
      CloseHandle(handle);
  
@@ -85,7 +97,7 @@ index ddd3d693659..e0a6e3b3143 100644
      /* Check deleting a file symlink as if it were a directory */
      bret = RemoveDirectoryW(reparse_path);
      ok(!bret, "Succeeded in deleting file symlink as a directory!\n");
-@@ -5225,6 +5263,10 @@ static void test_reparse_points(void)
+@@ -5084,6 +5122,10 @@ static void test_reparse_points(void)
      dwret = GetFileAttributesW(reparse_path);
      ok(dwret != (DWORD)~0, "Path doesn't exist (attributes: 0x%x)!\n", dwret);
      ok(!(dwret & FILE_ATTRIBUTE_REPARSE_POINT), "File is already a reparse point! (attributes: %d)\n", dwret);
@@ -96,40 +108,6 @@ index ddd3d693659..e0a6e3b3143 100644
  
      /* Create the directory symlink */
      HeapFree(GetProcessHeap(), 0, buffer);
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index ca21a799231..bdc8b8c756f 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -1507,6 +1507,8 @@ static int get_file_info( const char *path, struct stat *st, ULONG *attr )
- 
-         /* return information about the destination (unless this is a dangling symlink) */
-         stat( path, st );
-+        /* symbolic links always report size 0 */
-+        st->st_size = 0;
-         /* symbolic links (either junction points or NT symlinks) are "reparse points" */
-         *attr |= FILE_ATTRIBUTE_REPARSE_POINT;
-         /* whether a reparse point is a file or a directory is stored inside the link target */
-diff --git a/server/fd.c b/server/fd.c
-index 9e087917c0d..03966cd3067 100644
---- a/server/fd.c
-+++ b/server/fd.c
-@@ -1969,6 +1969,7 @@ struct fd *open_fd( struct fd *root, const char *name, int flags, mode_t *mode,
-     {
-         fd->unlink_name = path;
-         fd->unix_name = realpath( path, NULL );
-+        if (!fd->unix_name) fd->unix_name = dup_fd_name( root, name ); /* dangling symlink */
-     }
- 
-     closed_fd->unix_fd = fd->unix_fd;
-@@ -2487,7 +2488,7 @@ static void set_fd_disposition( struct fd *fd, int unlink )
-             file_set_error();
-             return;
-         }
--        if (S_ISREG( st.st_mode ))  /* can't unlink files we don't have permission to write */
-+        if (S_ISREG( st.st_mode ) || S_ISLNK( st.st_mode ))  /* can't unlink files we don't have permission to write */
-         {
-             if (!(st.st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)))
-             {
 -- 
 2.17.1
 
diff --git a/patches/ntdll-Junction_Points/0018-ntdll-Find-dangling-symlinks-quickly.patch b/patches/ntdll-Junction_Points/0018-ntdll-Find-dangling-symlinks-quickly.patch
index b520ff45..b1e31c60 100644
--- a/patches/ntdll-Junction_Points/0018-ntdll-Find-dangling-symlinks-quickly.patch
+++ b/patches/ntdll-Junction_Points/0018-ntdll-Find-dangling-symlinks-quickly.patch
@@ -1,21 +1,21 @@
-From bc78873be1ca0e16e7c2d5aedf15f9e09f86069c Mon Sep 17 00:00:00 2001
+From 1a7f83237f0d843be63c947f3c9e2aaaa90156a8 Mon Sep 17 00:00:00 2001
 From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
 Date: Wed, 1 May 2019 17:48:51 -0600
-Subject: ntdll: Find dangling symlinks quickly.
+Subject: [PATCH] ntdll: Find dangling symlinks quickly.
 
 This is also necessary on systems (such as MacOS) that support
 case-insensitive lookups of files.
 
 Signed-off-by: Erich E. Hoover <erich.e.hoover@gmail.com>
 ---
- dlls/ntdll/unix/file.c | 6 +++---
+ dlls/ntdll/directory.c | 6 +++---
  1 file changed, 3 insertions(+), 3 deletions(-)
 
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index bdc8b8c756f..a7dc12f0a3e 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -2501,7 +2501,7 @@ static NTSTATUS find_file_in_dir( char *unix_name, int pos, const WCHAR *name, i
+diff --git a/dlls/ntdll/directory.c b/dlls/ntdll/directory.c
+index 669fd56cbe..95af2dde24 100644
+--- a/dlls/ntdll/directory.c
++++ b/dlls/ntdll/directory.c
+@@ -2053,7 +2053,7 @@ static NTSTATUS find_file_in_dir( char *unix_name, int pos, const WCHAR *name, i
      if (ret >= 0 && ret <= MAX_DIR_ENTRY_LEN)
      {
          unix_name[pos + ret] = 0;
@@ -24,7 +24,7 @@ index bdc8b8c756f..a7dc12f0a3e 100644
          {
              if (is_win_dir) *is_win_dir = is_same_file( &windir, &st );
              return STATUS_SUCCESS;
-@@ -2606,7 +2606,7 @@ not_found:
+@@ -2175,7 +2175,7 @@ not_found:
      return STATUS_OBJECT_PATH_NOT_FOUND;
  
  success:
@@ -33,7 +33,7 @@ index bdc8b8c756f..a7dc12f0a3e 100644
      return STATUS_SUCCESS;
  }
  
-@@ -3101,7 +3101,7 @@ static NTSTATUS lookup_unix_name( const WCHAR *name, int name_len, char **buffer
+@@ -2580,7 +2580,7 @@ static NTSTATUS lookup_unix_name( const WCHAR *name, int name_len, char **buffer
          for (p = unix_name + pos ; *p; p++) if (*p == '\\') *p = '/';
          if (!name_len || !redirect || (!strstr( unix_name, "/windows/") && strncmp( unix_name, "windows/", 8 )))
          {
@@ -43,5 +43,5 @@ index bdc8b8c756f..a7dc12f0a3e 100644
                  if (disposition == FILE_CREATE)
                      return STATUS_OBJECT_NAME_COLLISION;
 -- 
-2.17.1
+2.24.1
 
diff --git a/patches/ntdll-Junction_Points/0020-kernel32-Add-reparse-support-to-FindNextFile.patch b/patches/ntdll-Junction_Points/0020-kernel32-Add-reparse-support-to-FindNextFile.patch
deleted file mode 100644
index c448f906..00000000
--- a/patches/ntdll-Junction_Points/0020-kernel32-Add-reparse-support-to-FindNextFile.patch
+++ /dev/null
@@ -1,45 +0,0 @@
-From 87cc49c8ae73e17bc953b66f25be76d5c0eff153 Mon Sep 17 00:00:00 2001
-From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
-Date: Wed, 29 May 2019 15:11:42 -0600
-Subject: kernel32: Add reparse support to FindNextFile.
-
-Signed-off-by: Erich E. Hoover <erich.e.hoover@gmail.com>
----
- dlls/kernelbase/file.c | 21 +++++++++++++++++++++
- 1 file changed, 21 insertions(+)
-
-diff --git a/dlls/kernelbase/file.c b/dlls/kernelbase/file.c
-index 2e67f6eaa3e..9920b50191b 100644
---- a/dlls/kernelbase/file.c
-+++ b/dlls/kernelbase/file.c
-@@ -1485,6 +1485,27 @@ BOOL WINAPI DECLSPEC_HOTPATCH FindNextFileW( HANDLE handle, WIN32_FIND_DATAW *da
-         memcpy( data->cFileName, dir_info->FileName, dir_info->FileNameLength );
-         data->cFileName[dir_info->FileNameLength/sizeof(WCHAR)] = 0;
- 
-+        /* get reparse tag */
-+        if (dir_info->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)
-+        {
-+            REPARSE_DATA_BUFFER *buffer = NULL;
-+            INT buffer_len;
-+            HANDLE hlink;
-+            DWORD dwret;
-+            BOOL bret;
-+
-+            hlink = CreateFileW( data->cFileName, GENERIC_READ | GENERIC_WRITE, 0, 0,
-+                                 OPEN_EXISTING,
-+                                 FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0 );
-+            buffer_len = sizeof(*buffer) + 2*MAX_PATH*sizeof(WCHAR);
-+            buffer = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, buffer_len );
-+            bret = DeviceIoControl( hlink, FSCTL_GET_REPARSE_POINT, NULL, 0, (LPVOID)buffer,
-+                                    buffer_len, &dwret, 0 );
-+            if (bret) data->dwReserved0 = buffer->ReparseTag;
-+            HeapFree( GetProcessHeap(), 0, buffer );
-+            CloseHandle( hlink );
-+        }
-+
-         if (info->level != FindExInfoBasic)
-         {
-             memcpy( data->cAlternateFileName, dir_info->ShortName, dir_info->ShortNameLength );
--- 
-2.17.1
-
diff --git a/patches/ntdll-Junction_Points/0021-wcmd-Display-reparse-point-type-in-directory-listing.patch b/patches/ntdll-Junction_Points/0021-wcmd-Display-reparse-point-type-in-directory-listing.patch
deleted file mode 100644
index 7790e720..00000000
--- a/patches/ntdll-Junction_Points/0021-wcmd-Display-reparse-point-type-in-directory-listing.patch
+++ /dev/null
@@ -1,50 +0,0 @@
-From 6eed7c952dbb0e7151723881dc26e955b9d9595d Mon Sep 17 00:00:00 2001
-From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
-Date: Wed, 29 May 2019 15:18:50 -0600
-Subject: wcmd: Display reparse point type in directory listings.
-
-Signed-off-by: Erich E. Hoover <erich.e.hoover@gmail.com>
----
- programs/cmd/directory.c | 26 ++++++++++++++++++++++++++
- 1 file changed, 26 insertions(+)
-
-diff --git a/programs/cmd/directory.c b/programs/cmd/directory.c
-index 2d35f8eb1d1..5b7416ce72a 100644
---- a/programs/cmd/directory.c
-+++ b/programs/cmd/directory.c
-@@ -400,6 +400,32 @@ static DIRECTORY_STACK *WCMD_list_directory (DIRECTORY_STACK *inputparms, int le
-             WCMD_output(L"%1!*s!", cur_width - tmp_width, nullW);
-         }
- 
-+      } else if (fd[i].dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
-+        if (!bare) {
-+           const WCHAR *type;
-+
-+           switch(fd[i].dwReserved0) {
-+           case IO_REPARSE_TAG_MOUNT_POINT:
-+              type = L"<JUNCTION>";
-+              break;
-+           case IO_REPARSE_TAG_SYMLINK:
-+           default:
-+              type = (fd[i].dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? L"<SYMLINKD>" : L"<SYMLINK>";
-+              break;
-+           }
-+           WCMD_output (L"%1!10s!  %2!8s!  %3!-14s!", datestring, timestring, type);
-+           if (shortname) WCMD_output (fmt2, fd[i].cAlternateFileName);
-+           if (usernames) WCMD_output (fmt3, username);
-+           WCMD_output(fmt4,fd[i].cFileName);
-+        } else {
-+           if (!((lstrcmpW(fd[i].cFileName, dotW) == 0) ||
-+                 (lstrcmpW(fd[i].cFileName, dotdotW) == 0))) {
-+              WCMD_output (fmt5, recurse?inputparms->dirName:nullW, fd[i].cFileName);
-+           } else {
-+              addNewLine = FALSE;
-+           }
-+        }
-+
-       } else if (fd[i].dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
-         dir_count++;
- 
--- 
-2.17.1
-
diff --git a/patches/ntdll-Junction_Points/0022-wcmd-Show-reparse-point-target-in-directory-listing.patch b/patches/ntdll-Junction_Points/0022-wcmd-Show-reparse-point-target-in-directory-listing.patch
deleted file mode 100644
index 18d4980e..00000000
--- a/patches/ntdll-Junction_Points/0022-wcmd-Show-reparse-point-target-in-directory-listing.patch
+++ /dev/null
@@ -1,72 +0,0 @@
-From 508f77e1653e67bfa8ed54eeb25251684b495115 Mon Sep 17 00:00:00 2001
-From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
-Date: Wed, 29 May 2019 15:38:30 -0600
-Subject: wcmd: Show reparse point target in directory listing.
-
-Signed-off-by: Erich E. Hoover <erich.e.hoover@gmail.com>
----
- programs/cmd/directory.c | 34 ++++++++++++++++++++++++++++++++++
- 1 file changed, 34 insertions(+)
-
-diff --git a/programs/cmd/directory.c b/programs/cmd/directory.c
-index 5b7416ce72a..87a5a310224 100644
---- a/programs/cmd/directory.c
-+++ b/programs/cmd/directory.c
-@@ -23,6 +23,8 @@
- 
- #include "wcmd.h"
- #include "wine/debug.h"
-+#include "winioctl.h"
-+#include "ntifs.h"
- 
- WINE_DEFAULT_DEBUG_CHANNEL(cmd);
- 
-@@ -256,6 +258,7 @@ static DIRECTORY_STACK *WCMD_list_directory (DIRECTORY_STACK *inputparms, int le
-   static const WCHAR fmt3[]  = {'%','1','!','-','2','3','s','!','\0'};
-   static const WCHAR fmt4[]  = {'%','1','\0'};
-   static const WCHAR fmt5[]  = {'%','1','%','2','\0'};
-+  static const WCHAR fmt6[]  = {' ','[','%','1',']','\0'};
- 
-   dir_count = 0;
-   file_count = 0;
-@@ -417,6 +420,37 @@ static DIRECTORY_STACK *WCMD_list_directory (DIRECTORY_STACK *inputparms, int le
-            if (shortname) WCMD_output (fmt2, fd[i].cAlternateFileName);
-            if (usernames) WCMD_output (fmt3, username);
-            WCMD_output(fmt4,fd[i].cFileName);
-+           if (fd[i].dwReserved0) {
-+              REPARSE_DATA_BUFFER *buffer = NULL;
-+              WCHAR *target = NULL;
-+              INT buffer_len;
-+              HANDLE hlink;
-+              DWORD dwret;
-+              BOOL bret;
-+
-+              hlink = CreateFileW(fd[i].cFileName, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
-+                                  FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
-+              buffer_len = sizeof(*buffer) + 2*MAX_PATH*sizeof(WCHAR);
-+              buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, buffer_len);
-+              bret = DeviceIoControl(hlink, FSCTL_GET_REPARSE_POINT, NULL, 0, (LPVOID)buffer,
-+                                     buffer_len, &dwret, 0);
-+              if (bret) {
-+                 INT offset;
-+                 switch(buffer->ReparseTag) {
-+                 case IO_REPARSE_TAG_MOUNT_POINT:
-+                    offset = buffer->MountPointReparseBuffer.PrintNameOffset/sizeof(WCHAR);
-+                    target = &buffer->MountPointReparseBuffer.PathBuffer[offset];
-+                    break;
-+                 case IO_REPARSE_TAG_SYMLINK:
-+                    offset = buffer->SymbolicLinkReparseBuffer.PrintNameOffset/sizeof(WCHAR);
-+                    target = &buffer->SymbolicLinkReparseBuffer.PathBuffer[offset];
-+                    break;
-+                 }
-+              }
-+              CloseHandle(hlink);
-+              if (target) WCMD_output(fmt6, target);
-+              HeapFree(GetProcessHeap(), 0, buffer);
-+           }
-         } else {
-            if (!((lstrcmpW(fd[i].cFileName, dotW) == 0) ||
-                  (lstrcmpW(fd[i].cFileName, dotdotW) == 0))) {
--- 
-2.17.1
-
diff --git a/patches/ntdll-Junction_Points/0023-wcmd-Add-junction-point-support-to-mklink.patch b/patches/ntdll-Junction_Points/0023-wcmd-Add-junction-point-support-to-mklink.patch
deleted file mode 100644
index bad07c10..00000000
--- a/patches/ntdll-Junction_Points/0023-wcmd-Add-junction-point-support-to-mklink.patch
+++ /dev/null
@@ -1,86 +0,0 @@
-From c146d5ab24640039bd143ebe501755701c126a9e Mon Sep 17 00:00:00 2001
-From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
-Date: Wed, 29 May 2019 16:01:45 -0600
-Subject: wcmd: Add junction point support to mklink.
-
-Signed-off-by: Erich E. Hoover <erich.e.hoover@gmail.com>
----
- programs/cmd/builtins.c | 48 ++++++++++++++++++++++++++++++++++++++++-
- 1 file changed, 47 insertions(+), 1 deletion(-)
-
-diff --git a/programs/cmd/builtins.c b/programs/cmd/builtins.c
-index 70ccddebc11..34de0486fdd 100644
---- a/programs/cmd/builtins.c
-+++ b/programs/cmd/builtins.c
-@@ -31,6 +31,9 @@
- #include "wcmd.h"
- #include <shellapi.h>
- #include "wine/debug.h"
-+#include "winternl.h"
-+#include "winioctl.h"
-+#include "ntifs.h"
- 
- WINE_DEFAULT_DEBUG_CHANNEL(cmd);
- 
-@@ -5055,6 +5058,49 @@ void WCMD_color (void) {
-   }
- }
- 
-+BOOL WCMD_create_junction(WCHAR *link, WCHAR *target) {
-+    static INT struct_size = offsetof(REPARSE_DATA_BUFFER, SymbolicLinkReparseBuffer.PathBuffer[0]);
-+    static INT header_size = offsetof(REPARSE_DATA_BUFFER, GenericReparseBuffer);
-+    INT buffer_size, data_size, string_len, prefix_len;
-+    WCHAR *subst_dest, *print_dest, *string;
-+    REPARSE_DATA_BUFFER *buffer;
-+    UNICODE_STRING nt_name;
-+    NTSTATUS status;
-+    HANDLE hlink;
-+    DWORD dwret;
-+    BOOL ret;
-+
-+    if (!CreateDirectoryW(link, NULL ))
-+        return FALSE;
-+    hlink = CreateFileW(link, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
-+                        FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
-+    if (hlink == INVALID_HANDLE_VALUE)
-+        return FALSE;
-+    status = RtlDosPathNameToNtPathName_U_WithStatus(target, &nt_name, NULL, NULL);
-+    if (status)
-+        return FALSE;
-+    prefix_len = strlen("\\??\\");
-+    string = nt_name.Buffer;
-+    string_len = lstrlenW( &string[prefix_len] );
-+    data_size = (prefix_len + 2 * string_len + 2) * sizeof(WCHAR);
-+    buffer_size = struct_size + data_size;
-+    buffer = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, buffer_size );
-+    buffer->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
-+    buffer->ReparseDataLength = struct_size - header_size + data_size;
-+    buffer->MountPointReparseBuffer.SubstituteNameLength = (prefix_len + string_len) * sizeof(WCHAR);
-+    buffer->MountPointReparseBuffer.PrintNameOffset = (prefix_len + string_len + 1) * sizeof(WCHAR);
-+    buffer->MountPointReparseBuffer.PrintNameLength = string_len * sizeof(WCHAR);
-+    subst_dest = &buffer->MountPointReparseBuffer.PathBuffer[0];
-+    print_dest = &buffer->MountPointReparseBuffer.PathBuffer[prefix_len + string_len + 1];
-+    lstrcpyW(subst_dest, string);
-+    lstrcpyW(print_dest, &string[prefix_len]);
-+    RtlFreeUnicodeString(&nt_name );
-+    ret = DeviceIoControl(hlink, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_size, NULL, 0,
-+                          &dwret, 0 );
-+    HeapFree(GetProcessHeap(), 0, buffer);
-+    return ret;
-+}
-+
- /****************************************************************************
-  * WCMD_mklink
-  */
-@@ -5106,7 +5152,7 @@ void WCMD_mklink(WCHAR *args)
-     else if(!junction)
-         ret = CreateSymbolicLinkW(file1, file2, isdir);
-     else
--        WINE_TRACE("Juction links currently not supported.\n");
-+        ret = WCMD_create_junction(file1, file2);
- 
-     if(!ret)
-         WCMD_output_stderr(WCMD_LoadMessage(WCMD_READFAIL), file1);
--- 
-2.17.1
-
diff --git a/patches/ntdll-Junction_Points/0024-server-Fix-obtaining-information-about-a-symlink.patch b/patches/ntdll-Junction_Points/0024-server-Fix-obtaining-information-about-a-symlink.patch
deleted file mode 100644
index 9d6021c5..00000000
--- a/patches/ntdll-Junction_Points/0024-server-Fix-obtaining-information-about-a-symlink.patch
+++ /dev/null
@@ -1,140 +0,0 @@
-From 7a25fabadf15c7514dec080502df19595249a3f6 Mon Sep 17 00:00:00 2001
-From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
-Date: Sat, 18 Jul 2020 09:13:29 -0600
-Subject: server: Fix obtaining information about a symlink.
-
-Signed-off-by: Erich E. Hoover <erich.e.hoover@gmail.com>
----
- dlls/ntdll/unix/file.c | 19 ++++++++++---------
- server/fd.c            |  7 ++++---
- server/protocol.def    |  1 +
- 3 files changed, 15 insertions(+), 12 deletions(-)
-
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index a7dc12f0a3e..b507d575766 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -1775,7 +1775,7 @@ static NTSTATUS fill_file_info( const struct stat *st, ULONG attr, void *ptr,
- }
- 
- 
--static NTSTATUS server_get_unix_name( HANDLE handle, char **unix_name )
-+static NTSTATUS server_get_unix_name( HANDLE handle, char **unix_name, BOOL nofollow )
- {
-     data_size_t size = 1024;
-     NTSTATUS ret;
-@@ -1788,6 +1788,7 @@ static NTSTATUS server_get_unix_name( HANDLE handle, char **unix_name )
-         SERVER_START_REQ( get_handle_unix_name )
-         {
-             req->handle = wine_server_obj_handle( handle );
-+            req->nofollow = nofollow;
-             wine_server_set_reply( req, name, size );
-             ret = wine_server_call( req );
-             size = reply->name_len;
-@@ -1962,7 +1963,7 @@ static NTSTATUS get_mountmgr_fs_info( HANDLE handle, int fd, struct mountmgr_uni
-     NTSTATUS status;
-     int letter;
- 
--    if ((status = server_get_unix_name( handle, &unix_name ))) return status;
-+    if ((status = server_get_unix_name( handle, &unix_name, FALSE ))) return status;
-     letter = find_dos_device( unix_name );
-     free( unix_name );
- 
-@@ -3973,7 +3974,7 @@ NTSTATUS WINAPI NtQueryInformationFile( HANDLE handle, IO_STATUS_BLOCK *io,
-             if (fd_get_file_info( fd, options, &st, &attr ) == -1) io->u.Status = errno_to_status( errno );
-             else if (!S_ISREG(st.st_mode) && !S_ISDIR(st.st_mode))
-                 io->u.Status = STATUS_INVALID_INFO_CLASS;
--            else if (!(io->u.Status = server_get_unix_name( handle, &unix_name )))
-+            else if (!(io->u.Status = server_get_unix_name( handle, &unix_name, FALSE )))
-             {
-                 LONG name_len = len - FIELD_OFFSET(FILE_ALL_INFORMATION, NameInformation.FileName);
- 
-@@ -4034,7 +4035,7 @@ NTSTATUS WINAPI NtQueryInformationFile( HANDLE handle, IO_STATUS_BLOCK *io,
-             FILE_NAME_INFORMATION *info = ptr;
-             char *unix_name;
- 
--            if (!(io->u.Status = server_get_unix_name( handle, &unix_name )))
-+            if (!(io->u.Status = server_get_unix_name( handle, &unix_name, FALSE )))
-             {
-                 LONG name_len = len - FIELD_OFFSET(FILE_NAME_INFORMATION, FileName);
-                 io->u.Status = fill_name_info( unix_name, info, &name_len );
-@@ -4048,7 +4049,7 @@ NTSTATUS WINAPI NtQueryInformationFile( HANDLE handle, IO_STATUS_BLOCK *io,
-             FILE_NETWORK_OPEN_INFORMATION *info = ptr;
-             char *unix_name;
- 
--            if (!(io->u.Status = server_get_unix_name( handle, &unix_name )))
-+            if (!(io->u.Status = server_get_unix_name( handle, &unix_name, FALSE )))
-             {
-                 ULONG attributes;
-                 struct stat st;
-@@ -5661,7 +5662,7 @@ NTSTATUS FILE_CreateSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer)
-     if ((status = server_get_unix_fd( handle, FILE_SPECIAL_ACCESS, &dest_fd, &needs_close, NULL, NULL )))
-         return status;
- 
--    if ((status = server_get_unix_name( handle, &unix_src )))
-+    if ((status = server_get_unix_name( handle, &unix_src, FALSE )))
-         goto cleanup;
-     src_allocated = TRUE;
-     if (flags == SYMLINK_FLAG_RELATIVE)
-@@ -5940,7 +5941,7 @@ NTSTATUS FILE_GetSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer, ULONG out_s
-     if ((status = server_get_unix_fd( handle, FILE_ANY_ACCESS, &dest_fd, &needs_close, NULL, NULL )))
-         return status;
- 
--    if ((status = server_get_unix_name( handle, &unix_src )))
-+    if ((status = server_get_unix_name( handle, &unix_src, TRUE )))
-         goto cleanup;
- 
-     if ((status = FILE_DecodeSymlink( unix_src, unix_dest, &unix_dest_len, &buffer->ReparseTag, &flags, NULL )))
-@@ -6078,7 +6079,7 @@ NTSTATUS FILE_RemoveSymlink(HANDLE handle, REPARSE_GUID_DATA_BUFFER *buffer)
-     if ((status = server_get_unix_fd( handle, FILE_SPECIAL_ACCESS, &dest_fd, &needs_close, NULL, NULL )))
-         return status;
- 
--    if ((status = server_get_unix_name( handle, &unix_name )))
-+    if ((status = server_get_unix_name( handle, &unix_name, TRUE )))
-         goto cleanup;
- 
-     TRACE( "Deleting symlink %s\n", unix_name );
-@@ -7104,7 +7105,7 @@ NTSTATUS WINAPI NtQueryObject( HANDLE handle, OBJECT_INFORMATION_CLASS info_clas
- 
-         /* first try as a file object */
- 
--        if (!(status = server_get_unix_name( handle, &unix_name )))
-+        if (!(status = server_get_unix_name( handle, &unix_name, FALSE )))
-         {
-             if (!(status = unix_to_nt_file_name( unix_name, &nt_name )))
-             {
-diff --git a/server/fd.c b/server/fd.c
-index 03966cd3067..100c3865126 100644
---- a/server/fd.c
-+++ b/server/fd.c
-@@ -2729,11 +2729,12 @@ DECL_HANDLER(get_handle_unix_name)
- 
-     if ((fd = get_handle_fd_obj( current->process, req->handle, 0 )))
-     {
--        if (fd->unix_name)
-+        char *name = (req->nofollow ? fd->unlink_name : fd->unix_name);
-+        if (name)
-         {
--            data_size_t name_len = strlen( fd->unix_name );
-+            data_size_t name_len = strlen( name );
-             reply->name_len = name_len;
--            if (name_len <= get_reply_max_size()) set_reply_data( fd->unix_name, name_len );
-+            if (name_len <= get_reply_max_size()) set_reply_data( name, name_len );
-             else set_error( STATUS_BUFFER_OVERFLOW );
-         }
-         else set_error( STATUS_OBJECT_TYPE_MISMATCH );
-diff --git a/server/protocol.def b/server/protocol.def
-index a121c371c19..faf4891a01e 100644
---- a/server/protocol.def
-+++ b/server/protocol.def
-@@ -1297,6 +1297,7 @@ enum event_op { PULSE_EVENT, SET_EVENT, RESET_EVENT };
- /* Get the Unix name from a file handle */
- @REQ(get_handle_unix_name)
-     obj_handle_t   handle;      /* file handle */
-+    int            nofollow;    /* do not follow symlinks (return the link) */
- @REPLY
-     data_size_t    name_len;    /* unix name length */
-     VARARG(name,string);        /* unix name */
--- 
-2.17.1
-
diff --git a/patches/ntdll-Junction_Points/definition b/patches/ntdll-Junction_Points/definition
index b8768439..1bc08a0b 100644
--- a/patches/ntdll-Junction_Points/definition
+++ b/patches/ntdll-Junction_Points/definition
@@ -1,5 +1,4 @@
 Fixes: [12401] NET Framework 2.0, 3.0, 4.0 installers and other apps that make use of GAC API for managed assembly installation on NTFS filesystems need reparse point/junction API support (FSCTL_SET_REPARSE_POINT/FSCTL_GET_REPARSE_POINT)
 Fixes: [44948] Multiple apps (Spine (Mod starter for Gothic), MS Office 365 installer) need CreateSymbolicLinkW implementation
 # FIXME: patch 0006 was broken by e36a9c459d. We really want to get that information from ntdll instead, but the how is not trivial...
-Depends: ntdll-DOS_Attributes
-Depends: ntdll-NtQueryEaFile
+# FIXME 2: patch 0019 needs to call RemoveDirectoryW() from kernelbase, but it's stuck in kernel32 for now...
diff --git a/patches/ntdll-Junction_Points/xx06-kernel32-Advertise-junction-point-support.patch b/patches/ntdll-Junction_Points/xx06-kernel32-Advertise-junction-point-support.patch
index d91b1c9d..cd0824bc 100644
--- a/patches/ntdll-Junction_Points/xx06-kernel32-Advertise-junction-point-support.patch
+++ b/patches/ntdll-Junction_Points/xx06-kernel32-Advertise-junction-point-support.patch
@@ -1,21 +1,38 @@
-From a796dda4d4b7676ef758245f712ed4891902043c Mon Sep 17 00:00:00 2001
+From 5028b688bbe434ce83811da8251d920c7e2dba8a Mon Sep 17 00:00:00 2001
 From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
 Date: Thu, 16 Jan 2014 21:03:47 -0700
 Subject: kernel32: Advertise junction point support.
 
-TODO: this patch requires an update that is dependent upon obtaining
-volume information through mountmgr.
-
 Signed-off-by: Erich E. Hoover <erich.e.hoover@gmail.com>
 ---
- dlls/kernelbase/volume.c | 72 +++++++++++++++++++++++++++++++++++++++-
- 1 file changed, 71 insertions(+), 1 deletion(-)
+ dlls/kernel32/volume.c | 85 +++++++++++++++++++++++++++++++++++++++++-
+ 1 file changed, 84 insertions(+), 1 deletion(-)
 
-diff --git a/dlls/kernelbase/volume.c b/dlls/kernelbase/volume.c
-index 53cc0d49b65..f58909d321d 100644
---- a/dlls/kernelbase/volume.c
-+++ b/dlls/kernelbase/volume.c
-@@ -646,6 +646,75 @@ static DWORD get_audiocd_serial( const CDROM_TOC *toc )
+diff --git a/dlls/kernel32/volume.c b/dlls/kernel32/volume.c
+index 4fd913aa22..437832e5c9 100644
+--- a/dlls/kernel32/volume.c
++++ b/dlls/kernel32/volume.c
+@@ -44,6 +44,19 @@
+ #include "wine/unicode.h"
+ #include "wine/debug.h"
+ 
++#ifdef HAVE_SYS_MOUNT_H
++# include <sys/mount.h>
++#endif
++#ifdef HAVE_SYS_STATFS_H
++# include <sys/statfs.h>
++#endif
++#ifdef HAVE_SYS_SYSCALL_H
++# include <sys/syscall.h>
++#endif
++#ifdef HAVE_SYS_VFS_H
++# include <sys/vfs.h>
++#endif
++
+ WINE_DEFAULT_DEBUG_CHANNEL(volume);
+ 
+ #define BLOCK_SIZE 2048
+@@ -680,6 +693,75 @@ static DWORD VOLUME_GetAudioCDSerial( const CDROM_TOC *toc )
  }
  
  
@@ -89,11 +106,11 @@ index 53cc0d49b65..f58909d321d 100644
 +
 +
  /***********************************************************************
-  *           GetVolumeInformationW   (kernelbase.@)
+  *           GetVolumeInformationW   (KERNEL32.@)
   */
-@@ -781,7 +850,8 @@ fill_fs_info:  /* now fill in the information that depends on the file system ty
+@@ -824,7 +906,8 @@ fill_fs_info:  /* now fill in the information that depends on the file system ty
      default:
-         if (fsname) lstrcpynW( fsname, L"NTFS", fsname_len );
+         if (fsname) lstrcpynW( fsname, ntfsW, fsname_len );
          if (filename_len) *filename_len = 255;
 -        if (flags) *flags = FILE_CASE_PRESERVED_NAMES | FILE_PERSISTENT_ACLS;
 +        if (flags) *flags = FILE_CASE_PRESERVED_NAMES | FILE_PERSISTENT_ACLS
diff --git a/patches/ntdll-Junction_Points/0019-kernel32-Implement-CreateSymbolicLink-A-W-with-ntdll.patch b/patches/ntdll-Junction_Points/xx19-kernel32-Implement-CreateSymbolicLink-A-W-with-ntdll.patch
similarity index 88%
rename from patches/ntdll-Junction_Points/0019-kernel32-Implement-CreateSymbolicLink-A-W-with-ntdll.patch
rename to patches/ntdll-Junction_Points/xx19-kernel32-Implement-CreateSymbolicLink-A-W-with-ntdll.patch
index eae76c42..3209c695 100644
--- a/patches/ntdll-Junction_Points/0019-kernel32-Implement-CreateSymbolicLink-A-W-with-ntdll.patch
+++ b/patches/ntdll-Junction_Points/xx19-kernel32-Implement-CreateSymbolicLink-A-W-with-ntdll.patch
@@ -1,19 +1,51 @@
-From f0eee9d4ed2009f24799a149a70e0848dda9fe14 Mon Sep 17 00:00:00 2001
+From cab7c1b99de7c594083c6fd16b728a79f16b9ac8 Mon Sep 17 00:00:00 2001
 From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
 Date: Wed, 13 Mar 2019 16:02:05 -0600
-Subject: kernel32: Implement CreateSymbolicLink[A|W] with ntdll reparse
- points.
+Subject: [PATCH] kernel32: Implement CreateSymbolicLink[A|W] with ntdll
+ reparse points.
 
 Signed-off-by: Erich E. Hoover <erich.e.hoover@gmail.com>
 ---
- dlls/kernel32/tests/path.c     |  94 ++++++++++++++++++++++++++++++
- dlls/kernelbase/file.c         | 103 ++++++++++++++++++++++++++++++++-
- dlls/msvcp120/tests/msvcp120.c |  75 +++++++++++-------------
+ dlls/kernel32/path.c           |  20 ++++++-
+ dlls/kernel32/tests/path.c     |  96 ++++++++++++++++++++++++++++++
+ dlls/kernelbase/file.c         | 105 ++++++++++++++++++++++++++++++++-
+ dlls/msvcp120/tests/msvcp120.c |  75 +++++++++++------------
  dlls/msvcp140/tests/msvcp140.c |  63 +++++++++-----------
- 4 files changed, 256 insertions(+), 79 deletions(-)
+ 5 files changed, 277 insertions(+), 82 deletions(-)
 
+diff --git a/dlls/kernel32/path.c b/dlls/kernel32/path.c
+index 0f075d0af1c..3d17b53a829 100644
+--- a/dlls/kernel32/path.c
++++ b/dlls/kernel32/path.c
+@@ -385,8 +385,24 @@ WCHAR * CDECL wine_get_dos_file_name( LPCSTR str )
+  */
+ BOOLEAN WINAPI CreateSymbolicLinkA(LPCSTR link, LPCSTR target, DWORD flags)
+ {
+-    FIXME("(%s %s %d): stub\n", debugstr_a(link), debugstr_a(target), flags);
+-    return TRUE;
++    WCHAR *targetW, *linkW;
++    BOOL ret;
++
++    TRACE("(%s %s %d)\n", debugstr_a(link), debugstr_a(target), flags);
++
++    if (!(linkW = FILE_name_AtoW( link, TRUE )))
++    {
++        return FALSE;
++    }
++    if (!(targetW = FILE_name_AtoW( target, TRUE )))
++    {
++        HeapFree( GetProcessHeap(), 0, linkW );
++        return FALSE;
++    }
++    ret = CreateSymbolicLinkW( linkW, targetW, flags );
++    HeapFree( GetProcessHeap(), 0, linkW );
++    HeapFree( GetProcessHeap(), 0, targetW );
++    return ret;
+ }
+ 
+ /*************************************************************************
 diff --git a/dlls/kernel32/tests/path.c b/dlls/kernel32/tests/path.c
-index 0e45ad44ff3..0f8d94e2957 100644
+index 0e45ad44ff3..841353dcab8 100644
 --- a/dlls/kernel32/tests/path.c
 +++ b/dlls/kernel32/tests/path.c
 @@ -83,6 +83,9 @@ static NTSTATUS (WINAPI *pLdrGetDllPath)(LPCWSTR,ULONG,LPWSTR*,LPWSTR*);
@@ -26,15 +58,22 @@ index 0e45ad44ff3..0f8d94e2957 100644
  /* a structure to deal with wine todos somewhat cleanly */
  typedef struct {
    DWORD shortlen;
-@@ -2147,6 +2150,7 @@ static void init_pointers(void)
+@@ -2147,11 +2150,14 @@ static void init_pointers(void)
      MAKEFUNC(SetDefaultDllDirectories);
      MAKEFUNC(CheckNameLegalDOS8Dot3W);
      MAKEFUNC(CheckNameLegalDOS8Dot3A);
 +    MAKEFUNC(CreateSymbolicLinkW);
++
      mod = GetModuleHandleA("ntdll.dll");
      MAKEFUNC(LdrGetDllPath);
      MAKEFUNC(RtlGetExePath);
-@@ -2690,6 +2694,95 @@ static void test_LdrGetDllPath(void)
+     MAKEFUNC(RtlGetSearchPath);
+     MAKEFUNC(RtlReleasePath);
++
+ #undef MAKEFUNC
+ }
+ 
+@@ -2690,6 +2696,95 @@ static void test_LdrGetDllPath(void)
      SetEnvironmentVariableW( pathW, old_path );
  }
  
@@ -65,7 +104,7 @@ index 0e45ad44ff3..0f8d94e2957 100644
 +    DeleteFileW( path );
 +    if (!CreateDirectoryW( path, NULL ))
 +    {
-+        win_skip("Unable to create a temporary reparse point directory.\n");
++        win_skip("Unable to create a temporary junction point directory.\n");
 +        return;
 +    }
 +    GetCurrentDirectoryW( sizeof(old_path)/sizeof(WCHAR), old_path );
@@ -77,7 +116,7 @@ index 0e45ad44ff3..0f8d94e2957 100644
 +    GetVolumeInformationW( volW, 0, 0, 0, &dwLen, &dwFlags, 0, 0 );
 +    if (!(dwFlags & FILE_SUPPORTS_REPARSE_POINTS))
 +    {
-+        skip("File system does not support reparse points.\n");
++        skip("File system does not support junction points.\n");
 +        goto cleanup;
 +    }
 +
@@ -130,27 +169,30 @@ index 0e45ad44ff3..0f8d94e2957 100644
  START_TEST(path)
  {
      CHAR origdir[MAX_PATH],curdir[MAX_PATH], curDrive, otherDrive;
-@@ -2719,4 +2812,5 @@ START_TEST(path)
+@@ -2719,4 +2814,5 @@ START_TEST(path)
      test_RtlGetSearchPath();
      test_RtlGetExePath();
      test_LdrGetDllPath();
 +    test_CreateSymbolicLink();
  }
 diff --git a/dlls/kernelbase/file.c b/dlls/kernelbase/file.c
-index d9b34408692..2e67f6eaa3e 100644
+index 905029066e4..ed6ba6ae30e 100644
 --- a/dlls/kernelbase/file.c
 +++ b/dlls/kernelbase/file.c
-@@ -38,6 +38,7 @@
+@@ -36,6 +36,7 @@
+ #include "wincon.h"
+ #include "fileapi.h"
  #include "shlwapi.h"
++#include "ntifs.h"
  #include "ddk/ntddk.h"
  #include "ddk/ntddser.h"
-+#include "ntifs.h"
  
- #include "kernelbase.h"
- #include "wine/exception.h"
-@@ -926,8 +927,106 @@ done:
+@@ -943,10 +944,108 @@ done:
+ /*************************************************************************
+  *	CreateSymbolicLinkW   (kernelbase.@)
   */
- BOOLEAN WINAPI /* DECLSPEC_HOTPATCH */ CreateSymbolicLinkW( LPCWSTR link, LPCWSTR target, DWORD flags )
+-BOOLEAN WINAPI /* DECLSPEC_HOTPATCH */ CreateSymbolicLinkW( LPCWSTR link, LPCWSTR target, DWORD flags )
++BOOLEAN WINAPI DECLSPEC_HOTPATCH CreateSymbolicLinkW( const WCHAR *link, const WCHAR *target, DWORD flags )
  {
 -    FIXME( "(%s %s %d): stub\n", debugstr_w(link), debugstr_w(target), flags );
 -    return TRUE;
@@ -168,7 +210,7 @@ index d9b34408692..2e67f6eaa3e 100644
 +    HANDLE hlink;
 +    DWORD dwret;
 +
-+    TRACE( "(%s %s %d): stub\n", debugstr_w(link), debugstr_w(target), flags );
++    TRACE("(%s %s %d)\n", debugstr_w(link), debugstr_w(target), flags);
 +
 +    is_relative = (RtlDetermineDosPathNameType_U( target ) == RELATIVE_PATH);
 +    is_dir = (flags & SYMBOLIC_LINK_FLAG_DIRECTORY);
@@ -202,11 +244,11 @@ index d9b34408692..2e67f6eaa3e 100644
 +        }
 +        /* append the target to the link path */
 +        target_path_len = nt_path.Length / sizeof(WCHAR);
-+        len = target_path_len + (lstrlenW( target ) + 1);
++        len = target_path_len + (wcslen( target ) + 1);
 +        target_path = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, len*sizeof(WCHAR) );
 +        lstrcpynW( target_path, nt_path.Buffer, target_path_len+1 );
 +        target_path[target_path_len+1] = 0;
-+        lstrcatW( target_path, target );
++        wcscat( target_path, target );
 +        RtlFreeUnicodeString( &nt_path );
 +    }
 +    else
@@ -217,14 +259,14 @@ index d9b34408692..2e67f6eaa3e 100644
 +        SetLastError( RtlNtStatusToDosError(status) );
 +        goto cleanup;
 +    }
-+    if (is_relative && _wcsnicmp( target_path, nt_name.Buffer, target_path_len ) != 0)
++    if (is_relative && wcsncmp( target_path, nt_name.Buffer, target_path_len ))
 +    {
 +        SetLastError( RtlNtStatusToDosError(status) );
 +        goto cleanup;
 +    }
 +    prefix_len = is_relative ? 0 : strlen("\\??\\");
 +    string = &nt_name.Buffer[target_path_len];
-+    string_len = lstrlenW( &string[prefix_len] );
++    string_len = wcslen( &string[prefix_len] );
 +    data_size = (prefix_len + 2 * string_len + 2) * sizeof(WCHAR);
 +    buffer_size = struct_size + data_size;
 +    buffer = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, buffer_size );
@@ -236,10 +278,10 @@ index d9b34408692..2e67f6eaa3e 100644
 +    buffer->SymbolicLinkReparseBuffer.Flags = is_relative ? SYMLINK_FLAG_RELATIVE : 0;
 +    subst_dest = &buffer->SymbolicLinkReparseBuffer.PathBuffer[0];
 +    print_dest = &buffer->SymbolicLinkReparseBuffer.PathBuffer[prefix_len + string_len + 1];
-+    lstrcpyW( subst_dest, string );
-+    lstrcpyW( print_dest, &string[prefix_len] );
++    wcscpy( subst_dest, string );
++    wcscpy( print_dest, &string[prefix_len] );
 +    RtlFreeUnicodeString( &nt_name );
-+    bret = DeviceIoControl( hlink, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_size, NULL, 0,
++    bret = DeviceIoControl( hlink, FSCTL_SET_REPARSE_POINT, buffer, buffer_size, NULL, 0,
 +                            &dwret, 0 );
 +    HeapFree( GetProcessHeap(), 0, buffer );
 +
@@ -258,7 +300,7 @@ index d9b34408692..2e67f6eaa3e 100644
  
  
 diff --git a/dlls/msvcp120/tests/msvcp120.c b/dlls/msvcp120/tests/msvcp120.c
-index ed632a27df2..bd2e8550d05 100644
+index 7a382ac6faa..9775ef5e1d8 100644
 --- a/dlls/msvcp120/tests/msvcp120.c
 +++ b/dlls/msvcp120/tests/msvcp120.c
 @@ -1615,15 +1615,14 @@ static void test_tr2_sys__Stat(void)
@@ -510,5 +552,5 @@ index 751b1beed86..382f5732c29 100644
      }
  
 -- 
-2.17.1
+2.26.2
 
diff --git a/patches/ntdll-NtAccessCheck/0001-ntdll-Improve-invalid-paramater-handling-in-NtAccess.patch b/patches/ntdll-NtAccessCheck/0001-ntdll-Improve-invalid-paramater-handling-in-NtAccess.patch
index 2de35b5d..a75d341a 100644
--- a/patches/ntdll-NtAccessCheck/0001-ntdll-Improve-invalid-paramater-handling-in-NtAccess.patch
+++ b/patches/ntdll-NtAccessCheck/0001-ntdll-Improve-invalid-paramater-handling-in-NtAccess.patch
@@ -1,19 +1,19 @@
-From 81bd9eaa0466b7adc763d4302ca70141f8aa3947 Mon Sep 17 00:00:00 2001
+From 77f149959058b5e45a2fd462b5077ae417bc5857 Mon Sep 17 00:00:00 2001
 From: Qian Hong <qhong@codeweavers.com>
 Date: Tue, 16 Feb 2016 04:53:12 +0800
-Subject: [PATCH] ntdll: Improve invalid paramater handling in NtAccessCheck.
+Subject: ntdll: Improve invalid paramater handling in NtAccessCheck.
 
 Signed-off-by: Qian Hong <qhong@codeweavers.com>
 ---
- dlls/advapi32/tests/security.c | 8 --------
- dlls/ntdll/unix/security.c     | 8 +++++++-
- 2 files changed, 7 insertions(+), 9 deletions(-)
+ dlls/advapi32/tests/security.c |  8 --------
+ dlls/ntdll/sec.c               | 11 ++++++++++-
+ 2 files changed, 10 insertions(+), 9 deletions(-)
 
 diff --git a/dlls/advapi32/tests/security.c b/dlls/advapi32/tests/security.c
-index 825f8451904..ca6e735c1c6 100644
+index 8b86d45..698a9aa 100644
 --- a/dlls/advapi32/tests/security.c
 +++ b/dlls/advapi32/tests/security.c
-@@ -1466,10 +1466,8 @@ static void test_AccessCheck(void)
+@@ -1429,10 +1429,8 @@ static void test_AccessCheck(void)
      ret = AccessCheck(SecurityDescriptor, Token, KEY_READ, &Mapping,
                        0, &PrivSetLen, &Access, &AccessStatus);
      err = GetLastError();
@@ -24,7 +24,7 @@ index 825f8451904..ca6e735c1c6 100644
      ok(PrivSetLen == sizeof(PRIVILEGE_SET), "PrivSetLen returns %d\n", PrivSetLen);
      ok(Access == 0x1abe11ed && AccessStatus == 0x1abe11ed,
         "Access and/or AccessStatus were changed!\n");
-@@ -1520,12 +1518,9 @@ todo_wine
+@@ -1483,12 +1481,9 @@ todo_wine
      ret = AccessCheck(SecurityDescriptor, Token, KEY_READ, &Mapping,
                        PrivSet, &PrivSetLen, &Access, &AccessStatus);
      err = GetLastError();
@@ -37,7 +37,7 @@ index 825f8451904..ca6e735c1c6 100644
      ok(Access == 0x1abe11ed && AccessStatus == 0x1abe11ed,
         "Access and/or AccessStatus were changed!\n");
  
-@@ -1637,12 +1632,9 @@ todo_wine
+@@ -1600,12 +1595,9 @@ todo_wine
          ret = AccessCheck(SecurityDescriptor, Token, KEY_READ, &Mapping,
                            PrivSet, &PrivSetLen, &Access, &AccessStatus);
          err = GetLastError();
@@ -50,25 +50,28 @@ index 825f8451904..ca6e735c1c6 100644
          ok(Access == 0x1abe11ed && AccessStatus == 0x1abe11ed,
             "Access and/or AccessStatus were changed!\n");
  
-diff --git a/dlls/ntdll/unix/security.c b/dlls/ntdll/unix/security.c
-index daecc5e0591..c1237859784 100644
---- a/dlls/ntdll/unix/security.c
-+++ b/dlls/ntdll/unix/security.c
-@@ -650,7 +650,13 @@ NTSTATUS WINAPI NtAccessCheck( PSECURITY_DESCRIPTOR descr, HANDLE token, ACCESS_
-     TRACE( "(%p, %p, %08x, %p, %p, %p, %p, %p)\n",
-            descr, token, access, mapping, privs, retlen, access_granted, access_status );
+diff --git a/dlls/ntdll/sec.c b/dlls/ntdll/sec.c
+index 125c86e..c32ae0c 100644
+--- a/dlls/ntdll/sec.c
++++ b/dlls/ntdll/sec.c
+@@ -1586,7 +1586,16 @@ NtAccessCheck(
+         SecurityDescriptor, ClientToken, DesiredAccess, GenericMapping,
+         PrivilegeSet, ReturnLength, GrantedAccess, AccessStatus);
  
--    if (!privs || !retlen) return STATUS_ACCESS_VIOLATION;
-+    if (!retlen) return STATUS_ACCESS_VIOLATION;
-+    if (!*retlen)
+-    if (!PrivilegeSet || !ReturnLength)
++    if (!ReturnLength)
++        return STATUS_ACCESS_VIOLATION;
++
++    if (*ReturnLength == 0)
 +    {
-+        *retlen = sizeof(PRIVILEGE_SET);
++        *ReturnLength = sizeof(PRIVILEGE_SET);
 +        return STATUS_BUFFER_TOO_SMALL;
 +    }
-+    if (!privs) return STATUS_ACCESS_VIOLATION;
++
++    if (!PrivilegeSet)
+         return STATUS_ACCESS_VIOLATION;
  
-     /* reuse the object attribute SD marshalling */
-     InitializeObjectAttributes( &attr, NULL, 0, 0, descr );
+     SERVER_START_REQ( access_check )
 -- 
-2.27.0
+2.7.1
 
diff --git a/patches/ntdll-NtContinue/0001-ntdll-Add-stub-for-NtContinue.patch b/patches/ntdll-NtContinue/0001-ntdll-Add-stub-for-NtContinue.patch
new file mode 100644
index 00000000..7145857b
--- /dev/null
+++ b/patches/ntdll-NtContinue/0001-ntdll-Add-stub-for-NtContinue.patch
@@ -0,0 +1,63 @@
+From 9ea4f081689959bd393eab2caaa0ed8237846117 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
+Date: Thu, 25 May 2017 05:04:26 +0200
+Subject: [PATCH] ntdll: Add stub for NtContinue.
+
+---
+ dlls/ntdll/exception.c | 10 +++++++++-
+ dlls/ntdll/ntdll.spec  |  4 ++--
+ 2 files changed, 11 insertions(+), 3 deletions(-)
+
+diff --git a/dlls/ntdll/exception.c b/dlls/ntdll/exception.c
+index c35312fd1d1..3b85f1efa04 100644
+--- a/dlls/ntdll/exception.c
++++ b/dlls/ntdll/exception.c
+@@ -328,7 +328,6 @@ LONG WINAPI call_unhandled_exception_filter( PEXCEPTION_POINTERS eptr )
+     return unhandled_exception_filter( eptr );
+ }
+ 
+-
+ #if defined(__x86_64__) || defined(__arm__) || defined(__aarch64__)
+ 
+ struct dynamic_unwind_entry
+@@ -667,6 +666,15 @@ PRUNTIME_FUNCTION WINAPI RtlLookupFunctionEntry( ULONG_PTR pc, ULONG_PTR *base,
+ 
+ #endif  /* __x86_64__ || __arm__ || __aarch64__ */
+ 
++/*********************************************************************
++ *         NtContinue   (NTDLL.@)
++ */
++NTSTATUS WINAPI NtContinue( CONTEXT *context, BOOLEAN alert )
++{
++    FIXME( "(%p, %d) stub!\n", context, alert );
++    return STATUS_NOT_IMPLEMENTED;
++}
++
+ /*************************************************************
+  *            __wine_spec_unimplemented_stub
+  *
+diff --git a/dlls/ntdll/ntdll.spec b/dlls/ntdll/ntdll.spec
+index 81faf7fc280..d21a6f08ac2 100644
+--- a/dlls/ntdll/ntdll.spec
++++ b/dlls/ntdll/ntdll.spec
+@@ -150,7 +150,7 @@
+ @ stdcall NtCompleteConnectPort(ptr)
+ # @ stub NtCompressKey
+ @ stdcall NtConnectPort(ptr ptr ptr ptr ptr ptr ptr ptr)
+-@ stub NtContinue
++@ stdcall NtContinue(ptr long)
+ # @ stub NtCreateDebugObject
+ @ stdcall NtCreateDirectoryObject(ptr long ptr)
+ @ stdcall NtCreateEvent(ptr long ptr long long)
+@@ -1105,7 +1105,7 @@
+ @ stdcall -private ZwCompleteConnectPort(ptr) NtCompleteConnectPort
+ # @ stub ZwCompressKey
+ @ stdcall -private ZwConnectPort(ptr ptr ptr ptr ptr ptr ptr ptr) NtConnectPort
+-@ stub ZwContinue
++@ stdcall -private ZwContinue(ptr long) NtContinue
+ # @ stub ZwCreateDebugObject
+ @ stdcall -private ZwCreateDirectoryObject(ptr long ptr) NtCreateDirectoryObject
+ @ stdcall -private ZwCreateEvent(ptr long ptr long long) NtCreateEvent
+-- 
+2.17.1
+
diff --git a/patches/ntdll-NtContinue/0002-Use-NtContinue-to-continue-execution-after-exception.patch b/patches/ntdll-NtContinue/0002-Use-NtContinue-to-continue-execution-after-exception.patch
new file mode 100644
index 00000000..90294097
--- /dev/null
+++ b/patches/ntdll-NtContinue/0002-Use-NtContinue-to-continue-execution-after-exception.patch
@@ -0,0 +1,82 @@
+From 812de54c6fc8f93e8fda01f0802397b183adab59 Mon Sep 17 00:00:00 2001
+From: Andrew Wesie <awesie@gmail.com>
+Date: Fri, 27 Jul 2018 01:26:56 -0500
+Subject: [PATCH] ntdll: Use NtContinue to continue execution after exceptions.
+
+NtContinue is exported by ntdll and some programs expect it to be used to
+restore the thread context after an exception handler returns
+EXCEPTION_CONTINUE_EXECUTION. It must take a context as its first argument
+and restore that context.
+
+Current implementation is a simple wrapper around NtSetContextThread. It is
+unlikely that it has the correct behavior if called by an external caller.
+
+The __syscall_NtContinue wrapper is used so that it can be hooked by a
+third-party.
+---
+ dlls/ntdll/exception.c     | 5 +++--
+ dlls/ntdll/signal_i386.c   | 3 ++-
+ dlls/ntdll/signal_x86_64.c | 3 ++-
+ 3 files changed, 7 insertions(+), 4 deletions(-)
+
+diff --git a/dlls/ntdll/exception.c b/dlls/ntdll/exception.c
+index 3b85f1efa..bc972254f 100644
+--- a/dlls/ntdll/exception.c
++++ b/dlls/ntdll/exception.c
+@@ -671,8 +671,9 @@ PRUNTIME_FUNCTION WINAPI RtlLookupFunctionEntry( ULONG_PTR pc, ULONG_PTR *base,
+  */
+ NTSTATUS WINAPI NtContinue( CONTEXT *context, BOOLEAN alert )
+ {
+-    FIXME( "(%p, %d) stub!\n", context, alert );
+-    return STATUS_NOT_IMPLEMENTED;
++    TRACE( "(%p, %d) stub!\n", context, alert );
++
++    return NtSetContextThread( GetCurrentThread(), context );
+ }
+ 
+ /*************************************************************
+diff --git a/dlls/ntdll/signal_i386.c b/dlls/ntdll/signal_i386.c
+index e55164630..8fc885ed4 100644
+--- a/dlls/ntdll/signal_i386.c
++++ b/dlls/ntdll/signal_i386.c
+@@ -730,6 +730,7 @@ static NTSTATUS call_stack_handlers( EXCEPTION_RECORD *rec, CONTEXT *context )
+     return STATUS_UNHANDLED_EXCEPTION;
+ }
+ 
++NTSTATUS WINAPI __syscall_NtContinue( CONTEXT *context, BOOLEAN alert );
+ 
+ /*******************************************************************
+  *		raise_exception
+@@ -794,7 +795,7 @@ static NTSTATUS raise_exception( EXCEPTION_RECORD *rec, CONTEXT *context, BOOL f
+         NtTerminateProcess( NtCurrentProcess(), rec->ExceptionCode );
+     }
+ done:
+-    return NtSetContextThread( GetCurrentThread(), context );
++    return __syscall_NtContinue( context, FALSE );
+ }
+ 
+ 
+diff --git a/dlls/ntdll/signal_x86_64.c b/dlls/ntdll/signal_x86_64.c
+index e48529d73..0e74fda43 100644
+--- a/dlls/ntdll/signal_x86_64.c
++++ b/dlls/ntdll/signal_x86_64.c
+@@ -2520,6 +2520,7 @@ static NTSTATUS call_stack_handlers( EXCEPTION_RECORD *rec, CONTEXT *orig_contex
+     return STATUS_UNHANDLED_EXCEPTION;
+ }
+ 
++NTSTATUS WINAPI __syscall_NtContinue( CONTEXT *context, BOOLEAN alert );
+ 
+ static NTSTATUS raise_exception( EXCEPTION_RECORD *rec, CONTEXT *context, BOOL first_chance )
+ {
+@@ -2582,7 +2583,7 @@ static NTSTATUS raise_exception( EXCEPTION_RECORD *rec, CONTEXT *context, BOOL f
+     }
+ 
+ done:
+-    return NtSetContextThread( GetCurrentThread(), context );
++    return __syscall_NtContinue( context, FALSE );
+ }
+ 
+ 
+-- 
+2.23.0
+
diff --git a/patches/ntdll-NtContinue/definition b/patches/ntdll-NtContinue/definition
new file mode 100644
index 00000000..06c2ebf9
--- /dev/null
+++ b/patches/ntdll-NtContinue/definition
@@ -0,0 +1,3 @@
+Fixes: [31910] Add stub for NtContinue
+Fixes: [45572] League of Legends 8.12+ fails to start a game (anticheat engine, hooking of NtContinue)
+Depends: winebuild-Fake_Dlls
\ No newline at end of file
diff --git a/patches/ntdll-NtDevicePath/0001-ntdll-Implement-opening-files-through-nt-device-path.patch b/patches/ntdll-NtDevicePath/0001-ntdll-Implement-opening-files-through-nt-device-path.patch
index ad814a42..0a34fb39 100644
--- a/patches/ntdll-NtDevicePath/0001-ntdll-Implement-opening-files-through-nt-device-path.patch
+++ b/patches/ntdll-NtDevicePath/0001-ntdll-Implement-opening-files-through-nt-device-path.patch
@@ -1,81 +1,38 @@
-From ee7a43bf36722acba4c870409fc15ea5bdf4a80b Mon Sep 17 00:00:00 2001
+From 934a7712600b45fa584386b4ada2a73af88ee072 Mon Sep 17 00:00:00 2001
 From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
 Date: Fri, 26 May 2017 05:17:17 +0200
-Subject: [PATCH] ntdll: Implement opening files through nt device paths.
+Subject: ntdll: Implement opening files through nt device paths.
 
 ---
+ dlls/ntdll/directory.c  | 132 +++++++++++++++++++++++++++++++++++++---
  dlls/ntdll/tests/file.c |  25 +++++++-
- dlls/ntdll/unix/file.c  | 122 +++++++++++++++++++++++++++++++++++++++-
- 2 files changed, 145 insertions(+), 2 deletions(-)
+ 2 files changed, 147 insertions(+), 10 deletions(-)
 
-diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
-index 6164b0c4bde..6610edbd042 100644
---- a/dlls/ntdll/tests/file.c
-+++ b/dlls/ntdll/tests/file.c
-@@ -135,18 +135,22 @@ static void WINAPI apc( void *arg, IO_STATUS_BLOCK *iosb, ULONG reserved )
+diff --git a/dlls/ntdll/directory.c b/dlls/ntdll/directory.c
+index c6249dd8658..242dbd27b2f 100644
+--- a/dlls/ntdll/directory.c
++++ b/dlls/ntdll/directory.c
+@@ -2732,16 +2732,10 @@ NTSTATUS nt_to_unix_file_name_attr( const OBJECT_ATTRIBUTES *attr, ANSI_STRING *
  
- static void create_file_test(void)
- {
-+    static const WCHAR notepadW[] = {'n','o','t','e','p','a','d','.','e','x','e',0};
-     static const WCHAR systemrootW[] = {'\\','S','y','s','t','e','m','R','o','o','t',
-                                         '\\','f','a','i','l','i','n','g',0};
-+    static const WCHAR systemrootExplorerW[] = {'\\','S','y','s','t','e','m','R','o','o','t',
-+                                               '\\','e','x','p','l','o','r','e','r','.','e','x','e',0};
-     static const WCHAR questionmarkInvalidNameW[] = {'a','f','i','l','e','?',0};
-     static const WCHAR pipeInvalidNameW[]  = {'a','|','b',0};
-     static const WCHAR pathInvalidNtW[] = {'\\','\\','?','\\',0};
-     static const WCHAR pathInvalidNt2W[] = {'\\','?','?','\\',0};
-     static const WCHAR pathInvalidDosW[] = {'\\','D','o','s','D','e','v','i','c','e','s','\\',0};
-     static const char testdata[] = "Hello World";
-+    static const WCHAR sepW[] = {'\\',0};
-     FILE_NETWORK_OPEN_INFORMATION info;
-     NTSTATUS status;
-     HANDLE dir, file;
--    WCHAR path[MAX_PATH];
-+    WCHAR path[MAX_PATH], temp[MAX_PATH];
-     OBJECT_ATTRIBUTES attr;
-     IO_STATUS_BLOCK io;
-     UNICODE_STRING nameW;
-@@ -327,6 +331,25 @@ static void create_file_test(void)
-     status = pNtQueryFullAttributesFile( &attr, &info );
-     ok( status == STATUS_OBJECT_NAME_INVALID,
-         "query %s failed %x\n", wine_dbgstr_w(nameW.Buffer), status );
-+
-+    GetWindowsDirectoryW( path, MAX_PATH );
-+    path[2] = 0;
-+    ok( QueryDosDeviceW( path, temp, MAX_PATH ),
-+        "QueryDosDeviceW failed with error %u\n", GetLastError() );
-+    lstrcatW( temp, sepW );
-+    lstrcatW( temp, path+3 );
-+    lstrcatW( temp, sepW );
-+    lstrcatW( temp, notepadW );
-+
-+    pRtlInitUnicodeString( &nameW, temp );
-+    status = pNtQueryFullAttributesFile( &attr, &info );
-+    ok( status == STATUS_SUCCESS,
-+        "query %s failed %x\n", wine_dbgstr_w(nameW.Buffer), status );
-+
-+    pRtlInitUnicodeString( &nameW, systemrootExplorerW );
-+    status = pNtQueryFullAttributesFile( &attr, &info );
-+    ok( status == STATUS_SUCCESS,
-+        "query %s failed %x\n", wine_dbgstr_w(nameW.Buffer), status );
- }
  
- static void open_file_test(void)
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index b6529241739..74f3f707444 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -3250,7 +3250,7 @@ static NTSTATUS nt_to_unix_file_name_attr( const OBJECT_ATTRIBUTES *attr, char *
-  * element doesn't have to exist; in that case STATUS_NO_SUCH_FILE is
-  * returned, but the unix name is still filled in properly.
+ /******************************************************************************
+- *           wine_nt_to_unix_file_name  (NTDLL.@) Not a Windows API
+- *
+- * Convert a file name from NT namespace to Unix namespace.
+- *
+- * If disposition is not FILE_OPEN or FILE_OVERWRITE, the last path
+- * element doesn't have to exist; in that case STATUS_NO_SUCH_FILE is
+- * returned, but the unix name is still filled in properly.
++ *           nt_to_unix_file_name_internal
   */
--NTSTATUS nt_to_unix_file_name( const UNICODE_STRING *nameW, char **unix_name_ret, UINT disposition )
-+static NTSTATUS nt_to_unix_file_name_internal( const UNICODE_STRING *nameW, char **unix_name_ret, UINT disposition )
+-NTSTATUS CDECL wine_nt_to_unix_file_name( const UNICODE_STRING *nameW, ANSI_STRING *unix_name_ret,
+-                                          UINT disposition, BOOLEAN check_case )
++static NTSTATUS nt_to_unix_file_name_internal( const UNICODE_STRING *nameW, ANSI_STRING *unix_name_ret,
++                                               UINT disposition, BOOLEAN check_case )
  {
      static const WCHAR unixW[] = {'u','n','i','x'};
      static const WCHAR pipeW[] = {'p','i','p','e'};
-@@ -3387,6 +3387,126 @@ NTSTATUS CDECL wine_nt_to_unix_file_name( const UNICODE_STRING *nameW, char *nam
+@@ -2857,6 +2851,126 @@ NTSTATUS CDECL wine_nt_to_unix_file_name( const UNICODE_STRING *nameW, ANSI_STRI
      return status;
  }
  
@@ -109,7 +66,7 @@ index b6529241739..74f3f707444 100644
 +static NTSTATUS nt_to_dos_device( WCHAR *name, size_t length, WCHAR *device_ret )
 +{
 +    static const WCHAR dosdevicesW[] = {'\\','D','o','s','D','e','v','i','c','e','s',0};
-+    UNICODE_STRING dosdevW = { sizeof(dosdevicesW) - sizeof(WCHAR), sizeof(dosdevicesW), (WCHAR *)dosdevicesW };
++    UNICODE_STRING dosdevW;
 +    WCHAR symlinkW[MAX_DIR_ENTRY_LEN];
 +    OBJECT_ATTRIBUTES attr;
 +    NTSTATUS status;
@@ -126,6 +83,7 @@ index b6529241739..74f3f707444 100644
 +    attr.SecurityDescriptor = NULL;
 +    attr.SecurityQualityOfService = NULL;
 +
++    RtlInitUnicodeString( &dosdevW, dosdevicesW );
 +    status = NtOpenDirectoryObject( &handle, FILE_LIST_DIRECTORY, &attr );
 +    if (status) return STATUS_BAD_DEVICE_TYPE;
 +
@@ -145,7 +103,7 @@ index b6529241739..74f3f707444 100644
 +}
 +
 +/******************************************************************************
-+ *           nt_to_unix_file_name  (NTDLL.@) Not a Windows API
++ *           wine_nt_to_unix_file_name  (NTDLL.@) Not a Windows API
 + *
 + * Convert a file name from NT namespace to Unix namespace.
 + *
@@ -153,8 +111,8 @@ index b6529241739..74f3f707444 100644
 + * element doesn't have to exist; in that case STATUS_NO_SUCH_FILE is
 + * returned, but the unix name is still filled in properly.
 + */
-+NTSTATUS nt_to_unix_file_name( const UNICODE_STRING *nameW, char **unix_name_ret,
-+                                     UINT disposition )
++NTSTATUS CDECL wine_nt_to_unix_file_name( const UNICODE_STRING *nameW, ANSI_STRING *unix_name_ret,
++                                          UINT disposition, BOOLEAN check_case )
 +{
 +    static const WCHAR systemrootW[] = {'\\','S','y','s','t','e','m','R','o','o','t','\\',0};
 +    static const WCHAR dosprefixW[] = {'\\','?','?','\\'};
@@ -177,11 +135,11 @@ index b6529241739..74f3f707444 100644
 +        prefix = user_shared_data->NtSystemRoot;
 +    }
 +    else
-+        return nt_to_unix_file_name_internal( nameW, unix_name_ret, disposition );
++        return nt_to_unix_file_name_internal( nameW, unix_name_ret, disposition, check_case );
 +
 +    name_len = sizeof(dosprefixW) + wcslen(prefix) * sizeof(WCHAR) +
 +               nameW->Length - offset * sizeof(WCHAR) + sizeof(WCHAR);
-+    if (!(name = malloc( name_len )))
++    if (!(name = RtlAllocateHeap( GetProcessHeap(), 0, name_len )))
 +        return STATUS_NO_MEMORY;
 +
 +    ptr = name;
@@ -192,16 +150,69 @@ index b6529241739..74f3f707444 100644
 +    memcpy( ptr, nameW->Buffer + offset, nameW->Length - offset * sizeof(WCHAR) );
 +    ptr[ nameW->Length / sizeof(WCHAR) - offset ] = 0;
 +
-+    dospathW.Buffer = name;
-+    dospathW.Length = wcslen( name ) * sizeof(WCHAR);
-+    status = nt_to_unix_file_name_internal( &dospathW, unix_name_ret, disposition );
++    RtlInitUnicodeString( &dospathW, name );
++    status = nt_to_unix_file_name_internal( &dospathW, unix_name_ret, disposition, check_case );
 +
-+    free( name );
++    RtlFreeHeap( GetProcessHeap(), 0, name );
 +    return status;
 +}
  
  /******************************************************************
-  *           unix_to_nt_file_name
+  *		RtlWow64EnableFsRedirection   (NTDLL.@)
+diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
+index 546795456a8..709698209d8 100644
+--- a/dlls/ntdll/tests/file.c
++++ b/dlls/ntdll/tests/file.c
+@@ -135,18 +135,22 @@ static void WINAPI apc( void *arg, IO_STATUS_BLOCK *iosb, ULONG reserved )
+ 
+ static void create_file_test(void)
+ {
++    static const WCHAR notepadW[] = {'n','o','t','e','p','a','d','.','e','x','e',0};
+     static const WCHAR systemrootW[] = {'\\','S','y','s','t','e','m','R','o','o','t',
+                                         '\\','f','a','i','l','i','n','g',0};
++    static const WCHAR systemrootExplorerW[] = {'\\','S','y','s','t','e','m','R','o','o','t',
++                                               '\\','e','x','p','l','o','r','e','r','.','e','x','e',0};
+     static const WCHAR questionmarkInvalidNameW[] = {'a','f','i','l','e','?',0};
+     static const WCHAR pipeInvalidNameW[]  = {'a','|','b',0};
+     static const WCHAR pathInvalidNtW[] = {'\\','\\','?','\\',0};
+     static const WCHAR pathInvalidNt2W[] = {'\\','?','?','\\',0};
+     static const WCHAR pathInvalidDosW[] = {'\\','D','o','s','D','e','v','i','c','e','s','\\',0};
+     static const char testdata[] = "Hello World";
++    static const WCHAR sepW[] = {'\\',0};
+     FILE_NETWORK_OPEN_INFORMATION info;
+     NTSTATUS status;
+     HANDLE dir, file;
+-    WCHAR path[MAX_PATH];
++    WCHAR path[MAX_PATH], temp[MAX_PATH];
+     OBJECT_ATTRIBUTES attr;
+     IO_STATUS_BLOCK io;
+     UNICODE_STRING nameW;
+@@ -327,6 +331,25 @@ static void create_file_test(void)
+     status = pNtQueryFullAttributesFile( &attr, &info );
+     ok( status == STATUS_OBJECT_NAME_INVALID,
+         "query %s failed %x\n", wine_dbgstr_w(nameW.Buffer), status );
++
++    GetWindowsDirectoryW( path, MAX_PATH );
++    path[2] = 0;
++    ok( QueryDosDeviceW( path, temp, MAX_PATH ),
++        "QueryDosDeviceW failed with error %u\n", GetLastError() );
++    lstrcatW( temp, sepW );
++    lstrcatW( temp, path+3 );
++    lstrcatW( temp, sepW );
++    lstrcatW( temp, notepadW );
++
++    pRtlInitUnicodeString( &nameW, temp );
++    status = pNtQueryFullAttributesFile( &attr, &info );
++    ok( status == STATUS_SUCCESS,
++        "query %s failed %x\n", wine_dbgstr_w(nameW.Buffer), status );
++
++    pRtlInitUnicodeString( &nameW, systemrootExplorerW );
++    status = pNtQueryFullAttributesFile( &attr, &info );
++    ok( status == STATUS_SUCCESS,
++        "query %s failed %x\n", wine_dbgstr_w(nameW.Buffer), status );
+ }
+ 
+ static void open_file_test(void)
 -- 
-2.27.0
+2.26.0
 
diff --git a/patches/ntdll-NtQueryEaFile/0001-ntdll-Improve-stub-of-NtQueryEaFile.patch b/patches/ntdll-NtQueryEaFile/0001-ntdll-Improve-stub-of-NtQueryEaFile.patch
index 036b0be2..0d9bdecd 100644
--- a/patches/ntdll-NtQueryEaFile/0001-ntdll-Improve-stub-of-NtQueryEaFile.patch
+++ b/patches/ntdll-NtQueryEaFile/0001-ntdll-Improve-stub-of-NtQueryEaFile.patch
@@ -1,19 +1,53 @@
-From b38ef24ec2a84cf8ae1e3d1fcb12c249a0d9c512 Mon Sep 17 00:00:00 2001
+From 157385f6bdf23c65b1375126f73dad87fcb503f4 Mon Sep 17 00:00:00 2001
 From: Sebastian Lackner <sebastian@fds-team.de>
 Date: Sat, 6 Jun 2015 07:03:33 +0800
 Subject: [PATCH] ntdll: Improve stub of NtQueryEaFile.
 
 Based on a patch by Qian Hong.
 ---
+ dlls/ntdll/file.c       | 19 ++++++++--
  dlls/ntdll/tests/file.c | 83 +++++++++++++++++++++++++++++++++++++++++
- dlls/ntdll/unix/file.c  | 15 +++++++-
- 2 files changed, 96 insertions(+), 2 deletions(-)
+ 2 files changed, 98 insertions(+), 4 deletions(-)
 
+diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
+index 7a49cb5d8db..b940201c5a8 100644
+--- a/dlls/ntdll/file.c
++++ b/dlls/ntdll/file.c
+@@ -4041,14 +4041,25 @@ NTSTATUS WINAPI NtQueryVolumeInformationFile( HANDLE handle, PIO_STATUS_BLOCK io
+  *  Success: 0. Attributes read into buffer
+  *  Failure: An NTSTATUS error code describing the error.
+  */
+-NTSTATUS WINAPI NtQueryEaFile( HANDLE hFile, PIO_STATUS_BLOCK iosb, PVOID buffer, ULONG length,
++NTSTATUS WINAPI NtQueryEaFile( HANDLE handle, PIO_STATUS_BLOCK iosb, PVOID buffer, ULONG length,
+                                BOOLEAN single_entry, PVOID ea_list, ULONG ea_list_len,
+                                PULONG ea_index, BOOLEAN restart )
+ {
+-    FIXME("(%p,%p,%p,%d,%d,%p,%d,%p,%d) stub\n",
+-            hFile, iosb, buffer, length, single_entry, ea_list,
++    int fd, needs_close;
++    NTSTATUS status;
++
++    FIXME("(%p,%p,%p,%d,%d,%p,%d,%p,%d) semi-stub\n",
++            handle, iosb, buffer, length, single_entry, ea_list,
+             ea_list_len, ea_index, restart);
+-    return STATUS_ACCESS_DENIED;
++
++    if ((status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, NULL )) != STATUS_SUCCESS)
++        return status;
++
++    if (buffer && length)
++        memset( buffer, 0, length );
++
++    if (needs_close) close( fd );
++    return STATUS_NO_EAS_ON_FILE;
+ }
+ 
+ 
 diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
-index decfaff638a..acba3540282 100644
+index 44335514761..abd5903e804 100644
 --- a/dlls/ntdll/tests/file.c
 +++ b/dlls/ntdll/tests/file.c
-@@ -84,6 +84,7 @@ static NTSTATUS (WINAPI *pNtQueryDirectoryFile)(HANDLE,HANDLE,PIO_APC_ROUTINE,PV
+@@ -85,6 +85,7 @@ static NTSTATUS (WINAPI *pNtQueryDirectoryFile)(HANDLE,HANDLE,PIO_APC_ROUTINE,PV
  static NTSTATUS (WINAPI *pNtQueryVolumeInformationFile)(HANDLE,PIO_STATUS_BLOCK,PVOID,ULONG,FS_INFORMATION_CLASS);
  static NTSTATUS (WINAPI *pNtQueryFullAttributesFile)(const OBJECT_ATTRIBUTES*, FILE_NETWORK_OPEN_INFORMATION*);
  static NTSTATUS (WINAPI *pNtFlushBuffersFile)(HANDLE, IO_STATUS_BLOCK*);
@@ -21,7 +55,7 @@ index decfaff638a..acba3540282 100644
  
  static WCHAR fooW[] = {'f','o','o',0};
  
-@@ -4990,6 +4991,86 @@ static void test_flush_buffers_file(void)
+@@ -4886,6 +4887,86 @@ static void test_flush_buffers_file(void)
      DeleteFileA(buffer);
  }
  
@@ -108,7 +142,7 @@ index decfaff638a..acba3540282 100644
  static void test_file_readonly_access(void)
  {
      static const DWORD default_sharing = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
-@@ -5163,6 +5244,7 @@ START_TEST(file)
+@@ -5375,6 +5456,7 @@ START_TEST(file)
      pNtQueryVolumeInformationFile = (void *)GetProcAddress(hntdll, "NtQueryVolumeInformationFile");
      pNtQueryFullAttributesFile = (void *)GetProcAddress(hntdll, "NtQueryFullAttributesFile");
      pNtFlushBuffersFile = (void *)GetProcAddress(hntdll, "NtFlushBuffersFile");
@@ -116,41 +150,14 @@ index decfaff638a..acba3540282 100644
  
      test_read_write();
      test_NtCreateFile();
-@@ -5192,6 +5274,7 @@ START_TEST(file)
+@@ -5404,6 +5486,7 @@ START_TEST(file)
      test_query_volume_information_file();
      test_query_attribute_information_file();
      test_ioctl();
 +    test_query_ea();
      test_flush_buffers_file();
-     test_mailslot_name();
+     test_reparse_points();
  }
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index 350a42f4249..e54a010855f 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -6555,9 +6555,20 @@ NTSTATUS WINAPI NtQueryEaFile( HANDLE handle, IO_STATUS_BLOCK *io, void *buffer,
-                                BOOLEAN single_entry, void *list, ULONG list_len,
-                                ULONG *index, BOOLEAN restart )
- {
--    FIXME( "(%p,%p,%p,%d,%d,%p,%d,%p,%d) stub\n",
-+    int fd, needs_close;
-+    NTSTATUS status;
-+
-+    FIXME( "(%p,%p,%p,%d,%d,%p,%d,%p,%d) semi-stub\n",
-            handle, io, buffer, length, single_entry, list, list_len, index, restart );
--    return STATUS_ACCESS_DENIED;
-+
-+    if ((status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, NULL )))
-+        return status;
-+
-+    if (buffer && length)
-+        memset( buffer, 0, length );
-+
-+    if (needs_close) close( fd );
-+    return STATUS_NO_EAS_ON_FILE;
- }
- 
- 
 -- 
-2.27.0
+2.26.2
 
diff --git a/patches/ntdll-NtQueryEaFile/definition b/patches/ntdll-NtQueryEaFile/definition
index c3a4b643..a86870c2 100644
--- a/patches/ntdll-NtQueryEaFile/definition
+++ b/patches/ntdll-NtQueryEaFile/definition
@@ -1 +1,3 @@
 Fixes: Improve stub for NtQueryEaFile
+# Depends: ntdll-Syscall_Wrappers
+Depends: ntdll-Junction_Points
diff --git a/patches/ntdll-NtQueryVirtualMemory/0003-ntdll-Implement-NtQueryVirtualMemory-MemorySectionNa.patch b/patches/ntdll-NtQueryVirtualMemory/0003-ntdll-Implement-NtQueryVirtualMemory-MemorySectionNa.patch
index e09b08f8..d2666fe2 100644
--- a/patches/ntdll-NtQueryVirtualMemory/0003-ntdll-Implement-NtQueryVirtualMemory-MemorySectionNa.patch
+++ b/patches/ntdll-NtQueryVirtualMemory/0003-ntdll-Implement-NtQueryVirtualMemory-MemorySectionNa.patch
@@ -1,49 +1,21 @@
-From 4ad7e0d2a51606b323cbe2f33c64a99c3666a072 Mon Sep 17 00:00:00 2001
+From e718ef3521d76d455dbfd1088cc83e47121d987c Mon Sep 17 00:00:00 2001
 From: Dmitry Timoshkov <dmitry@baikal.ru>
 Date: Sun, 28 May 2017 05:19:30 +0200
-Subject: [PATCH] ntdll: Implement NtQueryVirtualMemory(MemorySectionName).
- (v3)
+Subject: ntdll: Implement NtQueryVirtualMemory(MemorySectionName). (v3)
 
 Contains several improvements by Sebastian Lackner <sebastian@fds-team.de>.
 ---
- dlls/ntdll/unix/file.c         |  2 +-
- dlls/ntdll/unix/unix_private.h |  1 +
- dlls/ntdll/unix/virtual.c      | 96 +++++++++++++++++++++++++++++++++-
- dlls/psapi/tests/psapi_main.c  |  8 +--
- server/mapping.c               | 29 ++++++++++
- server/protocol.def            |  9 ++++
- 6 files changed, 136 insertions(+), 9 deletions(-)
+ dlls/ntdll/virtual.c          | 91 ++++++++++++++++++++++++++++++++++-
+ dlls/psapi/tests/psapi_main.c |  8 +--
+ server/mapping.c              | 29 +++++++++++
+ server/protocol.def           |  9 ++++
+ 4 files changed, 129 insertions(+), 8 deletions(-)
 
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index a41deb0881d..06ab827836d 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -1835,7 +1835,7 @@ static NTSTATUS fill_file_info( const struct stat *st, ULONG attr, void *ptr,
- }
- 
- 
--static NTSTATUS server_get_unix_name( HANDLE handle, char **unix_name, BOOL nofollow )
-+NTSTATUS server_get_unix_name( HANDLE handle, char **unix_name, BOOL nofollow )
- {
-     data_size_t size = 1024;
-     NTSTATUS ret;
-diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
-index 3cf9ca66736..a9ce3be82b2 100644
---- a/dlls/ntdll/unix/unix_private.h
-+++ b/dlls/ntdll/unix/unix_private.h
-@@ -171,6 +171,7 @@ extern unsigned int server_queue_process_apc( HANDLE process, const apc_call_t *
-                                               apc_result_t *result ) DECLSPEC_HIDDEN;
- extern int server_get_unix_fd( HANDLE handle, unsigned int wanted_access, int *unix_fd,
-                                int *needs_close, enum server_fd_type *type, unsigned int *options ) DECLSPEC_HIDDEN;
-+extern NTSTATUS server_get_unix_name( HANDLE handle, char **unix_name, BOOL nofollow ) DECLSPEC_HIDDEN;
- extern void server_init_process(void) DECLSPEC_HIDDEN;
- extern size_t server_init_thread( void *entry_point, BOOL *suspend ) DECLSPEC_HIDDEN;
- extern int server_pipe( int fd[2] ) DECLSPEC_HIDDEN;
-diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
-index 9d19a621666..9758b11de74 100644
---- a/dlls/ntdll/unix/virtual.c
-+++ b/dlls/ntdll/unix/virtual.c
-@@ -4060,6 +4060,98 @@ static NTSTATUS get_working_set_ex( HANDLE process, LPCVOID addr,
+diff --git a/dlls/ntdll/virtual.c b/dlls/ntdll/virtual.c
+index 6ad2d21e0..f49127c3e 100644
+--- a/dlls/ntdll/virtual.c
++++ b/dlls/ntdll/virtual.c
+@@ -3192,6 +3192,93 @@ static NTSTATUS get_working_set_ex( HANDLE process, LPCVOID addr,
      return STATUS_SUCCESS;
  }
  
@@ -53,8 +25,7 @@ index 9d19a621666..9758b11de74 100644
 +                                  SIZE_T len, SIZE_T *res_len )
 +{
 +    UNICODE_STRING nt_name;
-+    WCHAR *nt_nameW;
-+    char *unix_name;
++    ANSI_STRING unix_name;
 +    data_size_t size = 1024;
 +    WCHAR *name = NULL;
 +    NTSTATUS status;
@@ -73,25 +44,21 @@ index 9d19a621666..9758b11de74 100644
 +
 +    if (!status && mapping)
 +    {
-+        status = server_get_unix_name( mapping, &unix_name, FALSE );
-+        NtClose( mapping );
-+        if (!status)
-+        {
-+            status = unix_to_nt_file_name( unix_name, &nt_nameW );
-+            free( unix_name );
-+        }
++        status = server_get_unix_name( mapping, &unix_name );
++        close_handle( mapping );
 +        if (!status)
 +        {
-+            RtlInitUnicodeString( &nt_name, nt_nameW );
-+            goto found;
++            status = wine_unix_to_nt_file_name( &unix_name, &nt_name );
++            RtlFreeAnsiString( &unix_name );
 +        }
++        if (!status) goto found;
 +        if (status == STATUS_OBJECT_TYPE_MISMATCH) status = STATUS_FILE_INVALID;
 +        return status;
 +    }
 +
 +    for (;;)
 +    {
-+        if (!(name = malloc( (size + 1) * sizeof(WCHAR) )))
++        if (!(name = RtlAllocateHeap( GetProcessHeap(), 0, (size + 1) * sizeof(WCHAR) )))
 +            return STATUS_NO_MEMORY;
 +
 +        SERVER_START_REQ( get_dll_info )
@@ -109,14 +76,14 @@ index 9d19a621666..9758b11de74 100644
 +            name[size] = 0;
 +            break;
 +        }
-+        free( name );
++        RtlFreeHeap( GetProcessHeap(), 0, name );
 +        if (status == STATUS_DLL_NOT_FOUND) return STATUS_INVALID_ADDRESS;
 +        if (status != STATUS_BUFFER_TOO_SMALL) return status;
 +    }
 +
 +    if (!RtlDosPathNameToNtPathName_U( name, &nt_name, NULL, NULL ))
 +    {
-+        free( name );
++        RtlFreeHeap( GetProcessHeap(), 0, name );
 +        return STATUS_INVALID_PARAMETER;
 +    }
 +
@@ -133,7 +100,7 @@ index 9d19a621666..9758b11de74 100644
 +    else
 +        status = (len < sizeof(MEMORY_SECTION_NAME)) ? STATUS_INFO_LENGTH_MISMATCH : STATUS_BUFFER_OVERFLOW;
 +
-+    free( name );
++    RtlFreeHeap( GetProcessHeap(), 0, name );
 +    RtlFreeUnicodeString( &nt_name );
 +    return status;
 +}
@@ -142,7 +109,7 @@ index 9d19a621666..9758b11de74 100644
  #define UNIMPLEMENTED_INFO_CLASS(c) \
      case c: \
          FIXME("(process=%p,addr=%p) Unimplemented information class: " #c "\n", process, addr); \
-@@ -4084,8 +4176,10 @@ NTSTATUS WINAPI NtQueryVirtualMemory( HANDLE process, LPCVOID addr,
+@@ -3216,8 +3303,10 @@ NTSTATUS WINAPI NtQueryVirtualMemory( HANDLE process, LPCVOID addr,
          case MemoryWorkingSetExInformation:
              return get_working_set_ex( process, addr, buffer, len, res_len );
  
@@ -155,10 +122,10 @@ index 9d19a621666..9758b11de74 100644
  
          default:
 diff --git a/dlls/psapi/tests/psapi_main.c b/dlls/psapi/tests/psapi_main.c
-index da7524dd60a..bfe14231a9b 100644
+index 0df247e9b..1cc0455aa 100644
 --- a/dlls/psapi/tests/psapi_main.c
 +++ b/dlls/psapi/tests/psapi_main.c
-@@ -372,14 +372,7 @@ static BOOL nt_get_mapped_file_name(HANDLE process, LPVOID addr, LPWSTR name, DW
+@@ -375,14 +375,7 @@ static BOOL nt_get_mapped_file_name(HANDLE process, LPVOID addr, LPWSTR name, DW
  
      ret_len = 0xdeadbeef;
      status = pNtQueryVirtualMemory(process, addr, MemorySectionName, buf, buf_len, &ret_len);
@@ -173,7 +140,7 @@ index da7524dd60a..bfe14231a9b 100644
  
      section_name = (MEMORY_SECTION_NAME *)buf;
      ok(ret_len == section_name->SectionFileName.MaximumLength + sizeof(*section_name), "got %lu, %u\n",
-@@ -501,6 +494,7 @@ todo_wine {
+@@ -504,6 +497,7 @@ todo_wine {
      {
          ok(memcmp(map_nameW, nt_map_name, lstrlenW(map_nameW)) == 0, "map name does not start with a device name: %s\n", map_name);
          WideCharToMultiByte(CP_ACP, 0, map_nameW, -1, map_name, MAX_PATH, NULL, NULL);
@@ -182,10 +149,10 @@ index da7524dd60a..bfe14231a9b 100644
      }
  
 diff --git a/server/mapping.c b/server/mapping.c
-index db0debe0af5..6e74f5b770f 100644
+index 6990a1913..ca28e8909 100644
 --- a/server/mapping.c
 +++ b/server/mapping.c
-@@ -1099,6 +1099,35 @@ DECL_HANDLER(unmap_view)
+@@ -1064,6 +1064,35 @@ DECL_HANDLER(unmap_view)
      if (view) free_memory_view( view );
  }
  
@@ -222,10 +189,10 @@ index db0debe0af5..6e74f5b770f 100644
  DECL_HANDLER(get_mapping_committed_range)
  {
 diff --git a/server/protocol.def b/server/protocol.def
-index faf4891a01e..0d98d9413e4 100644
+index 6c44b2b43..e7753f8b7 100644
 --- a/server/protocol.def
 +++ b/server/protocol.def
-@@ -1691,6 +1691,15 @@ enum char_info_mode
+@@ -1838,6 +1838,15 @@ enum char_info_mode
  @END
  
  
@@ -242,5 +209,5 @@ index faf4891a01e..0d98d9413e4 100644
  @REQ(get_mapping_committed_range)
      client_ptr_t base;          /* view base address */
 -- 
-2.27.0
+2.26.2
 
diff --git a/patches/ntdll-NtQueryVirtualMemory/0004-ntdll-tests-Add-tests-for-NtQueryVirtualMemory-Memor.patch b/patches/ntdll-NtQueryVirtualMemory/0004-ntdll-tests-Add-tests-for-NtQueryVirtualMemory-Memor.patch
index 00610677..f3eb29b8 100644
--- a/patches/ntdll-NtQueryVirtualMemory/0004-ntdll-tests-Add-tests-for-NtQueryVirtualMemory-Memor.patch
+++ b/patches/ntdll-NtQueryVirtualMemory/0004-ntdll-tests-Add-tests-for-NtQueryVirtualMemory-Memor.patch
@@ -1,18 +1,18 @@
-From 8ea8ef48ce50b357f04664c70c3c86ea40c654ec Mon Sep 17 00:00:00 2001
+From a100b0b789c767230ef98eb2201e5ae5a272e907 Mon Sep 17 00:00:00 2001
 From: Dmitry Timoshkov <dmitry@baikal.ru>
 Date: Sun, 28 May 2017 10:30:43 +0200
 Subject: [PATCH] ntdll/tests: Add tests for
  NtQueryVirtualMemory(MemorySectionName).
 
 ---
- dlls/ntdll/tests/info.c | 30 ++++++++++++++++++++++++++++++
- 1 file changed, 30 insertions(+)
+ dlls/ntdll/tests/info.c | 35 +++++++++++++++++++++++++++++++++++
+ 1 file changed, 35 insertions(+)
 
 diff --git a/dlls/ntdll/tests/info.c b/dlls/ntdll/tests/info.c
-index e5137ef5a45..e06a229e6cd 100644
+index 7a641f8b84e..e335e758175 100644
 --- a/dlls/ntdll/tests/info.c
 +++ b/dlls/ntdll/tests/info.c
-@@ -2092,6 +2092,8 @@ static void test_queryvirtualmemory(void)
+@@ -2182,6 +2182,8 @@ static void test_queryvirtualmemory(void)
      char stackbuf[42];
      HMODULE module;
      void *user_shared_data = (void *)0x7ffe0000;
@@ -20,12 +20,13 @@ index e5137ef5a45..e06a229e6cd 100644
 +    MEMORY_SECTION_NAME *msn = (MEMORY_SECTION_NAME *)buffer_name;
  
      module = GetModuleHandleA( "ntdll.dll" );
-     status = pNtQueryVirtualMemory(NtCurrentProcess(), module, MemoryBasicInformation, &mbi, sizeof(MEMORY_BASIC_INFORMATION), &readcount);
-@@ -2174,6 +2176,34 @@ static void test_queryvirtualmemory(void)
+     trace("Check flags of the PE header of NTDLL.DLL at %p\n", module);
+@@ -2274,6 +2276,39 @@ static void test_queryvirtualmemory(void)
      /* check error code when len is less than MEMORY_BASIC_INFORMATION size */
      status = pNtQueryVirtualMemory(NtCurrentProcess(), GetProcessHeap(), MemoryBasicInformation, &mbi, sizeof(MEMORY_BASIC_INFORMATION) - 1, &readcount);
      ok(status == STATUS_INFO_LENGTH_MISMATCH, "Expected STATUS_INFO_LENGTH_MISMATCH, got %08x\n", status);
 +
++    trace("Check section name of NTDLL.DLL with invalid size\n");
 +    module = GetModuleHandleA( "ntdll.dll" );
 +    memset(msn, 0, sizeof(*msn));
 +    readcount = 0;
@@ -33,6 +34,7 @@ index e5137ef5a45..e06a229e6cd 100644
 +    ok( status == STATUS_BUFFER_OVERFLOW, "Expected STATUS_BUFFER_OVERFLOW, got %08x\n", status);
 +    ok( readcount > 0, "Expected readcount to be > 0\n");
 +
++    trace("Check section name of NTDLL.DLL with invalid size\n");
 +    module = GetModuleHandleA( "ntdll.dll" );
 +    memset(msn, 0, sizeof(*msn));
 +    readcount = 0;
@@ -40,6 +42,7 @@ index e5137ef5a45..e06a229e6cd 100644
 +    ok( status == STATUS_INFO_LENGTH_MISMATCH, "Expected STATUS_INFO_LENGTH_MISMATCH, got %08x\n", status);
 +    ok( readcount > 0, "Expected readcount to be > 0\n");
 +
++    trace("Check section name of NTDLL.DLL\n");
 +    module = GetModuleHandleA( "ntdll.dll" );
 +    memset(msn, 0x55, sizeof(*msn));
 +    memset(buffer_name, 0x77, sizeof(buffer_name));
@@ -47,7 +50,9 @@ index e5137ef5a45..e06a229e6cd 100644
 +    status = pNtQueryVirtualMemory(NtCurrentProcess(), module, MemorySectionName, msn, sizeof(buffer_name), &readcount);
 +    ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
 +    ok( readcount > 0, "Expected readcount to be > 0\n");
++    trace ("Section Name: %s\n", wine_dbgstr_w(msn->SectionFileName.Buffer));
 +
++    trace("Check section name of non mapped memory\n");
 +    memset(msn, 0, sizeof(*msn));
 +    readcount = 0;
 +    status = pNtQueryVirtualMemory(NtCurrentProcess(), &buffer_name, MemorySectionName, msn, sizeof(buffer_name), &readcount);
@@ -57,5 +62,5 @@ index e5137ef5a45..e06a229e6cd 100644
  
  static void test_affinity(void)
 -- 
-2.27.0
+2.26.2
 
diff --git a/patches/ntdll-NtQueryVirtualMemory/0005-ntdll-tests-Add-test-to-ensure-section-name-is-full-.patch b/patches/ntdll-NtQueryVirtualMemory/0005-ntdll-tests-Add-test-to-ensure-section-name-is-full-.patch
index 1a7b9f1f..e66c6e88 100644
--- a/patches/ntdll-NtQueryVirtualMemory/0005-ntdll-tests-Add-test-to-ensure-section-name-is-full-.patch
+++ b/patches/ntdll-NtQueryVirtualMemory/0005-ntdll-tests-Add-test-to-ensure-section-name-is-full-.patch
@@ -1,4 +1,4 @@
-From 451efee77500173d36ddd16f39cf3ee2df498a93 Mon Sep 17 00:00:00 2001
+From 951b3002db9c9277a01d965da4d0996a328ec9db Mon Sep 17 00:00:00 2001
 From: Sebastian Lackner <sebastian@fds-team.de>
 Date: Sun, 28 May 2017 10:33:40 +0200
 Subject: [PATCH] ntdll/tests: Add test to ensure section name is full path.
@@ -8,7 +8,7 @@ Subject: [PATCH] ntdll/tests: Add test to ensure section name is full path.
  1 file changed, 9 insertions(+)
 
 diff --git a/dlls/ntdll/tests/info.c b/dlls/ntdll/tests/info.c
-index e06a229e6cd..02538e6f49a 100644
+index 766ca086c76..c953740d050 100644
 --- a/dlls/ntdll/tests/info.c
 +++ b/dlls/ntdll/tests/info.c
 @@ -22,6 +22,7 @@
@@ -19,15 +19,15 @@ index e06a229e6cd..02538e6f49a 100644
  static NTSTATUS (WINAPI * pNtQuerySystemInformation)(SYSTEM_INFORMATION_CLASS, PVOID, ULONG, PULONG);
  static NTSTATUS (WINAPI * pNtSetSystemInformation)(SYSTEM_INFORMATION_CLASS, PVOID, ULONG);
  static NTSTATUS (WINAPI * pRtlGetNativeSystemInformation)(SYSTEM_INFORMATION_CLASS, PVOID, ULONG, PULONG);
-@@ -70,6 +71,7 @@ static BOOL InitFunctionPtrs(void)
-     HMODULE hntdll = GetModuleHandleA("ntdll");
-     HMODULE hkernel32 = GetModuleHandleA("kernel32");
+@@ -76,6 +77,7 @@ static BOOL InitFunctionPtrs(void)
+         return FALSE;
+     }
  
 +    NTDLL_GET_PROC(RtlDowncaseUnicodeString);
      NTDLL_GET_PROC(NtQuerySystemInformation);
      NTDLL_GET_PROC(NtSetSystemInformation);
      NTDLL_GET_PROC(RtlGetNativeSystemInformation);
-@@ -2085,6 +2087,7 @@ static void test_queryvirtualmemory(void)
+@@ -2211,6 +2213,7 @@ static void test_queryvirtualmemory(void)
  {
      NTSTATUS status;
      SIZE_T readcount;
@@ -35,7 +35,7 @@ index e06a229e6cd..02538e6f49a 100644
      static const char teststring[] = "test string";
      static char datatestbuf[42] = "abc";
      static char rwtestbuf[42];
-@@ -2094,6 +2097,8 @@ static void test_queryvirtualmemory(void)
+@@ -2220,6 +2223,8 @@ static void test_queryvirtualmemory(void)
      void *user_shared_data = (void *)0x7ffe0000;
      char buffer_name[sizeof(MEMORY_SECTION_NAME) + MAX_PATH * sizeof(WCHAR)];
      MEMORY_SECTION_NAME *msn = (MEMORY_SECTION_NAME *)buffer_name;
@@ -43,18 +43,18 @@ index e06a229e6cd..02538e6f49a 100644
 +    int i;
  
      module = GetModuleHandleA( "ntdll.dll" );
-     status = pNtQueryVirtualMemory(NtCurrentProcess(), module, MemoryBasicInformation, &mbi, sizeof(MEMORY_BASIC_INFORMATION), &readcount);
-@@ -2198,6 +2203,10 @@ static void test_queryvirtualmemory(void)
-     status = pNtQueryVirtualMemory(NtCurrentProcess(), module, MemorySectionName, msn, sizeof(buffer_name), &readcount);
+     trace("Check flags of the PE header of NTDLL.DLL at %p\n", module);
+@@ -2337,6 +2342,10 @@ static void test_queryvirtualmemory(void)
      ok( status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08x\n", status);
      ok( readcount > 0, "Expected readcount to be > 0\n");
+     trace ("Section Name: %s\n", wine_dbgstr_w(msn->SectionFileName.Buffer));
 +    pRtlDowncaseUnicodeString( &msn->SectionFileName, &msn->SectionFileName, FALSE );
 +    for (found = FALSE, i = (msn->SectionFileName.Length - sizeof(windowsW)) / sizeof(WCHAR); i >= 0; i--)
 +        found |= !memcmp( &msn->SectionFileName.Buffer[i], windowsW, sizeof(windowsW) );
 +    ok( found, "Section name does not contain \"Windows\"\n");
  
+     trace("Check section name of non mapped memory\n");
      memset(msn, 0, sizeof(*msn));
-     readcount = 0;
 -- 
-2.27.0
+2.26.2
 
diff --git a/patches/ntdll-NtQueryVirtualMemory/0008-ntdll-Resolve-drive-symlinks-before-returning-sectio.patch b/patches/ntdll-NtQueryVirtualMemory/0008-ntdll-Resolve-drive-symlinks-before-returning-sectio.patch
index e66390a1..d66484ff 100644
--- a/patches/ntdll-NtQueryVirtualMemory/0008-ntdll-Resolve-drive-symlinks-before-returning-sectio.patch
+++ b/patches/ntdll-NtQueryVirtualMemory/0008-ntdll-Resolve-drive-symlinks-before-returning-sectio.patch
@@ -1,20 +1,20 @@
-From bb973ee8d79d0a1117c437afe8d62f34b9d9d3c8 Mon Sep 17 00:00:00 2001
+From 02ea4a27a1d6598e3d6a1ab5c2a25d5459e5390c Mon Sep 17 00:00:00 2001
 From: Sebastian Lackner <sebastian@fds-team.de>
 Date: Sun, 28 May 2017 11:17:26 +0200
 Subject: [PATCH] ntdll: Resolve drive symlinks before returning section name.
 
 ---
- dlls/ntdll/unix/file.c         |  2 +-
- dlls/ntdll/unix/unix_private.h |  1 +
- dlls/ntdll/unix/virtual.c      | 37 ++++++++++++++++++++++++++++------
- dlls/psapi/tests/psapi_main.c  |  6 +-----
+ dlls/ntdll/directory.c        |  2 +-
+ dlls/ntdll/ntdll_misc.h       |  1 +
+ dlls/ntdll/virtual.c          | 37 +++++++++++++++++++++++++++++------
+ dlls/psapi/tests/psapi_main.c |  6 +-----
  4 files changed, 34 insertions(+), 12 deletions(-)
 
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index 2ac7fcaae35..d39c98b2e49 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -3418,7 +3418,7 @@ NTSTATUS CDECL wine_nt_to_unix_file_name( const UNICODE_STRING *nameW, char *nam
+diff --git a/dlls/ntdll/directory.c b/dlls/ntdll/directory.c
+index 7a9de26ccb0..1062e35e009 100644
+--- a/dlls/ntdll/directory.c
++++ b/dlls/ntdll/directory.c
+@@ -2806,7 +2806,7 @@ static NTSTATUS nt_to_unix_file_name_internal( const UNICODE_STRING *nameW, ANSI
  }
  
  /* read the contents of an NT symlink object */
@@ -23,22 +23,22 @@ index 2ac7fcaae35..d39c98b2e49 100644
  {
      OBJECT_ATTRIBUTES attr;
      UNICODE_STRING targetW;
-diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
-index 466c59da75a..884dff1e1b1 100644
---- a/dlls/ntdll/unix/unix_private.h
-+++ b/dlls/ntdll/unix/unix_private.h
-@@ -103,6 +103,7 @@ extern void CDECL get_initial_directory( UNICODE_STRING *dir ) DECLSPEC_HIDDEN;
- extern void CDECL get_initial_console( HANDLE *handle, HANDLE *std_in, HANDLE *std_out, HANDLE *std_err ) DECLSPEC_HIDDEN;
- extern USHORT * CDECL get_unix_codepage_data(void) DECLSPEC_HIDDEN;
- extern void CDECL get_locales( WCHAR *sys, WCHAR *user ) DECLSPEC_HIDDEN;
+diff --git a/dlls/ntdll/ntdll_misc.h b/dlls/ntdll/ntdll_misc.h
+index b6507599a92..b7822c54ad0 100644
+--- a/dlls/ntdll/ntdll_misc.h
++++ b/dlls/ntdll/ntdll_misc.h
+@@ -182,6 +182,7 @@ extern NTSTATUS nt_to_unix_file_name_attr( const OBJECT_ATTRIBUTES *attr, ANSI_S
+ /* virtual memory */
+ extern NTSTATUS virtual_alloc( PVOID *ret, unsigned short zero_bits_64, SIZE_T *size_ptr,
+                                ULONG type, ULONG protect ) DECLSPEC_HIDDEN;
 +extern NTSTATUS read_nt_symlink( HANDLE root, UNICODE_STRING *name, WCHAR *target, size_t length ) DECLSPEC_HIDDEN;
- extern NTSTATUS CDECL virtual_map_section( HANDLE handle, PVOID *addr_ptr, unsigned short zero_bits_64, SIZE_T commit_size,
-                                            const LARGE_INTEGER *offset_ptr, SIZE_T *size_ptr, ULONG alloc_type,
-                                            ULONG protect, pe_image_info_t *image_info ) DECLSPEC_HIDDEN;
-diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
-index 570a8a3bf49..c040adfaf23 100644
---- a/dlls/ntdll/unix/virtual.c
-+++ b/dlls/ntdll/unix/virtual.c
+ extern NTSTATUS virtual_map_section( HANDLE handle, PVOID *addr_ptr, unsigned short zero_bits_64, SIZE_T commit_size,
+                                      const LARGE_INTEGER *offset_ptr, SIZE_T *size_ptr, ULONG alloc_type,
+                                      ULONG protect, pe_image_info_t *image_info ) DECLSPEC_HIDDEN;
+diff --git a/dlls/ntdll/virtual.c b/dlls/ntdll/virtual.c
+index fb9a1a57729..89ed3bb3f0b 100644
+--- a/dlls/ntdll/virtual.c
++++ b/dlls/ntdll/virtual.c
 @@ -188,6 +188,8 @@ static BYTE **pages_vprot;
  static BYTE *pages_vprot;
  #endif
@@ -46,17 +46,16 @@ index 570a8a3bf49..c040adfaf23 100644
 +#define MAX_DIR_ENTRY_LEN 255  /* max length of a directory entry in chars */
 +
  static struct file_view *view_block_start, *view_block_end, *next_free_view;
- #ifdef _WIN64
- static const size_t view_block_size = 0x200000;
-@@ -4018,13 +4020,16 @@ static NTSTATUS get_section_name( HANDLE process, LPCVOID addr,
+ static const size_t view_block_size = 0x100000;
+ static void *preload_reserve_start;
+@@ -3471,12 +3473,15 @@ static NTSTATUS get_section_name( HANDLE process, LPCVOID addr,
                                    MEMORY_SECTION_NAME *info,
                                    SIZE_T len, SIZE_T *res_len )
  {
 +    static const WCHAR dosprefixW[] = {'\\','?','?','\\'};
 +    WCHAR symlinkW[MAX_DIR_ENTRY_LEN] = {0};
      UNICODE_STRING nt_name;
-     WCHAR *nt_nameW;
-     char *unix_name;
+     ANSI_STRING unix_name;
      data_size_t size = 1024;
 -    WCHAR *name = NULL;
 +    WCHAR *ptr, *name = NULL;
@@ -66,7 +65,7 @@ index 570a8a3bf49..c040adfaf23 100644
  
      if (!addr || !info || !res_len) return STATUS_INVALID_PARAMETER;
  
-@@ -4087,14 +4092,34 @@ static NTSTATUS get_section_name( HANDLE process, LPCVOID addr,
+@@ -3777,14 +3782,34 @@ static NTSTATUS get_section_name( HANDLE process, LPCVOID addr,
      }
  
  found:
@@ -107,10 +106,10 @@ index 570a8a3bf49..c040adfaf23 100644
      else
          status = (len < sizeof(MEMORY_SECTION_NAME)) ? STATUS_INFO_LENGTH_MISMATCH : STATUS_BUFFER_OVERFLOW;
 diff --git a/dlls/psapi/tests/psapi_main.c b/dlls/psapi/tests/psapi_main.c
-index f6a7b69eca0..a8263a2f44b 100644
+index 99e87db9543..3984805d2b9 100644
 --- a/dlls/psapi/tests/psapi_main.c
 +++ b/dlls/psapi/tests/psapi_main.c
-@@ -476,7 +476,6 @@ static void test_GetMappedFileName(void)
+@@ -488,7 +488,6 @@ static void test_GetMappedFileName(void)
      ret = GetMappedFileNameA(GetCurrentProcess(), base, map_name, sizeof(map_name));
      ok(ret, "GetMappedFileName error %d\n", GetLastError());
      ok(ret > strlen(device_name), "map_name should be longer than device_name\n");
@@ -118,7 +117,7 @@ index f6a7b69eca0..a8263a2f44b 100644
      ok(memcmp(map_name, device_name, strlen(device_name)) == 0, "map name does not start with a device name: %s\n", map_name);
  
      SetLastError(0xdeadbeef);
-@@ -489,7 +488,6 @@ todo_wine {
+@@ -501,7 +500,6 @@ todo_wine {
      {
          ok(memcmp(map_nameW, nt_map_name, lstrlenW(map_nameW)) == 0, "map name does not start with a device name: %s\n", map_name);
          WideCharToMultiByte(CP_ACP, 0, map_nameW, -1, map_name, MAX_PATH, NULL, NULL);
@@ -126,7 +125,7 @@ index f6a7b69eca0..a8263a2f44b 100644
          ok(memcmp(map_name, device_name, strlen(device_name)) == 0, "map name does not start with a device name: %s\n", map_name);
      }
  
-@@ -502,7 +500,6 @@ todo_wine
+@@ -514,7 +512,6 @@ todo_wine
      {
          ok(memcmp(map_nameW, nt_map_name, lstrlenW(map_nameW)) == 0, "map name does not start with a device name: %s\n", map_name);
          WideCharToMultiByte(CP_ACP, 0, map_nameW, -1, map_name, MAX_PATH, NULL, NULL);
@@ -134,7 +133,7 @@ index f6a7b69eca0..a8263a2f44b 100644
          ok(memcmp(map_name, device_name, strlen(device_name)) == 0, "map name does not start with a device name: %s\n", map_name);
      }
  
-@@ -510,7 +507,6 @@ todo_wine
+@@ -522,7 +519,6 @@ todo_wine
      ret = GetMappedFileNameA(GetCurrentProcess(), base + 0x2000, map_name, sizeof(map_name));
      ok(ret, "GetMappedFileName error %d\n", GetLastError());
      ok(ret > strlen(device_name), "map_name should be longer than device_name\n");
@@ -142,7 +141,7 @@ index f6a7b69eca0..a8263a2f44b 100644
      ok(memcmp(map_name, device_name, strlen(device_name)) == 0, "map name does not start with a device name: %s\n", map_name);
  
      SetLastError(0xdeadbeef);
-@@ -592,7 +588,7 @@ static void test_GetProcessImageFileName(void)
+@@ -604,7 +600,7 @@ static void test_GetProcessImageFileName(void)
      {
          /* Windows returns 2*strlen-1 */
          ok(ret >= strlen(szImgPath), "szImgPath=\"%s\" ret=%d\n", szImgPath, ret);
@@ -152,5 +151,5 @@ index f6a7b69eca0..a8263a2f44b 100644
  
      SetLastError(0xdeadbeef);
 -- 
-2.27.0
+2.26.2
 
diff --git a/patches/ntdll-NtQueryVirtualMemory/definition b/patches/ntdll-NtQueryVirtualMemory/definition
index 2368120a..06825174 100644
--- a/patches/ntdll-NtQueryVirtualMemory/definition
+++ b/patches/ntdll-NtQueryVirtualMemory/definition
@@ -1,8 +1,3 @@
 Fixes: [23999] Implement MemorySectionName class in NtQueryVirtualMemory
 Fixes: [27248] Implement K32GetMappedFileName
 Depends: ntdll-NtDevicePath
-Depends: ntdll-ForceBottomUpAlloc
-Depends: ntdll-Junction_Points
-# This uses RtlDosPathNameToNtPathName_U (and RtlInitUnicodeString) from
-# ntdll.so, and needs to stop.
-Disabled: true
diff --git a/patches/ntdll-NtSetLdtEntries/0001-ntdll-Implement-NtSetLdtEntries.patch b/patches/ntdll-NtSetLdtEntries/0001-ntdll-Implement-NtSetLdtEntries.patch
index 8b4edd8c..2cb774ee 100644
--- a/patches/ntdll-NtSetLdtEntries/0001-ntdll-Implement-NtSetLdtEntries.patch
+++ b/patches/ntdll-NtSetLdtEntries/0001-ntdll-Implement-NtSetLdtEntries.patch
@@ -119,11 +119,11 @@ index a9869863b44..2c2a0fda843 100644
  #endif
     test_QueueUserWorkItem();
     test_RegisterWaitForSingleObject();
-diff --git a/dlls/ntdll/unix/signal_i386.c b/dlls/ntdll/unix/signal_i386.c
-index 320ffa68407..a52490a096b 100644
---- a/dlls/ntdll/unix/signal_i386.c
-+++ b/dlls/ntdll/unix/signal_i386.c
-@@ -480,7 +480,7 @@ NTSTATUS CDECL get_thread_ldt_entry( HANDLE handle, void *data, ULONG len, ULONG
+diff --git a/dlls/ntdll/signal_i386.c b/dlls/ntdll/signal_i386.c
+index 441ef579609..eb28d668279 100644
+--- a/dlls/ntdll/signal_i386.c
++++ b/dlls/ntdll/signal_i386.c
+@@ -2533,7 +2533,7 @@ NTSTATUS get_thread_ldt_entry( HANDLE handle, void *data, ULONG len, ULONG *ret_
                  if (reply->flags)
                      info->Entry = ldt_make_entry( (void *)reply->base, reply->limit, reply->flags );
                  else
diff --git a/patches/ntdll-NtSetLdtEntries/0002-libs-wine-Allow-to-modify-reserved-LDT-entries.patch b/patches/ntdll-NtSetLdtEntries/0002-libs-wine-Allow-to-modify-reserved-LDT-entries.patch
index 1be49d6d..230d065e 100644
--- a/patches/ntdll-NtSetLdtEntries/0002-libs-wine-Allow-to-modify-reserved-LDT-entries.patch
+++ b/patches/ntdll-NtSetLdtEntries/0002-libs-wine-Allow-to-modify-reserved-LDT-entries.patch
@@ -1,4 +1,4 @@
-From 13b77a54bad4d9b390d2e31f70d8f130eab48635 Mon Sep 17 00:00:00 2001
+From f4d2bffd85329aed25b1add735fafd4efa69e7e3 Mon Sep 17 00:00:00 2001
 From: Dmitry Timoshkov <dmitry@baikal.ru>
 Date: Thu, 28 Apr 2016 17:01:16 +0200
 Subject: [PATCH] libs/wine: Allow to modify reserved LDT entries.
@@ -22,7 +22,7 @@ fails.
  3 files changed, 1 insertion(+), 9 deletions(-)
 
 diff --git a/dlls/kernel32/tests/thread.c b/dlls/kernel32/tests/thread.c
-index a76d74cb698..881db6d6513 100644
+index 2c2a0fda843..dae3d8d97d7 100644
 --- a/dlls/kernel32/tests/thread.c
 +++ b/dlls/kernel32/tests/thread.c
 @@ -1341,16 +1341,12 @@ static void test_NtSetLdtEntries(void)
@@ -42,18 +42,18 @@ index a76d74cb698..881db6d6513 100644
          ok(!memcmp(&ds_entry, &sel.entry, sizeof(ds_entry)), "entries do not match\n");
      }
  }
-diff --git a/dlls/ntdll/unix/signal_i386.c b/dlls/ntdll/unix/signal_i386.c
-index 30f1aee4d62..0ab09c1b4df 100644
---- a/dlls/ntdll/unix/signal_i386.c
-+++ b/dlls/ntdll/unix/signal_i386.c
-@@ -2098,8 +2098,6 @@ NTSTATUS WINAPI NtSetLdtEntries( ULONG sel1, LDT_ENTRY entry1, ULONG sel2, LDT_E
+diff --git a/dlls/ntdll/signal_i386.c b/dlls/ntdll/signal_i386.c
+index 98ce76c8e27..e31c3d6b0b8 100644
+--- a/dlls/ntdll/signal_i386.c
++++ b/dlls/ntdll/signal_i386.c
+@@ -2534,8 +2534,6 @@ NTSTATUS WINAPI NtSetLdtEntries( ULONG sel1, LDT_ENTRY entry1, ULONG sel2, LDT_E
      sigset_t sigset;
  
      if (sel1 >> 16 || sel2 >> 16) return STATUS_INVALID_LDT_DESCRIPTOR;
 -    if (sel1 && (sel1 >> 3) < first_ldt_entry) return STATUS_INVALID_LDT_DESCRIPTOR;
 -    if (sel2 && (sel2 >> 3) < first_ldt_entry) return STATUS_INVALID_LDT_DESCRIPTOR;
  
-     server_enter_uninterrupted_section( &ldt_mutex, &sigset );
+     server_enter_uninterrupted_section( &ldt_section, &sigset );
      if (sel1) ldt_set_entry( sel1, entry1 );
 diff --git a/libs/wine/ldt.c b/libs/wine/ldt.c
 index 18b0b9be9bf..30d9b945f73 100644
@@ -78,5 +78,5 @@ index 18b0b9be9bf..30d9b945f73 100644
      return ret;
  }
 -- 
-2.27.0
+2.26.2
 
diff --git a/patches/ntdll-Pipe_SpecialCharacters/0001-ntdll-Allow-special-characters-in-pipe-names.patch b/patches/ntdll-Pipe_SpecialCharacters/0001-ntdll-Allow-special-characters-in-pipe-names.patch
index 192ec010..db8af3f4 100644
--- a/patches/ntdll-Pipe_SpecialCharacters/0001-ntdll-Allow-special-characters-in-pipe-names.patch
+++ b/patches/ntdll-Pipe_SpecialCharacters/0001-ntdll-Allow-special-characters-in-pipe-names.patch
@@ -1,4 +1,4 @@
-From 56459884534d5b0acb6a410d2ba04f6f3aa15ded Mon Sep 17 00:00:00 2001
+From fb9f83f9c1043dfff84c51f7223bee172c9ac40f Mon Sep 17 00:00:00 2001
 From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
 Date: Sun, 27 Jul 2014 03:35:42 +0200
 Subject: [PATCH] ntdll: Allow special characters in pipe names.
@@ -6,7 +6,7 @@ Subject: [PATCH] ntdll: Allow special characters in pipe names.
 Based on patch by Valentyn Pavliuchenko.
 ---
  dlls/kernel32/tests/pipe.c | 10 ++++++++++
- dlls/ntdll/unix/file.c     | 14 ++++++++++----
+ dlls/ntdll/directory.c     | 14 ++++++++++----
  2 files changed, 20 insertions(+), 4 deletions(-)
 
 diff --git a/dlls/kernel32/tests/pipe.c b/dlls/kernel32/tests/pipe.c
@@ -37,27 +37,27 @@ index 3c7ca06a045..453dcc80b7b 100644
      if (winetest_debug > 1) trace("test_CreateNamedPipe returning\n");
  }
  
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index a0ad361fcbb..3c4670e114c 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -3282,6 +3282,7 @@ static NTSTATUS nt_to_unix_file_name_attr( const OBJECT_ATTRIBUTES *attr, char *
- NTSTATUS nt_to_unix_file_name( const UNICODE_STRING *nameW, char **unix_name_ret, UINT disposition )
+diff --git a/dlls/ntdll/directory.c b/dlls/ntdll/directory.c
+index 993a661015e..aaf7c6eeed4 100644
+--- a/dlls/ntdll/directory.c
++++ b/dlls/ntdll/directory.c
+@@ -2747,6 +2747,7 @@ NTSTATUS CDECL wine_nt_to_unix_file_name( const UNICODE_STRING *nameW, ANSI_STRI
+                                           UINT disposition, BOOLEAN check_case )
  {
      static const WCHAR unixW[] = {'u','n','i','x'};
 +    static const WCHAR pipeW[] = {'p','i','p','e'};
      static const WCHAR invalid_charsW[] = { INVALID_NT_CHARS, 0 };
  
      NTSTATUS status = STATUS_SUCCESS;
-@@ -3292,6 +3293,7 @@ NTSTATUS nt_to_unix_file_name( const UNICODE_STRING *nameW, char **unix_name_ret
+@@ -2757,6 +2758,7 @@ NTSTATUS CDECL wine_nt_to_unix_file_name( const UNICODE_STRING *nameW, ANSI_STRI
+     int pos, ret, name_len, unix_len, prefix_len;
      WCHAR prefix[MAX_DIR_ENTRY_LEN + 1];
-     BOOLEAN check_case = FALSE;
      BOOLEAN is_unix = FALSE;
 +    BOOLEAN is_pipe = FALSE;
  
      name     = nameW->Buffer;
      name_len = nameW->Length / sizeof(WCHAR);
-@@ -3325,13 +3327,17 @@ NTSTATUS nt_to_unix_file_name( const UNICODE_STRING *nameW, char **unix_name_ret
+@@ -2792,13 +2794,17 @@ NTSTATUS CDECL wine_nt_to_unix_file_name( const UNICODE_STRING *nameW, ANSI_STRI
      name += prefix_len;
      name_len -= prefix_len;
  
@@ -80,5 +80,5 @@ index a0ad361fcbb..3c4670e114c 100644
      else
      {
 -- 
-2.27.0
+2.25.1
 
diff --git a/patches/ntdll-ProcessQuotaLimits/0001-ntdll-Add-fake-data-implementation-for-ProcessQuotaL.patch b/patches/ntdll-ProcessQuotaLimits/0001-ntdll-Add-fake-data-implementation-for-ProcessQuotaL.patch
index 529b3963..1a617f26 100644
--- a/patches/ntdll-ProcessQuotaLimits/0001-ntdll-Add-fake-data-implementation-for-ProcessQuotaL.patch
+++ b/patches/ntdll-ProcessQuotaLimits/0001-ntdll-Add-fake-data-implementation-for-ProcessQuotaL.patch
@@ -1,50 +1,49 @@
-From 8c7d326435794a72c70e05acdff945edf506ec3c Mon Sep 17 00:00:00 2001
+From c7ed817b9c0b4edf7969ec05f1f3e081a04155d9 Mon Sep 17 00:00:00 2001
 From: Qian Hong <qhong@codeweavers.com>
 Date: Wed, 21 Oct 2015 06:23:22 +0800
-Subject: [PATCH] ntdll: Add fake data implementation for ProcessQuotaLimits
- class.
+Subject: ntdll: Add fake data implementation for ProcessQuotaLimits class.
 
 ---
- dlls/ntdll/unix/process.c | 32 +++++++++++++++++++++++++++++++-
- 1 file changed, 31 insertions(+), 1 deletion(-)
+ dlls/ntdll/process.c | 31 ++++++++++++++++++++++++++++++-
+ 1 file changed, 30 insertions(+), 1 deletion(-)
 
-diff --git a/dlls/ntdll/unix/process.c b/dlls/ntdll/unix/process.c
-index 93d7e7b0140..ae3ab9a8058 100644
---- a/dlls/ntdll/unix/process.c
-+++ b/dlls/ntdll/unix/process.c
-@@ -1050,7 +1050,6 @@ NTSTATUS WINAPI NtQueryInformationProcess( HANDLE handle, PROCESSINFOCLASS class
+diff --git a/dlls/ntdll/process.c b/dlls/ntdll/process.c
+index 37c08f1..088834e 100644
+--- a/dlls/ntdll/process.c
++++ b/dlls/ntdll/process.c
+@@ -134,7 +134,6 @@ NTSTATUS WINAPI SYSCALL(NtQueryInformationProcess)(
  
-     switch (class)
+     switch (ProcessInformationClass) 
      {
 -    UNIMPLEMENTED_INFO_CLASS(ProcessQuotaLimits);
      UNIMPLEMENTED_INFO_CLASS(ProcessBasePriority);
      UNIMPLEMENTED_INFO_CLASS(ProcessRaisePriority);
      UNIMPLEMENTED_INFO_CLASS(ProcessExceptionPort);
-@@ -1109,6 +1108,37 @@ NTSTATUS WINAPI NtQueryInformationProcess( HANDLE handle, PROCESSINFOCLASS class
+@@ -199,6 +198,36 @@ NTSTATUS WINAPI SYSCALL(NtQueryInformationProcess)(
+             }
          }
          break;
- 
 +    case ProcessQuotaLimits:
 +        {
 +            QUOTA_LIMITS pqli;
 +
-+            if (size >= sizeof(QUOTA_LIMITS))
++            if (ProcessInformationLength >= sizeof(QUOTA_LIMITS))
 +            {
-+                if (!info)
++                if (!ProcessInformation)
 +                    ret = STATUS_ACCESS_VIOLATION;
-+                else if (!handle)
++                else if (!ProcessHandle)
 +                    ret = STATUS_INVALID_HANDLE;
 +                else
 +                {
 +                    /* FIXME : real data */
 +                    memset(&pqli, 0, sizeof(QUOTA_LIMITS));
 +
-+                    memcpy(info, &pqli, sizeof(QUOTA_LIMITS));
++                    memcpy(ProcessInformation, &pqli, sizeof(QUOTA_LIMITS));
 +
 +                    len = sizeof(QUOTA_LIMITS);
 +                }
 +
-+                if (size > sizeof(QUOTA_LIMITS))
++                if (ProcessInformationLength > sizeof(QUOTA_LIMITS))
 +                    ret = STATUS_INFO_LENGTH_MISMATCH;
 +            }
 +            else
@@ -54,10 +53,9 @@ index 93d7e7b0140..ae3ab9a8058 100644
 +            }
 +        }
 +        break;
-+
      case ProcessIoCounters:
          {
              IO_COUNTERS pii;
 -- 
-2.27.0
+2.6.1
 
diff --git a/patches/ntdll-RtlCreateUserThread/0001-ntdll-Refactor-RtlCreateUserThread-into-NtCreateThre.patch b/patches/ntdll-RtlCreateUserThread/0001-ntdll-Refactor-RtlCreateUserThread-into-NtCreateThre.patch
new file mode 100644
index 00000000..4fcc2cde
--- /dev/null
+++ b/patches/ntdll-RtlCreateUserThread/0001-ntdll-Refactor-RtlCreateUserThread-into-NtCreateThre.patch
@@ -0,0 +1,321 @@
+From 9fdc6855fed56b4b6baa0c5bd0f4633fec536c06 Mon Sep 17 00:00:00 2001
+From: Andrew Wesie <awesie@gmail.com>
+Date: Fri, 27 Jul 2018 01:22:59 -0500
+Subject: [PATCH] ntdll: Refactor RtlCreateUserThread into NtCreateThreadEx.
+
+League of Legends hooks NtCreateThread or NtCreateThreadEx (depending on the
+reported version), and expects it to be called whenever a thread is created.
+---
+ dlls/ntdll/ntdll.spec |   2 +-
+ dlls/ntdll/thread.c   | 196 ++++++++++++++++++++++++++++++++++--------
+ include/winternl.h    |  27 ++++++
+ 3 files changed, 188 insertions(+), 37 deletions(-)
+
+diff --git a/dlls/ntdll/ntdll.spec b/dlls/ntdll/ntdll.spec
+index 42532bd9f1c..65fdc30d7a4 100644
+--- a/dlls/ntdll/ntdll.spec
++++ b/dlls/ntdll/ntdll.spec
+@@ -182,7 +182,7 @@
+ @ stdcall NtCreateSection(ptr long ptr ptr long long long)
+ @ stdcall NtCreateSemaphore(ptr long ptr long long)
+ @ stdcall NtCreateSymbolicLinkObject(ptr long ptr ptr)
+-@ stub NtCreateThread
++@ stdcall NtCreateThread(ptr long ptr long ptr ptr ptr long)
+ @ stdcall NtCreateThreadEx(ptr long ptr long ptr ptr long long long long ptr)
+ @ stdcall NtCreateTimer(ptr long ptr long)
+ @ stub NtCreateToken
+diff --git a/dlls/ntdll/thread.c b/dlls/ntdll/thread.c
+index 20934448fa3..9deb4397ba9 100644
+--- a/dlls/ntdll/thread.c
++++ b/dlls/ntdll/thread.c
+@@ -390,34 +390,18 @@ static void start_thread( struct startup_info *info )
+ /***********************************************************************
+  *              NtCreateThreadEx   (NTDLL.@)
+  */
+-NTSTATUS WINAPI NtCreateThreadEx( HANDLE *handle_ptr, ACCESS_MASK access, OBJECT_ATTRIBUTES *attr,
++NTSTATUS WINAPI NtCreateThreadEx( HANDLE *handle_ptr, ACCESS_MASK access, OBJECT_ATTRIBUTES *thread_attr,
+                                   HANDLE process, LPTHREAD_START_ROUTINE start, void *param,
+                                   ULONG flags, ULONG zero_bits, ULONG stack_commit,
+-                                  ULONG stack_reserve, void *attribute_list )
+-{
+-    FIXME( "%p, %x, %p, %p, %p, %p, %x, %x, %x, %x, %p semi-stub!\n", handle_ptr, access, attr,
+-           process, start, param, flags, zero_bits, stack_commit, stack_reserve, attribute_list );
+-
+-    return RtlCreateUserThread( process, NULL, flags & THREAD_CREATE_FLAGS_CREATE_SUSPENDED,
+-                                NULL, stack_reserve, stack_commit, (PRTL_THREAD_START_ROUTINE)start,
+-                                param, handle_ptr, NULL );
+-}
+-
+-
+-/***********************************************************************
+- *              RtlCreateUserThread   (NTDLL.@)
+- */
+-NTSTATUS WINAPI RtlCreateUserThread( HANDLE process, SECURITY_DESCRIPTOR *descr,
+-                                     BOOLEAN suspended, PVOID stack_addr,
+-                                     SIZE_T stack_reserve, SIZE_T stack_commit,
+-                                     PRTL_THREAD_START_ROUTINE start, void *param,
+-                                     HANDLE *handle_ptr, CLIENT_ID *id )
++                                  ULONG stack_reserve, PPS_ATTRIBUTE_LIST ps_attr_list )
+ {
+     sigset_t sigset;
+     pthread_t pthread_id;
+-    pthread_attr_t attr;
++    pthread_attr_t pthread_attr;
+     struct ntdll_thread_data *thread_data;
+     struct startup_info *info;
++    BOOLEAN suspended = !!(flags & THREAD_CREATE_FLAGS_CREATE_SUSPENDED);
++    CLIENT_ID *id = NULL;
+     HANDLE handle = 0, actctx = 0;
+     TEB *teb = NULL;
+     DWORD tid = 0;
+@@ -444,6 +428,33 @@ NTSTATUS WINAPI RtlCreateUserThread( HANDLE process, SECURITY_DESCRIPTOR *descr,
+     struct object_attributes *objattr = NULL;
+     INITIAL_TEB stack;
+ 
++    TRACE("(%p, %d, %p, %p, %p, %p, %u, %u, %u, %u, %p)\n",
++          handle_ptr, access, thread_attr, process, start, param, flags,
++          zero_bits, stack_commit, stack_reserve, ps_attr_list);
++
++    if (ps_attr_list != NULL)
++    {
++        PS_ATTRIBUTE *ps_attr,
++                     *ps_attr_end = (PS_ATTRIBUTE *)((UINT_PTR)ps_attr_list + ps_attr_list->TotalLength);
++        for (ps_attr = &ps_attr_list->Attributes[0]; ps_attr < ps_attr_end; ps_attr++)
++        {
++            switch (ps_attr->Attribute)
++            {
++            case PS_ATTRIBUTE_CLIENT_ID:
++                /* TODO validate ps_attr->Size == sizeof(CLIENT_ID) */
++                /* TODO set *ps_attr->ReturnLength */
++                id = ps_attr->ValuePtr;
++                break;
++            default:
++                FIXME("Unsupported attribute %08X\n", ps_attr->Attribute);
++                break;
++            }
++        }
++    }
++
++    if (access == (ACCESS_MASK)0)
++        access = THREAD_ALL_ACCESS;
++
+     if (process != NtCurrentProcess())
+     {
+         apc_call_t call;
+@@ -469,12 +480,7 @@ NTSTATUS WINAPI RtlCreateUserThread( HANDLE process, SECURITY_DESCRIPTOR *descr,
+         return result.create_thread.status;
+     }
+ 
+-    if (descr)
+-    {
+-        OBJECT_ATTRIBUTES thread_attr;
+-        InitializeObjectAttributes( &thread_attr, NULL, 0, NULL, descr );
+-        if ((status = alloc_object_attributes( &thread_attr, &objattr, &len ))) return status;
+-    }
++    if ((status = alloc_object_attributes( thread_attr, &objattr, &len ))) return status;
+ 
+     if (server_pipe( request_pipe ) == -1)
+     {
+@@ -486,7 +492,7 @@ NTSTATUS WINAPI RtlCreateUserThread( HANDLE process, SECURITY_DESCRIPTOR *descr,
+     SERVER_START_REQ( new_thread )
+     {
+         req->process    = wine_server_obj_handle( process );
+-        req->access     = THREAD_ALL_ACCESS;
++        req->access     = access;
+         req->suspend    = suspended;
+         req->request_fd = request_pipe[0];
+         wine_server_add_data( req, objattr, len );
+@@ -547,20 +553,20 @@ NTSTATUS WINAPI RtlCreateUserThread( HANDLE process, SECURITY_DESCRIPTOR *descr,
+     thread_data->wait_fd[1]  = -1;
+     thread_data->start_stack = (char *)teb->Tib.StackBase;
+ 
+-    pthread_attr_init( &attr );
+-    pthread_attr_setstack( &attr, teb->DeallocationStack,
++    pthread_attr_init( &pthread_attr );
++    pthread_attr_setstack( &pthread_attr, teb->DeallocationStack,
+                          (char *)teb->Tib.StackBase + extra_stack - (char *)teb->DeallocationStack );
+-    pthread_attr_setguardsize( &attr, 0 );
+-    pthread_attr_setscope( &attr, PTHREAD_SCOPE_SYSTEM ); /* force creating a kernel thread */
++    pthread_attr_setguardsize( &pthread_attr, 0 );
++    pthread_attr_setscope( &pthread_attr, PTHREAD_SCOPE_SYSTEM ); /* force creating a kernel thread */
+     InterlockedIncrement( &nb_threads );
+-    if (pthread_create( &pthread_id, &attr, (void * (*)(void *))start_thread, info ))
++    if (pthread_create( &pthread_id, &pthread_attr, (void * (*)(void *))start_thread, info ))
+     {
+         InterlockedDecrement( &nb_threads );
+-        pthread_attr_destroy( &attr );
++        pthread_attr_destroy( &pthread_attr );
+         status = STATUS_NO_MEMORY;
+         goto error;
+     }
+-    pthread_attr_destroy( &attr );
++    pthread_attr_destroy( &pthread_attr );
+     pthread_sigmask( SIG_SETMASK, &sigset, NULL );
+ 
+     if (id) id->UniqueThread = ULongToHandle(tid);
+@@ -559,6 +565,124 @@ error:
+     return status;
+ }
+ 
++NTSTATUS WINAPI NtCreateThread( HANDLE *handle_ptr, ACCESS_MASK access, OBJECT_ATTRIBUTES *attr, HANDLE process,
++                                CLIENT_ID *id, CONTEXT *context, INITIAL_TEB *teb, BOOLEAN suspended )
++{
++    LPTHREAD_START_ROUTINE entry;
++    void *arg;
++    ULONG flags = suspended ? THREAD_CREATE_FLAGS_CREATE_SUSPENDED : 0;
++    PS_ATTRIBUTE_LIST attr_list, *pattr_list = NULL;
++
++#if defined(__i386__)
++        entry = (LPTHREAD_START_ROUTINE) context->Eax;
++        arg = (void *)context->Ebx;
++#elif defined(__x86_64__)
++        entry = (LPTHREAD_START_ROUTINE) context->Rcx;
++        arg = (void *)context->Rdx;
++#elif defined(__arm__)
++        entry = (LPTHREAD_START_ROUTINE) context->R0;
++        arg = (void *)context->R1;
++#elif defined(__aarch64__)
++        entry = (LPTHREAD_START_ROUTINE) context->u.X0;
++        arg = (void *)context->u.X1;
++#elif defined(__powerpc__)
++        entry = (LPTHREAD_START_ROUTINE) context->Gpr3;
++        arg = (void *)context->Gpr4;
++#endif
++
++    if (id)
++    {
++        attr_list.TotalLength = sizeof(PS_ATTRIBUTE_LIST);
++        attr_list.Attributes[0].Attribute = PS_ATTRIBUTE_CLIENT_ID;
++        attr_list.Attributes[0].Size = sizeof(CLIENT_ID);
++        attr_list.Attributes[0].ValuePtr = id;
++        attr_list.Attributes[0].ReturnLength = NULL;
++        pattr_list = &attr_list;
++    }
++
++    return NtCreateThreadEx(handle_ptr, access, attr, process, entry, arg, flags, 0, 0, 0, pattr_list);
++}
++
++NTSTATUS WINAPI __syscall_NtCreateThread( HANDLE *handle_ptr, ACCESS_MASK access, OBJECT_ATTRIBUTES *attr,
++                                          HANDLE process, CLIENT_ID *id, CONTEXT *context, INITIAL_TEB *teb,
++                                          BOOLEAN suspended );
++NTSTATUS WINAPI __syscall_NtCreateThreadEx( HANDLE *handle_ptr, ACCESS_MASK access, OBJECT_ATTRIBUTES *attr,
++                                            HANDLE process, LPTHREAD_START_ROUTINE start, void *param,
++                                            ULONG flags, ULONG zero_bits, ULONG stack_commit,
++                                            ULONG stack_reserve, PPS_ATTRIBUTE_LIST ps_attr_list );
++
++/***********************************************************************
++ *              RtlCreateUserThread   (NTDLL.@)
++ */
++NTSTATUS WINAPI RtlCreateUserThread( HANDLE process, SECURITY_DESCRIPTOR *descr,
++                                     BOOLEAN suspended, void *stack_addr,
++                                     SIZE_T stack_reserve, SIZE_T stack_commit,
++                                     PRTL_THREAD_START_ROUTINE entry, void *arg,
++                                     HANDLE *handle_ptr, CLIENT_ID *id )
++{
++    OBJECT_ATTRIBUTES thread_attr;
++    InitializeObjectAttributes( &thread_attr, NULL, 0, NULL, descr );
++    if (stack_addr)
++        FIXME("stack_addr != NULL is unimplemented\n");
++
++    if (NtCurrentTeb()->Peb->OSMajorVersion < 6)
++    {
++        /* Use old API. */
++        CONTEXT context = { 0 };
++
++        if (stack_commit)
++            FIXME("stack_commit != 0 is unimplemented\n");
++        if (stack_reserve)
++            FIXME("stack_reserve != 0 is unimplemented\n");
++
++        context.ContextFlags = CONTEXT_FULL;
++#if defined(__i386__)
++        context.Eax = (DWORD)entry;
++        context.Ebx = (DWORD)arg;
++#elif defined(__x86_64__)
++        context.Rcx = (ULONG_PTR)entry;
++        context.Rdx = (ULONG_PTR)arg;
++#elif defined(__arm__)
++        context.R0 = (DWORD)entry;
++        context.R1 = (DWORD)arg;
++#elif defined(__aarch64__)
++        context.u.X0 = (DWORD_PTR)entry;
++        context.u.X1 = (DWORD_PTR)arg;
++#elif defined(__powerpc__)
++        context.Gpr3 = (DWORD)entry;
++        context.Gpr4 = (DWORD)arg;
++#endif
++
++#if defined(__i386__) || defined(__x86_64__)
++        return __syscall_NtCreateThread(handle_ptr, (ACCESS_MASK)0, &thread_attr, process, id, &context, NULL, suspended);
++#else
++        return NtCreateThread(handle_ptr, (ACCESS_MASK)0, &thread_attr, process, id, &context, NULL, suspended);
++#endif
++    }
++    else
++    {
++        /* Use new API from Vista+. */
++        ULONG flags = suspended ? THREAD_CREATE_FLAGS_CREATE_SUSPENDED : 0;
++        PS_ATTRIBUTE_LIST attr_list, *pattr_list = NULL;
++
++        if (id)
++        {
++            attr_list.TotalLength = sizeof(PS_ATTRIBUTE_LIST);
++            attr_list.Attributes[0].Attribute = PS_ATTRIBUTE_CLIENT_ID;
++            attr_list.Attributes[0].Size = sizeof(CLIENT_ID);
++            attr_list.Attributes[0].ValuePtr = id;
++            attr_list.Attributes[0].ReturnLength = NULL;
++            pattr_list = &attr_list;
++        }
++
++#if defined(__i386__) || defined(__x86_64__)
++        return __syscall_NtCreateThreadEx(handle_ptr, (ACCESS_MASK)0, &thread_attr, process, (LPTHREAD_START_ROUTINE)entry, arg, flags, 0, stack_commit, stack_reserve, pattr_list);
++#else
++        return NtCreateThreadEx(handle_ptr, (ACCESS_MASK)0, &thread_attr, process, (LPTHREAD_START_ROUTINE)entry, arg, flags, 0, stack_commit, stack_reserve, pattr_list);
++#endif
++    }
++}
++
+ 
+ /******************************************************************************
+  *              RtlGetNtGlobalFlags   (NTDLL.@)
+diff --git a/include/winternl.h b/include/winternl.h
+index 199b8fc52f2..489b145937c 100644
+--- a/include/winternl.h
++++ b/include/winternl.h
+@@ -2274,6 +2274,33 @@ typedef struct _NLSTABLEINFO
+     USHORT     *LowerCaseTable;
+ } NLSTABLEINFO, *PNLSTABLEINFO;
+ 
++#define PS_ATTRIBUTE_THREAD  0x00010000
++#define PS_ATTRIBUTE_INPUT   0x00020000
++#define PS_ATTRIBUTE_UNKNOWN 0x00040000
++
++typedef enum _PS_ATTRIBUTE_NUM {
++    PsAttributeClientId = 3,
++} PS_ATTRIBUTE_NUM;
++
++#define PS_ATTRIBUTE_CLIENT_ID (PsAttributeClientId | PS_ATTRIBUTE_THREAD)
++
++typedef struct _PS_ATTRIBUTE {
++    ULONG Attribute;
++    SIZE_T Size;
++    union {
++        ULONG Value;
++        PVOID ValuePtr;
++    };
++    PSIZE_T ReturnLength;
++} PS_ATTRIBUTE;
++
++typedef struct _PS_ATTRIBUTE_LIST {
++    SIZE_T TotalLength;
++    PS_ATTRIBUTE Attributes[1];
++} PS_ATTRIBUTE_LIST, *PPS_ATTRIBUTE_LIST;
++
++
++
+ /*************************************************************************
+  * Loader structures
+  *
+-- 
+2.26.2
+
diff --git a/patches/ntdll-RtlCreateUserThread/definition b/patches/ntdll-RtlCreateUserThread/definition
new file mode 100644
index 00000000..f9fbdcf1
--- /dev/null
+++ b/patches/ntdll-RtlCreateUserThread/definition
@@ -0,0 +1,2 @@
+Fixes: [45571] League of Legends 8.12+ fails to start a game (anticheat engine, hooking of NtCreateThread/Ex)
+Depends: winebuild-Fake_Dlls
diff --git a/patches/ntdll-Status_Mapping/0001-ntdll-Return-STATUS_INVALID_DEVICE_REQUEST-when-tryi.patch b/patches/ntdll-Status_Mapping/0001-ntdll-Return-STATUS_INVALID_DEVICE_REQUEST-when-tryi.patch
index 141319d8..f310a2ac 100644
--- a/patches/ntdll-Status_Mapping/0001-ntdll-Return-STATUS_INVALID_DEVICE_REQUEST-when-tryi.patch
+++ b/patches/ntdll-Status_Mapping/0001-ntdll-Return-STATUS_INVALID_DEVICE_REQUEST-when-tryi.patch
@@ -1,19 +1,32 @@
-From fda39199958fc169372b7dfee2077e2d8ecfa350 Mon Sep 17 00:00:00 2001
+From 3e4e21b4e66f85143a029374c58a66ae54f792e8 Mon Sep 17 00:00:00 2001
 From: Sebastian Lackner <sebastian@fds-team.de>
 Date: Sun, 13 Sep 2015 17:16:07 +0200
-Subject: [PATCH] ntdll: Return STATUS_INVALID_DEVICE_REQUEST when trying to
- call NtReadFile on directory.
+Subject: ntdll: Return STATUS_INVALID_DEVICE_REQUEST when trying to call
+ NtReadFile on directory.
 
 ---
+ dlls/ntdll/file.c       | 2 +-
  dlls/ntdll/tests/file.c | 1 -
- dlls/ntdll/unix/file.c  | 2 +-
  2 files changed, 1 insertion(+), 2 deletions(-)
 
+diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
+index 8f89ba5..67a13b2 100644
+--- a/dlls/ntdll/file.c
++++ b/dlls/ntdll/file.c
+@@ -459,7 +459,7 @@ NTSTATUS FILE_GetNtStatus(void)
+     case EACCES:    return STATUS_ACCESS_DENIED;
+     case ENOTDIR:   return STATUS_OBJECT_PATH_NOT_FOUND;
+     case ENOENT:    return STATUS_OBJECT_NAME_NOT_FOUND;
+-    case EISDIR:    return STATUS_FILE_IS_A_DIRECTORY;
++    case EISDIR:    return STATUS_INVALID_DEVICE_REQUEST;
+     case EMFILE:
+     case ENFILE:    return STATUS_TOO_MANY_OPENED_FILES;
+     case EINVAL:    return STATUS_INVALID_PARAMETER;
 diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
-index 184b7cdad59..6f830da85a2 100644
+index b8f1847..63dd4f9 100644
 --- a/dlls/ntdll/tests/file.c
 +++ b/dlls/ntdll/tests/file.c
-@@ -171,7 +171,6 @@ static void create_file_test(void)
+@@ -206,7 +206,6 @@ static void create_file_test(void)
      U(io).Status = 0xdeadbeef;
      offset.QuadPart = 0;
      status = pNtReadFile( dir, NULL, NULL, NULL, &io, buf, sizeof(buf), &offset, NULL );
@@ -21,19 +34,6 @@ index 184b7cdad59..6f830da85a2 100644
      ok( status == STATUS_INVALID_DEVICE_REQUEST || status == STATUS_PENDING, "NtReadFile error %08x\n", status );
      if (status == STATUS_PENDING)
      {
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index ca6899b50f5..d160f1a050e 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -348,7 +348,7 @@ NTSTATUS errno_to_status( int err )
-     case EACCES:    return STATUS_ACCESS_DENIED;
-     case ENOTDIR:   return STATUS_OBJECT_PATH_NOT_FOUND;
-     case ENOENT:    return STATUS_OBJECT_NAME_NOT_FOUND;
--    case EISDIR:    return STATUS_FILE_IS_A_DIRECTORY;
-+    case EISDIR:    return STATUS_INVALID_DEVICE_REQUEST;
-     case EMFILE:
-     case ENFILE:    return STATUS_TOO_MANY_OPENED_FILES;
-     case EINVAL:    return STATUS_INVALID_PARAMETER;
 -- 
-2.27.0
+2.6.0
 
diff --git a/patches/ntdll-Syscall_Emulation/0001-ntdll-Support-x86_64-syscall-emulation.patch b/patches/ntdll-Syscall_Emulation/0001-ntdll-Support-x86_64-syscall-emulation.patch
index 6bfd62d7..812a54d8 100644
--- a/patches/ntdll-Syscall_Emulation/0001-ntdll-Support-x86_64-syscall-emulation.patch
+++ b/patches/ntdll-Syscall_Emulation/0001-ntdll-Support-x86_64-syscall-emulation.patch
@@ -1,19 +1,24 @@
-From b91699bc26a89683053a6157f343372d98da2a67 Mon Sep 17 00:00:00 2001
+From b18e90a92f2e44b5167016c90ea1d49f4d7e3211 Mon Sep 17 00:00:00 2001
 From: Paul Gofman <pgofman@codeweavers.com>
-Date: Tue, 14 Jul 2020 15:00:34 +0300
+Date: Mon, 30 Dec 2019 13:27:53 +0300
 Subject: [PATCH] ntdll: Support x86_64 syscall emulation.
 
+The patch assigns the range of syscall numbers which does not
+overlap with native syscalls and assumes these numbers are
+used in the applications (i. e., that the applications
+get the number from syscall thunks). Linux specific Seccomp
+is used for trapping syscalls.
 ---
- configure.ac                    |   1 +
- dlls/ntdll/unix/signal_x86_64.c | 119 ++++++++++++++++++++++++++++++++
- tools/winebuild/import.c        |   3 +-
- 3 files changed, 122 insertions(+), 1 deletion(-)
+ configure.ac               |   1 +
+ dlls/ntdll/signal_x86_64.c | 111 +++++++++++++++++++++++++++++++++++++
+ tools/winebuild/spec32.c   |   9 ++-
+ 3 files changed, 119 insertions(+), 2 deletions(-)
 
 diff --git a/configure.ac b/configure.ac
-index f147d3e845d..74a9119d691 100644
+index 7b7433efde4..e62daf9e384 100644
 --- a/configure.ac
 +++ b/configure.ac
-@@ -473,6 +473,7 @@ AC_CHECK_HEADERS(\
+@@ -474,6 +474,7 @@ AC_CHECK_HEADERS(\
  	linux/joystick.h \
  	linux/major.h \
  	linux/param.h \
@@ -21,19 +26,19 @@ index f147d3e845d..74a9119d691 100644
  	linux/serial.h \
  	linux/types.h \
  	linux/ucdrom.h \
-diff --git a/dlls/ntdll/unix/signal_x86_64.c b/dlls/ntdll/unix/signal_x86_64.c
-index a0d3594e6b8..f693fbe6b9f 100644
---- a/dlls/ntdll/unix/signal_x86_64.c
-+++ b/dlls/ntdll/unix/signal_x86_64.c
-@@ -28,6 +28,7 @@
+diff --git a/dlls/ntdll/signal_x86_64.c b/dlls/ntdll/signal_x86_64.c
+index 66a17b9bbc9..2424109553c 100644
+--- a/dlls/ntdll/signal_x86_64.c
++++ b/dlls/ntdll/signal_x86_64.c
+@@ -24,6 +24,7 @@
  #include "wine/port.h"
  
  #include <assert.h>
 +#include <errno.h>
- #include <pthread.h>
  #include <signal.h>
  #include <stdlib.h>
-@@ -64,6 +65,13 @@
+ #include <stdarg.h>
+@@ -59,6 +60,13 @@
  # include <mach/mach.h>
  #endif
  
@@ -47,27 +52,49 @@ index a0d3594e6b8..f693fbe6b9f 100644
  #define NONAMELESSUNION
  #define NONAMELESSSTRUCT
  #include "ntstatus.h"
-@@ -2157,6 +2165,116 @@ static inline DWORD is_privileged_instr( CONTEXT *context )
-     return 0;
+@@ -3096,6 +3104,38 @@ static void usr1_handler( int signal, siginfo_t *siginfo, void *ucontext )
+     restore_context( &context, ucontext );
  }
  
++extern unsigned int __wine_nb_syscalls;
++
 +#ifdef HAVE_SECCOMP
 +static void sigsys_handler( int signal, siginfo_t *siginfo, void *sigcontext )
 +{
++    unsigned int thunk_ret_offset;
 +    ucontext_t *ctx = sigcontext;
++    unsigned int syscall_nr;
 +    void ***rsp;
 +
-+    TRACE("SIGSYS, rax %#llx, rip %#llx.\n", ctx->uc_mcontext.gregs[REG_RAX],
-+            ctx->uc_mcontext.gregs[REG_RIP]);
++    WARN("SIGSYS, rax %#llx.\n", ctx->uc_mcontext.gregs[REG_RAX]);
++
++    syscall_nr = ctx->uc_mcontext.gregs[REG_RAX] - 0xf000;
++    if (syscall_nr >= __wine_nb_syscalls)
++    {
++        ERR("Syscall %u is undefined.\n", syscall_nr);
++        return;
++    }
 +
 +    rsp = (void ***)&ctx->uc_mcontext.gregs[REG_RSP];
 +    *rsp -= 1;
-+    **rsp = (void *)(ctx->uc_mcontext.gregs[REG_RIP] + 0xb);
 +
++#ifdef __APPLE__
++    thunk_ret_offset = 0xb;
++#else
++    thunk_ret_offset = 0xc;
++#endif
++
++    **rsp = (void *)(ctx->uc_mcontext.gregs[REG_RIP] + thunk_ret_offset);
 +    ctx->uc_mcontext.gregs[REG_RIP] = (ULONG64)__wine_syscall_dispatcher;
 +}
 +#endif
-+
+ 
+ /***********************************************************************
+  *           __wine_set_signal_handler   (NTDLL.@)
+@@ -3266,6 +3306,72 @@ void signal_init_thread( TEB *teb )
+ #endif
+ }
+ 
 +#ifdef HAVE_SECCOMP
 +static int sc_seccomp(unsigned int operation, unsigned int flags, void *args)
 +{
@@ -78,32 +105,6 @@ index a0d3594e6b8..f693fbe6b9f 100644
 +}
 +#endif
 +
-+static void check_bpf_jit_enable(void)
-+{
-+    char enabled;
-+    int fd;
-+
-+    fd = open("/proc/sys/net/core/bpf_jit_enable", O_RDONLY);
-+    if (fd == -1)
-+    {
-+        WARN("Could not open /proc/sys/net/core/bpf_jit_enable.\n");
-+        return;
-+    }
-+
-+    if (read(fd, &enabled, sizeof(enabled)) == sizeof(enabled))
-+    {
-+        TRACE("enabled %#x.\n", enabled);
-+
-+        if (enabled != '1')
-+            ERR("BPF JIT is not enabled in the kernel, enable it to reduce syscall emulation overhead.\n");
-+    }
-+    else
-+    {
-+        WARN("Could not read /proc/sys/net/core/bpf_jit_enable.\n");
-+    }
-+    close(fd);
-+}
-+
 +static void install_bpf(struct sigaction *sig_act)
 +{
 +#ifdef HAVE_SECCOMP
@@ -144,8 +145,6 @@ index a0d3594e6b8..f693fbe6b9f 100644
 +            perror("prctl(PR_SET_SECCOMP, ...)");
 +            exit(1);
 +        }
-+
-+        check_bpf_jit_enable();
 +    }
 +    else
 +    {
@@ -161,38 +160,61 @@ index a0d3594e6b8..f693fbe6b9f 100644
 +    WARN("Built without seccomp.\n");
 +#endif
 +}
- 
- /***********************************************************************
-  *           handle_interrupt
-@@ -2644,6 +2762,7 @@ void signal_init_process(void)
-     if (sigaction( SIGSEGV, &sig_act, NULL ) == -1) goto error;
-     if (sigaction( SIGILL, &sig_act, NULL ) == -1) goto error;
-     if (sigaction( SIGBUS, &sig_act, NULL ) == -1) goto error;
++
+ /**********************************************************************
+  *		signal_init_process
+  */
+@@ -3298,6 +3404,9 @@ void signal_init_process(void)
+     sig_act.sa_sigaction = trap_handler;
+     if (sigaction( SIGTRAP, &sig_act, NULL ) == -1) goto error;
+ #endif
++
 +    install_bpf(&sig_act);
++
      return;
  
   error:
-diff --git a/tools/winebuild/import.c b/tools/winebuild/import.c
-index b90d93ca5db..e750ae0ad3f 100644
---- a/tools/winebuild/import.c
-+++ b/tools/winebuild/import.c
-@@ -1524,6 +1524,7 @@ void output_syscalls( DLLSPEC *spec )
-             /* Legends of Runeterra hooks the first system call return instruction, and
-              * depends on us returning to it. Adjust the return address accordingly. */
-             output( "\tsubq $0xb,0x8(%%rbp)\n" );
-+            output( "\tsubq $0xf000,%%rax\n" );
-             output( "\tmovq %%rsp,0x328(%%rcx)\n" );  /* amd64_thread_data()->syscall_frame */
-             output( "\tcmpq $%u,%%rax\n", count );
-             output( "\tjae 4f\n" );
-@@ -1703,7 +1704,7 @@ void output_syscalls( DLLSPEC *spec )
-              * validate that instruction, we can just put a jmp there instead. */
-             output( "\t.byte 0x4c,0x8b,0xd1\n" ); /* movq %rcx,%r10 */
-             output( "\t.byte 0xb8\n" );           /* movl $i,%eax */
--            output( "\t.long %u\n", i );
-+            output( "\t.long %u\n", 0xf000 + i );
-             output( "\t.byte 0xf6,0x04,0x25,0x08,0x03,0xfe,0x7f,0x01\n" ); /* testb $1,0x7ffe0308 */
-             output( "\t.byte 0x75,0x03\n" );      /* jne 1f */
-             output( "\t.byte 0x0f,0x05\n" );      /* syscall */
+diff --git a/tools/winebuild/spec32.c b/tools/winebuild/spec32.c
+index 9cc4698d0d7..c572fe49923 100644
+--- a/tools/winebuild/spec32.c
++++ b/tools/winebuild/spec32.c
+@@ -531,7 +531,7 @@ static void output_syscall_thunks_x64( DLLSPEC *spec )
+         output_cfi( ".cfi_startproc" );
+         output( "\t.byte 0x4c,0x8b,0xd1\n" );                               /* mov r10, rcx */
+         output( "\t.byte 0xb8\n" );                                         /* mov eax, SYSCALL */
+-        output( "\t.long %d\n", i );
++        output( "\t.long %d\n", i + 0xf000 );
+         output( "\t.byte 0xf6,0x04,0x25,0x08,0x03,0xfe,0x7f,0x01\n" );      /* test byte ptr [0x7ffe0308], 1 */
+         output( "\t.byte 0x75,0x03\n" );                                    /* jne (over syscall) */
+         output( "\t.byte 0x0f,0x05\n" );                                    /* syscall */
+@@ -576,6 +576,9 @@ static void output_syscall_thunks_x64( DLLSPEC *spec )
+         output( "\t.byte %d\n", max(get_args_size(odp), 32) - 32 );
+     }
+ 
++    output( "%s\n", asm_globl("__wine_nb_syscalls") );
++    output( "\t.long %u\n", spec->nb_syscalls );
++
+     output( "\n/* syscall dispatcher */\n\n" );
+     output( "\t.text\n" );
+     output( "\t.align %d\n", get_alignment(16) );
+@@ -601,6 +604,8 @@ static void output_syscall_thunks_x64( DLLSPEC *spec )
+     else
+         output( "\tsubq $0xc,0x8(%%rbp)\n" );
+ 
++    output( "\tsub $0xf000,%%rax\n" );
++
+     /* copy over any arguments on the stack */
+     output( "\tleaq 0x38(%%rbp),%%rsi\n" );
+     if (UsePIC)
+@@ -1192,7 +1197,7 @@ static void create_stub_exports_text_x64( DLLSPEC *spec )
+         align_output_rva( 16, 16 );
+         put_label( odp->link_name );
+         put_byte( 0x4c ); put_byte( 0x8b ); put_byte( 0xd1 );  /* mov r10, rcx */
+-        put_byte( 0xb8 ); put_dword( i );                      /* mov eax, SYSCALL */
++        put_byte( 0xb8 ); put_dword( i + 0xf000 );             /* mov eax, SYSCALL */
+         put_byte( 0xf6 ); put_byte( 0x04 ); put_byte( 0x25 );  /* test byte ptr [0x7ffe0308], 1 */
+                 put_byte( 0x08 ); put_byte( 0x03 ); put_byte( 0xfe );
+                 put_byte( 0x7f ); put_byte( 0x01 );
 -- 
-2.28.0
+2.26.2
 
diff --git a/patches/ntdll-Syscall_Emulation/definition b/patches/ntdll-Syscall_Emulation/definition
index 4b0a9477..035c18c1 100644
--- a/patches/ntdll-Syscall_Emulation/definition
+++ b/patches/ntdll-Syscall_Emulation/definition
@@ -1,2 +1,2 @@
 Fixes: [48291] Detroit: Become Human crashes on launch
-Depends: winebuild-pe_syscall_thunks
+Depends: winebuild-Fake_Dlls
diff --git a/patches/ntdll-SystemCodeIntegrityInformation/0001-ntdll-NtQuerySystemInformation-support-SystemCodeInt.patch b/patches/ntdll-SystemCodeIntegrityInformation/0001-ntdll-NtQuerySystemInformation-support-SystemCodeInt.patch
index dfb34149..80c42839 100644
--- a/patches/ntdll-SystemCodeIntegrityInformation/0001-ntdll-NtQuerySystemInformation-support-SystemCodeInt.patch
+++ b/patches/ntdll-SystemCodeIntegrityInformation/0001-ntdll-NtQuerySystemInformation-support-SystemCodeInt.patch
@@ -1,4 +1,4 @@
-From cef4355bf086ab493401931ae635792bad1186f3 Mon Sep 17 00:00:00 2001
+From 7421907b2ecc21493308aa31478b6828f4341e29 Mon Sep 17 00:00:00 2001
 From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
 Date: Fri, 22 May 2020 16:37:37 +1000
 Subject: [PATCH] ntdll: NtQuerySystemInformation support
@@ -7,51 +7,50 @@ Subject: [PATCH] ntdll: NtQuerySystemInformation support
 Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49192
 Signed-off-by: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
 ---
- dlls/ntdll/unix/system.c | 22 ++++++++++++++++++++++
- include/winternl.h       | 22 ++++++++++++++++++++++
- 2 files changed, 44 insertions(+)
+ dlls/ntdll/nt.c    | 21 +++++++++++++++++++++
+ include/winternl.h | 22 ++++++++++++++++++++++
+ 2 files changed, 43 insertions(+)
 
-diff --git a/dlls/ntdll/unix/system.c b/dlls/ntdll/unix/system.c
-index 909a7c5672f..cf36faf2b78 100644
---- a/dlls/ntdll/unix/system.c
-+++ b/dlls/ntdll/unix/system.c
-@@ -2557,6 +2557,28 @@ NTSTATUS WINAPI NtQuerySystemInformation( SYSTEM_INFORMATION_CLASS class,
+diff --git a/dlls/ntdll/nt.c b/dlls/ntdll/nt.c
+index 1d31f80a5f55..99b0d8dc0921 100644
+--- a/dlls/ntdll/nt.c
++++ b/dlls/ntdll/nt.c
+@@ -3179,6 +3179,27 @@ NTSTATUS WINAPI NtQuerySystemInformation(
+         memset(SystemInformation, 0, Length);
          ret = STATUS_SUCCESS;
          break;
- 
 +    case SystemCodeIntegrityInformation:
 +    {
-+        SYSTEM_CODEINTEGRITY_INFORMATION *scii = info;
++        SYSTEM_CODEINTEGRITY_INFORMATION *info = (SYSTEM_CODEINTEGRITY_INFORMATION*)SystemInformation;
 +
-+        FIXME("SystemCodeIntegrityInformation, size %u, info %p, stub!\n", size, info);
++        FIXME("SystemCodeIntegrityInformation, len %u, buffer %p, stub!\n", Length, info);
 +
-+        if (size < sizeof(SYSTEM_CODEINTEGRITY_INFORMATION))
++        if (Length < sizeof(SYSTEM_CODEINTEGRITY_INFORMATION))
 +        {
 +            ret = STATUS_INFO_LENGTH_MISMATCH;
 +            break;
 +        }
 +
-+        if (!info)
++        if (!SystemInformation)
 +        {
 +            ret = STATUS_ACCESS_VIOLATION;
 +            break;
 +        }
 +
-+        scii->CodeIntegrityOptions = CODEINTEGRITY_OPTION_ENABLED;
++        info->CodeIntegrityOptions = CODEINTEGRITY_OPTION_ENABLED;
 +        break;
 +    }
-+
      default:
- 	FIXME( "(0x%08x,%p,0x%08x,%p) stub\n", class, info, size, ret_size );
- 
+ 	FIXME("(0x%08x,%p,0x%08x,%p) stub\n",
+ 	      SystemInformationClass,SystemInformation,Length,ResultLength);
 diff --git a/include/winternl.h b/include/winternl.h
-index 9226f000557..7e85ee02552 100644
+index 640dbe5db354..1ae249c59404 100644
 --- a/include/winternl.h
 +++ b/include/winternl.h
-@@ -988,10 +988,32 @@ typedef enum _SYSTEM_INFORMATION_CLASS {
+@@ -972,10 +972,32 @@ typedef enum _SYSTEM_INFORMATION_CLASS {
+     SystemSuperfetchInformation = 79,
      SystemMemoryListInformation = 80,
      SystemFileCacheInformationEx = 81,
-     SystemDynamicTimeZoneInformation = 102,
 +    SystemCodeIntegrityInformation = 103,
      SystemLogicalProcessorInformationEx = 107,
      SystemInformationClassMax
@@ -82,5 +81,5 @@ index 9226f000557..7e85ee02552 100644
      ThreadBasicInformation = 0,
      ThreadTimes,
 -- 
-2.27.0
+2.26.2
 
diff --git a/patches/ntdll-SystemExtendedProcessInformation/0001-ntdll-Add-stub-for-NtQuerySystemInformation-SystemEx.patch b/patches/ntdll-SystemExtendedProcessInformation/0001-ntdll-Add-stub-for-NtQuerySystemInformation-SystemEx.patch
index bdad3ffa..cdf3324b 100644
--- a/patches/ntdll-SystemExtendedProcessInformation/0001-ntdll-Add-stub-for-NtQuerySystemInformation-SystemEx.patch
+++ b/patches/ntdll-SystemExtendedProcessInformation/0001-ntdll-Add-stub-for-NtQuerySystemInformation-SystemEx.patch
@@ -1,30 +1,29 @@
-From a74718ea86178b8aa580d542bed872a313bdd546 Mon Sep 17 00:00:00 2001
+From 317b8941e2c36fd568799915c8023332b5054331 Mon Sep 17 00:00:00 2001
 From: Zebediah Figura <z.figura12@gmail.com>
 Date: Sat, 6 Apr 2019 21:31:55 -0500
 Subject: [PATCH] ntdll: Add stub for
  NtQuerySystemInformation(SystemExtendedProcessInformation).
 
 ---
- dlls/ntdll/unix/system.c | 6 ++++++
- 1 file changed, 6 insertions(+)
+ dlls/ntdll/nt.c | 5 +++++
+ 1 file changed, 5 insertions(+)
 
-diff --git a/dlls/ntdll/unix/system.c b/dlls/ntdll/unix/system.c
-index 68de16b7e5b..c5b2018bf30 100644
---- a/dlls/ntdll/unix/system.c
-+++ b/dlls/ntdll/unix/system.c
-@@ -2145,6 +2145,12 @@ NTSTATUS WINAPI NtQuerySystemInformation( SYSTEM_INFORMATION_CLASS class,
+diff --git a/dlls/ntdll/nt.c b/dlls/ntdll/nt.c
+index f42934969..c019a9c29 100644
+--- a/dlls/ntdll/nt.c
++++ b/dlls/ntdll/nt.c
+@@ -2768,6 +2768,11 @@ NTSTATUS WINAPI NtQuerySystemInformation(
+             }
+         }
          break;
-     }
- 
 +    case SystemExtendedProcessInformation:
-+        FIXME("SystemExtendedProcessInformation, size %u, info %p, stub!\n", size, info);
-+        memset( info, 0, size );
++        FIXME("SystemExtendedProcessInformation, len %u, buffer %p, stub!\n", Length, SystemInformation);
++        memset(SystemInformation, 0, Length);
 +        ret = STATUS_SUCCESS;
 +        break;
-+
      default:
- 	FIXME( "(0x%08x,%p,0x%08x,%p) stub\n", class, info, size, ret_size );
- 
+ 	FIXME("(0x%08x,%p,0x%08x,%p) stub\n",
+ 	      SystemInformationClass,SystemInformation,Length,ResultLength);
 -- 
-2.27.0
+2.20.1
 
diff --git a/patches/ntdll-SystemInterruptInformation/0001-ntdll-Return-buffer-filled-with-random-values-from-S.patch b/patches/ntdll-SystemInterruptInformation/0001-ntdll-Return-buffer-filled-with-random-values-from-S.patch
new file mode 100644
index 00000000..e49935a6
--- /dev/null
+++ b/patches/ntdll-SystemInterruptInformation/0001-ntdll-Return-buffer-filled-with-random-values-from-S.patch
@@ -0,0 +1,39 @@
+From e42cdb8305dcebca77afba4a56e59391f2cb4a38 Mon Sep 17 00:00:00 2001
+From: Sebastian Lackner <sebastian@fds-team.de>
+Date: Thu, 7 Jan 2016 06:01:01 +0100
+Subject: ntdll: Return buffer filled with random values from
+ SystemInterruptInformation.
+
+---
+ dlls/ntdll/nt.c | 11 +++++++++++
+ 1 file changed, 11 insertions(+)
+
+diff --git a/dlls/ntdll/nt.c b/dlls/ntdll/nt.c
+index 9ee1923..fe3e8e8 100644
+--- a/dlls/ntdll/nt.c
++++ b/dlls/ntdll/nt.c
+@@ -2070,10 +2070,21 @@ NTSTATUS WINAPI NtQuerySystemInformation(
+     case SystemInterruptInformation:
+         {
+             SYSTEM_INTERRUPT_INFORMATION sii;
++            int dev_random;
+ 
+             memset(&sii, 0, sizeof(sii));
+             len = sizeof(sii);
+ 
++            /* Some applications use the returned buffer for random number
++             * generation. Its unlikely that an app depends on the exact
++             * layout, so just fill with values from /dev/urandom. */
++            dev_random = open( "/dev/urandom", O_RDONLY );
++            if (dev_random != -1)
++            {
++                read( dev_random, &sii, sizeof(sii) );
++                close( dev_random );
++            }
++
+             if ( Length >= len)
+             {
+                 if (!SystemInformation) ret = STATUS_ACCESS_VIOLATION;
+-- 
+2.6.4
+
diff --git a/patches/ntdll-SystemInterruptInformation/definition b/patches/ntdll-SystemInterruptInformation/definition
new file mode 100644
index 00000000..cc876097
--- /dev/null
+++ b/patches/ntdll-SystemInterruptInformation/definition
@@ -0,0 +1 @@
+Fixes: [39123] Return buffer filled with random values from SystemInterruptInformation
diff --git a/patches/ntdll-SystemModuleInformation/0001-ntdll-Don-t-call-LdrQueryProcessModuleInformation-in.patch b/patches/ntdll-SystemModuleInformation/0001-ntdll-Don-t-call-LdrQueryProcessModuleInformation-in.patch
new file mode 100644
index 00000000..9e03568d
--- /dev/null
+++ b/patches/ntdll-SystemModuleInformation/0001-ntdll-Don-t-call-LdrQueryProcessModuleInformation-in.patch
@@ -0,0 +1,50 @@
+From ee3f09c31baedd50ab53179249b482eb51fcb0f3 Mon Sep 17 00:00:00 2001
+From: Zebediah Figura <z.figura12@gmail.com>
+Date: Mon, 6 Aug 2018 21:32:56 -0500
+Subject: [PATCH] ntdll: Don't call LdrQueryProcessModuleInformation in
+ NtQuerySystemInformation(SystemModuleInformation).
+
+Based on a patch by Andrew Wesie.
+
+This is simply incorrect; this function should only list kernel drivers.
+
+This makes the anticheat engine in League of Legends 8.15+ happy.
+
+Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45550
+---
+ dlls/ntdll/nt.c | 19 ++++++++++++++++---
+ 1 file changed, 16 insertions(+), 3 deletions(-)
+
+diff --git a/dlls/ntdll/nt.c b/dlls/ntdll/nt.c
+index af22e58..80d3ef8 100644
+--- a/dlls/ntdll/nt.c
++++ b/dlls/ntdll/nt.c
+@@ -2493,9 +2493,22 @@ NTSTATUS WINAPI NtQuerySystemInformation(
+         }
+         break;
+     case SystemModuleInformation:
+-        /* FIXME: should be system-wide */
+-        if (!SystemInformation) ret = STATUS_ACCESS_VIOLATION;
+-        else ret = LdrQueryProcessModuleInformation( SystemInformation, Length, &len );
++        if (!SystemInformation)
++            ret = STATUS_ACCESS_VIOLATION;
++        else if (Length < FIELD_OFFSET( SYSTEM_MODULE_INFORMATION, Modules[1] ))
++        {
++            len = FIELD_OFFSET( SYSTEM_MODULE_INFORMATION, Modules[1] );
++            ret = STATUS_INFO_LENGTH_MISMATCH;
++        }
++        else
++        {
++            SYSTEM_MODULE_INFORMATION *smi = SystemInformation;
++
++            FIXME("returning fake driver list\n");
++            smi->ModulesCount = 1;
++            memset(&smi->Modules[0], 0, sizeof(smi->Modules[0]));
++            ret = STATUS_SUCCESS;
++        }
+         break;
+     case SystemHandleInformation:
+         {
+-- 
+2.7.4
+
diff --git a/patches/ntdll-SystemModuleInformation/0002-ntdll-Return-ntdll.dll-as-the-first-entry-for-System.patch b/patches/ntdll-SystemModuleInformation/0002-ntdll-Return-ntdll.dll-as-the-first-entry-for-System.patch
new file mode 100644
index 00000000..dba4a4a4
--- /dev/null
+++ b/patches/ntdll-SystemModuleInformation/0002-ntdll-Return-ntdll.dll-as-the-first-entry-for-System.patch
@@ -0,0 +1,60 @@
+From 223c2c82eba0aacee744f6d9fcf9189cff2fd1e7 Mon Sep 17 00:00:00 2001
+From: Andrew Wesie <awesie@gmail.com>
+Date: Fri, 12 Apr 2019 20:04:03 -0500
+Subject: [PATCH] ntdll: Return ntdll.dll as the first entry for
+ SystemModuleInformation.
+
+---
+ dlls/ntdll/nt.c | 29 ++++++++++++++++++++++++++++-
+ 1 file changed, 28 insertions(+), 1 deletion(-)
+
+diff --git a/dlls/ntdll/nt.c b/dlls/ntdll/nt.c
+index f44c232f4e9..ebb8c94bd11 100644
+--- a/dlls/ntdll/nt.c
++++ b/dlls/ntdll/nt.c
+@@ -2546,6 +2546,33 @@ BOOLEAN WINAPI RtlIsProcessorFeaturePresent( UINT feature )
+     return feature < PROCESSOR_FEATURE_MAX && user_shared_data->ProcessorFeatures[feature];
+ }
+ 
++static void get_ntdll_system_module(SYSTEM_MODULE *sm)
++{
++    char *ptr;
++    ANSI_STRING str;
++    PLIST_ENTRY entry;
++    LDR_DATA_TABLE_ENTRY *mod;
++
++    /* The first entry must be ntdll. */
++    entry = NtCurrentTeb()->Peb->LdrData->InLoadOrderModuleList.Flink;
++    mod = CONTAINING_RECORD(entry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
++
++    sm->Section = 0;
++    sm->MappedBaseAddress = 0;
++    sm->ImageBaseAddress = mod->DllBase;
++    sm->ImageSize = mod->SizeOfImage;
++    sm->Flags = mod->Flags;
++    sm->LoadOrderIndex = 0;
++    sm->InitOrderIndex = 0;
++    sm->LoadCount = 0;
++    str.Length = 0;
++    str.MaximumLength = MAXIMUM_FILENAME_LENGTH;
++    str.Buffer = (char*)sm->Name;
++    RtlUnicodeStringToAnsiString(&str, &mod->FullDllName, FALSE);
++    ptr = strrchr(str.Buffer, '\\');
++    sm->NameOffset = (ptr != NULL) ? (ptr - str.Buffer + 1) : 0;
++}
++
+ /******************************************************************************
+  * NtQuerySystemInformation [NTDLL.@]
+  * ZwQuerySystemInformation [NTDLL.@]
+@@ -2882,7 +2909,7 @@ NTSTATUS WINAPI NtQuerySystemInformation(
+ 
+             FIXME("returning fake driver list\n");
+             smi->ModulesCount = 1;
+-            memset(&smi->Modules[0], 0, sizeof(smi->Modules[0]));
++            get_ntdll_system_module(&smi->Modules[0]);
+             ret = STATUS_SUCCESS;
+         }
+         break;
+-- 
+2.26.0
+
diff --git a/patches/ntdll-SystemModuleInformation/0003-ntdll-Add-stub-for-NtQuerySystemInformation-SystemMo.patch b/patches/ntdll-SystemModuleInformation/0003-ntdll-Add-stub-for-NtQuerySystemInformation-SystemMo.patch
index d844aafe..ce26ca0c 100644
--- a/patches/ntdll-SystemModuleInformation/0003-ntdll-Add-stub-for-NtQuerySystemInformation-SystemMo.patch
+++ b/patches/ntdll-SystemModuleInformation/0003-ntdll-Add-stub-for-NtQuerySystemInformation-SystemMo.patch
@@ -1,74 +1,53 @@
-From 6c3862d1e2d08c9a82623e0d4ab3bb123a3efde0 Mon Sep 17 00:00:00 2001
-From: Zebediah Figura <z.figura12@gmail.com>
+From dbe17b07a502aa2fc29f9e382adccf8bdc211824 Mon Sep 17 00:00:00 2001
+From: Andrew Wesie <awesie@gmail.com>
 Date: Fri, 12 Apr 2019 20:06:08 -0500
 Subject: [PATCH] ntdll: Add stub for
  NtQuerySystemInformation(SystemModuleInformationEx).
 
-Based on a patch by Andrew Wesie.
 ---
- dlls/ntdll/unix/system.c | 41 ++++++++++++++++++++++++++++++++++++++++
- include/winternl.h       |  9 +++++++++
- 2 files changed, 50 insertions(+)
+ dlls/ntdll/nt.c    | 21 +++++++++++++++++++++
+ include/winternl.h |  9 +++++++++
+ 2 files changed, 30 insertions(+)
 
-diff --git a/dlls/ntdll/unix/system.c b/dlls/ntdll/unix/system.c
-index c3dca7ffe28..1260326bc4b 100644
---- a/dlls/ntdll/unix/system.c
-+++ b/dlls/ntdll/unix/system.c
-@@ -2328,6 +2328,47 @@ NTSTATUS WINAPI NtQuerySystemInformation( SYSTEM_INFORMATION_CLASS class,
+diff --git a/dlls/ntdll/nt.c b/dlls/ntdll/nt.c
+index ea740ac81..77b64cac0 100644
+--- a/dlls/ntdll/nt.c
++++ b/dlls/ntdll/nt.c
+@@ -2622,6 +2622,27 @@ NTSTATUS WINAPI NtQuerySystemInformation(
+             ret = STATUS_SUCCESS;
+         }
          break;
-     }
- 
 +    case SystemModuleInformationEx:
-+    {
-+        /* FIXME: return some fake info for now */
-+        static const char *fake_modules[] =
++        if (!SystemInformation)
++            ret = STATUS_ACCESS_VIOLATION;
++        else if (Length < sizeof(SYSTEM_MODULE_INFORMATION_EX))
 +        {
-+            "\\SystemRoot\\system32\\ntoskrnl.exe",
-+            "\\SystemRoot\\system32\\hal.dll",
-+            "\\SystemRoot\\system32\\drivers\\mountmgr.sys"
-+        };
-+
-+        if (!info) ret = STATUS_ACCESS_VIOLATION;
++            len = sizeof(SYSTEM_MODULE_INFORMATION_EX);
++            ret = STATUS_INFO_LENGTH_MISMATCH;
++        }
 +        else
 +        {
-+            ULONG i;
++            SYSTEM_MODULE_INFORMATION_EX *info = SystemInformation;
 +
-+            for (i = 0; i < ARRAY_SIZE(fake_modules); i++)
-+            {
-+                SYSTEM_MODULE_INFORMATION_EX *smi = (SYSTEM_MODULE_INFORMATION_EX *)((char *)info + len);
-+
-+                len += sizeof(SYSTEM_MODULE_INFORMATION_EX);
-+                if (len > size)
-+                {
-+                    ret = STATUS_INFO_LENGTH_MISMATCH;
-+                    continue;
-+                }
-+
-+                memset(smi, 0, sizeof(*smi));
-+                if (i < ARRAY_SIZE(fake_modules) - 1)
-+                    smi->NextOffset = len;
-+                smi->BaseInfo.ImageBaseAddress = (char *)0x10000000 + 0x200000 * i;
-+                smi->BaseInfo.ImageSize = 0x200000;
-+                smi->BaseInfo.LoadOrderIndex = i;
-+                smi->BaseInfo.LoadCount = 1;
-+                strcpy( (char *)smi->BaseInfo.Name, fake_modules[i] );
-+                smi->BaseInfo.NameOffset = strrchr( fake_modules[i], '\\' ) - fake_modules[i] + 1;
-+                smi->DefaultBase = smi->BaseInfo.ImageBaseAddress;
-+            }
++            FIXME("info_class SystemModuleInformationEx stub!\n");
++            get_ntdll_system_module(&info->BaseInfo);
++            info->NextOffset = 0;
++            info->ImageCheckSum = 0;
++            info->TimeDateStamp = 0;
++            info->DefaultBase = info->BaseInfo.ImageBaseAddress;
++            ret = STATUS_SUCCESS;
 +        }
 +        break;
-+    }
-+
      case SystemHandleInformation:
-     {
-         struct handle_info *handle_info;
+         {
+             struct handle_info *info;
 diff --git a/include/winternl.h b/include/winternl.h
-index 10d109fede1..b91af1d2dbe 100644
+index 2b3fb947b..613f55701 100644
 --- a/include/winternl.h
 +++ b/include/winternl.h
-@@ -2484,6 +2484,15 @@ typedef struct _SYSTEM_MODULE_INFORMATION
- #define PROCESS_CREATE_FLAGS_SUSPENDED              0x00000200
- #define PROCESS_CREATE_FLAGS_EXTENDED_UNKNOWN       0x00000400
+@@ -2272,6 +2272,15 @@ typedef struct _SYSTEM_MODULE_INFORMATION
+     SYSTEM_MODULE       Modules[1]; /* FIXME: should be Modules[0] */
+ } SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;
  
 +typedef struct _SYSTEM_MODULE_INFORMATION_EX
 +{
@@ -83,5 +62,5 @@ index 10d109fede1..b91af1d2dbe 100644
  #define THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH      0x00000002
  #define THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER      0x00000004
 -- 
-2.27.0
+2.21.0
 
diff --git a/patches/ntdll-SystemRoot_Symlink/0001-ntdll-Add-special-handling-for-SystemRoot-to-satisfy.patch b/patches/ntdll-SystemRoot_Symlink/0001-ntdll-Add-special-handling-for-SystemRoot-to-satisfy.patch
new file mode 100644
index 00000000..96592617
--- /dev/null
+++ b/patches/ntdll-SystemRoot_Symlink/0001-ntdll-Add-special-handling-for-SystemRoot-to-satisfy.patch
@@ -0,0 +1,42 @@
+From e0b0ac874fbe3dcab53222f38831978f63177602 Mon Sep 17 00:00:00 2001
+From: Sebastian Lackner <sebastian@fds-team.de>
+Date: Mon, 17 Aug 2015 06:17:33 +0200
+Subject: ntdll: Add special handling for \SystemRoot to satisfy MSYS2
+ case-insensitive system check.
+
+---
+ dlls/ntdll/om.c | 11 +++++++++++
+ 1 file changed, 11 insertions(+)
+
+diff --git a/dlls/ntdll/om.c b/dlls/ntdll/om.c
+index 0d66867496b..f8f0760de70 100644
+--- a/dlls/ntdll/om.c
++++ b/dlls/ntdll/om.c
+@@ -602,6 +602,7 @@ NTSTATUS WINAPI NtQueryDirectoryObject(HANDLE handle, PDIRECTORY_BASIC_INFORMATI
+ NTSTATUS WINAPI NtOpenSymbolicLinkObject( HANDLE *handle, ACCESS_MASK access,
+                                           const OBJECT_ATTRIBUTES *attr)
+ {
++    static const WCHAR SystemRootW[] = {'\\','S','y','s','t','e','m','R','o','o','t'};
+     NTSTATUS ret;
+ 
+     TRACE("(%p,0x%08x,%s)\n", handle, access, debugstr_ObjectAttributes(attr));
+@@ -609,6 +610,16 @@ NTSTATUS WINAPI NtOpenSymbolicLinkObject( HANDLE *handle, ACCESS_MASK access,
+     if (!handle) return STATUS_ACCESS_VIOLATION;
+     if ((ret = validate_open_object_attributes( attr ))) return ret;
+ 
++    /* MSYS2 tries to open \\SYSTEMROOT to check for case-insensitive systems */
++    if (!access && !attr->RootDirectory &&
++        attr->ObjectName->Length == sizeof(SystemRootW) &&
++        !wcsnicmp( attr->ObjectName->Buffer, SystemRootW,
++                   sizeof(SystemRootW)/sizeof(WCHAR) ))
++    {
++        TRACE( "returning STATUS_ACCESS_DENIED\n" );
++        return STATUS_ACCESS_DENIED;
++    }
++
+     SERVER_START_REQ(open_symlink)
+     {
+         req->access     = access;
+-- 
+2.26.0
+
diff --git a/patches/ntdll-SystemRoot_Symlink/definition b/patches/ntdll-SystemRoot_Symlink/definition
new file mode 100644
index 00000000..6fdba87a
--- /dev/null
+++ b/patches/ntdll-SystemRoot_Symlink/definition
@@ -0,0 +1 @@
+Fixes: Fix detection of case-insensitive systems in MSYS2
diff --git a/patches/ntdll-ThreadTime/0001-ntdll-Return-correct-values-in-GetThreadTimes-for-al.patch b/patches/ntdll-ThreadTime/0001-ntdll-Return-correct-values-in-GetThreadTimes-for-al.patch
new file mode 100644
index 00000000..58a46b34
--- /dev/null
+++ b/patches/ntdll-ThreadTime/0001-ntdll-Return-correct-values-in-GetThreadTimes-for-al.patch
@@ -0,0 +1,163 @@
+From 4b31157383a5e422660c17d47fd4cda511a991a4 Mon Sep 17 00:00:00 2001
+From: Sebastian Lackner <sebastian@fds-team.de>
+Date: Fri, 7 Nov 2014 03:26:18 +0100
+Subject: [PATCH] ntdll: Return correct values in GetThreadTimes() for all
+ threads.
+
+Based on a patch by Ray Hinchliffe <ray@pobox.co.uk>.
+---
+ dlls/ntdll/thread.c | 82 ++++++++++++++++++++++++++++++++++++++++++-----------
+ server/protocol.def |  2 ++
+ server/thread.c     |  2 ++
+ 3 files changed, 69 insertions(+), 17 deletions(-)
+
+diff --git a/dlls/ntdll/thread.c b/dlls/ntdll/thread.c
+index c999d4b..1491ebb 100644
+--- a/dlls/ntdll/thread.c
++++ b/dlls/ntdll/thread.c
+@@ -23,6 +23,8 @@
+ 
+ #include <assert.h>
+ #include <stdarg.h>
++#include <string.h>
++#include <stdio.h>
+ #include <limits.h>
+ #include <sys/types.h>
+ #ifdef HAVE_SYS_MMAN_H
+@@ -1017,7 +1019,10 @@ NTSTATUS WINAPI NtQueryInformationThread( HANDLE handle, THREADINFOCLASS class,
+     case ThreadTimes:
+         {
+             KERNEL_USER_TIMES   kusrt;
++            int unix_pid, unix_tid;
+ 
++            /* We need to do a server call to get the creation time, exit time, PID and TID */
++            /* This works on any thread */
+             SERVER_START_REQ( get_thread_times )
+             {
+                 req->handle = wine_server_obj_handle( handle );
+@@ -1026,36 +1031,79 @@ NTSTATUS WINAPI NtQueryInformationThread( HANDLE handle, THREADINFOCLASS class,
+                 {
+                     kusrt.CreateTime.QuadPart = reply->creation_time;
+                     kusrt.ExitTime.QuadPart = reply->exit_time;
++                    unix_pid = reply->unix_pid;
++                    unix_tid = reply->unix_tid;
+                 }
+             }
+             SERVER_END_REQ;
+             if (status == STATUS_SUCCESS)
+             {
+-                /* We call times(2) for kernel time or user time */
+-                /* We can only (portably) do this for the current thread */
+-                if (handle == GetCurrentThread())
++                unsigned long clk_tck = sysconf(_SC_CLK_TCK);
++                BOOL filled_times = FALSE;
++
++#ifdef __linux__
++                /* only /proc provides exact values for a specific thread */
++                if (unix_pid != -1 && unix_tid != -1)
+                 {
+-                    struct tms time_buf;
+-                    long clocks_per_sec = sysconf(_SC_CLK_TCK);
++                    unsigned long usr, sys;
++                    char buf[512], *pos;
++                    FILE *fp;
++                    int i;
++
++                    /* based on https://github.com/torvalds/linux/blob/master/fs/proc/array.c */
++                    sprintf( buf, "/proc/%u/task/%u/stat", unix_pid, unix_tid );
++                    if ((fp = fopen( buf, "r" )))
++                    {
++                        pos = fgets( buf, sizeof(buf), fp );
++                        fclose( fp );
++
++                        /* format of first chunk is "%d (%s) %c" - we have to skip to the last ')'
++                         * to avoid misinterpreting the string. */
++                        if (pos) pos = strrchr( pos, ')' );
++                        if (pos) pos = strchr( pos + 1, ' ' );
++                        if (pos) pos++;
++
++                        /* skip over the following fields: state, ppid, pgid, sid, tty_nr, tty_pgrp,
++                         * task->flags, min_flt, cmin_flt, maj_flt, cmaj_flt */
++                        for (i = 0; (i < 11) && pos; i++)
++                        {
++                            pos = strchr( pos + 1, ' ' );
++                            if (pos) pos++;
++                        }
++
++                        /* the next two values are user and system time */
++                        if (pos && (sscanf( pos, "%lu %lu", &usr, &sys ) == 2))
++                        {
++                            kusrt.KernelTime.QuadPart = (ULONGLONG)sys * 10000000 / clk_tck;
++                            kusrt.UserTime.QuadPart   = (ULONGLONG)usr * 10000000 / clk_tck;
++                            filled_times = TRUE;
++                        }
++                    }
++                }
++#endif
+ 
++                /* get values for current process instead */
++                if (!filled_times && handle == GetCurrentThread())
++                {
++                    struct tms time_buf;
+                     times(&time_buf);
+-                    kusrt.KernelTime.QuadPart = (ULONGLONG)time_buf.tms_stime * 10000000 / clocks_per_sec;
+-                    kusrt.UserTime.QuadPart = (ULONGLONG)time_buf.tms_utime * 10000000 / clocks_per_sec;
++
++                    kusrt.KernelTime.QuadPart = (ULONGLONG)time_buf.tms_stime * 10000000 / clk_tck;
++                    kusrt.UserTime.QuadPart   = (ULONGLONG)time_buf.tms_utime * 10000000 / clk_tck;
++                    filled_times = TRUE;
+                 }
+-                else
++
++                /* unable to determine exact values, fill with zero */
++                if (!filled_times)
+                 {
+-                    static BOOL reported = FALSE;
++                    static int once;
++                    if (!once++)
++                        FIXME("Cannot get kerneltime or usertime of other threads\n");
+ 
+                     kusrt.KernelTime.QuadPart = 0;
+-                    kusrt.UserTime.QuadPart = 0;
+-                    if (reported)
+-                        TRACE("Cannot get kerneltime or usertime of other threads\n");
+-                    else
+-                    {
+-                        FIXME("Cannot get kerneltime or usertime of other threads\n");
+-                        reported = TRUE;
+-                    }
++                    kusrt.UserTime.QuadPart   = 0;
+                 }
++
+                 if (data) memcpy( data, &kusrt, min( length, sizeof(kusrt) ));
+                 if (ret_len) *ret_len = min( length, sizeof(kusrt) );
+             }
+diff --git a/server/protocol.def b/server/protocol.def
+index 3bed47a..031b490 100644
+--- a/server/protocol.def
++++ b/server/protocol.def
+@@ -908,6 +908,8 @@ struct rawinput_device
+ @REPLY
+     timeout_t    creation_time; /* thread creation time */
+     timeout_t    exit_time;     /* thread exit time */
++    int          unix_pid;      /* thread native pid */
++    int          unix_tid;      /* thread native pid */
+ @END
+ 
+ 
+diff --git a/server/thread.c b/server/thread.c
+index 2cf5054..46fc9a7 100644
+--- a/server/thread.c
++++ b/server/thread.c
+@@ -1413,6 +1413,8 @@ DECL_HANDLER(get_thread_times)
+     {
+         reply->creation_time  = thread->creation_time;
+         reply->exit_time      = thread->exit_time;
++        reply->unix_pid       = thread->unix_pid;
++        reply->unix_tid       = thread->unix_tid;
+ 
+         release_object( thread );
+     }
+-- 
+1.9.1
+
diff --git a/patches/ntdll-ThreadTime/0002-ntdll-Set-correct-thread-creation-time-for-SystemPro.patch b/patches/ntdll-ThreadTime/0002-ntdll-Set-correct-thread-creation-time-for-SystemPro.patch
new file mode 100644
index 00000000..f72185ec
--- /dev/null
+++ b/patches/ntdll-ThreadTime/0002-ntdll-Set-correct-thread-creation-time-for-SystemPro.patch
@@ -0,0 +1,74 @@
+From e6832d1b0f923e7589424ade7571cc67dc768c4d Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
+Date: Thu, 9 Mar 2017 00:00:46 +0100
+Subject: ntdll: Set correct thread creation time for SystemProcessInformation
+ in NtQuerySystemInformation.
+
+---
+ dlls/ntdll/nt.c     |  2 +-
+ server/protocol.def |  1 +
+ server/snapshot.c   | 11 ++++++-----
+ server/thread.h     |  1 +
+ 4 files changed, 9 insertions(+), 6 deletions(-)
+
+diff --git a/dlls/ntdll/nt.c b/dlls/ntdll/nt.c
+index 86beb031e9c..fc8e3b1eb4e 100644
+--- a/dlls/ntdll/nt.c
++++ b/dlls/ntdll/nt.c
+@@ -2012,7 +2012,7 @@ NTSTATUS WINAPI NtQuerySystemInformation(
+ 
+                                     memset(&spi->ti[i], 0, sizeof(spi->ti));
+ 
+-                                    spi->ti[i].CreateTime.QuadPart = 0xdeadbeef;
++                                    spi->ti[i].CreateTime.QuadPart = reply->creation_time;
+                                     spi->ti[i].ClientId.UniqueProcess = UlongToHandle(reply->pid);
+                                     spi->ti[i].ClientId.UniqueThread  = UlongToHandle(reply->tid);
+                                     spi->ti[i].dwCurrentPriority = reply->base_pri + reply->delta_pri;
+diff --git a/server/protocol.def b/server/protocol.def
+index 60865a6ffc2..15adc51462f 100644
+--- a/server/protocol.def
++++ b/server/protocol.def
+@@ -1783,6 +1783,7 @@ enum char_info_mode
+     int          count;         /* thread usage count */
+     process_id_t pid;           /* process id */
+     thread_id_t  tid;           /* thread id */
++    timeout_t    creation_time; /* thread creation time */
+     int          base_pri;      /* base priority */
+     int          delta_pri;     /* delta priority */
+ @END
+diff --git a/server/snapshot.c b/server/snapshot.c
+index e35588a136c..858fca898a7 100644
+--- a/server/snapshot.c
++++ b/server/snapshot.c
+@@ -144,11 +144,12 @@ static int snapshot_next_thread( struct snapshot *snapshot, struct next_thread_r
+         return 0;
+     }
+     ptr = &snapshot->threads[snapshot->thread_pos++];
+-    reply->count     = ptr->count;
+-    reply->pid       = get_process_id( ptr->thread->process );
+-    reply->tid       = get_thread_id( ptr->thread );
+-    reply->base_pri  = ptr->priority;
+-    reply->delta_pri = 0;  /* FIXME */
++    reply->count         = ptr->count;
++    reply->pid           = get_process_id( ptr->thread->process );
++    reply->tid           = get_thread_id( ptr->thread );
++    reply->creation_time = get_thread_creation_time( ptr->thread );
++    reply->base_pri      = ptr->priority;
++    reply->delta_pri     = 0;  /* FIXME */
+     return 1;
+ }
+ 
+diff --git a/server/thread.h b/server/thread.h
+index 282199149e6..2098c76a472 100644
+--- a/server/thread.h
++++ b/server/thread.h
+@@ -145,5 +145,6 @@ static inline void clear_error(void)             { set_error(0); }
+ static inline void set_win32_error( unsigned int err ) { set_error( 0xc0010000 | err ); }
+ 
+ static inline thread_id_t get_thread_id( struct thread *thread ) { return thread->id; }
++static inline timeout_t get_thread_creation_time( struct thread *thread ) { return thread->creation_time; }
+ 
+ #endif  /* __WINE_SERVER_THREAD_H */
+-- 
+2.11.0
+
diff --git a/patches/ntdll-ThreadTime/0003-ntdll-Fill-process-kernel-and-user-time.patch b/patches/ntdll-ThreadTime/0003-ntdll-Fill-process-kernel-and-user-time.patch
new file mode 100644
index 00000000..529f621e
--- /dev/null
+++ b/patches/ntdll-ThreadTime/0003-ntdll-Fill-process-kernel-and-user-time.patch
@@ -0,0 +1,162 @@
+From 2fb8a13c53a38377e8c64d202f91c2b5997669d7 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
+Date: Thu, 9 Mar 2017 16:27:23 +0100
+Subject: [PATCH] ntdll: Fill process kernel and user time.
+
+---
+ dlls/ntdll/nt.c         |  6 ++-
+ dlls/ntdll/ntdll_misc.h |  4 ++
+ dlls/ntdll/thread.c     | 84 +++++++++++++++++++++++------------------
+ 3 files changed, 57 insertions(+), 37 deletions(-)
+
+diff --git a/dlls/ntdll/nt.c b/dlls/ntdll/nt.c
+index 6f17225b983..bdd169fb335 100644
+--- a/dlls/ntdll/nt.c
++++ b/dlls/ntdll/nt.c
+@@ -2646,6 +2646,7 @@ NTSTATUS WINAPI NtQuerySystemInformation(
+         {
+             SYSTEM_PROCESS_INFORMATION* spi = SystemInformation;
+             SYSTEM_PROCESS_INFORMATION* last = NULL;
++            unsigned long clk_tck = sysconf(_SC_CLK_TCK);
+             HANDLE hSnap = 0;
+             WCHAR procname[1024];
+             WCHAR* exename;
+@@ -2683,7 +2684,7 @@ NTSTATUS WINAPI NtQuerySystemInformation(
+ 
+                         if (Length >= len + procstructlen)
+                         {
+-                            /* ftCreationTime, ftUserTime, ftKernelTime;
++                            /* ftCreationTime;
+                              * vmCounters, ioCounters
+                              */
+  
+@@ -2701,6 +2702,9 @@ NTSTATUS WINAPI NtQuerySystemInformation(
+ 
+                             /* spi->ti will be set later on */
+ 
++                            if (reply->unix_pid != -1)
++                                read_process_time(reply->unix_pid, -1, clk_tck,
++                                                  &spi->KernelTime, &spi->UserTime);
+                         }
+                         len += procstructlen;
+                     }
+diff --git a/dlls/ntdll/ntdll_misc.h b/dlls/ntdll/ntdll_misc.h
+index 27e7141bc65..f30cfa2e36b 100644
+--- a/dlls/ntdll/ntdll_misc.h
++++ b/dlls/ntdll/ntdll_misc.h
+@@ -301,6 +301,10 @@ void     WINAPI LdrInitializeThunk(CONTEXT*,void**,ULONG_PTR,ULONG_PTR);
+ #define InterlockedCompareExchange64(dest,xchg,cmp) RtlInterlockedCompareExchange64(dest,xchg,cmp)
+ #endif
+ 
++/* process / thread time */
++extern BOOL read_process_time(int unix_pid, int unix_tid, unsigned long clk_tck,
++                              LARGE_INTEGER *kernel, LARGE_INTEGER *user) DECLSPEC_HIDDEN;
++
+ /* string functions */
+ int    __cdecl NTDLL_tolower( int c );
+ int    __cdecl _stricmp( LPCSTR str1, LPCSTR str2 );
+diff --git a/dlls/ntdll/thread.c b/dlls/ntdll/thread.c
+index de355c51fdd..18f4f5533e2 100644
+--- a/dlls/ntdll/thread.c
++++ b/dlls/ntdll/thread.c
+@@ -154,6 +154,53 @@ static ULONG_PTR get_image_addr(void)
+ #endif
+ 
+ 
++
++BOOL read_process_time(int unix_pid, int unix_tid, unsigned long clk_tck,
++                       LARGE_INTEGER *kernel, LARGE_INTEGER *user)
++{
++#ifdef __linux__
++    unsigned long usr, sys;
++    char buf[512], *pos;
++    FILE *fp;
++    int i;
++
++    /* based on https://github.com/torvalds/linux/blob/master/fs/proc/array.c */
++    if (unix_tid != -1)
++        sprintf( buf, "/proc/%u/task/%u/stat", unix_pid, unix_tid );
++    else
++        sprintf( buf, "/proc/%u/stat", unix_pid );
++    if ((fp = fopen( buf, "r" )))
++    {
++        pos = fgets( buf, sizeof(buf), fp );
++        fclose( fp );
++
++        /* format of first chunk is "%d (%s) %c" - we have to skip to the last ')'
++         * to avoid misinterpreting the string. */
++        if (pos) pos = strrchr( pos, ')' );
++        if (pos) pos = strchr( pos + 1, ' ' );
++        if (pos) pos++;
++
++        /* skip over the following fields: state, ppid, pgid, sid, tty_nr, tty_pgrp,
++         * task->flags, min_flt, cmin_flt, maj_flt, cmaj_flt */
++        for (i = 0; (i < 11) && pos; i++)
++        {
++            pos = strchr( pos + 1, ' ' );
++            if (pos) pos++;
++        }
++
++        /* the next two values are user and system time */
++        if (pos && (sscanf( pos, "%lu %lu", &usr, &sys ) == 2))
++        {
++            kernel->QuadPart = (ULONGLONG)sys * 10000000 / clk_tck;
++            user->QuadPart   = (ULONGLONG)usr * 10000000 / clk_tck;
++            return TRUE;
++        }
++    }
++#endif
++    return FALSE;
++}
++
++
+ /***********************************************************************
+  *		__wine_dbg_get_channel_flags  (NTDLL.@)
+  *
+@@ -988,42 +1035,7 @@ NTSTATUS WINAPI NtQueryInformationThread( HANDLE handle, THREADINFOCLASS class,
+ #ifdef __linux__
+                 /* only /proc provides exact values for a specific thread */
+                 if (unix_pid != -1 && unix_tid != -1)
+-                {
+-                    unsigned long usr, sys;
+-                    char buf[512], *pos;
+-                    FILE *fp;
+-                    int i;
+-
+-                    /* based on https://github.com/torvalds/linux/blob/master/fs/proc/array.c */
+-                    sprintf( buf, "/proc/%u/task/%u/stat", unix_pid, unix_tid );
+-                    if ((fp = fopen( buf, "r" )))
+-                    {
+-                        pos = fgets( buf, sizeof(buf), fp );
+-                        fclose( fp );
+-
+-                        /* format of first chunk is "%d (%s) %c" - we have to skip to the last ')'
+-                         * to avoid misinterpreting the string. */
+-                        if (pos) pos = strrchr( pos, ')' );
+-                        if (pos) pos = strchr( pos + 1, ' ' );
+-                        if (pos) pos++;
+-
+-                        /* skip over the following fields: state, ppid, pgid, sid, tty_nr, tty_pgrp,
+-                         * task->flags, min_flt, cmin_flt, maj_flt, cmaj_flt */
+-                        for (i = 0; (i < 11) && pos; i++)
+-                        {
+-                            pos = strchr( pos + 1, ' ' );
+-                            if (pos) pos++;
+-                        }
+-
+-                        /* the next two values are user and system time */
+-                        if (pos && (sscanf( pos, "%lu %lu", &usr, &sys ) == 2))
+-                        {
+-                            kusrt.KernelTime.QuadPart = (ULONGLONG)sys * 10000000 / clk_tck;
+-                            kusrt.UserTime.QuadPart   = (ULONGLONG)usr * 10000000 / clk_tck;
+-                            filled_times = TRUE;
+-                        }
+-                    }
+-                }
++                    filled_times = read_process_time(unix_pid, unix_tid, clk_tck, &kusrt.KernelTime, &kusrt.UserTime);
+ #endif
+ 
+                 /* get values for current process instead */
+-- 
+2.26.2
+
diff --git a/patches/ntdll-ThreadTime/0004-ntdll-Set-process-start-time.patch b/patches/ntdll-ThreadTime/0004-ntdll-Set-process-start-time.patch
new file mode 100644
index 00000000..e905d254
--- /dev/null
+++ b/patches/ntdll-ThreadTime/0004-ntdll-Set-process-start-time.patch
@@ -0,0 +1,64 @@
+From e048ad0cd3879fb8f752af7e2eeda770864f9982 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
+Date: Thu, 9 Mar 2017 16:32:59 +0100
+Subject: ntdll: Set process start time.
+
+---
+ dlls/ntdll/nt.c     |  1 +
+ server/protocol.def |  1 +
+ server/snapshot.c   | 15 ++++++++-------
+ 3 files changed, 10 insertions(+), 7 deletions(-)
+
+diff --git a/dlls/ntdll/nt.c b/dlls/ntdll/nt.c
+index 03cfd032bc..45572cb393 100644
+--- a/dlls/ntdll/nt.c
++++ b/dlls/ntdll/nt.c
+@@ -2058,6 +2058,7 @@ NTSTATUS WINAPI NtQuerySystemInformation(
+                             spi->UniqueProcessId = UlongToHandle(reply->pid);
+                             spi->ParentProcessId = UlongToHandle(reply->ppid);
+                             spi->HandleCount = reply->handles;
++                            spi->CreationTime.QuadPart = reply->start_time;
+ 
+                             /* spi->ti will be set later on */
+ 
+diff --git a/server/protocol.def b/server/protocol.def
+index 320e34384a..1347defe70 100644
+--- a/server/protocol.def
++++ b/server/protocol.def
+@@ -1808,6 +1808,7 @@ enum char_info_mode
+     int          priority;      /* process priority */
+     int          handles;       /* number of handles */
+     int          unix_pid;      /* Unix pid */
++    timeout_t    start_time;    /* start time */
+     VARARG(filename,unicode_str); /* file name of main exe */
+ @END
+ 
+diff --git a/server/snapshot.c b/server/snapshot.c
+index f2903d522e..e509e0aca9 100644
+--- a/server/snapshot.c
++++ b/server/snapshot.c
+@@ -114,13 +114,14 @@ static int snapshot_next_process( struct snapshot *snapshot, struct next_process
+         return 0;
+     }
+     ptr = &snapshot->processes[snapshot->process_pos++];
+-    reply->count    = ptr->count;
+-    reply->pid      = get_process_id( ptr->process );
+-    reply->ppid     = ptr->process->parent_id;
+-    reply->threads  = ptr->threads;
+-    reply->priority = ptr->priority;
+-    reply->handles  = ptr->handles;
+-    reply->unix_pid = ptr->process->unix_pid;
++    reply->count      = ptr->count;
++    reply->pid        = get_process_id( ptr->process );
++    reply->ppid       = ptr->process->parent_id;
++    reply->threads    = ptr->threads;
++    reply->priority   = ptr->priority;
++    reply->handles    = ptr->handles;
++    reply->unix_pid   = ptr->process->unix_pid;
++    reply->start_time = ptr->process->start_time;
+     if ((exe_module = get_process_exe_module( ptr->process )) && exe_module->filename)
+     {
+         data_size_t len = min( exe_module->namelen, get_reply_max_size() );
+-- 
+2.11.0
+
diff --git a/patches/ntdll-ThreadTime/0005-ntdll-Fill-out-thread-times-in-process-enumeration.patch b/patches/ntdll-ThreadTime/0005-ntdll-Fill-out-thread-times-in-process-enumeration.patch
new file mode 100644
index 00000000..0c317b37
--- /dev/null
+++ b/patches/ntdll-ThreadTime/0005-ntdll-Fill-out-thread-times-in-process-enumeration.patch
@@ -0,0 +1,82 @@
+From 6c3b7e0065c239b488bb224c1c67ff971562fdca Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
+Date: Thu, 9 Mar 2017 21:14:13 +0100
+Subject: ntdll: Fill out thread times in process enumeration.
+
+---
+ dlls/ntdll/nt.c     | 6 ++++++
+ server/protocol.def | 1 +
+ server/snapshot.c   | 1 +
+ server/thread.h     | 1 +
+ 4 files changed, 9 insertions(+)
+
+diff --git a/dlls/ntdll/nt.c b/dlls/ntdll/nt.c
+index 8c54e7edfb..8b84cd865b 100644
+--- a/dlls/ntdll/nt.c
++++ b/dlls/ntdll/nt.c
+@@ -1928,6 +1928,7 @@ NTSTATUS WINAPI NtQuerySystemInformation(
+             WCHAR* exename;
+             DWORD wlen = 0;
+             DWORD procstructlen = 0;
++            int unix_pid = -1;
+ 
+             SERVER_START_REQ( create_snapshot )
+             {
+@@ -1982,6 +1983,7 @@ NTSTATUS WINAPI NtQuerySystemInformation(
+                             if (reply->unix_pid != -1)
+                                 read_process_time(reply->unix_pid, -1, clk_tck,
+                                                   &spi->KernelTime, &spi->UserTime);
++                            unix_pid = reply->unix_pid;
+                         }
+                         len += procstructlen;
+                     }
+@@ -2022,6 +2024,10 @@ NTSTATUS WINAPI NtQuerySystemInformation(
+                                     spi->ti[i].ClientId.UniqueThread  = UlongToHandle(reply->tid);
+                                     spi->ti[i].dwCurrentPriority = reply->base_pri + reply->delta_pri;
+                                     spi->ti[i].dwBasePriority = reply->base_pri;
++
++                                    if (unix_pid != -1 && reply->unix_tid != -1)
++                                        read_process_time(unix_pid, reply->unix_tid, clk_tck,
++                                                          &spi->ti[i].KernelTime, &spi->ti[i].UserTime);
+                                     i++;
+                                 }
+                             }
+diff --git a/server/protocol.def b/server/protocol.def
+index b0b837cb93..542060decd 100644
+--- a/server/protocol.def
++++ b/server/protocol.def
+@@ -1789,6 +1789,7 @@ enum char_info_mode
+     timeout_t    creation_time; /* thread creation time */
+     int          base_pri;      /* base priority */
+     int          delta_pri;     /* delta priority */
++    int          unix_tid;      /* Unix tid */
+ @END
+ 
+ 
+diff --git a/server/snapshot.c b/server/snapshot.c
+index cc8a9be1b5..a32207c720 100644
+--- a/server/snapshot.c
++++ b/server/snapshot.c
+@@ -151,6 +151,7 @@ static int snapshot_next_thread( struct snapshot *snapshot, struct next_thread_r
+     reply->creation_time = get_thread_creation_time( ptr->thread );
+     reply->base_pri      = ptr->priority;
+     reply->delta_pri     = 0;  /* FIXME */
++    reply->unix_tid      = get_thread_unix_tid( ptr->thread );
+     return 1;
+ }
+ 
+diff --git a/server/thread.h b/server/thread.h
+index 2098c76a47..9614e2140d 100644
+--- a/server/thread.h
++++ b/server/thread.h
+@@ -145,6 +145,7 @@ static inline void clear_error(void)             { set_error(0); }
+ static inline void set_win32_error( unsigned int err ) { set_error( 0xc0010000 | err ); }
+ 
+ static inline thread_id_t get_thread_id( struct thread *thread ) { return thread->id; }
++static inline int get_thread_unix_tid( struct thread *thread ) { return thread->unix_tid; }
+ static inline timeout_t get_thread_creation_time( struct thread *thread ) { return thread->creation_time; }
+ 
+ #endif  /* __WINE_SERVER_THREAD_H */
+-- 
+2.11.0
+
diff --git a/patches/ntdll-ThreadTime/0006-ntdll-Fill-process-virtual-memory-counters-in-NtQuer.patch b/patches/ntdll-ThreadTime/0006-ntdll-Fill-process-virtual-memory-counters-in-NtQuer.patch
new file mode 100644
index 00000000..36e0bad8
--- /dev/null
+++ b/patches/ntdll-ThreadTime/0006-ntdll-Fill-process-virtual-memory-counters-in-NtQuer.patch
@@ -0,0 +1,105 @@
+From e1ff2fee38b602ff500c35f1eb589162c0d166d1 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
+Date: Thu, 9 Mar 2017 22:56:45 +0100
+Subject: [PATCH] ntdll: Fill process virtual memory counters in
+ NtQuerySystemInformation.
+
+FIXME: fill_VM_COUNTERS now uses a different method ... which one is better?
+---
+ dlls/ntdll/nt.c         |  3 +++
+ dlls/ntdll/ntdll_misc.h |  1 +
+ dlls/ntdll/process.c    |  2 +-
+ dlls/ntdll/thread.c     | 36 ++++++++++++++++++++++++++++++++++++
+ 4 files changed, 41 insertions(+), 1 deletion(-)
+
+diff --git a/dlls/ntdll/nt.c b/dlls/ntdll/nt.c
+index a21a8bcceee..608525347ca 100644
+--- a/dlls/ntdll/nt.c
++++ b/dlls/ntdll/nt.c
+@@ -2703,8 +2703,11 @@ NTSTATUS WINAPI NtQuerySystemInformation(
+                             /* spi->ti will be set later on */
+ 
+                             if (reply->unix_pid != -1)
++                            {
+                                 read_process_time(reply->unix_pid, -1, clk_tck,
+                                                   &spi->KernelTime, &spi->UserTime);
++                                read_process_memory_stats(reply->unix_pid, &spi->vmCounters);
++                            }
+                             unix_pid = reply->unix_pid;
+                         }
+                         len += procstructlen;
+diff --git a/dlls/ntdll/ntdll_misc.h b/dlls/ntdll/ntdll_misc.h
+index b4e3c7d5c83..15f72631f55 100644
+--- a/dlls/ntdll/ntdll_misc.h
++++ b/dlls/ntdll/ntdll_misc.h
+@@ -297,6 +297,7 @@ void     WINAPI LdrInitializeThunk(CONTEXT*,void**,ULONG_PTR,ULONG_PTR);
+ /* process / thread time */
+ extern BOOL read_process_time(int unix_pid, int unix_tid, unsigned long clk_tck,
+                               LARGE_INTEGER *kernel, LARGE_INTEGER *user) DECLSPEC_HIDDEN;
++extern BOOL read_process_memory_stats(int unix_pid, VM_COUNTERS *pvmi) DECLSPEC_HIDDEN;
+ 
+ /* string functions */
+ int    __cdecl NTDLL_tolower( int c );
+diff --git a/dlls/ntdll/process.c b/dlls/ntdll/process.c
+index e59c255e327..71233f92853 100644
+--- a/dlls/ntdll/process.c
++++ b/dlls/ntdll/process.c
+@@ -186,7 +186,7 @@ static void fill_VM_COUNTERS(VM_COUNTERS* pvmi)
+ 
+ static void fill_VM_COUNTERS(VM_COUNTERS* pvmi)
+ {
+-    /* FIXME : real data */
++    read_process_memory_stats(getpid(), pvmi);
+ }
+ 
+ #endif
+diff --git a/dlls/ntdll/thread.c b/dlls/ntdll/thread.c
+index a2a999f8996..f5f932ae703 100644
+--- a/dlls/ntdll/thread.c
++++ b/dlls/ntdll/thread.c
+@@ -366,6 +366,42 @@ TEB *thread_init(void)
+     return teb;
+ }
+ 
++BOOL read_process_memory_stats(int unix_pid, VM_COUNTERS *pvmi)
++{
++    BOOL ret = FALSE;
++#ifdef __linux__
++    unsigned long size, resident, shared, trs, drs, lrs, dt;
++    char buf[512];
++    FILE *fp;
++
++    sprintf( buf, "/proc/%u/statm", unix_pid );
++    if ((fp = fopen( buf, "r" )))
++    {
++        if (fscanf( fp, "%lu %lu %lu %lu %lu %lu %lu",
++            &size, &resident, &shared, &trs, &drs, &lrs, &dt ) == 7)
++        {
++            pvmi->VirtualSize = size * page_size;
++            pvmi->WorkingSetSize = resident * page_size;
++            pvmi->PrivatePageCount = size - shared;
++
++            /* these values are not available through /proc/pid/statm */
++            pvmi->PeakVirtualSize = pvmi->VirtualSize;
++            pvmi->PageFaultCount = 0;
++            pvmi->PeakWorkingSetSize = pvmi->WorkingSetSize;
++            pvmi->QuotaPagedPoolUsage = pvmi->VirtualSize;
++            pvmi->QuotaPeakPagedPoolUsage = pvmi->QuotaPagedPoolUsage;
++            pvmi->QuotaPeakNonPagedPoolUsage = 0;
++            pvmi->QuotaNonPagedPoolUsage = 0;
++            pvmi->PagefileUsage = 0;
++            pvmi->PeakPagefileUsage = 0;
++
++            ret = TRUE;
++        }
++        fclose( fp );
++    }
++#endif
++    return ret;
++}
+ 
+ /***********************************************************************
+  *           abort_thread
+-- 
+2.26.2
+
diff --git a/patches/ntdll-ThreadTime/definition b/patches/ntdll-ThreadTime/definition
new file mode 100644
index 00000000..680df20a
--- /dev/null
+++ b/patches/ntdll-ThreadTime/definition
@@ -0,0 +1,3 @@
+Fixes: [20230] Return correct values for GetThreadTimes function
+Fixes: Return correct thread creation time in SystemProcessInformation
+Fixes: Fill process virtual memory counters in NtQuerySystemInformation
diff --git a/patches/ntdll-Thread_Stack/definition b/patches/ntdll-Thread_Stack/definition
index e2fe47ff..f4581714 100644
--- a/patches/ntdll-Thread_Stack/definition
+++ b/patches/ntdll-Thread_Stack/definition
@@ -1,3 +1,4 @@
 Fixes: Use a separate stack when starting new threads
 Fixes: Ignore invalid exit_frame when exiting thread
+Depends: ntdll-ThreadTime
 Disabled: true
diff --git a/patches/ntdll-Threading/0001-ntdll-Fix-race-condition-when-threads-are-killed-dur.patch b/patches/ntdll-Threading/0001-ntdll-Fix-race-condition-when-threads-are-killed-dur.patch
index e331c3dc..e463ba9e 100644
--- a/patches/ntdll-Threading/0001-ntdll-Fix-race-condition-when-threads-are-killed-dur.patch
+++ b/patches/ntdll-Threading/0001-ntdll-Fix-race-condition-when-threads-are-killed-dur.patch
@@ -1,4 +1,4 @@
-From 9da818bd948256572640e17766a14a72e58ce100 Mon Sep 17 00:00:00 2001
+From f8e12f51bebca8cda3be339bcc216ca8cc60a718 Mon Sep 17 00:00:00 2001
 From: Sebastian Lackner <sebastian@fds-team.de>
 Date: Wed, 25 Feb 2015 22:45:42 +0100
 Subject: [PATCH] ntdll: Fix race-condition when threads are killed during
@@ -15,15 +15,22 @@ only be executed safely when all other threads have terminated before. Most
 likely there are more Wine bugs in this area, but the attached patch should
 fix the most critical one (messed up refcounting of threads) for now.
 ---
- dlls/ntdll/thread.c      | 2 +-
- dlls/ntdll/unix/thread.c | 7 +++++++
- 2 files changed, 8 insertions(+), 1 deletion(-)
+ dlls/ntdll/thread.c | 8 +++++++-
+ 1 file changed, 7 insertions(+), 1 deletion(-)
 
 diff --git a/dlls/ntdll/thread.c b/dlls/ntdll/thread.c
-index d5e34cae3b1..83237b3569a 100644
+index b25f87e437..5fbd9e06c3 100644
 --- a/dlls/ntdll/thread.c
 +++ b/dlls/ntdll/thread.c
-@@ -295,7 +295,7 @@ void WINAPI RtlExitUserThread( ULONG status )
+@@ -336,6 +336,7 @@ void exit_thread( int status )
+ void WINAPI RtlExitUserThread( ULONG status )
+ {
+     static void *prev_teb;
++    sigset_t sigset;
+     TEB *teb;
+ 
+     if (status)  /* send the exit code to the server (0 is already the default) */
+@@ -349,7 +350,7 @@ void WINAPI RtlExitUserThread( ULONG status )
          SERVER_END_REQ;
      }
  
@@ -31,30 +38,17 @@ index d5e34cae3b1..83237b3569a 100644
 +    if (InterlockedCompareExchange( &nb_threads, 0, 0 ) <= 0)
      {
          LdrShutdownProcess();
-         unix_funcs->exit_process( status );
-diff --git a/dlls/ntdll/unix/thread.c b/dlls/ntdll/unix/thread.c
-index 205a1312e92..563712bd59e 100644
---- a/dlls/ntdll/unix/thread.c
-+++ b/dlls/ntdll/unix/thread.c
-@@ -219,6 +219,7 @@ void CDECL abort_thread( int status )
- void CDECL exit_thread( int status )
- {
-     static void *prev_teb;
-+    sigset_t sigset;
-     TEB *teb;
- 
-     pthread_sigmask( SIG_BLOCK, &server_block_set, NULL );
-@@ -233,6 +234,12 @@ void CDECL exit_thread( int status )
-             virtual_free_teb( teb );
+         pthread_sigmask( SIG_BLOCK, &server_block_set, NULL );
+@@ -372,6 +373,11 @@ void WINAPI RtlExitUserThread( ULONG status )
          }
      }
-+
+ 
 +    sigemptyset( &sigset );
 +    sigaddset( &sigset, SIGQUIT );
 +    pthread_sigmask( SIG_BLOCK, &sigset, NULL );
-+    if (!InterlockedDecrement( nb_threads )) _exit( status );
++    if (!InterlockedDecrement( &nb_threads )) _exit( status );
 +
-     signal_exit_thread( status, pthread_exit_wrapper );
+     signal_exit_thread( status );
  }
  
 -- 
diff --git a/patches/ntdll-Threading/definition b/patches/ntdll-Threading/definition
index 7e597913..d0e88f9b 100644
--- a/patches/ntdll-Threading/definition
+++ b/patches/ntdll-Threading/definition
@@ -1,3 +1 @@
 Fixes: Fix race-condition when threads are killed during shutdown
-# Needs careful review to determine if this is still needed. Deferring.
-Disabled: true
diff --git a/patches/ntdll-WRITECOPY/0001-ntdll-Trigger-write-watches-before-passing-userdata-.patch b/patches/ntdll-WRITECOPY/0001-ntdll-Trigger-write-watches-before-passing-userdata-.patch
index 703f6334..7768a185 100644
--- a/patches/ntdll-WRITECOPY/0001-ntdll-Trigger-write-watches-before-passing-userdata-.patch
+++ b/patches/ntdll-WRITECOPY/0001-ntdll-Trigger-write-watches-before-passing-userdata-.patch
@@ -1,4 +1,4 @@
-From 967a59e4a02f5aa9a607e52b3cbc91a0d268c064 Mon Sep 17 00:00:00 2001
+From 78a7689c0360fbf9ab6e494cc7113da5f73510fe Mon Sep 17 00:00:00 2001
 From: Sebastian Lackner <sebastian@fds-team.de>
 Date: Sat, 4 Oct 2014 02:35:44 +0200
 Subject: [PATCH] ntdll: Trigger write watches before passing userdata pointer
@@ -6,11 +6,11 @@ Subject: [PATCH] ntdll: Trigger write watches before passing userdata pointer
 
 ---
  dlls/advapi32/tests/security.c | 1 -
- dlls/ntdll/unix/server.c       | 8 ++++++++
- 2 files changed, 8 insertions(+), 1 deletion(-)
+ dlls/ntdll/server.c            | 9 +++++++++
+ 2 files changed, 9 insertions(+), 1 deletion(-)
 
 diff --git a/dlls/advapi32/tests/security.c b/dlls/advapi32/tests/security.c
-index ab572421a735..01f7a8783b18 100644
+index 825f8451904..b414401634a 100644
 --- a/dlls/advapi32/tests/security.c
 +++ b/dlls/advapi32/tests/security.c
 @@ -1557,7 +1557,6 @@ todo_wine
@@ -21,11 +21,11 @@ index ab572421a735..01f7a8783b18 100644
      ok(Access == 0x1abe11ed && AccessStatus == 0x1abe11ed,
         "Access and/or AccessStatus were changed!\n");
  
-diff --git a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
-index 452094ff5dc0..3c0d29a00624 100644
---- a/dlls/ntdll/unix/server.c
-+++ b/dlls/ntdll/unix/server.c
-@@ -282,9 +282,17 @@ unsigned int server_call_unlocked( void *req_ptr )
+diff --git a/dlls/ntdll/server.c b/dlls/ntdll/server.c
+index 046cf601ebf..3d88b47a744 100644
+--- a/dlls/ntdll/server.c
++++ b/dlls/ntdll/server.c
+@@ -406,9 +406,18 @@ unsigned int server_call_unlocked( void *req_ptr )
   */
  unsigned int CDECL wine_server_call( void *req_ptr )
  {
@@ -37,12 +37,13 @@ index 452094ff5dc0..3c0d29a00624 100644
 +    if (req->u.req.request_header.reply_size &&
 +        !virtual_check_buffer_for_write( req->reply_data, req->u.req.request_header.reply_size ))
 +    {
-+        return STATUS_ACCESS_VIOLATION;
++        ret = STATUS_ACCESS_VIOLATION;
++        return ret;
 +    }
 +
      pthread_sigmask( SIG_BLOCK, &server_block_set, &old_set );
      ret = server_call_unlocked( req_ptr );
      pthread_sigmask( SIG_SETMASK, &old_set, NULL );
 -- 
-2.20.1
+2.26.2
 
diff --git a/patches/ntdll-WRITECOPY/0003-ntdll-Setup-a-temporary-signal-handler-during-proces.patch b/patches/ntdll-WRITECOPY/0003-ntdll-Setup-a-temporary-signal-handler-during-proces.patch
index ac1cd6ab..30014d7f 100644
--- a/patches/ntdll-WRITECOPY/0003-ntdll-Setup-a-temporary-signal-handler-during-proces.patch
+++ b/patches/ntdll-WRITECOPY/0003-ntdll-Setup-a-temporary-signal-handler-during-proces.patch
@@ -1,37 +1,36 @@
-From a65d5445eea1a5aa1108d5b214a37b37a8c82888 Mon Sep 17 00:00:00 2001
+From 6fa954cc5fd6840c9207abf4f41e53be0dbf8728 Mon Sep 17 00:00:00 2001
 From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
 Date: Sat, 4 Oct 2014 02:53:22 +0200
 Subject: [PATCH] ntdll: Setup a temporary signal handler during process
  startup to handle page faults. (v2)
 
 ---
- dlls/ntdll/unix/loader.c        |  2 ++
- dlls/ntdll/unix/signal_arm.c    |  6 ++++
- dlls/ntdll/unix/signal_arm64.c  |  7 +++++
- dlls/ntdll/unix/signal_i386.c   | 52 +++++++++++++++++++++++++++++++++
- dlls/ntdll/unix/signal_x86_64.c |  6 ++++
- dlls/ntdll/unix/unix_private.h  |  1 +
- dlls/ntdll/unix/virtual.c       |  2 +-
- 7 files changed, 75 insertions(+), 1 deletion(-)
+ dlls/ntdll/ntdll_misc.h     |  1 +
+ dlls/ntdll/signal_arm.c     |  6 +++++
+ dlls/ntdll/signal_arm64.c   |  6 +++++
+ dlls/ntdll/signal_i386.c    | 53 +++++++++++++++++++++++++++++++++++++
+ dlls/ntdll/signal_powerpc.c |  6 +++++
+ dlls/ntdll/signal_x86_64.c  |  6 +++++
+ dlls/ntdll/thread.c         |  1 +
+ 7 files changed, 79 insertions(+)
 
-diff --git a/dlls/ntdll/unix/loader.c b/dlls/ntdll/unix/loader.c
-index 6890a08428b..557d7254190 100644
---- a/dlls/ntdll/unix/loader.c
-+++ b/dlls/ntdll/unix/loader.c
-@@ -1775,6 +1775,8 @@ void __wine_main( int argc, char *argv[], char *envp[] )
- #endif
- 
-     virtual_init();
-+    signal_init_early();
-+
-     init_environment( argc, argv, envp );
- 
- #ifdef __APPLE__
-diff --git a/dlls/ntdll/unix/signal_arm.c b/dlls/ntdll/unix/signal_arm.c
-index e8971d22dbd..ca291456284 100644
---- a/dlls/ntdll/unix/signal_arm.c
-+++ b/dlls/ntdll/unix/signal_arm.c
-@@ -977,6 +977,12 @@ void signal_init_process(void)
+diff --git a/dlls/ntdll/ntdll_misc.h b/dlls/ntdll/ntdll_misc.h
+index 58b688d06bd..f3ebfb72d32 100644
+--- a/dlls/ntdll/ntdll_misc.h
++++ b/dlls/ntdll/ntdll_misc.h
+@@ -84,6 +84,7 @@ extern NTSTATUS signal_alloc_thread( TEB *teb ) DECLSPEC_HIDDEN;
+ extern void signal_free_thread( TEB *teb ) DECLSPEC_HIDDEN;
+ extern void signal_init_thread( TEB *teb ) DECLSPEC_HIDDEN;
+ extern void signal_init_process(void) DECLSPEC_HIDDEN;
++extern void signal_init_early(void) DECLSPEC_HIDDEN;
+ extern void signal_start_thread( LPTHREAD_START_ROUTINE entry, void *arg, BOOL suspend ) DECLSPEC_HIDDEN;
+ extern void signal_start_process( LPTHREAD_START_ROUTINE entry, BOOL suspend ) DECLSPEC_HIDDEN;
+ extern void DECLSPEC_NORETURN signal_exit_thread( int status ) DECLSPEC_HIDDEN;
+diff --git a/dlls/ntdll/signal_arm.c b/dlls/ntdll/signal_arm.c
+index 31280edce47..f903eb93434 100644
+--- a/dlls/ntdll/signal_arm.c
++++ b/dlls/ntdll/signal_arm.c
+@@ -1031,6 +1031,12 @@ void signal_init_process(void)
      exit(1);
  }
  
@@ -43,13 +42,13 @@ index e8971d22dbd..ca291456284 100644
 +}
  
  /***********************************************************************
-  *           init_thread_context
-diff --git a/dlls/ntdll/unix/signal_arm64.c b/dlls/ntdll/unix/signal_arm64.c
-index e08d6a2ee17..025fa63316a 100644
---- a/dlls/ntdll/unix/signal_arm64.c
-+++ b/dlls/ntdll/unix/signal_arm64.c
-@@ -1070,6 +1070,13 @@ void signal_init_process(void)
-     exit(1);
+  *            RtlUnwind  (NTDLL.@)
+diff --git a/dlls/ntdll/signal_arm64.c b/dlls/ntdll/signal_arm64.c
+index 9f84d3fbfd1..8ab83a1d142 100644
+--- a/dlls/ntdll/signal_arm64.c
++++ b/dlls/ntdll/signal_arm64.c
+@@ -1293,6 +1293,12 @@ void signal_init_thread( TEB *teb )
+     pthread_setspecific( teb_key, teb );
  }
  
 +/**********************************************************************
@@ -58,15 +57,14 @@ index e08d6a2ee17..025fa63316a 100644
 +void signal_init_early(void)
 +{
 +}
-+
- /***********************************************************************
-  *           init_thread_context
-  */
-diff --git a/dlls/ntdll/unix/signal_i386.c b/dlls/ntdll/unix/signal_i386.c
-index e0ba27d3e94..dd9c8e255cc 100644
---- a/dlls/ntdll/unix/signal_i386.c
-+++ b/dlls/ntdll/unix/signal_i386.c
-@@ -1865,6 +1865,30 @@ static BOOL handle_syscall_fault( ucontext_t *sigcontext, void *stack_ptr,
+ 
+ /**********************************************************************
+  *		signal_init_process
+diff --git a/dlls/ntdll/signal_i386.c b/dlls/ntdll/signal_i386.c
+index 2f2db70b57f..12771552a5d 100644
+--- a/dlls/ntdll/signal_i386.c
++++ b/dlls/ntdll/signal_i386.c
+@@ -1988,6 +1988,31 @@ static BOOL handle_interrupt( unsigned int interrupt, ucontext_t *sigcontext, st
  }
  
  
@@ -78,17 +76,18 @@ index e0ba27d3e94..dd9c8e255cc 100644
 + */
 +static void segv_handler_early( int signal, siginfo_t *siginfo, void *sigcontext )
 +{
-+    ucontext_t *ucontext = sigcontext;
++    WORD fs, gs;
++    ucontext_t *context = sigcontext;
++    init_handler( sigcontext, &fs, &gs );
 +
-+    switch (TRAP_sig(ucontext))
++    switch(get_trap_code(context))
 +    {
 +    case TRAP_x86_PAGEFLT:  /* Page fault */
-+        if (!virtual_handle_fault( siginfo->si_addr, (ERROR_sig(ucontext) >> 1) & 0x09,
-+                NULL))
++        if (!virtual_handle_fault( siginfo->si_addr, (get_error_code(context) >> 1) & 0x09, TRUE ))
 +            return;
 +        /* fall-through */
 +    default:
-+        WINE_ERR( "Got unexpected trap %d during process initialization\n", TRAP_sig(ucontext) );
++        WINE_ERR( "Got unexpected trap %d during process initialization\n", get_trap_code(context) );
 +        abort_thread(1);
 +        break;
 +    }
@@ -97,7 +96,7 @@ index e0ba27d3e94..dd9c8e255cc 100644
  /**********************************************************************
   *		segv_handler
   *
-@@ -2424,6 +2448,34 @@ void signal_init_process(void)
+@@ -2315,6 +2340,34 @@ void signal_init_process(void)
      exit(1);
  }
  
@@ -130,13 +129,30 @@ index e0ba27d3e94..dd9c8e255cc 100644
 +    exit(1);
 +}
  
- /***********************************************************************
-  *           init_thread_context
-diff --git a/dlls/ntdll/unix/signal_x86_64.c b/dlls/ntdll/unix/signal_x86_64.c
-index e11b2c70b59..1b45ca246d3 100644
---- a/dlls/ntdll/unix/signal_x86_64.c
-+++ b/dlls/ntdll/unix/signal_x86_64.c
-@@ -2680,6 +2680,12 @@ void signal_init_process(void)
+ /*******************************************************************
+  *		RtlUnwind (NTDLL.@)
+diff --git a/dlls/ntdll/signal_powerpc.c b/dlls/ntdll/signal_powerpc.c
+index 9df6eff31f4..e79fca3abce 100644
+--- a/dlls/ntdll/signal_powerpc.c
++++ b/dlls/ntdll/signal_powerpc.c
+@@ -1047,6 +1047,12 @@ void signal_init_thread( TEB *teb )
+     pthread_setspecific( teb_key, teb );
+ }
+ 
++/**********************************************************************
++ *    signal_init_early
++ */
++void signal_init_early(void)
++{
++}
+ 
+ /**********************************************************************
+  *		signal_init_process
+diff --git a/dlls/ntdll/signal_x86_64.c b/dlls/ntdll/signal_x86_64.c
+index d42438f88af..b4c11ed66ed 100644
+--- a/dlls/ntdll/signal_x86_64.c
++++ b/dlls/ntdll/signal_x86_64.c
+@@ -3141,6 +3141,12 @@ void signal_init_process(void)
      exit(1);
  }
  
@@ -147,33 +163,20 @@ index e11b2c70b59..1b45ca246d3 100644
 +{
 +}
  
- /***********************************************************************
-  *           init_thread_context
-diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
-index f99c13fe2ad..26f251b889a 100644
---- a/dlls/ntdll/unix/unix_private.h
-+++ b/dlls/ntdll/unix/unix_private.h
-@@ -210,6 +210,7 @@ extern NTSTATUS signal_alloc_thread( TEB *teb ) DECLSPEC_HIDDEN;
- extern void signal_free_thread( TEB *teb ) DECLSPEC_HIDDEN;
- extern void signal_init_thread( TEB *teb ) DECLSPEC_HIDDEN;
- extern void signal_init_process(void) DECLSPEC_HIDDEN;
-+extern void signal_init_early(void) DECLSPEC_HIDDEN;
- extern void DECLSPEC_NORETURN signal_start_thread( PRTL_THREAD_START_ROUTINE entry, void *arg,
-                                                    BOOL suspend, void *thunk, TEB *teb ) DECLSPEC_HIDDEN;
- extern void DECLSPEC_NORETURN signal_exit_thread( int status, void (*func)(int) ) DECLSPEC_HIDDEN;
-diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
-index f18e75c0842..0649b30e8b3 100644
---- a/dlls/ntdll/unix/virtual.c
-+++ b/dlls/ntdll/unix/virtual.c
-@@ -2917,7 +2917,7 @@ NTSTATUS virtual_handle_fault( void *addr, DWORD err, void *stack )
+ static ULONG64 get_int_reg( CONTEXT *context, int reg )
+ {
+diff --git a/dlls/ntdll/thread.c b/dlls/ntdll/thread.c
+index bb11521cf69..ff18b119232 100644
+--- a/dlls/ntdll/thread.c
++++ b/dlls/ntdll/thread.c
+@@ -228,6 +228,7 @@ TEB *thread_init(void)
+     struct ntdll_thread_data *thread_data;
+ 
+     virtual_init();
++    signal_init_early();
+ 
+     /* reserve space for shared user data */
  
-     mutex_lock( &virtual_mutex );  /* no need for signal masking inside signal handler */
-     vprot = get_page_vprot( page );
--    if (!is_inside_signal_stack( stack ) && (vprot & VPROT_GUARD))
-+    if (stack && !is_inside_signal_stack( stack ) && (vprot & VPROT_GUARD))
-     {
-         if (page < (char *)NtCurrentTeb()->DeallocationStack ||
-             page >= (char *)NtCurrentTeb()->Tib.StackBase)
 -- 
-2.28.0
+2.26.2
 
diff --git a/patches/ntdll-WRITECOPY/0004-ntdll-Properly-handle-PAGE_WRITECOPY-protection.-try.patch b/patches/ntdll-WRITECOPY/0004-ntdll-Properly-handle-PAGE_WRITECOPY-protection.-try.patch
index 4e67574d..4b395812 100644
--- a/patches/ntdll-WRITECOPY/0004-ntdll-Properly-handle-PAGE_WRITECOPY-protection.-try.patch
+++ b/patches/ntdll-WRITECOPY/0004-ntdll-Properly-handle-PAGE_WRITECOPY-protection.-try.patch
@@ -1,19 +1,19 @@
-From 4a297f731112822e51086826f975bf5db9178e52 Mon Sep 17 00:00:00 2001
+From 8c8e2422bea9485bdcda98cea703983bb01f6e41 Mon Sep 17 00:00:00 2001
 From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
 Date: Sat, 4 Oct 2014 03:22:09 +0200
 Subject: [PATCH] ntdll: Properly handle PAGE_WRITECOPY protection. (try 5)
 
 For now, only enable it when a special environment variable is set.
 ---
- dlls/ntdll/unix/virtual.c | 46 +++++++++++++++++++++++++++++++++------
+ dlls/ntdll/virtual.c | 46 +++++++++++++++++++++++++++++++++++++-------
  1 file changed, 39 insertions(+), 7 deletions(-)
 
-diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
-index cf0c1598720..ff585c647bc 100644
---- a/dlls/ntdll/unix/virtual.c
-+++ b/dlls/ntdll/unix/virtual.c
-@@ -495,6 +495,21 @@ static void reserve_area( void *addr, void *end )
- #endif /* __APPLE__ */
+diff --git a/dlls/ntdll/virtual.c b/dlls/ntdll/virtual.c
+index 328bc40a92f..3533a087d88 100644
+--- a/dlls/ntdll/virtual.c
++++ b/dlls/ntdll/virtual.c
+@@ -321,6 +321,21 @@ static const char *VIRTUAL_GetProtStr( BYTE prot )
+     return buffer;
  }
  
 +/* This might look like a hack, but it actually isn't - the 'experimental' version
@@ -32,9 +32,9 @@ index cf0c1598720..ff585c647bc 100644
 +    return enabled;
 +}
  
- static void mmap_init( const struct preload_info *preload_info )
- {
-@@ -852,8 +867,19 @@ static int get_unix_prot( BYTE vprot )
+ /***********************************************************************
+  *           VIRTUAL_GetUnixProt
+@@ -334,8 +349,19 @@ static int VIRTUAL_GetUnixProt( BYTE vprot )
      {
          if (vprot & VPROT_READ) prot |= PROT_READ;
          if (vprot & VPROT_WRITE) prot |= PROT_WRITE | PROT_READ;
@@ -55,7 +55,7 @@ index cf0c1598720..ff585c647bc 100644
          if (vprot & VPROT_WRITEWATCH) prot &= ~PROT_WRITE;
      }
      if (!prot) prot = PROT_NONE;
-@@ -1457,7 +1483,7 @@ static void update_write_watches( void *base, size_t size, size_t accessed_size
+@@ -1080,7 +1106,7 @@ static void update_write_watches( void *base, size_t size, size_t accessed_size
  {
      TRACE( "updating watch %p-%p-%p\n", base, (char *)base + accessed_size, (char *)base + size );
      /* clear write watch flag on accessed pages */
@@ -64,12 +64,12 @@ index cf0c1598720..ff585c647bc 100644
      /* restore page protections on the entire range */
      mprotect_range( base, size, 0, 0 );
  }
-@@ -2985,12 +3011,13 @@ NTSTATUS virtual_handle_fault( void *addr, DWORD err, void *stack )
+@@ -2340,12 +2366,13 @@ NTSTATUS virtual_handle_fault( LPCVOID addr, DWORD err, BOOL on_signal_stack )
              set_page_vprot_bits( page, page_size, 0, VPROT_WRITEWATCH );
              mprotect_range( page, page_size, 0, 0 );
          }
 -        /* ignore fault if page is writable now */
--        if (get_unix_prot( get_page_vprot( page )) & PROT_WRITE)
+-        if (VIRTUAL_GetUnixProt( get_page_vprot( page )) & PROT_WRITE)
 +        if (vprot & VPROT_WRITECOPY)
          {
 -            if ((vprot & VPROT_WRITEWATCH) || is_write_watch_range( page, page_size ))
@@ -78,11 +78,11 @@ index cf0c1598720..ff585c647bc 100644
 +            mprotect_range( page, page_size, 0, 0 );
          }
 +        /* ignore fault if page is writable now */
-+        if (get_unix_prot( get_page_vprot( page ) ) & PROT_WRITE) ret = STATUS_SUCCESS;
++        if (VIRTUAL_GetUnixProt( get_page_vprot( page )) & PROT_WRITE) ret = STATUS_SUCCESS;
      }
-     mutex_unlock( &virtual_mutex );
+     server_leave_uninterrupted_section( &csVirtual, &sigset );
      return ret;
-@@ -3067,11 +3094,16 @@ static NTSTATUS check_write_access( void *base, size_t size, BOOL *has_write_wat
+@@ -2367,11 +2394,16 @@ static NTSTATUS check_write_access( void *base, size_t size, BOOL *has_write_wat
      {
          BYTE vprot = get_page_vprot( addr + i );
          if (vprot & VPROT_WRITEWATCH) *has_write_watch = TRUE;
@@ -91,7 +91,7 @@ index cf0c1598720..ff585c647bc 100644
 +            vprot = (vprot & ~VPROT_WRITECOPY) | VPROT_WRITE;
 +            *has_write_watch = TRUE;
 +        }
-         if (!(get_unix_prot( vprot & ~VPROT_WRITEWATCH ) & PROT_WRITE))
+         if (!(VIRTUAL_GetUnixProt( vprot & ~VPROT_WRITEWATCH ) & PROT_WRITE))
              return STATUS_INVALID_USER_BUFFER;
      }
      if (*has_write_watch)
@@ -101,5 +101,5 @@ index cf0c1598720..ff585c647bc 100644
  }
  
 -- 
-2.28.0
+2.26.2
 
diff --git a/patches/ntdll-WRITECOPY/0005-ntdll-Track-if-a-WRITECOPY-page-has-been-modified.patch b/patches/ntdll-WRITECOPY/0005-ntdll-Track-if-a-WRITECOPY-page-has-been-modified.patch
index 76685150..aa66e6d1 100644
--- a/patches/ntdll-WRITECOPY/0005-ntdll-Track-if-a-WRITECOPY-page-has-been-modified.patch
+++ b/patches/ntdll-WRITECOPY/0005-ntdll-Track-if-a-WRITECOPY-page-has-been-modified.patch
@@ -1,4 +1,4 @@
-From 6af98b9092396f69ac66c4659581436d9c6c7183 Mon Sep 17 00:00:00 2001
+From 6836700fb6d9e0221de770c8b020822b6f4c9b55 Mon Sep 17 00:00:00 2001
 From: Andrew Wesie <awesie@gmail.com>
 Date: Fri, 24 Apr 2020 14:55:14 -0500
 Subject: [PATCH] ntdll: Track if a WRITECOPY page has been modified.
@@ -8,22 +8,22 @@ read-write page.
 
 Signed-off-by: Andrew Wesie <awesie@gmail.com>
 ---
- dlls/ntdll/unix/virtual.c | 25 +++++++++++++++++++------
+ dlls/ntdll/virtual.c | 25 +++++++++++++++++++------
  1 file changed, 19 insertions(+), 6 deletions(-)
 
-diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
-index f3d7c24515f..045d10d92be 100644
---- a/dlls/ntdll/unix/virtual.c
-+++ b/dlls/ntdll/unix/virtual.c
-@@ -101,6 +101,7 @@ struct file_view
+diff --git a/dlls/ntdll/virtual.c b/dlls/ntdll/virtual.c
+index 3533a087d88..75219ae2376 100644
+--- a/dlls/ntdll/virtual.c
++++ b/dlls/ntdll/virtual.c
+@@ -85,6 +85,7 @@ struct file_view
  #define VPROT_GUARD      0x10
  #define VPROT_COMMITTED  0x20
  #define VPROT_WRITEWATCH 0x40
 +#define VPROT_WRITTEN    0x80
  /* per-mapping protection flags */
  #define VPROT_SYSTEM     0x0200  /* system view (underlying mmap not under our control) */
- #define VPROT_NATIVE     0x0400
-@@ -871,7 +872,7 @@ static int get_unix_prot( BYTE vprot )
+ 
+@@ -353,7 +354,7 @@ static int VIRTUAL_GetUnixProt( BYTE vprot )
  #if defined(__i386__)
          if (vprot & VPROT_WRITECOPY)
          {
@@ -32,9 +32,9 @@ index f3d7c24515f..045d10d92be 100644
                  prot = (prot & ~PROT_WRITE) | PROT_READ;
              else
                  prot |= PROT_WRITE | PROT_READ;
-@@ -1315,7 +1316,11 @@ static NTSTATUS create_view( struct file_view **view_ret, void *base, size_t siz
+@@ -925,7 +926,11 @@ static NTSTATUS create_view( struct file_view **view_ret, void *base, size_t siz
   */
- static DWORD get_win32_prot( BYTE vprot, unsigned int map_prot )
+ static DWORD VIRTUAL_GetWin32Prot( BYTE vprot, unsigned int map_prot )
  {
 -    DWORD ret = VIRTUAL_Win32Flags[vprot & 0x0f];
 +    DWORD ret;
@@ -45,7 +45,7 @@ index f3d7c24515f..045d10d92be 100644
      if (vprot & VPROT_GUARD) ret |= PAGE_GUARD;
      if (map_prot & SEC_NOCACHE) ret |= PAGE_NOCACHE;
      return ret;
-@@ -1426,7 +1431,7 @@ static BOOL set_vprot( struct file_view *view, void *base, size_t size, BYTE vpr
+@@ -1049,7 +1054,7 @@ static BOOL VIRTUAL_SetProt( struct file_view *view, /* [in] Pointer to view */
      if (view->protect & VPROT_WRITEWATCH)
      {
          /* each page may need different protections depending on write watch flag */
@@ -54,7 +54,7 @@ index f3d7c24515f..045d10d92be 100644
          mprotect_range( base, size, 0, 0 );
          return TRUE;
      }
-@@ -1442,10 +1447,18 @@ static BOOL set_vprot( struct file_view *view, void *base, size_t size, BYTE vpr
+@@ -1065,10 +1070,18 @@ static BOOL VIRTUAL_SetProt( struct file_view *view, /* [in] Pointer to view */
          return TRUE;
      }
  
@@ -74,7 +74,7 @@ index f3d7c24515f..045d10d92be 100644
      return TRUE;
  }
  
-@@ -3013,7 +3026,7 @@ NTSTATUS virtual_handle_fault( void *addr, DWORD err, void *stack )
+@@ -2368,7 +2381,7 @@ NTSTATUS virtual_handle_fault( LPCVOID addr, DWORD err, BOOL on_signal_stack )
          }
          if (vprot & VPROT_WRITECOPY)
          {
@@ -83,7 +83,7 @@ index f3d7c24515f..045d10d92be 100644
              mprotect_range( page, page_size, 0, 0 );
          }
          /* ignore fault if page is writable now */
-@@ -3955,7 +3968,7 @@ static NTSTATUS get_basic_memory_info( HANDLE process, LPCVOID addr,
+@@ -3272,7 +3285,7 @@ static NTSTATUS get_basic_memory_info( HANDLE process, LPCVOID addr,
          else if (view->protect & (SEC_FILE | SEC_RESERVE | SEC_COMMIT)) info->Type = MEM_MAPPED;
          else info->Type = MEM_PRIVATE;
          for (ptr = base; ptr < base + range_size; ptr += page_size)
@@ -91,7 +91,7 @@ index f3d7c24515f..045d10d92be 100644
 +            if ((get_page_vprot( ptr ) ^ vprot) & ~(VPROT_WRITEWATCH|VPROT_WRITTEN)) break;
          info->RegionSize = ptr - base;
      }
-     server_leave_uninterrupted_section( &virtual_mutex, &sigset );
+     server_leave_uninterrupted_section( &csVirtual, &sigset );
 -- 
-2.28.0
+2.26.2
 
diff --git a/patches/ntdll-WRITECOPY/0006-ntdll-Support-WRITECOPY-on-x64.patch b/patches/ntdll-WRITECOPY/0006-ntdll-Support-WRITECOPY-on-x64.patch
index a1f4ec8d..ea1c9483 100644
--- a/patches/ntdll-WRITECOPY/0006-ntdll-Support-WRITECOPY-on-x64.patch
+++ b/patches/ntdll-WRITECOPY/0006-ntdll-Support-WRITECOPY-on-x64.patch
@@ -1,19 +1,19 @@
-From 153825fbb1dfc7e8624808681fd44f244b5c7c0e Mon Sep 17 00:00:00 2001
+From aae6e8d097aaa6665a65ec6f896e37b445c371ea Mon Sep 17 00:00:00 2001
 From: Andrew Wesie <awesie@gmail.com>
 Date: Fri, 24 Apr 2020 14:55:15 -0500
 Subject: [PATCH] ntdll: Support WRITECOPY on x64.
 
 Signed-off-by: Andrew Wesie <awesie@gmail.com>
 ---
- dlls/ntdll/unix/signal_x86_64.c | 41 +++++++++++++++++++++++++++++++++
- dlls/ntdll/unix/virtual.c       |  2 +-
- 2 files changed, 42 insertions(+), 1 deletion(-)
+ dlls/ntdll/signal_x86_64.c | 40 ++++++++++++++++++++++++++++++++++++++
+ dlls/ntdll/virtual.c       |  2 +-
+ 2 files changed, 41 insertions(+), 1 deletion(-)
 
-diff --git a/dlls/ntdll/unix/signal_x86_64.c b/dlls/ntdll/unix/signal_x86_64.c
-index db608b358ea..741d0ebed5f 100644
---- a/dlls/ntdll/unix/signal_x86_64.c
-+++ b/dlls/ntdll/unix/signal_x86_64.c
-@@ -2266,6 +2266,30 @@ static BOOL handle_syscall_fault( ucontext_t *sigcontext, EXCEPTION_RECORD *rec,
+diff --git a/dlls/ntdll/signal_x86_64.c b/dlls/ntdll/signal_x86_64.c
+index 29829bfb1c6..89a8e36410d 100644
+--- a/dlls/ntdll/signal_x86_64.c
++++ b/dlls/ntdll/signal_x86_64.c
+@@ -2871,6 +2871,29 @@ static inline BOOL handle_interrupt( ucontext_t *sigcontext, struct stack_layout
  }
  
  
@@ -30,8 +30,7 @@ index db608b358ea..741d0ebed5f 100644
 +    switch(TRAP_sig(ucontext))
 +    {
 +    case TRAP_x86_PAGEFLT:  /* Page fault */
-+        if (!virtual_handle_fault( siginfo->si_addr, (ERROR_sig(ucontext) >> 1) & 0x09,
-+                NULL ))
++        if (!virtual_handle_fault( siginfo->si_addr, (ERROR_sig(ucontext) >> 1) & 0x09, TRUE ))
 +            return;
 +        /* fall-through */
 +    default:
@@ -44,7 +43,7 @@ index db608b358ea..741d0ebed5f 100644
  /**********************************************************************
   *		segv_handler
   *
-@@ -2641,6 +2665,23 @@ void signal_init_process(void)
+@@ -3291,6 +3314,23 @@ void signal_init_process(void)
   */
  void signal_init_early(void)
  {
@@ -67,12 +66,12 @@ index db608b358ea..741d0ebed5f 100644
 +    exit(1);
  }
  
- /***********************************************************************
-diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
-index 21760152115..534f99a7064 100644
---- a/dlls/ntdll/unix/virtual.c
-+++ b/dlls/ntdll/unix/virtual.c
-@@ -820,7 +820,7 @@ static int get_unix_prot( BYTE vprot )
+ static ULONG64 get_int_reg( CONTEXT *context, int reg )
+diff --git a/dlls/ntdll/virtual.c b/dlls/ntdll/virtual.c
+index 75219ae2376..df77f55a9e7 100644
+--- a/dlls/ntdll/virtual.c
++++ b/dlls/ntdll/virtual.c
+@@ -351,7 +351,7 @@ static int VIRTUAL_GetUnixProt( BYTE vprot )
          if (vprot & VPROT_READ) prot |= PROT_READ;
          if (vprot & VPROT_WRITE) prot |= PROT_WRITE | PROT_READ;
          if (vprot & VPROT_EXEC) prot |= PROT_EXEC | PROT_READ;
@@ -82,5 +81,5 @@ index 21760152115..534f99a7064 100644
          {
              if (experimental_WRITECOPY() && !(vprot & VPROT_WRITTEN))
 -- 
-2.28.0
+2.26.2
 
diff --git a/patches/ntdll-WRITECOPY/0007-ntdll-Report-unmodified-WRITECOPY-pages-as-shared.patch b/patches/ntdll-WRITECOPY/0007-ntdll-Report-unmodified-WRITECOPY-pages-as-shared.patch
index be42d7d3..207450c3 100644
--- a/patches/ntdll-WRITECOPY/0007-ntdll-Report-unmodified-WRITECOPY-pages-as-shared.patch
+++ b/patches/ntdll-WRITECOPY/0007-ntdll-Report-unmodified-WRITECOPY-pages-as-shared.patch
@@ -1,4 +1,4 @@
-From 961363c939e566a74b9343ad2e328b1f6fce7361 Mon Sep 17 00:00:00 2001
+From 262cfe702345c97ebb32a651cef272fe74e98322 Mon Sep 17 00:00:00 2001
 From: Andrew Wesie <awesie@gmail.com>
 Date: Fri, 24 Apr 2020 14:55:17 -0500
 Subject: [PATCH] ntdll: Report unmodified WRITECOPY pages as shared.
@@ -9,14 +9,14 @@ match the behavior of Windows.
 Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=48665
 Signed-off-by: Andrew Wesie <awesie@gmail.com>
 ---
- dlls/ntdll/unix/virtual.c | 4 +++-
+ dlls/ntdll/virtual.c | 4 +++-
  1 file changed, 3 insertions(+), 1 deletion(-)
 
-diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
-index 16cfa8bda2d7..8b3f93b70d41 100644
---- a/dlls/ntdll/unix/virtual.c
-+++ b/dlls/ntdll/unix/virtual.c
-@@ -2174,6 +2174,8 @@ static NTSTATUS map_image_into_view( struct file_view *view, int fd, void *orig_
+diff --git a/dlls/ntdll/virtual.c b/dlls/ntdll/virtual.c
+index df77f55a9e7..b329a9024d8 100644
+--- a/dlls/ntdll/virtual.c
++++ b/dlls/ntdll/virtual.c
+@@ -1737,6 +1737,8 @@ static NTSTATUS map_image( HANDLE hmapping, ACCESS_MASK access, int fd, int top_
                             ptr + sec->VirtualAddress + file_size,
                             ptr + sec->VirtualAddress + end );
              memset( ptr + sec->VirtualAddress + file_size, 0, end - file_size );
@@ -25,7 +25,7 @@ index 16cfa8bda2d7..8b3f93b70d41 100644
          }
      }
  
-@@ -3937,7 +3939,7 @@ static NTSTATUS get_working_set_ex( HANDLE process, LPCVOID addr,
+@@ -3336,7 +3338,7 @@ static NTSTATUS get_working_set_ex( HANDLE process, LPCVOID addr,
                  (vprot & VPROT_COMMITTED))
          {
              p->VirtualAttributes.Valid = !(vprot & VPROT_GUARD) && (vprot & 0x0f) && (pagemap >> 63);
@@ -35,5 +35,5 @@ index 16cfa8bda2d7..8b3f93b70d41 100644
                  p->VirtualAttributes.ShareCount = 1; /* FIXME */
              if (p->VirtualAttributes.Valid)
 -- 
-2.20.1
+2.26.2
 
diff --git a/patches/ntdll-WRITECOPY/0008-ntdll-Fallback-to-copy-pages-for-WRITECOPY.patch b/patches/ntdll-WRITECOPY/0008-ntdll-Fallback-to-copy-pages-for-WRITECOPY.patch
index f6a71373..70c8fc27 100644
--- a/patches/ntdll-WRITECOPY/0008-ntdll-Fallback-to-copy-pages-for-WRITECOPY.patch
+++ b/patches/ntdll-WRITECOPY/0008-ntdll-Fallback-to-copy-pages-for-WRITECOPY.patch
@@ -1,4 +1,4 @@
-From 86b7f01ebe8d0cccd81a1d9913c9a42966ea7d3c Mon Sep 17 00:00:00 2001
+From 560a608432d8d4df920370e4bd50113c1db87b1f Mon Sep 17 00:00:00 2001
 From: Andrew Wesie <awesie@gmail.com>
 Date: Tue, 28 Apr 2020 03:27:16 -0500
 Subject: [PATCH] ntdll: Fallback to copy pages for WRITECOPY.
@@ -12,14 +12,14 @@ then copy the contents to the new page.
 
 Signed-off-by: Andrew Wesie <awesie@gmail.com>
 ---
- dlls/ntdll/unix/virtual.c | 25 +++++++++++++++++++++----
+ dlls/ntdll/virtual.c | 25 +++++++++++++++++++++----
  1 file changed, 21 insertions(+), 4 deletions(-)
 
-diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
-index 148da16f34d..1ca19a24003 100644
---- a/dlls/ntdll/unix/virtual.c
-+++ b/dlls/ntdll/unix/virtual.c
-@@ -1447,8 +1447,9 @@ static BOOL set_vprot( struct file_view *view, void *base, size_t size, BYTE vpr
+diff --git a/dlls/ntdll/virtual.c b/dlls/ntdll/virtual.c
+index b329a9024d8..e68ca274ca4 100644
+--- a/dlls/ntdll/virtual.c
++++ b/dlls/ntdll/virtual.c
+@@ -1070,8 +1070,9 @@ static BOOL VIRTUAL_SetProt( struct file_view *view, /* [in] Pointer to view */
          return TRUE;
      }
  
@@ -31,14 +31,14 @@ index 148da16f34d..1ca19a24003 100644
          unix_prot |= PROT_WRITE;
  
      if (mprotect_exec( base, size, unix_prot )) /* FIXME: last error */
-@@ -3026,10 +3027,26 @@ NTSTATUS virtual_handle_fault( void *addr, DWORD err, void *stack )
+@@ -2381,10 +2382,26 @@ NTSTATUS virtual_handle_fault( LPCVOID addr, DWORD err, BOOL on_signal_stack )
              set_page_vprot_bits( page, page_size, 0, VPROT_WRITEWATCH );
              mprotect_range( page, page_size, 0, 0 );
          }
 -        if (vprot & VPROT_WRITECOPY)
 +        if ((vprot & VPROT_WRITECOPY) && (vprot & VPROT_COMMITTED))
          {
-+            struct file_view *view = find_view( page, 0 );
++            struct file_view *view = VIRTUAL_FindView( page, 0 );
 +
              set_page_vprot_bits( page, page_size, VPROT_WRITE | VPROT_WRITTEN, VPROT_WRITECOPY );
 -            mprotect_range( page, page_size, 0, 0 );
@@ -50,16 +50,16 @@ index 148da16f34d..1ca19a24003 100644
 +            {
 +                static BYTE *temp_page = NULL;
 +                if (!temp_page)
-+                    temp_page = anon_mmap_alloc( page_size, PROT_READ | PROT_WRITE );
++                    temp_page = wine_anon_mmap( NULL, page_size, PROT_READ | PROT_WRITE, 0 );
 +
 +                /* original mapping is shared, replace with a private page */
 +                memcpy( temp_page, page, page_size );
-+                anon_mmap_fixed( page, page_size, get_unix_prot( vprot | VPROT_WRITE | VPROT_WRITTEN ), 0 );
++                wine_anon_mmap( page, page_size, VIRTUAL_GetUnixProt(vprot | VPROT_WRITE | VPROT_WRITTEN), MAP_FIXED );
 +                memcpy( page, temp_page, page_size );
 +            }
          }
          /* ignore fault if page is writable now */
-         if (get_unix_prot( get_page_vprot( page ) ) & PROT_WRITE) ret = STATUS_SUCCESS;
+         if (VIRTUAL_GetUnixProt( get_page_vprot( page )) & PROT_WRITE) ret = STATUS_SUCCESS;
 -- 
-2.28.0
+2.26.2
 
diff --git a/patches/ntdll-WRITECOPY/definition b/patches/ntdll-WRITECOPY/definition
index 9f26ca0c..d5806b79 100644
--- a/patches/ntdll-WRITECOPY/definition
+++ b/patches/ntdll-WRITECOPY/definition
@@ -1,5 +1,5 @@
 Fixes: [29384] Multiple applications expect correct handling of WRITECOPY memory protection (Voobly fails to launch Age of Empires II, MSYS2)
-Depends: ntdll-ForceBottomUpAlloc
+
 # Causes regressions?
 # https://bugs.wine-staging.com/show_bug.cgi?id=207
 # https://bugs.wine-staging.com/show_bug.cgi?id=521
diff --git a/patches/ntdll-Zero_mod_name/0001-ntdll-Initialize-mod_name-to-zero.patch b/patches/ntdll-Zero_mod_name/0001-ntdll-Initialize-mod_name-to-zero.patch
index 0f4a4abf..80c23f58 100644
--- a/patches/ntdll-Zero_mod_name/0001-ntdll-Initialize-mod_name-to-zero.patch
+++ b/patches/ntdll-Zero_mod_name/0001-ntdll-Initialize-mod_name-to-zero.patch
@@ -1,4 +1,4 @@
-From d1536aa5b9df87c3764dc2090bdde76f708fda94 Mon Sep 17 00:00:00 2001
+From 8fe1b6c64671ab1fc5af0099b23021eae0a046d7 Mon Sep 17 00:00:00 2001
 From: Qian Hong <qhong@codeweavers.com>
 Date: Wed, 9 Sep 2015 05:31:18 +0800
 Subject: [PATCH] ntdll: Initialize mod_name to zero.
@@ -8,11 +8,11 @@ Subject: [PATCH] ntdll: Initialize mod_name to zero.
  1 file changed, 2 insertions(+)
 
 diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
-index 42cdc628021..ef1e28af2e7 100644
+index 0568be63ad8..98472b060e1 100644
 --- a/dlls/ntdll/loader.c
 +++ b/dlls/ntdll/loader.c
-@@ -1299,6 +1299,8 @@ static NTSTATUS MODULE_InitDLL( WINE_MODREF *wm, UINT reason, LPVOID lpReserved
-         unix_funcs->init_builtin_dll( wm->ldr.DllBase );
+@@ -1363,6 +1363,8 @@ static NTSTATUS MODULE_InitDLL( WINE_MODREF *wm, UINT reason, LPVOID lpReserved
+     if (wm->so_handle && reason == DLL_PROCESS_ATTACH) call_constructors( wm );
      if (!entry) return STATUS_SUCCESS;
  
 +    memset( mod_name, 0, sizeof(mod_name) );
@@ -21,5 +21,5 @@ index 42cdc628021..ef1e28af2e7 100644
      {
          size_t len = min( wm->ldr.BaseDllName.Length, sizeof(mod_name)-sizeof(WCHAR) );
 -- 
-2.27.0
+2.26.0
 
diff --git a/patches/ntdll-aarch-TEB/0002-ntdll-Always-restore-TEB-to-x18-on-aarch-64-on-retur.patch b/patches/ntdll-aarch-TEB/0002-ntdll-Always-restore-TEB-to-x18-on-aarch-64-on-retur.patch
index 3c358a0b..25268c38 100644
--- a/patches/ntdll-aarch-TEB/0002-ntdll-Always-restore-TEB-to-x18-on-aarch-64-on-retur.patch
+++ b/patches/ntdll-aarch-TEB/0002-ntdll-Always-restore-TEB-to-x18-on-aarch-64-on-retur.patch
@@ -1,4 +1,4 @@
-From c9d1b1c5498a893ed99803dbcead591ff3f9e953 Mon Sep 17 00:00:00 2001
+From e25066ea9c9e0442d4c18c13818071c104a9c5d2 Mon Sep 17 00:00:00 2001
 From: Martin Storsjo <martin@martin.st>
 Date: Wed, 16 Aug 2017 23:48:40 +0300
 Subject: [PATCH] ntdll: Always restore TEB to x18 on aarch 64 on return from
@@ -20,29 +20,29 @@ Signed-off-by: Martin Storsjo <martin@martin.st>
  2 files changed, 11 insertions(+), 1 deletion(-)
 
 diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
-index cec8e114e14..d09948c51aa 100644
+index 0568be63ad8..b7612dcc9a7 100644
 --- a/dlls/ntdll/loader.c
 +++ b/dlls/ntdll/loader.c
-@@ -2135,7 +2135,13 @@ static NTSTATUS build_module( LPCWSTR load_path, const UNICODE_STRING *nt_name,
+@@ -2036,7 +2036,13 @@ static NTSTATUS build_so_dll_module( const WCHAR *load_path, const UNICODE_STRIN
+     SERVER_END_REQ;
  
-     if (image_info->u.ImageFlags & IMAGE_FLAGS_WineBuiltin)
-     {
--        if (TRACE_ON(relay)) RELAY_SetupDLL( *module );
+     /* setup relay debugging entry points */
+-    if (TRACE_ON(relay)) RELAY_SetupDLL( module );
 +#ifdef __aarch64__
-+        /* Always enable relay entry points on aarch64, to allow restoring
-+         * the TEB to x18. */
++    /* Always enable relay entry points on aarch64, to allow restoring
++     * the TEB to x18. */
 +#else
-+        if (TRACE_ON(relay))
++    if (TRACE_ON(relay))
 +#endif
-+            RELAY_SetupDLL( *module );
-     }
-     else
-     {
++        RELAY_SetupDLL( module );
+ 
+     *pwm = wm;
+     return STATUS_SUCCESS;
 diff --git a/dlls/ntdll/relay.c b/dlls/ntdll/relay.c
-index e1596312491..63ae0d8ec41 100644
+index acccf088811..35dd4161d8b 100644
 --- a/dlls/ntdll/relay.c
 +++ b/dlls/ntdll/relay.c
-@@ -702,8 +702,12 @@ static LONGLONG WINAPI relay_call( struct relay_descr *descr, unsigned int idx,
+@@ -705,8 +705,12 @@ static LONGLONG WINAPI relay_call( struct relay_descr *descr, unsigned int idx,
  {
      unsigned int nb_args;
      void *func = relay_trace_entry( descr, idx, stack, &nb_args );
@@ -56,5 +56,5 @@ index e1596312491..63ae0d8ec41 100644
  }
  
 -- 
-2.28.0
+2.26.0
 
diff --git a/patches/ntdll-ext4-case-folder/0002-ntdll-server-Mark-drive_c-as-case-insensitive-when-c.patch b/patches/ntdll-ext4-case-folder/0002-ntdll-server-Mark-drive_c-as-case-insensitive-when-c.patch
index 9711a716..78dac208 100644
--- a/patches/ntdll-ext4-case-folder/0002-ntdll-server-Mark-drive_c-as-case-insensitive-when-c.patch
+++ b/patches/ntdll-ext4-case-folder/0002-ntdll-server-Mark-drive_c-as-case-insensitive-when-c.patch
@@ -1,4 +1,4 @@
-From 627618459891aa36fc9a9ac0c04b7035d2272fb1 Mon Sep 17 00:00:00 2001
+From acdd5aaf5d4f618a96f21710a8ee2f44a994194c Mon Sep 17 00:00:00 2001
 From: =?UTF-8?q?Gabriel=20Iv=C4=83ncescu?= <gabrielopcode@gmail.com>
 Date: Fri, 24 May 2019 15:09:35 +0300
 Subject: [PATCH] ntdll/server: Mark drive_c as case-insensitive when created
@@ -9,14 +9,14 @@ Content-Transfer-Encoding: 8bit
 Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47099
 Signed-off-by: Gabriel Ivncescu <gabrielopcode@gmail.com>
 ---
- dlls/ntdll/unix/server.c | 45 ++++++++++++++++++++++++++++++++++++++++
+ dlls/ntdll/server.c | 45 +++++++++++++++++++++++++++++++++++++++++++++
  1 file changed, 45 insertions(+)
 
-diff --git a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
-index 8dc3f33bc80..0e6c9d90281 100644
---- a/dlls/ntdll/unix/server.c
-+++ b/dlls/ntdll/unix/server.c
-@@ -55,6 +55,12 @@
+diff --git a/dlls/ntdll/server.c b/dlls/ntdll/server.c
+index bc25e242a77..f2109dd1ef0 100644
+--- a/dlls/ntdll/server.c
++++ b/dlls/ntdll/server.c
+@@ -54,6 +54,12 @@
  #ifdef HAVE_SYS_MMAN_H
  #include <sys/mman.h>
  #endif
@@ -29,7 +29,7 @@ index 8dc3f33bc80..0e6c9d90281 100644
  #ifdef HAVE_SYS_PRCTL_H
  # include <sys/prctl.h>
  #endif
-@@ -93,6 +99,22 @@
+@@ -87,6 +93,22 @@
  
  WINE_DEFAULT_DEBUG_CHANNEL(server);
  
@@ -49,10 +49,10 @@ index 8dc3f33bc80..0e6c9d90281 100644
 +
 +#endif
 +
- #ifndef MSG_CMSG_CLOEXEC
- #define MSG_CMSG_CLOEXEC 0
- #endif
-@@ -729,6 +751,28 @@ static const char *init_server_dir( dev_t dev, ino_t ino )
+ /* Some versions of glibc don't define this */
+ #ifndef SCM_RIGHTS
+ #define SCM_RIGHTS 1
+@@ -1380,6 +1402,28 @@ void init_paths(void)
  }
  
  
@@ -81,7 +81,7 @@ index 8dc3f33bc80..0e6c9d90281 100644
  /***********************************************************************
   *           setup_config_dir
   *
-@@ -765,6 +809,7 @@ static int setup_config_dir(void)
+@@ -1416,6 +1460,7 @@ static int setup_config_dir(void)
      if (!mkdir( "dosdevices", 0777 ))
      {
          mkdir( "drive_c", 0777 );
diff --git a/patches/ntdll-set_full_cpu_context/0001-ntdll-Add-back-SS-segment-prefixes-in-set_full_cpu_c.patch b/patches/ntdll-set_full_cpu_context/0001-ntdll-Add-back-SS-segment-prefixes-in-set_full_cpu_c.patch
index c311d267..91d6081d 100644
--- a/patches/ntdll-set_full_cpu_context/0001-ntdll-Add-back-SS-segment-prefixes-in-set_full_cpu_c.patch
+++ b/patches/ntdll-set_full_cpu_context/0001-ntdll-Add-back-SS-segment-prefixes-in-set_full_cpu_c.patch
@@ -1,17 +1,17 @@
-From afec7f854357083d9741054ff0d3c768c8b77e9b Mon Sep 17 00:00:00 2001
+From 9701b29e87bc913b95e26ec8f7d26ba404dc1bce Mon Sep 17 00:00:00 2001
 From: Sebastian Lackner <sebastian@fds-team.de>
 Date: Wed, 26 Jul 2017 23:44:32 +0200
-Subject: [PATCH] ntdll: Add back SS segment prefixes in set_full_cpu_context.
+Subject: ntdll: Add back SS segment prefixes in set_full_cpu_context.
 
 ---
- dlls/ntdll/unix/signal_i386.c | 4 ++++
+ dlls/ntdll/signal_i386.c | 4 ++++
  1 file changed, 4 insertions(+)
 
-diff --git a/dlls/ntdll/unix/signal_i386.c b/dlls/ntdll/unix/signal_i386.c
-index 515090d9af8..06751681f5b 100644
---- a/dlls/ntdll/unix/signal_i386.c
-+++ b/dlls/ntdll/unix/signal_i386.c
-@@ -304,12 +304,16 @@ __ASM_GLOBAL_FUNC( set_full_cpu_context,
+diff --git a/dlls/ntdll/signal_i386.c b/dlls/ntdll/signal_i386.c
+index bee08275340..75c6654a7f5 100644
+--- a/dlls/ntdll/signal_i386.c
++++ b/dlls/ntdll/signal_i386.c
+@@ -1274,12 +1274,16 @@ __ASM_GLOBAL_FUNC( set_full_cpu_context,
                     "movl 0xc4(%ecx),%eax\n\t" /* Esp */
                     "leal -4*4(%eax),%eax\n\t"
                     "movl 0xc0(%ecx),%edx\n\t" /* EFlags */
@@ -29,5 +29,5 @@ index 515090d9af8..06751681f5b 100644
                     "pushl 0x98(%ecx)\n\t"     /* SegDs */
                     "movl 0xa8(%ecx),%edx\n\t" /* Edx */
 -- 
-2.26.2
+2.13.1
 
diff --git a/patches/ntdll-x86_64_SegDs/0001-ntdll-Report-SegDs-to-be-identical-to-SegSs-on-x86_6.patch b/patches/ntdll-x86_64_SegDs/0001-ntdll-Report-SegDs-to-be-identical-to-SegSs-on-x86_6.patch
index d07ca424..455a3be4 100644
--- a/patches/ntdll-x86_64_SegDs/0001-ntdll-Report-SegDs-to-be-identical-to-SegSs-on-x86_6.patch
+++ b/patches/ntdll-x86_64_SegDs/0001-ntdll-Report-SegDs-to-be-identical-to-SegSs-on-x86_6.patch
@@ -1,4 +1,4 @@
-From 6fb2e6ef08a7cf1339b39fa753b29092fa76c3df Mon Sep 17 00:00:00 2001
+From 1178a02719088e81b2e5b35074b4559f60d8a5b1 Mon Sep 17 00:00:00 2001
 From: Zebediah Figura <z.figura12@gmail.com>
 Date: Thu, 21 Nov 2019 10:44:42 -0600
 Subject: [PATCH] ntdll: Report SegDs to be identical to SegSs on x86_64.
@@ -8,14 +8,14 @@ Based on a patch by David Torok.
 Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47970
 Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
 ---
- dlls/ntdll/unix/signal_x86_64.c | 11 ++++++-----
+ dlls/ntdll/signal_x86_64.c | 11 ++++++-----
  1 file changed, 6 insertions(+), 5 deletions(-)
 
-diff --git a/dlls/ntdll/unix/signal_x86_64.c b/dlls/ntdll/unix/signal_x86_64.c
-index d4a6e821a4c..ebbef9d2fcd 100644
---- a/dlls/ntdll/unix/signal_x86_64.c
-+++ b/dlls/ntdll/unix/signal_x86_64.c
-@@ -348,11 +348,6 @@ static void save_context( CONTEXT *context, const ucontext_t *sigcontext )
+diff --git a/dlls/ntdll/signal_x86_64.c b/dlls/ntdll/signal_x86_64.c
+index c372f65b34b..a1797811da3 100644
+--- a/dlls/ntdll/signal_x86_64.c
++++ b/dlls/ntdll/signal_x86_64.c
+@@ -1699,11 +1699,6 @@ static void save_context( CONTEXT *context, const ucontext_t *sigcontext )
      context->SegFs  = FS_sig(sigcontext);
      context->SegGs  = GS_sig(sigcontext);
      context->EFlags = EFL_sig(sigcontext);
@@ -27,7 +27,7 @@ index d4a6e821a4c..ebbef9d2fcd 100644
  #ifdef ES_sig
      context->SegEs  = ES_sig(sigcontext);
  #else
-@@ -363,6 +358,12 @@ static void save_context( CONTEXT *context, const ucontext_t *sigcontext )
+@@ -1714,6 +1709,12 @@ static void save_context( CONTEXT *context, const ucontext_t *sigcontext )
  #else
      __asm__("movw %%ss,%0" : "=m" (context->SegSs));
  #endif
@@ -41,5 +41,5 @@ index d4a6e821a4c..ebbef9d2fcd 100644
      context->Dr1    = amd64_thread_data()->dr1;
      context->Dr2    = amd64_thread_data()->dr2;
 -- 
-2.26.2
+2.23.0
 
diff --git a/patches/nvcuda-CUDA_Support/0003-nvcuda-First-implementation.patch b/patches/nvcuda-CUDA_Support/0003-nvcuda-First-implementation.patch
index 4d822013..33d0ae8f 100644
--- a/patches/nvcuda-CUDA_Support/0003-nvcuda-First-implementation.patch
+++ b/patches/nvcuda-CUDA_Support/0003-nvcuda-First-implementation.patch
@@ -1,4 +1,4 @@
-From b56857593bfce8f684953cd4c3356e78100a7ef5 Mon Sep 17 00:00:00 2001
+From c5c277e9a6d54ff4b9b22fd9f412401c47a71a4e Mon Sep 17 00:00:00 2001
 From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
 Date: Sat, 3 Jan 2015 03:39:11 +0100
 Subject: [PATCH] nvcuda: First implementation. (rev 2)
@@ -10,23 +10,23 @@ Changes by Sebastian Lackner <sebastian@fds-team.de>:
 ---
  configure.ac                  |    1 +
  dlls/nvcuda/Makefile.in       |    1 +
- dlls/nvcuda/internal.c        |  514 ++++++++
- dlls/nvcuda/nvcuda.c          | 2096 ++++++++++++++++++++++++++++++++-
+ dlls/nvcuda/internal.c        |  515 ++++++++
+ dlls/nvcuda/nvcuda.c          | 2097 ++++++++++++++++++++++++++++++++-
  dlls/nvcuda/nvcuda.h          |   29 +
  dlls/nvcuda/nvcuda.spec       |  492 ++++----
  dlls/nvcuda/tests/Makefile.in |    4 +
  dlls/nvcuda/tests/nvcuda.c    |  168 +++
- 8 files changed, 3054 insertions(+), 251 deletions(-)
+ 8 files changed, 3056 insertions(+), 251 deletions(-)
  create mode 100644 dlls/nvcuda/internal.c
  create mode 100644 dlls/nvcuda/nvcuda.h
  create mode 100644 dlls/nvcuda/tests/Makefile.in
  create mode 100644 dlls/nvcuda/tests/nvcuda.c
 
 diff --git a/configure.ac b/configure.ac
-index 7fd6ce83974..7dd3db6bb9f 100644
+index 2bc340b70..d70d21d94 100644
 --- a/configure.ac
 +++ b/configure.ac
-@@ -3602,6 +3602,7 @@ WINE_CONFIG_MAKEFILE(dlls/ntoskrnl.exe/tests)
+@@ -3544,6 +3544,7 @@ WINE_CONFIG_MAKEFILE(dlls/ntoskrnl.exe/tests)
  WINE_CONFIG_MAKEFILE(dlls/ntprint)
  WINE_CONFIG_MAKEFILE(dlls/ntprint/tests)
  WINE_CONFIG_MAKEFILE(dlls/nvcuda)
@@ -35,7 +35,7 @@ index 7fd6ce83974..7dd3db6bb9f 100644
  WINE_CONFIG_MAKEFILE(dlls/odbc32)
  WINE_CONFIG_MAKEFILE(dlls/odbcbcp)
 diff --git a/dlls/nvcuda/Makefile.in b/dlls/nvcuda/Makefile.in
-index 4b33278c115..0921ce64cae 100644
+index 4b33278c1..0921ce64c 100644
 --- a/dlls/nvcuda/Makefile.in
 +++ b/dlls/nvcuda/Makefile.in
 @@ -1,6 +1,7 @@
@@ -48,10 +48,10 @@ index 4b33278c115..0921ce64cae 100644
  RC_SRCS = nvcuda.rc
 diff --git a/dlls/nvcuda/internal.c b/dlls/nvcuda/internal.c
 new file mode 100644
-index 00000000000..664bdf84f51
+index 000000000..611e3108d
 --- /dev/null
 +++ b/dlls/nvcuda/internal.c
-@@ -0,0 +1,514 @@
+@@ -0,0 +1,515 @@
 +/*
 + * Copyright (C) 2014-2015 Michael Mller
 + * Copyright (C) 2014-2015 Sebastian Lackner
@@ -79,6 +79,7 @@ index 00000000000..664bdf84f51
 +
 +#include "windef.h"
 +#include "winbase.h"
++#include "wine/library.h"
 +#include "wine/debug.h"
 +#include "wine/list.h"
 +#include "cuda.h"
@@ -567,7 +568,7 @@ index 00000000000..664bdf84f51
 +    return CUDA_ERROR_UNKNOWN;
 +}
 diff --git a/dlls/nvcuda/nvcuda.c b/dlls/nvcuda/nvcuda.c
-index 8b7eb9c37b0..623c9f3c87a 100644
+index 8b7eb9c37..3ef7c3505 100644
 --- a/dlls/nvcuda/nvcuda.c
 +++ b/dlls/nvcuda/nvcuda.c
 @@ -1,4 +1,5 @@
@@ -576,7 +577,7 @@ index 8b7eb9c37b0..623c9f3c87a 100644
   * Copyright (C) 2014-2015 Sebastian Lackner
   *
   * This library is free software; you can redistribute it and/or
-@@ -17,19 +18,2104 @@
+@@ -17,19 +18,2105 @@
   */
  
  #include "config.h"
@@ -588,6 +589,7 @@ index 8b7eb9c37b0..623c9f3c87a 100644
 -#include "winbase.h"
 +#include "windef.h"
 +#include "winbase.h"
++#include "wine/library.h"
 +#include "wine/debug.h"
 +#include "wine/wgl.h"
 +#include "cuda.h"
@@ -2688,7 +2690,7 @@ index 8b7eb9c37b0..623c9f3c87a 100644
  
 diff --git a/dlls/nvcuda/nvcuda.h b/dlls/nvcuda/nvcuda.h
 new file mode 100644
-index 00000000000..aaffe13af5f
+index 000000000..aaffe13af
 --- /dev/null
 +++ b/dlls/nvcuda/nvcuda.h
 @@ -0,0 +1,29 @@
@@ -2722,7 +2724,7 @@ index 00000000000..aaffe13af5f
 +
 +#endif
 diff --git a/dlls/nvcuda/nvcuda.spec b/dlls/nvcuda/nvcuda.spec
-index 279f7ab803b..621b8d59cf0 100644
+index 279f7ab80..621b8d59c 100644
 --- a/dlls/nvcuda/nvcuda.spec
 +++ b/dlls/nvcuda/nvcuda.spec
 @@ -1,36 +1,36 @@
@@ -3236,7 +3238,7 @@ index 279f7ab803b..621b8d59cf0 100644
  @ stub cuWGLGetDevice
 diff --git a/dlls/nvcuda/tests/Makefile.in b/dlls/nvcuda/tests/Makefile.in
 new file mode 100644
-index 00000000000..81f9290e5aa
+index 000000000..81f9290e5
 --- /dev/null
 +++ b/dlls/nvcuda/tests/Makefile.in
 @@ -0,0 +1,4 @@
@@ -3246,7 +3248,7 @@ index 00000000000..81f9290e5aa
 +	nvcuda.c
 diff --git a/dlls/nvcuda/tests/nvcuda.c b/dlls/nvcuda/tests/nvcuda.c
 new file mode 100644
-index 00000000000..fc8f300a28b
+index 000000000..fc8f300a2
 --- /dev/null
 +++ b/dlls/nvcuda/tests/nvcuda.c
 @@ -0,0 +1,168 @@
@@ -3419,5 +3421,5 @@ index 00000000000..fc8f300a28b
 +    test_TlsNotifyInterface();
 +}
 -- 
-2.28.0
+2.24.0
 
diff --git a/patches/nvcuda-CUDA_Support/0007-nvcuda-Properly-wrap-stream-callbacks-by-forwarding-.patch b/patches/nvcuda-CUDA_Support/0007-nvcuda-Properly-wrap-stream-callbacks-by-forwarding-.patch
index 4bd6de9c..af4db274 100644
--- a/patches/nvcuda-CUDA_Support/0007-nvcuda-Properly-wrap-stream-callbacks-by-forwarding-.patch
+++ b/patches/nvcuda-CUDA_Support/0007-nvcuda-Properly-wrap-stream-callbacks-by-forwarding-.patch
@@ -1,12 +1,12 @@
-From 3693c4416a4d6e938a36a63970d9ae16ac5c38a8 Mon Sep 17 00:00:00 2001
+From 0d393cfac6d2d4908f40a09565eab989bc71dfab Mon Sep 17 00:00:00 2001
 From: Sebastian Lackner <sebastian@fds-team.de>
 Date: Thu, 22 Jan 2015 01:02:53 +0100
-Subject: [PATCH] nvcuda: Properly wrap stream callbacks by forwarding them to
- a worker thread.
+Subject: nvcuda: Properly wrap stream callbacks by forwarding them to a worker
+ thread.
 
 ---
  dlls/nvcuda/Makefile.in |   1 +
- dlls/nvcuda/nvcuda.c    | 136 +++++++++++++++++++++++++++++++++++-----
+ dlls/nvcuda/nvcuda.c    | 136 ++++++++++++++++++++++++++++++++++++++++++------
  2 files changed, 122 insertions(+), 15 deletions(-)
 
 diff --git a/dlls/nvcuda/Makefile.in b/dlls/nvcuda/Makefile.in
@@ -20,10 +20,10 @@ index 0921ce64cae..ab8a5a29a7a 100644
  C_SRCS = \
  	internal.c \
 diff --git a/dlls/nvcuda/nvcuda.c b/dlls/nvcuda/nvcuda.c
-index 7b23abe6f90..117d78b6766 100644
+index 9fefc28fa76..8b356fd6f5d 100644
 --- a/dlls/nvcuda/nvcuda.c
 +++ b/dlls/nvcuda/nvcuda.c
-@@ -21,10 +21,16 @@
+@@ -21,11 +21,17 @@
  #include "wine/port.h"
  
  #include <stdarg.h>
@@ -35,12 +35,13 @@ index 7b23abe6f90..117d78b6766 100644
  
  #include "windef.h"
  #include "winbase.h"
+ #include "wine/library.h"
  #include "wine/debug.h"
 +#include "wine/list.h"
  #include "wine/wgl.h"
  #include "cuda.h"
  #include "nvcuda.h"
-@@ -38,6 +44,30 @@
+@@ -39,6 +45,30 @@
  
  WINE_DEFAULT_DEBUG_CHANNEL(nvcuda);
  
@@ -71,7 +72,7 @@ index 7b23abe6f90..117d78b6766 100644
  static CUresult (*pcuArray3DCreate)(CUarray *pHandle, const CUDA_ARRAY3D_DESCRIPTOR *pAllocateArray);
  static CUresult (*pcuArray3DCreate_v2)(CUarray *pHandle, const CUDA_ARRAY3D_DESCRIPTOR *pAllocateArray);
  static CUresult (*pcuArray3DGetDescriptor)(CUDA_ARRAY3D_DESCRIPTOR *pArrayDescriptor, CUarray hArray);
-@@ -1792,40 +1822,116 @@ CUresult WINAPI wine_cuPointerSetAttribute(const void *value, CUpointer_attribut
+@@ -1793,40 +1823,116 @@ CUresult WINAPI wine_cuPointerSetAttribute(const void *value, CUpointer_attribut
      return pcuPointerSetAttribute(value, attribute, ptr);
  }
  
@@ -204,5 +205,5 @@ index 7b23abe6f90..117d78b6766 100644
  }
  
 -- 
-2.28.0
+2.11.0
 
diff --git a/patches/nvcuda-CUDA_Support/0009-nvcuda-Implement-cuModuleLoad-wrapper-function.patch b/patches/nvcuda-CUDA_Support/0009-nvcuda-Implement-cuModuleLoad-wrapper-function.patch
index 0d4398e1..2b648b03 100644
--- a/patches/nvcuda-CUDA_Support/0009-nvcuda-Implement-cuModuleLoad-wrapper-function.patch
+++ b/patches/nvcuda-CUDA_Support/0009-nvcuda-Implement-cuModuleLoad-wrapper-function.patch
@@ -1,27 +1,27 @@
-From 052056600a2161cf975878db4d58877192cf7614 Mon Sep 17 00:00:00 2001
+From 73f255bdc5edef27f9a03b7e8917686490d3bf7a Mon Sep 17 00:00:00 2001
 From: Sebastian Lackner <sebastian@fds-team.de>
 Date: Sat, 7 Mar 2015 06:20:55 +0100
 Subject: [PATCH] nvcuda: Implement cuModuleLoad wrapper function.
 
 ---
- dlls/nvcuda/nvcuda.c    | 22 ++++++++++++++++++++++
+ dlls/nvcuda/nvcuda.c    | 46 +++++++++++++++++++++++++++++++++++++++++
  dlls/nvcuda/nvcuda.spec |  2 +-
  include/cuda.h          |  1 +
- 3 files changed, 24 insertions(+), 1 deletion(-)
+ 3 files changed, 48 insertions(+), 1 deletion(-)
 
 diff --git a/dlls/nvcuda/nvcuda.c b/dlls/nvcuda/nvcuda.c
-index 9aab6dda7d8..5d720ebed77 100644
+index e11a1d51a9d..14b695f3371 100644
 --- a/dlls/nvcuda/nvcuda.c
 +++ b/dlls/nvcuda/nvcuda.c
 @@ -29,6 +29,7 @@
  
  #include "windef.h"
  #include "winbase.h"
-+#include "winnls.h"
++#include "winternl.h"
+ #include "wine/library.h"
  #include "wine/debug.h"
  #include "wine/list.h"
- #include "wine/wgl.h"
-@@ -260,6 +261,7 @@ static CUresult (*pcuModuleGetGlobal)(CUdeviceptr *dptr, size_t *bytes, CUmodule
+@@ -261,6 +262,7 @@ static CUresult (*pcuModuleGetGlobal)(CUdeviceptr *dptr, size_t *bytes, CUmodule
  static CUresult (*pcuModuleGetGlobal_v2)(CUdeviceptr *dptr, size_t *bytes, CUmodule hmod, const char *name);
  static CUresult (*pcuModuleGetSurfRef)(CUsurfref *pSurfRef, CUmodule hmod, const char *name);
  static CUresult (*pcuModuleGetTexRef)(CUtexref *pTexRef, CUmodule hmod, const char *name);
@@ -29,7 +29,7 @@ index 9aab6dda7d8..5d720ebed77 100644
  static CUresult (*pcuModuleLoadData)(CUmodule *module, const void *image);
  static CUresult (*pcuModuleLoadDataEx)(CUmodule *module, const void *image, unsigned int numOptions, CUjit_option *options, void **optionValues);
  static CUresult (*pcuModuleLoadFatBinary)(CUmodule *module, const void *fatCubin);
-@@ -605,6 +607,7 @@ static BOOL load_functions(void)
+@@ -606,6 +608,7 @@ static BOOL load_functions(void)
      LOAD_FUNCPTR(cuModuleGetGlobal_v2);
      LOAD_FUNCPTR(cuModuleGetSurfRef);
      LOAD_FUNCPTR(cuModuleGetTexRef);
@@ -37,14 +37,38 @@ index 9aab6dda7d8..5d720ebed77 100644
      LOAD_FUNCPTR(cuModuleLoadData);
      LOAD_FUNCPTR(cuModuleLoadDataEx);
      LOAD_FUNCPTR(cuModuleLoadFatBinary);
-@@ -1882,6 +1885,25 @@ CUresult WINAPI wine_cuModuleGetTexRef(CUtexref *pTexRef, CUmodule hmod, const c
+@@ -1883,6 +1886,49 @@ CUresult WINAPI wine_cuModuleGetTexRef(CUtexref *pTexRef, CUmodule hmod, const c
      return pcuModuleGetTexRef(pTexRef, hmod, name);
  }
  
++/* FIXME: Should we pay attention to AreFileApisANSI() ? */
++static BOOL get_unix_path(ANSI_STRING *unix_name, const char *filename)
++{
++    UNICODE_STRING dospathW, ntpathW;
++    ANSI_STRING dospath;
++    NTSTATUS status;
++
++    RtlInitAnsiString(&dospath, filename);
++
++    if (RtlAnsiStringToUnicodeString(&dospathW, &dospath, TRUE))
++        return FALSE;
++
++    if (!RtlDosPathNameToNtPathName_U(dospathW.Buffer, &ntpathW, NULL, NULL))
++    {
++        RtlFreeUnicodeString(&dospathW);
++        return FALSE;
++    }
++
++    status = wine_nt_to_unix_file_name(&ntpathW, unix_name, FILE_OPEN);
++
++    RtlFreeUnicodeString(&ntpathW);
++    RtlFreeUnicodeString(&dospathW);
++    return !status;
++}
++
 +CUresult WINAPI wine_cuModuleLoad(CUmodule *module, const char *fname)
 +{
-+    WCHAR filenameW[MAX_PATH];
-+    char *unix_name;
++    ANSI_STRING unix_name;
 +    CUresult ret;
 +
 +    TRACE("(%p, %s)\n", module, fname);
@@ -52,11 +76,11 @@ index 9aab6dda7d8..5d720ebed77 100644
 +    if (!fname)
 +        return CUDA_ERROR_INVALID_VALUE;
 +
-+    MultiByteToWideChar(CP_ACP, 0, fname, -1, filenameW, ARRAY_SIZE(filenameW));
-+    unix_name = wine_get_unix_file_name( filenameW );
++    if (!get_unix_path(&unix_name, fname))
++        return CUDA_ERROR_FILE_NOT_FOUND;
 +
-+    ret = pcuModuleLoad(module, unix_name);
-+    HeapFree(GetProcessHeap(), 0, unix_name);
++    ret = pcuModuleLoad(module, unix_name.Buffer);
++    RtlFreeAnsiString(&unix_name);
 +    return ret;
 +}
 +
@@ -89,5 +113,5 @@ index 327fe4d8ef3..2bf20f9533e 100644
  #define CUDA_ERROR_NOT_SUPPORTED    801
  #define CUDA_ERROR_UNKNOWN          999
 -- 
-2.28.0
+2.27.0
 
diff --git a/patches/nvcuvid-CUDA_Video_Support/0001-nvcuvid-First-implementation.patch b/patches/nvcuvid-CUDA_Video_Support/0001-nvcuvid-First-implementation.patch
index 263901c5..ed89575c 100644
--- a/patches/nvcuvid-CUDA_Video_Support/0001-nvcuvid-First-implementation.patch
+++ b/patches/nvcuvid-CUDA_Video_Support/0001-nvcuvid-First-implementation.patch
@@ -1,19 +1,19 @@
-From c279f033d866661f9c2d7e090669a27c836b0579 Mon Sep 17 00:00:00 2001
+From ecde4f4f994831bbeb1029d93e0b06f815c503b2 Mon Sep 17 00:00:00 2001
 From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
 Date: Tue, 6 Jan 2015 05:16:36 +0100
-Subject: [PATCH] nvcuvid: First implementation. (rev 2)
+Subject: nvcuvid: First implementation. (rev 2)
 
 Changes by Sebastian Lackner <sebastian@fds-team.de>:
 * Convert structures properly where the Windows and Linux definition differs.
 ---
  configure.ac              |   1 +
  dlls/nvcuvid/Makefile.in  |   4 +
- dlls/nvcuvid/nvcuvid.c    | 512 ++++++++++++++++++++++++++++++++++++++
+ dlls/nvcuvid/nvcuvid.c    | 537 ++++++++++++++++++++++++++++++++++++++
  dlls/nvcuvid/nvcuvid.spec |  24 ++
  include/Makefile.in       |   2 +
- include/cuviddec.h        |  99 ++++++++
+ include/cuviddec.h        |  99 +++++++
  include/nvcuvid.h         |  79 ++++++
- 7 files changed, 721 insertions(+)
+ 7 files changed, 746 insertions(+)
  create mode 100644 dlls/nvcuvid/Makefile.in
  create mode 100644 dlls/nvcuvid/nvcuvid.c
  create mode 100644 dlls/nvcuvid/nvcuvid.spec
@@ -21,10 +21,10 @@ Changes by Sebastian Lackner <sebastian@fds-team.de>:
  create mode 100644 include/nvcuvid.h
 
 diff --git a/configure.ac b/configure.ac
-index d449af00211..a278e6d30ac 100644
+index e0d4af5b9d8..14bd257d826 100644
 --- a/configure.ac
 +++ b/configure.ac
-@@ -3612,6 +3612,7 @@ WINE_CONFIG_MAKEFILE(dlls/nvapi/tests)
+@@ -3589,6 +3589,7 @@ WINE_CONFIG_MAKEFILE(dlls/nvapi/tests)
  WINE_CONFIG_MAKEFILE(dlls/nvapi64,enable_win64)
  WINE_CONFIG_MAKEFILE(dlls/nvcuda)
  WINE_CONFIG_MAKEFILE(dlls/nvcuda/tests)
@@ -44,10 +44,10 @@ index 00000000000..2c2dc8ccf67
 +	nvcuvid.c
 diff --git a/dlls/nvcuvid/nvcuvid.c b/dlls/nvcuvid/nvcuvid.c
 new file mode 100644
-index 00000000000..616f883c329
+index 00000000000..2704bfa9a63
 --- /dev/null
 +++ b/dlls/nvcuvid/nvcuvid.c
-@@ -0,0 +1,512 @@
+@@ -0,0 +1,537 @@
 +/*
 + * Copyright (C) 2015 Michael Mller
 + *
@@ -73,7 +73,8 @@ index 00000000000..616f883c329
 +
 +#include "windef.h"
 +#include "winbase.h"
-+#include "winnls.h"
++#include "winternl.h"
++#include "wine/library.h"
 +#include "wine/debug.h"
 +#include "nvcuvid.h"
 +
@@ -319,12 +320,36 @@ index 00000000000..616f883c329
 +    return CUDA_SUCCESS;
 +}
 +
++/* FIXME: Should we pay attention to AreFileApisANSI() ? */
++static BOOL get_unix_path(ANSI_STRING *unix_name, const char *filename)
++{
++    UNICODE_STRING dospathW, ntpathW;
++    ANSI_STRING dospath;
++    NTSTATUS status;
++
++    RtlInitAnsiString(&dospath, filename);
++
++    if (RtlAnsiStringToUnicodeString(&dospathW, &dospath, TRUE))
++        return FALSE;
++
++    if (!RtlDosPathNameToNtPathName_U(dospathW.Buffer, &ntpathW, NULL, NULL))
++    {
++        RtlFreeUnicodeString(&dospathW);
++        return FALSE;
++    }
++
++    status = wine_nt_to_unix_file_name(&ntpathW, unix_name, FILE_OPEN);
++
++    RtlFreeUnicodeString(&ntpathW);
++    RtlFreeUnicodeString(&dospathW);
++    return !status;
++}
++
 +CUresult WINAPI wine_cuvidCreateVideoSource(CUvideosource *pObj, const char *pszFileName, CUVIDSOURCEPARAMS *pParams)
 +{
-+    WCHAR filenameW[MAX_PATH];
 +    struct fake_source *source;
 +    CUVIDSOURCEPARAMS fake_params;
-+    char *unix_name;
++    ANSI_STRING unix_name;
 +    CUresult ret;
 +
 +    TRACE("(%p, %s, %p)\n", pObj, pszFileName, pParams);
@@ -336,13 +361,13 @@ index 00000000000..616f883c329
 +    if (!pszFileName)
 +        return CUDA_ERROR_UNKNOWN;
 +
-+    MultiByteToWideChar(CP_ACP, 0, pszFileName, -1, filenameW, ARRAY_SIZE(filenameW));
-+    unix_name = wine_get_unix_file_name( filenameW );
++    if (!get_unix_path(&unix_name, pszFileName))
++        return CUDA_ERROR_UNKNOWN;
 +
 +    source = HeapAlloc(GetProcessHeap(), 0, sizeof(*source));
 +    if (!source)
 +    {
-+        HeapFree(GetProcessHeap(), 0, &unix_name);
++        RtlFreeAnsiString(&unix_name);
 +        return CUDA_ERROR_OUT_OF_MEMORY;
 +    }
 +
@@ -363,8 +388,8 @@ index 00000000000..616f883c329
 +    source->orig_data = pParams->pUserData;
 +    fake_params.pUserData = source;
 +
-+    ret = pcuvidCreateVideoSource((void *)&source->orig_source, unix_name, &fake_params);
-+    HeapFree(GetProcessHeap(), 0, &unix_name);
++    ret = pcuvidCreateVideoSource((void *)&source->orig_source, unix_name.Buffer, &fake_params);
++    RtlFreeAnsiString(&unix_name);
 +
 +    if (ret)
 +    {
@@ -591,10 +616,10 @@ index 00000000000..433e7db3b7e
 +@ stdcall cuvidSetVideoSourceState(ptr long) wine_cuvidSetVideoSourceState
 +@ stdcall cuvidUnmapVideoFrame(ptr long) wine_cuvidUnmapVideoFrame
 diff --git a/include/Makefile.in b/include/Makefile.in
-index 34daad90e78..22ed27ed968 100644
+index 3bb3f938747..3db2e16be76 100644
 --- a/include/Makefile.in
 +++ b/include/Makefile.in
-@@ -88,6 +88,7 @@ SOURCES = \
+@@ -87,6 +87,7 @@ SOURCES = \
  	ctxtcall.idl \
  	cuda.h \
  	custcntl.h \
@@ -602,7 +627,7 @@ index 34daad90e78..22ed27ed968 100644
  	cvconst.h \
  	d2d1.idl \
  	d2d1_1.idl \
-@@ -530,6 +531,7 @@ SOURCES = \
+@@ -527,6 +528,7 @@ SOURCES = \
  	ntsecpkg.h \
  	ntstatus.h \
  	nvapi.h \
@@ -801,5 +826,5 @@ index 00000000000..a192ef64c2e
 +
 +#endif /* __WINE_NVCUVID_H */
 -- 
-2.28.0
+2.27.0
 
diff --git a/patches/nvencodeapi-Video_Encoder/0001-nvencodeapi-First-implementation.patch b/patches/nvencodeapi-Video_Encoder/0001-nvencodeapi-First-implementation.patch
index e7986a4e..31fb734d 100644
--- a/patches/nvencodeapi-Video_Encoder/0001-nvencodeapi-First-implementation.patch
+++ b/patches/nvencodeapi-Video_Encoder/0001-nvencodeapi-First-implementation.patch
@@ -1,4 +1,4 @@
-From 12499caabc7010d8ba89f3886ecdadd636cbc123 Mon Sep 17 00:00:00 2001
+From aaf02d5e9c8e3d5d90ac3a1bae16df9669385011 Mon Sep 17 00:00:00 2001
 From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
 Date: Sun, 8 Feb 2015 06:10:26 +0100
 Subject: [PATCH] nvencodeapi: First implementation.
@@ -6,13 +6,13 @@ Subject: [PATCH] nvencodeapi: First implementation.
 ---
  configure.ac                          |   2 +
  dlls/nvencodeapi/Makefile.in          |   4 +
- dlls/nvencodeapi/nvencodeapi.c        | 369 ++++++++++++++++++++++++++
+ dlls/nvencodeapi/nvencodeapi.c        | 370 ++++++++++++++++++++++++++
  dlls/nvencodeapi/nvencodeapi.spec     |   1 +
  dlls/nvencodeapi64/Makefile.in        |   5 +
  dlls/nvencodeapi64/nvencodeapi64.spec |   1 +
  include/Makefile.in                   |   1 +
- include/nvencodeapi.h                 | 281 ++++++++++++++++++++
- 8 files changed, 664 insertions(+)
+ include/nvencodeapi.h                 | 281 +++++++++++++++++++
+ 8 files changed, 665 insertions(+)
  create mode 100644 dlls/nvencodeapi/Makefile.in
  create mode 100644 dlls/nvencodeapi/nvencodeapi.c
  create mode 100644 dlls/nvencodeapi/nvencodeapi.spec
@@ -21,10 +21,10 @@ Subject: [PATCH] nvencodeapi: First implementation.
  create mode 100644 include/nvencodeapi.h
 
 diff --git a/configure.ac b/configure.ac
-index a278e6d30ac..3df3fb9ae18 100644
+index 326d03975..a2f06d7ff 100644
 --- a/configure.ac
 +++ b/configure.ac
-@@ -3613,6 +3613,8 @@ WINE_CONFIG_MAKEFILE(dlls/nvapi64,enable_win64)
+@@ -3555,6 +3555,8 @@ WINE_CONFIG_MAKEFILE(dlls/nvapi64,enable_win64)
  WINE_CONFIG_MAKEFILE(dlls/nvcuda)
  WINE_CONFIG_MAKEFILE(dlls/nvcuda/tests)
  WINE_CONFIG_MAKEFILE(dlls/nvcuvid)
@@ -35,7 +35,7 @@ index a278e6d30ac..3df3fb9ae18 100644
  WINE_CONFIG_MAKEFILE(dlls/odbcbcp)
 diff --git a/dlls/nvencodeapi/Makefile.in b/dlls/nvencodeapi/Makefile.in
 new file mode 100644
-index 00000000000..a2e58acaf0d
+index 000000000..a2e58acaf
 --- /dev/null
 +++ b/dlls/nvencodeapi/Makefile.in
 @@ -0,0 +1,4 @@
@@ -45,10 +45,10 @@ index 00000000000..a2e58acaf0d
 +	nvencodeapi.c
 diff --git a/dlls/nvencodeapi/nvencodeapi.c b/dlls/nvencodeapi/nvencodeapi.c
 new file mode 100644
-index 00000000000..40be216485f
+index 000000000..91a33fd58
 --- /dev/null
 +++ b/dlls/nvencodeapi/nvencodeapi.c
-@@ -0,0 +1,369 @@
+@@ -0,0 +1,370 @@
 +/*
 + * Copyright (C) 2015 Michael Mller
 + *
@@ -75,6 +75,7 @@ index 00000000000..40be216485f
 +#include "windef.h"
 +#include "winbase.h"
 +#include "wine/debug.h"
++#include "wine/library.h"
 +
 +#include "nvencodeapi.h"
 +
@@ -420,14 +421,14 @@ index 00000000000..40be216485f
 +}
 diff --git a/dlls/nvencodeapi/nvencodeapi.spec b/dlls/nvencodeapi/nvencodeapi.spec
 new file mode 100644
-index 00000000000..11d74e82d99
+index 000000000..11d74e82d
 --- /dev/null
 +++ b/dlls/nvencodeapi/nvencodeapi.spec
 @@ -0,0 +1 @@
 +@ stdcall NvEncodeAPICreateInstance(ptr)
 diff --git a/dlls/nvencodeapi64/Makefile.in b/dlls/nvencodeapi64/Makefile.in
 new file mode 100644
-index 00000000000..8297ec352b5
+index 000000000..8297ec352
 --- /dev/null
 +++ b/dlls/nvencodeapi64/Makefile.in
 @@ -0,0 +1,5 @@
@@ -438,16 +439,16 @@ index 00000000000..8297ec352b5
 +	nvencodeapi.c
 diff --git a/dlls/nvencodeapi64/nvencodeapi64.spec b/dlls/nvencodeapi64/nvencodeapi64.spec
 new file mode 100644
-index 00000000000..11d74e82d99
+index 000000000..11d74e82d
 --- /dev/null
 +++ b/dlls/nvencodeapi64/nvencodeapi64.spec
 @@ -0,0 +1 @@
 +@ stdcall NvEncodeAPICreateInstance(ptr)
 diff --git a/include/Makefile.in b/include/Makefile.in
-index 22ed27ed968..667b4640d80 100644
+index c38dd2ad1..5b21ec0df 100644
 --- a/include/Makefile.in
 +++ b/include/Makefile.in
-@@ -532,6 +532,7 @@ SOURCES = \
+@@ -500,6 +500,7 @@ SOURCES = \
  	ntstatus.h \
  	nvapi.h \
  	nvcuvid.h \
@@ -457,7 +458,7 @@ index 22ed27ed968..667b4640d80 100644
  	objectarray.idl \
 diff --git a/include/nvencodeapi.h b/include/nvencodeapi.h
 new file mode 100644
-index 00000000000..45e9fb97f16
+index 000000000..45e9fb97f
 --- /dev/null
 +++ b/include/nvencodeapi.h
 @@ -0,0 +1,281 @@
@@ -743,5 +744,5 @@ index 00000000000..45e9fb97f16
 +
 +#endif /* __WINE_NVENCODEAPI_H */
 -- 
-2.28.0
+2.24.0
 
diff --git a/patches/patchinstall.sh b/patches/patchinstall.sh
index ffb9da02..10787242 100755
--- a/patches/patchinstall.sh
+++ b/patches/patchinstall.sh
@@ -34,6 +34,7 @@ usage()
 	echo "  --force-autoconf     Run autoreconf and tools/make_requests after each patch"
 	echo "  --help               Display this help and exit"
 	echo "  --no-autoconf        Do not run autoreconf and tools/make_requests"
+	echo "  --no-patchlist       Do not apply patchlist (needed for 'wine --patches')"
 	echo "  --upstream-commit    Print the upstream Wine commit SHA1 and exit"
 	echo "  --version            Show version information and exit"
 	echo "  -W patchset          Exclude a specific patchset"
@@ -85,7 +86,9 @@ patch_enable_all ()
 	enable_Compiler_Warnings="$1"
 	enable_Pipelight="$1"
 	enable_Staging="$1"
+	enable_advapi32_CreateRestrictedToken="$1"
 	enable_advapi32_LsaLookupPrivilegeName="$1"
+	enable_advapi32_Token_Integrity_Level="$1"
 	enable_api_ms_win_Stub_DLLs="$1"
 	enable_atl_AtlAxDialogBox="$1"
 	enable_bcrypt_ECDHSecretAgreement="$1"
@@ -95,6 +98,7 @@ patch_enable_all ()
 	enable_comctl32_rebar_capture="$1"
 	enable_comctl32_version_6="$1"
 	enable_comdlg32_lpstrFileTitle="$1"
+	enable_configure_Absolute_RPATH="$1"
 	enable_crypt32_CMS_Certificates="$1"
 	enable_cryptext_CryptExtOpenCER="$1"
 	enable_d3d11_Deferred_Context="$1"
@@ -127,6 +131,7 @@ patch_enable_all ()
 	enable_dwrite_FontFallback="$1"
 	enable_dxdiagn_Enumerate_DirectSound="$1"
 	enable_dxdiagn_GetChildContainer_Leaf_Nodes="$1"
+	enable_eventfd_synchronization="$1"
 	enable_explorer_Video_Registry_Key="$1"
 	enable_fonts_Missing_Fonts="$1"
 	enable_gdi32_Lazy_Font_Initialization="$1"
@@ -141,6 +146,7 @@ patch_enable_all ()
 	enable_kernel32_Debugger="$1"
 	enable_kernel32_FindFirstFile="$1"
 	enable_kernel32_Job_Tests="$1"
+	enable_kernel32_K32GetPerformanceInfo="$1"
 	enable_kernel32_Processor_Group="$1"
 	enable_kernel32_SetProcessDEPPolicy="$1"
 	enable_krnl386_exe16_GDT_LDT_Emulation="$1"
@@ -164,6 +170,7 @@ patch_enable_all ()
 	enable_ntdll_CriticalSection="$1"
 	enable_ntdll_DOS_Attributes="$1"
 	enable_ntdll_Dealloc_Thread_Stack="$1"
+	enable_ntdll_DeviceType_Systemroot="$1"
 	enable_ntdll_Exception="$1"
 	enable_ntdll_FLS_Callbacks="$1"
 	enable_ntdll_FileDispositionInformation="$1"
@@ -177,12 +184,15 @@ patch_enable_all ()
 	enable_ntdll_Junction_Points="$1"
 	enable_ntdll_Manifest_Range="$1"
 	enable_ntdll_NtAccessCheck="$1"
+	enable_ntdll_NtContinue="$1"
 	enable_ntdll_NtDevicePath="$1"
 	enable_ntdll_NtQueryEaFile="$1"
 	enable_ntdll_NtQuerySection="$1"
+	enable_ntdll_NtQueryVirtualMemory="$1"
 	enable_ntdll_NtSetLdtEntries="$1"
 	enable_ntdll_Pipe_SpecialCharacters="$1"
 	enable_ntdll_ProcessQuotaLimits="$1"
+	enable_ntdll_RtlCreateUserThread="$1"
 	enable_ntdll_RtlQueryPackageIdentity="$1"
 	enable_ntdll_RtlQueryRegistryValuesEx="$1"
 	enable_ntdll_Serial_Port_Detection="$1"
@@ -190,7 +200,11 @@ patch_enable_all ()
 	enable_ntdll_Syscall_Emulation="$1"
 	enable_ntdll_SystemCodeIntegrityInformation="$1"
 	enable_ntdll_SystemExtendedProcessInformation="$1"
+	enable_ntdll_SystemInterruptInformation="$1"
 	enable_ntdll_SystemModuleInformation="$1"
+	enable_ntdll_SystemRoot_Symlink="$1"
+	enable_ntdll_ThreadTime="$1"
+	enable_ntdll_Threading="$1"
 	enable_ntdll_WRITECOPY="$1"
 	enable_ntdll_Zero_mod_name="$1"
 	enable_ntdll_aarch_TEB="$1"
@@ -218,11 +232,11 @@ patch_enable_all ()
 	enable_server_FileEndOfFileInformation="$1"
 	enable_server_File_Permissions="$1"
 	enable_server_Inherited_ACLs="$1"
-	enable_server_Key_State="$1"
 	enable_server_Object_Types="$1"
 	enable_server_PeekMessage="$1"
 	enable_server_Realtime_Priority="$1"
 	enable_server_Registry_Notifications="$1"
+	enable_server_Shared_Memory="$1"
 	enable_server_Signal_Thread="$1"
 	enable_server_Stored_ACLs="$1"
 	enable_setupapi_DiskSpaceList="$1"
@@ -285,7 +299,7 @@ patch_enable_all ()
 	enable_wineboot_HKEY_DYN_DATA="$1"
 	enable_wineboot_ProxySettings="$1"
 	enable_wineboot_drivers_etc_Stubs="$1"
-	enable_winebuild_pe_syscall_thunks="$1"
+	enable_winebuild_Fake_Dlls="$1"
 	enable_winecfg_Libraries="$1"
 	enable_winecfg_Staging="$1"
 	enable_wined3d_Accounting="$1"
@@ -305,6 +319,7 @@ patch_enable_all ()
 	enable_winemenubuilder_integration="$1"
 	enable_wineps_drv_PostScript_Fixes="$1"
 	enable_winepulse_PulseAudio_Support="$1"
+	enable_winevulkan_vkGetPhysicalDeviceSurfaceCapabilitiesKHR="$1"
 	enable_winex11_CandidateWindowPos="$1"
 	enable_winex11_MWM_Decorations="$1"
 	enable_winex11_UpdateLayeredWindow="$1"
@@ -328,6 +343,7 @@ patch_enable_all ()
 	enable_wpcap_Dynamic_Linking="$1"
 	enable_ws2_32_APC_Performance="$1"
 	enable_ws2_32_Connect_Time="$1"
+	enable_ws2_32_TransmitFile="$1"
 	enable_ws2_32_getaddrinfo="$1"
 	enable_ws2_32_getsockopt="$1"
 	enable_wtsapi32_EnumerateProcesses="$1"
@@ -349,9 +365,15 @@ patch_enable ()
 		Staging)
 			enable_Staging="$2"
 			;;
+		advapi32-CreateRestrictedToken)
+			enable_advapi32_CreateRestrictedToken="$2"
+			;;
 		advapi32-LsaLookupPrivilegeName)
 			enable_advapi32_LsaLookupPrivilegeName="$2"
 			;;
+		advapi32-Token_Integrity_Level)
+			enable_advapi32_Token_Integrity_Level="$2"
+			;;
 		api-ms-win-Stub_DLLs)
 			enable_api_ms_win_Stub_DLLs="$2"
 			;;
@@ -379,6 +401,9 @@ patch_enable ()
 		comdlg32-lpstrFileTitle)
 			enable_comdlg32_lpstrFileTitle="$2"
 			;;
+		configure-Absolute_RPATH)
+			enable_configure_Absolute_RPATH="$2"
+			;;
 		crypt32-CMS_Certificates)
 			enable_crypt32_CMS_Certificates="$2"
 			;;
@@ -475,6 +500,9 @@ patch_enable ()
 		dxdiagn-GetChildContainer_Leaf_Nodes)
 			enable_dxdiagn_GetChildContainer_Leaf_Nodes="$2"
 			;;
+		eventfd_synchronization)
+			enable_eventfd_synchronization="$2"
+			;;
 		explorer-Video_Registry_Key)
 			enable_explorer_Video_Registry_Key="$2"
 			;;
@@ -517,6 +545,9 @@ patch_enable ()
 		kernel32-Job_Tests)
 			enable_kernel32_Job_Tests="$2"
 			;;
+		kernel32-K32GetPerformanceInfo)
+			enable_kernel32_K32GetPerformanceInfo="$2"
+			;;
 		kernel32-Processor_Group)
 			enable_kernel32_Processor_Group="$2"
 			;;
@@ -586,6 +617,9 @@ patch_enable ()
 		ntdll-Dealloc_Thread_Stack)
 			enable_ntdll_Dealloc_Thread_Stack="$2"
 			;;
+		ntdll-DeviceType_Systemroot)
+			enable_ntdll_DeviceType_Systemroot="$2"
+			;;
 		ntdll-Exception)
 			enable_ntdll_Exception="$2"
 			;;
@@ -625,6 +659,9 @@ patch_enable ()
 		ntdll-NtAccessCheck)
 			enable_ntdll_NtAccessCheck="$2"
 			;;
+		ntdll-NtContinue)
+			enable_ntdll_NtContinue="$2"
+			;;
 		ntdll-NtDevicePath)
 			enable_ntdll_NtDevicePath="$2"
 			;;
@@ -634,6 +671,9 @@ patch_enable ()
 		ntdll-NtQuerySection)
 			enable_ntdll_NtQuerySection="$2"
 			;;
+		ntdll-NtQueryVirtualMemory)
+			enable_ntdll_NtQueryVirtualMemory="$2"
+			;;
 		ntdll-NtSetLdtEntries)
 			enable_ntdll_NtSetLdtEntries="$2"
 			;;
@@ -643,6 +683,9 @@ patch_enable ()
 		ntdll-ProcessQuotaLimits)
 			enable_ntdll_ProcessQuotaLimits="$2"
 			;;
+		ntdll-RtlCreateUserThread)
+			enable_ntdll_RtlCreateUserThread="$2"
+			;;
 		ntdll-RtlQueryPackageIdentity)
 			enable_ntdll_RtlQueryPackageIdentity="$2"
 			;;
@@ -664,9 +707,21 @@ patch_enable ()
 		ntdll-SystemExtendedProcessInformation)
 			enable_ntdll_SystemExtendedProcessInformation="$2"
 			;;
+		ntdll-SystemInterruptInformation)
+			enable_ntdll_SystemInterruptInformation="$2"
+			;;
 		ntdll-SystemModuleInformation)
 			enable_ntdll_SystemModuleInformation="$2"
 			;;
+		ntdll-SystemRoot_Symlink)
+			enable_ntdll_SystemRoot_Symlink="$2"
+			;;
+		ntdll-ThreadTime)
+			enable_ntdll_ThreadTime="$2"
+			;;
+		ntdll-Threading)
+			enable_ntdll_Threading="$2"
+			;;
 		ntdll-WRITECOPY)
 			enable_ntdll_WRITECOPY="$2"
 			;;
@@ -748,9 +803,6 @@ patch_enable ()
 		server-Inherited_ACLs)
 			enable_server_Inherited_ACLs="$2"
 			;;
-		server-Key_State)
-			enable_server_Key_State="$2"
-			;;
 		server-Object_Types)
 			enable_server_Object_Types="$2"
 			;;
@@ -763,6 +815,9 @@ patch_enable ()
 		server-Registry_Notifications)
 			enable_server_Registry_Notifications="$2"
 			;;
+		server-Shared_Memory)
+			enable_server_Shared_Memory="$2"
+			;;
 		server-Signal_Thread)
 			enable_server_Signal_Thread="$2"
 			;;
@@ -949,8 +1004,8 @@ patch_enable ()
 		wineboot-drivers_etc_Stubs)
 			enable_wineboot_drivers_etc_Stubs="$2"
 			;;
-		winebuild-pe_syscall_thunks)
-			enable_winebuild_pe_syscall_thunks="$2"
+		winebuild-Fake_Dlls)
+			enable_winebuild_Fake_Dlls="$2"
 			;;
 		winecfg-Libraries)
 			enable_winecfg_Libraries="$2"
@@ -1078,6 +1133,9 @@ patch_enable ()
 		ws2_32-Connect_Time)
 			enable_ws2_32_Connect_Time="$2"
 			;;
+		ws2_32-TransmitFile)
+			enable_ws2_32_TransmitFile="$2"
+			;;
 		ws2_32-getaddrinfo)
 			enable_ws2_32_getaddrinfo="$2"
 			;;
@@ -1105,7 +1163,9 @@ patch_enable ()
 
 # Default settings
 patch_enable_all 0
+enable_patchlist=1
 enable_autoconf=1
+patchlist="/dev/null"
 backend="patch"
 
 # Find location of patches
@@ -1150,6 +1210,11 @@ while test "$#" -gt 0; do
 			exit 0
 			;;
 
+		--no-patchlist)
+			enable_patchlist=0
+			shift
+			;;
+
 		--no-autoconf)
 			enable_autoconf=0
 			shift
@@ -1421,6 +1486,7 @@ elif test "$backend" = "stg"; then
 
 	# Only import the regular patches, no autogenerated ones -
 	# moreover, don't run autoreconf or ./tools/make_requests.
+	enable_patchlist=0
 	enable_autoconf=0
 
 	patch_apply_file()
@@ -1443,6 +1509,13 @@ patch_apply()
 }
 
 
+if test "$enable_wow64cpu_Wow64Transition" -eq 1; then
+	if test "$enable_advapi32_Token_Integrity_Level" -gt 1; then
+		abort "Patchset advapi32-Token_Integrity_Level disabled, but wow64cpu-Wow64Transition depends on that."
+	fi
+	enable_advapi32_Token_Integrity_Level=1
+fi
+
 if test "$enable_winex11_WM_WINDOWPOSCHANGING" -eq 1; then
 	if test "$enable_winex11__NET_ACTIVE_WINDOW" -gt 1; then
 		abort "Patchset winex11-_NET_ACTIVE_WINDOW disabled, but winex11-WM_WINDOWPOSCHANGING depends on that."
@@ -1557,10 +1630,10 @@ if test "$enable_shell32_Progress_Dialog" -eq 1; then
 fi
 
 if test "$enable_server_Object_Types" -eq 1; then
-	if test "$enable_ntdll_SystemModuleInformation" -gt 1; then
-		abort "Patchset ntdll-SystemModuleInformation disabled, but server-Object_Types depends on that."
+	if test "$enable_server_Shared_Memory" -gt 1; then
+		abort "Patchset server-Shared_Memory disabled, but server-Object_Types depends on that."
 	fi
-	enable_ntdll_SystemModuleInformation=1
+	enable_server_Shared_Memory=1
 fi
 
 if test "$enable_server_Inherited_ACLs" -eq 1; then
@@ -1581,13 +1654,6 @@ if test "$enable_server_Stored_ACLs" -eq 1; then
 	enable_server_File_Permissions=1
 fi
 
-if test "$enable_server_File_Permissions" -eq 1; then
-	if test "$enable_ntdll_Junction_Points" -gt 1; then
-		abort "Patchset ntdll-Junction_Points disabled, but server-File_Permissions depends on that."
-	fi
-	enable_ntdll_Junction_Points=1
-fi
-
 if test "$enable_oleaut32_OLEPictureImpl_SaveAsFile" -eq 1; then
 	if test "$enable_oleaut32_Load_Save_EMF" -gt 1; then
 		abort "Patchset oleaut32-Load_Save_EMF disabled, but oleaut32-OLEPictureImpl_SaveAsFile depends on that."
@@ -1617,10 +1683,24 @@ if test "$enable_ntdll_SystemCodeIntegrityInformation" -eq 1; then
 fi
 
 if test "$enable_ntdll_Syscall_Emulation" -eq 1; then
-	if test "$enable_winebuild_pe_syscall_thunks" -gt 1; then
-		abort "Patchset winebuild-pe_syscall_thunks disabled, but ntdll-Syscall_Emulation depends on that."
+	if test "$enable_winebuild_Fake_Dlls" -gt 1; then
+		abort "Patchset winebuild-Fake_Dlls disabled, but ntdll-Syscall_Emulation depends on that."
 	fi
-	enable_winebuild_pe_syscall_thunks=1
+	enable_winebuild_Fake_Dlls=1
+fi
+
+if test "$enable_ntdll_NtQueryVirtualMemory" -eq 1; then
+	if test "$enable_ntdll_NtDevicePath" -gt 1; then
+		abort "Patchset ntdll-NtDevicePath disabled, but ntdll-NtQueryVirtualMemory depends on that."
+	fi
+	enable_ntdll_NtDevicePath=1
+fi
+
+if test "$enable_ntdll_NtQueryEaFile" -eq 1; then
+	if test "$enable_ntdll_Junction_Points" -gt 1; then
+		abort "Patchset ntdll-Junction_Points disabled, but ntdll-NtQueryEaFile depends on that."
+	fi
+	enable_ntdll_Junction_Points=1
 fi
 
 if test "$enable_ntdll_NtDevicePath" -eq 1; then
@@ -1630,15 +1710,29 @@ if test "$enable_ntdll_NtDevicePath" -eq 1; then
 	enable_ntdll_Pipe_SpecialCharacters=1
 fi
 
-if test "$enable_ntdll_Junction_Points" -eq 1; then
-	if test "$enable_ntdll_DOS_Attributes" -gt 1; then
-		abort "Patchset ntdll-DOS_Attributes disabled, but ntdll-Junction_Points depends on that."
+if test "$enable_ntdll_NtContinue" -eq 1; then
+	if test "$enable_winebuild_Fake_Dlls" -gt 1; then
+		abort "Patchset winebuild-Fake_Dlls disabled, but ntdll-NtContinue depends on that."
 	fi
-	if test "$enable_ntdll_NtQueryEaFile" -gt 1; then
-		abort "Patchset ntdll-NtQueryEaFile disabled, but ntdll-Junction_Points depends on that."
+	enable_winebuild_Fake_Dlls=1
+fi
+
+if test "$enable_ntdll_Hide_Wine_Exports" -eq 1; then
+	if test "$enable_advapi32_Token_Integrity_Level" -gt 1; then
+		abort "Patchset advapi32-Token_Integrity_Level disabled, but ntdll-Hide_Wine_Exports depends on that."
 	fi
-	enable_ntdll_DOS_Attributes=1
-	enable_ntdll_NtQueryEaFile=1
+	if test "$enable_ntdll_ThreadTime" -gt 1; then
+		abort "Patchset ntdll-ThreadTime disabled, but ntdll-Hide_Wine_Exports depends on that."
+	fi
+	enable_advapi32_Token_Integrity_Level=1
+	enable_ntdll_ThreadTime=1
+fi
+
+if test "$enable_ntdll_DOS_Attributes" -eq 1; then
+	if test "$enable_ntdll_Junction_Points" -gt 1; then
+		abort "Patchset ntdll-Junction_Points disabled, but ntdll-DOS_Attributes depends on that."
+	fi
+	enable_ntdll_Junction_Points=1
 fi
 
 if test "$enable_ntdll_Builtin_Prot" -eq 1; then
@@ -1648,18 +1742,11 @@ if test "$enable_ntdll_Builtin_Prot" -eq 1; then
 	enable_ntdll_WRITECOPY=1
 fi
 
-if test "$enable_ntdll_WRITECOPY" -eq 1; then
-	if test "$enable_ntdll_ForceBottomUpAlloc" -gt 1; then
-		abort "Patchset ntdll-ForceBottomUpAlloc disabled, but ntdll-WRITECOPY depends on that."
-	fi
-	enable_ntdll_ForceBottomUpAlloc=1
-fi
-
 if test "$enable_ntdll_ApiSetMap" -eq 1; then
-	if test "$enable_ntdll_FLS_Callbacks" -gt 1; then
-		abort "Patchset ntdll-FLS_Callbacks disabled, but ntdll-ApiSetMap depends on that."
+	if test "$enable_ntdll_ThreadTime" -gt 1; then
+		abort "Patchset ntdll-ThreadTime disabled, but ntdll-ApiSetMap depends on that."
 	fi
-	enable_ntdll_FLS_Callbacks=1
+	enable_ntdll_ThreadTime=1
 fi
 
 if test "$enable_kernel32_Processor_Group" -eq 1; then
@@ -1676,6 +1763,81 @@ if test "$enable_kernel32_CopyFileEx" -eq 1; then
 	enable_ntdll_FileDispositionInformation=1
 fi
 
+if test "$enable_ntdll_FileDispositionInformation" -eq 1; then
+	if test "$enable_server_File_Permissions" -gt 1; then
+		abort "Patchset server-File_Permissions disabled, but ntdll-FileDispositionInformation depends on that."
+	fi
+	enable_server_File_Permissions=1
+fi
+
+if test "$enable_server_File_Permissions" -eq 1; then
+	if test "$enable_ntdll_Junction_Points" -gt 1; then
+		abort "Patchset ntdll-Junction_Points disabled, but server-File_Permissions depends on that."
+	fi
+	enable_ntdll_Junction_Points=1
+fi
+
+if test "$enable_eventfd_synchronization" -eq 1; then
+	if test "$enable_advapi32_Token_Integrity_Level" -gt 1; then
+		abort "Patchset advapi32-Token_Integrity_Level disabled, but eventfd_synchronization depends on that."
+	fi
+	if test "$enable_kernel32_K32GetPerformanceInfo" -gt 1; then
+		abort "Patchset kernel32-K32GetPerformanceInfo disabled, but eventfd_synchronization depends on that."
+	fi
+	if test "$enable_ntdll_Junction_Points" -gt 1; then
+		abort "Patchset ntdll-Junction_Points disabled, but eventfd_synchronization depends on that."
+	fi
+	if test "$enable_ntdll_RtlCreateUserThread" -gt 1; then
+		abort "Patchset ntdll-RtlCreateUserThread disabled, but eventfd_synchronization depends on that."
+	fi
+	if test "$enable_server_Realtime_Priority" -gt 1; then
+		abort "Patchset server-Realtime_Priority disabled, but eventfd_synchronization depends on that."
+	fi
+	if test "$enable_server_Shared_Memory" -gt 1; then
+		abort "Patchset server-Shared_Memory disabled, but eventfd_synchronization depends on that."
+	fi
+	enable_advapi32_Token_Integrity_Level=1
+	enable_kernel32_K32GetPerformanceInfo=1
+	enable_ntdll_Junction_Points=1
+	enable_ntdll_RtlCreateUserThread=1
+	enable_ntdll_SystemRoot_Symlink=1
+	enable_server_Realtime_Priority=1
+	enable_server_Shared_Memory=1
+fi
+
+if test "$enable_server_Shared_Memory" -eq 1; then
+	if test "$enable_ntdll_Threading" -gt 1; then
+		abort "Patchset ntdll-Threading disabled, but server-Shared_Memory depends on that."
+	fi
+	if test "$enable_ntdll_ext4_case_folder" -gt 1; then
+		abort "Patchset ntdll-ext4-case-folder disabled, but server-Shared_Memory depends on that."
+	fi
+	if test "$enable_server_PeekMessage" -gt 1; then
+		abort "Patchset server-PeekMessage disabled, but server-Shared_Memory depends on that."
+	fi
+	if test "$enable_server_Signal_Thread" -gt 1; then
+		abort "Patchset server-Signal_Thread disabled, but server-Shared_Memory depends on that."
+	fi
+	enable_ntdll_Threading=1
+	enable_ntdll_ext4_case_folder=1
+	enable_server_PeekMessage=1
+	enable_server_Signal_Thread=1
+fi
+
+if test "$enable_server_Realtime_Priority" -eq 1; then
+	if test "$enable_ntdll_ThreadTime" -gt 1; then
+		abort "Patchset ntdll-ThreadTime disabled, but server-Realtime_Priority depends on that."
+	fi
+	enable_ntdll_ThreadTime=1
+fi
+
+if test "$enable_ntdll_RtlCreateUserThread" -eq 1; then
+	if test "$enable_winebuild_Fake_Dlls" -gt 1; then
+		abort "Patchset winebuild-Fake_Dlls disabled, but ntdll-RtlCreateUserThread depends on that."
+	fi
+	enable_winebuild_Fake_Dlls=1
+fi
+
 if test "$enable_dxdiagn_GetChildContainer_Leaf_Nodes" -eq 1; then
 	if test "$enable_dxdiagn_Enumerate_DirectSound" -gt 1; then
 		abort "Patchset dxdiagn-Enumerate_DirectSound disabled, but dxdiagn-GetChildContainer_Leaf_Nodes depends on that."
@@ -1725,11 +1887,30 @@ if test "$enable_nvapi_Stub_DLL" -eq 1; then
 	enable_nvcuda_CUDA_Support=1
 fi
 
-if test "$enable_Staging" -eq 1; then
-	if test "$enable_ntdll_FLS_Callbacks" -gt 1; then
-		abort "Patchset ntdll-FLS_Callbacks disabled, but Staging depends on that."
+if test "$enable_advapi32_Token_Integrity_Level" -eq 1; then
+	if test "$enable_Staging" -gt 1; then
+		abort "Patchset Staging disabled, but advapi32-Token_Integrity_Level depends on that."
+	fi
+	if test "$enable_advapi32_CreateRestrictedToken" -gt 1; then
+		abort "Patchset advapi32-CreateRestrictedToken disabled, but advapi32-Token_Integrity_Level depends on that."
+	fi
+	enable_Staging=1
+	enable_advapi32_CreateRestrictedToken=1
+fi
+
+
+# If autoupdate is enabled then create a tempfile to keep track of all patches
+if test "$enable_patchlist" -eq 1; then
+	if test "$enable_Staging" -eq 1; then
+		# macOS 10.10 and prior do not allow mktemp with empty argument
+		patchlist=$(mktemp 2>/dev/null || mktemp -t tmp)
+		if test ! -f "$patchlist"; then
+			abort "Unable to create temporary file for patchlist."
+		fi
+	else
+		warning "Skipping generation of patchlist because 'Staging' patchset is disabled."
+		enable_patchlist=0
 	fi
-	enable_ntdll_FLS_Callbacks=1
 fi
 
 
@@ -1770,35 +1951,30 @@ if test "$enable_Pipelight" -eq 1; then
 	patch_apply Pipelight/0004-winex11.drv-Indicate-direct-rendering-through-OpenGL.patch
 fi
 
-# Patchset ntdll-FLS_Callbacks
-# |
-# | This patchset fixes the following Wine bugs:
-# |   *	[#49012] Application build with .NET CoreRT crashes due to FLS callbacks not being called
+# Patchset Staging
 # |
 # | Modified files:
-# |   *	dlls/kernel32/tests/fiber.c, dlls/kernel32/tests/loader.c, dlls/kernel32/tests/thread.c, dlls/kernelbase/thread.c,
-# | 	dlls/ntdll/loader.c
+# |   *	dlls/kernel32/process.c, dlls/ntdll/Makefile.in, include/wine/library.h, libs/wine/Makefile.in, libs/wine/config.c,
+# | 	libs/wine/wine.map, loader/main.c
 # |
-if test "$enable_ntdll_FLS_Callbacks" -eq 1; then
-	patch_apply ntdll-FLS_Callbacks/0001-kernelbase-Maintain-FLS-storage-list-in-PEB.patch
-	patch_apply ntdll-FLS_Callbacks/0002-kernelbase-Don-t-use-PEB-lock-for-FLS-data.patch
-	patch_apply ntdll-FLS_Callbacks/0003-kernelbase-Zero-all-FLS-slots-instances-in-FlsFree.patch
-	patch_apply ntdll-FLS_Callbacks/0004-ntdll-Call-FLS-callbacks-on-thread-shutdown.patch
-	patch_apply ntdll-FLS_Callbacks/0005-kernelbase-Call-FLS-callbacks-from-FlsFree.patch
-	patch_apply ntdll-FLS_Callbacks/0006-kernelbase-Call-FLS-callbacks-from-DeleteFiber.patch
+if test "$enable_Staging" -eq 1; then
+	patch_apply Staging/0001-kernel32-Add-winediag-message-to-show-warning-that-t.patch
+	patch_apply Staging/0002-winelib-Append-Staging-at-the-end-of-the-version-s.patch
+	patch_apply Staging/0003-loader-Add-commandline-option-patches-to-show-the-pa.patch
 fi
 
-# Patchset Staging
+# Patchset advapi32-CreateRestrictedToken
 # |
-# | This patchset has the following (direct or indirect) dependencies:
-# |   *	ntdll-FLS_Callbacks
+# | This patchset fixes the following Wine bugs:
+# |   *	[#25834] Implement advapi32.CreateRestrictedToken
 # |
 # | Modified files:
-# |   *	Makefile.in, dlls/ntdll/Makefile.in, dlls/ntdll/loader.c
+# |   *	dlls/kernelbase/security.c, dlls/ntdll/nt.c, dlls/ntdll/ntdll.spec, include/winnt.h, include/winternl.h,
+# | 	server/process.c, server/protocol.def, server/security.h, server/token.c
 # |
-if test "$enable_Staging" -eq 1; then
-	patch_apply Staging/0001-kernel32-Add-winediag-message-to-show-warning-that-t.patch
-	patch_apply Staging/0002-winelib-Append-Staging-at-the-end-of-the-version-s.patch
+if test "$enable_advapi32_CreateRestrictedToken" -eq 1; then
+	patch_apply advapi32-CreateRestrictedToken/0001-ntdll-Implement-NtFilterToken.patch
+	patch_apply advapi32-CreateRestrictedToken/0002-advapi32-Implement-CreateRestrictedToken.patch
 fi
 
 # Patchset advapi32-LsaLookupPrivilegeName
@@ -1811,6 +1987,38 @@ if test "$enable_advapi32_LsaLookupPrivilegeName" -eq 1; then
 	patch_apply advapi32-LsaLookupPrivilegeName/0002-advapi32-Use-TRACE-for-LsaOpenPolicy-LsaClose.patch
 fi
 
+# Patchset advapi32-Token_Integrity_Level
+# |
+# | This patchset has the following (direct or indirect) dependencies:
+# |   *	Staging, advapi32-CreateRestrictedToken
+# |
+# | This patchset fixes the following Wine bugs:
+# |   *	[#40613] Basic implementation for token integrity levels and UAC handling
+# |   *	[#39262] Run explorer.exe as unevaluated process
+# |
+# | Modified files:
+# |   *	configure.ac, dlls/advapi32/tests/Makefile.in, dlls/advapi32/tests/security.c, dlls/kernelbase/process.c,
+# | 	dlls/ntdll/loader.c, dlls/ntdll/nt.c, dlls/ntdll/ntdll.spec, dlls/ntdll/ntdll_misc.h, dlls/ntdll/process.c,
+# | 	dlls/shell32/shlexec.c, dlls/user32/win.c, programs/runas/Makefile.in, programs/runas/runas.c, programs/runas/runas.h,
+# | 	programs/runas/runas.rc, server/process.c, server/process.h, server/protocol.def, server/request.c, server/security.h,
+# | 	server/token.c
+# |
+if test "$enable_advapi32_Token_Integrity_Level" -eq 1; then
+	patch_apply advapi32-Token_Integrity_Level/0001-advapi32-tests-Extend-security-label-token-integrity.patch
+	patch_apply advapi32-Token_Integrity_Level/0002-server-Implement-token-elevation-information.patch
+	patch_apply advapi32-Token_Integrity_Level/0003-server-Correctly-treat-zero-access-mask-in-duplicate.patch
+	patch_apply advapi32-Token_Integrity_Level/0004-server-Implement-token-integrity-level.patch
+	patch_apply advapi32-Token_Integrity_Level/0005-server-Use-all-group-attributes-in-create_token.patch
+	patch_apply advapi32-Token_Integrity_Level/0006-ntdll-Add-function-to-create-new-tokens-for-elevatio.patch
+	patch_apply advapi32-Token_Integrity_Level/0007-shell32-Implement-process-elevation-using-runas-verb.patch
+	patch_apply advapi32-Token_Integrity_Level/0008-ntdll-Implement-process-token-elevation-through-mani.patch
+	patch_apply advapi32-Token_Integrity_Level/0010-server-Implement-support-for-creating-processes-usin.patch
+	patch_apply advapi32-Token_Integrity_Level/0012-user32-Start-explorer.exe-using-limited-rights.patch
+	patch_apply advapi32-Token_Integrity_Level/0013-server-Correctly-assign-security-labels-for-tokens.patch
+	patch_apply advapi32-Token_Integrity_Level/0014-programs-runas-Basic-implementation-for-starting-pro.patch
+	patch_apply advapi32-Token_Integrity_Level/0015-ntdll-Add-semi-stub-for-TokenLinkedToken-info-class.patch
+fi
+
 # Patchset api-ms-win-Stub_DLLs
 # |
 # | Modified files:
@@ -1927,6 +2135,18 @@ if test "$enable_comdlg32_lpstrFileTitle" -eq 1; then
 	patch_apply comdlg32-lpstrFileTitle/0001-comdlg32-Postpone-setting-ofn-lpstrFileTitle-to-work.patch
 fi
 
+# Patchset configure-Absolute_RPATH
+# |
+# | This patchset fixes the following Wine bugs:
+# |   *	[#26256] Support for setcap on wine-preloader
+# |
+# | Modified files:
+# |   *	configure.ac
+# |
+if test "$enable_configure_Absolute_RPATH" -eq 1; then
+	patch_apply configure-Absolute_RPATH/0001-configure-Also-add-the-absolute-RPATH-when-linking-a.patch
+fi
+
 # Patchset crypt32-CMS_Certificates
 # |
 # | This patchset fixes the following Wine bugs:
@@ -2473,6 +2693,331 @@ if test "$enable_dxdiagn_GetChildContainer_Leaf_Nodes" -eq 1; then
 	patch_apply dxdiagn-GetChildContainer_Leaf_Nodes/0001-dxdiagn-Calling-GetChildContainer-with-an-empty-stri.patch
 fi
 
+# Patchset kernel32-K32GetPerformanceInfo
+# |
+# | Modified files:
+# |   *	dlls/kernelbase/debug.c, server/process.c, server/protocol.def
+# |
+if test "$enable_kernel32_K32GetPerformanceInfo" -eq 1; then
+	patch_apply kernel32-K32GetPerformanceInfo/0001-kernel32-Make-K32GetPerformanceInfo-faster.patch
+fi
+
+# Patchset ntdll-Junction_Points
+# |
+# | This patchset fixes the following Wine bugs:
+# |   *	[#12401] NET Framework 2.0, 3.0, 4.0 installers and other apps that make use of GAC API for managed assembly
+# | 	installation on NTFS filesystems need reparse point/junction API support
+# | 	(FSCTL_SET_REPARSE_POINT/FSCTL_GET_REPARSE_POINT)
+# |   *	[#44948] Multiple apps (Spine (Mod starter for Gothic), MS Office 365 installer) need CreateSymbolicLinkW implementation
+# |
+# | Modified files:
+# |   *	configure.ac, dlls/kernel32/path.c, dlls/ntdll/directory.c, dlls/ntdll/file.c, dlls/ntdll/tests/file.c,
+# | 	include/Makefile.in, include/ntifs.h, include/wine/port.h, include/winternl.h, libs/port/Makefile.in,
+# | 	libs/port/renameat2.c, server/fd.c
+# |
+if test "$enable_ntdll_Junction_Points" -eq 1; then
+	patch_apply ntdll-Junction_Points/0001-ntdll-Add-support-for-junction-point-creation.patch
+	patch_apply ntdll-Junction_Points/0002-ntdll-Add-support-for-reading-junction-points.patch
+	patch_apply ntdll-Junction_Points/0003-ntdll-Add-support-for-deleting-junction-points.patch
+	patch_apply ntdll-Junction_Points/0004-ntdll-Add-a-test-for-junction-point-advertisement.patch
+	patch_apply ntdll-Junction_Points/0005-kernel32-ntdll-Add-support-for-deleting-junction-poi.patch
+	patch_apply ntdll-Junction_Points/0007-ntdll-Add-support-for-absolute-symlink-creation.patch
+	patch_apply ntdll-Junction_Points/0008-ntdll-Add-support-for-reading-absolute-symlinks.patch
+	patch_apply ntdll-Junction_Points/0009-ntdll-Add-support-for-deleting-symlinks.patch
+	patch_apply ntdll-Junction_Points/0010-ntdll-Add-support-for-relative-symlink-creation.patch
+	patch_apply ntdll-Junction_Points/0011-ntdll-Add-support-for-reading-relative-symlinks.patch
+	patch_apply ntdll-Junction_Points/0012-ntdll-Add-support-for-file-symlinks.patch
+	patch_apply ntdll-Junction_Points/0013-ntdll-Allow-creation-of-dangling-reparse-points-to-n.patch
+	patch_apply ntdll-Junction_Points/0014-ntdll-Correctly-report-file-symbolic-links-as-files.patch
+	patch_apply ntdll-Junction_Points/0015-kernel32-Set-error-code-when-attempting-to-delete-fi.patch
+	patch_apply ntdll-Junction_Points/0016-server-Properly-handle-file-symlink-deletion.patch
+	patch_apply ntdll-Junction_Points/0017-ntdll-Always-report-symbolic-links-as-containing-zer.patch
+	patch_apply ntdll-Junction_Points/0018-ntdll-Find-dangling-symlinks-quickly.patch
+fi
+
+# Patchset winebuild-Fake_Dlls
+# |
+# | This patchset fixes the following Wine bugs:
+# |   *	[#21232] Chromium-based browser engines (Chrome, Opera, Comodo Dragon, SRWare Iron) crash on startup unless '--no-
+# | 	sandbox' is used (native API sandboxing/hooking scheme incompatible with Wine)
+# |   *	[#42741] StarCraft I: 1.18 PTR fails to initialize ClientSdk.dll
+# |   *	[#45349] Multiple applications and games crash due to missing support for 64-bit syscall thunks (StreetFighter V)
+# |   *	[#45573] League of Legends 8.12+ fails to start a game (anticheat engine, hooking of syscall return instructions)
+# |   *	[#45650] chromium 32-bit sandbox expects different syscall thunks depending on Windows version
+# |
+# | Modified files:
+# |   *	dlls/dbghelp/cpu_i386.c, dlls/kernel32/tests/loader.c, dlls/krnl386.exe16/kernel.c,
+# | 	dlls/krnl386.exe16/kernel16_private.h, dlls/krnl386.exe16/ne_module.c, dlls/krnl386.exe16/ne_segment.c,
+# | 	dlls/krnl386.exe16/task.c, dlls/krnl386.exe16/thunk.c, dlls/krnl386.exe16/wowthunk.c, dlls/ntdll/actctx.c,
+# | 	dlls/ntdll/directory.c, dlls/ntdll/loader.c, dlls/ntdll/locale.c, dlls/ntdll/ntdll_misc.h, dlls/ntdll/path.c,
+# | 	dlls/ntdll/process.c, dlls/ntdll/signal_i386.c, dlls/ntdll/signal_x86_64.c, dlls/ntdll/tests/exception.c,
+# | 	dlls/ntdll/thread.c, dlls/system.drv16/system.c, dlls/toolhelp.dll16/toolhelp.c, dlls/user.exe16/message.c,
+# | 	dlls/user.exe16/user.c, dlls/user.exe16/window.c, include/winternl.h, libs/wine/loader.c, tools/winebuild/build.h,
+# | 	tools/winebuild/import.c, tools/winebuild/parser.c, tools/winebuild/relay.c, tools/winebuild/res32.c,
+# | 	tools/winebuild/spec16.c, tools/winebuild/spec32.c, tools/winebuild/utils.c
+# |
+if test "$enable_winebuild_Fake_Dlls" -eq 1; then
+	patch_apply winebuild-Fake_Dlls/0001-kernel32-tests-Add-basic-tests-for-fake-dlls.patch
+	patch_apply winebuild-Fake_Dlls/0002-krnl386.exe16-Do-not-abuse-WOW32Reserved-field-for-1.patch
+	patch_apply winebuild-Fake_Dlls/0003-winebuild-Generate-syscall-thunks-for-ntdll-exports.patch
+	patch_apply winebuild-Fake_Dlls/0004-winebuild-Use-multipass-label-system-to-generate-fak.patch
+	patch_apply winebuild-Fake_Dlls/0005-winebuild-Add-stub-functions-in-fake-dlls.patch
+	patch_apply winebuild-Fake_Dlls/0006-winebuild-Add-syscall-thunks-in-fake-dlls.patch
+	patch_apply winebuild-Fake_Dlls/0007-winebuild-Fix-size-of-relocation-information-in-fake.patch
+	patch_apply winebuild-Fake_Dlls/0008-winebuild-Try-to-make-sure-RVA-matches-between-fake-.patch
+	patch_apply winebuild-Fake_Dlls/0009-libs-wine-Use-same-file-alignment-for-fake-and-built.patch
+	patch_apply winebuild-Fake_Dlls/0010-tools-winebuild-Add-syscall-thunks-for-64-bit.patch
+	patch_apply winebuild-Fake_Dlls/0011-ntdll-Call-NtOpenFile-through-syscall-thunk.patch
+fi
+
+# Patchset ntdll-RtlCreateUserThread
+# |
+# | This patchset has the following (direct or indirect) dependencies:
+# |   *	winebuild-Fake_Dlls
+# |
+# | This patchset fixes the following Wine bugs:
+# |   *	[#45571] League of Legends 8.12+ fails to start a game (anticheat engine, hooking of NtCreateThread/Ex)
+# |
+# | Modified files:
+# |   *	dlls/ntdll/ntdll.spec, dlls/ntdll/thread.c, include/winternl.h
+# |
+if test "$enable_ntdll_RtlCreateUserThread" -eq 1; then
+	patch_apply ntdll-RtlCreateUserThread/0001-ntdll-Refactor-RtlCreateUserThread-into-NtCreateThre.patch
+fi
+
+# Patchset ntdll-SystemRoot_Symlink
+# |
+# | Modified files:
+# |   *	dlls/ntdll/om.c
+# |
+if test "$enable_ntdll_SystemRoot_Symlink" -eq 1; then
+	patch_apply ntdll-SystemRoot_Symlink/0001-ntdll-Add-special-handling-for-SystemRoot-to-satisfy.patch
+fi
+
+# Patchset ntdll-ThreadTime
+# |
+# | This patchset fixes the following Wine bugs:
+# |   *	[#20230] Return correct values for GetThreadTimes function
+# |
+# | Modified files:
+# |   *	dlls/ntdll/nt.c, dlls/ntdll/ntdll_misc.h, dlls/ntdll/process.c, dlls/ntdll/thread.c, server/protocol.def,
+# | 	server/snapshot.c, server/thread.c, server/thread.h
+# |
+if test "$enable_ntdll_ThreadTime" -eq 1; then
+	patch_apply ntdll-ThreadTime/0001-ntdll-Return-correct-values-in-GetThreadTimes-for-al.patch
+	patch_apply ntdll-ThreadTime/0002-ntdll-Set-correct-thread-creation-time-for-SystemPro.patch
+	patch_apply ntdll-ThreadTime/0003-ntdll-Fill-process-kernel-and-user-time.patch
+	patch_apply ntdll-ThreadTime/0004-ntdll-Set-process-start-time.patch
+	patch_apply ntdll-ThreadTime/0005-ntdll-Fill-out-thread-times-in-process-enumeration.patch
+	patch_apply ntdll-ThreadTime/0006-ntdll-Fill-process-virtual-memory-counters-in-NtQuer.patch
+fi
+
+# Patchset server-Realtime_Priority
+# |
+# | This patchset has the following (direct or indirect) dependencies:
+# |   *	ntdll-ThreadTime
+# |
+# | Modified files:
+# |   *	server/Makefile.in, server/main.c, server/scheduler.c, server/thread.c, server/thread.h
+# |
+if test "$enable_server_Realtime_Priority" -eq 1; then
+	patch_apply server-Realtime_Priority/0001-wineserver-Draft-to-implement-priority-levels-throug.patch
+fi
+
+# Patchset ntdll-Threading
+# |
+# | Modified files:
+# |   *	dlls/ntdll/thread.c
+# |
+if test "$enable_ntdll_Threading" -eq 1; then
+	patch_apply ntdll-Threading/0001-ntdll-Fix-race-condition-when-threads-are-killed-dur.patch
+fi
+
+# Patchset ntdll-ext4-case-folder
+# |
+# | This patchset fixes the following Wine bugs:
+# |   *	[#47099] Support for EXT4 case folding per directory.
+# |
+# | Modified files:
+# |   *	dlls/ntdll/server.c
+# |
+if test "$enable_ntdll_ext4_case_folder" -eq 1; then
+	patch_apply ntdll-ext4-case-folder/0002-ntdll-server-Mark-drive_c-as-case-insensitive-when-c.patch
+fi
+
+# Patchset server-PeekMessage
+# |
+# | This patchset fixes the following Wine bugs:
+# |   *	[#28884] GetMessage should remove already seen messages with higher priority
+# |
+# | Modified files:
+# |   *	dlls/user32/tests/msg.c, server/queue.c
+# |
+if test "$enable_server_PeekMessage" -eq 1; then
+	patch_apply server-PeekMessage/0001-server-Fix-handling-of-GetMessage-after-previous-Pee.patch
+fi
+
+# Patchset server-Signal_Thread
+# |
+# | Modified files:
+# |   *	server/thread.c, server/thread.h
+# |
+if test "$enable_server_Signal_Thread" -eq 1; then
+	patch_apply server-Signal_Thread/0001-server-Do-not-signal-thread-until-it-is-really-gone.patch
+fi
+
+# Patchset loader-KeyboardLayouts
+# |
+# | This patchset fixes the following Wine bugs:
+# |   *	[#47439] loader: Add Keyboard Layouts registry enteries.
+# |
+# | Modified files:
+# |   *	dlls/user32/driver.c, dlls/user32/tests/input.c, loader/wine.inf.in
+# |
+if test "$enable_loader_KeyboardLayouts" -eq 1; then
+	patch_apply loader-KeyboardLayouts/0001-loader-Add-Keyboard-Layouts-registry-enteries.patch
+	patch_apply loader-KeyboardLayouts/0002-user32-Improve-GetKeyboardLayoutList.patch
+fi
+
+# Patchset server-Shared_Memory
+# |
+# | This patchset has the following (direct or indirect) dependencies:
+# |   *	ntdll-Threading, ntdll-ext4-case-folder, server-PeekMessage, server-Signal_Thread, loader-
+# | 	KeyboardLayouts
+# |
+# | Modified files:
+# |   *	dlls/ntdll/ntdll_misc.h, dlls/ntdll/server.c, dlls/ntdll/thread.c, dlls/ntdll/virtual.c, dlls/user32/focus.c,
+# | 	dlls/user32/input.c, dlls/user32/message.c, dlls/user32/user_private.h, include/wine/server.h, include/winternl.h,
+# | 	server/fd.c, server/file.h, server/main.c, server/mapping.c, server/protocol.def, server/queue.c, server/thread.c,
+# | 	server/thread.h
+# |
+if test "$enable_server_Shared_Memory" -eq 1; then
+	patch_apply server-Shared_Memory/0001-ntdll-Implement-virtual_map_shared_memory.patch
+	patch_apply server-Shared_Memory/0002-server-Implement-support-for-global-and-local-shared.patch
+	patch_apply server-Shared_Memory/0003-user32-Get-rid-of-wineserver-call-for-GetInputState.patch
+	patch_apply server-Shared_Memory/0004-user32-Avoid-unnecessary-wineserver-calls-in-PeekMes.patch
+	patch_apply server-Shared_Memory/0005-user32-Get-rid-of-wineserver-call-for-GetLastInputIn.patch
+	patch_apply server-Shared_Memory/0006-ntdll-Only-enable-wineserver-shared-memory-communica.patch
+	patch_apply server-Shared_Memory/0007-server-Store-a-list-of-associated-queues-for-each-th.patch
+	patch_apply server-Shared_Memory/0008-user32-Get-rid-of-wineserver-call-for-GetActiveWindo.patch
+fi
+
+# Patchset eventfd_synchronization
+# |
+# | This patchset has the following (direct or indirect) dependencies:
+# |   *	Staging, advapi32-CreateRestrictedToken, advapi32-Token_Integrity_Level, kernel32-K32GetPerformanceInfo, ntdll-
+# | 	Junction_Points, winebuild-Fake_Dlls, ntdll-RtlCreateUserThread, ntdll-SystemRoot_Symlink, ntdll-ThreadTime, server-
+# | 	Realtime_Priority, ntdll-Threading, ntdll-ext4-case-folder, server-PeekMessage, server-Signal_Thread,
+# | 	loader-KeyboardLayouts, server-Shared_Memory
+# |
+# | This patchset fixes the following Wine bugs:
+# |   *	[#36692] Many multi-threaded applications have poor performance due to heavy use of synchronization primitives
+# |
+# | Modified files:
+# |   *	README.esync, configure.ac, dlls/kernel32/tests/sync.c, dlls/ntdll/Makefile.in, dlls/ntdll/critsection.c,
+# | 	dlls/ntdll/esync.c, dlls/ntdll/esync.h, dlls/ntdll/loader.c, dlls/ntdll/ntdll.spec, dlls/ntdll/ntdll_misc.h,
+# | 	dlls/ntdll/om.c, dlls/ntdll/server.c, dlls/ntdll/sync.c, dlls/ntdll/thread.c, dlls/rpcrt4/rpc_server.c,
+# | 	dlls/user32/hook.c, dlls/wineandroid.drv/window.c, dlls/winemac.drv/macdrv_main.c, dlls/winex11.drv/x11drv_main.c,
+# | 	server/Makefile.in, server/async.c, server/atom.c, server/change.c, server/clipboard.c, server/completion.c,
+# | 	server/console.c, server/debugger.c, server/device.c, server/directory.c, server/esync.c, server/esync.h,
+# | 	server/event.c, server/fd.c, server/file.c, server/file.h, server/handle.c, server/hook.c, server/mailslot.c,
+# | 	server/main.c, server/mapping.c, server/mutex.c, server/named_pipe.c, server/object.h, server/process.c,
+# | 	server/process.h, server/protocol.def, server/queue.c, server/registry.c, server/request.c, server/semaphore.c,
+# | 	server/serial.c, server/signal.c, server/snapshot.c, server/sock.c, server/symlink.c, server/thread.c, server/thread.h,
+# | 	server/timer.c, server/token.c, server/winstation.c
+# |
+if test "$enable_eventfd_synchronization" -eq 1; then
+	patch_apply eventfd_synchronization/0001-configure-Check-for-sys-eventfd.h-ppoll-and-shm_open.patch
+	patch_apply eventfd_synchronization/0002-server-Create-server-objects-for-eventfd-based-synch.patch
+	patch_apply eventfd_synchronization/0003-ntdll-Create-eventfd-based-objects-for-semaphores.patch
+	patch_apply eventfd_synchronization/0004-ntdll-Store-esync-objects-locally.patch
+	patch_apply eventfd_synchronization/0005-ntdll-Implement-NtReleaseSemaphore.patch
+	patch_apply eventfd_synchronization/0006-ntdll-Close-esync-objects.patch
+	patch_apply eventfd_synchronization/0007-ntdll-Implement-waiting-on-esync-objects.patch
+	patch_apply eventfd_synchronization/0008-ntdll-Create-esync-objects-for-events.patch
+	patch_apply eventfd_synchronization/0009-ntdll-Implement-NtSetEvent.patch
+	patch_apply eventfd_synchronization/0010-ntdll-Implement-NtResetEvent.patch
+	patch_apply eventfd_synchronization/0011-ntdll-Implement-NtPulseEvent.patch
+	patch_apply eventfd_synchronization/0012-ntdll-Implement-waiting-on-events.patch
+	patch_apply eventfd_synchronization/0013-server-Add-an-object-operation-to-grab-the-esync-fil.patch
+	patch_apply eventfd_synchronization/0014-server-Add-a-request-to-get-the-eventfd-file-descrip.patch
+	patch_apply eventfd_synchronization/0015-server-Create-eventfd-file-descriptors-for-process-o.patch
+	patch_apply eventfd_synchronization/0016-ntdll-server-Implement-waiting-on-server-bound-objec.patch
+	patch_apply eventfd_synchronization/0017-server-Create-eventfd-file-descriptors-for-event-obj.patch
+	patch_apply eventfd_synchronization/0018-server-Allow-re-setting-esync-events-on-the-server-s.patch
+	patch_apply eventfd_synchronization/0019-ntdll-Try-again-if-poll-returns-EINTR.patch
+	patch_apply eventfd_synchronization/0020-server-Create-eventfd-file-descriptors-for-thread-ob.patch
+	patch_apply eventfd_synchronization/0021-rpcrt4-Avoid-closing-the-server-thread-handle-while-.patch
+	patch_apply eventfd_synchronization/0022-server-Create-eventfd-file-descriptors-for-message-q.patch
+	patch_apply eventfd_synchronization/0023-ntdll-wineandroid.drv-winemac.drv-winex11.drv-Store-.patch
+	patch_apply eventfd_synchronization/0024-server-ntdll-Also-wait-on-the-queue-fd-when-waiting-.patch
+	patch_apply eventfd_synchronization/0025-server-Create-eventfd-descriptors-for-device-manager.patch
+	patch_apply eventfd_synchronization/0026-ntdll-Create-esync-objects-for-mutexes.patch
+	patch_apply eventfd_synchronization/0027-ntdll-Implement-NtReleaseMutant.patch
+	patch_apply eventfd_synchronization/0028-ntdll-Implement-waiting-on-mutexes.patch
+	patch_apply eventfd_synchronization/0029-ntdll-Implement-wait-all.patch
+	patch_apply eventfd_synchronization/0030-esync-Add-a-README.patch
+	patch_apply eventfd_synchronization/0031-ntdll-Implement-NtSignalAndWaitForSingleObject.patch
+	patch_apply eventfd_synchronization/0032-server-ntdll-Also-store-the-esync-type-in-the-server.patch
+	patch_apply eventfd_synchronization/0033-ntdll-server-Implement-NtOpenSemaphore.patch
+	patch_apply eventfd_synchronization/0034-ntdll-Implement-NtOpenEvent.patch
+	patch_apply eventfd_synchronization/0035-ntdll-Implement-NtOpenMutant.patch
+	patch_apply eventfd_synchronization/0036-ntdll-Record-the-current-count-of-a-semaphore-locall.patch
+	patch_apply eventfd_synchronization/0037-server-Implement-esync_map_access.patch
+	patch_apply eventfd_synchronization/0038-server-Alter-conditions-in-is_queue_hung.patch
+	patch_apply eventfd_synchronization/0039-ntdll-server-Allow-DuplicateHandle-to-succeed-by-imp.patch
+	patch_apply eventfd_synchronization/0040-server-Create-eventfd-descriptors-for-timers.patch
+	patch_apply eventfd_synchronization/0041-server-Allocate-shared-memory-segments-for-semaphore.patch
+	patch_apply eventfd_synchronization/0042-ntdll-Use-shared-memory-segments-to-store-semaphore-.patch
+	patch_apply eventfd_synchronization/0043-ntdll-Lock-creating-and-opening-objects-with-volatil.patch
+	patch_apply eventfd_synchronization/0044-server-ntdll-Pass-the-shared-memory-index-back-from-.patch
+	patch_apply eventfd_synchronization/0045-server-ntdll-Implement-alertable-waits.patch
+	patch_apply eventfd_synchronization/0046-esync-Update-README.patch
+	patch_apply eventfd_synchronization/0047-kernel32-tests-Mark-some-existing-tests-as-failing-u.patch
+	patch_apply eventfd_synchronization/0048-kernel32-tests-Add-some-semaphore-tests.patch
+	patch_apply eventfd_synchronization/0049-kernel32-tests-Add-some-event-tests.patch
+	patch_apply eventfd_synchronization/0050-kernel32-tests-Add-some-mutex-tests.patch
+	patch_apply eventfd_synchronization/0051-kernel32-tests-Add-some-tests-for-wait-timeouts.patch
+	patch_apply eventfd_synchronization/0052-ntdll-Go-through-the-server-if-necessary-when-perfor.patch
+	patch_apply eventfd_synchronization/0053-server-Create-eventfd-descriptors-for-console_input_.patch
+	patch_apply eventfd_synchronization/0054-server-Alter-conditions-in-is_queue_hung-again.patch
+	patch_apply eventfd_synchronization/0055-ntdll-Let-the-server-know-when-we-are-doing-a-messag.patch
+	patch_apply eventfd_synchronization/0056-ntdll-Avoid-server_select-when-waiting-for-critical-.patch
+	patch_apply eventfd_synchronization/0057-user32-Remove-hooks-that-time-out.patch
+	patch_apply eventfd_synchronization/0058-server-Don-t-check-for-a-hung-queue-when-sending-low.patch
+	patch_apply eventfd_synchronization/0059-kernel32-tests-Zigzag-test.patch
+	patch_apply eventfd_synchronization/0060-server-Try-to-remove-a-pre-xisting-shm-file.patch
+	patch_apply eventfd_synchronization/0061-ntdll-Implement-NtQuerySemaphore.patch
+	patch_apply eventfd_synchronization/0062-ntdll-Implement-NtQueryEvent.patch
+	patch_apply eventfd_synchronization/0063-ntdll-Implement-NtQueryMutant.patch
+	patch_apply eventfd_synchronization/0064-server-Create-eventfd-descriptors-for-pseudo-fd-obje.patch
+	patch_apply eventfd_synchronization/0065-ntdll-Cache-the-esync-struct-itself-instead-of-a-poi.patch
+	patch_apply eventfd_synchronization/0066-esync-Update-README.patch
+	patch_apply eventfd_synchronization/0067-esync-Add-note-about-file-limits-not-being-raised-wh.patch
+	patch_apply eventfd_synchronization/0068-ntdll-Ignore-pseudo-handles.patch
+	patch_apply eventfd_synchronization/0069-ntdll-Try-to-avoid-poll-for-uncontended-objects.patch
+	patch_apply eventfd_synchronization/0070-ntdll-Store-an-event-s-signaled-state-internally.patch
+	patch_apply eventfd_synchronization/0071-ntdll-Fix-growing-the-shm_addrs-array.patch
+	patch_apply eventfd_synchronization/0072-server-Update-the-shared-memory-state-when-re-settin.patch
+	patch_apply eventfd_synchronization/0073-ntdll-Fix-a-missing-break-statement.patch
+	patch_apply eventfd_synchronization/0074-ntdll-server-Abort-if-esync-is-enabled-for-the-serve.patch
+	patch_apply eventfd_synchronization/0075-esync-Update-README.patch
+	patch_apply eventfd_synchronization/0076-ntdll-Correctly-allocate-the-esync-handle-cache.patch
+	patch_apply eventfd_synchronization/0077-ntdll-server-Specify-EFD_SEMAPHORE-on-the-server-sid.patch
+	patch_apply eventfd_synchronization/0078-ntdll-server-Initialize-the-shared-memory-portion-on.patch
+	patch_apply eventfd_synchronization/0079-ntdll-server-Revert-to-old-implementation-of-hung-qu.patch
+	patch_apply eventfd_synchronization/0080-ntdll-Fix-a-couple-of-misplaced-global-variables.patch
+	patch_apply eventfd_synchronization/0081-ntdll-Yield-during-PulseEvent.patch
+	patch_apply eventfd_synchronization/0082-ntdll-server-Check-the-value-of-WINEESYNC-instead-of.patch
+	patch_apply eventfd_synchronization/0083-esync-Update-README.patch
+	patch_apply eventfd_synchronization/0084-server-Use-default_fd_get_esync_fd-for-directory-cha.patch
+	patch_apply eventfd_synchronization/0085-server-Only-signal-the-APC-fd-for-user-APCs.patch
+	patch_apply eventfd_synchronization/0086-ntdll-Check-the-APC-fd-first.patch
+	patch_apply eventfd_synchronization/0087-ntdll-esync-Lock-accessing-the-shm_addrs-array.patch
+	patch_apply eventfd_synchronization/0088-ntdll-Get-rid-of-the-per-event-spinlock-for-auto-res.patch
+	patch_apply eventfd_synchronization/0089-ntdll-server-Abandon-esync-mutexes-on-thread-exit.patch
+fi
+
 # Patchset explorer-Video_Registry_Key
 # |
 # | Modified files:
@@ -2595,8 +3140,33 @@ if test "$enable_iphlpapi_System_Ping" -eq 1; then
 	patch_apply iphlpapi-System_Ping/0001-iphlpapi-Fallback-to-system-ping-when-ICMP-permissio.patch
 fi
 
+# Patchset server-File_Permissions
+# |
+# | This patchset has the following (direct or indirect) dependencies:
+# |   *	ntdll-Junction_Points
+# |
+# | This patchset fixes the following Wine bugs:
+# |   *	[#44691] Improve mapping of DACL to file permissions
+# |
+# | Modified files:
+# |   *	dlls/advapi32/tests/security.c, dlls/ntdll/tests/file.c, server/fd.c, server/file.c
+# |
+if test "$enable_server_File_Permissions" -eq 1; then
+	patch_apply server-File_Permissions/0001-server-Improve-STATUS_CANNOT_DELETE-checks-for-direc.patch
+	patch_apply server-File_Permissions/0002-server-Allow-to-open-files-without-any-permission-bi.patch
+	patch_apply server-File_Permissions/0003-server-When-creating-new-directories-temporarily-giv.patch
+	patch_apply server-File_Permissions/0004-advapi32-tests-Add-tests-for-ACL-inheritance-in-Crea.patch
+	patch_apply server-File_Permissions/0005-advapi32-tests-Add-ACL-inheritance-tests-for-creatin.patch
+	patch_apply server-File_Permissions/0006-ntdll-tests-Added-tests-for-open-behaviour-on-readon.patch
+	patch_apply server-File_Permissions/0007-server-FILE_WRITE_ATTRIBUTES-should-succeed-for-read.patch
+	patch_apply server-File_Permissions/0008-server-Improve-mapping-of-DACL-to-file-permissions.patch
+fi
+
 # Patchset ntdll-FileDispositionInformation
 # |
+# | This patchset has the following (direct or indirect) dependencies:
+# |   *	ntdll-Junction_Points, server-File_Permissions
+# |
 # | Modified files:
 # |   *	dlls/ntdll/tests/file.c, server/fd.c
 # |
@@ -2608,7 +3178,7 @@ fi
 # Patchset kernel32-CopyFileEx
 # |
 # | This patchset has the following (direct or indirect) dependencies:
-# |   *	ntdll-FileDispositionInformation
+# |   *	ntdll-Junction_Points, server-File_Permissions, ntdll-FileDispositionInformation
 # |
 # | This patchset fixes the following Wine bugs:
 # |   *	[#22692] Add support for CopyFileEx progress callback
@@ -2705,19 +3275,6 @@ if test "$enable_krnl386_exe16_Invalid_Console_Handles" -eq 1; then
 	patch_apply krnl386.exe16-Invalid_Console_Handles/0001-krnl386.exe16-Really-translate-all-invalid-console-h.patch
 fi
 
-# Patchset loader-KeyboardLayouts
-# |
-# | This patchset fixes the following Wine bugs:
-# |   *	[#47439] loader: Add Keyboard Layouts registry enteries.
-# |
-# | Modified files:
-# |   *	dlls/user32/driver.c, dlls/user32/tests/input.c, loader/wine.inf.in
-# |
-if test "$enable_loader_KeyboardLayouts" -eq 1; then
-	patch_apply loader-KeyboardLayouts/0001-loader-Add-Keyboard-Layouts-registry-enteries.patch
-	patch_apply loader-KeyboardLayouts/0002-user32-Improve-GetKeyboardLayoutList.patch
-fi
-
 # Patchset mfplat-streaming-support
 # |
 # | This patchset fixes the following Wine bugs:
@@ -2915,7 +3472,7 @@ fi
 # Patchset ntdll-APC_Performance
 # |
 # | Modified files:
-# |   *	dlls/ntdll/unix/file.c
+# |   *	dlls/ntdll/file.c
 # |
 if test "$enable_ntdll_APC_Performance" -eq 1; then
 	patch_apply ntdll-APC_Performance/0001-ntdll-Reuse-old-async-fileio-structures-if-possible.patch
@@ -2933,48 +3490,28 @@ fi
 # Patchset ntdll-ApiSetMap
 # |
 # | This patchset has the following (direct or indirect) dependencies:
-# |   *	ntdll-FLS_Callbacks
+# |   *	ntdll-ThreadTime
 # |
 # | This patchset fixes the following Wine bugs:
 # |   *	[#44658] Add dummy apiset to PEB struct
 # |
 # | Modified files:
-# |   *	dlls/ntdll/loader.c, include/Makefile.in, include/apiset.h, include/winternl.h
+# |   *	dlls/ntdll/thread.c, include/Makefile.in, include/apiset.h, include/winternl.h
 # |
 if test "$enable_ntdll_ApiSetMap" -eq 1; then
 	patch_apply ntdll-ApiSetMap/0001-ntdll-Add-dummy-apiset-to-PEB.patch
 fi
 
-# Patchset ntdll-ForceBottomUpAlloc
-# |
-# | This patchset fixes the following Wine bugs:
-# |   *	[#48175] AION (64 bit) - crashes in crysystem.dll.CryFree() due to high memory pointers allocated
-# |   *	[#46568] 64-bit msxml6.dll from Microsoft Core XML Services 6.0 redist package fails to load (Wine doesn't respect
-# | 	44-bit user-mode VA limitation from Windows < 8.1)
-# |
-# | Modified files:
-# |   *	dlls/ntdll/unix/virtual.c
-# |
-if test "$enable_ntdll_ForceBottomUpAlloc" -eq 1; then
-	patch_apply ntdll-ForceBottomUpAlloc/0001-ntdll-Increase-step-after-failed-map-attempt-in-try_.patch
-	patch_apply ntdll-ForceBottomUpAlloc/0002-ntdll-Increase-free-ranges-view-block-size-on-64-bit.patch
-	patch_apply ntdll-ForceBottomUpAlloc/0003-ntdll-Force-virtual-memory-allocation-order.patch
-	patch_apply ntdll-ForceBottomUpAlloc/0004-ntdll-Exclude-natively-mapped-areas-from-free-areas-.patch
-fi
-
 # Patchset ntdll-WRITECOPY
 # |
-# | This patchset has the following (direct or indirect) dependencies:
-# |   *	ntdll-ForceBottomUpAlloc
-# |
 # | This patchset fixes the following Wine bugs:
 # |   *	[#29384] Multiple applications expect correct handling of WRITECOPY memory protection (Voobly fails to launch Age of
 # | 	Empires II, MSYS2)
 # |
 # | Modified files:
-# |   *	dlls/advapi32/tests/security.c, dlls/kernel32/tests/virtual.c, dlls/ntdll/unix/loader.c, dlls/ntdll/unix/server.c,
-# | 	dlls/ntdll/unix/signal_arm.c, dlls/ntdll/unix/signal_arm64.c, dlls/ntdll/unix/signal_i386.c,
-# | 	dlls/ntdll/unix/signal_x86_64.c, dlls/ntdll/unix/unix_private.h, dlls/ntdll/unix/virtual.c,
+# |   *	dlls/advapi32/crypt.c, dlls/advapi32/tests/security.c, dlls/kernel32/tests/virtual.c, dlls/ntdll/ntdll_misc.h,
+# | 	dlls/ntdll/server.c, dlls/ntdll/signal_arm.c, dlls/ntdll/signal_arm64.c, dlls/ntdll/signal_i386.c,
+# | 	dlls/ntdll/signal_powerpc.c, dlls/ntdll/signal_x86_64.c, dlls/ntdll/thread.c, dlls/ntdll/virtual.c,
 # | 	dlls/psapi/tests/psapi_main.c
 # |
 if test "$enable_ntdll_WRITECOPY" -eq 1; then
@@ -2991,13 +3528,13 @@ fi
 # Patchset ntdll-Builtin_Prot
 # |
 # | This patchset has the following (direct or indirect) dependencies:
-# |   *	ntdll-ForceBottomUpAlloc, ntdll-WRITECOPY
+# |   *	ntdll-WRITECOPY
 # |
 # | This patchset fixes the following Wine bugs:
 # |   *	[#44650] Fix holes in ELF mappings
 # |
 # | Modified files:
-# |   *	dlls/ntdll/unix/virtual.c, dlls/psapi/tests/psapi_main.c
+# |   *	dlls/ntdll/virtual.c, dlls/psapi/tests/psapi_main.c
 # |
 if test "$enable_ntdll_Builtin_Prot" -eq 1; then
 	patch_apply ntdll-Builtin_Prot/0001-ntdll-Fix-holes-in-ELF-mappings.patch
@@ -3016,15 +3553,20 @@ fi
 
 # Patchset ntdll-DOS_Attributes
 # |
+# | This patchset has the following (direct or indirect) dependencies:
+# |   *	ntdll-Junction_Points
+# |
 # | This patchset fixes the following Wine bugs:
 # |   *	[#9158] Support for DOS hidden/system file attributes
 # |   *	[#15679] cygwin symlinks not working in wine
 # |
 # | Modified files:
-# |   *	configure.ac, dlls/ntdll/tests/directory.c, dlls/ntdll/tests/file.c, dlls/ntdll/unix/file.c
+# |   *	configure.ac, dlls/ntdll/directory.c, dlls/ntdll/file.c, dlls/ntdll/ntdll_misc.h, dlls/ntdll/tests/directory.c,
+# | 	dlls/ntdll/tests/file.c, include/wine/port.h, libs/port/Makefile.in, libs/port/xattr.c
 # |
 if test "$enable_ntdll_DOS_Attributes" -eq 1; then
-	patch_apply ntdll-DOS_Attributes/0001-ntdll-Implement-retrieving-DOS-attributes-in-fd_-get.patch
+	patch_apply ntdll-DOS_Attributes/0001-ntdll-Implement-retrieving-DOS-attributes-in-NtQuery.patch
+	patch_apply ntdll-DOS_Attributes/0002-ntdll-Implement-retrieving-DOS-attributes-in-NtQuery.patch
 	patch_apply ntdll-DOS_Attributes/0003-ntdll-Implement-storing-DOS-attributes-in-NtSetInfor.patch
 	patch_apply ntdll-DOS_Attributes/0004-ntdll-Implement-storing-DOS-attributes-in-NtCreateFi.patch
 	patch_apply ntdll-DOS_Attributes/0005-libport-Add-support-for-Mac-OS-X-style-extended-attr.patch
@@ -3036,12 +3578,24 @@ fi
 # Patchset ntdll-Dealloc_Thread_Stack
 # |
 # | Modified files:
-# |   *	dlls/ntdll/unix/unix_private.h, dlls/ntdll/unix/virtual.c
+# |   *	dlls/ntdll/ntdll_misc.h, dlls/ntdll/virtual.c
 # |
 if test "$enable_ntdll_Dealloc_Thread_Stack" -eq 1; then
 	patch_apply ntdll-Dealloc_Thread_Stack/0001-ntdll-Do-not-allow-to-allocate-thread-stack-for-curr.patch
 fi
 
+# Patchset ntdll-DeviceType_Systemroot
+# |
+# | This patchset fixes the following Wine bugs:
+# |   *	[#36546] Return fake device type when systemroot is located on virtual disk
+# |
+# | Modified files:
+# |   *	dlls/ntdll/file.c
+# |
+if test "$enable_ntdll_DeviceType_Systemroot" -eq 1; then
+	patch_apply ntdll-DeviceType_Systemroot/0001-ntdll-Return-fake-device-type-when-systemroot-is-loc.patch
+fi
+
 # Patchset ntdll-Exception
 # |
 # | This patchset fixes the following Wine bugs:
@@ -3054,10 +3608,28 @@ if test "$enable_ntdll_Exception" -eq 1; then
 	patch_apply ntdll-Exception/0002-ntdll-OutputDebugString-should-throw-the-exception-a.patch
 fi
 
+# Patchset ntdll-FLS_Callbacks
+# |
+# | This patchset fixes the following Wine bugs:
+# |   *	[#49012] Application build with .NET CoreRT crashes due to FLS callbacks not being called
+# |
+# | Modified files:
+# |   *	dlls/kernel32/tests/fiber.c, dlls/kernel32/tests/loader.c, dlls/kernel32/tests/thread.c, dlls/kernelbase/thread.c,
+# | 	dlls/ntdll/loader.c
+# |
+if test "$enable_ntdll_FLS_Callbacks" -eq 1; then
+	patch_apply ntdll-FLS_Callbacks/0001-kernelbase-Maintain-FLS-storage-list-in-PEB.patch
+	patch_apply ntdll-FLS_Callbacks/0002-kernelbase-Don-t-use-PEB-lock-for-FLS-data.patch
+	patch_apply ntdll-FLS_Callbacks/0003-kernelbase-Zero-all-FLS-slots-instances-in-FlsFree.patch
+	patch_apply ntdll-FLS_Callbacks/0004-ntdll-Call-FLS-callbacks-on-thread-shutdown.patch
+	patch_apply ntdll-FLS_Callbacks/0005-kernelbase-Call-FLS-callbacks-from-FlsFree.patch
+	patch_apply ntdll-FLS_Callbacks/0006-kernelbase-Call-FLS-callbacks-from-DeleteFiber.patch
+fi
+
 # Patchset ntdll-FileFsFullSizeInformation
 # |
 # | Modified files:
-# |   *	dlls/ntdll/tests/file.c, dlls/ntdll/unix/file.c
+# |   *	dlls/ntdll/file.c, dlls/ntdll/tests/file.c
 # |
 if test "$enable_ntdll_FileFsFullSizeInformation" -eq 1; then
 	patch_apply ntdll-FileFsFullSizeInformation/0001-ntdll-Add-support-for-FileFsFullSizeInformation-clas.patch
@@ -3069,12 +3641,31 @@ fi
 # |   *	[#33162] Ensure NtProtectVirtualMemory and NtCreateSection are on separate pages
 # |
 # | Modified files:
-# |   *	dlls/ntdll/unix/virtual.c
+# |   *	dlls/ntdll/virtual.c
 # |
 if test "$enable_ntdll_Fix_Alignment" -eq 1; then
 	patch_apply ntdll-Fix_Alignment/0001-ntdll-Move-NtProtectVirtualMemory-and-NtCreateSectio.patch
 fi
 
+# Patchset ntdll-ForceBottomUpAlloc
+# |
+# | This patchset fixes the following Wine bugs:
+# |   *	[#48175] AION (64 bit) - crashes in crysystem.dll.CryFree() due to high memory pointers allocated
+# |   *	[#46568] 64-bit msxml6.dll from Microsoft Core XML Services 6.0 redist package fails to load (Wine doesn't respect
+# | 	44-bit user-mode VA limitation from Windows < 8.1)
+# |
+# | Modified files:
+# |   *	dlls/ntdll/virtual.c
+# |
+if test "$enable_ntdll_ForceBottomUpAlloc" -eq 1; then
+	patch_apply ntdll-ForceBottomUpAlloc/0001-ntdll-Stop-search-on-mmap-error-in-try_map_free_area.patch
+	patch_apply ntdll-ForceBottomUpAlloc/0002-ntdll-Use-MAP_FIXED_NOREPLACE-flag-in-try_map_free_a.patch
+	patch_apply ntdll-ForceBottomUpAlloc/0003-ntdll-Force-bottom-up-allocation-order-for-64-bit-ar.patch
+	patch_apply ntdll-ForceBottomUpAlloc/0004-ntdll-Increase-step-after-failed-map-attempt-in-try_.patch
+	patch_apply ntdll-ForceBottomUpAlloc/0005-ntdll-Use-free-area-list-for-virtual-memory-allocati.patch
+	patch_apply ntdll-ForceBottomUpAlloc/0006-ntdll-Permanently-exclude-natively-mapped-areas-from.patch
+fi
+
 # Patchset ntdll-HashLinks
 # |
 # | Modified files:
@@ -3100,6 +3691,9 @@ fi
 
 # Patchset ntdll-Hide_Wine_Exports
 # |
+# | This patchset has the following (direct or indirect) dependencies:
+# |   *	Staging, advapi32-CreateRestrictedToken, advapi32-Token_Integrity_Level, ntdll-ThreadTime
+# |
 # | This patchset fixes the following Wine bugs:
 # |   *	[#38656] Add support for hiding wine version information from applications
 # |
@@ -3116,63 +3710,12 @@ fi
 # |   *	[#42647] Implement stub handler for int 0x2e
 # |
 # | Modified files:
-# |   *	dlls/ntdll/unix/signal_i386.c
+# |   *	dlls/ntdll/signal_i386.c
 # |
 if test "$enable_ntdll_Interrupt_0x2e" -eq 1; then
 	patch_apply ntdll-Interrupt-0x2e/0001-ntdll-Catch-windows-int-0x2e-syscall-on-i386.patch
 fi
 
-# Patchset ntdll-NtQueryEaFile
-# |
-# | Modified files:
-# |   *	dlls/ntdll/tests/file.c, dlls/ntdll/unix/file.c
-# |
-if test "$enable_ntdll_NtQueryEaFile" -eq 1; then
-	patch_apply ntdll-NtQueryEaFile/0001-ntdll-Improve-stub-of-NtQueryEaFile.patch
-fi
-
-# Patchset ntdll-Junction_Points
-# |
-# | This patchset has the following (direct or indirect) dependencies:
-# |   *	ntdll-DOS_Attributes, ntdll-NtQueryEaFile
-# |
-# | This patchset fixes the following Wine bugs:
-# |   *	[#12401] NET Framework 2.0, 3.0, 4.0 installers and other apps that make use of GAC API for managed assembly
-# | 	installation on NTFS filesystems need reparse point/junction API support
-# | 	(FSCTL_SET_REPARSE_POINT/FSCTL_GET_REPARSE_POINT)
-# |   *	[#44948] Multiple apps (Spine (Mod starter for Gothic), MS Office 365 installer) need CreateSymbolicLinkW implementation
-# |
-# | Modified files:
-# |   *	configure.ac, dlls/kernel32/tests/path.c, dlls/kernelbase/file.c, dlls/msvcp120/tests/msvcp120.c,
-# | 	dlls/msvcp140/tests/msvcp140.c, dlls/ntdll/tests/file.c, dlls/ntdll/unix/file.c, include/Makefile.in, include/ntifs.h,
-# | 	include/winternl.h, programs/cmd/builtins.c, programs/cmd/directory.c, server/fd.c, server/protocol.def
-# |
-if test "$enable_ntdll_Junction_Points" -eq 1; then
-	patch_apply ntdll-Junction_Points/0001-ntdll-Add-support-for-junction-point-creation.patch
-	patch_apply ntdll-Junction_Points/0002-ntdll-Add-support-for-reading-junction-points.patch
-	patch_apply ntdll-Junction_Points/0003-ntdll-Add-support-for-deleting-junction-points.patch
-	patch_apply ntdll-Junction_Points/0004-ntdll-Add-a-test-for-junction-point-advertisement.patch
-	patch_apply ntdll-Junction_Points/0005-server-Add-support-for-deleting-junction-points-with.patch
-	patch_apply ntdll-Junction_Points/0007-ntdll-Add-support-for-absolute-symlink-creation.patch
-	patch_apply ntdll-Junction_Points/0008-ntdll-Add-support-for-reading-absolute-symlinks.patch
-	patch_apply ntdll-Junction_Points/0009-ntdll-Add-support-for-deleting-symlinks.patch
-	patch_apply ntdll-Junction_Points/0010-ntdll-Add-support-for-relative-symlink-creation.patch
-	patch_apply ntdll-Junction_Points/0011-ntdll-Add-support-for-reading-relative-symlinks.patch
-	patch_apply ntdll-Junction_Points/0012-ntdll-Add-support-for-file-symlinks.patch
-	patch_apply ntdll-Junction_Points/0013-ntdll-Allow-creation-of-dangling-reparse-points-to-n.patch
-	patch_apply ntdll-Junction_Points/0014-ntdll-Correctly-report-file-symbolic-links-as-files.patch
-	patch_apply ntdll-Junction_Points/0015-kernel32-Set-error-code-when-attempting-to-delete-fi.patch
-	patch_apply ntdll-Junction_Points/0016-server-Properly-handle-file-symlink-deletion.patch
-	patch_apply ntdll-Junction_Points/0017-ntdll-Always-report-symbolic-links-as-containing-zer.patch
-	patch_apply ntdll-Junction_Points/0018-ntdll-Find-dangling-symlinks-quickly.patch
-	patch_apply ntdll-Junction_Points/0019-kernel32-Implement-CreateSymbolicLink-A-W-with-ntdll.patch
-	patch_apply ntdll-Junction_Points/0020-kernel32-Add-reparse-support-to-FindNextFile.patch
-	patch_apply ntdll-Junction_Points/0021-wcmd-Display-reparse-point-type-in-directory-listing.patch
-	patch_apply ntdll-Junction_Points/0022-wcmd-Show-reparse-point-target-in-directory-listing.patch
-	patch_apply ntdll-Junction_Points/0023-wcmd-Add-junction-point-support-to-mklink.patch
-	patch_apply ntdll-Junction_Points/0024-server-Fix-obtaining-information-about-a-symlink.patch
-fi
-
 # Patchset ntdll-Manifest_Range
 # |
 # | This patchset fixes the following Wine bugs:
@@ -3188,19 +3731,36 @@ fi
 # Patchset ntdll-NtAccessCheck
 # |
 # | Modified files:
-# |   *	dlls/advapi32/tests/security.c, dlls/ntdll/unix/security.c
+# |   *	dlls/advapi32/tests/security.c, dlls/ntdll/sec.c
 # |
 if test "$enable_ntdll_NtAccessCheck" -eq 1; then
 	patch_apply ntdll-NtAccessCheck/0001-ntdll-Improve-invalid-paramater-handling-in-NtAccess.patch
 fi
 
+# Patchset ntdll-NtContinue
+# |
+# | This patchset has the following (direct or indirect) dependencies:
+# |   *	winebuild-Fake_Dlls
+# |
+# | This patchset fixes the following Wine bugs:
+# |   *	[#31910] Add stub for NtContinue
+# |   *	[#45572] League of Legends 8.12+ fails to start a game (anticheat engine, hooking of NtContinue)
+# |
+# | Modified files:
+# |   *	dlls/ntdll/exception.c, dlls/ntdll/ntdll.spec, dlls/ntdll/signal_i386.c, dlls/ntdll/signal_x86_64.c
+# |
+if test "$enable_ntdll_NtContinue" -eq 1; then
+	patch_apply ntdll-NtContinue/0001-ntdll-Add-stub-for-NtContinue.patch
+	patch_apply ntdll-NtContinue/0002-Use-NtContinue-to-continue-execution-after-exception.patch
+fi
+
 # Patchset ntdll-Pipe_SpecialCharacters
 # |
 # | This patchset fixes the following Wine bugs:
 # |   *	[#28995] Allow special characters in pipe names
 # |
 # | Modified files:
-# |   *	dlls/kernel32/tests/pipe.c, dlls/ntdll/unix/file.c
+# |   *	dlls/kernel32/tests/pipe.c, dlls/ntdll/directory.c
 # |
 if test "$enable_ntdll_Pipe_SpecialCharacters" -eq 1; then
 	patch_apply ntdll-Pipe_SpecialCharacters/0001-ntdll-Allow-special-characters-in-pipe-names.patch
@@ -3215,12 +3775,24 @@ fi
 # |   *	[#37487] Resolve \\SystemRoot\\ prefix when opening files
 # |
 # | Modified files:
-# |   *	dlls/ntdll/tests/file.c, dlls/ntdll/unix/file.c
+# |   *	dlls/ntdll/directory.c, dlls/ntdll/tests/file.c
 # |
 if test "$enable_ntdll_NtDevicePath" -eq 1; then
 	patch_apply ntdll-NtDevicePath/0001-ntdll-Implement-opening-files-through-nt-device-path.patch
 fi
 
+# Patchset ntdll-NtQueryEaFile
+# |
+# | This patchset has the following (direct or indirect) dependencies:
+# |   *	ntdll-Junction_Points
+# |
+# | Modified files:
+# |   *	dlls/ntdll/file.c, dlls/ntdll/tests/file.c
+# |
+if test "$enable_ntdll_NtQueryEaFile" -eq 1; then
+	patch_apply ntdll-NtQueryEaFile/0001-ntdll-Improve-stub-of-NtQueryEaFile.patch
+fi
+
 # Patchset ntdll-NtQuerySection
 # |
 # | Modified files:
@@ -3230,6 +3802,28 @@ if test "$enable_ntdll_NtQuerySection" -eq 1; then
 	patch_apply ntdll-NtQuerySection/0002-kernel32-tests-Add-tests-for-NtQuerySection.patch
 fi
 
+# Patchset ntdll-NtQueryVirtualMemory
+# |
+# | This patchset has the following (direct or indirect) dependencies:
+# |   *	ntdll-Pipe_SpecialCharacters, ntdll-NtDevicePath
+# |
+# | This patchset fixes the following Wine bugs:
+# |   *	[#23999] Implement MemorySectionName class in NtQueryVirtualMemory
+# |   *	[#27248] Implement K32GetMappedFileName
+# |
+# | Modified files:
+# |   *	dlls/kernelbase/debug.c, dlls/ntdll/directory.c, dlls/ntdll/ntdll_misc.h, dlls/ntdll/tests/info.c, dlls/ntdll/virtual.c,
+# | 	dlls/psapi/tests/psapi_main.c, server/mapping.c, server/protocol.def
+# |
+if test "$enable_ntdll_NtQueryVirtualMemory" -eq 1; then
+	patch_apply ntdll-NtQueryVirtualMemory/0003-ntdll-Implement-NtQueryVirtualMemory-MemorySectionNa.patch
+	patch_apply ntdll-NtQueryVirtualMemory/0004-ntdll-tests-Add-tests-for-NtQueryVirtualMemory-Memor.patch
+	patch_apply ntdll-NtQueryVirtualMemory/0005-ntdll-tests-Add-test-to-ensure-section-name-is-full-.patch
+	patch_apply ntdll-NtQueryVirtualMemory/0006-ntdll-Allow-to-query-section-names-from-other-proces.patch
+	patch_apply ntdll-NtQueryVirtualMemory/0007-kernel32-Implement-K32GetMappedFileName.-v2.patch
+	patch_apply ntdll-NtQueryVirtualMemory/0008-ntdll-Resolve-drive-symlinks-before-returning-sectio.patch
+fi
+
 # Patchset ntdll-NtSetLdtEntries
 # |
 # | Modified files:
@@ -3247,7 +3841,7 @@ fi
 # | 	2.x)
 # |
 # | Modified files:
-# |   *	dlls/ntdll/unix/process.c
+# |   *	dlls/ntdll/process.c
 # |
 if test "$enable_ntdll_ProcessQuotaLimits" -eq 1; then
 	patch_apply ntdll-ProcessQuotaLimits/0001-ntdll-Add-fake-data-implementation-for-ProcessQuotaL.patch
@@ -3289,40 +3883,22 @@ fi
 # Patchset ntdll-Status_Mapping
 # |
 # | Modified files:
-# |   *	dlls/ntdll/tests/file.c, dlls/ntdll/unix/file.c
+# |   *	dlls/ntdll/file.c, dlls/ntdll/tests/file.c
 # |
 if test "$enable_ntdll_Status_Mapping" -eq 1; then
 	patch_apply ntdll-Status_Mapping/0001-ntdll-Return-STATUS_INVALID_DEVICE_REQUEST-when-tryi.patch
 fi
 
-# Patchset winebuild-pe_syscall_thunks
-# |
-# | This patchset fixes the following Wine bugs:
-# |   *	[#21232] Chromium-based browser engines (Chrome, Opera, Comodo Dragon, SRWare Iron) crash on startup unless '--no-
-# | 	sandbox' is used (native API sandboxing/hooking scheme incompatible with Wine)
-# |   *	[#42741] StarCraft I: 1.18 PTR fails to initialize ClientSdk.dll
-# |   *	[#45349] Multiple applications and games crash due to missing support for 64-bit syscall thunks (StreetFighter V, World
-# | 	of Warcraft)
-# |   *	[#45573] League of Legends 8.12+ fails to start a game (anticheat engine, hooking of syscall return instructions)
-# |   *	[#45650] chromium 32-bit sandbox expects different syscall thunks depending on Windows version
-# |
-# | Modified files:
-# |   *	dlls/ntdll/unix/virtual.c, tools/winebuild/import.c
-# |
-if test "$enable_winebuild_pe_syscall_thunks" -eq 1; then
-	patch_apply winebuild-pe_syscall_thunks/0002-winebuild-Call-__wine_syscall_dispatcher-through-the.patch
-fi
-
 # Patchset ntdll-Syscall_Emulation
 # |
 # | This patchset has the following (direct or indirect) dependencies:
-# |   *	winebuild-pe_syscall_thunks
+# |   *	winebuild-Fake_Dlls
 # |
 # | This patchset fixes the following Wine bugs:
 # |   *	[#48291] Detroit: Become Human crashes on launch
 # |
 # | Modified files:
-# |   *	configure.ac, dlls/ntdll/unix/signal_x86_64.c, tools/winebuild/import.c
+# |   *	configure.ac, dlls/ntdll/signal_x86_64.c, tools/winebuild/spec32.c
 # |
 if test "$enable_ntdll_Syscall_Emulation" -eq 1; then
 	patch_apply ntdll-Syscall_Emulation/0001-ntdll-Support-x86_64-syscall-emulation.patch
@@ -3335,7 +3911,7 @@ fi
 # | 	SystemExtendedProcessInformation)
 # |
 # | Modified files:
-# |   *	dlls/ntdll/unix/system.c
+# |   *	dlls/ntdll/nt.c
 # |
 if test "$enable_ntdll_SystemExtendedProcessInformation" -eq 1; then
 	patch_apply ntdll-SystemExtendedProcessInformation/0001-ntdll-Add-stub-for-NtQuerySystemInformation-SystemEx.patch
@@ -3350,12 +3926,24 @@ fi
 # |   *	[#49192] ntdll: NtQuerySystemInformation support SystemCodeIntegrityInformation
 # |
 # | Modified files:
-# |   *	dlls/ntdll/unix/system.c, include/winternl.h
+# |   *	dlls/ntdll/nt.c, include/winternl.h
 # |
 if test "$enable_ntdll_SystemCodeIntegrityInformation" -eq 1; then
 	patch_apply ntdll-SystemCodeIntegrityInformation/0001-ntdll-NtQuerySystemInformation-support-SystemCodeInt.patch
 fi
 
+# Patchset ntdll-SystemInterruptInformation
+# |
+# | This patchset fixes the following Wine bugs:
+# |   *	[#39123] Return buffer filled with random values from SystemInterruptInformation
+# |
+# | Modified files:
+# |   *	dlls/ntdll/nt.c
+# |
+if test "$enable_ntdll_SystemInterruptInformation" -eq 1; then
+	patch_apply ntdll-SystemInterruptInformation/0001-ntdll-Return-buffer-filled-with-random-values-from-S.patch
+fi
+
 # Patchset ntdll-SystemModuleInformation
 # |
 # | This patchset fixes the following Wine bugs:
@@ -3365,16 +3953,18 @@ fi
 # | 	NtQuerySystemInformation(SystemModuleInformationEx) in Windows Vista+ mode
 # |
 # | Modified files:
-# |   *	dlls/ntdll/unix/system.c, include/winternl.h
+# |   *	dlls/ntdll/nt.c, include/winternl.h
 # |
 if test "$enable_ntdll_SystemModuleInformation" -eq 1; then
+	patch_apply ntdll-SystemModuleInformation/0001-ntdll-Don-t-call-LdrQueryProcessModuleInformation-in.patch
+	patch_apply ntdll-SystemModuleInformation/0002-ntdll-Return-ntdll.dll-as-the-first-entry-for-System.patch
 	patch_apply ntdll-SystemModuleInformation/0003-ntdll-Add-stub-for-NtQuerySystemInformation-SystemMo.patch
 fi
 
 # Patchset ntdll-Zero_mod_name
 # |
 # | Modified files:
-# |   *	dlls/ntdll/loader.c
+# |   *	dlls/ntdll/loader.c, dlls/ntdll/ntdll_misc.h
 # |
 if test "$enable_ntdll_Zero_mod_name" -eq 1; then
 	patch_apply ntdll-Zero_mod_name/0001-ntdll-Initialize-mod_name-to-zero.patch
@@ -3393,22 +3983,10 @@ if test "$enable_ntdll_aarch_TEB" -eq 1; then
 	patch_apply ntdll-aarch-TEB/0002-ntdll-Always-restore-TEB-to-x18-on-aarch-64-on-retur.patch
 fi
 
-# Patchset ntdll-ext4-case-folder
-# |
-# | This patchset fixes the following Wine bugs:
-# |   *	[#47099] Support for EXT4 case folding per directory.
-# |
-# | Modified files:
-# |   *	dlls/ntdll/unix/server.c
-# |
-if test "$enable_ntdll_ext4_case_folder" -eq 1; then
-	patch_apply ntdll-ext4-case-folder/0002-ntdll-server-Mark-drive_c-as-case-insensitive-when-c.patch
-fi
-
 # Patchset ntdll-set_full_cpu_context
 # |
 # | Modified files:
-# |   *	dlls/ntdll/unix/signal_i386.c
+# |   *	dlls/ntdll/signal_i386.c
 # |
 if test "$enable_ntdll_set_full_cpu_context" -eq 1; then
 	patch_apply ntdll-set_full_cpu_context/0001-ntdll-Add-back-SS-segment-prefixes-in-set_full_cpu_c.patch
@@ -3420,7 +3998,7 @@ fi
 # |   *	[#47970] Legends of Runeterra crashes at launch
 # |
 # | Modified files:
-# |   *	dlls/ntdll/unix/signal_x86_64.c
+# |   *	dlls/ntdll/signal_x86_64.c
 # |
 if test "$enable_ntdll_x86_64_SegDs" -eq 1; then
 	patch_apply ntdll-x86_64_SegDs/0001-ntdll-Report-SegDs-to-be-identical-to-SegSs-on-x86_6.patch
@@ -3625,45 +4203,24 @@ fi
 # Patchset server-FileEndOfFileInformation
 # |
 # | Modified files:
-# |   *	dlls/ntdll/unix/file.c, server/fd.c, server/protocol.def
+# |   *	dlls/ntdll/file.c, server/fd.c, server/protocol.def
 # |
 if test "$enable_server_FileEndOfFileInformation" -eq 1; then
 	patch_apply server-FileEndOfFileInformation/0001-ntdll-Set-EOF-on-file-which-has-a-memory-mapping-sho.patch
 	patch_apply server-FileEndOfFileInformation/0002-server-Growing-files-which-are-mapped-to-memory-shou.patch
 fi
 
-# Patchset server-File_Permissions
-# |
-# | This patchset has the following (direct or indirect) dependencies:
-# |   *	ntdll-DOS_Attributes, ntdll-NtQueryEaFile, ntdll-Junction_Points
-# |
-# | This patchset fixes the following Wine bugs:
-# |   *	[#44691] Improve mapping of DACL to file permissions
-# |
-# | Modified files:
-# |   *	dlls/advapi32/tests/security.c, dlls/ntdll/tests/file.c, server/fd.c, server/file.c
-# |
-if test "$enable_server_File_Permissions" -eq 1; then
-	patch_apply server-File_Permissions/0001-server-Improve-STATUS_CANNOT_DELETE-checks-for-direc.patch
-	patch_apply server-File_Permissions/0002-server-Allow-to-open-files-without-any-permission-bi.patch
-	patch_apply server-File_Permissions/0003-server-When-creating-new-directories-temporarily-giv.patch
-	patch_apply server-File_Permissions/0004-advapi32-tests-Add-tests-for-ACL-inheritance-in-Crea.patch
-	patch_apply server-File_Permissions/0005-advapi32-tests-Add-ACL-inheritance-tests-for-creatin.patch
-	patch_apply server-File_Permissions/0006-ntdll-tests-Added-tests-for-open-behaviour-on-readon.patch
-	patch_apply server-File_Permissions/0007-server-FILE_WRITE_ATTRIBUTES-should-succeed-for-read.patch
-	patch_apply server-File_Permissions/0008-server-Improve-mapping-of-DACL-to-file-permissions.patch
-fi
-
 # Patchset server-Stored_ACLs
 # |
 # | This patchset has the following (direct or indirect) dependencies:
-# |   *	ntdll-DOS_Attributes, ntdll-NtQueryEaFile, ntdll-Junction_Points, server-File_Permissions
+# |   *	ntdll-Junction_Points, ntdll-DOS_Attributes, server-File_Permissions
 # |
 # | This patchset fixes the following Wine bugs:
 # |   *	[#33576] Support for stored file ACLs
 # |
 # | Modified files:
-# |   *	dlls/advapi32/tests/security.c, server/change.c, server/file.c, server/file.h, server/object.c, server/object.h
+# |   *	dlls/advapi32/tests/security.c, include/wine/port.h, server/change.c, server/file.c, server/file.h, server/object.c,
+# | 	server/object.h
 # |
 if test "$enable_server_Stored_ACLs" -eq 1; then
 	patch_apply server-Stored_ACLs/0001-server-Unify-the-storage-of-security-attributes-for-.patch
@@ -3678,7 +4235,7 @@ fi
 # Patchset server-Inherited_ACLs
 # |
 # | This patchset has the following (direct or indirect) dependencies:
-# |   *	ntdll-DOS_Attributes, ntdll-NtQueryEaFile, ntdll-Junction_Points, server-File_Permissions, server-Stored_ACLs
+# |   *	ntdll-Junction_Points, ntdll-DOS_Attributes, server-File_Permissions, server-Stored_ACLs
 # |
 # | Modified files:
 # |   *	dlls/advapi32/tests/security.c, server/file.c
@@ -3687,31 +4244,14 @@ if test "$enable_server_Inherited_ACLs" -eq 1; then
 	patch_apply server-Inherited_ACLs/0001-server-Inherit-security-attributes-from-parent-direc.patch
 fi
 
-# Patchset server-Key_State
-# |
-# | This patchset fixes the following Wine bugs:
-# |   *	[#31899] Implement locking and synchronization of key states
-# |   *	[#35907] Fix caps lock state issues with multiple processes
-# |
-# | Modified files:
-# |   *	server/queue.c
-# |
-if test "$enable_server_Key_State" -eq 1; then
-	patch_apply server-Key_State/0001-server-Introduce-a-helper-function-to-update-the-thr.patch
-	patch_apply server-Key_State/0002-server-Implement-locking-and-synchronization-of-keys.patch
-fi
-
 # Patchset server-Object_Types
 # |
-# | This patchset has the following (direct or indirect) dependencies:
-# |   *	ntdll-SystemModuleInformation
-# |
 # | This patchset fixes the following Wine bugs:
 # |   *	[#44629] Process Hacker can't enumerate handles
 # |   *	[#45374] Yet Another Process Monitor (.NET 2.0 app) reports System.AccessViolationException
 # |
 # | Modified files:
-# |   *	dlls/ntdll/tests/info.c, dlls/ntdll/tests/om.c, dlls/ntdll/unix/file.c, dlls/ntdll/unix/system.c, include/winternl.h,
+# |   *	dlls/ntdll/nt.c, dlls/ntdll/om.c, dlls/ntdll/tests/info.c, dlls/ntdll/tests/om.c, include/winternl.h,
 # | 	server/completion.c, server/directory.c, server/event.c, server/file.c, server/handle.c, server/mailslot.c,
 # | 	server/main.c, server/mapping.c, server/mutex.c, server/named_pipe.c, server/object.c, server/object.h,
 # | 	server/process.c, server/protocol.def, server/registry.c, server/semaphore.c, server/symlink.c, server/thread.c,
@@ -3727,27 +4267,6 @@ if test "$enable_server_Object_Types" -eq 1; then
 	patch_apply server-Object_Types/0010-ntdll-Mimic-object-type-behavior-for-different-windo.patch
 fi
 
-# Patchset server-PeekMessage
-# |
-# | This patchset fixes the following Wine bugs:
-# |   *	[#28884] GetMessage should remove already seen messages with higher priority
-# |
-# | Modified files:
-# |   *	dlls/user32/tests/msg.c, server/queue.c
-# |
-if test "$enable_server_PeekMessage" -eq 1; then
-	patch_apply server-PeekMessage/0001-server-Fix-handling-of-GetMessage-after-previous-Pee.patch
-fi
-
-# Patchset server-Realtime_Priority
-# |
-# | Modified files:
-# |   *	server/Makefile.in, server/main.c, server/scheduler.c, server/thread.c, server/thread.h
-# |
-if test "$enable_server_Realtime_Priority" -eq 1; then
-	patch_apply server-Realtime_Priority/0001-wineserver-Draft-to-implement-priority-levels-throug.patch
-fi
-
 # Patchset server-Registry_Notifications
 # |
 # | Modified files:
@@ -3758,15 +4277,6 @@ if test "$enable_server_Registry_Notifications" -eq 1; then
 	patch_apply server-Registry_Notifications/0002-server-Introduce-refcounting-for-registry-notificati.patch
 fi
 
-# Patchset server-Signal_Thread
-# |
-# | Modified files:
-# |   *	server/thread.c, server/thread.h
-# |
-if test "$enable_server_Signal_Thread" -eq 1; then
-	patch_apply server-Signal_Thread/0001-server-Do-not-signal-thread-until-it-is-really-gone.patch
-fi
-
 # Patchset setupapi-DiskSpaceList
 # |
 # | Modified files:
@@ -3821,7 +4331,8 @@ fi
 # Patchset shell32-Progress_Dialog
 # |
 # | This patchset has the following (direct or indirect) dependencies:
-# |   *	ntdll-FileDispositionInformation, kernel32-CopyFileEx, shell32-SHFileOperation_Move
+# |   *	ntdll-Junction_Points, server-File_Permissions, ntdll-FileDispositionInformation, kernel32-CopyFileEx,
+# | 	shell32-SHFileOperation_Move
 # |
 # | Modified files:
 # |   *	dlls/shell32/shell32.rc, dlls/shell32/shlfileop.c, dlls/shell32/shresdef.h
@@ -3836,7 +4347,8 @@ fi
 # Patchset shell32-ACE_Viewer
 # |
 # | This patchset has the following (direct or indirect) dependencies:
-# |   *	ntdll-FileDispositionInformation, kernel32-CopyFileEx, shell32-SHFileOperation_Move, shell32-Progress_Dialog
+# |   *	ntdll-Junction_Points, server-File_Permissions, ntdll-FileDispositionInformation, kernel32-CopyFileEx,
+# | 	shell32-SHFileOperation_Move, shell32-Progress_Dialog
 # |
 # | Modified files:
 # |   *	dlls/aclui/Makefile.in, dlls/aclui/aclui.rc, dlls/aclui/aclui_main.c, dlls/aclui/resource.h, dlls/aclui/user_icons.bmp,
@@ -5069,6 +5581,9 @@ fi
 
 # Patchset wow64cpu-Wow64Transition
 # |
+# | This patchset has the following (direct or indirect) dependencies:
+# |   *	Staging, advapi32-CreateRestrictedToken, advapi32-Token_Integrity_Level
+# |
 # | This patchset fixes the following Wine bugs:
 # |   *	[#45567] League of Legends 8.12+ fails to start a game (anticheat engine, validation of WoW64 syscall dispatcher)
 # |
@@ -5108,6 +5623,16 @@ if test "$enable_ws2_32_Connect_Time" -eq 1; then
 	patch_apply ws2_32-Connect_Time/0001-ws2_32-Implement-returning-the-proper-time-with-SO_C.patch
 fi
 
+# Patchset ws2_32-TransmitFile
+# |
+# | Modified files:
+# |   *	dlls/ws2_32/socket.c, dlls/ws2_32/tests/sock.c, include/winsock.h, server/protocol.def, server/sock.c
+# |
+if test "$enable_ws2_32_TransmitFile" -eq 1; then
+	patch_apply ws2_32-TransmitFile/0001-ws2_32-Add-support-for-TF_DISCONNECT-to-TransmitFile.patch
+	patch_apply ws2_32-TransmitFile/0002-ws2_32-Add-support-for-TF_REUSE_SOCKET-to-TransmitFi.patch
+fi
+
 # Patchset ws2_32-getaddrinfo
 # |
 # | Modified files:
diff --git a/patches/server-FileEndOfFileInformation/0001-ntdll-Set-EOF-on-file-which-has-a-memory-mapping-sho.patch b/patches/server-FileEndOfFileInformation/0001-ntdll-Set-EOF-on-file-which-has-a-memory-mapping-sho.patch
index 64df7cee..0e92a640 100644
--- a/patches/server-FileEndOfFileInformation/0001-ntdll-Set-EOF-on-file-which-has-a-memory-mapping-sho.patch
+++ b/patches/server-FileEndOfFileInformation/0001-ntdll-Set-EOF-on-file-which-has-a-memory-mapping-sho.patch
@@ -1,20 +1,19 @@
-From b956b7f35f07153aa61a9a57a1b5bb7f2f9d1e8b Mon Sep 17 00:00:00 2001
+From 3b5ea5ff15907d1d8f1902a08451b0a03eb11dc9 Mon Sep 17 00:00:00 2001
 From: Qian Hong <qhong@codeweavers.com>
 Date: Fri, 21 Aug 2015 21:58:51 +0800
-Subject: [PATCH] ntdll: Set EOF on file which has a memory mapping should
- fail.
+Subject: ntdll: Set EOF on file which has a memory mapping should fail.
 
 ---
- dlls/ntdll/unix/file.c | 23 ++++--------------
- server/fd.c            | 55 ++++++++++++++++++++++++++++++++++++++++++
- server/protocol.def    |  7 ++++++
- 3 files changed, 67 insertions(+), 18 deletions(-)
+ dlls/ntdll/file.c   | 27 +++++++-------------------
+ server/fd.c         | 55 +++++++++++++++++++++++++++++++++++++++++++++++++++++
+ server/protocol.def |  7 +++++++
+ 3 files changed, 69 insertions(+), 20 deletions(-)
 
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index d39ca8cd635..b0ec1ff3f5f 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -4038,28 +4038,15 @@ NTSTATUS WINAPI NtSetInformationFile( HANDLE handle, IO_STATUS_BLOCK *io,
+diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
+index be6b591..8c9b076 100644
+--- a/dlls/ntdll/file.c
++++ b/dlls/ntdll/file.c
+@@ -2650,30 +2650,17 @@ NTSTATUS WINAPI NtSetInformationFile(HANDLE handle, PIO_STATUS_BLOCK io,
      case FileEndOfFileInformation:
          if (len >= sizeof(FILE_END_OF_FILE_INFORMATION))
          {
@@ -41,18 +40,22 @@ index d39ca8cd635..b0ec1ff3f5f 100644
 +                req->eof      = info->EndOfFile.QuadPart;
 +                io->u.Status  = wine_server_call( req );
              }
--            io->u.Status = errno_to_status( errno );
+-            io->u.Status = FILE_GetNtStatus();
 -
 -            if (needs_close) close( fd );
+-        }
+-        else io->u.Status = STATUS_INVALID_PARAMETER_3;
 +            SERVER_END_REQ;
-         }
-         else io->u.Status = STATUS_INVALID_PARAMETER_3;
++        } else
++            io->u.Status = STATUS_INVALID_PARAMETER_3;
          break;
+ 
+     case FilePipeInformation:
 diff --git a/server/fd.c b/server/fd.c
-index 7ea8ac273e5..3a92ca5fd48 100644
+index 06d1d81bdb0..7b016acb382 100644
 --- a/server/fd.c
 +++ b/server/fd.c
-@@ -2574,6 +2574,50 @@ failed:
+@@ -2534,6 +2534,50 @@ failed:
      free( name );
  }
  
@@ -103,7 +106,7 @@ index 7ea8ac273e5..3a92ca5fd48 100644
  struct completion *fd_get_completion( struct fd *fd, apc_param_t *p_key )
  {
      *p_key = fd->comp_key;
-@@ -2852,3 +2896,14 @@ DECL_HANDLER(set_fd_name_info)
+@@ -2812,3 +2856,14 @@ DECL_HANDLER(set_fd_name_info)
      }
      if (root_fd) release_object( root_fd );
  }
@@ -119,10 +122,10 @@ index 7ea8ac273e5..3a92ca5fd48 100644
 +    }
 +}
 diff --git a/server/protocol.def b/server/protocol.def
-index c3442c06e9b..80ca76f9271 100644
+index 423e6079009..c6110fc675e 100644
 --- a/server/protocol.def
 +++ b/server/protocol.def
-@@ -3822,6 +3822,13 @@ struct handle_info
+@@ -3821,6 +3821,13 @@ struct handle_info
  @END
  
  
@@ -137,5 +140,5 @@ index c3442c06e9b..80ca76f9271 100644
  @REQ(get_window_layered_info)
      user_handle_t  handle;        /* handle to the window */
 -- 
-2.27.0
+2.26.2
 
diff --git a/patches/server-File_Permissions/0002-server-Allow-to-open-files-without-any-permission-bi.patch b/patches/server-File_Permissions/0002-server-Allow-to-open-files-without-any-permission-bi.patch
index 703c81c7..cefe93f4 100644
--- a/patches/server-File_Permissions/0002-server-Allow-to-open-files-without-any-permission-bi.patch
+++ b/patches/server-File_Permissions/0002-server-Allow-to-open-files-without-any-permission-bi.patch
@@ -1,4 +1,4 @@
-From 7f1169fde63549646dcd24d60ea648db3a11765c Mon Sep 17 00:00:00 2001
+From 9ecf9653d3f4d564f000d4e0f7f96ae0cd3610b2 Mon Sep 17 00:00:00 2001
 From: Sebastian Lackner <sebastian@fds-team.de>
 Date: Fri, 3 Apr 2015 03:58:47 +0200
 Subject: [PATCH] server: Allow to open files without any permission bits. (try
@@ -13,7 +13,7 @@ Changes in v2:
  2 files changed, 32 insertions(+), 20 deletions(-)
 
 diff --git a/dlls/advapi32/tests/security.c b/dlls/advapi32/tests/security.c
-index 825f8451904..948c257cea2 100644
+index 1ec2e6bbb48..cc59210e609 100644
 --- a/dlls/advapi32/tests/security.c
 +++ b/dlls/advapi32/tests/security.c
 @@ -3702,17 +3702,13 @@ static void test_CreateDirectoryA(void)
@@ -65,10 +65,10 @@ index 825f8451904..948c257cea2 100644
  
  done:
 diff --git a/server/fd.c b/server/fd.c
-index 819f77d041e..c1401acc1aa 100644
+index d238c43cf1f..8292a0b82f2 100644
 --- a/server/fd.c
 +++ b/server/fd.c
-@@ -1892,6 +1892,7 @@ struct fd *open_fd( struct fd *root, const char *name, int flags, mode_t *mode,
+@@ -1825,6 +1825,7 @@ struct fd *open_fd( struct fd *root, const char *name, int flags, mode_t *mode,
      int root_fd = -1;
      int rw_mode;
      char *path;
@@ -76,7 +76,7 @@ index 819f77d041e..c1401acc1aa 100644
      int created = (flags & O_CREAT);
  
      if (((options & FILE_DELETE_ON_CLOSE) && !(access & DELETE)) ||
-@@ -1958,10 +1959,28 @@ struct fd *open_fd( struct fd *root, const char *name, int flags, mode_t *mode,
+@@ -1891,10 +1892,28 @@ struct fd *open_fd( struct fd *root, const char *name, int flags, mode_t *mode,
              fd->unix_fd = open( name, rw_mode | O_SYMLINK | (flags & ~O_TRUNC), *mode );
          }
  #endif
@@ -105,14 +105,14 @@ index 819f77d041e..c1401acc1aa 100644
              goto error;
          }
      }
-@@ -1978,6 +1997,7 @@ struct fd *open_fd( struct fd *root, const char *name, int flags, mode_t *mode,
+@@ -1909,6 +1928,7 @@ struct fd *open_fd( struct fd *root, const char *name, int flags, mode_t *mode,
+     closed_fd->unix_fd = fd->unix_fd;
      closed_fd->unlink = 0;
-     closed_fd->unlink_name = fd->unlink_name;
      closed_fd->unix_name = fd->unix_name;
 +    if (do_chmod) chmod( name, *mode );
-     lstat( fd->unlink_name, &st );
+     lstat( fd->unix_name, &st );
      *mode = st.st_mode;
  
 -- 
-2.27.0
+2.25.1
 
diff --git a/patches/server-Key_State/0001-server-Introduce-a-helper-function-to-update-the-thr.patch b/patches/server-Key_State/0001-server-Introduce-a-helper-function-to-update-the-thr.patch
index c34e64b3..2f57b1f8 100644
--- a/patches/server-Key_State/0001-server-Introduce-a-helper-function-to-update-the-thr.patch
+++ b/patches/server-Key_State/0001-server-Introduce-a-helper-function-to-update-the-thr.patch
@@ -1,4 +1,4 @@
-From f20e406fad78eeebea4e07407e6b05e069c8475f Mon Sep 17 00:00:00 2001
+From 0fefda7a02d52d1c8813d7caaf2ca3cc6e352a29 Mon Sep 17 00:00:00 2001
 From: Sebastian Lackner <sebastian@fds-team.de>
 Date: Thu, 12 Mar 2015 00:44:25 +0100
 Subject: [PATCH] server: Introduce a helper function to update the
@@ -9,7 +9,7 @@ Subject: [PATCH] server: Introduce a helper function to update the
  1 file changed, 23 insertions(+), 17 deletions(-)
 
 diff --git a/server/queue.c b/server/queue.c
-index a65eab38bdc..b8943bc4b61 100644
+index 432885f9e4c..0a20bd3639d 100644
 --- a/server/queue.c
 +++ b/server/queue.c
 @@ -1295,9 +1295,9 @@ static void set_input_key_state( unsigned char *keystate, unsigned char key, int
@@ -61,16 +61,16 @@ index a65eab38bdc..b8943bc4b61 100644
  }
  
  /* release the hardware message currently being processed by the given thread */
-@@ -1408,7 +1414,7 @@ static void release_hardware_message( struct msg_queue *queue, unsigned int hw_i
-     }
-     if (clr_bit) clear_queue_bits( queue, clr_bit );
+@@ -1413,7 +1419,7 @@ static void release_hardware_message( struct msg_queue *queue, unsigned int hw_i
+         }
+         if (clr_bit) clear_queue_bits( queue, clr_bit );
  
--    update_input_key_state( input->desktop, input->keystate, msg->msg, msg->wparam );
-+    update_input_key_state( input, msg->msg, msg->wparam );
-     list_remove( &msg->entry );
-     free_message( msg );
- }
-@@ -1526,7 +1532,7 @@ static void queue_hardware_message( struct desktop *desktop, struct message *msg
+-        update_input_key_state( input->desktop, input->keystate, msg->msg, msg->wparam );
++        update_input_key_state( input, msg->msg, msg->wparam );
+         list_remove( &msg->entry );
+         free_message( msg );
+     }
+@@ -1532,7 +1538,7 @@ static void queue_hardware_message( struct desktop *desktop, struct message *msg
      struct thread_input *input;
      unsigned int msg_code;
  
@@ -79,7 +79,7 @@ index a65eab38bdc..b8943bc4b61 100644
      last_input_time = get_tick_count();
      if (msg->msg != WM_MOUSEMOVE) always_queue = 1;
  
-@@ -1561,7 +1567,7 @@ static void queue_hardware_message( struct desktop *desktop, struct message *msg
+@@ -1567,7 +1573,7 @@ static void queue_hardware_message( struct desktop *desktop, struct message *msg
      win = find_hardware_message_window( desktop, input, msg, &msg_code, &thread );
      if (!win || !thread)
      {
@@ -88,7 +88,7 @@ index a65eab38bdc..b8943bc4b61 100644
          free_message( msg );
          return;
      }
-@@ -1899,7 +1905,7 @@ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, c
+@@ -1905,7 +1911,7 @@ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, c
  
      if ((device = current->process->rawinput_kbd) && (device->flags & RIDEV_NOLEGACY))
      {
@@ -97,7 +97,7 @@ index a65eab38bdc..b8943bc4b61 100644
          return 0;
      }
  
-@@ -2028,7 +2034,7 @@ static int get_hardware_message( struct thread *thread, unsigned int hw_id, user
+@@ -2034,7 +2040,7 @@ static int get_hardware_message( struct thread *thread, unsigned int hw_id, user
          if (!win || !win_thread)
          {
              /* no window at all, remove it */
@@ -106,7 +106,7 @@ index a65eab38bdc..b8943bc4b61 100644
              list_remove( &msg->entry );
              free_message( msg );
              continue;
-@@ -2044,7 +2050,7 @@ static int get_hardware_message( struct thread *thread, unsigned int hw_id, user
+@@ -2050,7 +2056,7 @@ static int get_hardware_message( struct thread *thread, unsigned int hw_id, user
              else
              {
                  /* for another thread input, drop it */
diff --git a/patches/server-Object_Types/0001-ntdll-Implement-SystemExtendedHandleInformation-in-N.patch b/patches/server-Object_Types/0001-ntdll-Implement-SystemExtendedHandleInformation-in-N.patch
index 2d139d6a..3b9b864c 100644
--- a/patches/server-Object_Types/0001-ntdll-Implement-SystemExtendedHandleInformation-in-N.patch
+++ b/patches/server-Object_Types/0001-ntdll-Implement-SystemExtendedHandleInformation-in-N.patch
@@ -1,20 +1,82 @@
-From 01c9f751698b45255b3a43f44ae656bf09646ddc Mon Sep 17 00:00:00 2001
+From 0384d32afa328e76bff7f8e508201ce2535ee763 Mon Sep 17 00:00:00 2001
 From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
 Date: Tue, 7 Mar 2017 18:30:33 +0100
-Subject: [PATCH] ntdll: Implement SystemExtendedHandleInformation in
+Subject: ntdll: Implement SystemExtendedHandleInformation in
  NtQuerySystemInformation.
 
 ---
- dlls/ntdll/tests/info.c  | 51 +++++++++++++++++++++++++++++++++++++++
- dlls/ntdll/unix/system.c | 52 ++++++++++++++++++++++++++++++++++++++++
- include/winternl.h       | 21 ++++++++++++++++
- 3 files changed, 124 insertions(+)
+ dlls/ntdll/nt.c         | 51 +++++++++++++++++++++++++++++++++++++++++
+ dlls/ntdll/tests/info.c | 60 +++++++++++++++++++++++++++++++++++++++++++++++++
+ include/winternl.h      | 21 +++++++++++++++++
+ 3 files changed, 132 insertions(+)
 
+diff --git a/dlls/ntdll/nt.c b/dlls/ntdll/nt.c
+index de8f16f9a0..a939298d19 100644
+--- a/dlls/ntdll/nt.c
++++ b/dlls/ntdll/nt.c
+@@ -2294,6 +2294,57 @@ NTSTATUS WINAPI NtQuerySystemInformation(
+             RtlFreeHeap( GetProcessHeap(), 0, info );
+         }
+         break;
++    case SystemExtendedHandleInformation:
++        {
++            struct handle_info *info;
++            DWORD i, num_handles;
++
++            if (Length < sizeof(SYSTEM_HANDLE_INFORMATION_EX))
++            {
++                ret = STATUS_INFO_LENGTH_MISMATCH;
++                break;
++            }
++
++            if (!SystemInformation)
++            {
++                ret = STATUS_ACCESS_VIOLATION;
++                break;
++            }
++
++            num_handles = (Length - FIELD_OFFSET( SYSTEM_HANDLE_INFORMATION_EX, Handle ));
++            num_handles /= sizeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX);
++            if (!(info = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*info) * num_handles )))
++                return STATUS_NO_MEMORY;
++
++            SERVER_START_REQ( get_system_handles )
++            {
++                wine_server_set_reply( req, info, sizeof(*info) * num_handles );
++                if (!(ret = wine_server_call( req )))
++                {
++                    SYSTEM_HANDLE_INFORMATION_EX *shi = SystemInformation;
++                    shi->Count = wine_server_reply_size( req ) / sizeof(*info);
++                    shi->Reserved = 0;
++                    len = FIELD_OFFSET( SYSTEM_HANDLE_INFORMATION_EX, Handle[shi->Count] );
++                    for (i = 0; i < shi->Count; i++)
++                    {
++                        memset( &shi->Handle[i], 0, sizeof(shi->Handle[i]) );
++                        shi->Handle[i].UniqueProcessId = info[i].owner;
++                        shi->Handle[i].HandleValue     = info[i].handle;
++                        shi->Handle[i].GrantedAccess   = info[i].access;
++                        /* FIXME: Fill out remaining fields */
++                    }
++                }
++                else if (ret == STATUS_BUFFER_TOO_SMALL)
++                {
++                    len = FIELD_OFFSET( SYSTEM_HANDLE_INFORMATION_EX, Handle[reply->count] );
++                    ret = STATUS_INFO_LENGTH_MISMATCH;
++                }
++            }
++            SERVER_END_REQ;
++
++            RtlFreeHeap( GetProcessHeap(), 0, info );
++        }
++        break;
+     case SystemCacheInformation:
+         {
+             SYSTEM_CACHE_INFORMATION sci;
 diff --git a/dlls/ntdll/tests/info.c b/dlls/ntdll/tests/info.c
-index e5137ef5a45..04b8a6c454d 100644
+index 32cb4f5a5d..c65a74bf5e 100644
 --- a/dlls/ntdll/tests/info.c
 +++ b/dlls/ntdll/tests/info.c
-@@ -570,6 +570,56 @@ done:
+@@ -561,6 +561,62 @@ done:
      HeapFree( GetProcessHeap(), 0, shi);
  }
  
@@ -52,6 +114,12 @@ index e5137ef5a45..04b8a6c454d 100644
 +                ((HANDLE)(ULONG_PTR)shi->Handle[i].HandleValue == EventHandle);
 +    ok( found, "Expected to find event handle %p (pid %x) in handle list\n", EventHandle, GetCurrentProcessId() );
 +
++    if (!found)
++    {
++        for (i = 0; i < shi->Count; i++)
++            trace( "%d: handle %x pid %x\n", i, (DWORD)shi->Handle[i].HandleValue, (DWORD)shi->Handle[i].UniqueProcessId );
++    }
++
 +    CloseHandle(EventHandle);
 +
 +    ReturnLength = 0xdeadbeef;
@@ -71,82 +139,22 @@ index e5137ef5a45..04b8a6c454d 100644
  static void test_query_cache(void)
  {
      NTSTATUS status;
-@@ -2593,6 +2643,7 @@ START_TEST(info)
-     test_query_procperf();
-     test_query_module();
+@@ -2147,6 +2203,10 @@ START_TEST(info)
+     trace("Starting test_query_handle()\n");
      test_query_handle();
-+    test_query_handle_ex();
-     test_query_cache();
-     test_query_interrupt();
-     test_time_adjustment();
-diff --git a/dlls/ntdll/unix/system.c b/dlls/ntdll/unix/system.c
-index e34f6ab9384..4597a8d788e 100644
---- a/dlls/ntdll/unix/system.c
-+++ b/dlls/ntdll/unix/system.c
-@@ -2399,6 +2399,58 @@ NTSTATUS WINAPI NtQuerySystemInformation( SYSTEM_INFORMATION_CLASS class,
-         break;
-     }
  
-+    case SystemExtendedHandleInformation:
-+    {
-+        struct handle_info *handle_info;
-+        DWORD i, num_handles;
-+
-+        if (size < sizeof(SYSTEM_HANDLE_INFORMATION_EX))
-+        {
-+            ret = STATUS_INFO_LENGTH_MISMATCH;
-+            break;
-+        }
-+
-+        if (!info)
-+        {
-+            ret = STATUS_ACCESS_VIOLATION;
-+            break;
-+        }
-+
-+        num_handles = size - FIELD_OFFSET( SYSTEM_HANDLE_INFORMATION_EX, Handle );
-+        num_handles /= sizeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX);
-+        if (!(handle_info = malloc( sizeof(*handle_info) * num_handles )))
-+            return STATUS_NO_MEMORY;
-+
-+        SERVER_START_REQ( get_system_handles )
-+        {
-+            wine_server_set_reply( req, handle_info, sizeof(*handle_info) * num_handles );
-+            if (!(ret = wine_server_call( req )))
-+            {
-+                SYSTEM_HANDLE_INFORMATION_EX *shi = info;
-+                shi->Count = wine_server_reply_size( req ) / sizeof(*handle_info);
-+                shi->Reserved = 0;
-+                len = FIELD_OFFSET( SYSTEM_HANDLE_INFORMATION_EX, Handle[shi->Count] );
-+                for (i = 0; i < shi->Count; i++)
-+                {
-+                    memset( &shi->Handle[i], 0, sizeof(shi->Handle[i]) );
-+                    shi->Handle[i].UniqueProcessId = handle_info[i].owner;
-+                    shi->Handle[i].HandleValue     = handle_info[i].handle;
-+                    shi->Handle[i].GrantedAccess   = handle_info[i].access;
-+                    /* FIXME: Fill out remaining fields */
-+                }
-+            }
-+            else if (ret == STATUS_BUFFER_TOO_SMALL)
-+            {
-+                len = FIELD_OFFSET( SYSTEM_HANDLE_INFORMATION_EX, Handle[reply->count] );
-+                ret = STATUS_INFO_LENGTH_MISMATCH;
-+            }
-+        }
-+        SERVER_END_REQ;
-+
-+        free( handle_info );
-+        break;
-+    }
++    /* 0x40 SystemHandleInformation */
++    trace("Starting test_query_handle_ex()\n");
++    test_query_handle_ex();
 +
-     case SystemCacheInformation:
-     {
-         SYSTEM_CACHE_INFORMATION sci = { 0 };
+     /* 0x15 SystemCacheInformation */
+     trace("Starting test_query_cache()\n");
+     test_query_cache();
 diff --git a/include/winternl.h b/include/winternl.h
-index 091a22376f8..1266f55c6b1 100644
+index 87b2c4d253..7ffe4f6c81 100644
 --- a/include/winternl.h
 +++ b/include/winternl.h
-@@ -1532,6 +1532,27 @@ typedef struct _SYSTEM_HANDLE_INFORMATION {
+@@ -1442,6 +1442,27 @@ typedef struct _SYSTEM_HANDLE_INFORMATION {
      SYSTEM_HANDLE_ENTRY Handle[1];
  } SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;
  
@@ -175,5 +183,5 @@ index 091a22376f8..1266f55c6b1 100644
  
  typedef struct _SYSTEM_CACHE_INFORMATION {
 -- 
-2.27.0
+2.11.0
 
diff --git a/patches/server-Object_Types/0002-ntdll-Implement-ObjectTypesInformation-in-NtQueryObj.patch b/patches/server-Object_Types/0002-ntdll-Implement-ObjectTypesInformation-in-NtQueryObj.patch
index 8a7ff853..99ea6b2d 100644
--- a/patches/server-Object_Types/0002-ntdll-Implement-ObjectTypesInformation-in-NtQueryObj.patch
+++ b/patches/server-Object_Types/0002-ntdll-Implement-ObjectTypesInformation-in-NtQueryObj.patch
@@ -1,21 +1,90 @@
-From fb47d0b55447f5ec93fb5091fc318c92651f0b40 Mon Sep 17 00:00:00 2001
+From df0394fbe1b04909081ab265eb8ec7f20ff4e8b6 Mon Sep 17 00:00:00 2001
 From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
 Date: Wed, 8 Mar 2017 02:12:37 +0100
-Subject: [PATCH] ntdll: Implement ObjectTypesInformation in NtQueryObject.
+Subject: ntdll: Implement ObjectTypesInformation in NtQueryObject.
 
 ---
- dlls/ntdll/tests/om.c  | 57 ++++++++++++++++++++++++++++++++++++++++++
- dlls/ntdll/unix/file.c | 53 +++++++++++++++++++++++++++++++++++++++
- include/winternl.h     | 30 ++++++++++++++++++++--
- server/directory.c     | 23 +++++++++++++++++
- server/protocol.def    |  9 +++++++
- 5 files changed, 170 insertions(+), 2 deletions(-)
+ dlls/ntdll/om.c       | 51 ++++++++++++++++++++++++++++++++++++++
+ dlls/ntdll/tests/om.c | 57 +++++++++++++++++++++++++++++++++++++++++++
+ include/winternl.h    | 30 +++++++++++++++++++++--
+ server/directory.c    | 19 ++++++++++++++-
+ server/protocol.def   |  9 +++++++
+ 5 files changed, 163 insertions(+), 3 deletions(-)
 
+diff --git a/dlls/ntdll/om.c b/dlls/ntdll/om.c
+index 0b562513..88a4f800 100644
+--- a/dlls/ntdll/om.c
++++ b/dlls/ntdll/om.c
+@@ -42,6 +42,7 @@
+ 
+ WINE_DEFAULT_DEBUG_CHANNEL(ntdll);
+ 
++#define ROUND_UP(value, alignment) (((value) + ((alignment) - 1)) & ~((alignment)-1))
+ 
+ /*
+  *	Generic object functions
+@@ -187,6 +188,56 @@ NTSTATUS WINAPI NtQueryObject(IN HANDLE handle,
+             SERVER_END_REQ;
+         }
+         break;
++    case ObjectTypesInformation:
++        {
++            OBJECT_TYPES_INFORMATION *p = ptr;
++            OBJECT_TYPE_INFORMATION *type = (OBJECT_TYPE_INFORMATION *)(p + 1);
++            ULONG count, type_len, req_len = sizeof(OBJECT_TYPES_INFORMATION);
++
++            for (count = 0, status = STATUS_SUCCESS; !status; count++)
++            {
++                SERVER_START_REQ( get_object_type_by_index )
++                {
++                    req->index = count;
++                    if (len > sizeof(*type))
++                        wine_server_set_reply( req, type + 1, len - sizeof(*type) );
++                    status = wine_server_call( req );
++                    if (status == STATUS_SUCCESS)
++                    {
++                        type_len = sizeof(*type);
++                        if (reply->total)
++                            type_len += ROUND_UP( reply->total + sizeof(WCHAR), sizeof(DWORD_PTR) );
++                        req_len += type_len;
++                    }
++                    if (status == STATUS_SUCCESS && len >= req_len)
++                    {
++                        ULONG res = wine_server_reply_size( reply );
++                        memset( type, 0, sizeof(*type) );
++                        if (reply->total)
++                        {
++                            type->TypeName.Buffer = (WCHAR *)(type + 1);
++                            type->TypeName.Length = res;
++                            type->TypeName.MaximumLength = res + sizeof(WCHAR);
++                            type->TypeName.Buffer[res / sizeof(WCHAR)] = 0;
++                        }
++                        type->TypeIndex = count;
++                        type = (OBJECT_TYPE_INFORMATION *)((char *)type + type_len);
++                    }
++                }
++                SERVER_END_REQ;
++            }
++
++            if (status != STATUS_NO_MORE_ENTRIES)
++                return status;
++
++            if (used_len) *used_len = req_len;
++            if (len < req_len)
++                return STATUS_INFO_LENGTH_MISMATCH;
++
++            p->NumberOfTypes = count - 1;
++            status = STATUS_SUCCESS;
++        }
++        break;
+     case ObjectDataInformation:
+         {
+             OBJECT_DATA_INFORMATION* p = ptr;
 diff --git a/dlls/ntdll/tests/om.c b/dlls/ntdll/tests/om.c
-index d3b932bec1d..e5a123447e2 100644
+index 3f627aad..dbe7be39 100644
 --- a/dlls/ntdll/tests/om.c
 +++ b/dlls/ntdll/tests/om.c
-@@ -78,6 +78,21 @@ static void     (WINAPI *pRtlWakeAddressSingle)( const void * );
+@@ -79,6 +79,21 @@ static void     (WINAPI *pRtlWakeAddressSingle)( const void * );
  #define KEYEDEVENT_WAKE       0x0002
  #define KEYEDEVENT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x0003)
  
@@ -36,9 +105,9 @@ index d3b932bec1d..e5a123447e2 100644
 +
  static void test_case_sensitive (void)
  {
-     NTSTATUS status;
-@@ -1493,6 +1508,47 @@ static void test_query_object(void)
-     pNtClose(handle);
+     static const WCHAR buffer1[] = {'\\','B','a','s','e','N','a','m','e','d','O','b','j','e','c','t','s','\\','t','e','s','t',0};
+@@ -1579,6 +1594,47 @@ static void test_query_object(void)
+ 
  }
  
 +static void test_query_object_types(void)
@@ -85,7 +154,7 @@ index d3b932bec1d..e5a123447e2 100644
  static void test_type_mismatch(void)
  {
      HANDLE h;
-@@ -2090,6 +2146,7 @@ START_TEST(om)
+@@ -2178,6 +2234,7 @@ START_TEST(om)
      test_directory();
      test_symboliclink();
      test_query_object();
@@ -93,82 +162,11 @@ index d3b932bec1d..e5a123447e2 100644
      test_type_mismatch();
      test_event();
      test_mutant();
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index afb552be098..e18daaea5ca 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -130,6 +130,8 @@
- WINE_DEFAULT_DEBUG_CHANNEL(file);
- WINE_DECLARE_DEBUG_CHANNEL(winediag);
- 
-+#define ROUND_UP(value, alignment) (((value) + ((alignment) - 1)) & ~((alignment)-1))
-+
- #define MAX_DOS_DRIVES 26
- 
- #define FILE_WRITE_TO_END_OF_FILE      ((LONGLONG)-1)
-@@ -6593,6 +6595,57 @@ NTSTATUS WINAPI NtQueryObject( HANDLE handle, OBJECT_INFORMATION_CLASS info_clas
-         break;
-     }
- 
-+    case ObjectTypesInformation:
-+    {
-+        OBJECT_TYPES_INFORMATION *p = ptr;
-+        OBJECT_TYPE_INFORMATION *type = (OBJECT_TYPE_INFORMATION *)(p + 1);
-+        ULONG count, type_len, req_len = sizeof(OBJECT_TYPES_INFORMATION);
-+
-+        for (count = 0, status = STATUS_SUCCESS; !status; count++)
-+        {
-+            SERVER_START_REQ( get_object_type_by_index )
-+            {
-+                req->index = count;
-+                if (len > sizeof(*type))
-+                    wine_server_set_reply( req, type + 1, len - sizeof(*type) );
-+                status = wine_server_call( req );
-+                if (status == STATUS_SUCCESS)
-+                {
-+                    type_len = sizeof(*type);
-+                    if (reply->total)
-+                        type_len += ROUND_UP( reply->total + sizeof(WCHAR), sizeof(DWORD_PTR) );
-+                    req_len += type_len;
-+                }
-+                if (status == STATUS_SUCCESS && len >= req_len)
-+                {
-+                    ULONG res = wine_server_reply_size( reply );
-+                    memset( type, 0, sizeof(*type) );
-+                    if (reply->total)
-+                    {
-+                        type->TypeName.Buffer = (WCHAR *)(type + 1);
-+                        type->TypeName.Length = res;
-+                        type->TypeName.MaximumLength = res + sizeof(WCHAR);
-+                        type->TypeName.Buffer[res / sizeof(WCHAR)] = 0;
-+                    }
-+                    type->TypeIndex = count;
-+                    type = (OBJECT_TYPE_INFORMATION *)((char *)type + type_len);
-+                }
-+            }
-+            SERVER_END_REQ;
-+        }
-+
-+        if (status != STATUS_NO_MORE_ENTRIES)
-+            return status;
-+
-+        if (used_len) *used_len = req_len;
-+        if (len < req_len)
-+            return STATUS_INFO_LENGTH_MISMATCH;
-+
-+        p->NumberOfTypes = count - 1;
-+        status = STATUS_SUCCESS;
-+        break;
-+    }
-+
-     case ObjectDataInformation:
-     {
-         OBJECT_DATA_INFORMATION* p = ptr;
 diff --git a/include/winternl.h b/include/winternl.h
-index 9b628474655..2944e03afc0 100644
+index 0c8a5014..0b17c2f5 100644
 --- a/include/winternl.h
 +++ b/include/winternl.h
-@@ -1115,7 +1115,7 @@ typedef enum _OBJECT_INFORMATION_CLASS {
+@@ -826,7 +826,7 @@ typedef enum _OBJECT_INFORMATION_CLASS {
      ObjectBasicInformation,
      ObjectNameInformation,
      ObjectTypeInformation,
@@ -177,7 +175,7 @@ index 9b628474655..2944e03afc0 100644
      ObjectDataInformation
  } OBJECT_INFORMATION_CLASS, *POBJECT_INFORMATION_CLASS;
  
-@@ -1554,9 +1554,35 @@ typedef struct _OBJECT_NAME_INFORMATION {
+@@ -1237,9 +1237,35 @@ typedef struct _OBJECT_NAME_INFORMATION {
  
  typedef struct __OBJECT_TYPE_INFORMATION {
      UNICODE_STRING TypeName;
@@ -215,10 +213,10 @@ index 9b628474655..2944e03afc0 100644
  #ifdef __WINESRC__
      DWORD_PTR ExitStatus;
 diff --git a/server/directory.c b/server/directory.c
-index 4d6978f61af..82f02ddeb2e 100644
+index 6aa3a55f..6e22a741 100644
 --- a/server/directory.c
 +++ b/server/directory.c
-@@ -73,6 +73,8 @@ static const struct object_ops object_type_ops =
+@@ -71,6 +71,8 @@ static const struct object_ops object_type_ops =
      no_destroy                    /* destroy */
  };
  
@@ -227,22 +225,17 @@ index 4d6978f61af..82f02ddeb2e 100644
  
  struct directory
  {
-@@ -236,7 +238,14 @@ struct object_type *get_object_type( const struct unicode_str *name )
- 
-     if ((type = create_named_object( &dir_objtype->obj, &object_type_ops, name,
-                                      OBJ_OPENIF | OBJ_PERMANENT, NULL )))
-+    {
-+        if (get_error() != STATUS_OBJECT_NAME_EXISTS)
-+        {
-+            assert( object_type_count < ARRAY_SIZE(object_type_list) );
+@@ -236,7 +238,8 @@ struct object_type *get_object_type( const struct unicode_str *name )
+     {
+         if (get_error() != STATUS_OBJECT_NAME_EXISTS)
+         {
+-            grab_object( type );
++            assert( object_type_count < sizeof(object_type_list)/sizeof(object_type_list[0]) );
 +            object_type_list[ object_type_count++ ] = (struct object_type *)grab_object( type );
-+        }
+             make_object_static( &type->obj );
+         }
          clear_error();
-+    }
-     return type;
- }
- 
-@@ -532,3 +541,17 @@ DECL_HANDLER(get_object_type)
+@@ -529,3 +532,17 @@ DECL_HANDLER(get_object_type)
      }
      release_object( obj );
  }
@@ -261,10 +254,10 @@ index 4d6978f61af..82f02ddeb2e 100644
 +    else set_error( STATUS_NO_MORE_ENTRIES );
 +}
 diff --git a/server/protocol.def b/server/protocol.def
-index 85af5f0061c..9bc4ba12042 100644
+index 3ffb8940..0d866986 100644
 --- a/server/protocol.def
 +++ b/server/protocol.def
-@@ -3339,6 +3339,15 @@ struct handle_info
+@@ -3575,6 +3575,15 @@ struct handle_info
  @END
  
  
@@ -277,9 +270,9 @@ index 85af5f0061c..9bc4ba12042 100644
 +@END
 +
 +
- /* Query the impersonation level of an impersonation token */
- @REQ(get_token_impersonation_level)
+ /* Unlink a named object */
+ @REQ(unlink_object)
      obj_handle_t   handle;        /* handle to the object */
 -- 
-2.28.0
+2.20.1
 
diff --git a/patches/server-Object_Types/0003-server-Register-types-during-startup.patch b/patches/server-Object_Types/0003-server-Register-types-during-startup.patch
index 769f1f3c..703c49ba 100644
--- a/patches/server-Object_Types/0003-server-Register-types-during-startup.patch
+++ b/patches/server-Object_Types/0003-server-Register-types-during-startup.patch
@@ -116,22 +116,22 @@ index 781e6f3141a..42350048877 100644
  }
  
 diff --git a/server/main.c b/server/main.c
-index efb205f5292..fee10ea3d37 100644
+index 43297a3e93d..0a628c30e2d 100644
 --- a/server/main.c
 +++ b/server/main.c
-@@ -145,6 +145,7 @@ int main( int argc, char *argv[] )
-     init_signals();
+@@ -146,6 +146,7 @@ int main( int argc, char *argv[] )
      init_directories();
      init_registry();
+     init_shared_memory();
 +    init_types();
      main_loop();
      return 0;
  }
 diff --git a/server/mapping.c b/server/mapping.c
-index 0941dd87c05..88894661025 100644
+index 2a2803404cc..24ab0f63e48 100644
 --- a/server/mapping.c
 +++ b/server/mapping.c
-@@ -915,8 +915,7 @@ static void mapping_dump( struct object *obj, int verbose )
+@@ -979,8 +979,7 @@ static void mapping_dump( struct object *obj, int verbose )
  
  static struct object_type *mapping_get_type( struct object *obj )
  {
diff --git a/patches/server-Object_Types/0008-ntdll-Set-TypeIndex-for-ObjectTypeInformation-in-NtQ.patch b/patches/server-Object_Types/0008-ntdll-Set-TypeIndex-for-ObjectTypeInformation-in-NtQ.patch
index a571992a..feb7ddfc 100644
--- a/patches/server-Object_Types/0008-ntdll-Set-TypeIndex-for-ObjectTypeInformation-in-NtQ.patch
+++ b/patches/server-Object_Types/0008-ntdll-Set-TypeIndex-for-ObjectTypeInformation-in-NtQ.patch
@@ -1,32 +1,31 @@
-From 64928073fc2e463fa9f637a9a1bcddfaeb5a55c6 Mon Sep 17 00:00:00 2001
+From 1e3e93483b223c6e0e9d712fff4a8874c503c973 Mon Sep 17 00:00:00 2001
 From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
 Date: Wed, 8 Mar 2017 17:41:11 +0100
-Subject: [PATCH] ntdll: Set TypeIndex for ObjectTypeInformation in
- NtQueryObject.
+Subject: ntdll: Set TypeIndex for ObjectTypeInformation in NtQueryObject.
 
 ---
- dlls/ntdll/unix/file.c | 4 ++++
- server/directory.c     | 5 ++++-
- server/protocol.def    | 1 +
+ dlls/ntdll/om.c     | 4 ++++
+ server/directory.c  | 5 ++++-
+ server/protocol.def | 1 +
  3 files changed, 9 insertions(+), 1 deletion(-)
 
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index e18daaea5ca..ece09c12f77 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -6589,6 +6589,10 @@ NTSTATUS WINAPI NtQueryObject( HANDLE handle, OBJECT_INFORMATION_CLASS info_clas
-                     p->TypeName.Buffer[res / sizeof(WCHAR)] = 0;
-                     if (used_len) *used_len = sizeof(*p) + p->TypeName.MaximumLength;
+diff --git a/dlls/ntdll/om.c b/dlls/ntdll/om.c
+index 8911a28b20..8f54d4f49f 100644
+--- a/dlls/ntdll/om.c
++++ b/dlls/ntdll/om.c
+@@ -184,6 +184,10 @@ NTSTATUS WINAPI NtQueryObject(IN HANDLE handle,
+                         p->TypeName.Buffer[res / sizeof(WCHAR)] = 0;
+                         if (used_len) *used_len = sizeof(*p) + p->TypeName.MaximumLength;
+                     }
++                    if (status == STATUS_SUCCESS)
++                    {
++                        p->TypeIndex = reply->index;
++                    }
                  }
-+                if (status == STATUS_SUCCESS)
-+                {
-+                    p->TypeIndex = reply->index;
-+                }
              }
-         }
-         SERVER_END_REQ;
+             SERVER_END_REQ;
 diff --git a/server/directory.c b/server/directory.c
-index 65357e7f2e3..c752a652d49 100644
+index b4f53e2edf..59c8194d09 100644
 --- a/server/directory.c
 +++ b/server/directory.c
 @@ -44,6 +44,7 @@
@@ -37,17 +36,17 @@ index 65357e7f2e3..c752a652d49 100644
  };
  
  static void object_type_dump( struct object *obj, int verbose );
-@@ -240,7 +241,8 @@ struct object_type *get_object_type( const struct unicode_str *name )
+@@ -239,7 +240,8 @@ struct object_type *get_object_type( const struct unicode_str *name )
          if (get_error() != STATUS_OBJECT_NAME_EXISTS)
          {
-             assert( object_type_count < ARRAY_SIZE(object_type_list) );
+             assert( object_type_count < sizeof(object_type_list)/sizeof(object_type_list[0]) );
 -            object_type_list[ object_type_count++ ] = (struct object_type *)grab_object( type );
 +            type->index = object_type_count++;
 +            object_type_list[ type->index ] = (struct object_type *)grab_object( type );
+             make_object_static( &type->obj );
          }
          clear_error();
-     }
-@@ -535,6 +537,7 @@ DECL_HANDLER(get_object_type)
+@@ -528,6 +530,7 @@ DECL_HANDLER(get_object_type)
      {
          if ((name = get_object_name( &type->obj, &reply->total )))
              set_reply_data( name, min( reply->total, get_reply_max_size() ) );
@@ -56,10 +55,10 @@ index 65357e7f2e3..c752a652d49 100644
      }
      release_object( obj );
 diff --git a/server/protocol.def b/server/protocol.def
-index 9bc4ba12042..b52321ed519 100644
+index 98c4c58a4e..d6847f8d55 100644
 --- a/server/protocol.def
 +++ b/server/protocol.def
-@@ -3334,6 +3334,7 @@ struct handle_info
+@@ -3543,6 +3543,7 @@ struct handle_info
  @REQ(get_object_type)
      obj_handle_t   handle;        /* handle to the object */
  @REPLY
@@ -68,5 +67,5 @@ index 9bc4ba12042..b52321ed519 100644
      VARARG(type,unicode_str);     /* type name */
  @END
 -- 
-2.28.0
+2.11.0
 
diff --git a/patches/server-Object_Types/0009-ntdll-Set-object-type-for-System-Extended-HandleInfo.patch b/patches/server-Object_Types/0009-ntdll-Set-object-type-for-System-Extended-HandleInfo.patch
index 7eeb98f0..72db5626 100644
--- a/patches/server-Object_Types/0009-ntdll-Set-object-type-for-System-Extended-HandleInfo.patch
+++ b/patches/server-Object_Types/0009-ntdll-Set-object-type-for-System-Extended-HandleInfo.patch
@@ -1,44 +1,44 @@
-From f4c44206896c0fdbcff7c465e631acff98bc920e Mon Sep 17 00:00:00 2001
+From ba10e334a375c7dde7cd890554fbbade1be81a9d Mon Sep 17 00:00:00 2001
 From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
 Date: Wed, 8 Mar 2017 17:44:17 +0100
-Subject: [PATCH] ntdll: Set object type for System(Extended)HandleInformation
- in NtQuerySystemInformation.
+Subject: ntdll: Set object type for System(Extended)HandleInformation in
+ NtQuerySystemInformation.
 
 ---
- dlls/ntdll/unix/system.c |  4 +++-
- server/directory.c       |  6 ++++++
- server/handle.c          | 10 ++++++++++
- server/object.h          |  1 +
- server/protocol.def      |  1 +
+ dlls/ntdll/nt.c     |  4 +++-
+ server/directory.c  |  6 ++++++
+ server/handle.c     | 10 ++++++++++
+ server/object.h     |  1 +
+ server/protocol.def |  1 +
  5 files changed, 21 insertions(+), 1 deletion(-)
 
-diff --git a/dlls/ntdll/unix/system.c b/dlls/ntdll/unix/system.c
-index 34cea04f852..7ae3f12753b 100644
---- a/dlls/ntdll/unix/system.c
-+++ b/dlls/ntdll/unix/system.c
-@@ -1970,7 +1970,8 @@ NTSTATUS WINAPI NtQuerySystemInformation( SYSTEM_INFORMATION_CLASS class,
-                     shi->Handle[i].OwnerPid     = handle_info[i].owner;
-                     shi->Handle[i].HandleValue  = handle_info[i].handle;
-                     shi->Handle[i].AccessMask   = handle_info[i].access;
--                    /* FIXME: Fill out ObjectType, HandleFlags, ObjectPointer */
-+                    shi->Handle[i].ObjectType   = handle_info[i].type;
-+                    /* FIXME: Fill out HandleFlags, ObjectPointer */
+diff --git a/dlls/ntdll/nt.c b/dlls/ntdll/nt.c
+index a939298d19..211b67f98b 100644
+--- a/dlls/ntdll/nt.c
++++ b/dlls/ntdll/nt.c
+@@ -2280,7 +2280,8 @@ NTSTATUS WINAPI NtQuerySystemInformation(
+                         shi->Handle[i].OwnerPid     = info[i].owner;
+                         shi->Handle[i].HandleValue  = info[i].handle;
+                         shi->Handle[i].AccessMask   = info[i].access;
+-                        /* FIXME: Fill out ObjectType, HandleFlags, ObjectPointer */
++                        shi->Handle[i].ObjectType   = info[i].type;
++                        /* FIXME: Fill out HandleFlags, ObjectPointer */
+                     }
                  }
-             }
-             else if (ret == STATUS_BUFFER_TOO_SMALL)
-@@ -2022,6 +2023,7 @@ NTSTATUS WINAPI NtQuerySystemInformation( SYSTEM_INFORMATION_CLASS class,
-                     shi->Handle[i].UniqueProcessId = handle_info[i].owner;
-                     shi->Handle[i].HandleValue     = handle_info[i].handle;
-                     shi->Handle[i].GrantedAccess   = handle_info[i].access;
-+                    shi->Handle[i].ObjectTypeIndex = handle_info[i].type;
-                     /* FIXME: Fill out remaining fields */
+                 else if (ret == STATUS_BUFFER_TOO_SMALL)
+@@ -2331,6 +2332,7 @@ NTSTATUS WINAPI NtQuerySystemInformation(
+                         shi->Handle[i].UniqueProcessId = info[i].owner;
+                         shi->Handle[i].HandleValue     = info[i].handle;
+                         shi->Handle[i].GrantedAccess   = info[i].access;
++                        shi->Handle[i].ObjectTypeIndex = info[i].type;
+                         /* FIXME: Fill out remaining fields */
+                     }
                  }
-             }
 diff --git a/server/directory.c b/server/directory.c
-index e6c1edc719a..021bc149c4d 100644
+index 59c8194d09..f61a5cecf1 100644
 --- a/server/directory.c
 +++ b/server/directory.c
-@@ -247,6 +247,12 @@ struct object_type *get_object_type( const struct unicode_str *name )
+@@ -249,6 +249,12 @@ struct object_type *get_object_type( const struct unicode_str *name )
      return type;
  }
  
@@ -52,10 +52,10 @@ index e6c1edc719a..021bc149c4d 100644
  
  static void create_session( unsigned int id )
 diff --git a/server/handle.c b/server/handle.c
-index a2a8bb5479c..e40e9e95d8f 100644
+index 0e909ff27e..e29cead46b 100644
 --- a/server/handle.c
 +++ b/server/handle.c
-@@ -790,6 +790,7 @@ static int enum_handles( struct process *process, void *user )
+@@ -971,6 +971,7 @@ static int enum_handles( struct process *process, void *user )
      struct handle_table *table = process->handles;
      struct handle_entry *entry;
      struct handle_info *handle;
@@ -63,7 +63,7 @@ index a2a8bb5479c..e40e9e95d8f 100644
      unsigned int i;
  
      if (!table)
-@@ -808,6 +809,15 @@ static int enum_handles( struct process *process, void *user )
+@@ -989,6 +990,15 @@ static int enum_handles( struct process *process, void *user )
          handle->owner  = process->id;
          handle->handle = index_to_handle(i);
          handle->access = entry->access & ~RESERVED_ALL;
@@ -80,10 +80,10 @@ index a2a8bb5479c..e40e9e95d8f 100644
      }
  
 diff --git a/server/object.h b/server/object.h
-index f3f7617394d..1517e8c98fb 100644
+index 3ba3f4b431..4a5d282a47 100644
 --- a/server/object.h
 +++ b/server/object.h
-@@ -262,6 +262,7 @@ static const WCHAR type_Type[] =          {'T','y','p','e'};
+@@ -264,6 +264,7 @@ static const WCHAR type_Type[] =          {'T','y','p','e'};
  static const WCHAR type_WindowStation[] = {'W','i','n','d','o','w','S','t','a','t','i','o','n'};
  
  extern void init_types(void);
@@ -92,10 +92,10 @@ index f3f7617394d..1517e8c98fb 100644
  /* symbolic link functions */
  
 diff --git a/server/protocol.def b/server/protocol.def
-index 2ec81bb6ad1..72f148b12e7 100644
+index d6847f8d55..35730d60cb 100644
 --- a/server/protocol.def
 +++ b/server/protocol.def
-@@ -3493,6 +3493,7 @@ struct handle_info
+@@ -3433,6 +3433,7 @@ struct handle_info
      process_id_t owner;
      obj_handle_t handle;
      unsigned int access;
@@ -104,5 +104,5 @@ index 2ec81bb6ad1..72f148b12e7 100644
  
  /* Return a list of all opened handles */
 -- 
-2.27.0
+2.11.0
 
diff --git a/patches/server-Object_Types/0010-ntdll-Mimic-object-type-behavior-for-different-windo.patch b/patches/server-Object_Types/0010-ntdll-Mimic-object-type-behavior-for-different-windo.patch
index b44ca560..18a607c8 100644
--- a/patches/server-Object_Types/0010-ntdll-Mimic-object-type-behavior-for-different-windo.patch
+++ b/patches/server-Object_Types/0010-ntdll-Mimic-object-type-behavior-for-different-windo.patch
@@ -1,20 +1,78 @@
-From 31de811f968861971bb6e014286cd34fb6c2f4c8 Mon Sep 17 00:00:00 2001
+From 963a3aedc5b1539187d9aa5065ff16d6c60b6477 Mon Sep 17 00:00:00 2001
 From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
 Date: Wed, 8 Mar 2017 19:39:29 +0100
 Subject: [PATCH] ntdll: Mimic object type behavior for different windows
  versions.
 
 ---
- dlls/ntdll/tests/om.c    | 65 +++++++++++++++++++++++++++++++++++++++-
- dlls/ntdll/unix/file.c   |  5 +++-
- dlls/ntdll/unix/system.c | 17 +++++++++--
- 3 files changed, 82 insertions(+), 5 deletions(-)
+ dlls/ntdll/nt.c       | 17 +++++++++--
+ dlls/ntdll/om.c       |  5 +++-
+ dlls/ntdll/tests/om.c | 65 ++++++++++++++++++++++++++++++++++++++++++-
+ 3 files changed, 83 insertions(+), 4 deletions(-)
 
+diff --git a/dlls/ntdll/nt.c b/dlls/ntdll/nt.c
+index d194f863..452fad15 100644
+--- a/dlls/ntdll/nt.c
++++ b/dlls/ntdll/nt.c
+@@ -126,6 +126,19 @@ struct smbios_chassis {
+ #define FIRM 0x4649524D
+ #define RSMB 0x52534D42
+ 
++static DWORD translate_object_index(DWORD index)
++{
++    WORD version = MAKEWORD(NtCurrentTeb()->Peb->OSMinorVersion, NtCurrentTeb()->Peb->OSMajorVersion);
++
++    /* Process Hacker depends on this logic */
++    if (version >= 0x0602)
++        return index;
++    else if (version == 0x0601)
++        return index + 2;
++    else
++        return index + 1;
++}
++
+ /*
+  *	Token
+  */
+@@ -2617,7 +2630,7 @@ NTSTATUS WINAPI NtQuerySystemInformation(
+                         shi->Handle[i].OwnerPid     = info[i].owner;
+                         shi->Handle[i].HandleValue  = info[i].handle;
+                         shi->Handle[i].AccessMask   = info[i].access;
+-                        shi->Handle[i].ObjectType   = info[i].type;
++                        shi->Handle[i].ObjectType   = translate_object_index(info[i].type);
+                         /* FIXME: Fill out HandleFlags, ObjectPointer */
+                     }
+                 }
+@@ -2669,7 +2682,7 @@ NTSTATUS WINAPI NtQuerySystemInformation(
+                         shi->Handle[i].UniqueProcessId = info[i].owner;
+                         shi->Handle[i].HandleValue     = info[i].handle;
+                         shi->Handle[i].GrantedAccess   = info[i].access;
+-                        shi->Handle[i].ObjectTypeIndex = info[i].type;
++                        shi->Handle[i].ObjectTypeIndex = translate_object_index(info[i].type);
+                         /* FIXME: Fill out remaining fields */
+                     }
+                 }
+diff --git a/dlls/ntdll/om.c b/dlls/ntdll/om.c
+index c0479ea6..2156fad5 100644
+--- a/dlls/ntdll/om.c
++++ b/dlls/ntdll/om.c
+@@ -185,7 +185,10 @@ NTSTATUS WINAPI NtQueryObject(IN HANDLE handle,
+                     }
+                     if (status == STATUS_SUCCESS)
+                     {
+-                        p->TypeIndex = reply->index;
++                        WORD version = MAKEWORD(NtCurrentTeb()->Peb->OSMinorVersion,
++                                                NtCurrentTeb()->Peb->OSMajorVersion);
++                        if (version >= 0x0602)
++                            p->TypeIndex = reply->index;
+                     }
+                 }
+             }
 diff --git a/dlls/ntdll/tests/om.c b/dlls/ntdll/tests/om.c
-index 58fd9482720..7deb0b156d8 100644
+index a94b9866..54ef3955 100644
 --- a/dlls/ntdll/tests/om.c
 +++ b/dlls/ntdll/tests/om.c
-@@ -73,6 +73,7 @@ static NTSTATUS (WINAPI *pNtQuerySystemTime)( LARGE_INTEGER * );
+@@ -74,6 +74,7 @@ static NTSTATUS (WINAPI *pNtQuerySystemTime)( LARGE_INTEGER * );
  static NTSTATUS (WINAPI *pRtlWaitOnAddress)( const void *, const void *, SIZE_T, const LARGE_INTEGER * );
  static void     (WINAPI *pRtlWakeAddressAll)( const void * );
  static void     (WINAPI *pRtlWakeAddressSingle)( const void * );
@@ -22,8 +80,8 @@ index 58fd9482720..7deb0b156d8 100644
  
  #define KEYEDEVENT_WAIT       0x0001
  #define KEYEDEVENT_WAKE       0x0002
-@@ -1508,13 +1509,31 @@ static void test_query_object(void)
-     pNtClose(handle);
+@@ -1594,13 +1595,31 @@ static void test_query_object(void)
+ 
  }
  
 +static BOOL winver_equal_or_newer(WORD major, WORD minor)
@@ -55,7 +113,7 @@ index 58fd9482720..7deb0b156d8 100644
  
      buffer = HeapAlloc( GetProcessHeap(), 0, sizeof(OBJECT_TYPES_INFORMATION) );
      ok( buffer != NULL, "Failed to allocate memory\n" );
-@@ -1542,11 +1561,54 @@ static void test_query_object_types(void)
+@@ -1628,11 +1647,54 @@ static void test_query_object_types(void)
              ok( type->TypeName.Length == sizeof(typeW) && !strncmpW(typeW, type->TypeName.Buffer, 4),
                  "Expected 'Type' as first type, got %s\n", wine_dbgstr_us(&type->TypeName) );
          }
@@ -110,7 +168,7 @@ index 58fd9482720..7deb0b156d8 100644
  }
  
  static void test_type_mismatch(void)
-@@ -2138,6 +2200,7 @@ START_TEST(om)
+@@ -2226,6 +2288,7 @@ START_TEST(om)
      pRtlWaitOnAddress       =  (void *)GetProcAddress(hntdll, "RtlWaitOnAddress");
      pRtlWakeAddressAll      =  (void *)GetProcAddress(hntdll, "RtlWakeAddressAll");
      pRtlWakeAddressSingle   =  (void *)GetProcAddress(hntdll, "RtlWakeAddressSingle");
@@ -118,71 +176,6 @@ index 58fd9482720..7deb0b156d8 100644
  
      test_case_sensitive();
      test_namespace_pipe();
-diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
-index ece09c12f77..9a1659d2f66 100644
---- a/dlls/ntdll/unix/file.c
-+++ b/dlls/ntdll/unix/file.c
-@@ -6591,7 +6591,10 @@ NTSTATUS WINAPI NtQueryObject( HANDLE handle, OBJECT_INFORMATION_CLASS info_clas
-                 }
-                 if (status == STATUS_SUCCESS)
-                 {
--                    p->TypeIndex = reply->index;
-+                    WORD version = MAKEWORD(NtCurrentTeb()->Peb->OSMinorVersion,
-+                                            NtCurrentTeb()->Peb->OSMajorVersion);
-+                    if (version >= 0x0602)
-+                        p->TypeIndex = reply->index;
-                 }
-             }
-         }
-diff --git a/dlls/ntdll/unix/system.c b/dlls/ntdll/unix/system.c
-index 6c8e50fb88f..201e66d1759 100644
---- a/dlls/ntdll/unix/system.c
-+++ b/dlls/ntdll/unix/system.c
-@@ -2035,6 +2035,18 @@ static void get_timezone_info( RTL_DYNAMIC_TIME_ZONE_INFORMATION *tzi )
-     mutex_unlock( &tz_mutex );
- }
- 
-+static DWORD translate_object_index(DWORD index)
-+{
-+    WORD version = MAKEWORD(NtCurrentTeb()->Peb->OSMinorVersion, NtCurrentTeb()->Peb->OSMajorVersion);
-+
-+    /* Process Hacker depends on this logic */
-+    if (version >= 0x0602)
-+        return index;
-+    else if (version == 0x0601)
-+        return index + 2;
-+    else
-+        return index + 1;
-+}
- 
- /******************************************************************************
-  *              NtQuerySystemInformation  (NTDLL.@)
-@@ -2435,7 +2447,7 @@ NTSTATUS WINAPI NtQuerySystemInformation( SYSTEM_INFORMATION_CLASS class,
-                     shi->Handle[i].OwnerPid     = handle_info[i].owner;
-                     shi->Handle[i].HandleValue  = handle_info[i].handle;
-                     shi->Handle[i].AccessMask   = handle_info[i].access;
--                    shi->Handle[i].ObjectType   = handle_info[i].type;
-+                    shi->Handle[i].ObjectType   = translate_object_index( handle_info[i].type );
-                     /* FIXME: Fill out HandleFlags, ObjectPointer */
-                 }
-             }
-@@ -2488,7 +2500,7 @@ NTSTATUS WINAPI NtQuerySystemInformation( SYSTEM_INFORMATION_CLASS class,
-                     shi->Handle[i].UniqueProcessId = handle_info[i].owner;
-                     shi->Handle[i].HandleValue     = handle_info[i].handle;
-                     shi->Handle[i].GrantedAccess   = handle_info[i].access;
--                    shi->Handle[i].ObjectTypeIndex = handle_info[i].type;
-+                    shi->Handle[i].ObjectTypeIndex = translate_object_index( handle_info[i].type );
-                     /* FIXME: Fill out remaining fields */
-                 }
-             }
-@@ -2724,7 +2736,6 @@ NTSTATUS WINAPI NtQuerySystemInformation( SYSTEM_INFORMATION_CLASS class,
-     return ret;
- }
- 
--
- /******************************************************************************
-  *              NtQuerySystemInformationEx  (NTDLL.@)
-  */
 -- 
-2.28.0
+2.20.1
 
diff --git a/patches/server-Object_Types/definition b/patches/server-Object_Types/definition
index 1da5e3dc..9f2708c1 100644
--- a/patches/server-Object_Types/definition
+++ b/patches/server-Object_Types/definition
@@ -1,4 +1,3 @@
 Fixes: [44629] Process Hacker can't enumerate handles
 Fixes: [45374] Yet Another Process Monitor (.NET 2.0 app) reports System.AccessViolationException
-Depends: ntdll-SystemModuleInformation
-#Depends: server-Shared_Memory
+Depends: server-Shared_Memory
diff --git a/patches/server-PeekMessage/0001-server-Fix-handling-of-GetMessage-after-previous-Pee.patch b/patches/server-PeekMessage/0001-server-Fix-handling-of-GetMessage-after-previous-Pee.patch
index ce7ec607..c1f1af9a 100644
--- a/patches/server-PeekMessage/0001-server-Fix-handling-of-GetMessage-after-previous-Pee.patch
+++ b/patches/server-PeekMessage/0001-server-Fix-handling-of-GetMessage-after-previous-Pee.patch
@@ -1,8 +1,8 @@
-From c527f32596831ae31b055cd77cb3bc848f83a8a8 Mon Sep 17 00:00:00 2001
+From 52837e975cb343d78e626bd8a9464db59d27565b Mon Sep 17 00:00:00 2001
 From: Sebastian Lackner <sebastian@fds-team.de>
 Date: Sun, 15 Mar 2015 01:05:48 +0100
-Subject: [PATCH] server: Fix handling of GetMessage after previous PeekMessage
- call. (v3)
+Subject: server: Fix handling of GetMessage after previous PeekMessage call.
+ (v3)
 
 Changes in v2:
 * accept_hardware_message should also reset ignore_post_msg.
@@ -10,15 +10,15 @@ Changes in v2:
 Changes in v3:
 * Fix remaining todo_wine.
 ---
- dlls/user32/tests/msg.c | 29 ++++++++++++++++--------
- server/queue.c          | 50 ++++++++++++++++++++++++++++++++++-------
+ dlls/user32/tests/msg.c | 29 +++++++++++++++++++---------
+ server/queue.c          | 50 +++++++++++++++++++++++++++++++++++++++++--------
  2 files changed, 62 insertions(+), 17 deletions(-)
 
 diff --git a/dlls/user32/tests/msg.c b/dlls/user32/tests/msg.c
-index f84525a0bf9..80cc0daa6c6 100644
+index 45b5222deba..e36d0f8af49 100644
 --- a/dlls/user32/tests/msg.c
 +++ b/dlls/user32/tests/msg.c
-@@ -12429,13 +12429,10 @@ static void test_PeekMessage3(void)
+@@ -11037,13 +11037,10 @@ static void test_PeekMessage3(void)
      ok(msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
      PostMessageA(hwnd, WM_USER, 0, 0);
      ret = PeekMessageA(&msg, NULL, 0, 0, PM_NOREMOVE);
@@ -32,7 +32,7 @@ index f84525a0bf9..80cc0daa6c6 100644
      ok(ret && msg.message == WM_USER, "msg.message = %u instead of WM_USER\n", msg.message);
      ret = PeekMessageA(&msg, NULL, 0, 0, 0);
      ok(!ret, "expected PeekMessage to return FALSE, got %u\n", ret);
-@@ -12445,10 +12442,8 @@ static void test_PeekMessage3(void)
+@@ -11053,10 +11050,8 @@ static void test_PeekMessage3(void)
      ok(msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
      PostMessageA(hwnd, WM_USER, 0, 0);
      ret = PeekMessageA(&msg, NULL, 0, 0, PM_REMOVE);
@@ -43,7 +43,7 @@ index f84525a0bf9..80cc0daa6c6 100644
      ok(ret && msg.message == WM_USER, "msg.message = %u instead of WM_USER\n", msg.message);
      ret = PeekMessageA(&msg, NULL, 0, 0, 0);
      ok(!ret, "expected PeekMessage to return FALSE, got %u\n", ret);
-@@ -12460,10 +12455,8 @@ static void test_PeekMessage3(void)
+@@ -11068,10 +11063,8 @@ static void test_PeekMessage3(void)
      ok(msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
      PostMessageA(hwnd, WM_USER, 0, 0);
      ret = GetMessageA(&msg, NULL, 0, 0);
@@ -54,7 +54,7 @@ index f84525a0bf9..80cc0daa6c6 100644
      ok(ret && msg.message == WM_USER, "msg.message = %u instead of WM_USER\n", msg.message);
      ret = PeekMessageA(&msg, NULL, 0, 0, 0);
      ok(!ret, "expected PeekMessage to return FALSE, got %u\n", ret);
-@@ -12491,14 +12484,32 @@ static void test_PeekMessage3(void)
+@@ -11099,14 +11092,32 @@ static void test_PeekMessage3(void)
      ret = GetMessageA(&msg, NULL, 0, 0);
      ok(ret && msg.message == WM_USER, "msg.message = %u instead of WM_USER\n", msg.message);
      ret = GetMessageA(&msg, NULL, 0, 0);
@@ -90,7 +90,7 @@ index f84525a0bf9..80cc0daa6c6 100644
       * because both messages are in the same queue. */
  
 diff --git a/server/queue.c b/server/queue.c
-index a65eab38bdc..bf315f5008c 100644
+index c479b388bd6..fdb09d93238 100644
 --- a/server/queue.c
 +++ b/server/queue.c
 @@ -140,6 +140,7 @@ struct msg_queue
@@ -101,7 +101,7 @@ index a65eab38bdc..bf315f5008c 100644
  };
  
  struct hotkey
-@@ -300,6 +301,7 @@ static struct msg_queue *create_msg_queue( struct thread *thread, struct thread_
+@@ -298,6 +299,7 @@ static struct msg_queue *create_msg_queue( struct thread *thread, struct thread_
          queue->input           = (struct thread_input *)grab_object( input );
          queue->hooks           = NULL;
          queue->last_get_msg    = current_time;
@@ -109,7 +109,7 @@ index a65eab38bdc..bf315f5008c 100644
          list_init( &queue->send_result );
          list_init( &queue->callback_result );
          list_init( &queue->pending_timers );
-@@ -529,13 +531,21 @@ static inline struct msg_queue *get_current_queue(void)
+@@ -495,13 +497,21 @@ static inline struct msg_queue *get_current_queue(void)
  }
  
  /* get a (pseudo-)unique id to tag hardware messages */
@@ -132,7 +132,7 @@ index a65eab38bdc..bf315f5008c 100644
  /* try to merge a message with the last in the list; return 1 if successful */
  static int merge_message( struct thread_input *input, const struct message *msg )
  {
-@@ -813,7 +823,7 @@ static int match_window( user_handle_t win, user_handle_t msg_win )
+@@ -779,7 +789,7 @@ static int match_window( user_handle_t win, user_handle_t msg_win )
  }
  
  /* retrieve a posted message */
@@ -141,7 +141,7 @@ index a65eab38bdc..bf315f5008c 100644
                                 unsigned int first, unsigned int last, unsigned int flags,
                                 struct get_message_reply *reply )
  {
-@@ -824,6 +834,7 @@ static int get_posted_message( struct msg_queue *queue, user_handle_t win,
+@@ -790,6 +800,7 @@ static int get_posted_message( struct msg_queue *queue, user_handle_t win,
      {
          if (!match_window( win, msg->win )) continue;
          if (!check_msg_filter( msg->msg, first, last )) continue;
@@ -149,7 +149,7 @@ index a65eab38bdc..bf315f5008c 100644
          goto found; /* found one */
      }
      return 0;
-@@ -1439,6 +1450,7 @@ found:
+@@ -1387,6 +1398,7 @@ found:
      msg->msg       = WM_HOTKEY;
      msg->wparam    = hotkey->id;
      msg->lparam    = ((hotkey->vkey & 0xffff) << 16) | modifiers;
@@ -157,7 +157,7 @@ index a65eab38bdc..bf315f5008c 100644
  
      free( msg->data );
      msg->data      = NULL;
-@@ -2061,7 +2073,7 @@ static int get_hardware_message( struct thread *thread, unsigned int hw_id, user
+@@ -1992,7 +2004,7 @@ static int get_hardware_message( struct thread *thread, unsigned int hw_id, user
              continue;
          }
          /* now we can return it */
@@ -166,7 +166,7 @@ index a65eab38bdc..bf315f5008c 100644
          reply->type   = MSG_HARDWARE;
          reply->win    = win;
          reply->msg    = msg_code;
-@@ -2167,6 +2179,7 @@ void post_message( user_handle_t win, unsigned int message, lparam_t wparam, lpa
+@@ -2098,6 +2110,7 @@ void post_message( user_handle_t win, unsigned int message, lparam_t wparam, lpa
          msg->result    = NULL;
          msg->data      = NULL;
          msg->data_size = 0;
@@ -174,7 +174,7 @@ index a65eab38bdc..bf315f5008c 100644
  
          get_message_defaults( thread->queue, &msg->x, &msg->y, &msg->time );
  
-@@ -2411,6 +2424,7 @@ DECL_HANDLER(send_message)
+@@ -2342,6 +2355,7 @@ DECL_HANDLER(send_message)
              set_queue_bits( recv_queue, QS_SENDMESSAGE );
              break;
          case MSG_POSTED:
@@ -182,7 +182,7 @@ index a65eab38bdc..bf315f5008c 100644
              list_add_tail( &recv_queue->msg_list[POST_MESSAGE], &msg->entry );
              set_queue_bits( recv_queue, QS_POSTMESSAGE|QS_ALLPOSTMESSAGE );
              if (msg->msg == WM_HOTKEY)
-@@ -2531,12 +2545,12 @@ DECL_HANDLER(get_message)
+@@ -2455,12 +2469,12 @@ DECL_HANDLER(get_message)
  
      /* then check for posted messages */
      if ((filter & QS_POSTMESSAGE) &&
@@ -197,7 +197,7 @@ index a65eab38bdc..bf315f5008c 100644
          return;
  
      /* only check for quit messages if not posted messages pending */
-@@ -2547,7 +2561,7 @@ DECL_HANDLER(get_message)
+@@ -2471,7 +2485,7 @@ DECL_HANDLER(get_message)
      if ((filter & QS_INPUT) &&
          filter_contains_hw_range( req->get_first, req->get_last ) &&
          get_hardware_message( current, req->hw_id, get_win, req->get_first, req->get_last, req->flags, reply ))
@@ -206,7 +206,7 @@ index a65eab38bdc..bf315f5008c 100644
  
      /* now check for WM_PAINT */
      if ((filter & QS_PAINT) &&
-@@ -2560,7 +2574,7 @@ DECL_HANDLER(get_message)
+@@ -2484,7 +2498,7 @@ DECL_HANDLER(get_message)
          reply->wparam = 0;
          reply->lparam = 0;
          get_message_defaults( queue, &reply->x, &reply->y, &reply->time );
@@ -215,7 +215,7 @@ index a65eab38bdc..bf315f5008c 100644
      }
  
      /* now check for timer */
-@@ -2576,13 +2590,30 @@ DECL_HANDLER(get_message)
+@@ -2500,13 +2514,30 @@ DECL_HANDLER(get_message)
          get_message_defaults( queue, &reply->x, &reply->y, &reply->time );
          if (!(req->flags & PM_NOYIELD) && current->process->idle_event)
              set_event( current->process->idle_event );
@@ -247,17 +247,17 @@ index a65eab38bdc..bf315f5008c 100644
  }
  
  
-@@ -2600,7 +2631,10 @@ DECL_HANDLER(reply_message)
+@@ -2524,7 +2555,10 @@ DECL_HANDLER(reply_message)
  DECL_HANDLER(accept_hardware_message)
  {
      if (current->queue)
 +    {
-         release_hardware_message( current->queue, req->hw_id );
-+        current->queue->ignore_post_msg = 0;
+         release_hardware_message( current->queue, req->hw_id, req->remove );
++        if (req->remove) current->queue->ignore_post_msg = 0;
 +    }
      else
          set_error( STATUS_ACCESS_DENIED );
  }
 -- 
-2.27.0
+2.11.0
 
diff --git a/patches/server-Realtime_Priority/0001-wineserver-Draft-to-implement-priority-levels-throug.patch b/patches/server-Realtime_Priority/0001-wineserver-Draft-to-implement-priority-levels-throug.patch
index 6c7846b0..4691e814 100644
--- a/patches/server-Realtime_Priority/0001-wineserver-Draft-to-implement-priority-levels-throug.patch
+++ b/patches/server-Realtime_Priority/0001-wineserver-Draft-to-implement-priority-levels-throug.patch
@@ -1,4 +1,4 @@
-From 13a0529750a14a032bb9ef5af97a48bc4f1aff14 Mon Sep 17 00:00:00 2001
+From c85f5ea67bddac0afecdf6d0cd54bf3c6c4df42d Mon Sep 17 00:00:00 2001
 From: Joakim Hernberg <jhernberg@alchemy.lu>
 Date: Tue, 31 Mar 2015 20:58:20 +0200
 Subject: [PATCH] wineserver: Draft to implement priority levels through POSIX
@@ -19,7 +19,7 @@ Changes by Sebastian Lackner <sebastian@fds-team.de>:
  create mode 100644 server/scheduler.c
 
 diff --git a/server/Makefile.in b/server/Makefile.in
-index e90c5d1336c..9a695cefc30 100644
+index 3f3761faab6..89c1d8a4cdb 100644
 --- a/server/Makefile.in
 +++ b/server/Makefile.in
 @@ -30,6 +30,7 @@ C_SRCS = \
@@ -215,10 +215,10 @@ index 00000000000..4a5d82b208d
 +
 +#endif
 diff --git a/server/thread.c b/server/thread.c
-index 9b14174578e..7280f87012d 100644
+index d6d80a9a864..f161c8f3e24 100644
 --- a/server/thread.c
 +++ b/server/thread.c
-@@ -608,7 +608,10 @@ static void set_thread_info( struct thread *thread,
+@@ -539,7 +539,10 @@ static void set_thread_info( struct thread *thread,
          if ((req->priority >= min && req->priority <= max) ||
              req->priority == THREAD_PRIORITY_IDLE ||
              req->priority == THREAD_PRIORITY_TIME_CRITICAL)
@@ -230,12 +230,12 @@ index 9b14174578e..7280f87012d 100644
              set_error( STATUS_INVALID_PARAMETER );
      }
 diff --git a/server/thread.h b/server/thread.h
-index 650bc44628d..2599f7629c3 100644
+index 26dbc494f3c..7957557b6cc 100644
 --- a/server/thread.h
 +++ b/server/thread.h
-@@ -144,4 +144,9 @@ static inline void set_win32_error( unsigned int err ) { set_error( 0xc0010000 |
- 
- static inline thread_id_t get_thread_id( struct thread *thread ) { return thread->id; }
+@@ -154,4 +154,9 @@ static inline thread_id_t get_thread_id( struct thread *thread ) { return thread
+ static inline int get_thread_unix_tid( struct thread *thread ) { return thread->unix_tid; }
+ static inline timeout_t get_thread_creation_time( struct thread *thread ) { return thread->creation_time; }
  
 +/* scheduler functions */
 +
@@ -244,5 +244,5 @@ index 650bc44628d..2599f7629c3 100644
 +
  #endif  /* __WINE_SERVER_THREAD_H */
 -- 
-2.27.0
+2.26.0
 
diff --git a/patches/server-Realtime_Priority/definition b/patches/server-Realtime_Priority/definition
index a8e417cd..de7045a9 100644
--- a/patches/server-Realtime_Priority/definition
+++ b/patches/server-Realtime_Priority/definition
@@ -1 +1,2 @@
 Fixes: Support for linux priority levels for faster performance
+Depends: ntdll-ThreadTime
diff --git a/patches/server-Shared_Memory/0004-user32-Avoid-unnecessary-wineserver-calls-in-PeekMes.patch b/patches/server-Shared_Memory/0004-user32-Avoid-unnecessary-wineserver-calls-in-PeekMes.patch
index 18cafe2a..8bdb5ccb 100644
--- a/patches/server-Shared_Memory/0004-user32-Avoid-unnecessary-wineserver-calls-in-PeekMes.patch
+++ b/patches/server-Shared_Memory/0004-user32-Avoid-unnecessary-wineserver-calls-in-PeekMes.patch
@@ -51,9 +51,9 @@ index c11aae707c9..74f56925211 100644
  
 +#include <pshpack1.h>
 +
- /* this is the structure stored in TEB->Win32ClientInfo */
- /* no attempt is made to keep the layout compatible with the Windows one */
- struct user_thread_info
+ /* on windows the buffer capacity is quite large as well, enough to */
+ /* hold up to 10s of 1kHz mouse rawinput events */
+ #define RAWINPUT_BUFFER_SIZE (512*1024)
 @@ -189,6 +191,7 @@ struct user_thread_info
      DWORD                         GetMessageTimeVal;      /* Value for GetMessageTime */
      DWORD                         GetMessagePosVal;       /* Value for GetMessagePos */
diff --git a/patches/server-Shared_Memory/0005-user32-Get-rid-of-wineserver-call-for-GetLastInputIn.patch b/patches/server-Shared_Memory/0005-user32-Get-rid-of-wineserver-call-for-GetLastInputIn.patch
index e4afbfb9..bffb50fc 100644
--- a/patches/server-Shared_Memory/0005-user32-Get-rid-of-wineserver-call-for-GetLastInputIn.patch
+++ b/patches/server-Shared_Memory/0005-user32-Get-rid-of-wineserver-call-for-GetLastInputIn.patch
@@ -57,9 +57,9 @@ diff --git a/server/queue.c b/server/queue.c
 index d7c0f7178ec..337bdf3b044 100644
 --- a/server/queue.c
 +++ b/server/queue.c
-@@ -1600,6 +1600,7 @@ static void queue_hardware_message( struct desktop *desktop, struct message *msg
+@@ -1490,6 +1490,7 @@ static void queue_hardware_message( struct desktop *desktop, struct message *msg
  
-     update_key_state( desktop, desktop->keystate, msg->msg, msg->wparam );
+     update_input_key_state( desktop, desktop->keystate, msg->msg, msg->wparam );
      last_input_time = get_tick_count();
 +    if (shmglobal) shmglobal->last_input_time = last_input_time;
      if (msg->msg != WM_MOUSEMOVE) always_queue = 1;
diff --git a/patches/server-Shared_Memory/0007-server-Store-a-list-of-associated-queues-for-each-th.patch b/patches/server-Shared_Memory/0007-server-Store-a-list-of-associated-queues-for-each-th.patch
index dd3ecf0a..9d75b2d8 100644
--- a/patches/server-Shared_Memory/0007-server-Store-a-list-of-associated-queues-for-each-th.patch
+++ b/patches/server-Shared_Memory/0007-server-Store-a-list-of-associated-queues-for-each-th.patch
@@ -30,9 +30,9 @@ index 418a2b1..1b80348 100644
      timeout_t              last_get_msg;    /* time of last get message call */
      unsigned int           ignore_post_msg; /* ignore post messages newer than this unique id */
 @@ -254,6 +256,7 @@ static struct thread_input *create_thread_input( struct thread *thread )
+         input->move_size    = 0;
          input->cursor       = 0;
          input->cursor_count = 0;
-         input->lock_count   = 0;
 +        list_init( &input->queues );
          list_init( &input->msg_list );
          set_caret_window( input, 0 );
@@ -45,13 +45,12 @@ index 418a2b1..1b80348 100644
          queue->hooks           = NULL;
          queue->last_get_msg    = current_time;
          queue->ignore_post_msg = 0;
-@@ -336,10 +340,12 @@ static int assign_thread_input( struct thread *thread, struct thread_input *new_
+@@ -336,9 +340,11 @@ static int assign_thread_input( struct thread *thread, struct thread_input *new_
+     if (queue->input)
      {
-         if (queue->keystate_locked) queue->input->lock_count--;
          queue->input->cursor_count -= queue->cursor_count;
 +        list_remove( &queue->input_entry );
          release_object( queue->input );
-         queue->keystate_locked = 0;
      }
      queue->input = (struct thread_input *)grab_object( new_input );
 +    list_add_tail( &new_input->queues, &queue->input_entry );
@@ -59,8 +58,8 @@ index 418a2b1..1b80348 100644
      return 1;
  }
 @@ -1003,6 +1009,7 @@ static void msg_queue_destroy( struct object *obj )
+     }
      if (queue->timeout) remove_timeout_user( queue->timeout );
-     if (queue->keystate_locked) queue->input->lock_count--;
      queue->input->cursor_count -= queue->cursor_count;
 +    list_remove( &queue->input_entry );
      release_object( queue->input );
diff --git a/patches/server-Shared_Memory/definition b/patches/server-Shared_Memory/definition
index 593dea94..82046030 100644
--- a/patches/server-Shared_Memory/definition
+++ b/patches/server-Shared_Memory/definition
@@ -5,5 +5,3 @@ Depends: ntdll-Threading
 Depends: server-PeekMessage
 Depends: server-Signal_Thread
 Depends: ntdll-ext4-case-folder
-# This is not worth rebasing right now.
-Disabled: true
diff --git a/patches/server-Signal_Thread/0001-server-Do-not-signal-thread-until-it-is-really-gone.patch b/patches/server-Signal_Thread/0001-server-Do-not-signal-thread-until-it-is-really-gone.patch
index ad9665b3..dbac4400 100644
--- a/patches/server-Signal_Thread/0001-server-Do-not-signal-thread-until-it-is-really-gone.patch
+++ b/patches/server-Signal_Thread/0001-server-Do-not-signal-thread-until-it-is-really-gone.patch
@@ -1,4 +1,4 @@
-From d05ac476a0ca682ecb7ae13aa9e578c94b71e3f8 Mon Sep 17 00:00:00 2001
+From a2401a21b78201f2310d571f8d66ac574dd0d830 Mon Sep 17 00:00:00 2001
 From: Sebastian Lackner <sebastian@fds-team.de>
 Date: Mon, 12 Nov 2018 18:10:32 +0200
 Subject: [PATCH] server: Do not signal violently terminated threads until they
@@ -27,10 +27,10 @@ Signed-off-by: Gabriel Ivncescu <gabrielopcode@gmail.com>
  2 files changed, 30 insertions(+), 3 deletions(-)
 
 diff --git a/server/thread.c b/server/thread.c
-index 9b14174578e..2f32cb4b62e 100644
+index 1c0fbd4179b..f8962221d9a 100644
 --- a/server/thread.c
 +++ b/server/thread.c
-@@ -239,6 +239,7 @@ static inline void init_thread_structure( struct thread *thread )
+@@ -203,6 +203,7 @@ static inline void init_thread_structure( struct thread *thread )
      thread->token           = NULL;
      thread->desc            = NULL;
      thread->desc_len        = 0;
@@ -38,7 +38,7 @@ index 9b14174578e..2f32cb4b62e 100644
  
      thread->creation_time = current_time;
      thread->exit_time     = 0;
-@@ -430,6 +431,7 @@ static void destroy_thread( struct object *obj )
+@@ -361,6 +362,7 @@ static void destroy_thread( struct object *obj )
      list_remove( &thread->entry );
      cleanup_thread( thread );
      release_object( thread->process );
@@ -46,7 +46,7 @@ index 9b14174578e..2f32cb4b62e 100644
      if (thread->id) free_ptid( thread->id );
      if (thread->token) release_object( thread->token );
  }
-@@ -454,7 +456,7 @@ static struct object_type *thread_get_type( struct object *obj )
+@@ -385,7 +387,7 @@ static struct object_type *thread_get_type( struct object *obj )
  static int thread_signaled( struct object *obj, struct wait_queue_entry *entry )
  {
      struct thread *mythread = (struct thread *)obj;
@@ -55,7 +55,7 @@ index 9b14174578e..2f32cb4b62e 100644
  }
  
  static unsigned int thread_map_access( struct object *obj, unsigned int access )
-@@ -1245,6 +1247,26 @@ int thread_get_inflight_fd( struct thread *thread, int client )
+@@ -1171,6 +1173,26 @@ int thread_get_inflight_fd( struct thread *thread, int client )
      return -1;
  }
  
@@ -82,7 +82,7 @@ index 9b14174578e..2f32cb4b62e 100644
  /* kill a thread on the spot */
  void kill_thread( struct thread *thread, int violent_death )
  {
-@@ -1265,8 +1287,12 @@ void kill_thread( struct thread *thread, int violent_death )
+@@ -1191,8 +1213,12 @@ void kill_thread( struct thread *thread, int violent_death )
      kill_console_processes( thread, 0 );
      debug_exit_thread( thread );
      abandon_mutexes( thread );
@@ -98,17 +98,17 @@ index 9b14174578e..2f32cb4b62e 100644
      remove_process_thread( thread->process, thread );
      release_object( thread );
 diff --git a/server/thread.h b/server/thread.h
-index 650bc44628d..668cc4ebd79 100644
+index 7957557b6cc..880419c5924 100644
 --- a/server/thread.h
 +++ b/server/thread.h
-@@ -91,6 +91,7 @@ struct thread
+@@ -90,6 +90,7 @@ struct thread
      struct list            kernel_object; /* list of kernel object pointers */
      data_size_t            desc_len;      /* thread description length in bytes */
      WCHAR                 *desc;          /* thread description string */
 +    struct timeout_user   *exit_poll;     /* poll if the thread/process has exited already */
  };
  
- extern struct thread *current;
+ struct thread_snapshot
 -- 
-2.27.0
+2.24.0
 
diff --git a/patches/server-Stored_ACLs/0003-server-Add-a-helper-function-set_sd_from_token_inter.patch b/patches/server-Stored_ACLs/0003-server-Add-a-helper-function-set_sd_from_token_inter.patch
index 43c5e3da..2bc07715 100644
--- a/patches/server-Stored_ACLs/0003-server-Add-a-helper-function-set_sd_from_token_inter.patch
+++ b/patches/server-Stored_ACLs/0003-server-Add-a-helper-function-set_sd_from_token_inter.patch
@@ -1,19 +1,19 @@
-From 2756f2f11aaa25a9d31eee8eae603f278bbc20f1 Mon Sep 17 00:00:00 2001
+From d294da0642e0fafe103120915f835d529840d233 Mon Sep 17 00:00:00 2001
 From: Sebastian Lackner <sebastian@fds-team.de>
 Date: Mon, 30 Mar 2015 12:32:34 +0200
-Subject: [PATCH] server: Add a helper function set_sd_from_token_internal to
- merge two security descriptors.
+Subject: server: Add a helper function set_sd_from_token_internal to merge two
+ security descriptors.
 
 ---
- server/object.c | 59 +++++++++++++++++++++++++++++++------------------
+ server/object.c | 59 ++++++++++++++++++++++++++++++++++++---------------------
  server/object.h |  3 +++
  2 files changed, 40 insertions(+), 22 deletions(-)
 
 diff --git a/server/object.c b/server/object.c
-index c4c62cb78ad..9342e94ae81 100644
+index 4455718aac..522035bcb8 100644
 --- a/server/object.c
 +++ b/server/object.c
-@@ -554,8 +554,9 @@ struct security_descriptor *default_get_sd( struct object *obj )
+@@ -535,8 +535,9 @@ struct security_descriptor *default_get_sd( struct object *obj )
      return obj->sd;
  }
  
@@ -25,7 +25,7 @@ index c4c62cb78ad..9342e94ae81 100644
  {
      struct security_descriptor new_sd, *new_sd_ptr;
      int present;
-@@ -564,8 +565,6 @@ int set_sd_defaults_from_token( struct object *obj, const struct security_descri
+@@ -545,8 +546,6 @@ int set_sd_defaults_from_token( struct object *obj, const struct security_descri
      ACL *replaced_sacl = NULL;
      char *ptr;
  
@@ -34,7 +34,7 @@ index c4c62cb78ad..9342e94ae81 100644
      new_sd.control = sd->control & ~SE_SELF_RELATIVE;
  
      if (set_info & OWNER_SECURITY_INFORMATION && sd->owner_len)
-@@ -573,10 +572,10 @@ int set_sd_defaults_from_token( struct object *obj, const struct security_descri
+@@ -554,10 +553,10 @@ int set_sd_defaults_from_token( struct object *obj, const struct security_descri
          owner = sd_get_owner( sd );
          new_sd.owner_len = sd->owner_len;
      }
@@ -48,7 +48,7 @@ index c4c62cb78ad..9342e94ae81 100644
      }
      else if (token)
      {
-@@ -590,10 +589,10 @@ int set_sd_defaults_from_token( struct object *obj, const struct security_descri
+@@ -571,10 +570,10 @@ int set_sd_defaults_from_token( struct object *obj, const struct security_descri
          group = sd_get_group( sd );
          new_sd.group_len = sd->group_len;
      }
@@ -62,7 +62,7 @@ index c4c62cb78ad..9342e94ae81 100644
      }
      else if (token)
      {
-@@ -611,20 +610,20 @@ int set_sd_defaults_from_token( struct object *obj, const struct security_descri
+@@ -592,20 +591,20 @@ int set_sd_defaults_from_token( struct object *obj, const struct security_descri
      else if (set_info & LABEL_SECURITY_INFORMATION && present)
      {
          const ACL *old_sacl = NULL;
@@ -88,7 +88,7 @@ index c4c62cb78ad..9342e94ae81 100644
          }
          else
              new_sd.sacl_len = 0;
-@@ -638,12 +637,12 @@ int set_sd_defaults_from_token( struct object *obj, const struct security_descri
+@@ -619,12 +618,12 @@ int set_sd_defaults_from_token( struct object *obj, const struct security_descri
      }
      else
      {
@@ -104,7 +104,7 @@ index c4c62cb78ad..9342e94ae81 100644
          }
          else if (token)
          {
-@@ -659,7 +658,7 @@ int set_sd_defaults_from_token( struct object *obj, const struct security_descri
+@@ -640,7 +639,7 @@ int set_sd_defaults_from_token( struct object *obj, const struct security_descri
      if (!ptr)
      {
          free( replaced_sacl );
@@ -113,7 +113,7 @@ index c4c62cb78ad..9342e94ae81 100644
      }
      new_sd_ptr = (struct security_descriptor*)ptr;
  
-@@ -674,9 +673,25 @@ int set_sd_defaults_from_token( struct object *obj, const struct security_descri
+@@ -655,9 +654,25 @@ int set_sd_defaults_from_token( struct object *obj, const struct security_descri
      memcpy( ptr, dacl, new_sd.dacl_len );
  
      free( replaced_sacl );
@@ -143,10 +143,10 @@ index c4c62cb78ad..9342e94ae81 100644
  
  /** Set the security descriptor using the current primary token for defaults. */
 diff --git a/server/object.h b/server/object.h
-index 53e37b61a21..8203889323a 100644
+index b5c50e1cee..cfbd5e06bc 100644
 --- a/server/object.h
 +++ b/server/object.h
-@@ -164,6 +164,9 @@ extern struct fd *no_get_fd( struct object *obj );
+@@ -156,6 +156,9 @@ extern struct fd *no_get_fd( struct object *obj );
  extern unsigned int no_map_access( struct object *obj, unsigned int access );
  extern struct security_descriptor *default_get_sd( struct object *obj );
  extern int default_set_sd( struct object *obj, const struct security_descriptor *sd, unsigned int set_info );
@@ -155,7 +155,7 @@ index 53e37b61a21..8203889323a 100644
 +                                                               unsigned int set_info, struct token *token );
  extern int set_sd_defaults_from_token( struct object *obj, const struct security_descriptor *sd,
                                         unsigned int set_info, struct token *token );
- extern WCHAR *no_get_full_name( struct object *obj, data_size_t *ret_len );
+ extern struct object *no_lookup_name( struct object *obj, struct unicode_str *name, unsigned int attributes );
 -- 
-2.28.0
+2.13.1
 
diff --git a/patches/server-Stored_ACLs/0005-server-Store-file-security-attributes-with-extended-.patch b/patches/server-Stored_ACLs/0005-server-Store-file-security-attributes-with-extended-.patch
index 8ef1abc3..ab2fe924 100644
--- a/patches/server-Stored_ACLs/0005-server-Store-file-security-attributes-with-extended-.patch
+++ b/patches/server-Stored_ACLs/0005-server-Store-file-security-attributes-with-extended-.patch
@@ -1,15 +1,30 @@
-From a36fb419f7a4c4023507b985ed54387354596445 Mon Sep 17 00:00:00 2001
+From f574af9e0d14b048ff0b410831f226cf764c5d05 Mon Sep 17 00:00:00 2001
 From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
 Date: Mon, 30 Mar 2015 13:04:23 +0200
 Subject: [PATCH] server: Store file security attributes with extended file
  attributes. (v8)
 
 ---
- server/file.c | 63 +++++++++++++++++++++++++++++++++++++++++++++++++++
- 1 file changed, 63 insertions(+)
+ include/wine/port.h |  3 +++
+ server/file.c       | 34 ++++++++++++++++++++++++++++++++++
+ 2 files changed, 37 insertions(+)
 
+diff --git a/include/wine/port.h b/include/wine/port.h
+index 7d2c73887073..145f78bebdba 100644
+--- a/include/wine/port.h
++++ b/include/wine/port.h
+@@ -366,6 +366,9 @@ extern int mkstemps(char *template, int suffix_len);
+ #ifndef XATTR_USER_PREFIX
+ # define XATTR_USER_PREFIX "user."
+ #endif
++#ifndef XATTR_SIZE_MAX
++# define XATTR_SIZE_MAX    65536
++#endif
+ 
+ extern int xattr_fget( int filedes, const char *name, void *value, size_t size );
+ extern int xattr_fremove( int filedes, const char *name );
 diff --git a/server/file.c b/server/file.c
-index f0253115c5d..5df300a9a73 100644
+index 9c94f9ba2bba..5e542b62e77e 100644
 --- a/server/file.c
 +++ b/server/file.c
 @@ -32,6 +32,7 @@
@@ -20,30 +35,10 @@ index f0253115c5d..5df300a9a73 100644
  #include <unistd.h>
  #ifdef HAVE_UTIME_H
  #include <utime.h>
-@@ -39,6 +40,12 @@
- #ifdef HAVE_POLL_H
- #include <poll.h>
- #endif
-+#ifdef HAVE_ATTR_XATTR_H
-+#undef XATTR_ADDITIONAL_OPTIONS
-+#include <attr/xattr.h>
-+#elif defined(HAVE_SYS_XATTR_H)
-+#include <sys/xattr.h>
-+#endif
- 
- #include "ntstatus.h"
- #define WIN32_NO_STATUS
-@@ -52,6 +59,21 @@
+@@ -52,6 +53,14 @@
  #include "process.h"
  #include "security.h"
  
-+#ifndef XATTR_USER_PREFIX
-+#define XATTR_USER_PREFIX "user."
-+#endif
-+#ifndef XATTR_SIZE_MAX
-+#define XATTR_SIZE_MAX    65536
-+#endif
-+
 +/* We intentionally do not match the Samba 4 extended attribute for NT security descriptors (SDs):
 + *  1) Samba stores this information using an internal data structure (we use a flat NT SD).
 + *  2) Samba uses the attribute "security.NTACL".  This attribute is within a namespace that only
@@ -55,26 +50,10 @@ index f0253115c5d..5df300a9a73 100644
  struct file
  {
      struct object       obj;            /* object header */
-@@ -203,6 +225,44 @@ int is_file_executable( const char *name )
+@@ -204,6 +213,28 @@ int is_file_executable( const char *name )
      return len >= 4 && (!strcasecmp( name + len - 4, ".exe") || !strcasecmp( name + len - 4, ".com" ));
  }
  
-+static int xattr_fset( int filedes, const char *name, void *value, size_t size )
-+{
-+#if defined(XATTR_ADDITIONAL_OPTIONS)
-+    return fsetxattr( filedes, name, value, size, 0, 0 );
-+#elif defined(HAVE_SYS_XATTR_H) || defined(HAVE_ATTR_XATTR_H)
-+    return fsetxattr( filedes, name, value, size, 0 );
-+#elif defined(HAVE_SYS_EXTATTR_H)
-+    if (!xattr_valid_namespace( name )) return -1;
-+    return extattr_set_fd( filedes, EXTATTR_NAMESPACE_USER, &name[XATTR_USER_PREFIX_LEN],
-+                           value, size );
-+#else
-+    errno = ENOSYS;
-+    return -1;
-+#endif
-+}
-+
 +static void set_xattr_sd( int fd, const struct security_descriptor *sd )
 +{
 +    char buffer[XATTR_SIZE_MAX];
@@ -100,7 +79,7 @@ index f0253115c5d..5df300a9a73 100644
  static struct object *create_file( struct fd *root, const char *nameptr, data_size_t len,
                                     unsigned int access, unsigned int sharing, int create,
                                     unsigned int options, unsigned int attrs,
-@@ -622,6 +682,9 @@ int set_file_sd( struct object *obj, struct fd *fd, mode_t *mode, uid_t *uid,
+@@ -623,6 +654,9 @@ int set_file_sd( struct object *obj, struct fd *fd, mode_t *mode, uid_t *uid,
              *mode = (*mode & S_IFMT) | new_mode;
          }
  
@@ -111,5 +90,5 @@ index f0253115c5d..5df300a9a73 100644
          obj->sd = new_sd;
          return 1;
 -- 
-2.28.0
+2.26.2
 
diff --git a/patches/server-Stored_ACLs/0007-server-Retrieve-file-security-attributes-with-extend.patch b/patches/server-Stored_ACLs/0007-server-Retrieve-file-security-attributes-with-extend.patch
index 51a4ebe2..5aedd2d6 100644
--- a/patches/server-Stored_ACLs/0007-server-Retrieve-file-security-attributes-with-extend.patch
+++ b/patches/server-Stored_ACLs/0007-server-Retrieve-file-security-attributes-with-extend.patch
@@ -1,19 +1,19 @@
-From f6264626e3a00195c740cd339043d48372005f17 Mon Sep 17 00:00:00 2001
+From 025a3715592c3f4fe8a3300422e6387f82f38792 Mon Sep 17 00:00:00 2001
 From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
 Date: Fri, 18 Apr 2014 14:01:35 -0600
 Subject: [PATCH] server: Retrieve file security attributes with extended file
  attributes. (try 7)
 
 ---
- dlls/advapi32/tests/security.c | 19 +++++++-------
- server/file.c                  | 46 +++++++++++++++++++++++++++++++---
- 2 files changed, 52 insertions(+), 13 deletions(-)
+ dlls/advapi32/tests/security.c | 19 +++++++++----------
+ server/file.c                  | 30 +++++++++++++++++++++++++++---
+ 2 files changed, 36 insertions(+), 13 deletions(-)
 
 diff --git a/dlls/advapi32/tests/security.c b/dlls/advapi32/tests/security.c
-index b79ea481e64..849a6b0b032 100644
+index a27cd41cde81..6968c9a3d2ac 100644
 --- a/dlls/advapi32/tests/security.c
 +++ b/dlls/advapi32/tests/security.c
-@@ -3648,7 +3648,7 @@ static void test_CreateDirectoryA(void)
+@@ -3639,7 +3639,7 @@ static void test_CreateDirectoryA(void)
      }
      ok(!error, "GetNamedSecurityInfo failed with error %d\n", error);
      test_inherited_dacl(pDacl, admin_sid, user_sid, OBJECT_INHERIT_ACE|CONTAINER_INHERIT_ACE,
@@ -22,7 +22,7 @@ index b79ea481e64..849a6b0b032 100644
      LocalFree(pSD);
  
      /* Test inheritance of ACLs in CreateFile without security descriptor */
-@@ -4102,21 +4102,20 @@ static void test_GetNamedSecurityInfoA(void)
+@@ -4093,21 +4093,20 @@ static void test_GetNamedSecurityInfoA(void)
          bret = GetAce(pDacl, 0, (VOID **)&ace);
          ok(bret, "Failed to get Current User ACE.\n");
          bret = EqualSid(&ace->SidStart, user_sid);
@@ -50,7 +50,7 @@ index b79ea481e64..849a6b0b032 100644
          ok(((ACE_HEADER *)ace)->AceFlags == 0,
             "Administators Group ACE has unexpected flags (0x%x != 0x0)\n", ((ACE_HEADER *)ace)->AceFlags);
          ok(ace->Mask == 0x1f01ff || broken(ace->Mask == GENERIC_ALL) /* win2k */,
-@@ -4143,8 +4142,8 @@ static void test_GetNamedSecurityInfoA(void)
+@@ -4134,8 +4133,8 @@ static void test_GetNamedSecurityInfoA(void)
      {
          bret = GetAce(pDacl, 0, (VOID **)&ace);
          ok(bret, "Failed to get ACE.\n");
@@ -62,33 +62,10 @@ index b79ea481e64..849a6b0b032 100644
      LocalFree(pSD);
  
 diff --git a/server/file.c b/server/file.c
-index a659b1c7872..19d04e050ed 100644
+index 818bd42af76a..53d59d3e8e2a 100644
 --- a/server/file.c
 +++ b/server/file.c
-@@ -225,6 +225,22 @@ int is_file_executable( const char *name )
-     return len >= 4 && (!strcasecmp( name + len - 4, ".exe") || !strcasecmp( name + len - 4, ".com" ));
- }
- 
-+static int xattr_fget( int filedes, const char *name, void *value, size_t size )
-+{
-+#if defined(XATTR_ADDITIONAL_OPTIONS)
-+    return fgetxattr( filedes, name, value, size, 0, 0 );
-+#elif defined(HAVE_SYS_XATTR_H) || defined(HAVE_ATTR_XATTR_H)
-+    return fgetxattr( filedes, name, value, size );
-+#elif defined(HAVE_SYS_EXTATTR_H)
-+    if (!xattr_valid_namespace( name )) return -1;
-+    return extattr_get_fd( filedes, EXTATTR_NAMESPACE_USER, &name[XATTR_USER_PREFIX_LEN],
-+                           value, size );
-+#else
-+    errno = ENOSYS;
-+    return -1;
-+#endif
-+}
-+
- static int xattr_fset( int filedes, const char *name, void *value, size_t size )
- {
- #if defined(XATTR_ADDITIONAL_OPTIONS)
-@@ -523,6 +539,29 @@ static void convert_generic_sd( struct security_descriptor *sd )
+@@ -495,6 +495,29 @@ static void convert_generic_sd( struct security_descriptor *sd )
      }
  }
  
@@ -118,7 +95,7 @@ index a659b1c7872..19d04e050ed 100644
  struct security_descriptor *get_file_sd( struct object *obj, struct fd *fd, mode_t *mode,
                                           uid_t *uid )
  {
-@@ -538,9 +577,10 @@ struct security_descriptor *get_file_sd( struct object *obj, struct fd *fd, mode
+@@ -510,9 +533,10 @@ struct security_descriptor *get_file_sd( struct object *obj, struct fd *fd, mode
          (st.st_uid == *uid))
          return obj->sd;
  
@@ -133,5 +110,5 @@ index a659b1c7872..19d04e050ed 100644
  
      *mode = st.st_mode;
 -- 
-2.28.0
+2.26.2
 
diff --git a/patches/user32-DrawTextExW/0001-user32-Fix-handling-of-invert_y-in-DrawTextExW.patch b/patches/user32-DrawTextExW/0001-user32-Fix-handling-of-invert_y-in-DrawTextExW.patch
index 42fdc92d..3799c09b 100644
--- a/patches/user32-DrawTextExW/0001-user32-Fix-handling-of-invert_y-in-DrawTextExW.patch
+++ b/patches/user32-DrawTextExW/0001-user32-Fix-handling-of-invert_y-in-DrawTextExW.patch
@@ -1,17 +1,17 @@
-From 6e42e27181a16cc0b427e3504ec3ac8b7ab21f65 Mon Sep 17 00:00:00 2001
+From 984661d3ad7f1a78cc5b69f81a45b949781ce791 Mon Sep 17 00:00:00 2001
 From: Sebastian Lackner <sebastian@fds-team.de>
 Date: Thu, 13 Nov 2014 06:43:43 +0100
-Subject: [PATCH] user32: Fix handling of invert_y in DrawTextExW.
+Subject: user32: Fix handling of invert_y in DrawTextExW.
 
 ---
  dlls/user32/text.c | 32 +++++++++++++++-----------------
  1 file changed, 15 insertions(+), 17 deletions(-)
 
 diff --git a/dlls/user32/text.c b/dlls/user32/text.c
-index dd9d711cd48..647fff30c30 100644
+index 66a35d2..2aa127a 100644
 --- a/dlls/user32/text.c
 +++ b/dlls/user32/text.c
-@@ -909,6 +909,15 @@ INT WINAPI DrawTextExW( HDC hdc, LPWSTR str, INT i_count,
+@@ -911,6 +911,15 @@ INT WINAPI DrawTextExW( HDC hdc, LPWSTR str, INT i_count,
      if (dtp && dtp->cbSize != sizeof(DRAWTEXTPARAMS))
          return 0;
  
@@ -26,8 +26,8 @@ index dd9d711cd48..647fff30c30 100644
 +
      if (count == -1)
      {
-         count = lstrlenW(str);
-@@ -918,7 +927,7 @@ INT WINAPI DrawTextExW( HDC hdc, LPWSTR str, INT i_count,
+         count = strlenW(str);
+@@ -920,7 +929,7 @@ INT WINAPI DrawTextExW( HDC hdc, LPWSTR str, INT i_count,
              {
                  rect->right = rect->left;
                  if( flags & DT_SINGLELINE)
@@ -36,7 +36,7 @@ index dd9d711cd48..647fff30c30 100644
                  else
                      rect->bottom = rect->top;
              }
-@@ -926,15 +935,6 @@ INT WINAPI DrawTextExW( HDC hdc, LPWSTR str, INT i_count,
+@@ -928,15 +937,6 @@ INT WINAPI DrawTextExW( HDC hdc, LPWSTR str, INT i_count,
          }
      }
  
@@ -52,7 +52,7 @@ index dd9d711cd48..647fff30c30 100644
      if (dtp)
      {
          lmargin = dtp->iLeftMargin;
-@@ -982,9 +982,10 @@ INT WINAPI DrawTextExW( HDC hdc, LPWSTR str, INT i_count,
+@@ -983,9 +983,10 @@ INT WINAPI DrawTextExW( HDC hdc, LPWSTR str, INT i_count,
  
  	if (flags & DT_SINGLELINE)
  	{
@@ -66,7 +66,7 @@ index dd9d711cd48..647fff30c30 100644
          }
  
  	if (!(flags & DT_CALCRECT))
-@@ -1042,10 +1043,7 @@ INT WINAPI DrawTextExW( HDC hdc, LPWSTR str, INT i_count,
+@@ -1050,10 +1051,7 @@ INT WINAPI DrawTextExW( HDC hdc, LPWSTR str, INT i_count,
  	else if (size.cx > max_width)
  	    max_width = size.cx;
  
@@ -79,5 +79,5 @@ index dd9d711cd48..647fff30c30 100644
              dtp->uiLengthDrawn += len;
      }
 -- 
-2.28.0
+2.1.3
 
diff --git a/patches/uxtheme-GTK_Theming/0001-uxtheme-Initial-implementation-of-GTK-backend.patch b/patches/uxtheme-GTK_Theming/0001-uxtheme-Initial-implementation-of-GTK-backend.patch
index bc812215..97ee730b 100644
--- a/patches/uxtheme-GTK_Theming/0001-uxtheme-Initial-implementation-of-GTK-backend.patch
+++ b/patches/uxtheme-GTK_Theming/0001-uxtheme-Initial-implementation-of-GTK-backend.patch
@@ -1,7 +1,7 @@
-From 6c7e1cd9d421fef33c4e89e17c4e269af4a53f8a Mon Sep 17 00:00:00 2001
+From 661d9d1f1f04ae904f4420f4a067fc23dae45c6f Mon Sep 17 00:00:00 2001
 From: Ivan Akulinchev <ivan.akulinchev@gmail.com>
 Date: Sat, 9 Feb 2019 15:18:54 -0600
-Subject: [PATCH] uxtheme: Initial implementation of GTK backend.
+Subject: [PATCH 1/2] uxtheme: Initial implementation of GTK backend.
 MIME-Version: 1.0
 Content-Type: text/plain; charset=UTF-8
 Content-Transfer-Encoding: 8bit
@@ -35,13 +35,13 @@ Additional changes by Sebastian Lackner <sebastian@fds-team.de>:
  dlls/uxtheme/gtk-toolbar.c  | 171 +++++++
  dlls/uxtheme/gtk-trackbar.c | 188 +++++++
  dlls/uxtheme/gtk-window.c   | 172 +++++++
- dlls/uxtheme/gtk.c          | 961 ++++++++++++++++++++++++++++++++++++
+ dlls/uxtheme/gtk.c          | 962 ++++++++++++++++++++++++++++++++++++
  dlls/uxtheme/metric.c       |  24 +
  dlls/uxtheme/property.c     |  40 ++
  dlls/uxtheme/system.c       |  34 +-
  dlls/uxtheme/uxthemedll.h   |  72 +++
  dlls/uxtheme/uxthemegtk.h   | 129 +++++
- 22 files changed, 3760 insertions(+), 1 deletion(-)
+ 22 files changed, 3761 insertions(+), 1 deletion(-)
  create mode 100644 dlls/uxtheme/gtk-button.c
  create mode 100644 dlls/uxtheme/gtk-combobox.c
  create mode 100644 dlls/uxtheme/gtk-edit.c
@@ -59,10 +59,10 @@ Additional changes by Sebastian Lackner <sebastian@fds-team.de>:
  create mode 100644 dlls/uxtheme/uxthemegtk.h
 
 diff --git a/configure.ac b/configure.ac
-index 006087e05ec..cf5a6fa1b44 100644
+index 1c912a30a..c4373aeb2 100644
 --- a/configure.ac
 +++ b/configure.ac
-@@ -57,6 +57,7 @@ AC_ARG_WITH(gsm,       AS_HELP_STRING([--without-gsm],[do not use libgsm (GSM 06
+@@ -56,6 +56,7 @@ AC_ARG_WITH(gsm,       AS_HELP_STRING([--without-gsm],[do not use libgsm (GSM 06
              [if test "x$withval" = "xno"; then ac_cv_header_gsm_h=no; ac_cv_header_gsm_gsm_h=no; fi])
  AC_ARG_WITH(gssapi,    AS_HELP_STRING([--without-gssapi],[do not use GSSAPI (Kerberos SSP support)]))
  AC_ARG_WITH(gstreamer, AS_HELP_STRING([--without-gstreamer],[do not use GStreamer (codecs support)]))
@@ -70,7 +70,7 @@ index 006087e05ec..cf5a6fa1b44 100644
  AC_ARG_WITH(hal,       AS_HELP_STRING([--without-hal],[do not use HAL (dynamic device support)]))
  AC_ARG_WITH(inotify,   AS_HELP_STRING([--without-inotify],[do not use inotify (filesystem change notifications)]))
  AC_ARG_WITH(jpeg,      AS_HELP_STRING([--without-jpeg],[do not use JPEG]))
-@@ -1606,6 +1607,21 @@ fi
+@@ -1539,6 +1540,21 @@ fi
  WINE_NOTICE_WITH(cms,[test "$ac_cv_lib_lcms2_cmsOpenProfileFromFile" != "yes"],
                   [liblcms2 ${notice_platform}development files not found, Color Management won't be supported.])
  
@@ -93,7 +93,7 @@ index 006087e05ec..cf5a6fa1b44 100644
  if test "x$with_freetype" != "xno"
  then
 diff --git a/dlls/uxtheme/Makefile.in b/dlls/uxtheme/Makefile.in
-index c3fff30ba90..e09f891ee48 100644
+index c3fff30ba..e09f891ee 100644
 --- a/dlls/uxtheme/Makefile.in
 +++ b/dlls/uxtheme/Makefile.in
 @@ -2,10 +2,25 @@ MODULE    = uxtheme.dll
@@ -123,7 +123,7 @@ index c3fff30ba90..e09f891ee48 100644
  	metric.c \
  	msstyles.c \
 diff --git a/dlls/uxtheme/draw.c b/dlls/uxtheme/draw.c
-index 69c53b9ebc3..dbcbaab79b1 100644
+index 69c53b9eb..dbcbaab79 100644
 --- a/dlls/uxtheme/draw.c
 +++ b/dlls/uxtheme/draw.c
 @@ -55,6 +55,10 @@ HRESULT WINAPI EnableThemeDialogTexture(HWND hwnd, DWORD dwFlags)
@@ -221,7 +221,7 @@ index 69c53b9ebc3..dbcbaab79b1 100644
      if (bgtype != BT_IMAGEFILE) return FALSE;
 diff --git a/dlls/uxtheme/gtk-button.c b/dlls/uxtheme/gtk-button.c
 new file mode 100644
-index 00000000000..1e8581c77eb
+index 000000000..1e8581c77
 --- /dev/null
 +++ b/dlls/uxtheme/gtk-button.c
 @@ -0,0 +1,516 @@
@@ -743,7 +743,7 @@ index 00000000000..1e8581c77eb
 +#endif /* HAVE_GTK_GTK_H */
 diff --git a/dlls/uxtheme/gtk-combobox.c b/dlls/uxtheme/gtk-combobox.c
 new file mode 100644
-index 00000000000..f6cc0405587
+index 000000000..f6cc04055
 --- /dev/null
 +++ b/dlls/uxtheme/gtk-combobox.c
 @@ -0,0 +1,242 @@
@@ -991,7 +991,7 @@ index 00000000000..f6cc0405587
 +#endif /* HAVE_GTK_GTK_H */
 diff --git a/dlls/uxtheme/gtk-edit.c b/dlls/uxtheme/gtk-edit.c
 new file mode 100644
-index 00000000000..834a3889c5c
+index 000000000..834a3889c
 --- /dev/null
 +++ b/dlls/uxtheme/gtk-edit.c
 @@ -0,0 +1,211 @@
@@ -1208,7 +1208,7 @@ index 00000000000..834a3889c5c
 +#endif /* HAVE_GTK_GTK_H */
 diff --git a/dlls/uxtheme/gtk-header.c b/dlls/uxtheme/gtk-header.c
 new file mode 100644
-index 00000000000..c95918db2ef
+index 000000000..c95918db2
 --- /dev/null
 +++ b/dlls/uxtheme/gtk-header.c
 @@ -0,0 +1,128 @@
@@ -1342,7 +1342,7 @@ index 00000000000..c95918db2ef
 +#endif /* HAVE_GTK_GTK_H */
 diff --git a/dlls/uxtheme/gtk-listbox.c b/dlls/uxtheme/gtk-listbox.c
 new file mode 100644
-index 00000000000..89b281ded41
+index 000000000..89b281ded
 --- /dev/null
 +++ b/dlls/uxtheme/gtk-listbox.c
 @@ -0,0 +1,119 @@
@@ -1467,7 +1467,7 @@ index 00000000000..89b281ded41
 +#endif /* HAVE_GTK_GTK_H */
 diff --git a/dlls/uxtheme/gtk-listview.c b/dlls/uxtheme/gtk-listview.c
 new file mode 100644
-index 00000000000..fbc85fdccce
+index 000000000..fbc85fdcc
 --- /dev/null
 +++ b/dlls/uxtheme/gtk-listview.c
 @@ -0,0 +1,38 @@
@@ -1511,7 +1511,7 @@ index 00000000000..fbc85fdccce
 +#endif /* HAVE_GTK_GTK_H */
 diff --git a/dlls/uxtheme/gtk-menu.c b/dlls/uxtheme/gtk-menu.c
 new file mode 100644
-index 00000000000..30357bc85f4
+index 000000000..30357bc85
 --- /dev/null
 +++ b/dlls/uxtheme/gtk-menu.c
 @@ -0,0 +1,189 @@
@@ -1706,7 +1706,7 @@ index 00000000000..30357bc85f4
 +#endif /* HAVE_GTK_GTK_H */
 diff --git a/dlls/uxtheme/gtk-rebar.c b/dlls/uxtheme/gtk-rebar.c
 new file mode 100644
-index 00000000000..493b05b6ff1
+index 000000000..493b05b6f
 --- /dev/null
 +++ b/dlls/uxtheme/gtk-rebar.c
 @@ -0,0 +1,102 @@
@@ -1814,7 +1814,7 @@ index 00000000000..493b05b6ff1
 +#endif /* HAVE_GTK_GTK_H */
 diff --git a/dlls/uxtheme/gtk-status.c b/dlls/uxtheme/gtk-status.c
 new file mode 100644
-index 00000000000..558a8227c42
+index 000000000..558a8227c
 --- /dev/null
 +++ b/dlls/uxtheme/gtk-status.c
 @@ -0,0 +1,157 @@
@@ -1977,7 +1977,7 @@ index 00000000000..558a8227c42
 +#endif /* HAVE_GTK_GTK_H */
 diff --git a/dlls/uxtheme/gtk-tab.c b/dlls/uxtheme/gtk-tab.c
 new file mode 100644
-index 00000000000..845dbec1a65
+index 000000000..845dbec1a
 --- /dev/null
 +++ b/dlls/uxtheme/gtk-tab.c
 @@ -0,0 +1,207 @@
@@ -2190,7 +2190,7 @@ index 00000000000..845dbec1a65
 +#endif /* HAVE_GTK_GTK_H */
 diff --git a/dlls/uxtheme/gtk-toolbar.c b/dlls/uxtheme/gtk-toolbar.c
 new file mode 100644
-index 00000000000..231fffe7335
+index 000000000..231fffe73
 --- /dev/null
 +++ b/dlls/uxtheme/gtk-toolbar.c
 @@ -0,0 +1,171 @@
@@ -2367,7 +2367,7 @@ index 00000000000..231fffe7335
 +#endif /* HAVE_GTK_GTK_H */
 diff --git a/dlls/uxtheme/gtk-trackbar.c b/dlls/uxtheme/gtk-trackbar.c
 new file mode 100644
-index 00000000000..0bd4c2d1dd2
+index 000000000..0bd4c2d1d
 --- /dev/null
 +++ b/dlls/uxtheme/gtk-trackbar.c
 @@ -0,0 +1,188 @@
@@ -2561,7 +2561,7 @@ index 00000000000..0bd4c2d1dd2
 +#endif /* HAVE_GTK_GTK_H */
 diff --git a/dlls/uxtheme/gtk-window.c b/dlls/uxtheme/gtk-window.c
 new file mode 100644
-index 00000000000..2c4b4007402
+index 000000000..2c4b40074
 --- /dev/null
 +++ b/dlls/uxtheme/gtk-window.c
 @@ -0,0 +1,172 @@
@@ -2739,10 +2739,10 @@ index 00000000000..2c4b4007402
 +#endif /* HAVE_GTK_GTK_H */
 diff --git a/dlls/uxtheme/gtk.c b/dlls/uxtheme/gtk.c
 new file mode 100644
-index 00000000000..17cee005d5a
+index 000000000..ddaa96496
 --- /dev/null
 +++ b/dlls/uxtheme/gtk.c
-@@ -0,0 +1,961 @@
+@@ -0,0 +1,962 @@
 +/*
 + * GTK uxtheme implementation
 + *
@@ -2780,6 +2780,7 @@ index 00000000000..17cee005d5a
 +#include "vssym32.h"
 +
 +#include "wine/debug.h"
++#include "wine/library.h"
 +
 +#include "uxthemedll.h"
 +
@@ -3705,7 +3706,7 @@ index 00000000000..17cee005d5a
 +
 +#endif /* HAVE_GTK_GTK_H */
 diff --git a/dlls/uxtheme/metric.c b/dlls/uxtheme/metric.c
-index 073422f1cda..244187d1963 100644
+index 073422f1c..244187d19 100644
 --- a/dlls/uxtheme/metric.c
 +++ b/dlls/uxtheme/metric.c
 @@ -31,6 +31,7 @@
@@ -3782,7 +3783,7 @@ index 073422f1cda..244187d1963 100644
          WARN("Unknown StringID: %d\n", iStringID);
          return STG_E_INVALIDPARAMETER;
 diff --git a/dlls/uxtheme/property.c b/dlls/uxtheme/property.c
-index 0e077aeec46..ada48287952 100644
+index 0e077aeec..ada482879 100644
 --- a/dlls/uxtheme/property.c
 +++ b/dlls/uxtheme/property.c
 @@ -31,6 +31,7 @@
@@ -3924,7 +3925,7 @@ index 0e077aeec46..ada48287952 100644
          *pOrigin = PO_NOTFOUND;
          return S_OK;
 diff --git a/dlls/uxtheme/system.c b/dlls/uxtheme/system.c
-index c898ad32e2f..2f7d40fc011 100644
+index c898ad32e..2f7d40fc0 100644
 --- a/dlls/uxtheme/system.c
 +++ b/dlls/uxtheme/system.c
 @@ -558,6 +558,10 @@ BOOL WINAPI IsAppThemed(void)
@@ -4032,7 +4033,7 @@ index c898ad32e2f..2f7d40fc011 100644
          return TRUE;
      return FALSE;
 diff --git a/dlls/uxtheme/uxthemedll.h b/dlls/uxtheme/uxthemedll.h
-index fee152c9c34..cdc5958d7c7 100644
+index fee152c9c..cdc5958d7 100644
 --- a/dlls/uxtheme/uxthemedll.h
 +++ b/dlls/uxtheme/uxthemedll.h
 @@ -21,6 +21,14 @@
@@ -4123,7 +4124,7 @@ index fee152c9c34..cdc5958d7c7 100644
  /* "Cheap" binary alpha blending - but possibly faster */
 diff --git a/dlls/uxtheme/uxthemegtk.h b/dlls/uxtheme/uxthemegtk.h
 new file mode 100644
-index 00000000000..87cd0456f8d
+index 000000000..87cd0456f
 --- /dev/null
 +++ b/dlls/uxtheme/uxthemegtk.h
 @@ -0,0 +1,129 @@
@@ -4257,5 +4258,5 @@ index 00000000000..87cd0456f8d
 +
 +#endif /* UXTHEMEGTK_H */
 -- 
-2.28.0
+2.23.0
 
diff --git a/patches/wineboot-DriveSerial/0001-wineboot-Assign-a-drive-serial-number-during-prefix-.patch b/patches/wineboot-DriveSerial/0001-wineboot-Assign-a-drive-serial-number-during-prefix-.patch
index 093120d0..3b0839c0 100644
--- a/patches/wineboot-DriveSerial/0001-wineboot-Assign-a-drive-serial-number-during-prefix-.patch
+++ b/patches/wineboot-DriveSerial/0001-wineboot-Assign-a-drive-serial-number-during-prefix-.patch
@@ -57,14 +57,14 @@ index 21be0f55fb0..b67b60974b4 100644
  /* create the volatile hardware registry keys */
  static void create_hardware_registry_keys(void)
  {
-@@ -1590,6 +1621,7 @@ int __cdecl main( int argc, char *argv[] )
+@@ -1694,6 +1725,7 @@ int __cdecl main( int argc, char *argv[] )
+ 
      ResetEvent( event );  /* in case this is a restart */
  
-     create_user_shared_data();
 +    create_disk_serial_number();
      create_hardware_registry_keys();
      create_dynamic_registry_keys();
      create_environment_registry_keys();
 -- 
-2.26.2
+2.25.0
 
diff --git a/patches/winebuild-Fake_Dlls/0001-kernel32-tests-Add-basic-tests-for-fake-dlls.patch b/patches/winebuild-Fake_Dlls/0001-kernel32-tests-Add-basic-tests-for-fake-dlls.patch
new file mode 100644
index 00000000..ef056cfc
--- /dev/null
+++ b/patches/winebuild-Fake_Dlls/0001-kernel32-tests-Add-basic-tests-for-fake-dlls.patch
@@ -0,0 +1,121 @@
+From de68d5c0e6bd728788bbec09100ea59802b8ff13 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
+Date: Thu, 25 May 2017 07:02:46 +0200
+Subject: [PATCH] kernel32/tests: Add basic tests for fake dlls.
+
+---
+ dlls/kernel32/tests/loader.c | 91 ++++++++++++++++++++++++++++++++++++
+ 1 file changed, 91 insertions(+)
+
+diff --git a/dlls/kernel32/tests/loader.c b/dlls/kernel32/tests/loader.c
+index 5474d543248..4e7a15970cb 100644
+--- a/dlls/kernel32/tests/loader.c
++++ b/dlls/kernel32/tests/loader.c
+@@ -1535,6 +1535,96 @@ static void test_filenames(void)
+     DeleteFileA( long_path );
+ }
+ 
++static void test_FakeDLL(void)
++{
++#ifdef __i386__
++    NTSTATUS (WINAPI *pNtSetEvent)(HANDLE, ULONG *) = NULL;
++    IMAGE_EXPORT_DIRECTORY *dir;
++    HMODULE module = GetModuleHandleA("ntdll.dll");
++    HANDLE file, map, event;
++    WCHAR path[MAX_PATH];
++    DWORD *names, *funcs;
++    WORD *ordinals;
++    ULONG size;
++    void *ptr;
++    int i;
++
++    GetModuleFileNameW(module, path, MAX_PATH);
++
++    file = CreateFileW(path, GENERIC_READ | GENERIC_EXECUTE, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0);
++    ok(file != INVALID_HANDLE_VALUE, "Failed to open %s (error %u)\n", wine_dbgstr_w(path), GetLastError());
++
++    map = CreateFileMappingW(file, NULL, PAGE_EXECUTE_READ | SEC_IMAGE, 0, 0, NULL);
++    ok(map != NULL, "CreateFileMapping failed with error %u\n", GetLastError());
++    ptr = MapViewOfFile(map, FILE_MAP_READ | FILE_MAP_EXECUTE, 0, 0, 0);
++    ok(ptr != NULL, "MapViewOfFile failed with error %u\n", GetLastError());
++
++    dir = RtlImageDirectoryEntryToData(ptr, TRUE, IMAGE_DIRECTORY_ENTRY_EXPORT, &size);
++todo_wine
++    ok(dir != NULL, "RtlImageDirectoryEntryToData failed\n");
++    if (dir == NULL) goto done;
++
++    names    = RVAToAddr(dir->AddressOfNames, ptr);
++    ordinals = RVAToAddr(dir->AddressOfNameOrdinals, ptr);
++    funcs    = RVAToAddr(dir->AddressOfFunctions, ptr);
++    ok(dir->NumberOfNames > 0, "Could not find any exported functions\n");
++
++    for (i = 0; i < dir->NumberOfNames; i++)
++    {
++        DWORD map_rva, dll_rva, map_offset, dll_offset;
++        char *func_name = RVAToAddr(names[i], ptr);
++        BYTE *dll_func, *map_func;
++
++        /* check only Nt functions for now */
++        if (strncmp(func_name, "Zw", 2) && strncmp(func_name, "Nt", 2))
++            continue;
++
++        dll_func = (BYTE *)GetProcAddress(module, func_name);
++        ok(dll_func != NULL, "%s: GetProcAddress returned NULL\n", func_name);
++        if (dll_func[0] == 0x90 && dll_func[1] == 0x90 &&
++            dll_func[2] == 0x90 && dll_func[3] == 0x90)
++        {
++            todo_wine ok(0, "%s: Export is a stub-function, skipping\n", func_name);
++            continue;
++        }
++
++        /* check position in memory */
++        dll_rva = (DWORD_PTR)dll_func - (DWORD_PTR)module;
++        map_rva = funcs[ordinals[i]];
++        ok(map_rva == dll_rva, "%s: Rva of mapped function (0x%x) does not match dll (0x%x)\n",
++           func_name, dll_rva, map_rva);
++
++        /* check position in file */
++        map_offset = (DWORD_PTR)RtlImageRvaToVa(RtlImageNtHeader(ptr),    ptr,    map_rva, NULL) - (DWORD_PTR)ptr;
++        dll_offset = (DWORD_PTR)RtlImageRvaToVa(RtlImageNtHeader(module), module, dll_rva, NULL) - (DWORD_PTR)module;
++        ok(map_offset == dll_offset, "%s: File offset of mapped function (0x%x) does not match dll (0x%x)\n",
++           func_name, map_offset, dll_offset);
++
++        /* check function content */
++        map_func = RVAToAddr(map_rva, ptr);
++        ok(!memcmp(map_func, dll_func, 0x20), "%s: Function content does not match!\n", func_name);
++
++        if (!strcmp(func_name, "NtSetEvent"))
++            pNtSetEvent = (void *)map_func;
++    }
++
++    ok(pNtSetEvent != NULL, "Could not find NtSetEvent export\n");
++    if (pNtSetEvent)
++    {
++        event = CreateEventA(NULL, TRUE, FALSE, NULL);
++        ok(event != NULL, "CreateEvent failed with error %u\n", GetLastError());
++        pNtSetEvent(event, 0);
++        ok(WaitForSingleObject(event, 0) == WAIT_OBJECT_0, "Event was not signaled\n");
++        CloseHandle(event);
++    }
++
++done:
++    UnmapViewOfFile(ptr);
++    CloseHandle(map);
++    CloseHandle(file);
++#endif
++}
++
+ /* Verify linking style of import descriptors */
+ static void test_ImportDescriptors(void)
+ {
+@@ -3997,6 +4087,7 @@ START_TEST(loader)
+         return;
+     }
+ 
++    test_FakeDLL();
+     test_filenames();
+     test_ResolveDelayLoadedAPI();
+     test_ImportDescriptors();
+-- 
+2.26.2
+
diff --git a/patches/winebuild-Fake_Dlls/0002-krnl386.exe16-Do-not-abuse-WOW32Reserved-field-for-1.patch b/patches/winebuild-Fake_Dlls/0002-krnl386.exe16-Do-not-abuse-WOW32Reserved-field-for-1.patch
new file mode 100644
index 00000000..01293676
--- /dev/null
+++ b/patches/winebuild-Fake_Dlls/0002-krnl386.exe16-Do-not-abuse-WOW32Reserved-field-for-1.patch
@@ -0,0 +1,660 @@
+From 362b04b78c2da18e81dd4f571d3671d452c76634 Mon Sep 17 00:00:00 2001
+From: Sebastian Lackner <sebastian@fds-team.de>
+Date: Tue, 16 May 2017 04:37:52 +0200
+Subject: [PATCH] krnl386.exe16: Do not abuse WOW32Reserved field for 16-bit
+ stack address.
+
+---
+ dlls/dbghelp/cpu_i386.c               |  6 ++---
+ dlls/krnl386.exe16/kernel.c           |  6 ++---
+ dlls/krnl386.exe16/kernel16_private.h | 11 ++++----
+ dlls/krnl386.exe16/ne_module.c        |  6 ++---
+ dlls/krnl386.exe16/ne_segment.c       | 20 +++++++--------
+ dlls/krnl386.exe16/task.c             | 14 +++++------
+ dlls/krnl386.exe16/thunk.c            | 36 +++++++++++++--------------
+ dlls/krnl386.exe16/wowthunk.c         | 20 +++++++--------
+ dlls/ntdll/signal_i386.c              |  2 +-
+ dlls/system.drv16/system.c            |  2 +-
+ dlls/toolhelp.dll16/toolhelp.c        |  6 ++---
+ dlls/user.exe16/message.c             | 16 ++++++------
+ dlls/user.exe16/user.c                |  4 +--
+ dlls/user.exe16/window.c              |  2 +-
+ include/winternl.h                    |  2 +-
+ tools/winebuild/relay.c               |  2 +-
+ 16 files changed, 78 insertions(+), 77 deletions(-)
+
+diff --git a/dlls/dbghelp/cpu_i386.c b/dlls/dbghelp/cpu_i386.c
+index fd808a0d324..7d6723977a2 100644
+--- a/dlls/dbghelp/cpu_i386.c
++++ b/dlls/dbghelp/cpu_i386.c
+@@ -213,16 +213,16 @@ static BOOL i386_stack_walk(struct cpu_stack_walk *csw, STACKFRAME64 *frame,
+         /* Init done */
+         set_curr_mode((frame->AddrPC.Mode == AddrModeFlat) ? stm_32bit : stm_16bit);
+ 
+-        /* cur_switch holds address of WOW32Reserved field in TEB in debuggee
++        /* cur_switch holds address of SystemReserved1[0] field in TEB in debuggee
+          * address space
+          */
+         if (NtQueryInformationThread(csw->hThread, ThreadBasicInformation, &info,
+                                      sizeof(info), NULL) == STATUS_SUCCESS)
+         {
+-            curr_switch = (DWORD_PTR)info.TebBaseAddress + FIELD_OFFSET(TEB, WOW32Reserved);
++            curr_switch = (DWORD_PTR)info.TebBaseAddress + FIELD_OFFSET(TEB, SystemReserved1[0]);
+             if (!sw_read_mem(csw, curr_switch, &p, sizeof(p)))
+             {
+-                WARN("Can't read TEB:WOW32Reserved\n");
++                WARN("Can't read TEB:SystemReserved1[0]\n");
+                 goto done_err;
+             }
+             next_switch = p;
+diff --git a/dlls/krnl386.exe16/kernel.c b/dlls/krnl386.exe16/kernel.c
+index 07a57d0d937..89ea5c042e7 100644
+--- a/dlls/krnl386.exe16/kernel.c
++++ b/dlls/krnl386.exe16/kernel.c
+@@ -47,8 +47,8 @@ static void thread_attach(void)
+     /* allocate the 16-bit stack (FIXME: should be done lazily) */
+     HGLOBAL16 hstack = WOWGlobalAlloc16( GMEM_FIXED, 0x10000 );
+     kernel_get_thread_data()->stack_sel = GlobalHandleToSel16( hstack );
+-    NtCurrentTeb()->WOW32Reserved = (void *)MAKESEGPTR( kernel_get_thread_data()->stack_sel,
+-                                                        0x10000 - sizeof(STACK16FRAME) );
++    NtCurrentTeb()->SystemReserved1[0] = (void *)MAKESEGPTR( kernel_get_thread_data()->stack_sel,
++                                                             0x10000 - sizeof(STACK16FRAME) );
+     memset( (char *)GlobalLock16(hstack) + 0x10000 - sizeof(STACK16FRAME), 0, sizeof(STACK16FRAME) );
+ }
+ 
+@@ -60,7 +60,7 @@ static void thread_detach(void)
+ {
+     /* free the 16-bit stack */
+     WOWGlobalFree16( kernel_get_thread_data()->stack_sel );
+-    NtCurrentTeb()->WOW32Reserved = 0;
++    NtCurrentTeb()->SystemReserved1[0] = 0;
+     if (NtCurrentTeb()->Tib.SubSystemTib) TASK_ExitTask();
+ }
+ 
+diff --git a/dlls/krnl386.exe16/kernel16_private.h b/dlls/krnl386.exe16/kernel16_private.h
+index f15934daa0e..9f939a9d5ba 100644
+--- a/dlls/krnl386.exe16/kernel16_private.h
++++ b/dlls/krnl386.exe16/kernel16_private.h
+@@ -169,7 +169,7 @@ extern THHOOK *pThhook DECLSPEC_HIDDEN;
+     (((offset)+(size) <= pModule->mapping_size) ? \
+      (memcpy( buffer, (const char *)pModule->mapping + (offset), (size) ), TRUE) : FALSE)
+ 
+-#define CURRENT_STACK16 ((STACK16FRAME*)MapSL(PtrToUlong(NtCurrentTeb()->WOW32Reserved)))
++#define CURRENT_STACK16 ((STACK16FRAME*)MapSL(PtrToUlong(NtCurrentTeb()->SystemReserved1[0])))
+ #define CURRENT_DS      (CURRENT_STACK16->ds)
+ 
+ /* push bytes on the 16-bit stack of a thread; return a segptr to the first pushed byte */
+@@ -177,8 +177,8 @@ static inline SEGPTR stack16_push( int size )
+ {
+     STACK16FRAME *frame = CURRENT_STACK16;
+     memmove( (char*)frame - size, frame, sizeof(*frame) );
+-    NtCurrentTeb()->WOW32Reserved = (char *)NtCurrentTeb()->WOW32Reserved - size;
+-    return (SEGPTR)((char *)NtCurrentTeb()->WOW32Reserved + sizeof(*frame));
++    NtCurrentTeb()->SystemReserved1[0] = (char *)NtCurrentTeb()->SystemReserved1[0] - size;
++    return (SEGPTR)((char *)NtCurrentTeb()->SystemReserved1[0] + sizeof(*frame));
+ }
+ 
+ /* pop bytes from the 16-bit stack of a thread */
+@@ -186,7 +186,7 @@ static inline void stack16_pop( int size )
+ {
+     STACK16FRAME *frame = CURRENT_STACK16;
+     memmove( (char*)frame + size, frame, sizeof(*frame) );
+-    NtCurrentTeb()->WOW32Reserved = (char *)NtCurrentTeb()->WOW32Reserved + size;
++    NtCurrentTeb()->SystemReserved1[0] = (char *)NtCurrentTeb()->SystemReserved1[0] + size;
+ }
+ 
+ /* dosmem.c */
+@@ -300,11 +300,12 @@ struct tagSYSLEVEL;
+ 
+ struct kernel_thread_data
+ {
++    void               *reserved;       /* stack segment pointer */
+     WORD                stack_sel;      /* 16-bit stack selector */
+     WORD                htask16;        /* Win16 task handle */
+     DWORD               sys_count[4];   /* syslevel mutex entry counters */
+     struct tagSYSLEVEL *sys_mutex[4];   /* syslevel mutex pointers */
+-    void               *pad[45];        /* change this if you add fields! */
++    void               *pad[44];        /* change this if you add fields! */
+ };
+ 
+ static inline struct kernel_thread_data *kernel_get_thread_data(void)
+diff --git a/dlls/krnl386.exe16/ne_module.c b/dlls/krnl386.exe16/ne_module.c
+index f1e1a14dd67..c951a18f869 100644
+--- a/dlls/krnl386.exe16/ne_module.c
++++ b/dlls/krnl386.exe16/ne_module.c
+@@ -1208,7 +1208,7 @@ DWORD NE_StartTask(void)
+             sp = pSegTable[SELECTOROF(pModule->ne_sssp)-1].minsize + pModule->ne_stack;
+         sp &= ~1;
+         sp -= sizeof(STACK16FRAME);
+-        NtCurrentTeb()->WOW32Reserved = (void *)MAKESEGPTR( GlobalHandleToSel16(hInstance), sp );
++        NtCurrentTeb()->SystemReserved1[0] = (void *)MAKESEGPTR( GlobalHandleToSel16(hInstance), sp );
+ 
+         /* Registers at initialization must be:
+          * ax   zero
+@@ -1236,8 +1236,8 @@ DWORD NE_StartTask(void)
+ 
+         TRACE("Starting main program: cs:ip=%04x:%04x ds=%04x ss:sp=%04x:%04x\n",
+               context.SegCs, context.Eip, context.SegDs,
+-              SELECTOROF(NtCurrentTeb()->WOW32Reserved),
+-              OFFSETOF(NtCurrentTeb()->WOW32Reserved) );
++              SELECTOROF(NtCurrentTeb()->SystemReserved1[0]),
++              OFFSETOF(NtCurrentTeb()->SystemReserved1[0]) );
+ 
+         WOWCallback16Ex( 0, WCB16_REGS, 0, NULL, (DWORD *)&context );
+         ExitThread( LOWORD(context.Eax) );
+diff --git a/dlls/krnl386.exe16/ne_segment.c b/dlls/krnl386.exe16/ne_segment.c
+index aa886148029..70eb3360914 100644
+--- a/dlls/krnl386.exe16/ne_segment.c
++++ b/dlls/krnl386.exe16/ne_segment.c
+@@ -370,9 +370,9 @@ BOOL NE_LoadSegment( NE_MODULE *pModule, WORD segnum )
+         DWORD ret;
+ 
+  	selfloadheader = MapSL( MAKESEGPTR(SEL(pSegTable->hSeg),0) );
+-        oldstack = NtCurrentTeb()->WOW32Reserved;
+-        NtCurrentTeb()->WOW32Reserved = (void *)MAKESEGPTR(pModule->self_loading_sel,
+-                                                           0xff00 - sizeof(STACK16FRAME));
++        oldstack = NtCurrentTeb()->SystemReserved1[0];
++        NtCurrentTeb()->SystemReserved1[0] = (void *)MAKESEGPTR(pModule->self_loading_sel,
++                                                                0xff00 - sizeof(STACK16FRAME));
+ 
+         hFile16 = NE_OpenFile( pModule );
+         TRACE_(dll)("Call LoadAppSegProc(hmodule=0x%04x,hf=%x,segnum=%d)\n",
+@@ -384,7 +384,7 @@ BOOL NE_LoadSegment( NE_MODULE *pModule, WORD segnum )
+         pSeg->hSeg = LOWORD(ret);
+         TRACE_(dll)("Ret LoadAppSegProc: hSeg=0x%04x\n", pSeg->hSeg);
+         _lclose16( hFile16 );
+-        NtCurrentTeb()->WOW32Reserved = oldstack;
++        NtCurrentTeb()->SystemReserved1[0] = oldstack;
+ 
+         pSeg->flags |= NE_SEGFLAGS_LOADED;
+         return TRUE;
+@@ -476,9 +476,9 @@ BOOL NE_LoadAllSegments( NE_MODULE *pModule )
+         sel = GlobalAlloc16( GMEM_ZEROINIT, 0xFF00 );
+         pModule->self_loading_sel = SEL(sel);
+         FarSetOwner16( sel, pModule->self );
+-        oldstack = NtCurrentTeb()->WOW32Reserved;
+-        NtCurrentTeb()->WOW32Reserved = (void *)MAKESEGPTR(pModule->self_loading_sel,
+-                                                           0xff00 - sizeof(STACK16FRAME) );
++        oldstack = NtCurrentTeb()->SystemReserved1[0];
++        NtCurrentTeb()->SystemReserved1[0] = (void *)MAKESEGPTR(pModule->self_loading_sel,
++                                                                0xff00 - sizeof(STACK16FRAME) );
+ 
+         hFile16 = NE_OpenFile(pModule);
+         TRACE_(dll)("CallBootAppProc(hModule=0x%04x,hf=0x%04x)\n",
+@@ -488,7 +488,7 @@ BOOL NE_LoadAllSegments( NE_MODULE *pModule )
+         WOWCallback16Ex( (DWORD)selfloadheader->BootApp, WCB16_PASCAL, sizeof(args), args, NULL );
+ 	TRACE_(dll)("Return from CallBootAppProc\n");
+         _lclose16(hFile16);
+-        NtCurrentTeb()->WOW32Reserved = oldstack;
++        NtCurrentTeb()->SystemReserved1[0] = oldstack;
+ 
+         for (i = 2; i <= pModule->ne_cseg; i++)
+             if (!NE_LoadSegment( pModule, i )) return FALSE;
+@@ -680,7 +680,7 @@ static BOOL NE_InitDLL( NE_MODULE *pModule )
+     context.SegEs = ds;   /* who knows ... */
+     context.SegCs = SEL(pSegTable[SELECTOROF(pModule->ne_csip)-1].hSeg);
+     context.Eip   = OFFSETOF(pModule->ne_csip);
+-    context.Ebp   = OFFSETOF(NtCurrentTeb()->WOW32Reserved) + FIELD_OFFSET(STACK16FRAME,bp);
++    context.Ebp   = OFFSETOF(NtCurrentTeb()->SystemReserved1[0]) + FIELD_OFFSET(STACK16FRAME,bp);
+ 
+     pModule->ne_csip = 0;  /* Don't initialize it twice */
+     TRACE_(dll)("Calling LibMain for %.*s, cs:ip=%04x:%04x ds=%04x di=%04x cx=%04x\n",
+@@ -782,7 +782,7 @@ static void NE_CallDllEntryPoint( NE_MODULE *pModule, DWORD dwReason )
+         context.SegEs = ds;   /* who knows ... */
+         context.SegCs = HIWORD(entryPoint);
+         context.Eip   = LOWORD(entryPoint);
+-        context.Ebp   = OFFSETOF(NtCurrentTeb()->WOW32Reserved) + FIELD_OFFSET(STACK16FRAME,bp);
++        context.Ebp   = OFFSETOF(NtCurrentTeb()->SystemReserved1[0]) + FIELD_OFFSET(STACK16FRAME,bp);
+ 
+         args[7] = HIWORD(dwReason);
+         args[6] = LOWORD(dwReason);
+diff --git a/dlls/krnl386.exe16/task.c b/dlls/krnl386.exe16/task.c
+index 39a60cb97a9..21de62c5a01 100644
+--- a/dlls/krnl386.exe16/task.c
++++ b/dlls/krnl386.exe16/task.c
+@@ -624,7 +624,7 @@ void WINAPI InitTask16( CONTEXT *context )
+ 
+     /* Initialize the INSTANCEDATA structure */
+     pinstance = MapSL( MAKESEGPTR(CURRENT_DS, 0) );
+-    pinstance->stackmin    = OFFSETOF(NtCurrentTeb()->WOW32Reserved) + sizeof( STACK16FRAME );
++    pinstance->stackmin    = OFFSETOF(NtCurrentTeb()->SystemReserved1[0]) + sizeof( STACK16FRAME );
+     pinstance->stackbottom = pinstance->stackmin; /* yup, that's right. Confused me too. */
+     pinstance->stacktop    = ( pinstance->stackmin > LOWORD(context->Ebx) ?
+                                pinstance->stackmin - LOWORD(context->Ebx) : 0 ) + 150;
+@@ -1095,14 +1095,14 @@ void WINAPI SwitchStackTo16( WORD seg, WORD ptr, WORD top )
+ 
+     if (!(pData = GlobalLock16( seg ))) return;
+     TRACE("old=%04x:%04x new=%04x:%04x\n",
+-          SELECTOROF( NtCurrentTeb()->WOW32Reserved ),
+-          OFFSETOF( NtCurrentTeb()->WOW32Reserved ), seg, ptr );
++          SELECTOROF( NtCurrentTeb()->SystemReserved1[0] ),
++          OFFSETOF( NtCurrentTeb()->SystemReserved1[0] ), seg, ptr );
+ 
+     /* Save the old stack */
+ 
+     oldFrame = CURRENT_STACK16;
+     /* pop frame + args and push bp */
+-    pData->old_ss_sp   = (SEGPTR)NtCurrentTeb()->WOW32Reserved + sizeof(STACK16FRAME)
++    pData->old_ss_sp   = (SEGPTR)NtCurrentTeb()->SystemReserved1[0] + sizeof(STACK16FRAME)
+                            + 2 * sizeof(WORD);
+     *(WORD *)MapSL(pData->old_ss_sp) = oldFrame->bp;
+     pData->stacktop    = top;
+@@ -1116,7 +1116,7 @@ void WINAPI SwitchStackTo16( WORD seg, WORD ptr, WORD top )
+      */
+     copySize = oldFrame->bp - OFFSETOF(pData->old_ss_sp);
+     copySize += 3 * sizeof(WORD) + sizeof(STACK16FRAME);
+-    NtCurrentTeb()->WOW32Reserved = (void *)MAKESEGPTR( seg, ptr - copySize );
++    NtCurrentTeb()->SystemReserved1[0] = (void *)MAKESEGPTR( seg, ptr - copySize );
+     newFrame = CURRENT_STACK16;
+ 
+     /* Copy the stack frame and the local variables to the new stack */
+@@ -1135,7 +1135,7 @@ void WINAPI SwitchStackBack16( CONTEXT *context )
+     STACK16FRAME *oldFrame, *newFrame;
+     INSTANCEDATA *pData;
+ 
+-    if (!(pData = GlobalLock16(SELECTOROF(NtCurrentTeb()->WOW32Reserved))))
++    if (!(pData = GlobalLock16(SELECTOROF(NtCurrentTeb()->SystemReserved1[0]))))
+         return;
+     if (!pData->old_ss_sp)
+     {
+@@ -1154,7 +1154,7 @@ void WINAPI SwitchStackBack16( CONTEXT *context )
+ 
+     /* Switch back to the old stack */
+ 
+-    NtCurrentTeb()->WOW32Reserved = (void *)(pData->old_ss_sp - sizeof(STACK16FRAME));
++    NtCurrentTeb()->SystemReserved1[0] = (void *)(pData->old_ss_sp - sizeof(STACK16FRAME));
+     context->SegSs = SELECTOROF(pData->old_ss_sp);
+     context->Esp   = OFFSETOF(pData->old_ss_sp) - sizeof(DWORD); /*ret addr*/
+     pData->old_ss_sp = 0;
+diff --git a/dlls/krnl386.exe16/thunk.c b/dlls/krnl386.exe16/thunk.c
+index 78925f594ba..141acb8d5e6 100644
+--- a/dlls/krnl386.exe16/thunk.c
++++ b/dlls/krnl386.exe16/thunk.c
+@@ -428,7 +428,7 @@ void WINAPI __regs_QT_Thunk( CONTEXT *context )
+     context16.Eip   = LOWORD(context->Edx);
+     /* point EBP to the STACK16FRAME on the stack
+      * for the call_to_16 to set up the register content on calling */
+-    context16.Ebp   = OFFSETOF(NtCurrentTeb()->WOW32Reserved) + FIELD_OFFSET(STACK16FRAME,bp);
++    context16.Ebp   = OFFSETOF(NtCurrentTeb()->SystemReserved1[0]) + FIELD_OFFSET(STACK16FRAME,bp);
+ 
+     /*
+      * used to be (problematic):
+@@ -450,7 +450,7 @@ void WINAPI __regs_QT_Thunk( CONTEXT *context )
+      * the number of parameters that the Win16 function
+      * accepted (that it popped from the corresponding Win16 stack) */
+     context->Esp +=   LOWORD(context16.Esp) -
+-                        ( OFFSETOF(NtCurrentTeb()->WOW32Reserved) - argsize );
++                        ( OFFSETOF(NtCurrentTeb()->SystemReserved1[0]) - argsize );
+ }
+ DEFINE_REGS_ENTRYPOINT( QT_Thunk )
+ 
+@@ -554,7 +554,7 @@ void WINAPI __regs_FT_Thunk( CONTEXT *context )
+ 
+     context16.SegCs = HIWORD(callTarget);
+     context16.Eip   = LOWORD(callTarget);
+-    context16.Ebp   = OFFSETOF(NtCurrentTeb()->WOW32Reserved) + FIELD_OFFSET(STACK16FRAME,bp);
++    context16.Ebp   = OFFSETOF(NtCurrentTeb()->SystemReserved1[0]) + FIELD_OFFSET(STACK16FRAME,bp);
+ 
+     argsize  = context->Ebp-context->Esp-0x40;
+     if (argsize > sizeof(newstack)) argsize = sizeof(newstack);
+@@ -566,8 +566,8 @@ void WINAPI __regs_FT_Thunk( CONTEXT *context )
+ 	if (mapESPrelative & (1 << i))
+ 	{
+ 	    SEGPTR *arg = (SEGPTR *)newstack[i];
+-	    *arg = MAKESEGPTR(SELECTOROF(NtCurrentTeb()->WOW32Reserved),
+-                              OFFSETOF(NtCurrentTeb()->WOW32Reserved) - argsize
++	    *arg = MAKESEGPTR(SELECTOROF(NtCurrentTeb()->SystemReserved1[0]),
++                              OFFSETOF(NtCurrentTeb()->SystemReserved1[0]) - argsize
+                               + (*(LPBYTE *)arg - oldstack));
+ 	}
+ 
+@@ -577,7 +577,7 @@ void WINAPI __regs_FT_Thunk( CONTEXT *context )
+     context->Ecx = context16.Ecx;
+ 
+     context->Esp +=   LOWORD(context16.Esp) -
+-                        ( OFFSETOF(NtCurrentTeb()->WOW32Reserved) - argsize );
++                        ( OFFSETOF(NtCurrentTeb()->SystemReserved1[0]) - argsize );
+ 
+     /* Copy modified buffers back to 32-bit stack */
+     memcpy( oldstack, newstack, argsize );
+@@ -712,7 +712,7 @@ void WINAPI __regs_Common32ThkLS( CONTEXT *context )
+     context16.Edi   = LOWORD(context->Ecx);
+     context16.SegCs = HIWORD(context->Eax);
+     context16.Eip   = LOWORD(context->Eax);
+-    context16.Ebp   = OFFSETOF(NtCurrentTeb()->WOW32Reserved) + FIELD_OFFSET(STACK16FRAME,bp);
++    context16.Ebp   = OFFSETOF(NtCurrentTeb()->SystemReserved1[0]) + FIELD_OFFSET(STACK16FRAME,bp);
+ 
+     argsize = HIWORD(context->Edx) * 4;
+ 
+@@ -768,7 +768,7 @@ void WINAPI __regs_OT_32ThkLSF( CONTEXT *context )
+ 
+     context16.SegCs = HIWORD(context->Edx);
+     context16.Eip   = LOWORD(context->Edx);
+-    context16.Ebp   = OFFSETOF(NtCurrentTeb()->WOW32Reserved) + FIELD_OFFSET(STACK16FRAME,bp);
++    context16.Ebp   = OFFSETOF(NtCurrentTeb()->SystemReserved1[0]) + FIELD_OFFSET(STACK16FRAME,bp);
+ 
+     argsize = 2 * *(WORD *)context->Esp + 2;
+ 
+@@ -781,7 +781,7 @@ void WINAPI __regs_OT_32ThkLSF( CONTEXT *context )
+             (LPBYTE)CURRENT_STACK16 - argsize, argsize );
+ 
+     context->Esp +=   LOWORD(context16.Esp) -
+-                        ( OFFSETOF(NtCurrentTeb()->WOW32Reserved) - argsize );
++                        ( OFFSETOF(NtCurrentTeb()->SystemReserved1[0]) - argsize );
+ }
+ DEFINE_REGS_ENTRYPOINT( OT_32ThkLSF )
+ 
+@@ -1233,26 +1233,26 @@ void WINAPI __regs_K32Thk1632Prolog( CONTEXT *context )
+       DWORD argSize = context->Ebp - context->Esp;
+       char *stack16 = (char *)context->Esp - 4;
+       STACK16FRAME *frame16 = (STACK16FRAME *)stack16 - 1;
+-      STACK32FRAME *frame32 = NtCurrentTeb()->WOW32Reserved;
++      STACK32FRAME *frame32 = NtCurrentTeb()->SystemReserved1[0];
+       char *stack32 = (char *)frame32 - argSize;
+       WORD  stackSel  = SELECTOROF(frame32->frame16);
+       DWORD stackBase = GetSelectorBase(stackSel);
+ 
+       TRACE("before SYSTHUNK hack: EBP: %08x ESP: %08x cur_stack: %p\n",
+-            context->Ebp, context->Esp, NtCurrentTeb()->WOW32Reserved);
++            context->Ebp, context->Esp, NtCurrentTeb()->SystemReserved1[0]);
+ 
+       memset(frame16, '\0', sizeof(STACK16FRAME));
+       frame16->frame32 = frame32;
+       frame16->ebp = context->Ebp;
+ 
+       memcpy(stack32, stack16, argSize);
+-      NtCurrentTeb()->WOW32Reserved = (void *)MAKESEGPTR(stackSel, (DWORD)frame16 - stackBase);
++      NtCurrentTeb()->SystemReserved1[0] = (void *)MAKESEGPTR(stackSel, (DWORD)frame16 - stackBase);
+ 
+       context->Esp = (DWORD)stack32 + 4;
+       context->Ebp = context->Esp + argSize;
+ 
+       TRACE("after  SYSTHUNK hack: EBP: %08x ESP: %08x cur_stack: %p\n",
+-            context->Ebp, context->Esp, NtCurrentTeb()->WOW32Reserved);
++            context->Ebp, context->Esp, NtCurrentTeb()->SystemReserved1[0]);
+    }
+ 
+     /* entry_point is never used again once the entry point has
+@@ -1275,7 +1275,7 @@ void WINAPI __regs_K32Thk1632Epilog( CONTEXT *context )
+    if (   code[5] == 0xFF && code[6] == 0x55 && code[7] == 0xFC
+        && code[13] == 0x66 && code[14] == 0xCB)
+    {
+-      STACK16FRAME *frame16 = MapSL((SEGPTR)NtCurrentTeb()->WOW32Reserved);
++      STACK16FRAME *frame16 = MapSL((SEGPTR)NtCurrentTeb()->SystemReserved1[0]);
+       char *stack16 = (char *)(frame16 + 1);
+       DWORD argSize = frame16->ebp - (DWORD)stack16;
+       char *stack32 = (char *)frame16->frame32 - argSize;
+@@ -1283,15 +1283,15 @@ void WINAPI __regs_K32Thk1632Epilog( CONTEXT *context )
+       DWORD nArgsPopped = context->Esp - (DWORD)stack32;
+ 
+       TRACE("before SYSTHUNK hack: EBP: %08x ESP: %08x cur_stack: %p\n",
+-            context->Ebp, context->Esp, NtCurrentTeb()->WOW32Reserved);
++            context->Ebp, context->Esp, NtCurrentTeb()->SystemReserved1[0]);
+ 
+-      NtCurrentTeb()->WOW32Reserved = frame16->frame32;
++      NtCurrentTeb()->SystemReserved1[0] = frame16->frame32;
+ 
+       context->Esp = (DWORD)stack16 + nArgsPopped;
+       context->Ebp = frame16->ebp;
+ 
+       TRACE("after  SYSTHUNK hack: EBP: %08x ESP: %08x cur_stack: %p\n",
+-            context->Ebp, context->Esp, NtCurrentTeb()->WOW32Reserved);
++            context->Ebp, context->Esp, NtCurrentTeb()->SystemReserved1[0]);
+    }
+ }
+ DEFINE_REGS_ENTRYPOINT( K32Thk1632Epilog )
+@@ -2302,7 +2302,7 @@ void WINAPI Throw16( LPCATCHBUF lpbuf, INT16 retval, CONTEXT *context )
+     frame32 = pFrame->frame32;
+     while (frame32 && frame32->frame16)
+     {
+-        if (OFFSETOF(frame32->frame16) < OFFSETOF(NtCurrentTeb()->WOW32Reserved))
++        if (OFFSETOF(frame32->frame16) < OFFSETOF(NtCurrentTeb()->SystemReserved1[0]))
+             break;  /* Something strange is going on */
+         if (OFFSETOF(frame32->frame16) > lpbuf[2])
+         {
+diff --git a/dlls/krnl386.exe16/wowthunk.c b/dlls/krnl386.exe16/wowthunk.c
+index 2dddbf93289..3a4b104a673 100644
+--- a/dlls/krnl386.exe16/wowthunk.c
++++ b/dlls/krnl386.exe16/wowthunk.c
+@@ -127,7 +127,7 @@ static DWORD call16_handler( EXCEPTION_RECORD *record, EXCEPTION_REGISTRATION_RE
+     {
+         /* unwinding: restore the stack pointer in the TEB, and leave the Win16 mutex */
+         STACK32FRAME *frame32 = CONTAINING_RECORD(frame, STACK32FRAME, frame);
+-        NtCurrentTeb()->WOW32Reserved = (void *)frame32->frame16;
++        NtCurrentTeb()->SystemReserved1[0] = (void *)frame32->frame16;
+         _LeaveWin16Lock();
+     }
+     else if (record->ExceptionCode == EXCEPTION_ACCESS_VIOLATION ||
+@@ -412,8 +412,8 @@ BOOL WINAPI K32WOWCallback16Ex( DWORD vpfn16, DWORD dwFlags,
+             TRACE_(relay)( "\1CallTo16(func=%04x:%04x", context->SegCs, LOWORD(context->Eip) );
+             while (count) TRACE_(relay)( ",%04x", wstack[--count] );
+             TRACE_(relay)( ") ss:sp=%04x:%04x ax=%04x bx=%04x cx=%04x dx=%04x si=%04x di=%04x bp=%04x ds=%04x es=%04x\n",
+-                           SELECTOROF(NtCurrentTeb()->WOW32Reserved),
+-                           OFFSETOF(NtCurrentTeb()->WOW32Reserved),
++                           SELECTOROF(NtCurrentTeb()->SystemReserved1[0]),
++                           OFFSETOF(NtCurrentTeb()->SystemReserved1[0]),
+                            (WORD)context->Eax, (WORD)context->Ebx, (WORD)context->Ecx,
+                            (WORD)context->Edx, (WORD)context->Esi, (WORD)context->Edi,
+                            (WORD)context->Ebp, (WORD)context->SegDs, (WORD)context->SegEs );
+@@ -443,8 +443,8 @@ BOOL WINAPI K32WOWCallback16Ex( DWORD vpfn16, DWORD dwFlags,
+         if (TRACE_ON(relay))
+         {
+             TRACE_(relay)( "\1RetFrom16() ss:sp=%04x:%04x ax=%04x bx=%04x cx=%04x dx=%04x bp=%04x sp=%04x\n",
+-                           SELECTOROF(NtCurrentTeb()->WOW32Reserved),
+-                           OFFSETOF(NtCurrentTeb()->WOW32Reserved),
++                           SELECTOROF(NtCurrentTeb()->SystemReserved1[0]),
++                           OFFSETOF(NtCurrentTeb()->SystemReserved1[0]),
+                            (WORD)context->Eax, (WORD)context->Ebx, (WORD)context->Ecx,
+                            (WORD)context->Edx, (WORD)context->Ebp, (WORD)context->Esp );
+             SYSLEVEL_CheckNotLevel( 2 );
+@@ -460,10 +460,10 @@ BOOL WINAPI K32WOWCallback16Ex( DWORD vpfn16, DWORD dwFlags,
+             WORD * wstack = (WORD *)stack;
+ 
+             TRACE_(relay)( "\1CallTo16(func=%04x:%04x,ds=%04x",
+-                           HIWORD(vpfn16), LOWORD(vpfn16), SELECTOROF(NtCurrentTeb()->WOW32Reserved) );
++                           HIWORD(vpfn16), LOWORD(vpfn16), SELECTOROF(NtCurrentTeb()->SystemReserved1[0]) );
+             while (count) TRACE_(relay)( ",%04x", wstack[--count] );
+-            TRACE_(relay)( ") ss:sp=%04x:%04x\n", SELECTOROF(NtCurrentTeb()->WOW32Reserved),
+-                           OFFSETOF(NtCurrentTeb()->WOW32Reserved) );
++            TRACE_(relay)( ") ss:sp=%04x:%04x\n", SELECTOROF(NtCurrentTeb()->SystemReserved1[0]),
++                           OFFSETOF(NtCurrentTeb()->SystemReserved1[0]) );
+             SYSLEVEL_CheckNotLevel( 2 );
+         }
+ 
+@@ -486,8 +486,8 @@ BOOL WINAPI K32WOWCallback16Ex( DWORD vpfn16, DWORD dwFlags,
+         if (TRACE_ON(relay))
+         {
+             TRACE_(relay)( "\1RetFrom16() ss:sp=%04x:%04x retval=%08x\n",
+-                           SELECTOROF(NtCurrentTeb()->WOW32Reserved),
+-                           OFFSETOF(NtCurrentTeb()->WOW32Reserved), ret );
++                           SELECTOROF(NtCurrentTeb()->SystemReserved1[0]),
++                           OFFSETOF(NtCurrentTeb()->SystemReserved1[0]), ret );
+             SYSLEVEL_CheckNotLevel( 2 );
+         }
+     }
+diff --git a/dlls/ntdll/signal_i386.c b/dlls/ntdll/signal_i386.c
+index e905ed0af17..8a976f7745d 100644
+--- a/dlls/ntdll/signal_i386.c
++++ b/dlls/ntdll/signal_i386.c
+@@ -912,7 +912,7 @@ static inline void *init_handler( const ucontext_t *sigcontext, WORD *fs, WORD *
+          * SS is still non-system segment. This is why both CS and SS
+          * are checked.
+          */
+-        return teb->WOW32Reserved;
++        return teb->SystemReserved1[0];
+     }
+     return (void *)(ESP_sig(sigcontext) & ~3);
+ }
+diff --git a/dlls/system.drv16/system.c b/dlls/system.drv16/system.c
+index b6fd51c05f0..695ad7b6003 100644
+--- a/dlls/system.drv16/system.c
++++ b/dlls/system.drv16/system.c
+@@ -70,7 +70,7 @@ static void CALLBACK SYSTEM_TimerTick( LPVOID arg, DWORD low, DWORD high )
+             memset( &context, 0, sizeof(context) );
+             context.SegCs = SELECTOROF( proc );
+             context.Eip   = OFFSETOF( proc );
+-            context.Ebp   = OFFSETOF(NtCurrentTeb()->WOW32Reserved) + FIELD_OFFSET(STACK16FRAME, bp);
++            context.Ebp   = OFFSETOF(NtCurrentTeb()->SystemReserved1[0]) + FIELD_OFFSET(STACK16FRAME, bp);
+             context.Eax   = i + 1;
+ 
+             WOWCallback16Ex( 0, WCB16_REGS, 0, NULL, (DWORD *)&context );
+diff --git a/dlls/toolhelp.dll16/toolhelp.c b/dlls/toolhelp.dll16/toolhelp.c
+index 578d1ae7fab..1077f0b0367 100644
+--- a/dlls/toolhelp.dll16/toolhelp.c
++++ b/dlls/toolhelp.dll16/toolhelp.c
+@@ -491,8 +491,8 @@ BOOL16 WINAPI TaskNext16( TASKENTRY *lpte )
+     lpte->hTaskParent   = pTask->hParent;
+     lpte->hInst         = pTask->hInstance;
+     lpte->hModule       = pTask->hModule;
+-    lpte->wSS           = SELECTOROF( pTask->teb->WOW32Reserved );
+-    lpte->wSP           = OFFSETOF( pTask->teb->WOW32Reserved );
++    lpte->wSS           = SELECTOROF( pTask->teb->SystemReserved1[0] );
++    lpte->wSP           = OFFSETOF( pTask->teb->SystemReserved1[0] );
+     lpte->wStackTop     = pInstData->stacktop;
+     lpte->wStackMinimum = pInstData->stackmin;
+     lpte->wStackBottom  = pInstData->stackbottom;
+@@ -718,7 +718,7 @@ BOOL16 WINAPI TimerCount16( TIMERINFO *pTimerInfo )
+  */
+ BOOL16 WINAPI SystemHeapInfo16( SYSHEAPINFO *pHeapInfo )
+ {
+-    STACK16FRAME* stack16 = MapSL((SEGPTR)NtCurrentTeb()->WOW32Reserved);
++    STACK16FRAME* stack16 = MapSL((SEGPTR)NtCurrentTeb()->SystemReserved1[0]);
+     HANDLE16 oldDS = stack16->ds;
+     WORD user = LoadLibrary16( "USER.EXE" );
+     WORD gdi = LoadLibrary16( "GDI.EXE" );
+diff --git a/dlls/user.exe16/message.c b/dlls/user.exe16/message.c
+index e3ca3fd779d..fa9388ceaa1 100644
+--- a/dlls/user.exe16/message.c
++++ b/dlls/user.exe16/message.c
+@@ -240,11 +240,11 @@ static LRESULT call_window_proc16( HWND16 hwnd, UINT16 msg, WPARAM16 wParam, LPA
+     /* Window procedures want ax = hInstance, ds = es = ss */
+ 
+     memset(&context, 0, sizeof(context));
+-    context.SegDs = context.SegEs = SELECTOROF(NtCurrentTeb()->WOW32Reserved);
++    context.SegDs = context.SegEs = SELECTOROF(NtCurrentTeb()->SystemReserved1[0]);
+     if (!(context.Eax = GetWindowWord( HWND_32(hwnd), GWLP_HINSTANCE ))) context.Eax = context.SegDs;
+     context.SegCs = SELECTOROF(func);
+     context.Eip   = OFFSETOF(func);
+-    context.Ebp   = OFFSETOF(NtCurrentTeb()->WOW32Reserved) + FIELD_OFFSET(STACK16FRAME, bp);
++    context.Ebp   = OFFSETOF(NtCurrentTeb()->SystemReserved1[0]) + FIELD_OFFSET(STACK16FRAME, bp);
+ 
+     if (lParam)
+     {
+@@ -267,7 +267,7 @@ static LRESULT call_window_proc16( HWND16 hwnd, UINT16 msg, WPARAM16 wParam, LPA
+         if (size)
+         {
+             memcpy( &args.u, MapSL(lParam), size );
+-            lParam = PtrToUlong(NtCurrentTeb()->WOW32Reserved) - size;
++            lParam = PtrToUlong(NtCurrentTeb()->SystemReserved1[0]) - size;
+         }
+     }
+ 
+@@ -2092,7 +2092,7 @@ static LRESULT combo_proc16( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam,
+ 
+ static void edit_lock_buffer( HWND hwnd )
+ {
+-    STACK16FRAME* stack16 = MapSL(PtrToUlong(NtCurrentTeb()->WOW32Reserved));
++    STACK16FRAME* stack16 = MapSL(PtrToUlong(NtCurrentTeb()->SystemReserved1[0]));
+     HLOCAL16 hloc16 = GetWindowWord( hwnd, GWW_HANDLE16 );
+     HANDLE16 oldDS;
+     HLOCAL hloc32;
+@@ -2118,7 +2118,7 @@ static void edit_lock_buffer( HWND hwnd )
+ 
+ static void edit_unlock_buffer( HWND hwnd )
+ {
+-    STACK16FRAME* stack16 = MapSL(PtrToUlong(NtCurrentTeb()->WOW32Reserved));
++    STACK16FRAME* stack16 = MapSL(PtrToUlong(NtCurrentTeb()->SystemReserved1[0]));
+     HLOCAL16 hloc16 = GetWindowWord( hwnd, GWW_HANDLE16 );
+     HANDLE16 oldDS;
+     HLOCAL hloc32;
+@@ -2155,7 +2155,7 @@ static HLOCAL16 edit_get_handle( HWND hwnd )
+     if (!(hloc = (HLOCAL)wow_handlers32.edit_proc( hwnd, EM_GETHANDLE, 0, 0, FALSE ))) return 0;
+     alloc_size = LocalSize( hloc );
+ 
+-    stack16 = MapSL(PtrToUlong(NtCurrentTeb()->WOW32Reserved));
++    stack16 = MapSL(PtrToUlong(NtCurrentTeb()->SystemReserved1[0]));
+     oldDS = stack16->ds;
+     stack16->ds = GetWindowLongPtrW( hwnd, GWLP_HINSTANCE );
+ 
+@@ -2193,7 +2193,7 @@ done:
+ 
+ static void edit_set_handle( HWND hwnd, HLOCAL16 hloc16 )
+ {
+-    STACK16FRAME* stack16 = MapSL(PtrToUlong(NtCurrentTeb()->WOW32Reserved));
++    STACK16FRAME* stack16 = MapSL(PtrToUlong(NtCurrentTeb()->SystemReserved1[0]));
+     HINSTANCE16 hInstance = GetWindowLongPtrW( hwnd, GWLP_HINSTANCE );
+     HANDLE16 oldDS = stack16->ds;
+     HLOCAL hloc32;
+@@ -2223,7 +2223,7 @@ static void edit_destroy_handle( HWND hwnd )
+     HLOCAL16 hloc16 = GetWindowWord( hwnd, GWW_HANDLE16 );
+     if (hloc16)
+     {
+-        STACK16FRAME* stack16 = MapSL(PtrToUlong(NtCurrentTeb()->WOW32Reserved));
++        STACK16FRAME* stack16 = MapSL(PtrToUlong(NtCurrentTeb()->SystemReserved1[0]));
+         HANDLE16 oldDS = stack16->ds;
+ 
+         stack16->ds = GetWindowLongPtrW( hwnd, GWLP_HINSTANCE );
+diff --git a/dlls/user.exe16/user.c b/dlls/user.exe16/user.c
+index 27b92793836..deec596f766 100644
+--- a/dlls/user.exe16/user.c
++++ b/dlls/user.exe16/user.c
+@@ -1394,7 +1394,7 @@ DWORD WINAPI GetTabbedTextExtent16( HDC16 hdc, LPCSTR lpstr, INT16 count,
+  */
+ DWORD WINAPI UserSeeUserDo16(WORD wReqType, WORD wParam1, WORD wParam2, WORD wParam3)
+ {
+-    STACK16FRAME* stack16 = MapSL((SEGPTR)NtCurrentTeb()->WOW32Reserved);
++    STACK16FRAME* stack16 = MapSL((SEGPTR)NtCurrentTeb()->SystemReserved1[0]);
+     HANDLE16 oldDS = stack16->ds;
+     DWORD ret = (DWORD)-1;
+ 
+@@ -1787,7 +1787,7 @@ UINT16 WINAPI RealizePalette16( HDC16 hdc )
+  */
+ WORD WINAPI GetFreeSystemResources16( WORD resType )
+ {
+-    STACK16FRAME* stack16 = MapSL((SEGPTR)NtCurrentTeb()->WOW32Reserved);
++    STACK16FRAME* stack16 = MapSL((SEGPTR)NtCurrentTeb()->SystemReserved1[0]);
+     HANDLE16 oldDS = stack16->ds;
+     int userPercent, gdiPercent;
+ 
+diff --git a/dlls/user.exe16/window.c b/dlls/user.exe16/window.c
+index bf86719325b..1f53bdc9540 100644
+--- a/dlls/user.exe16/window.c
++++ b/dlls/user.exe16/window.c
+@@ -456,7 +456,7 @@ HWND16 WINAPI GetParent16( HWND16 hwnd )
+  */
+ BOOL16 WINAPI IsWindow16( HWND16 hwnd )
+ {
+-    STACK16FRAME *frame = MapSL( (SEGPTR)NtCurrentTeb()->WOW32Reserved );
++    STACK16FRAME *frame = MapSL( (SEGPTR)NtCurrentTeb()->SystemReserved1[0] );
+     frame->es = USER_HeapSel;
+     /* don't use WIN_Handle32 here, we don't care about the full handle */
+     return IsWindow( HWND_32(hwnd) );
+diff --git a/include/winternl.h b/include/winternl.h
+index dd63300d915..0aa0ac311c3 100644
+--- a/include/winternl.h
++++ b/include/winternl.h
+@@ -362,7 +362,7 @@ typedef struct _TEB
+     PVOID                        WOW32Reserved;                     /* 0c0/0100 */
+     ULONG                        CurrentLocale;                     /* 0c4/0108 */
+     ULONG                        FpSoftwareStatusRegister;          /* 0c8/010c */
+-    PVOID                        SystemReserved1[54];               /* 0cc/0110 used for kernel32 private data in Wine */
++    PVOID                        SystemReserved1[54];               /* 0cc/0110 used for krnl386.exe16 private data in Wine */
+     LONG                         ExceptionCode;                     /* 1a4/02c0 */
+     ACTIVATION_CONTEXT_STACK     ActivationContextStack;            /* 1a8/02c8 */
+     BYTE                         SpareBytes1[24];                   /* 1bc/02e8 */
+diff --git a/tools/winebuild/relay.c b/tools/winebuild/relay.c
+index 29d0a74c833..01bb97e02b4 100644
+--- a/tools/winebuild/relay.c
++++ b/tools/winebuild/relay.c
+@@ -31,7 +31,7 @@
+ #include "build.h"
+ 
+ /* offset of the stack pointer relative to %fs:(0) */
+-#define STACKOFFSET 0xc0  /* FIELD_OFFSET(TEB,WOW32Reserved) */
++#define STACKOFFSET 0xcc  /* FIELD_OFFSET(TEB,SystemReserved1[0]) */
+ 
+ /* fix this if the x86_thread_data structure is changed */
+ #define GS_OFFSET  0x1d8  /* FIELD_OFFSET(TEB,SystemReserved2) + FIELD_OFFSET(struct x86_thread_data,gs) */
+-- 
+2.26.2
+
diff --git a/patches/winebuild-Fake_Dlls/0003-winebuild-Generate-syscall-thunks-for-ntdll-exports.patch b/patches/winebuild-Fake_Dlls/0003-winebuild-Generate-syscall-thunks-for-ntdll-exports.patch
new file mode 100644
index 00000000..51b89b4e
--- /dev/null
+++ b/patches/winebuild-Fake_Dlls/0003-winebuild-Generate-syscall-thunks-for-ntdll-exports.patch
@@ -0,0 +1,464 @@
+From 3b9456b9e0bc870281df2144b67d42112baad4bd Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
+Date: Thu, 11 May 2017 05:32:55 +0200
+Subject: [PATCH] winebuild: Generate syscall thunks for ntdll exports.
+
+Based on a patch by Erich E. Hoover.
+---
+ dlls/ntdll/signal_i386.c     |   4 +-
+ dlls/ntdll/tests/exception.c |   2 +
+ dlls/ntdll/thread.c          |   4 ++
+ include/winternl.h           |   2 +-
+ tools/winebuild/build.h      |   7 +++
+ tools/winebuild/import.c     |  10 ++--
+ tools/winebuild/parser.c     |  59 ++++++++++++++++++++
+ tools/winebuild/spec16.c     |  22 +-------
+ tools/winebuild/spec32.c     | 104 +++++++++++++++++++++++++++++++++++
+ tools/winebuild/utils.c      |  21 +++++++
+ 9 files changed, 207 insertions(+), 27 deletions(-)
+
+diff --git a/dlls/ntdll/signal_i386.c b/dlls/ntdll/signal_i386.c
+index 5353ab4df2ce..527ba01672e1 100644
+--- a/dlls/ntdll/signal_i386.c
++++ b/dlls/ntdll/signal_i386.c
+@@ -476,6 +476,9 @@ static ULONG first_ldt_entry = 32;
+ 
+ static wine_signal_handler handlers[256];
+ 
++extern void DECLSPEC_NORETURN __wine_syscall_dispatcher( void );
++extern NTSTATUS WINAPI __syscall_NtGetContextThread( HANDLE handle, CONTEXT *context );
++
+ enum i386_trap_code
+ {
+     TRAP_x86_UNKNOWN    = -1,  /* Unknown fault (TRAP_sig not defined) */
+@@ -1514,7 +1517,7 @@ NTSTATUS CDECL DECLSPEC_HIDDEN __regs_NtGetContextThread( DWORD edi, DWORD esi,
+         {
+             context->Ebp    = ebp;
+             context->Esp    = (DWORD)&retaddr;
+-            context->Eip    = *(&edi - 1);
++            context->Eip    = (DWORD)__syscall_NtGetContextThread + 18;
+             context->SegCs  = get_cs();
+             context->SegSs  = get_ds();
+             context->EFlags = eflags;
+@@ -2561,6 +2564,8 @@ NTSTATUS signal_alloc_thread( TEB *teb )
+     }
+     else thread_data->fs = gdt_fs_sel;
+ 
++    teb->WOW32Reserved = __wine_syscall_dispatcher;
++
+     return STATUS_SUCCESS;
+ }
+ 
+diff --git a/dlls/ntdll/tests/exception.c b/dlls/ntdll/tests/exception.c
+index a5e6faa461a3..51938bf84cc1 100644
+--- a/dlls/ntdll/tests/exception.c
++++ b/dlls/ntdll/tests/exception.c
+@@ -1643,6 +1643,8 @@ static void test_thread_context(void)
+     ok( (char *)context.Eip >= (char *)pNtGetContextThread - 0x40000 &&
+         (char *)context.Eip <= (char *)pNtGetContextThread + 0x40000,
+         "wrong Eip %08x/%08x\n", context.Eip, (DWORD)pNtGetContextThread );
++    ok( *(WORD *)context.Eip == 0xc483 || *(WORD *)context.Eip == 0x08c2 || *(WORD *)context.Eip == 0x8dc3,
++        "expected 0xc483 or 0x08c2 or 0x8dc3, got %04x\n", *(WORD *)context.Eip );
+     /* segment registers clear the high word */
+     ok( context.SegCs == LOWORD(expect.SegCs), "wrong SegCs %08x/%08x\n", context.SegCs, expect.SegCs );
+     ok( context.SegDs == LOWORD(expect.SegDs), "wrong SegDs %08x/%08x\n", context.SegDs, expect.SegDs );
+diff --git a/include/winternl.h b/include/winternl.h
+index 0f808d71dd33..d641ed1436ad 100644
+--- a/include/winternl.h
++++ b/include/winternl.h
+@@ -359,7 +359,7 @@ typedef struct _TEB
+     PVOID                        CsrClientThread;                   /* 03c/0070 */
+     PVOID                        Win32ThreadInfo;                   /* 040/0078 */
+     ULONG                        Win32ClientInfo[31];               /* 044/0080 used for user32 private data in Wine */
+-    PVOID                        WOW32Reserved;                     /* 0c0/0100 */
++    PVOID                        WOW32Reserved;                     /* 0c0/0100 used for ntdll syscall thunks */
+     ULONG                        CurrentLocale;                     /* 0c4/0108 */
+     ULONG                        FpSoftwareStatusRegister;          /* 0c8/010c */
+     PVOID                        SystemReserved1[54];               /* 0cc/0110 used for krnl386.exe16 private data in Wine */
+diff --git a/tools/winebuild/build.h b/tools/winebuild/build.h
+index c162888a035..55d5b0b9dc2 100644
+--- a/tools/winebuild/build.h
++++ b/tools/winebuild/build.h
+@@ -105,6 +105,7 @@ typedef struct
+     int         flags;
+     char       *name;         /* public name of this function */
+     char       *link_name;    /* name of the C symbol to link to */
++    char       *impl_name;    /* name of the C symbol of the real implementation (thunks only) */
+     char       *export_name;  /* name exported under for noname exports */
+     union
+     {
+@@ -131,6 +132,7 @@ typedef struct
+     int              alloc_entry_points; /* number of allocated entry points */
+     int              nb_names;           /* number of entry points with names */
+     unsigned int     nb_resources;       /* number of resources */
++    int              nb_syscalls;        /* number of syscalls */
+     int              characteristics;    /* characteristics for the PE header */
+     int              dll_characteristics;/* DLL characteristics for the PE header */
+     int              subsystem;          /* subsystem id */
+@@ -140,6 +142,7 @@ typedef struct
+     ORDDEF         **names;              /* array of entry point names (points into entry_points) */
+     ORDDEF         **ordinals;           /* array of dll ordinals (points into entry_points) */
+     struct resource *resources;          /* array of dll resources (format differs between Win16/Win32) */
++    ORDDEF         **syscalls;           /* array of syscalls (points into entry_points) */
+ } DLLSPEC;
+ 
+ enum target_cpu
+@@ -182,8 +185,10 @@ struct strarray
+ #define FLAG_FORWARD   0x1000  /* function is a forwarded name */
+ #define FLAG_EXT_LINK  0x2000  /* function links to an external symbol */
+ #define FLAG_EXPORT32  0x4000  /* 32-bit export in 16-bit spec file */
++#define FLAG_SYSCALL   0x8000  /* function should be called through a syscall thunk */
+ 
+ #define FLAG_CPU(cpu)  (0x10000 << (cpu))
++
+ #define FLAG_CPU_MASK  (FLAG_CPU(CPU_LAST + 1) - FLAG_CPU(0))
+ #define FLAG_CPU_WIN64 (FLAG_CPU(CPU_x86_64) | FLAG_CPU(CPU_ARM64))
+ #define FLAG_CPU_WIN32 (FLAG_CPU_MASK & ~FLAG_CPU_WIN64)
+@@ -327,6 +332,8 @@ extern void add_16bit_exports( DLLSPEC *spec32, DLLSPEC *spec16 );
+ extern int parse_spec_file( FILE *file, DLLSPEC *spec );
+ extern int parse_def_file( FILE *file, DLLSPEC *spec );
+ 
++extern int sort_func_list( ORDDEF **list, int count, int (*compare)(const void *, const void *) );
++
+ /* buffer management */
+ 
+ extern int byte_swapped;
+diff --git a/tools/winebuild/import.c b/tools/winebuild/import.c
+index 04ab433dd65..0c6bafed8e5 100644
+--- a/tools/winebuild/import.c
++++ b/tools/winebuild/import.c
+@@ -531,6 +531,7 @@ static void check_undefined_forwards( DLLSPEC *spec )
+ /* flag the dll exports that link to an undefined symbol */
+ static void check_undefined_exports( DLLSPEC *spec )
+ {
++    const char *name;
+     int i;
+ 
+     for (i = 0; i < spec->nb_entry_points; i++)
+@@ -538,7 +539,8 @@ static void check_undefined_exports( DLLSPEC *spec )
+         ORDDEF *odp = &spec->entry_points[i];
+         if (odp->type == TYPE_STUB || odp->type == TYPE_ABS || odp->type == TYPE_VARIABLE) continue;
+         if (odp->flags & FLAG_FORWARD) continue;
+-        if (find_name( odp->link_name, &undef_symbols ))
++        name = odp->impl_name ? odp->impl_name : odp->link_name;
++        if (find_name( name, &undef_symbols ))
+         {
+             switch(odp->type)
+             {
+@@ -549,14 +551,14 @@ static void check_undefined_exports( DLLSPEC *spec )
+                 if (link_ext_symbols)
+                 {
+                     odp->flags |= FLAG_EXT_LINK;
+-                    strarray_add( &ext_link_imports, odp->link_name, NULL );
++                    strarray_add( &ext_link_imports, name, NULL );
+                 }
+                 else error( "%s:%d: function '%s' not defined\n",
+-                            spec->src_name, odp->lineno, odp->link_name );
++                            spec->src_name, odp->lineno, name );
+                 break;
+             default:
+                 error( "%s:%d: external symbol '%s' is not a function\n",
+-                       spec->src_name, odp->lineno, odp->link_name );
++                       spec->src_name, odp->lineno, name );
+                 break;
+             }
+         }
+diff --git a/tools/winebuild/parser.c b/tools/winebuild/parser.c
+index 0f2b9c1e10a..74216f8bb6e 100644
+--- a/tools/winebuild/parser.c
++++ b/tools/winebuild/parser.c
+@@ -543,6 +543,24 @@ static const char *parse_spec_flags( DLLSPEC *spec, ORDDEF *odp )
+ }
+ 
+ 
++static int needs_syscall( ORDDEF *odp, DLLSPEC *spec )
++{
++    if (target_cpu != CPU_x86)
++        return 0;
++    if (odp->flags & (FLAG_FORWARD | FLAG_REGISTER))
++        return 0;
++    if (odp->type != TYPE_STDCALL)
++        return 0;
++    if (!spec->dll_name || strcmp(spec->dll_name, "ntdll"))
++        return 0;
++    if (!odp->name)
++        return 0;
++    if (strncmp(odp->name, "Nt", 2) && strncmp(odp->name, "Zw", 2))
++        return 0;
++    return 1;
++}
++
++
+ /*******************************************************************
+  *         parse_spec_ordinal
+  *
+@@ -618,6 +636,14 @@ static int parse_spec_ordinal( int ordinal, DLLSPEC *spec )
+         assert( 0 );
+     }
+ 
++    if (needs_syscall( odp, spec ))
++    {
++        char *link_name = strmake( "__syscall_%s", odp->link_name );
++        odp->impl_name = odp->link_name;
++        odp->link_name = link_name;
++        odp->flags |= FLAG_SYSCALL;
++    }
++
+     if ((odp->flags & FLAG_CPU_MASK) && !(odp->flags & FLAG_CPU(target_cpu)))
+     {
+         /* ignore this entry point */
+@@ -815,6 +841,37 @@ static void assign_ordinals( DLLSPEC *spec )
+ }
+ 
+ 
++static int link_name_compare( const void *e1, const void *e2 )
++{
++    const ORDDEF *odp1 = *(const ORDDEF * const *)e1;
++    const ORDDEF *odp2 = *(const ORDDEF * const *)e2;
++    return strcmp(odp1->link_name, odp2->link_name);
++}
++
++
++static void assign_syscalls( DLLSPEC *spec )
++{
++    int i;
++
++    spec->syscalls = xmalloc( (spec->limit - spec->base + 1) * sizeof(*spec->syscalls) );
++    spec->nb_syscalls = 0;
++
++    for (i = 0; i <= spec->limit; i++)
++    {
++        ORDDEF *odp = spec->ordinals[i];
++        if (!odp || !(odp->flags & FLAG_SYSCALL)) continue;
++        spec->syscalls[spec->nb_syscalls++] = odp;
++    }
++
++    spec->nb_syscalls = sort_func_list( spec->syscalls, spec->nb_syscalls, link_name_compare );
++    if (!spec->nb_syscalls)
++    {
++        free( spec->syscalls );
++        spec->syscalls = NULL;
++    }
++}
++
++
+ /*******************************************************************
+  *         add_16bit_exports
+  *
+@@ -916,6 +973,8 @@ int parse_spec_file( FILE *file, DLLSPEC *spec )
+     current_line = 0;  /* no longer parsing the input file */
+     assign_names( spec );
+     assign_ordinals( spec );
++    assign_syscalls( spec );
++
+     return !nb_errors;
+ }
+ 
+diff --git a/tools/winebuild/spec16.c b/tools/winebuild/spec16.c
+index a52c03aaa6a..15ef9a3f893 100644
+--- a/tools/winebuild/spec16.c
++++ b/tools/winebuild/spec16.c
+@@ -495,27 +495,6 @@ static int relay_type_compare( const void *e1, const void *e2 )
+ }
+ 
+ 
+-/*******************************************************************
+- *         sort_func_list
+- *
+- * Sort a list of functions, removing duplicates.
+- */
+-static int sort_func_list( ORDDEF **list, int count,
+-                           int (*compare)(const void *, const void *) )
+-{
+-    int i, j;
+-
+-    if (!count) return 0;
+-    qsort( list, count, sizeof(*list), compare );
+-
+-    for (i = j = 0; i < count; i++)
+-    {
+-        if (compare( &list[j], &list[i] )) list[++j] = list[i];
+-    }
+-    return j + 1;
+-}
+-
+-
+ /*******************************************************************
+  *         output_module16
+  *
+@@ -544,6 +523,7 @@ static void output_module16( DLLSPEC *spec )
+         entry_point->flags = FLAG_REGISTER;
+         entry_point->name = NULL;
+         entry_point->link_name = xstrdup( spec->init_func );
++        entry_point->impl_name = NULL;
+         entry_point->export_name = NULL;
+         entry_point->u.func.nb_args = 0;
+         assert( !spec->ordinals[0] );
+diff --git a/tools/winebuild/spec32.c b/tools/winebuild/spec32.c
+index b1e20e0484d..22dd399cb2b 100644
+--- a/tools/winebuild/spec32.c
++++ b/tools/winebuild/spec32.c
+@@ -374,6 +374,109 @@ static void output_relay_debug( DLLSPEC *spec )
+     }
+ }
+ 
++/*******************************************************************
++ *         output_syscall_thunks
++ *
++ * Output entry points for system call functions
++ */
++static void output_syscall_thunks( DLLSPEC *spec )
++{
++    int i;
++
++    if (!spec->nb_syscalls)
++        return;
++
++    output( "\n/* syscall thunks */\n\n" );
++    output( "\t.text\n" );
++
++    for (i = 0; i < spec->nb_syscalls; i++)
++    {
++        ORDDEF *odp = spec->syscalls[i];
++        const char *name = odp->link_name;
++
++        /* Chromium attempts to hook system call thunks. It expects them to
++         * have a very specific form, or it will fail. The below matches what
++         * Chromium expects from 64-bit Windows 8. */
++
++        output( "\t.balign 16, 0\n" );
++        output( "\t%s\n", func_declaration(name) );
++        output( "%s\n", asm_globl(name) );
++        output_cfi( ".cfi_startproc" );
++        output( "\t.byte 0xb8\n" );                               /* mov eax, SYSCALL */
++        output( "\t.long %d\n", i );
++        output( "\t.byte 0x64,0xff,0x15,0xc0,0x00,0x00,0x00\n" ); /* call dword ptr fs:[0C0h] */
++        output( "\t.byte 0xc2\n" );                               /* ret X */
++        output( "\t.short %d\n", get_args_size(odp) );
++        output_cfi( ".cfi_endproc" );
++        output_function_size( name );
++    }
++
++    for (i = 0; i < 0x20; i++)
++        output( "\t.byte 0\n" );
++
++    output( "\n/* syscall table */\n\n" );
++    output( "\t.data\n" );
++    output( "%s\n", asm_globl("__wine_syscall_table") );
++    for (i = 0; i < spec->nb_syscalls; i++)
++    {
++        ORDDEF *odp = spec->syscalls[i];
++        output ("\t%s %s\n", get_asm_ptr_keyword(), asm_name(odp->impl_name) );
++    }
++
++    output( "\n/* syscall argument stack size table */\n\n" );
++    output( "\t.data\n" );
++    output( "%s\n", asm_globl("__wine_syscall_stack_size") );
++    for (i = 0; i < spec->nb_syscalls; i++)
++    {
++        ORDDEF *odp = spec->syscalls[i];
++        output( "\t.byte %d\n", get_args_size(odp) );
++    }
++
++    output( "\n/* syscall dispatcher */\n\n" );
++    output( "\t.text\n" );
++    output( "\t.align %d\n", get_alignment(16) );
++    output( "\t%s\n", func_declaration("__wine_syscall_dispatcher") );
++    output( "%s\n", asm_globl("__wine_syscall_dispatcher") );
++    output_cfi( ".cfi_startproc" );
++    output( "\tpushl %%ebp\n" );
++    output_cfi( ".cfi_adjust_cfa_offset 4\n" );
++    output_cfi( ".cfi_rel_offset %%ebp,0\n" );
++    output( "\tmovl %%esp,%%ebp\n" );
++    output_cfi( ".cfi_def_cfa_register %%ebp\n" );
++    output( "\tpushl %%esi\n" );
++    output_cfi( ".cfi_rel_offset %%esi,-4\n" );
++    output( "\tpushl %%edi\n" );
++    output_cfi( ".cfi_rel_offset %%edi,-8\n" );
++    output( "\tleal 12(%%ebp),%%esi\n" );
++    if (UsePIC)
++    {
++        output( "\tcall 1f\n" );
++        output( "1:\tpopl %%edx\n" );
++        output( "movzbl (%s-1b)(%%edx,%%eax,1),%%ecx\n", asm_name("__wine_syscall_stack_size") );
++    }
++    else
++        output( "movzbl %s(%%eax),%%ecx\n", asm_name("__wine_syscall_stack_size") );
++
++    output( "\tsubl %%ecx,%%esp\n" );
++    output( "\tshrl $2,%%ecx\n" );
++    output( "\tmovl %%esp,%%edi\n" );
++    output( "\trep; movsl\n" );
++    if (UsePIC)
++        output( "\tcall *(%s-1b)(%%edx,%%eax,%d)\n", asm_name("__wine_syscall_table"), get_ptr_size() );
++    else
++        output( "\tcall *%s(,%%eax,%d)\n", asm_name("__wine_syscall_table"), get_ptr_size() );
++    output( "\tpop %%edi\n" );
++    output_cfi( ".cfi_same_value %%edi\n" );
++    output( "\tpop %%esi\n" );
++    output_cfi( ".cfi_same_value %%esi\n" );
++    output( "\tleave\n" );
++    output_cfi( ".cfi_def_cfa %%esp,4\n" );
++    output_cfi( ".cfi_same_value %%ebp\n" );
++    output( "\tret\n" );
++    output_cfi( ".cfi_endproc" );
++    output_function_size( "__wine_syscall_dispatcher" );
++}
++
+ /*******************************************************************
+  *         output_exports
+  *
+@@ -729,6 +832,7 @@ void output_spec32_file( DLLSPEC *spec )
+     open_output_file();
+     output_standard_file_header();
+     output_module( spec );
++    output_syscall_thunks( spec );
+     output_stubs( spec );
+     output_exports( spec );
+     output_imports( spec );
+diff --git a/tools/winebuild/utils.c b/tools/winebuild/utils.c
+index 2a1fc960926..07a579004ad 100644
+--- a/tools/winebuild/utils.c
++++ b/tools/winebuild/utils.c
+@@ -860,6 +860,7 @@ void free_dll_spec( DLLSPEC *spec )
+         free( odp->name );
+         free( odp->export_name );
+         free( odp->link_name );
++        free( odp->impl_name );
+     }
+     free( spec->file_name );
+     free( spec->dll_name );
+@@ -869,6 +870,7 @@ void free_dll_spec( DLLSPEC *spec )
+     free( spec->names );
+     free( spec->ordinals );
+     free( spec->resources );
++    free( spec->syscalls );
+     free( spec );
+ }
+ 
+@@ -1275,3 +1277,22 @@ const char *get_asm_string_section(void)
+     default:             return ".section .rodata";
+     }
+ }
++
++/*******************************************************************
++ *         sort_func_list
++ *
++ * Sort a list of functions, removing duplicates.
++ */
++int sort_func_list( ORDDEF **list, int count, int (*compare)(const void *, const void *) )
++{
++    int i, j;
++
++    if (!count) return 0;
++    qsort( list, count, sizeof(*list), compare );
++
++    for (i = j = 0; i < count; i++)
++    {
++        if (compare( &list[j], &list[i] )) list[++j] = list[i];
++    }
++    return j + 1;
++}
+-- 
+2.26.2
+
diff --git a/patches/winebuild-Fake_Dlls/0004-winebuild-Use-multipass-label-system-to-generate-fak.patch b/patches/winebuild-Fake_Dlls/0004-winebuild-Use-multipass-label-system-to-generate-fak.patch
new file mode 100644
index 00000000..6c3984f8
--- /dev/null
+++ b/patches/winebuild-Fake_Dlls/0004-winebuild-Use-multipass-label-system-to-generate-fak.patch
@@ -0,0 +1,430 @@
+From 15182deeb13e26abdb3067a77353354726ac82aa Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
+Date: Mon, 15 May 2017 02:05:49 +0200
+Subject: [PATCH] winebuild: Use multipass label system to generate fake dlls.
+
+---
+ tools/winebuild/build.h  |   6 ++
+ tools/winebuild/res32.c  |   1 -
+ tools/winebuild/spec32.c | 145 ++++++++++++++++++++++-----------------
+ tools/winebuild/utils.c  |  92 +++++++++++++++++++++++++
+ 4 files changed, 181 insertions(+), 63 deletions(-)
+
+diff --git a/tools/winebuild/build.h b/tools/winebuild/build.h
+index 6ee847f908c..210324406a9 100644
+--- a/tools/winebuild/build.h
++++ b/tools/winebuild/build.h
+@@ -343,6 +343,7 @@ extern size_t input_buffer_pos;
+ extern size_t input_buffer_size;
+ extern unsigned char *output_buffer;
+ extern size_t output_buffer_pos;
++extern size_t output_buffer_rva;
+ extern size_t output_buffer_size;
+ 
+ extern void init_input_buffer( const char *file );
+@@ -358,6 +359,11 @@ extern void put_dword( unsigned int val );
+ extern void put_qword( unsigned int val );
+ extern void put_pword( unsigned int val );
+ extern void align_output( unsigned int align );
++extern void align_output_rva( unsigned int file_align, unsigned int rva_align );
++extern size_t label_pos( const char *name );
++extern size_t label_rva( const char *name );
++extern size_t label_rva_align( const char *name );
++extern void put_label( const char *name );
+ 
+ /* global variables */
+ 
+diff --git a/tools/winebuild/res32.c b/tools/winebuild/res32.c
+index bd55bb2fa5c..d9329019f8a 100644
+--- a/tools/winebuild/res32.c
++++ b/tools/winebuild/res32.c
+@@ -539,7 +539,6 @@ void output_bin_resources( DLLSPEC *spec, unsigned int start_rva )
+     if (!spec->nb_resources) return;
+ 
+     tree = build_resource_tree( spec, &data_offset );
+-    init_output_buffer();
+ 
+     /* output the resource directories */
+ 
+diff --git a/tools/winebuild/spec32.c b/tools/winebuild/spec32.c
+index 22dd399cb2b..c38f1fe663c 100644
+--- a/tools/winebuild/spec32.c
++++ b/tools/winebuild/spec32.c
+@@ -844,11 +844,11 @@ void output_spec32_file( DLLSPEC *spec )
+ 
+ 
+ /*******************************************************************
+- *         output_fake_module
++ *         output_fake_module_pass
+  *
+- * Build a fake binary module from a spec file.
++ * Helper to create a fake binary module from a spec file.
+  */
+-void output_fake_module( DLLSPEC *spec )
++static void output_fake_module_pass( DLLSPEC *spec )
+ {
+     static const unsigned char dll_code_section[] = { 0x31, 0xc0,          /* xor %eax,%eax */
+                                                       0xc2, 0x0c, 0x00 };  /* ret $12 */
+@@ -860,21 +860,8 @@ void output_fake_module( DLLSPEC *spec )
+     const unsigned int section_align = page_size;
+     const unsigned int file_align = 0x200;
+     const unsigned int reloc_size = 8;
+-    const unsigned int lfanew = 0x40 + sizeof(fakedll_signature);
++    const unsigned int lfanew = (0x40 + sizeof(fakedll_signature) + 15) & ~15;
+     const unsigned int nb_sections = 2 + (spec->nb_resources != 0);
+-    const unsigned int text_size = (spec->characteristics & IMAGE_FILE_DLL) ?
+-                                    sizeof(dll_code_section) : sizeof(exe_code_section);
+-    unsigned char *resources;
+-    unsigned int resources_size;
+-    unsigned int image_size = 3 * section_align;
+-
+-    resolve_imports( spec );
+-    output_bin_resources( spec, 3 * section_align );
+-    resources = output_buffer;
+-    resources_size = output_buffer_pos;
+-    if (resources_size) image_size += (resources_size + section_align - 1) & ~(section_align - 1);
+-
+-    init_output_buffer();
+ 
+     put_word( 0x5a4d );       /* e_magic */
+     put_word( 0x40 );         /* e_cblp */
+@@ -902,6 +889,7 @@ void output_fake_module( DLLSPEC *spec )
+     put_dword( lfanew );
+ 
+     put_data( fakedll_signature, sizeof(fakedll_signature) );
++    align_output_rva( 16, 16 );
+ 
+     put_dword( 0x4550 );                             /* Signature */
+     switch(target_cpu)
+@@ -925,11 +913,11 @@ void output_fake_module( DLLSPEC *spec )
+               IMAGE_NT_OPTIONAL_HDR32_MAGIC );       /* Magic */
+     put_byte(  7 );                                  /* MajorLinkerVersion */
+     put_byte(  10 );                                 /* MinorLinkerVersion */
+-    put_dword( text_size );                          /* SizeOfCode */
++    put_dword( label_pos("text_end") - label_pos("text_start") ); /* SizeOfCode */
+     put_dword( 0 );                                  /* SizeOfInitializedData */
+     put_dword( 0 );                                  /* SizeOfUninitializedData */
+-    put_dword( section_align );                      /* AddressOfEntryPoint */
+-    put_dword( section_align );                      /* BaseOfCode */
++    put_dword( label_rva("entrypoint") );            /* AddressOfEntryPoint */
++    put_dword( label_rva("text_start") );            /* BaseOfCode */
+     if (get_ptr_size() == 4) put_dword( 0 );         /* BaseOfData */
+     put_pword( 0x10000000 );                         /* ImageBase */
+     put_dword( section_align );                      /* SectionAlignment */
+@@ -941,8 +929,8 @@ void output_fake_module( DLLSPEC *spec )
+     put_word( spec->subsystem_major );               /* MajorSubsystemVersion */
+     put_word( spec->subsystem_minor );               /* MinorSubsystemVersion */
+     put_dword( 0 );                                  /* Win32VersionValue */
+-    put_dword( image_size );                         /* SizeOfImage */
+-    put_dword( file_align );                         /* SizeOfHeaders */
++    put_dword( label_rva_align("file_end") );        /* SizeOfImage */
++    put_dword( label_pos("header_end") );            /* SizeOfHeaders */
+     put_dword( 0 );                                  /* CheckSum */
+     put_word( spec->subsystem );                     /* Subsystem */
+     put_word( spec->dll_characteristics );           /* DllCharacteristics */
+@@ -955,10 +943,10 @@ void output_fake_module( DLLSPEC *spec )
+ 
+     put_dword( 0 ); put_dword( 0 );   /* DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT] */
+     put_dword( 0 ); put_dword( 0 );   /* DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT] */
+-    if (resources_size)   /* DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE] */
++    if (spec->nb_resources)           /* DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE] */
+     {
+-        put_dword( 3 * section_align );
+-        put_dword( resources_size );
++        put_dword( label_rva("res_start") );
++        put_dword( label_pos("res_end") - label_pos("res_start") );
+     }
+     else
+     {
+@@ -968,8 +956,8 @@ void output_fake_module( DLLSPEC *spec )
+ 
+     put_dword( 0 ); put_dword( 0 );   /* DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION] */
+     put_dword( 0 ); put_dword( 0 );   /* DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY] */
+-    put_dword( 2 * section_align );   /* DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC] */
+-    put_dword( reloc_size );
++    put_dword( label_rva("reloc_start") ); /* DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC] */
++    put_dword( label_pos("reloc_end") - label_pos("reloc_start") );
+     put_dword( 0 ); put_dword( 0 );   /* DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG] */
+     put_dword( 0 ); put_dword( 0 );   /* DataDirectory[IMAGE_DIRECTORY_ENTRY_COPYRIGHT] */
+     put_dword( 0 ); put_dword( 0 );   /* DataDirectory[IMAGE_DIRECTORY_ENTRY_GLOBALPTR] */
+@@ -982,62 +970,95 @@ void output_fake_module( DLLSPEC *spec )
+     put_dword( 0 ); put_dword( 0 );   /* DataDirectory[15] */
+ 
+     /* .text section */
+-    put_data( ".text\0\0", 8 );    /* Name */
+-    put_dword( section_align );    /* VirtualSize */
+-    put_dword( section_align );    /* VirtualAddress */
+-    put_dword( text_size );        /* SizeOfRawData */
+-    put_dword( file_align );       /* PointerToRawData */
+-    put_dword( 0 );                /* PointerToRelocations */
+-    put_dword( 0 );                /* PointerToLinenumbers */
+-    put_word( 0 );                 /* NumberOfRelocations */
+-    put_word( 0 );                 /* NumberOfLinenumbers */
+-    put_dword( 0x60000020 /* CNT_CODE|MEM_EXECUTE|MEM_READ */ ); /* Characteristics  */
++    put_data( ".text\0\0", 8 );                                           /* Name */
++    put_dword( label_rva_align("text_end") - label_rva("text_start") );   /* VirtualSize */
++    put_dword( label_rva("text_start") );                                 /* VirtualAddress */
++    put_dword( label_pos("text_end") - label_pos("text_start") );         /* SizeOfRawData */
++    put_dword( label_pos("text_start") );                                 /* PointerToRawData */
++    put_dword( 0 );                                                       /* PointerToRelocations */
++    put_dword( 0 );                                                       /* PointerToLinenumbers */
++    put_word( 0 );                                                        /* NumberOfRelocations */
++    put_word( 0 );                                                        /* NumberOfLinenumbers */
++    put_dword( 0x60000020 /* CNT_CODE|MEM_EXECUTE|MEM_READ */ );          /* Characteristics  */
+ 
+     /* .reloc section */
+-    put_data( ".reloc\0", 8 );     /* Name */
+-    put_dword( section_align );    /* VirtualSize */
+-    put_dword( 2 * section_align );/* VirtualAddress */
+-    put_dword( reloc_size );       /* SizeOfRawData */
+-    put_dword( 2 * file_align );   /* PointerToRawData */
+-    put_dword( 0 );                /* PointerToRelocations */
+-    put_dword( 0 );                /* PointerToLinenumbers */
+-    put_word( 0 );                 /* NumberOfRelocations */
+-    put_word( 0 );                 /* NumberOfLinenumbers */
++    put_data( ".reloc\0", 8 );                                            /* Name */
++    put_dword( label_rva_align("reloc_end") - label_rva("reloc_start") ); /* VirtualSize */
++    put_dword( label_rva("reloc_start") );                                /* VirtualAddress */
++    put_dword( label_pos("reloc_end") - label_pos("reloc_start") );       /* SizeOfRawData */
++    put_dword( label_pos("reloc_start") );                                /* PointerToRawData */
++    put_dword( 0 );                                                       /* PointerToRelocations */
++    put_dword( 0 );                                                       /* PointerToLinenumbers */
++    put_word( 0 );                                                        /* NumberOfRelocations */
++    put_word( 0 );                                                        /* NumberOfLinenumbers */
+     put_dword( 0x42000040 /* CNT_INITIALIZED_DATA|MEM_DISCARDABLE|MEM_READ */ ); /* Characteristics */
+ 
+     /* .rsrc section */
+-    if (resources_size)
++    if (spec->nb_resources)
+     {
+-        put_data( ".rsrc\0\0", 8 );    /* Name */
+-        put_dword( (resources_size + section_align - 1) & ~(section_align - 1) ); /* VirtualSize */
+-        put_dword( 3 * section_align );/* VirtualAddress */
+-        put_dword( resources_size );   /* SizeOfRawData */
+-        put_dword( 3 * file_align );   /* PointerToRawData */
+-        put_dword( 0 );                /* PointerToRelocations */
+-        put_dword( 0 );                /* PointerToLinenumbers */
+-        put_word( 0 );                 /* NumberOfRelocations */
+-        put_word( 0 );                 /* NumberOfLinenumbers */
+-        put_dword( 0x40000040 /* CNT_INITIALIZED_DATA|MEM_READ */ ); /* Characteristics */
++        put_data( ".rsrc\0\0", 8 );                                       /* Name */
++        put_dword( label_rva_align("res_end") - label_rva("res_start") ); /* VirtualSize */
++        put_dword( label_rva("res_start") );                              /* VirtualAddress */
++        put_dword( label_pos("res_end") - label_pos("res_start") );       /* SizeOfRawData */
++        put_dword( label_pos("res_start") );                              /* PointerToRawData */
++        put_dword( 0 );                                                   /* PointerToRelocations */
++        put_dword( 0 );                                                   /* PointerToLinenumbers */
++        put_word( 0 );                                                    /* NumberOfRelocations */
++        put_word( 0 );                                                    /* NumberOfLinenumbers */
++        put_dword( 0x40000040 /* CNT_INITIALIZED_DATA|MEM_READ */ );      /* Characteristics */
+     }
+ 
++    align_output_rva( file_align, file_align );
++    put_label( "header_end" );
++
+     /* .text contents */
+-    align_output( file_align );
++    align_output_rva( file_align, section_align );
++    put_label( "text_start" );
++    put_label( "entrypoint" );
+     if (spec->characteristics & IMAGE_FILE_DLL)
+         put_data( dll_code_section, sizeof(dll_code_section) );
+     else
+         put_data( exe_code_section, sizeof(exe_code_section) );
++    put_label( "text_end" );
+ 
+     /* .reloc contents */
+-    align_output( file_align );
++    align_output_rva( file_align, section_align );
++    put_label( "reloc_start" );
+     put_dword( 0 );   /* VirtualAddress */
+     put_dword( 0 );   /* SizeOfBlock */
++    put_label( "reloc_end" );
+ 
+     /* .rsrc contents */
+-    if (resources_size)
++    if (spec->nb_resources)
+     {
+-        align_output( file_align );
+-        put_data( resources, resources_size );
++        align_output_rva( file_align, section_align );
++        put_label( "res_start" );
++        output_bin_resources( spec, label_rva("res_start") );
++        put_label( "res_end" );
+     }
++
++    put_label( "file_end" );
++}
++
++
++/*******************************************************************
++ *         output_fake_module
++ *
++ * Build a fake binary module from a spec file.
++ */
++void output_fake_module( DLLSPEC *spec )
++{
++    resolve_imports( spec );
++
++    /* First pass */
++    init_output_buffer();
++    output_fake_module_pass( spec );
++
++    /* Second pass */
++    output_buffer_pos = 0;
++    output_buffer_rva = 0;
++    output_fake_module_pass( spec );
++
+     flush_output_buffer();
+ }
+ 
+diff --git a/tools/winebuild/utils.c b/tools/winebuild/utils.c
+index 7dc61a708db..64e1fa51455 100644
+--- a/tools/winebuild/utils.c
++++ b/tools/winebuild/utils.c
+@@ -34,6 +34,7 @@
+ # include <sys/stat.h>
+ #endif
+ 
++#include "wine/list.h"
+ #include "build.h"
+ 
+ #if defined(_WIN32) && !defined(__CYGWIN__)
+@@ -542,8 +543,86 @@ size_t input_buffer_pos;
+ size_t input_buffer_size;
+ unsigned char *output_buffer;
+ size_t output_buffer_pos;
++size_t output_buffer_rva;
+ size_t output_buffer_size;
+ 
++struct label
++{
++    struct list entry;
++    const char *name;
++    size_t pos;
++    size_t rva;
++};
++
++static struct list labels = LIST_INIT( labels );
++
++struct label *get_label( const char *name )
++{
++    struct label *label;
++
++    LIST_FOR_EACH_ENTRY( label, &labels, struct label, entry )
++    {
++        if (!strcmp(name, label->name))
++            return label;
++    }
++
++    label = xmalloc( sizeof(*label) );
++    label->name = name;
++    label->pos = 0;
++    label->rva = 0;
++
++    list_add_tail( &labels, &label->entry );
++
++    return label;
++}
++
++size_t label_pos( const char *name )
++{
++    struct label *label = get_label( name );
++    return label->pos;
++}
++
++size_t label_rva( const char *name )
++{
++    struct label *label = get_label( name );
++    return label->rva;
++}
++
++size_t label_rva_align( const char *name )
++{
++    const unsigned int page_size = get_page_size();
++    size_t rva = label_rva( name );
++    size_t size = page_size - (rva % page_size);
++
++    if (size != page_size) rva += size;
++    return rva;
++}
++
++void put_label( const char *name )
++{
++    struct label *label = get_label( name );
++
++    if (label->pos || label->rva)
++    {
++        assert( label->pos == output_buffer_pos );
++        assert( label->rva == output_buffer_rva );
++    }
++
++    label->pos = output_buffer_pos;
++    label->rva = output_buffer_rva;
++}
++
++void free_labels( void )
++{
++    struct label *label, *label2;
++
++    LIST_FOR_EACH_ENTRY_SAFE( label, label2, &labels, struct label, entry )
++    {
++        list_remove( &label->entry );
++        free( label );
++    }
++}
++
+ static void check_output_buffer_space( size_t size )
+ {
+     if (output_buffer_pos + size >= output_buffer_size)
+@@ -575,7 +654,9 @@ void init_output_buffer(void)
+ {
+     output_buffer_size = 1024;
+     output_buffer_pos = 0;
++    output_buffer_rva = 0;
+     output_buffer = xmalloc( output_buffer_size );
++    free_labels();
+ }
+ 
+ void flush_output_buffer(void)
+@@ -585,6 +666,7 @@ void flush_output_buffer(void)
+         fatal_error( "Error writing to %s\n", output_file_name );
+     close_output_file();
+     free( output_buffer );
++    free_labels();
+ }
+ 
+ unsigned char get_byte(void)
+@@ -624,12 +706,14 @@ void put_data( const void *data, size_t size )
+     check_output_buffer_space( size );
+     memcpy( output_buffer + output_buffer_pos, data, size );
+     output_buffer_pos += size;
++    output_buffer_rva += size;
+ }
+ 
+ void put_byte( unsigned char val )
+ {
+     check_output_buffer_space( 1 );
+     output_buffer[output_buffer_pos++] = val;
++    output_buffer_rva++;
+ }
+ 
+ void put_word( unsigned short val )
+@@ -676,6 +760,14 @@ void align_output( unsigned int align )
+     output_buffer_pos += size;
+ }
+ 
++void align_output_rva( unsigned int file_align, unsigned int rva_align )
++{
++    size_t size = rva_align - (output_buffer_rva % rva_align);
++
++    if (size != rva_align) output_buffer_rva += size;
++    align_output( file_align );
++}
++
+ /* output a standard header for generated files */
+ void output_standard_file_header(void)
+ {
+-- 
+2.26.2
+
diff --git a/patches/winebuild-Fake_Dlls/0005-winebuild-Add-stub-functions-in-fake-dlls.patch b/patches/winebuild-Fake_Dlls/0005-winebuild-Add-stub-functions-in-fake-dlls.patch
new file mode 100644
index 00000000..f34c9e3c
--- /dev/null
+++ b/patches/winebuild-Fake_Dlls/0005-winebuild-Add-stub-functions-in-fake-dlls.patch
@@ -0,0 +1,440 @@
+From 724fec1afabf68217dc161e0f784a8b65c2c5854 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
+Date: Mon, 15 May 2017 16:27:56 +0200
+Subject: [PATCH] winebuild: Add stub functions in fake dlls.
+
+---
+ dlls/kernel32/tests/loader.c |   8 +-
+ dlls/ntdll/thread.c          |  35 ++++++
+ include/winternl.h           |   2 +-
+ tools/winebuild/build.h      |   1 +
+ tools/winebuild/spec32.c     | 209 +++++++++++++++++++++++++++++++++--
+ tools/winebuild/utils.c      |  10 +-
+ 6 files changed, 250 insertions(+), 15 deletions(-)
+
+diff --git a/dlls/kernel32/tests/loader.c b/dlls/kernel32/tests/loader.c
+index 926fa913866..902907329c0 100644
+--- a/dlls/kernel32/tests/loader.c
++++ b/dlls/kernel32/tests/loader.c
+@@ -1596,9 +1596,7 @@ static void test_FakeDLL(void)
+     ok(ptr != NULL, "MapViewOfFile failed with error %u\n", GetLastError());
+ 
+     dir = RtlImageDirectoryEntryToData(ptr, TRUE, IMAGE_DIRECTORY_ENTRY_EXPORT, &size);
+-todo_wine
+     ok(dir != NULL, "RtlImageDirectoryEntryToData failed\n");
+-    if (dir == NULL) goto done;
+ 
+     names    = RVAToAddr(dir->AddressOfNames, ptr);
+     ordinals = RVAToAddr(dir->AddressOfNameOrdinals, ptr);
+@@ -1627,17 +1625,20 @@ todo_wine
+         /* check position in memory */
+         dll_rva = (DWORD_PTR)dll_func - (DWORD_PTR)module;
+         map_rva = funcs[ordinals[i]];
++    todo_wine
+         ok(map_rva == dll_rva, "%s: Rva of mapped function (0x%x) does not match dll (0x%x)\n",
+            func_name, dll_rva, map_rva);
+ 
+         /* check position in file */
+         map_offset = (DWORD_PTR)RtlImageRvaToVa(RtlImageNtHeader(ptr),    ptr,    map_rva, NULL) - (DWORD_PTR)ptr;
+         dll_offset = (DWORD_PTR)RtlImageRvaToVa(RtlImageNtHeader(module), module, dll_rva, NULL) - (DWORD_PTR)module;
++    todo_wine
+         ok(map_offset == dll_offset, "%s: File offset of mapped function (0x%x) does not match dll (0x%x)\n",
+            func_name, map_offset, dll_offset);
+ 
+         /* check function content */
+         map_func = RVAToAddr(map_rva, ptr);
++    todo_wine
+         ok(!memcmp(map_func, dll_func, 0x20), "%s: Function content does not match!\n", func_name);
+ 
+         if (!strcmp(func_name, "NtSetEvent"))
+@@ -1651,10 +1652,11 @@ todo_wine
+         ok(event != NULL, "CreateEvent failed with error %u\n", GetLastError());
+         pNtSetEvent(event, 0);
+         ok(WaitForSingleObject(event, 0) == WAIT_OBJECT_0, "Event was not signaled\n");
++        pNtSetEvent(event, 0);
++        ok(WaitForSingleObject(event, 0) == WAIT_OBJECT_0, "Event was not signaled\n");
+         CloseHandle(event);
+     }
+ 
+-done:
+     UnmapViewOfFile(ptr);
+     CloseHandle(map);
+     CloseHandle(file);
+diff --git a/dlls/ntdll/signal_i386.c b/dlls/ntdll/signal_i386.c
+index 04fdaf564b3..1dcc54895dc 100644
+--- a/dlls/ntdll/signal_i386.c
++++ b/dlls/ntdll/signal_i386.c
+@@ -479,6 +479,39 @@ static wine_signal_handler handlers[256];
+ extern void DECLSPEC_NORETURN __wine_syscall_dispatcher( void );
+ extern NTSTATUS WINAPI __syscall_NtGetContextThread( HANDLE handle, CONTEXT *context );
+ 
++static void* WINAPI __wine_fakedll_dispatcher( const char *module, ULONG ord )
++{
++    UNICODE_STRING name;
++    NTSTATUS status;
++    HMODULE base;
++    WCHAR *moduleW;
++    void *proc = NULL;
++    DWORD len = strlen(module);
++
++    TRACE( "(%s, %u)\n", debugstr_a(module), ord );
++
++    if (!(moduleW = RtlAllocateHeap( GetProcessHeap(), 0, (len + 1) * sizeof(WCHAR) )))
++        return NULL;
++
++    ascii_to_unicode( moduleW, module, len );
++    moduleW[ len ] = 0;
++    RtlInitUnicodeString( &name, moduleW );
++
++    status = LdrGetDllHandle( NULL, 0, &name, &base );
++    if (status == STATUS_DLL_NOT_FOUND)
++        status = LdrLoadDll( NULL, 0, &name, &base );
++    if (status == STATUS_SUCCESS)
++        status = LdrAddRefDll( LDR_ADDREF_DLL_PIN, base );
++    if (status == STATUS_SUCCESS)
++        status = LdrGetProcedureAddress( base, NULL, ord, &proc );
++
++    if (status)
++        FIXME( "No procedure address found for %s.#%u, status %x\n", debugstr_a(module), ord, status );
++
++    RtlFreeHeap( GetProcessHeap(), 0, moduleW );
++    return proc;
++}
++
+ enum i386_trap_code
+ {
+     TRAP_x86_UNKNOWN    = -1,  /* Unknown fault (TRAP_sig not defined) */
+@@ -2565,6 +2598,7 @@ NTSTATUS signal_alloc_thread( TEB *teb )
+     else thread_data->fs = gdt_fs_sel;
+ 
+     teb->WOW32Reserved = __wine_syscall_dispatcher;
++    teb->Spare2 = __wine_fakedll_dispatcher;
+ 
+     return STATUS_SUCCESS;
+ }
+diff --git a/include/winternl.h b/include/winternl.h
+index 26ee5b601fb..03f86dae253 100644
+--- a/include/winternl.h
++++ b/include/winternl.h
+@@ -398,7 +398,7 @@ typedef struct _TEB
+     PVOID                        Instrumentation[16];               /* f2c/16b8 */
+     PVOID                        WinSockData;                       /* f6c/1738 */
+     ULONG                        GdiBatchCount;                     /* f70/1740 */
+-    ULONG                        Spare2;                            /* f74/1744 */
++    ULONG                        Spare2;                            /* f74/1744  used for fakedll thunks */
+     ULONG                        GuaranteedStackBytes;              /* f78/1748 */
+     PVOID                        ReservedForPerf;                   /* f7c/1750 */
+     PVOID                        ReservedForOle;                    /* f80/1758 */
+diff --git a/tools/winebuild/build.h b/tools/winebuild/build.h
+index 8930df408d3..44113bad28a 100644
+--- a/tools/winebuild/build.h
++++ b/tools/winebuild/build.h
+@@ -358,6 +358,7 @@ extern void put_word( unsigned short val );
+ extern void put_dword( unsigned int val );
+ extern void put_qword( unsigned int val );
+ extern void put_pword( unsigned int val );
++extern void put_str( const char *str );
+ extern void align_output( unsigned int align );
+ extern void align_output_rva( unsigned int file_align, unsigned int rva_align );
+ extern size_t label_pos( const char *name );
+diff --git a/tools/winebuild/spec32.c b/tools/winebuild/spec32.c
+index c38f1fe663c..bf82ca497c0 100644
+--- a/tools/winebuild/spec32.c
++++ b/tools/winebuild/spec32.c
+@@ -843,6 +843,163 @@ void output_spec32_file( DLLSPEC *spec )
+ }
+ 
+ 
++static int needs_stub_exports( DLLSPEC *spec )
++{
++    if (target_cpu != CPU_x86)
++        return 0;
++    if (!(spec->characteristics & IMAGE_FILE_DLL))
++        return 0;
++    if (!spec->nb_entry_points)
++        return 0;
++    return 1;
++}
++
++
++static void create_stub_exports_text( DLLSPEC *spec )
++{
++    int i, nr_exports = spec->base <= spec->limit ? spec->limit - spec->base + 1 : 0;
++    size_t rva, thunk;
++
++    /* output stub code for exports */
++    for (i = 0; i < spec->nb_entry_points; i++)
++    {
++        ORDDEF *odp = &spec->entry_points[i];
++        const char *name = get_stub_name( odp, spec );
++
++        align_output_rva( 16, 16 );
++        put_label( name );
++        put_byte( 0x8b ); put_byte( 0xff );                           /* mov edi, edi */
++        put_byte( 0x55 );                                             /* push ebp */
++        put_byte( 0x8b ); put_byte( 0xec );                           /* mov ebp, esp */
++        put_byte( 0x68 ); put_dword( 0 );                             /* push dword 0 */
++        put_byte( 0x68 ); put_dword( odp->ordinal );                  /* push ORDINAL */
++        rva = output_buffer_rva + 5;
++        put_byte( 0xe8 ); put_dword( label_rva("_forward") - rva );   /* call _forward */
++        put_byte( 0x89 ); put_byte( 0xec );                           /* mov esp, ebp */
++        put_byte( 0x5d );                                             /* pop ebp */
++        if (odp->type == TYPE_STDCALL)
++        {
++            put_byte( 0xc2 ); put_word( get_args_size(odp) );         /* ret X */
++        }
++        else
++        {
++            put_byte( 0xc3 );                                         /* ret */
++        }
++    }
++
++    /* output entry point */
++    align_output_rva( 16, 16 );
++    put_label( "entrypoint" );
++    put_byte( 0xb8 ); put_dword( 1 );                                 /* mov eax, 1 */
++    put_byte( 0xc2 ); put_word( 12 );                                 /* ret 12 */
++
++    /* output forward function */
++    align_output_rva( 16, 16 );
++    put_label( "_forward" );
++    put_byte( 0x8b ); put_byte( 0x6d ); put_byte( 0x00 );             /* mov ebp, dword[ebp] */
++    put_byte( 0x89 ); put_byte( 0x44 );                               /* mov dword[esp+8], eax */
++    put_byte( 0x24 ); put_byte( 0x08 );
++    put_byte( 0x89 ); put_byte( 0x14 ); put_byte( 0x24 );             /* mov dword[esp], edx */
++    put_byte( 0x8b ); put_byte( 0x54 );                               /* mov edx, dword[esp+4] */
++    put_byte( 0x24 ); put_byte( 0x04 );
++    put_byte( 0x89 ); put_byte( 0x4c );                               /* mov dword[esp+4], ecx */
++    put_byte( 0x24 ); put_byte( 0x04 );
++    put_byte( 0xe8 ); put_dword( 0 );                                 /* call 1f */
++    thunk = output_buffer_rva;
++    put_byte( 0x59 );                                                 /* pop ecx */
++    put_byte( 0x8b ); put_byte( 0x84 ); put_byte( 0x91 );             /* mov eax, dword[_functions + 4 * (edx - BASE)] */
++    put_dword( label_rva("_functions") - thunk - 4 * spec->base );
++    put_byte( 0x09 ); put_byte( 0xc0 );                               /* or eax, eax */
++    rva = output_buffer_rva + 2;
++    put_byte( 0x74 ); put_byte( label_rva("_forward_load") - rva );   /* je _forward_load */
++
++    put_label( "_forward_done" );
++    put_byte( 0x89 ); put_byte( 0x44 );                               /* mov dword[esp+12], eax */
++    put_byte( 0x24 ); put_byte( 0x0c );
++    put_byte( 0x5a );                                                 /* pop edx */
++    put_byte( 0x59 );                                                 /* pop ecx */
++    put_byte( 0x58 );                                                 /* pop eax */
++    put_byte( 0xc3 );                                                 /* ret */
++
++    align_output_rva( 16, 16 );
++    put_label( "_forward_load" );
++    put_byte( 0x8d ); put_byte( 0x84 ); put_byte( 0x91 );             /* lea eax, [_functions + 4 * (edx - BASE)] */
++    put_dword( label_rva("_functions") - thunk - 4 * spec->base );
++    put_byte( 0x50 );                                                 /* push eax */
++    put_byte( 0x52 );                                                 /* push edx */
++    put_byte( 0x8d ); put_byte( 0x81 );                               /* lea eax, [dll_name] */
++    put_dword( label_rva("dll_name") - thunk );
++    put_byte( 0x50 );                                                 /* push eax */
++    put_byte( 0x64 ); put_byte( 0xff );                               /* call dword ptr fs:[0F74h] */
++    put_byte( 0x15 ); put_dword( 0xf74 );
++    put_byte( 0x5a );                                                 /* pop edx */
++    put_byte( 0x89 ); put_byte( 0x02 );                               /* mov dword[edx], eax */
++    rva = output_buffer_rva + 2;
++    put_byte( 0xeb ); put_byte( label_rva("_forward_done") - rva );   /* jmp _forward_done */
++
++    /* export directory */
++    align_output_rva( 16, 16 );
++    put_label( "export_start" );
++    put_dword( 0 );                             /* Characteristics */
++    put_dword( 0 );                             /* TimeDateStamp */
++    put_dword( 0 );                             /* MajorVersion/MinorVersion */
++    put_dword( label_rva("dll_name") );         /* Name */
++    put_dword( spec->base );                    /* Base */
++    put_dword( nr_exports );                    /* NumberOfFunctions */
++    put_dword( spec->nb_names );                /* NumberOfNames */
++    put_dword( label_rva("export_funcs") );     /* AddressOfFunctions */
++    put_dword( label_rva("export_names") );     /* AddressOfNames */
++    put_dword( label_rva("export_ordinals") );  /* AddressOfNameOrdinals */
++
++    put_label( "export_funcs" );
++    for (i = spec->base; i <= spec->limit; i++)
++    {
++        ORDDEF *odp = spec->ordinals[i];
++        if (odp)
++        {
++            const char *name = get_stub_name( odp, spec );
++            put_dword( label_rva( name ) );
++        }
++        else
++            put_dword( 0 );
++    }
++
++    if (spec->nb_names)
++    {
++        put_label( "export_names" );
++        for (i = 0; i < spec->nb_names; i++)
++            put_dword( label_rva(strmake("str_%s", get_stub_name(spec->names[i], spec))) );
++
++        put_label( "export_ordinals" );
++        for (i = 0; i < spec->nb_names; i++)
++            put_word( spec->names[i]->ordinal - spec->base );
++        if (spec->nb_names % 2)
++            put_word( 0 );
++    }
++
++    put_label( "dll_name" );
++    put_str( spec->file_name );
++
++    for (i = 0; i < spec->nb_names; i++)
++    {
++        put_label( strmake("str_%s", get_stub_name(spec->names[i], spec)) );
++        put_str( spec->names[i]->name );
++    }
++
++    put_label( "export_end" );
++}
++
++
++static void create_stub_exports_data( DLLSPEC *spec )
++{
++    int i;
++
++    put_label( "_functions" );
++    for (i = spec->base; i <= spec->limit; i++)
++        put_dword( 0 );
++}
++
++
+ /*******************************************************************
+  *         output_fake_module_pass
+  *
+@@ -861,7 +1018,7 @@ static void output_fake_module_pass( DLLSPEC *spec )
+     const unsigned int file_align = 0x200;
+     const unsigned int reloc_size = 8;
+     const unsigned int lfanew = (0x40 + sizeof(fakedll_signature) + 15) & ~15;
+-    const unsigned int nb_sections = 2 + (spec->nb_resources != 0);
++    const unsigned int nb_sections = 2 + (needs_stub_exports( spec ) != 0) + (spec->nb_resources != 0);
+ 
+     put_word( 0x5a4d );       /* e_magic */
+     put_word( 0x40 );         /* e_cblp */
+@@ -918,7 +1075,7 @@ static void output_fake_module_pass( DLLSPEC *spec )
+     put_dword( 0 );                                  /* SizeOfUninitializedData */
+     put_dword( label_rva("entrypoint") );            /* AddressOfEntryPoint */
+     put_dword( label_rva("text_start") );            /* BaseOfCode */
+-    if (get_ptr_size() == 4) put_dword( 0 );         /* BaseOfData */
++    if (get_ptr_size() == 4) put_dword( label_rva("data_start") ); /* BaseOfData */
+     put_pword( 0x10000000 );                         /* ImageBase */
+     put_dword( section_align );                      /* SectionAlignment */
+     put_dword( file_align );                         /* FileAlignment */
+@@ -941,7 +1098,8 @@ static void output_fake_module_pass( DLLSPEC *spec )
+     put_dword( 0 );                                  /* LoaderFlags */
+     put_dword( 16 );                                 /* NumberOfRvaAndSizes */
+ 
+-    put_dword( 0 ); put_dword( 0 );   /* DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT] */
++    put_dword( label_rva("export_start") ); /* DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT] */
++    put_dword( label_pos("export_end") - label_pos("export_start") );
+     put_dword( 0 ); put_dword( 0 );   /* DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT] */
+     if (spec->nb_resources)           /* DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE] */
+     {
+@@ -981,6 +1139,21 @@ static void output_fake_module_pass( DLLSPEC *spec )
+     put_word( 0 );                                                        /* NumberOfLinenumbers */
+     put_dword( 0x60000020 /* CNT_CODE|MEM_EXECUTE|MEM_READ */ );          /* Characteristics  */
+ 
++    /* .data section */
++    if (needs_stub_exports( spec ))
++    {
++        put_data( ".data\0\0", 8 );                                       /* Name */
++        put_dword( label_rva_align("data_end") - label_rva("data_start") ); /* VirtualSize */
++        put_dword( label_rva("data_start") );                             /* VirtualAddress */
++        put_dword( label_pos("data_end") - label_pos("data_start") );     /* SizeOfRawData */
++        put_dword( label_pos("data_start") );                             /* PointerToRawData */
++        put_dword( 0 );                                                   /* PointerToRelocations */
++        put_dword( 0 );                                                   /* PointerToLinenumbers */
++        put_word( 0 );                                                    /* NumberOfRelocations */
++        put_word( 0 );                                                    /* NumberOfLinenumbers */
++        put_dword( 0xc0000040 /* CNT_INITIALIZED_DATA|MEM_READ|MEM_WRITE */ ); /* Characteristics  */
++    }
++
+     /* .reloc section */
+     put_data( ".reloc\0", 8 );                                            /* Name */
+     put_dword( label_rva_align("reloc_end") - label_rva("reloc_start") ); /* VirtualSize */
+@@ -1013,13 +1186,31 @@ static void output_fake_module_pass( DLLSPEC *spec )
+ 
+     /* .text contents */
+     align_output_rva( file_align, section_align );
+-    put_label( "text_start" );
+-    put_label( "entrypoint" );
+-    if (spec->characteristics & IMAGE_FILE_DLL)
+-        put_data( dll_code_section, sizeof(dll_code_section) );
++    if (needs_stub_exports( spec ))
++    {
++        put_label( "text_start" );
++        create_stub_exports_text( spec );
++        put_label( "text_end" );
++    }
+     else
+-        put_data( exe_code_section, sizeof(exe_code_section) );
+-    put_label( "text_end" );
++    {
++        put_label( "text_start" );
++        put_label( "entrypoint" );
++        if (spec->characteristics & IMAGE_FILE_DLL)
++            put_data( dll_code_section, sizeof(dll_code_section) );
++        else
++            put_data( exe_code_section, sizeof(exe_code_section) );
++        put_label( "text_end" );
++    }
++
++    /* .data contents */
++    align_output_rva( file_align, section_align );
++    if (needs_stub_exports( spec ))
++    {
++        put_label( "data_start" );
++        create_stub_exports_data( spec );
++        put_label( "data_end" );
++    }
+ 
+     /* .reloc contents */
+     align_output_rva( file_align, section_align );
+diff --git a/tools/winebuild/utils.c b/tools/winebuild/utils.c
+index 80dec6db29e..d394a1382c6 100644
+--- a/tools/winebuild/utils.c
++++ b/tools/winebuild/utils.c
+@@ -549,7 +549,7 @@ size_t output_buffer_size;
+ struct label
+ {
+     struct list entry;
+-    const char *name;
++    char *name;
+     size_t pos;
+     size_t rva;
+ };
+@@ -567,7 +567,7 @@ struct label *get_label( const char *name )
+     }
+ 
+     label = xmalloc( sizeof(*label) );
+-    label->name = name;
++    label->name = xstrdup( name );
+     label->pos = 0;
+     label->rva = 0;
+ 
+@@ -619,6 +619,7 @@ void free_labels( void )
+     LIST_FOR_EACH_ENTRY_SAFE( label, label2, &labels, struct label, entry )
+     {
+         list_remove( &label->entry );
++        free( label->name );
+         free( label );
+     }
+ }
+@@ -750,6 +751,11 @@ void put_pword( unsigned int val )
+     else put_dword( val );
+ }
+ 
++void put_str( const char *str )
++{
++    put_data( str, strlen(str) + 1 );
++}
++
+ void align_output( unsigned int align )
+ {
+     size_t size = align - (output_buffer_pos % align);
+-- 
+2.26.2
+
diff --git a/patches/winebuild-Fake_Dlls/0006-winebuild-Add-syscall-thunks-in-fake-dlls.patch b/patches/winebuild-Fake_Dlls/0006-winebuild-Add-syscall-thunks-in-fake-dlls.patch
new file mode 100644
index 00000000..5ae2b3de
--- /dev/null
+++ b/patches/winebuild-Fake_Dlls/0006-winebuild-Add-syscall-thunks-in-fake-dlls.patch
@@ -0,0 +1,76 @@
+From 84a9f7b8192d7735108da2d7e81cf63faef97c13 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
+Date: Mon, 15 May 2017 17:56:48 +0200
+Subject: [PATCH] winebuild: Add syscall thunks in fake dlls.
+
+---
+ dlls/kernel32/tests/loader.c |  1 -
+ tools/winebuild/spec32.c     | 27 +++++++++++++++++++++++++--
+ 2 files changed, 25 insertions(+), 3 deletions(-)
+
+diff --git a/dlls/kernel32/tests/loader.c b/dlls/kernel32/tests/loader.c
+index ec173c94a8e..a3bed8b310b 100644
+--- a/dlls/kernel32/tests/loader.c
++++ b/dlls/kernel32/tests/loader.c
+@@ -1602,7 +1602,6 @@ static void test_FakeDLL(void)
+ 
+         /* check function content */
+         map_func = RVAToAddr(map_rva, ptr);
+-    todo_wine
+         ok(!memcmp(map_func, dll_func, 0x20), "%s: Function content does not match!\n", func_name);
+ 
+         if (!strcmp(func_name, "NtSetEvent"))
+diff --git a/tools/winebuild/spec32.c b/tools/winebuild/spec32.c
+index bf82ca497c0..6968e41260f 100644
+--- a/tools/winebuild/spec32.c
++++ b/tools/winebuild/spec32.c
+@@ -860,13 +860,36 @@ static void create_stub_exports_text( DLLSPEC *spec )
+     int i, nr_exports = spec->base <= spec->limit ? spec->limit - spec->base + 1 : 0;
+     size_t rva, thunk;
+ 
++    /* output syscalls */
++    for (i = 0; i < spec->nb_syscalls; i++)
++    {
++        ORDDEF *odp = spec->syscalls[i];
++
++        align_output_rva( 16, 16 );
++        put_label( odp->link_name );
++        put_byte( 0xb8 ); put_dword( i );                     /* mov eax, SYSCALL */
++        put_byte( 0x64 ); put_byte( 0xff );                   /* call dword ptr fs:[0C0h] */
++        put_byte( 0x15 ); put_dword( 0xc0 );
++        put_byte( 0xc2 ); put_word( get_args_size(odp) );     /* ret X */
++    }
++
++    if (spec->nb_syscalls)
++    {
++        for (i = 0; i < 0x20; i++)
++            put_byte( 0 );
++    }
++
+     /* output stub code for exports */
+     for (i = 0; i < spec->nb_entry_points; i++)
+     {
+         ORDDEF *odp = &spec->entry_points[i];
+-        const char *name = get_stub_name( odp, spec );
++        const char *name;
++
++        if (odp->flags & FLAG_SYSCALL)
++            continue;
+ 
+         align_output_rva( 16, 16 );
++        name = get_stub_name( odp, spec );
+         put_label( name );
+         put_byte( 0x8b ); put_byte( 0xff );                           /* mov edi, edi */
+         put_byte( 0x55 );                                             /* push ebp */
+@@ -957,7 +980,7 @@ static void create_stub_exports_text( DLLSPEC *spec )
+         ORDDEF *odp = spec->ordinals[i];
+         if (odp)
+         {
+-            const char *name = get_stub_name( odp, spec );
++            const char *name = (odp->flags & FLAG_SYSCALL) ? odp->link_name : get_stub_name( odp, spec );
+             put_dword( label_rva( name ) );
+         }
+         else
+-- 
+2.26.2
+
diff --git a/patches/winebuild-Fake_Dlls/0007-winebuild-Fix-size-of-relocation-information-in-fake.patch b/patches/winebuild-Fake_Dlls/0007-winebuild-Fix-size-of-relocation-information-in-fake.patch
new file mode 100644
index 00000000..92a7161d
--- /dev/null
+++ b/patches/winebuild-Fake_Dlls/0007-winebuild-Fix-size-of-relocation-information-in-fake.patch
@@ -0,0 +1,27 @@
+From d77c31b1567bfbde1ce4ceb526ad596d0be3e788 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
+Date: Thu, 25 May 2017 03:22:25 +0200
+Subject: [PATCH] winebuild: Fix size of relocation information in fake dlls.
+
+---
+ tools/winebuild/spec32.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/tools/winebuild/spec32.c b/tools/winebuild/spec32.c
+index 6968e41260f..f95b45b9a0d 100644
+--- a/tools/winebuild/spec32.c
++++ b/tools/winebuild/spec32.c
+@@ -1238,8 +1238,8 @@ static void output_fake_module_pass( DLLSPEC *spec )
+     /* .reloc contents */
+     align_output_rva( file_align, section_align );
+     put_label( "reloc_start" );
+-    put_dword( 0 );   /* VirtualAddress */
+-    put_dword( 0 );   /* SizeOfBlock */
++    put_dword( label_rva("text_start") );   /* VirtualAddress */
++    put_dword( 8 );                         /* SizeOfBlock */
+     put_label( "reloc_end" );
+ 
+     /* .rsrc contents */
+-- 
+2.26.2
+
diff --git a/patches/winebuild-Fake_Dlls/0008-winebuild-Try-to-make-sure-RVA-matches-between-fake-.patch b/patches/winebuild-Fake_Dlls/0008-winebuild-Try-to-make-sure-RVA-matches-between-fake-.patch
new file mode 100644
index 00000000..c4f1fb00
--- /dev/null
+++ b/patches/winebuild-Fake_Dlls/0008-winebuild-Try-to-make-sure-RVA-matches-between-fake-.patch
@@ -0,0 +1,99 @@
+From afa59bbabca36f306e9db4c1b080a250c4a919ea Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
+Date: Thu, 25 May 2017 21:46:27 +0200
+Subject: [PATCH] winebuild: Try to make sure RVA matches between fake and
+ builtin DLLs.
+
+---
+ dlls/kernel32/tests/loader.c |  1 -
+ libs/wine/loader.c           | 13 +++++++++++--
+ tools/winebuild/spec32.c     | 17 +++++++++++++++--
+ 3 files changed, 26 insertions(+), 5 deletions(-)
+
+diff --git a/dlls/kernel32/tests/loader.c b/dlls/kernel32/tests/loader.c
+index a3bed8b310b..8b5a345b086 100644
+--- a/dlls/kernel32/tests/loader.c
++++ b/dlls/kernel32/tests/loader.c
+@@ -1589,7 +1589,6 @@ static void test_FakeDLL(void)
+         /* check position in memory */
+         dll_rva = (DWORD_PTR)dll_func - (DWORD_PTR)module;
+         map_rva = funcs[ordinals[i]];
+-    todo_wine
+         ok(map_rva == dll_rva, "%s: Rva of mapped function (0x%x) does not match dll (0x%x)\n",
+            func_name, dll_rva, map_rva);
+ 
+diff --git a/libs/wine/loader.c b/libs/wine/loader.c
+index c3b59d90224..b6847ca77b3 100644
+--- a/libs/wine/loader.c
++++ b/libs/wine/loader.c
+@@ -335,8 +335,12 @@ static void *map_dll( const IMAGE_NT_HEADERS *nt_descr )
+     assert( size <= page_size );
+ 
+     /* module address must be aligned on 64K boundary */
+-    addr = (BYTE *)((nt_descr->OptionalHeader.ImageBase + 0xffff) & ~0xffff);
+-    if (wine_anon_mmap( addr, page_size, PROT_READ|PROT_WRITE, MAP_FIXED ) != addr) return NULL;
++    addr = *(BYTE **)&nt_descr->OptionalHeader.DataDirectory[15];
++    if (!addr || ((ULONG_PTR)addr & 0xffff) || mprotect( addr, page_size, PROT_READ | PROT_WRITE ))
++    {
++        addr = (BYTE *)((nt_descr->OptionalHeader.ImageBase + 0xffff) & ~0xffff);
++        if (wine_anon_mmap( addr, page_size, PROT_READ|PROT_WRITE, MAP_FIXED ) != addr) return NULL;
++    }
+ 
+     dos    = (IMAGE_DOS_HEADER *)addr;
+     nt     = (IMAGE_NT_HEADERS *)(dos + 1);
+@@ -383,6 +387,11 @@ static void *map_dll( const IMAGE_NT_HEADERS *nt_descr )
+     nt->OptionalHeader.SizeOfImage                 = data_end;
+     nt->OptionalHeader.ImageBase                   = (ULONG_PTR)addr;
+ 
++    /* Clear DataDirectory[15] */
++
++    nt->OptionalHeader.DataDirectory[15].VirtualAddress = 0;
++    nt->OptionalHeader.DataDirectory[15].Size = 0;
++
+     /* Build the code section */
+ 
+     memcpy( sec->Name, ".text", sizeof(".text") );
+diff --git a/tools/winebuild/spec32.c b/tools/winebuild/spec32.c
+index f95b45b9a0d..07d6eed05fc 100644
+--- a/tools/winebuild/spec32.c
++++ b/tools/winebuild/spec32.c
+@@ -381,14 +381,25 @@ static void output_relay_debug( DLLSPEC *spec )
+  */
+ static void output_syscall_thunks( DLLSPEC *spec )
+ {
++    const unsigned int page_size = get_page_size();
+     int i;
+ 
+     if (!spec->nb_syscalls)
+         return;
+ 
+-    output( "\n/* syscall thunks */\n\n" );
+-    output( "\t.text\n" );
++    /* Reserve space for PE header directly before syscalls. */
++    if (target_platform == PLATFORM_APPLE)
++        output( "\t.text\n" );
++    else
++        output( "\n\t.section \".text.startup\"\n" );
++
++    output( "\t.align %d\n", get_alignment(65536) );
++    output( "__wine_spec_pe_header_syscalls:\n" );
++    output( "__wine_spec_pe_header_syscalls_end:\n" );
++    output( "\t.byte 0\n" );
++    output( "\t.balign %d, 0\n", page_size );
+ 
++    output( "\n/* syscall thunks */\n\n" );
+     for (i = 0; i < spec->nb_syscalls; i++)
+     {
+         ORDDEF *odp = spec->syscalls[i];
+@@ -813,6 +824,8 @@ void output_module( DLLSPEC *spec )
+         data_dirs[1] = ".L__wine_spec_imports";   /* DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT] */
+     if (spec->nb_resources)
+         data_dirs[2] = ".L__wine_spec_resources"; /* DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE] */
++    if (spec->nb_syscalls)
++        data_dirs[15] = "__wine_spec_pe_header_syscalls";
+ 
+     output_data_directories( data_dirs );
+ 
+-- 
+2.26.2
+
diff --git a/patches/winebuild-Fake_Dlls/0009-libs-wine-Use-same-file-alignment-for-fake-and-built.patch b/patches/winebuild-Fake_Dlls/0009-libs-wine-Use-same-file-alignment-for-fake-and-built.patch
new file mode 100644
index 00000000..e0ae33a5
--- /dev/null
+++ b/patches/winebuild-Fake_Dlls/0009-libs-wine-Use-same-file-alignment-for-fake-and-built.patch
@@ -0,0 +1,38 @@
+From 29478273c4db90d209ac5afbdc1dd80add3d2c7e Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
+Date: Thu, 25 May 2017 21:56:06 +0200
+Subject: [PATCH] libs/wine: Use same file alignment for fake and builtin DLLs.
+
+---
+ dlls/kernel32/tests/loader.c | 1 -
+ libs/wine/loader.c           | 2 +-
+ 2 files changed, 1 insertion(+), 2 deletions(-)
+
+diff --git a/dlls/kernel32/tests/loader.c b/dlls/kernel32/tests/loader.c
+index 8b5a345b086..5373dc4efe1 100644
+--- a/dlls/kernel32/tests/loader.c
++++ b/dlls/kernel32/tests/loader.c
+@@ -1595,7 +1595,6 @@ static void test_FakeDLL(void)
+         /* check position in file */
+         map_offset = (DWORD_PTR)RtlImageRvaToVa(RtlImageNtHeader(ptr),    ptr,    map_rva, NULL) - (DWORD_PTR)ptr;
+         dll_offset = (DWORD_PTR)RtlImageRvaToVa(RtlImageNtHeader(module), module, dll_rva, NULL) - (DWORD_PTR)module;
+-    todo_wine
+         ok(map_offset == dll_offset, "%s: File offset of mapped function (0x%x) does not match dll (0x%x)\n",
+            func_name, map_offset, dll_offset);
+ 
+diff --git a/libs/wine/loader.c b/libs/wine/loader.c
+index b6847ca77b3..4597a6cb324 100644
+--- a/libs/wine/loader.c
++++ b/libs/wine/loader.c
+@@ -398,7 +398,7 @@ static void *map_dll( const IMAGE_NT_HEADERS *nt_descr )
+     sec->SizeOfRawData = code_end - code_start;
+     sec->Misc.VirtualSize = sec->SizeOfRawData;
+     sec->VirtualAddress   = code_start;
+-    sec->PointerToRawData = code_start;
++    sec->PointerToRawData = 0x200; /* file alignment */
+     sec->Characteristics  = (IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ);
+     sec++;
+ 
+-- 
+2.26.2
+
diff --git a/patches/winebuild-Fake_Dlls/0010-tools-winebuild-Add-syscall-thunks-for-64-bit.patch b/patches/winebuild-Fake_Dlls/0010-tools-winebuild-Add-syscall-thunks-for-64-bit.patch
new file mode 100644
index 00000000..55bedd41
--- /dev/null
+++ b/patches/winebuild-Fake_Dlls/0010-tools-winebuild-Add-syscall-thunks-for-64-bit.patch
@@ -0,0 +1,490 @@
+From 253d27816a1eb43b54834a12aa4c55442b0b1062 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
+Date: Thu, 7 Sep 2017 00:38:09 +0200
+Subject: [PATCH] tools/winebuild: Add syscall thunks for 64 bit.
+
+---
+ dlls/kernel32/tests/loader.c |   7 +-
+ dlls/ntdll/thread.c          |  13 +-
+ libs/wine/loader.c           |   4 +
+ server/mapping.c             |   6 +-
+ tools/winebuild/parser.c     |   2 +-
+ tools/winebuild/spec32.c     | 285 ++++++++++++++++++++++++++++++++++-
+ 6 files changed, 306 insertions(+), 11 deletions(-)
+
+diff --git a/dlls/kernel32/tests/loader.c b/dlls/kernel32/tests/loader.c
+index 95939ba6bde..ae5462f6e55 100644
+--- a/dlls/kernel32/tests/loader.c
++++ b/dlls/kernel32/tests/loader.c
+@@ -1573,7 +1573,7 @@ static void test_filenames(void)
+ 
+ static void test_FakeDLL(void)
+ {
+-#ifdef __i386__
++#if defined(__i386__) || defined(__x86_64__)
+     NTSTATUS (WINAPI *pNtSetEvent)(HANDLE, ULONG *) = NULL;
+     IMAGE_EXPORT_DIRECTORY *dir;
+     HMODULE module = GetModuleHandleA("ntdll.dll");
+@@ -1615,8 +1615,13 @@ static void test_FakeDLL(void)
+ 
+         dll_func = (BYTE *)GetProcAddress(module, func_name);
+         ok(dll_func != NULL, "%s: GetProcAddress returned NULL\n", func_name);
++#if defined(__i386__)
+         if (dll_func[0] == 0x90 && dll_func[1] == 0x90 &&
+             dll_func[2] == 0x90 && dll_func[3] == 0x90)
++#elif defined(__x86_64__)
++        if (dll_func[0] == 0x48 && dll_func[1] == 0x83 &&
++            dll_func[2] == 0xec && dll_func[3] == 0x08)
++#endif
+         {
+             todo_wine ok(0, "%s: Export is a stub-function, skipping\n", func_name);
+             continue;
+diff --git a/dlls/ntdll/signal_x86_64.c b/dlls/ntdll/signal_x86_64.c
+index 5defcd6a7af..c2936045c5d 100644
+--- a/dlls/ntdll/signal_x86_64.c
++++ b/dlls/ntdll/signal_x86_64.c
+@@ -354,6 +354,7 @@ static inline void set_sigcontext( const CONTEXT *context, ucontext_t *sigcontex
+ #endif
+ }
+ 
++extern void DECLSPEC_NORETURN __wine_syscall_dispatcher( void );
+ 
+ /***********************************************************************
+  * Definitions for Win32 unwind tables
+@@ -3142,6 +3143,7 @@ void signal_init_threading(void)
+  */
+ NTSTATUS signal_alloc_thread( TEB *teb )
+ {
++    teb->WOW32Reserved = __wine_syscall_dispatcher;
+     return STATUS_SUCCESS;
+ }
+ 
+diff --git a/dlls/ntdll/thread.c b/dlls/ntdll/thread.c
+index e5ff24f34f1..ddaf41637d0 100644
+--- a/dlls/ntdll/thread.c
++++ b/dlls/ntdll/thread.c
+@@ -56,6 +56,8 @@ WINE_DEFAULT_DEBUG_CHANNEL(thread);
+ 
+ struct _KUSER_SHARED_DATA *user_shared_data = NULL;
+ 
++extern void DECLSPEC_NORETURN __wine_syscall_dispatcher( void );
++
+ void (WINAPI *kernel32_start_process)(LPTHREAD_START_ROUTINE,void*) = NULL;
+ 
+ /* info passed to a starting thread */
+@@ -267,9 +269,9 @@ TEB *thread_init(void)
+     /* reserve space for shared user data */
+ 
+     addr = (void *)0x7ffe0000;
+-    size = 0x1000;
++    size = 0x2000;
+     status = NtAllocateVirtualMemory( NtCurrentProcess(), &addr, 0, &size,
+-                                      MEM_RESERVE|MEM_COMMIT, PAGE_READONLY );
++                                      MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE );
+     if (status)
+     {
+         MESSAGE( "wine: failed to map the shared user data: %08x\n", status );
+@@ -277,6 +279,13 @@ TEB *thread_init(void)
+     }
+     user_shared_data = addr;
+ 
++#if defined(__APPLE__) && defined(__x86_64__)
++    *((DWORD*)((char*)user_shared_data + 0x1000)) = __wine_syscall_dispatcher;
++#endif
++
++    /* Init this field early for x86_64 syscall thunks. */
++    user_shared_data->SystemCallPad[0] = 1;
++
+     /* allocate and initialize the PEB and initial TEB */
+ 
+     teb = virtual_alloc_first_teb();
+diff --git a/libs/wine/loader.c b/libs/wine/loader.c
+index 4597a6cb324..3d0d75e9c6d 100644
+--- a/libs/wine/loader.c
++++ b/libs/wine/loader.c
+@@ -398,7 +398,11 @@ static void *map_dll( const IMAGE_NT_HEADERS *nt_descr )
+     sec->SizeOfRawData = code_end - code_start;
+     sec->Misc.VirtualSize = sec->SizeOfRawData;
+     sec->VirtualAddress   = code_start;
++#ifdef _WIN64
++    sec->PointerToRawData = 0x400; /* file alignment */
++#else
+     sec->PointerToRawData = 0x200; /* file alignment */
++#endif
+     sec->Characteristics  = (IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ);
+     sec++;
+ 
+diff --git a/server/mapping.c b/server/mapping.c
+index 0941dd87c05..002f3215af2 100644
+--- a/server/mapping.c
++++ b/server/mapping.c
+@@ -964,7 +964,11 @@ struct object *create_user_data_mapping( struct object *root, const struct unico
+     if (!(mapping = create_mapping( root, name, OBJ_OPENIF, sizeof(KSHARED_USER_DATA),
+                                     SEC_COMMIT, 0, FILE_READ_DATA | FILE_WRITE_DATA, NULL ))) return NULL;
+     ptr = mmap( NULL, mapping->size, PROT_WRITE, MAP_SHARED, get_unix_fd( mapping->fd ), 0 );
+-    if (ptr != MAP_FAILED) user_shared_data = ptr;
++    if (ptr != MAP_FAILED)
++    {
++        user_shared_data = ptr;
++        user_shared_data->SystemCallPad[0] = 1;
++    }
+     return &mapping->obj;
+ }
+ 
+diff --git a/tools/winebuild/parser.c b/tools/winebuild/parser.c
+index 74216f8bb6e..820516329a4 100644
+--- a/tools/winebuild/parser.c
++++ b/tools/winebuild/parser.c
+@@ -545,7 +545,7 @@ static const char *parse_spec_flags( DLLSPEC *spec, ORDDEF *odp )
+ 
+ static int needs_syscall( ORDDEF *odp, DLLSPEC *spec )
+ {
+-    if (target_cpu != CPU_x86)
++    if (target_cpu != CPU_x86 && target_cpu != CPU_x86_64)
+         return 0;
+     if (odp->flags & (FLAG_FORWARD | FLAG_REGISTER))
+         return 0;
+diff --git a/tools/winebuild/spec32.c b/tools/winebuild/spec32.c
+index 07d6eed05fc..9cc4698d0d7 100644
+--- a/tools/winebuild/spec32.c
++++ b/tools/winebuild/spec32.c
+@@ -375,11 +375,11 @@ static void output_relay_debug( DLLSPEC *spec )
+ }
+ 
+ /*******************************************************************
+- *         output_syscall_thunks
++ *         output_syscall_thunks_x86
+  *
+  * Output entry points for system call functions
+  */
+-static void output_syscall_thunks( DLLSPEC *spec )
++static void output_syscall_thunks_x86( DLLSPEC *spec )
+ {
+     const unsigned int page_size = get_page_size();
+     int i;
+@@ -488,6 +488,157 @@ static void output_syscall_thunks( DLLSPEC *spec )
+     output_function_size( "__wine_syscall_dispatcher" );
+ }
+ 
++/*******************************************************************
++ *         output_syscall_thunks_x64
++ *
++ * Output entry points for system call functions
++ */
++static void output_syscall_thunks_x64( DLLSPEC *spec )
++{
++    const unsigned int page_size = get_page_size();
++    int i;
++
++    if (!spec->nb_syscalls)
++        return;
++
++    /* Reserve space for PE header directly before syscalls. */
++    if (target_platform == PLATFORM_APPLE)
++        output( "\t.text\n" );
++    else
++        output( "\n\t.section \".text.startup\"\n" );
++
++    output( "\t.align %d\n", get_alignment(65536) );
++    output( "__wine_spec_pe_header_syscalls:\n" );
++    output( "__wine_spec_pe_header_syscalls_end:\n" );
++    output( "\t.byte 0\n" );
++    output( "\t.balign %d, 0\n", page_size );
++
++    output( "\n/* syscall thunks */\n\n" );
++    for (i = 0; i < spec->nb_syscalls; i++)
++    {
++        ORDDEF *odp = spec->syscalls[i];
++        const char *name = odp->link_name;
++
++        /* Chromium depends on syscall thunks having the same form as on
++         * Windows. For 64-bit systems the only viable form we can emulate is
++         * having an int $0x2e fallback. Since actually using an interrupt is
++         * expensive, and since for some reason Chromium doesn't actually
++         * validate that instruction, we can just put a jmp there instead. */
++
++        output( "\t.balign 16, 0\n" );
++        output( "\t%s\n", func_declaration(name) );
++        output( "%s\n", asm_globl(name) );
++        output_cfi( ".cfi_startproc" );
++        output( "\t.byte 0x4c,0x8b,0xd1\n" );                               /* mov r10, rcx */
++        output( "\t.byte 0xb8\n" );                                         /* mov eax, SYSCALL */
++        output( "\t.long %d\n", i );
++        output( "\t.byte 0xf6,0x04,0x25,0x08,0x03,0xfe,0x7f,0x01\n" );      /* test byte ptr [0x7ffe0308], 1 */
++        output( "\t.byte 0x75,0x03\n" );                                    /* jne (over syscall) */
++        output( "\t.byte 0x0f,0x05\n" );                                    /* syscall */
++        output( "\t.byte 0xc3\n" );                                         /* ret */
++        output( "\t.byte 0xeb,0x01\n" );                                    /* jmp over ret */
++        output( "\t.byte 0xc3\n" );                                         /* ret */
++        if (target_platform == PLATFORM_APPLE)
++        {
++            output( "\t.byte 0xff,0x14,0x25\n" );                           /* call [0x7ffe1000] */
++            output( "\t.long 0x7ffe1000\n" );
++        }
++        else
++        {
++            output( "\t.byte 0x65,0xff,0x14,0x25\n" );                      /* call qword ptr gs:[0x100] */
++            output( "\t.long 0x100\n");
++        }
++        /* This RET is never reached, but Legends of Runeterra demands that it
++         * exist anyway. */
++        output( "\t.byte 0xc3\n" );                                         /* ret */
++        output_cfi( ".cfi_endproc" );
++        output_function_size( name );
++    }
++
++    for (i = 0; i < 0x20; i++)
++        output( "\t.byte 0\n" );
++
++    output( "\n/* syscall table */\n\n" );
++    output( "\t.data\n" );
++    output( "%s\n", asm_globl("__wine_syscall_table") );
++    for (i = 0; i < spec->nb_syscalls; i++)
++    {
++        ORDDEF *odp = spec->syscalls[i];
++        output ("\t%s %s\n", get_asm_ptr_keyword(), asm_name(odp->impl_name) );
++    }
++
++    output( "\n/* syscall argument stack size table */\n\n" );
++    output( "\t.data\n" );
++    output( "%s\n", asm_globl("__wine_syscall_stack_size") );
++    for (i = 0; i < spec->nb_syscalls; i++)
++    {
++        ORDDEF *odp = spec->syscalls[i];
++        output( "\t.byte %d\n", max(get_args_size(odp), 32) - 32 );
++    }
++
++    output( "\n/* syscall dispatcher */\n\n" );
++    output( "\t.text\n" );
++    output( "\t.align %d\n", get_alignment(16) );
++    output( "\t%s\n", func_declaration("__wine_syscall_dispatcher") );
++    output( "%s\n", asm_globl("__wine_syscall_dispatcher") );
++
++    /* prologue */
++    output_cfi( ".cfi_startproc" );
++    output( "\tpushq %%rbp\n" );
++    output_cfi( ".cfi_adjust_cfa_offset 8" );
++    output_cfi( ".cfi_rel_offset %%rbp,0" );
++    output( "\tmovq %%rsp,%%rbp\n" );
++    output_cfi( ".cfi_def_cfa_register %%rbp" );
++    output( "\tpushq %%rsi\n" );
++    output_cfi( ".cfi_rel_offset %%rsi,-8" );
++    output( "\tpushq %%rdi\n" );
++    output_cfi( ".cfi_rel_offset %%rdi,-16" );
++
++    /* Legends of Runeterra hooks the first system call return instruction, and
++     * depends on us returning to it. Adjust the return address accordingly. */
++    if (target_platform == PLATFORM_APPLE)
++        output( "\tsubq $0xb,0x8(%%rbp)\n" );
++    else
++        output( "\tsubq $0xc,0x8(%%rbp)\n" );
++
++    /* copy over any arguments on the stack */
++    output( "\tleaq 0x38(%%rbp),%%rsi\n" );
++    if (UsePIC)
++    {
++        output( "\tleaq (%%rip), %%r11\n" );
++        output( "1:\tmovzbq (%s-1b)(%%r11,%%rax,1),%%rcx\n", asm_name("__wine_syscall_stack_size") );
++    }
++    else
++        output( "\tmovzbq %s(%%rax),%%rcx\n", asm_name("__wine_syscall_stack_size") );
++    output( "\tsubq %%rcx,%%rsp\n" );
++    output( "\tand $~0xf,%%rsp\n\t" ); /* ensure stack alignment. */
++    output( "\tshrq $3,%%rcx\n" );
++    output( "\tmovq %%rsp,%%rdi\n" );
++    output( "\trep; movsq\n" );
++
++    /* call the function */
++    output( "\tmovq %%r10,%%rcx\n" );
++    output( "\tsubq $0x20,%%rsp\n" );
++    if (UsePIC)
++        output( "\tcallq *(%s-1b)(%%r11,%%rax,%d)\n", asm_name("__wine_syscall_table"), get_ptr_size() );
++    else
++        output( "\tcallq *%s(,%%rax,%d)\n", asm_name("__wine_syscall_table"), get_ptr_size() );
++    output( "\tleaq -0x10(%%rbp),%%rsp\n" );
++
++    /* epilogue */
++    output( "\tpopq %%rdi\n" );
++    output_cfi( ".cfi_same_value %%rdi" );
++    output( "\tpopq %%rsi\n" );
++    output_cfi( ".cfi_same_value %%rsi" );
++    output_cfi( ".cfi_def_cfa_register %%rsp" );
++    output( "\tpopq %%rbp\n" );
++    output_cfi( ".cfi_adjust_cfa_offset -8" );
++    output_cfi( ".cfi_same_value %%rbp" );
++    output( "\tret\n" );
++    output_cfi( ".cfi_endproc" );
++    output_function_size( "__wine_syscall_dispatcher" );
++}
++
+ /*******************************************************************
+  *         output_exports
+  *
+@@ -845,7 +996,10 @@ void output_spec32_file( DLLSPEC *spec )
+     open_output_file();
+     output_standard_file_header();
+     output_module( spec );
+-    output_syscall_thunks( spec );
++    if (target_cpu == CPU_x86)
++        output_syscall_thunks_x86( spec );
++    else if (target_cpu == CPU_x86_64)
++        output_syscall_thunks_x64( spec );
+     output_stubs( spec );
+     output_exports( spec );
+     output_imports( spec );
+@@ -858,7 +1012,7 @@ void output_spec32_file( DLLSPEC *spec )
+ 
+ static int needs_stub_exports( DLLSPEC *spec )
+ {
+-    if (target_cpu != CPU_x86)
++    if (target_cpu != CPU_x86 && target_cpu != CPU_x86_64)
+         return 0;
+     if (!(spec->characteristics & IMAGE_FILE_DLL))
+         return 0;
+@@ -868,7 +1022,7 @@ static int needs_stub_exports( DLLSPEC *spec )
+ }
+ 
+ 
+-static void create_stub_exports_text( DLLSPEC *spec )
++static void create_stub_exports_text_x86( DLLSPEC *spec )
+ {
+     int i, nr_exports = spec->base <= spec->limit ? spec->limit - spec->base + 1 : 0;
+     size_t rva, thunk;
+@@ -1026,6 +1180,122 @@ static void create_stub_exports_text( DLLSPEC *spec )
+ }
+ 
+ 
++static void create_stub_exports_text_x64( DLLSPEC *spec )
++{
++    int i, nr_exports = spec->base <= spec->limit ? spec->limit - spec->base + 1 : 0;
++
++    /* output syscalls */
++    for (i = 0; i < spec->nb_syscalls; i++)
++    {
++        ORDDEF *odp = spec->syscalls[i];
++
++        align_output_rva( 16, 16 );
++        put_label( odp->link_name );
++        put_byte( 0x4c ); put_byte( 0x8b ); put_byte( 0xd1 );  /* mov r10, rcx */
++        put_byte( 0xb8 ); put_dword( i );                      /* mov eax, SYSCALL */
++        put_byte( 0xf6 ); put_byte( 0x04 ); put_byte( 0x25 );  /* test byte ptr [0x7ffe0308], 1 */
++                put_byte( 0x08 ); put_byte( 0x03 ); put_byte( 0xfe );
++                put_byte( 0x7f ); put_byte( 0x01 );
++        put_byte( 0x75 ); put_byte( 0x03 );                    /* jne */
++        put_byte( 0x0f ); put_byte( 0x05 );                    /* syscall */
++        put_byte( 0xc3 );                                      /* ret */
++        put_byte( 0xeb ); put_byte( 0x01 );                    /* jmp */
++        put_byte( 0xc3 );                                      /* ret */
++        if (target_platform == PLATFORM_APPLE)
++        {
++            put_byte( 0xff ); put_byte( 0x14 );                /* call [0x7ffe1000] */
++            put_byte( 0x25 ); put_dword( 0x7ffe1000 );
++        }
++        else
++        {
++            put_byte( 0x65 ); put_byte( 0xff );                /* call ptr gs:[0x100] */
++            put_byte( 0x14 ); put_byte( 0x25 ); put_dword( 0x100 );
++
++        }
++        put_byte( 0xc3 );                                      /* ret */
++    }
++
++    if (spec->nb_syscalls)
++    {
++        for (i = 0; i < 0x20; i++)
++            put_byte( 0 );
++    }
++
++    /* output stub code for exports */
++    for (i = 0; i < spec->nb_entry_points; i++)
++    {
++        ORDDEF *odp = &spec->entry_points[i];
++        const char *name;
++
++        if (odp->flags & FLAG_SYSCALL)
++            continue;
++
++        align_output_rva( 16, 16 );
++        name = get_stub_name( odp, spec );
++        put_label( name );
++        put_byte( 0xcc );                                             /* int $0x3 */
++        put_byte( 0xc3 );                                             /* ret */
++    }
++
++    /* output entry point */
++    align_output_rva( 16, 16 );
++    put_label( "entrypoint" );
++    put_byte( 0xb8 ); put_dword( 1 );                                 /* mov rax, 1 */
++    put_byte( 0xc3 );                                                 /* ret */
++
++    /* export directory */
++    align_output_rva( 16, 16 );
++    put_label( "export_start" );
++    put_dword( 0 );                             /* Characteristics */
++    put_dword( 0 );                             /* TimeDateStamp */
++    put_dword( 0 );                             /* MajorVersion/MinorVersion */
++    put_dword( label_rva("dll_name") );         /* Name */
++    put_dword( spec->base );                    /* Base */
++    put_dword( nr_exports );                    /* NumberOfFunctions */
++    put_dword( spec->nb_names );                /* NumberOfNames */
++    put_dword( label_rva("export_funcs") );     /* AddressOfFunctions */
++    put_dword( label_rva("export_names") );     /* AddressOfNames */
++    put_dword( label_rva("export_ordinals") );  /* AddressOfNameOrdinals */
++
++    put_label( "export_funcs" );
++    for (i = spec->base; i <= spec->limit; i++)
++    {
++        ORDDEF *odp = spec->ordinals[i];
++        if (odp)
++        {
++            const char *name = (odp->flags & FLAG_SYSCALL) ? odp->link_name : get_stub_name( odp, spec );
++            put_dword( label_rva( name ) );
++        }
++        else
++            put_dword( 0 );
++    }
++
++    if (spec->nb_names)
++    {
++        put_label( "export_names" );
++        for (i = 0; i < spec->nb_names; i++)
++            put_dword( label_rva(strmake("str_%s", get_stub_name(spec->names[i], spec))) );
++
++        put_label( "export_ordinals" );
++        for (i = 0; i < spec->nb_names; i++)
++            put_word( spec->names[i]->ordinal - spec->base );
++        if (spec->nb_names % 2)
++            put_word( 0 );
++    }
++
++    put_label( "dll_name" );
++    put_str( spec->file_name );
++
++    for (i = 0; i < spec->nb_names; i++)
++    {
++        put_label( strmake("str_%s", get_stub_name(spec->names[i], spec)) );
++        put_str( spec->names[i]->name );
++    }
++
++    put_label( "export_end" );
++}
++
++
+ static void create_stub_exports_data( DLLSPEC *spec )
+ {
+     int i;
+@@ -1225,7 +1495,10 @@ static void output_fake_module_pass( DLLSPEC *spec )
+     if (needs_stub_exports( spec ))
+     {
+         put_label( "text_start" );
+-        create_stub_exports_text( spec );
++        if (target_cpu == CPU_x86)
++            create_stub_exports_text_x86( spec );
++        else if (target_cpu == CPU_x86_64)
++            create_stub_exports_text_x64( spec );
+         put_label( "text_end" );
+     }
+     else
+-- 
+2.26.2
+
diff --git a/patches/winebuild-Fake_Dlls/0011-ntdll-Call-NtOpenFile-through-syscall-thunk.patch b/patches/winebuild-Fake_Dlls/0011-ntdll-Call-NtOpenFile-through-syscall-thunk.patch
new file mode 100644
index 00000000..69ee26be
--- /dev/null
+++ b/patches/winebuild-Fake_Dlls/0011-ntdll-Call-NtOpenFile-through-syscall-thunk.patch
@@ -0,0 +1,132 @@
+From 659e192979eecfb59d1c1b26e8cea78c42300de5 Mon Sep 17 00:00:00 2001
+From: Paul Gofman <gofmanp@gmail.com>
+Date: Fri, 3 Jan 2020 17:39:08 +0300
+Subject: [PATCH] ntdll: Call NtOpenFile through syscall thunk.
+
+Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=48410
+---
+ dlls/ntdll/actctx.c     | 4 ++--
+ dlls/ntdll/directory.c  | 2 +-
+ dlls/ntdll/loader.c     | 2 +-
+ dlls/ntdll/locale.c     | 4 ++--
+ dlls/ntdll/ntdll_misc.h | 8 ++++++++
+ dlls/ntdll/path.c       | 2 +-
+ dlls/ntdll/process.c    | 2 +-
+ 7 files changed, 16 insertions(+), 8 deletions(-)
+
+diff --git a/dlls/ntdll/actctx.c b/dlls/ntdll/actctx.c
+index 1ca794ae3e5..b3c13042adc 100644
+--- a/dlls/ntdll/actctx.c
++++ b/dlls/ntdll/actctx.c
+@@ -2892,7 +2892,7 @@ static NTSTATUS open_nt_file( HANDLE *handle, UNICODE_STRING *name )
+     attr.ObjectName = name;
+     attr.SecurityDescriptor = NULL;
+     attr.SecurityQualityOfService = NULL;
+-    return NtOpenFile( handle, GENERIC_READ | SYNCHRONIZE, &attr, &io, FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_ALERT );
++    return __syscall_NtOpenFile( handle, GENERIC_READ | SYNCHRONIZE, &attr, &io, FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_ALERT );
+ }
+ 
+ static NTSTATUS get_manifest_in_module( struct actctx_loader* acl, struct assembly_identity* ai,
+@@ -3209,7 +3209,7 @@ static NTSTATUS lookup_winsxs(struct actctx_loader* acl, struct assembly_identit
+     attr.SecurityDescriptor = NULL;
+     attr.SecurityQualityOfService = NULL;
+ 
+-    if (!NtOpenFile( &handle, GENERIC_READ | SYNCHRONIZE, &attr, &io, FILE_SHARE_READ | FILE_SHARE_WRITE,
++    if (!__syscall_NtOpenFile( &handle, GENERIC_READ | SYNCHRONIZE, &attr, &io, FILE_SHARE_READ | FILE_SHARE_WRITE,
+                      FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT ))
+     {
+         sxs_ai = *ai;
+diff --git a/dlls/ntdll/directory.c b/dlls/ntdll/directory.c
+index d18df38f626..69607a4fed9 100644
+--- a/dlls/ntdll/directory.c
++++ b/dlls/ntdll/directory.c
+@@ -2943,7 +2943,7 @@ NTSTATUS DIR_get_unix_cwd( char **cwd )
+         attr.SecurityDescriptor = NULL;
+         attr.SecurityQualityOfService = NULL;
+ 
+-        status = NtOpenFile( &handle, SYNCHRONIZE, &attr, &io, 0,
++        status = __syscall_NtOpenFile( &handle, SYNCHRONIZE, &attr, &io, 0,
+                              FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT );
+         RtlFreeUnicodeString( &dirW );
+         if (status != STATUS_SUCCESS) goto done;
+diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
+index 0b8c28a0651..e48cd84cffd 100644
+--- a/dlls/ntdll/loader.c
++++ b/dlls/ntdll/loader.c
+@@ -2469,7 +2469,7 @@ static NTSTATUS open_dll_file( UNICODE_STRING *nt_name, WINE_MODREF **pwm,
+     attr.ObjectName = nt_name;
+     attr.SecurityDescriptor = NULL;
+     attr.SecurityQualityOfService = NULL;
+-    if ((status = NtOpenFile( &handle, GENERIC_READ | SYNCHRONIZE, &attr, &io,
++    if ((status = __syscall_NtOpenFile( &handle, GENERIC_READ | SYNCHRONIZE, &attr, &io,
+                               FILE_SHARE_READ | FILE_SHARE_DELETE,
+                               FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE )))
+     {
+diff --git a/dlls/ntdll/locale.c b/dlls/ntdll/locale.c
+index 0d0c1194d23..a1bf219ed0a 100644
+--- a/dlls/ntdll/locale.c
++++ b/dlls/ntdll/locale.c
+@@ -661,7 +661,7 @@ static NTSTATUS open_nls_data_file( ULONG type, ULONG id, HANDLE *file )
+         return STATUS_NO_MEMORY;
+     valueW.Length = NTDLL_swprintf( valueW.Buffer, pathfmtW, dir, name ) * sizeof(WCHAR);
+     InitializeObjectAttributes( &attr, &valueW, 0, 0, NULL );
+-    status = NtOpenFile( file, GENERIC_READ, &attr, &io, FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_ALERT );
++    status = __syscall_NtOpenFile( file, GENERIC_READ, &attr, &io, FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_ALERT );
+     if (!status) TRACE( "found %s\n", debugstr_w( valueW.Buffer ));
+     RtlFreeUnicodeString( &valueW );
+     if (status != STATUS_OBJECT_NAME_NOT_FOUND && status != STATUS_OBJECT_PATH_NOT_FOUND) return status;
+@@ -685,7 +685,7 @@ static NTSTATUS open_nls_data_file( ULONG type, ULONG id, HANDLE *file )
+         wcscat( valueW.Buffer, name );
+         valueW.Length = wcslen(valueW.Buffer) * sizeof(WCHAR);
+         InitializeObjectAttributes( &attr, &valueW, 0, 0, NULL );
+-        status = NtOpenFile( file, GENERIC_READ, &attr, &io, FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_ALERT );
++        status = __syscall_NtOpenFile( file, GENERIC_READ, &attr, &io, FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_ALERT );
+         if (!status) TRACE( "found %s\n", debugstr_w( valueW.Buffer ));
+     }
+     RtlFreeUnicodeString( &valueW );
+diff --git a/dlls/ntdll/ntdll_misc.h b/dlls/ntdll/ntdll_misc.h
+index 2e791b92f73..f8170793185 100644
+--- a/dlls/ntdll/ntdll_misc.h
++++ b/dlls/ntdll/ntdll_misc.h
+@@ -350,4 +350,12 @@ static inline void ascii_to_unicode( WCHAR *dst, const char *src, size_t len )
+     while (len--) *dst++ = (unsigned char)*src++;
+ }
+ 
++#if defined(__i386__) || defined(__x86_64__)
++NTSTATUS WINAPI __syscall_NtOpenFile( PHANDLE handle, ACCESS_MASK access,
++                            POBJECT_ATTRIBUTES attr, PIO_STATUS_BLOCK io,
++                            ULONG sharing, ULONG options );
++#else
++#define __syscall_NtOpenFile NtOpenFile
++#endif
++
+ #endif
+diff --git a/dlls/ntdll/path.c b/dlls/ntdll/path.c
+index 32e1f951af5..71ae44dd498 100644
+--- a/dlls/ntdll/path.c
++++ b/dlls/ntdll/path.c
+@@ -1020,7 +1020,7 @@ NTSTATUS WINAPI RtlSetCurrentDirectory_U(const UNICODE_STRING* dir)
+     attr.SecurityDescriptor = NULL;
+     attr.SecurityQualityOfService = NULL;
+ 
+-    nts = NtOpenFile( &handle, FILE_TRAVERSE | SYNCHRONIZE, &attr, &io, FILE_SHARE_READ | FILE_SHARE_WRITE,
++    nts = __syscall_NtOpenFile( &handle, FILE_TRAVERSE | SYNCHRONIZE, &attr, &io, FILE_SHARE_READ | FILE_SHARE_WRITE,
+                       FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT );
+     if (nts != STATUS_SUCCESS) goto out;
+ 
+diff --git a/dlls/ntdll/process.c b/dlls/ntdll/process.c
+index 60ee39765bf..70dfe6f768a 100644
+--- a/dlls/ntdll/process.c
++++ b/dlls/ntdll/process.c
+@@ -1281,7 +1281,7 @@ static NTSTATUS get_pe_file_info( UNICODE_STRING *path, ULONG attributes,
+ 
+     memset( info, 0, sizeof(*info) );
+     InitializeObjectAttributes( &attr, path, attributes, 0, 0 );
+-    if ((status = NtOpenFile( handle, GENERIC_READ, &attr, &io,
++    if ((status = __syscall_NtOpenFile( handle, GENERIC_READ, &attr, &io,
+                               FILE_SHARE_READ | FILE_SHARE_DELETE, FILE_SYNCHRONOUS_IO_NONALERT )))
+     {
+         BOOL is_64bit;
+-- 
+2.26.2
+
diff --git a/patches/winebuild-pe_syscall_thunks/definition b/patches/winebuild-Fake_Dlls/definition
similarity index 88%
rename from patches/winebuild-pe_syscall_thunks/definition
rename to patches/winebuild-Fake_Dlls/definition
index 7b86a429..5ffc046f 100644
--- a/patches/winebuild-pe_syscall_thunks/definition
+++ b/patches/winebuild-Fake_Dlls/definition
@@ -1,5 +1,5 @@
 Fixes: [21232] Chromium-based browser engines (Chrome, Opera, Comodo Dragon, SRWare Iron) crash on startup unless '--no-sandbox' is used (native API sandboxing/hooking scheme incompatible with Wine)
 Fixes: [42741] StarCraft I: 1.18 PTR fails to initialize ClientSdk.dll
-Fixes: [45349] Multiple applications and games crash due to missing support for 64-bit syscall thunks (StreetFighter V, World of Warcraft)
+Fixes: [45349] Multiple applications and games crash due to missing support for 64-bit syscall thunks (StreetFighter V)
 Fixes: [45573] League of Legends 8.12+ fails to start a game (anticheat engine, hooking of syscall return instructions)
 Fixes: [45650] chromium 32-bit sandbox expects different syscall thunks depending on Windows version
diff --git a/patches/winebuild-pe_syscall_thunks/0002-winebuild-Call-__wine_syscall_dispatcher-through-the.patch b/patches/winebuild-pe_syscall_thunks/0002-winebuild-Call-__wine_syscall_dispatcher-through-the.patch
deleted file mode 100644
index 595e4599..00000000
--- a/patches/winebuild-pe_syscall_thunks/0002-winebuild-Call-__wine_syscall_dispatcher-through-the.patch
+++ /dev/null
@@ -1,77 +0,0 @@
-From 699069081ca58f401501f9fda60ccc6ef6187470 Mon Sep 17 00:00:00 2001
-From: Paul Gofman <pgofman@codeweavers.com>
-Date: Tue, 14 Jul 2020 14:43:01 +0300
-Subject: [PATCH] winebuild: Call __wine_syscall_dispatcher through the fixed
- address.
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Based on a patch by Erich E. Hoover and Michael Mller.
-
-Helps applications which directly load ntdll.dll from disk and
-call syscall thunks from the loaded image.
----
- dlls/ntdll/unix/virtual.c | 6 ++++--
- tools/winebuild/import.c  | 8 ++++----
- 2 files changed, 8 insertions(+), 6 deletions(-)
-
-diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
-index 3af5241ee30..7b0ebf4dda7 100644
---- a/dlls/ntdll/unix/virtual.c
-+++ b/dlls/ntdll/unix/virtual.c
-@@ -2815,20 +2815,22 @@ TEB *virtual_alloc_first_teb(void)
-     PEB *peb;
-     void *ptr;
-     NTSTATUS status;
--    SIZE_T data_size = page_size;
-+    SIZE_T data_size = page_size * 2;
-     SIZE_T peb_size = page_size * (is_win64 ? 1 : 2);
-     SIZE_T block_size = signal_stack_mask + 1;
-     SIZE_T total = 32 * block_size;
- 
-     /* reserve space for shared user data */
-     status = NtAllocateVirtualMemory( NtCurrentProcess(), (void **)&user_shared_data, 0, &data_size,
--                                      MEM_RESERVE | MEM_COMMIT, PAGE_READONLY );
-+                                      MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE );
-     if (status)
-     {
-         ERR( "wine: failed to map the shared user data: %08x\n", status );
-         exit(1);
-     }
- 
-+    *((void **)((char *)user_shared_data + 0x1000)) = __wine_syscall_dispatcher;
-+
-     NtAllocateVirtualMemory( NtCurrentProcess(), &teb_block, 0, &total,
-                              MEM_RESERVE | MEM_TOP_DOWN, PAGE_READWRITE );
-     teb_block_pos = 30;
-diff --git a/tools/winebuild/import.c b/tools/winebuild/import.c
-index 461f1851d61..b90d93ca5db 100644
---- a/tools/winebuild/import.c
-+++ b/tools/winebuild/import.c
-@@ -1710,10 +1710,10 @@ void output_syscalls( DLLSPEC *spec )
-             output( "\t.byte 0xc3\n" );           /* ret */
-             output( "\tjmp 1f\n" );
-             output( "\t.byte 0xc3\n" );           /* ret */
--            if (target_platform == PLATFORM_WINDOWS)
-+            if (target_platform == PLATFORM_WINDOWS || target_platform == PLATFORM_APPLE)
-             {
--                output( "1:\t.byte 0xff,0x14,0x25\n" ); /* 1: callq *(__wine_syscall_dispatcher) */
--                output( "\t.long __wine_syscall_dispatcher\n" );
-+                output( "1:\t.byte 0xff,0x14,0x25\n" ); /* call *(user_shared_data + 0x1000) */
-+                output( "\t.long 0x7ffe1000\n" );
-             }
-             else
-             {
-@@ -1754,7 +1754,7 @@ void output_syscalls( DLLSPEC *spec )
-         output( "\t.align %d\n", get_alignment(16) );
-         output( "\t%s\n", func_declaration("__wine_syscall") );
-         output( "%s:\n", asm_name("__wine_syscall") );
--        output( "\tjmp *(%s)\n", asm_name("__wine_syscall_dispatcher") );
-+        output( "\tjmp *(0x7ffe1000)\n" );
-         output_function_size( "__wine_syscall" );
-     }
-     output( "\t.data\n" );
--- 
-2.28.0
-
diff --git a/patches/winedevice-Default_Drivers/0004-programs-winedevice-Load-some-common-drivers-and-fix.patch b/patches/winedevice-Default_Drivers/0004-programs-winedevice-Load-some-common-drivers-and-fix.patch
index 8223f94f..21c7373a 100644
--- a/patches/winedevice-Default_Drivers/0004-programs-winedevice-Load-some-common-drivers-and-fix.patch
+++ b/patches/winedevice-Default_Drivers/0004-programs-winedevice-Load-some-common-drivers-and-fix.patch
@@ -1,4 +1,4 @@
-From b230ad8676c16e2c02b6c317b0c050494225c696 Mon Sep 17 00:00:00 2001
+From d67ca0757315f863020402e44c50b89f08be3ae6 Mon Sep 17 00:00:00 2001
 From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
 Date: Thu, 8 Jun 2017 23:50:03 +0200
 Subject: [PATCH] programs/winedevice: Load some common drivers and fix ldr
@@ -10,7 +10,7 @@ Subject: [PATCH] programs/winedevice: Load some common drivers and fix ldr
  2 files changed, 76 insertions(+)
 
 diff --git a/dlls/ntoskrnl.exe/tests/driver.c b/dlls/ntoskrnl.exe/tests/driver.c
-index 0671a56efc7..85327c6f4b3 100644
+index fa8d7b20e3e..176b60d66ad 100644
 --- a/dlls/ntoskrnl.exe/tests/driver.c
 +++ b/dlls/ntoskrnl.exe/tests/driver.c
 @@ -46,6 +46,7 @@ static const WCHAR driver_link[] = {'\\','D','o','s','D','e','v','i','c','e','s'
@@ -29,8 +29,8 @@ index 0671a56efc7..85327c6f4b3 100644
  static void test_lookup_thread(void)
  {
      NTSTATUS status;
-@@ -2072,6 +2074,52 @@ static void test_permanence(void)
-     ok(status == STATUS_OBJECT_NAME_NOT_FOUND, "got %#x\n", status);
+@@ -1996,6 +1998,52 @@ static void test_process_memory(const struct test_input *test_input)
+     ObDereferenceObject(process);
  }
  
 +static void test_default_modules(void)
@@ -82,7 +82,7 @@ index 0671a56efc7..85327c6f4b3 100644
  static NTSTATUS main_test(DEVICE_OBJECT *device, IRP *irp, IO_STACK_LOCATION *stack)
  {
      ULONG length = stack->Parameters.DeviceIoControl.OutputBufferLength;
-@@ -2118,6 +2166,7 @@ static NTSTATUS main_test(DEVICE_OBJECT *device, IRP *irp, IO_STACK_LOCATION *st
+@@ -2042,6 +2090,7 @@ static NTSTATUS main_test(DEVICE_OBJECT *device, IRP *irp, IO_STACK_LOCATION *st
      test_stack_callout();
      test_lookaside_list();
      test_ob_reference(test_input->path);
@@ -90,7 +90,7 @@ index 0671a56efc7..85327c6f4b3 100644
      test_resource();
      test_lookup_thread();
      test_IoAttachDeviceToDeviceStack();
-@@ -2392,6 +2441,7 @@ NTSTATUS WINAPI DriverEntry(DRIVER_OBJECT *driver, PUNICODE_STRING registry)
+@@ -2296,6 +2345,7 @@ NTSTATUS WINAPI DriverEntry(DRIVER_OBJECT *driver, PUNICODE_STRING registry)
      DbgPrint("loading driver\n");
  
      driver_obj = driver;
@@ -137,5 +137,5 @@ index 0755caaafb0..6595788053e 100644
      if (!(stop_event = CreateEventW( NULL, TRUE, FALSE, NULL )))
          return;
 -- 
-2.27.0
+2.26.2
 
diff --git a/patches/wow64cpu-Wow64Transition/0002-ntdll-Add-a-stub-implementation-of-Wow64Transition.patch b/patches/wow64cpu-Wow64Transition/0002-ntdll-Add-a-stub-implementation-of-Wow64Transition.patch
index 9b9a53bc..3e655e0c 100644
--- a/patches/wow64cpu-Wow64Transition/0002-ntdll-Add-a-stub-implementation-of-Wow64Transition.patch
+++ b/patches/wow64cpu-Wow64Transition/0002-ntdll-Add-a-stub-implementation-of-Wow64Transition.patch
@@ -1,60 +1,66 @@
-From 85c9586902b2f1d197e0d6dcbde53a36b7803092 Mon Sep 17 00:00:00 2001
+From 68293a760784f2b4fd2fe79bbba443d76b17e11a Mon Sep 17 00:00:00 2001
 From: Zebediah Figura <z.figura12@gmail.com>
 Date: Wed, 8 Aug 2018 20:00:15 -0500
 Subject: [PATCH] ntdll: Add a stub implementation of Wow64Transition.
 
 ---
- dlls/ntdll/loader.c   | 10 +++++++++-
+ dlls/ntdll/loader.c   | 11 ++++++++++-
  dlls/ntdll/ntdll.spec |  1 +
- 2 files changed, 10 insertions(+), 1 deletion(-)
+ 2 files changed, 11 insertions(+), 1 deletion(-)
 
 diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
-index 0eac7fdb939..36c1a467562 100644
+index 6155996b7c4..0e99604eb2b 100644
 --- a/dlls/ntdll/loader.c
 +++ b/dlls/ntdll/loader.c
-@@ -4181,6 +4181,7 @@ BOOL WINAPI DllMain( HINSTANCE inst, DWORD reason, LPVOID reserved )
-     return TRUE;
+@@ -4287,6 +4287,7 @@ NTSTATUS WINAPI NtLoadDriver( const UNICODE_STRING *DriverServiceName )
+     return STATUS_NOT_IMPLEMENTED;
  }
  
 +void *Wow64Transition;
  
  /***********************************************************************
-  *           restart_winevdm
-@@ -4217,7 +4218,7 @@ static NTSTATUS process_init(void)
+  *           NtUnloadDriver   (NTDLL.@)
+@@ -4345,12 +4346,13 @@ void __wine_process_init(void)
+     static const WCHAR ntdllW[] = {'\\','?','?','\\','C',':','\\','w','i','n','d','o','w','s','\\',
+                                    's','y','s','t','e','m','3','2','\\',
+                                    'n','t','d','l','l','.','d','l','l',0};
++    static const WCHAR wow64cpuW[] = {'w','o','w','6','4','c','p','u','.','d','l','l',0};
+     static const WCHAR kernel32W[] = {'\\','?','?','\\','C',':','\\','w','i','n','d','o','w','s','\\',
                                        's','y','s','t','e','m','3','2','\\',
                                        'k','e','r','n','e','l','3','2','.','d','l','l',0};
      RTL_USER_PROCESS_PARAMETERS *params;
+     ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION runlevel;
 -    WINE_MODREF *wm;
 +    WINE_MODREF *wm, *wow64cpu_wm;
      NTSTATUS status;
      ANSI_STRING func_name;
      UNICODE_STRING nt_name;
-@@ -4282,6 +4283,13 @@ static NTSTATUS process_init(void)
+@@ -4400,6 +4402,13 @@ void __wine_process_init(void)
          MESSAGE( "wine: could not load kernel32.dll, status %x\n", status );
-         NtTerminateProcess( GetCurrentProcess(), status );
+         exit(1);
      }
 +
-+    RtlInitUnicodeString( &nt_name, L"\\??\\C:\\windows\\system32\\wow64cpu.dll" );
++    RtlInitUnicodeString( &nt_name, wow64cpuW );
 +    if ((status = load_builtin_dll( NULL, &nt_name, 0, 0, &wow64cpu_wm )) == STATUS_SUCCESS)
 +        Wow64Transition = wow64cpu_wm->ldr.DllBase;
 +    else
 +        WARN( "could not load wow64cpu.dll, status %#x\n", status );
 +
-     RtlInitAnsiString( &func_name, "BaseThreadInitThunk" );
+     RtlInitAnsiString( &func_name, "__wine_start_process" );
      if ((status = LdrGetProcedureAddress( wm->ldr.DllBase, &func_name,
-                                           0, (void **)&pBaseThreadInitThunk )) != STATUS_SUCCESS)
+                                           0, (void **)&kernel32_start_process )) != STATUS_SUCCESS)
 diff --git a/dlls/ntdll/ntdll.spec b/dlls/ntdll/ntdll.spec
-index c0e9c681e1d..e343e66f4af 100644
+index b97eed0bc7d..9e2f6e418eb 100644
 --- a/dlls/ntdll/ntdll.spec
 +++ b/dlls/ntdll/ntdll.spec
-@@ -1124,6 +1124,7 @@
+@@ -1103,6 +1103,7 @@
  @ stdcall WinSqmIsOptedIn()
  @ stdcall WinSqmSetDWORD(ptr long long)
  @ stdcall WinSqmStartSession(ptr long long)
 +@ extern Wow64Transition
- @ stdcall -private -syscall ZwAcceptConnectPort(ptr long ptr long ptr ptr) NtAcceptConnectPort
- @ stdcall -private -syscall ZwAccessCheck(ptr long long ptr ptr ptr ptr ptr) NtAccessCheck
- @ stdcall -private -syscall ZwAccessCheckAndAuditAlarm(ptr long ptr ptr ptr long ptr long ptr ptr ptr) NtAccessCheckAndAuditAlarm
+ @ stdcall -private ZwAcceptConnectPort(ptr long ptr long ptr ptr) NtAcceptConnectPort
+ @ stdcall -private ZwAccessCheck(ptr long long ptr ptr ptr ptr ptr) NtAccessCheck
+ @ stdcall -private ZwAccessCheckAndAuditAlarm(ptr long ptr ptr ptr long ptr long ptr ptr ptr) NtAccessCheckAndAuditAlarm
 -- 
-2.28.0
+2.26.2
 
diff --git a/patches/wow64cpu-Wow64Transition/definition b/patches/wow64cpu-Wow64Transition/definition
index 52022c4d..2b682bf8 100644
--- a/patches/wow64cpu-Wow64Transition/definition
+++ b/patches/wow64cpu-Wow64Transition/definition
@@ -1 +1,2 @@
 Fixes: [45567] League of Legends 8.12+ fails to start a game (anticheat engine, validation of WoW64 syscall dispatcher)
+Depends: advapi32-Token_Integrity_Level
diff --git a/patches/wpcap-Dynamic_Linking/0001-wpcap-Load-libpcap-dynamically.patch b/patches/wpcap-Dynamic_Linking/0001-wpcap-Load-libpcap-dynamically.patch
index 4ad9fee8..143739f7 100644
--- a/patches/wpcap-Dynamic_Linking/0001-wpcap-Load-libpcap-dynamically.patch
+++ b/patches/wpcap-Dynamic_Linking/0001-wpcap-Load-libpcap-dynamically.patch
@@ -1,4 +1,4 @@
-From 317c7d9b27c4ebc9184e5225f505bb1ca782f464 Mon Sep 17 00:00:00 2001
+From 90ebd2a601712db291079151491b2f0f6ddba70b Mon Sep 17 00:00:00 2001
 From: =?UTF-8?q?Andr=C3=A9=20Hentschel?= <nerv@dawncrow.de>
 Date: Tue, 26 Aug 2014 00:59:37 +0200
 Subject: [PATCH] wpcap: Load libpcap dynamically.
@@ -8,14 +8,14 @@ Something we don't want i guess.
 ---
  configure.ac           |   4 +-
  dlls/wpcap/Makefile.in |   1 -
- dlls/wpcap/wpcap.c     | 172 ++++++++++++++++++++++++++++++++---------
- 3 files changed, 139 insertions(+), 38 deletions(-)
+ dlls/wpcap/wpcap.c     | 173 ++++++++++++++++++++++++++++++++---------
+ 3 files changed, 140 insertions(+), 38 deletions(-)
 
 diff --git a/configure.ac b/configure.ac
-index 006087e05ec..30d67574e26 100644
+index c58d34330..9e8066e93 100644
 --- a/configure.ac
 +++ b/configure.ac
-@@ -1370,9 +1370,9 @@ WINE_NOTICE_WITH(opencl,[test "x$ac_cv_lib_OpenCL_clGetPlatformInfo" != xyes],
+@@ -1317,9 +1317,9 @@ WINE_NOTICE_WITH(opencl,[test "x$ac_cv_lib_OpenCL_clGetPlatformInfo" != xyes],
  dnl **** Check for libpcap ****
  if test "$ac_cv_header_pcap_pcap_h" = "yes"
  then
@@ -28,7 +28,7 @@ index 006087e05ec..30d67574e26 100644
                   [enable_wpcap])
  
 diff --git a/dlls/wpcap/Makefile.in b/dlls/wpcap/Makefile.in
-index 91b4a955911..aeef71a46e5 100644
+index 91b4a9559..aeef71a46 100644
 --- a/dlls/wpcap/Makefile.in
 +++ b/dlls/wpcap/Makefile.in
 @@ -1,6 +1,5 @@
@@ -39,19 +39,20 @@ index 91b4a955911..aeef71a46e5 100644
  C_SRCS = \
  	wpcap.c
 diff --git a/dlls/wpcap/wpcap.c b/dlls/wpcap/wpcap.c
-index d2f1be7a312..67d3b789a41 100644
+index d2f1be7a3..c355fc6e1 100644
 --- a/dlls/wpcap/wpcap.c
 +++ b/dlls/wpcap/wpcap.c
-@@ -18,6 +18,8 @@
+@@ -18,6 +18,9 @@
   * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
   */
  
 +#include "config.h"
 +#include "wine/port.h"
++#include "wine/library.h"
  #include <pcap/pcap.h>
  
  /* pcap.h might define those: */
-@@ -63,47 +65,128 @@ static inline WCHAR *heap_strdupAtoW(const char *str)
+@@ -63,47 +66,128 @@ static inline WCHAR *heap_strdupAtoW(const char *str)
      return ret;
  }
  
@@ -187,7 +188,7 @@ index d2f1be7a312..67d3b789a41 100644
  }
  
  typedef struct
-@@ -132,10 +215,10 @@ int CDECL wine_pcap_dispatch(pcap_t *p, int cnt,
+@@ -132,10 +216,10 @@ int CDECL wine_pcap_dispatch(pcap_t *p, int cnt,
          PCAP_HANDLER_CALLBACK pcb;
          pcb.pfn_cb = callback;
          pcb.user_data = user;
@@ -200,7 +201,7 @@ index d2f1be7a312..67d3b789a41 100644
  }
  
  int CDECL wine_pcap_findalldevs(pcap_if_t **alldevsp, char *errbuf)
-@@ -143,7 +226,7 @@ int CDECL wine_pcap_findalldevs(pcap_if_t **alldevsp, char *errbuf)
+@@ -143,7 +227,7 @@ int CDECL wine_pcap_findalldevs(pcap_if_t **alldevsp, char *errbuf)
      int ret;
  
      TRACE("(%p %p)\n", alldevsp, errbuf);
@@ -209,7 +210,7 @@ index d2f1be7a312..67d3b789a41 100644
      if(alldevsp && !*alldevsp)
          ERR_(winediag)("Failed to access raw network (pcap), this requires special permissions.\n");
  
-@@ -159,13 +242,13 @@ int CDECL wine_pcap_findalldevs_ex(char *source, void *auth, pcap_if_t **alldevs
+@@ -159,13 +243,13 @@ int CDECL wine_pcap_findalldevs_ex(char *source, void *auth, pcap_if_t **alldevs
  void CDECL wine_pcap_freealldevs(pcap_if_t *alldevs)
  {
      TRACE("(%p)\n", alldevs);
@@ -225,7 +226,7 @@ index d2f1be7a312..67d3b789a41 100644
  }
  
  typedef struct _AirpcapHandle *PAirpcapHandle;
-@@ -178,18 +261,18 @@ PAirpcapHandle CDECL wine_pcap_get_airpcap_handle(pcap_t *p)
+@@ -178,18 +262,18 @@ PAirpcapHandle CDECL wine_pcap_get_airpcap_handle(pcap_t *p)
  char* CDECL wine_pcap_geterr(pcap_t *p)
  {
      TRACE("(%p)\n", p);
@@ -247,7 +248,7 @@ index d2f1be7a312..67d3b789a41 100644
      TRACE("%s\n", debugstr_a(ret));
      return ret;
  }
-@@ -197,7 +280,7 @@ const char* CDECL wine_pcap_lib_version(void)
+@@ -197,7 +281,7 @@ const char* CDECL wine_pcap_lib_version(void)
  int CDECL wine_pcap_list_datalinks(pcap_t *p, int **dlt_buffer)
  {
      TRACE("(%p %p)\n", p, dlt_buffer);
@@ -256,7 +257,7 @@ index d2f1be7a312..67d3b789a41 100644
  }
  
  char* CDECL wine_pcap_lookupdev(char *errbuf)
-@@ -208,10 +291,10 @@ char* CDECL wine_pcap_lookupdev(char *errbuf)
+@@ -208,10 +292,10 @@ char* CDECL wine_pcap_lookupdev(char *errbuf)
      TRACE("(%p)\n", errbuf);
      if (!ret)
      {
@@ -269,7 +270,7 @@ index d2f1be7a312..67d3b789a41 100644
      }
      return ret;
  }
-@@ -220,7 +303,7 @@ int CDECL wine_pcap_lookupnet(const char *device, unsigned int *netp, unsigned i
+@@ -220,7 +304,7 @@ int CDECL wine_pcap_lookupnet(const char *device, unsigned int *netp, unsigned i
                                char *errbuf)
  {
      TRACE("(%s %p %p %p)\n", debugstr_a(device), netp, maskp, errbuf);
@@ -278,7 +279,7 @@ index d2f1be7a312..67d3b789a41 100644
  }
  
  int CDECL wine_pcap_loop(pcap_t *p, int cnt,
-@@ -234,34 +317,34 @@ int CDECL wine_pcap_loop(pcap_t *p, int cnt,
+@@ -234,34 +318,34 @@ int CDECL wine_pcap_loop(pcap_t *p, int cnt,
          PCAP_HANDLER_CALLBACK pcb;
          pcb.pfn_cb = callback;
          pcb.user_data = user;
@@ -319,7 +320,7 @@ index d2f1be7a312..67d3b789a41 100644
  }
  
  #ifndef PCAP_OPENFLAG_PROMISCUOUS
-@@ -274,14 +357,14 @@ pcap_t* CDECL wine_pcap_open(const char *source, int snaplen, int flags, int rea
+@@ -274,14 +358,14 @@ pcap_t* CDECL wine_pcap_open(const char *source, int snaplen, int flags, int rea
      int promisc = flags & PCAP_OPENFLAG_PROMISCUOUS;
      FIXME("(%s %i %i %i %p %p): partial stub\n", debugstr_a(source), snaplen, flags, read_timeout,
                                                   auth, errbuf);
@@ -336,7 +337,7 @@ index d2f1be7a312..67d3b789a41 100644
  }
  
  int CDECL wine_pcap_parsesrcstr(const char *source, int *type, char *host, char *port, char *name, char *errbuf)
-@@ -325,13 +408,13 @@ int CDECL wine_pcap_parsesrcstr(const char *source, int *type, char *host, char
+@@ -325,13 +409,13 @@ int CDECL wine_pcap_parsesrcstr(const char *source, int *type, char *host, char
  int CDECL wine_pcap_sendpacket(pcap_t *p, const unsigned char *buf, int size)
  {
      TRACE("(%p %p %i)\n", p, buf, size);
@@ -352,7 +353,7 @@ index d2f1be7a312..67d3b789a41 100644
  }
  
  int CDECL wine_pcap_setbuff(pcap_t * p, int dim)
-@@ -343,25 +426,25 @@ int CDECL wine_pcap_setbuff(pcap_t * p, int dim)
+@@ -343,25 +427,25 @@ int CDECL wine_pcap_setbuff(pcap_t * p, int dim)
  int CDECL wine_pcap_setfilter(pcap_t *p, struct bpf_program *fp)
  {
      TRACE("(%p %p)\n", p, fp);
@@ -382,7 +383,7 @@ index d2f1be7a312..67d3b789a41 100644
  }
  
  int CDECL wine_wsockinit(void)
-@@ -387,7 +470,7 @@ pcap_dumper_t* CDECL wine_pcap_dump_open(pcap_t *p, const char *fname)
+@@ -387,7 +471,7 @@ pcap_dumper_t* CDECL wine_pcap_dump_open(pcap_t *p, const char *fname)
  
      TRACE("unix_path %s\n", debugstr_a(unix_path));
  
@@ -391,7 +392,7 @@ index d2f1be7a312..67d3b789a41 100644
      heap_free(unix_path);
  
      return dumper;
-@@ -396,5 +479,24 @@ pcap_dumper_t* CDECL wine_pcap_dump_open(pcap_t *p, const char *fname)
+@@ -396,5 +480,24 @@ pcap_dumper_t* CDECL wine_pcap_dump_open(pcap_t *p, const char *fname)
  void CDECL wine_pcap_dump(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)
  {
      TRACE("(%p %p %p)\n", user, h, sp);
@@ -418,5 +419,5 @@ index d2f1be7a312..67d3b789a41 100644
 +    return TRUE;
  }
 -- 
-2.28.0
+2.22.0
 
diff --git a/patches/ws2_32-TransmitFile/definition b/patches/ws2_32-TransmitFile/definition
index a2a8db04..f54cc82d 100644
--- a/patches/ws2_32-TransmitFile/definition
+++ b/patches/ws2_32-TransmitFile/definition
@@ -1,3 +1 @@
 # Fixes: [5048] Support for TransmitFile
-# Broken nontrivially by db8a75312, and I'm working on a proper implementation for this.
-Disabled: true
-- 
2.28.0


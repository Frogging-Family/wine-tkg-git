From 208fbbf5d3a8e289f5a35a65d08abda05089d150 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 22 May 2024 14:56:04 +0200
Subject: [PATCH 0263/1564] winegstreamer: Implement drain and flush for the
 audio decoder.

CW-Bug-Id: #20833
---
 dlls/winegstreamer/audio_decoder.c | 18 ++++++++++++++++--
 1 file changed, 16 insertions(+), 2 deletions(-)

diff --git a/dlls/winegstreamer/audio_decoder.c b/dlls/winegstreamer/audio_decoder.c
index 7490362e5b4..498540587ee 100644
--- a/dlls/winegstreamer/audio_decoder.c
+++ b/dlls/winegstreamer/audio_decoder.c
@@ -520,8 +520,22 @@ static HRESULT WINAPI transform_ProcessEvent(IMFTransform *iface, DWORD id, IMFM
 
 static HRESULT WINAPI transform_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
 {
-    FIXME("iface %p, message %#x, param %p stub!\n", iface, message, (void *)param);
-    return S_OK;
+    struct audio_decoder *decoder = impl_from_IMFTransform(iface);
+
+    TRACE("iface %p, message %#x, param %Ix.\n", iface, message, param);
+
+    switch (message)
+    {
+    case MFT_MESSAGE_COMMAND_DRAIN:
+        return wg_transform_drain(decoder->wg_transform);
+
+    case MFT_MESSAGE_COMMAND_FLUSH:
+        return wg_transform_flush(decoder->wg_transform);
+
+    default:
+        FIXME("Ignoring message %#x.\n", message);
+        return S_OK;
+    }
 }
 
 static HRESULT WINAPI transform_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
-- 
2.49.0

From 722233dd495b57e657655feb62c98bf6a0250156 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 19 Jun 2024 14:23:20 +0200
Subject: [PATCH 0264/1564] winegstreamer/audio_decoder: Fill output block
 align and bytes per second if not set.

Fixes audio in Halo Infinite as well, as we're propagating upstream
block align from the AAC media type, which isn't right for the decoded
media type.

This breaks a couple of aacdec tests, though in a harmless way: no
additional information should be added to the output media type when it
is read back. We could just do that internally or flag the tests todo.

CW-Bug-Id: #20833
CW-Bug-Id: #24641
---
 dlls/winegstreamer/audio_decoder.c | 11 ++++++++---
 1 file changed, 8 insertions(+), 3 deletions(-)

diff --git a/dlls/winegstreamer/audio_decoder.c b/dlls/winegstreamer/audio_decoder.c
index 498540587ee..02ff0b8309f 100644
--- a/dlls/winegstreamer/audio_decoder.c
+++ b/dlls/winegstreamer/audio_decoder.c
@@ -422,10 +422,15 @@ static HRESULT WINAPI transform_SetOutputType(IMFTransform *iface, DWORD id, IMF
     if (flags & MFT_SET_TYPE_TEST_ONLY)
         return S_OK;
 
-    if (!decoder->output_type && FAILED(hr = MFCreateMediaType(&decoder->output_type)))
-        return hr;
+    wfx.Format.nBlockAlign = wfx.Format.wBitsPerSample * wfx.Format.nChannels / 8;
+    wfx.Format.nAvgBytesPerSec = wfx.Format.nBlockAlign * wfx.Format.nSamplesPerSec;
 
-    if (FAILED(hr = IMFMediaType_CopyAllItems(type, (IMFAttributes *)decoder->output_type)))
+    if (decoder->output_type)
+    {
+        IMFMediaType_Release(decoder->output_type);
+        decoder->output_type = NULL;
+    }
+    if (FAILED(hr = MFCreateAudioMediaType(&wfx.Format, (IMFAudioMediaType **)&decoder->output_type)))
         return hr;
 
     if (FAILED(hr = try_create_wg_transform(decoder)))
-- 
2.49.0

From 205ee933ef27a8cb64eb0815d81c72c61cb2b7dd Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 5 Dec 2024 23:36:09 +0100
Subject: [PATCH 0265/1564] HACK: winegstreamer/wg_transform: Implement vorbis
 decoder support.

---
 dlls/winegstreamer/wg_media_type.c | 13 ++++++
 dlls/winegstreamer/wg_transform.c  | 71 ++++++++++++++++++++++++++++++
 2 files changed, 84 insertions(+)

diff --git a/dlls/winegstreamer/wg_media_type.c b/dlls/winegstreamer/wg_media_type.c
index c26a6518a02..9e204567b8b 100644
--- a/dlls/winegstreamer/wg_media_type.c
+++ b/dlls/winegstreamer/wg_media_type.c
@@ -163,6 +163,17 @@ static void init_caps_from_wave_format_wma3(GstCaps *caps, const WMAUDIO3WAVEFOR
     gst_caps_set_simple(caps, "bitrate", G_TYPE_INT, format->wfx.nAvgBytesPerSec * 8, NULL);
 }
 
+static void init_caps_from_wave_format_vorbis(GstCaps *caps, const WAVEFORMATEX *format, UINT32 format_size)
+{
+    init_caps_codec_data(caps, format + 1, format->cbSize);
+
+    gst_structure_remove_field(gst_caps_get_structure(caps, 0), "format");
+    gst_structure_set_name(gst_caps_get_structure(caps, 0), "audio/x-vorbis");
+    gst_caps_set_simple(caps, "block_align", G_TYPE_INT, format->nBlockAlign, NULL);
+    gst_caps_set_simple(caps, "depth", G_TYPE_INT, format->wBitsPerSample, NULL);
+    gst_caps_set_simple(caps, "bitrate", G_TYPE_INT, format->nAvgBytesPerSec * 8, NULL);
+}
+
 static void init_caps_from_wave_format(GstCaps *caps, const GUID *subtype,
         const void *format, UINT32 format_size)
 {
@@ -182,6 +193,8 @@ static void init_caps_from_wave_format(GstCaps *caps, const GUID *subtype,
         return init_caps_from_wave_format_wma3(caps, format, format_size, 3);
     if (IsEqualGUID(subtype, &MFAudioFormat_WMAudio_Lossless))
         return init_caps_from_wave_format_wma3(caps, format, format_size, 4);
+    if (IsEqualGUID(subtype, &MFAudioFormat_Vorbis))
+        return init_caps_from_wave_format_vorbis(caps, format, format_size);
 
     GST_FIXME("Unsupported subtype " WG_GUID_FORMAT, WG_GUID_ARGS(*subtype));
 }
diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
index 7fb43bdbc93..18a6599f7b9 100644
--- a/dlls/winegstreamer/wg_transform.c
+++ b/dlls/winegstreamer/wg_transform.c
@@ -470,6 +470,74 @@ static GstCaps *transform_get_parsed_caps(GstCaps *caps, const char *media_type)
     return parsed_caps;
 }
 
+static GstBuffer *caps_get_buffer(const GstCaps *caps, const char *name, UINT32 *buffer_size)
+{
+    const GstStructure *structure = gst_caps_get_structure(caps, 0);
+    const GValue *buffer_value;
+
+    if ((buffer_value = gst_structure_get_value(structure, name)))
+    {
+        GstBuffer *buffer = gst_value_get_buffer(buffer_value);
+        *buffer_size = gst_buffer_get_size(buffer);
+        return buffer;
+    }
+
+    *buffer_size = 0;
+    return NULL;
+}
+
+static void push_vorbis_headers(struct wg_transform *transform)
+{
+    const uint8_t *ptr, *beg, *end;
+    GstBuffer *codec_data, *hdr;
+    UINT32 codec_data_size;
+    GstBufferMapInfo info;
+    int i, count, len;
+
+    if (!(codec_data = caps_get_buffer(transform->input_caps, "codec_data",
+            &codec_data_size)) || !codec_data_size) return;
+    gst_buffer_map(codec_data, &info, GST_MAP_READ);
+    ptr = info.data;
+    end = ptr + info.size;
+
+    for (len = 0, i = 0, count = *ptr++; ptr < end && i < count; i++)
+    {
+        while (ptr < end && *ptr++ == 0xff) len += 0xff;
+        len += ptr[-1];
+        GST_DEBUG("buffer %d: %u bytes", i, len);
+    }
+    if (len > end - ptr) goto failed;
+    beg = ptr;
+    ptr = info.data;
+
+    GST_DEBUG("%u stream headers, total length=%u bytes", count + 1, codec_data_size);
+    for (len = 0, i = 0, count = *ptr++; ptr < end && i < count; i++, len = 0)
+    {
+        while (ptr < end && *ptr++ == 0xff) len += 0xff;
+        len += ptr[-1];
+
+        if (!(hdr = gst_buffer_new_memdup(beg, len))) break;
+        GST_DEBUG("buffer %d: %u bytes", i, len);
+        GST_BUFFER_FLAG_SET(hdr, GST_BUFFER_FLAG_HEADER);
+        GST_MEMDUMP("data", beg, len);
+        gst_pad_push(transform->my_src, hdr);
+        beg += len;
+    }
+
+    if ((hdr = gst_buffer_new_memdup(beg, end - beg)))
+    {
+        GST_DEBUG("buffer %d: %zu bytes", i, end - beg);
+        GST_MEMDUMP("data", beg, end - beg);
+        GST_BUFFER_FLAG_SET(hdr, GST_BUFFER_FLAG_HEADER);
+        gst_pad_push(transform->my_src, hdr);
+    }
+
+failed:
+    gst_buffer_unmap(codec_data, &info);
+    gst_buffer_unref(codec_data);
+}
+
+
 static bool transform_create_decoder_elements(struct wg_transform *transform,
         const gchar *input_mime, const gchar *output_mime, GstElement **first, GstElement **last)
 {
@@ -682,6 +750,9 @@ NTSTATUS wg_transform_create(void *args)
             || !push_event(transform->my_src, event))
         goto out;
 
+    if (!strcmp(input_mime, "audio/x-vorbis"))
+        push_vorbis_headers(transform);
+
     GST_INFO("Created winegstreamer transform %p.", transform);
     params->transform = (wg_transform_t)(ULONG_PTR)transform;
     return STATUS_SUCCESS;
-- 
2.49.0

From a3feeabebeb010229a6377fb81bdb4c823366fef Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 5 Dec 2024 23:36:09 +0100
Subject: [PATCH 0266/1564] HACK: winegstreamer/audio_decoder: Expose a vorbis
 audio decoder.

---
 dlls/winegstreamer/audio_decoder.c           | 33 ++++++++++++++++++++
 dlls/winegstreamer/gst_private.h             |  1 +
 dlls/winegstreamer/mfplat.c                  |  2 ++
 dlls/winegstreamer/winegstreamer_classes.idl |  6 ++++
 4 files changed, 42 insertions(+)

diff --git a/dlls/winegstreamer/audio_decoder.c b/dlls/winegstreamer/audio_decoder.c
index 02ff0b8309f..a675ef84f35 100644
--- a/dlls/winegstreamer/audio_decoder.c
+++ b/dlls/winegstreamer/audio_decoder.c
@@ -663,3 +663,36 @@ HRESULT aac_decoder_create(REFIID riid, void **ret)
     TRACE("Created decoder %p\n", *ret);
     return S_OK;
 }
+
+static WAVEFORMATEXTENSIBLE audio_decoder_input_types[] =
+{
+    {.Format = {.wFormatTag = WAVE_FORMAT_EXTENSIBLE, .nChannels = 6, .nSamplesPerSec = 48000, .nAvgBytesPerSec = 1152000, \
+                .nBlockAlign = 24, .wBitsPerSample = 32, .cbSize = sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX)}, \
+     .SubFormat = {0x8d2fd10b,0x5841,0x4a6b,{0x89,0x05,0x58,0x8f,0xec,0x1a,0xde,0xd9}}},
+};
+
+HRESULT audio_decoder_create(REFIID riid, void **ret)
+{
+    struct audio_decoder *decoder;
+    HRESULT hr;
+
+    TRACE("riid %s, ret %p.\n", debugstr_guid(riid), ret);
+
+    if (!(decoder = calloc(1, sizeof(*decoder))))
+        return E_OUTOFMEMORY;
+    decoder->input_types = (WAVEFORMATEXTENSIBLE *)audio_decoder_input_types;
+    decoder->input_type_count = ARRAY_SIZE(audio_decoder_input_types);
+
+    if (FAILED(hr = wg_sample_queue_create(&decoder->wg_sample_queue)))
+    {
+        free(decoder);
+        return hr;
+    }
+
+    decoder->IMFTransform_iface.lpVtbl = &transform_vtbl;
+    decoder->refcount = 1;
+
+    *ret = &decoder->IMFTransform_iface;
+    TRACE("Created decoder %p\n", *ret);
+    return S_OK;
+}
diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index 9db484c033f..f9f0048bbe1 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -183,6 +183,7 @@ unsigned int wg_format_get_stride(const struct wg_format *format);
 
 bool wg_video_format_is_rgb(enum wg_video_format format);
 
+HRESULT audio_decoder_create(REFIID riid, void **ret);
 HRESULT aac_decoder_create(REFIID riid, void **ret);
 HRESULT h264_decoder_create(REFIID riid, void **ret);
 HRESULT video_processor_create(REFIID riid, void **ret);
diff --git a/dlls/winegstreamer/mfplat.c b/dlls/winegstreamer/mfplat.c
index 93f787a9040..35777a552f9 100644
--- a/dlls/winegstreamer/mfplat.c
+++ b/dlls/winegstreamer/mfplat.c
@@ -121,6 +121,7 @@ static const IClassFactoryVtbl class_factory_vtbl =
     class_factory_LockServer,
 };
 
+static const GUID CLSID_GStreamerAudioDecoder = {0x480b1517, 0xc8e9, 0x4eae, {0xb0, 0x06, 0xe6, 0x30, 0x07, 0x18, 0xd8, 0x5d}};
 static const GUID CLSID_GStreamerByteStreamHandler = {0x317df618, 0x5e5a, 0x468a, {0x9f, 0x15, 0xd8, 0x27, 0xa9, 0xa0, 0x81, 0x62}};
 static const GUID CLSID_wg_video_processor = {0xd527607f,0x89cb,0x4e94,{0x95,0x71,0xbc,0xfe,0x62,0x17,0x56,0x13}};
 static const GUID CLSID_wg_aac_decoder = {0xe7889a8a,0x2083,0x4844,{0x83,0x70,0x5e,0xe3,0x49,0xb1,0x45,0x03}};
@@ -135,6 +136,7 @@ static const struct class_object
 class_objects[] =
 {
     { &CLSID_wg_video_processor, &video_processor_create },
+    { &CLSID_GStreamerAudioDecoder, &audio_decoder_create },
     { &CLSID_GStreamerByteStreamHandler, &gstreamer_byte_stream_handler_create },
     { &CLSID_wg_aac_decoder, &aac_decoder_create },
     { &CLSID_wg_h264_decoder, &h264_decoder_create },
diff --git a/dlls/winegstreamer/winegstreamer_classes.idl b/dlls/winegstreamer/winegstreamer_classes.idl
index bb9f81c2341..d435ea68232 100644
--- a/dlls/winegstreamer/winegstreamer_classes.idl
+++ b/dlls/winegstreamer/winegstreamer_classes.idl
@@ -77,6 +77,12 @@ coclass wg_video_processor {}
 ]
 coclass GStreamerByteStreamHandler {}
 
+[
+    threading(both),
+    uuid(480b1517-c8e9-4eae-b006-e6300718d85d)
+]
+coclass GStreamerAudioDecoder {}
+
 [
     threading(both),
     uuid(5b4d4e54-0620-4cf9-94ae-7823965c28b6)
-- 
2.49.0

From 22d8bc2c8028baf68e313834f4caed9fc916704c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 5 Dec 2024 23:36:09 +0100
Subject: [PATCH 0267/1564] HACK: msauddecmft: Expose a vorbis audio decoder.

---
 dlls/msauddecmft/msauddecmft.c   | 37 ++++++++++++++++++++++++++++++++
 dlls/msauddecmft/msauddecmft.idl |  6 ++++++
 2 files changed, 43 insertions(+)

diff --git a/dlls/msauddecmft/msauddecmft.c b/dlls/msauddecmft/msauddecmft.c
index 813d81387b5..dd6f91fe5b6 100644
--- a/dlls/msauddecmft/msauddecmft.c
+++ b/dlls/msauddecmft/msauddecmft.c
@@ -34,6 +34,14 @@ WINE_DEFAULT_DEBUG_CHANNEL(dmo);
 #include "initguid.h"
 
 DEFINE_MEDIATYPE_GUID(MFAudioFormat_RAW_AAC,WAVE_FORMAT_RAW_AAC1);
+static const GUID CLSID_WineAudioDecoder = {0x480b1517,0xc8e9,0x4eaf,{0xb0,0x06,0xe6,0x30,0x07,0x18,0xd8,0x5d}};
+
+static HRESULT WINAPI audio_decoder_factory_CreateInstance(IClassFactory *iface, IUnknown *outer,
+        REFIID riid, void **out)
+{
+    static const GUID CLSID_GStreamerAudioDecoder = {0x480b1517,0xc8e9,0x4eae,{0xb0,0x06,0xe6,0x30,0x07,0x18,0xd8,0x5d}};
+    return CoCreateInstance(&CLSID_GStreamerAudioDecoder, outer, CLSCTX_INPROC_SERVER, riid, out);
+}
 
 static HRESULT WINAPI aac_decoder_factory_CreateInstance(IClassFactory *iface, IUnknown *outer,
         REFIID riid, void **out)
@@ -71,6 +79,17 @@ static const IClassFactoryVtbl aac_decoder_factory_vtbl =
 
 static IClassFactory aac_decoder_factory = {&aac_decoder_factory_vtbl};
 
+static const IClassFactoryVtbl audio_decoder_factory_vtbl =
+{
+    class_factory_QueryInterface,
+    class_factory_AddRef,
+    class_factory_Release,
+    audio_decoder_factory_CreateInstance,
+    class_factory_LockServer,
+};
+
+static IClassFactory audio_decoder_factory = {&audio_decoder_factory_vtbl};
+
 /***********************************************************************
  *              DllGetClassObject (msauddecmft.@)
  */
@@ -78,6 +97,8 @@ HRESULT WINAPI DllGetClassObject(REFCLSID clsid, REFIID riid, void **out)
 {
     if (IsEqualGUID(clsid, &CLSID_MSAACDecMFT))
         return IClassFactory_QueryInterface(&aac_decoder_factory, riid, out);
+    if (IsEqualGUID(clsid, &CLSID_WineAudioDecoder))
+        return IClassFactory_QueryInterface(&audio_decoder_factory, riid, out);
 
     *out = NULL;
     FIXME("Unknown clsid %s.\n", debugstr_guid(clsid));
@@ -100,6 +121,15 @@ HRESULT WINAPI DllRegisterServer(void)
         {MFMediaType_Audio, MFAudioFormat_Float},
         {MFMediaType_Audio, MFAudioFormat_PCM},
     };
+    MFT_REGISTER_TYPE_INFO audio_decoder_mft_inputs[] =
+    {
+        {MFMediaType_Audio, MFAudioFormat_Vorbis},
+    };
+    MFT_REGISTER_TYPE_INFO audio_decoder_mft_outputs[] =
+    {
+        {MFMediaType_Audio, MFAudioFormat_Float},
+        {MFMediaType_Audio, MFAudioFormat_PCM},
+    };
     HRESULT hr;
 
     TRACE("\n");
@@ -111,6 +141,11 @@ HRESULT WINAPI DllRegisterServer(void)
             ARRAY_SIZE(aac_decoder_mft_inputs), aac_decoder_mft_inputs,
             ARRAY_SIZE(aac_decoder_mft_outputs), aac_decoder_mft_outputs, NULL)))
         return hr;
+    if (FAILED(hr = MFTRegister(CLSID_WineAudioDecoder, MFT_CATEGORY_AUDIO_DECODER,
+            (WCHAR *)L"Wine Audio Decoder", MFT_ENUM_FLAG_SYNCMFT,
+            ARRAY_SIZE(audio_decoder_mft_inputs), audio_decoder_mft_inputs,
+            ARRAY_SIZE(audio_decoder_mft_outputs), audio_decoder_mft_outputs, NULL)))
+        return hr;
 
     return S_OK;
 }
@@ -128,6 +163,8 @@ HRESULT WINAPI DllUnregisterServer(void)
         return hr;
     if (FAILED(hr = MFTUnregister(CLSID_MSAACDecMFT)))
         return hr;
+    if (FAILED(hr = MFTUnregister(CLSID_WineAudioDecoder)))
+        return hr;
 
     return S_OK;
 }
diff --git a/dlls/msauddecmft/msauddecmft.idl b/dlls/msauddecmft/msauddecmft.idl
index f1b2a62a2d2..1aba2baf7b1 100644
--- a/dlls/msauddecmft/msauddecmft.idl
+++ b/dlls/msauddecmft/msauddecmft.idl
@@ -23,3 +23,9 @@
     uuid(32d186a7-218f-4c75-8876-dd77273a8999)
 ]
 coclass CMSAACDecMFT {}
+
+[
+    threading(both),
+    uuid(480b1517-c8e9-4eaf-b006-e6300718d85d)
+]
+coclass WineAudioDecoder {}
-- 
2.49.0

From 340ca4864b87ff168302f00dcc930dbf68b4f372 Mon Sep 17 00:00:00 2001
From: Zhiyi Zhang <zzhang@codeweavers.com>
Date: Fri, 22 Dec 2023 10:44:16 +0800
Subject: [PATCH 0556/1564] HACK: winegstreamer: Reduce Biomutant_Trailer.mp4
 media source duration.

Hack for bug 19766 - Biomutant (597820) [T5] Title Hangs After Intro Cut Scene Unless Skipped.

Unreal Engine 4 games expect presentation clock correlated time to run past media source
duration[1], which assumes that all streams in a media source have the same duration.
Biomutant_Trailer.mp4 from Biomutant(597820) has a 1:27.734s video stream and a 1:27.776s
audio stream so the media source duration is reported to be 1:27.776s. However, the game
builds a topology that only uses the video stream. So the last presentation clock correlated
time could be something before the media source duration 1:27.776s before it's stopped. In
Unreal Engine 4.18 source, on every frame FWmfMediaSession::GetEvents()[2] checks
"Time > CurrentDuration" to decide whether to stop its media session. With the time check
fails, the game will hang forever waiting for the session to stop. This hack shortens the
media source duration to satisfy the condition check. The reason why it works on Windows is
probably due to a delay caused a busy CPU and different scheduling.

[1][2]: UnrealEngine-4.18/Engine/Plugins/Media/WmfMedia/Source/WmfMedia/Private/Wmf/WmfMediaSession.cpp#FWmfMediaSession::GetEvents()

CW-Bug-Id: #19766
---
 dlls/winegstreamer/media_source.c | 22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)

diff --git a/dlls/winegstreamer/media_source.c b/dlls/winegstreamer/media_source.c
index 88056b27c5d..caaf8d16b96 100644
--- a/dlls/winegstreamer/media_source.c
+++ b/dlls/winegstreamer/media_source.c
@@ -1786,6 +1786,28 @@ static HRESULT media_source_create(struct object_context *context, IMFMediaSourc
         object->stream_count++;
     }
 
+    /* Hack for bug 19766 - Biomutant (597820) [T5] Title Hangs After Intro Cut Scene Unless Skipped.
+     *
+     * Unreal Engine 4 games expect presentation clock correlated time to run past media source
+     * duration[1], which assumes that all streams in a media source have the same duration.
+     * Biomutant_Trailer.mp4 from Biomutant(597820) has a 1:27.734s video stream and a 1:27.776s
+     * audio stream so the media source duration is reported to be 1:27.776s. However, the game
+     * builds a topology that only uses the video stream. So the last presentation clock correlated
+     * time could be something before the media source duration 1:27.776s before it's stopped. In
+     * Unreal Engine 4.18 source, on every frame FWmfMediaSession::GetEvents()[2] checks
+     * "Time > CurrentDuration" to decide whether to stop its media session. With the time check
+     * fails, the game will hang forever waiting for the session to stop. This hack shortens the
+     * media source duration to satisfy the condition check. The reason why it works on Windows is
+     * probably due to a delay caused a busy CPU and different scheduling.
+     *
+     * [1][2]: UnrealEngine-4.18/Engine/Plugins/Media/WmfMedia/Source/WmfMedia/Private/Wmf/WmfMediaSession.cpp#FWmfMediaSession::GetEvents()
+     */
+    {
+        const char *id = getenv("SteamGameId");
+        if (id && !strcmp(id, "597820") && object->duration == 877760000) /* Biomutant_Trailer.mp4 */
+            object->duration = 877340000;
+    }
+
     media_source_init_descriptors(object);
     object->state = SOURCE_STOPPED;
 
-- 
2.49.0

From 2a0a25c8d6cbdb9697faf8857974b0060b5b76f4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 5 Dec 2024 10:54:15 +0100
Subject: [PATCH 0561/1564] winegstreamer/media-converter: Rename payload_hash
 to fozdb_hash.

---
 .../winegstreamer/media-converter/audioconv.c | 24 +++++++-------
 .../winegstreamer/media-converter/fossilize.c | 32 +++++++++----------
 .../media-converter/media-converter.h         | 25 +++++++++------
 .../winegstreamer/media-converter/videoconv.c | 28 ++++++++--------
 4 files changed, 58 insertions(+), 51 deletions(-)

diff --git a/dlls/winegstreamer/media-converter/audioconv.c b/dlls/winegstreamer/media-converter/audioconv.c
index 462cec16a8a..5acce9a7915 100644
--- a/dlls/winegstreamer/media-converter/audioconv.c
+++ b/dlls/winegstreamer/media-converter/audioconv.c
@@ -162,7 +162,7 @@ typedef enum
 
 struct buffer_entry
 {
-    struct payload_hash hash;
+    struct fozdb_hash hash;
     GstBuffer *buffer;
 };
 
@@ -182,7 +182,7 @@ struct need_transcode_head
 struct stream_state
 {
     struct murmur3_128_state hash_state;
-    struct payload_hash current_hash;
+    struct fozdb_hash current_hash;
     GList *buffers;      /* Entry type: struct buffer_entry. */
     GList *loop_buffers; /* Entry type: struct buffer_entry. */
     struct need_transcode_head *codec_info;
@@ -235,7 +235,7 @@ static GstStaticPadTemplate audio_conv_src_template = GST_STATIC_PAD_TEMPLATE("s
 
 static struct dump_fozdb dump_fozdb = {PTHREAD_MUTEX_INITIALIZER, NULL, false};
 
-static struct buffer_entry *buffer_entry_create(struct payload_hash *hash, GstBuffer *buffer)
+static struct buffer_entry *buffer_entry_create(struct fozdb_hash *hash, GstBuffer *buffer)
 {
     struct buffer_entry *entry = calloc(1, sizeof(*entry));
     entry->hash = *hash;
@@ -255,7 +255,7 @@ static bool dumping_disabled(void)
     return option_enabled("MEDIACONV_AUDIO_DONT_DUMP");
 }
 
-static bool hash_data(const uint8_t *data, size_t size, struct murmur3_128_state *hash_state, struct payload_hash *hash)
+static bool hash_data(const uint8_t *data, size_t size, struct murmur3_128_state *hash_state, struct fozdb_hash *hash)
 {
     struct bytes_reader reader;
     bytes_reader_init(&reader, data, size);
@@ -270,7 +270,7 @@ static int dump_fozdb_open_audio(bool create)
 static void dump_fozdb_discard_transcoded(void)
 {
     GList *chunks_to_discard = NULL, *chunks_to_keep = NULL, *chunks = NULL, *list_iter;
-    struct payload_hash chunk_id, *stream_id;
+    struct fozdb_hash chunk_id, *stream_id;
     struct fozdb *read_fozdb;
     char *read_fozdb_path;
     GHashTableIter iter;
@@ -317,7 +317,7 @@ static void dump_fozdb_discard_transcoded(void)
 
                 for (i = 0; i < read_size / sizeof(chunk_id); ++i)
                 {
-                    payload_hash_from_bytes(&chunk_id, buffer + i * sizeof(chunk_id));
+                    fozdb_hash_from_bytes(&chunk_id, buffer + i * sizeof(chunk_id));
                     if (!fozdb_has_entry(read_fozdb, AUDIO_CONV_FOZ_TAG_PTNADATA, &chunk_id))
                     {
                         has_all = false;
@@ -517,8 +517,8 @@ static void stream_state_reset(struct stream_state *state)
     state->needs_dump = false;
 }
 
-static loop_state stream_state_record_buffer(struct stream_state *state, struct payload_hash *buffer_hash,
-        struct payload_hash *loop_hash, GstBuffer *buffer, struct need_transcode_head *codec_info)
+static loop_state stream_state_record_buffer(struct stream_state *state, struct fozdb_hash *buffer_hash,
+        struct fozdb_hash *loop_hash, GstBuffer *buffer, struct need_transcode_head *codec_info)
 {
     if (!state->codec_info && codec_info)
         state->codec_info = need_transcode_head_dup(codec_info);
@@ -553,7 +553,7 @@ static loop_state stream_state_record_buffer(struct stream_state *state, struct
     return NO_LOOP;
 }
 
-static bool stream_state_is_stream_subset(struct stream_state *state, struct fozdb *db, struct payload_hash *stream_id)
+static bool stream_state_is_stream_subset(struct stream_state *state, struct fozdb *db, struct fozdb_hash *stream_id)
 {
     uint64_t offset = 0;
     GList *list_iter;
@@ -561,7 +561,7 @@ static bool stream_state_is_stream_subset(struct stream_state *state, struct foz
     for (list_iter = state->buffers; list_iter; list_iter = list_iter->next)
     {
         struct buffer_entry *entry = list_iter->data;
-        struct payload_hash buffer_id;
+        struct fozdb_hash buffer_id;
         size_t read_size;
 
         if ((fozdb_read_entry_data(db, AUDIO_CONV_FOZ_TAG_STREAM, stream_id,
@@ -610,7 +610,7 @@ static int stream_state_write_to_foz(struct stream_state *state)
     if (!found)
     {
         /* Are there any recorded streams of which this stream is a subset? */
-        struct payload_hash *stream_id;
+        struct fozdb_hash *stream_id;
         GHashTableIter stream_ids;
 
         fozdb_iter_tag(dump_fozdb.fozdb, AUDIO_CONV_FOZ_TAG_STREAM, &stream_ids);
@@ -727,7 +727,7 @@ static void audio_conv_state_reset(struct audio_conv_state *state)
 static int audio_conv_state_open_transcode_file(struct audio_conv_state *state, GstBuffer *buffer,
         uint8_t **out_data, size_t *out_size)
 {
-    struct payload_hash hash, loop_hash;
+    struct fozdb_hash hash, loop_hash;
     uint32_t transcoded_size;
     const char *blank_audio;
     bool try_loop, hash_ok;
diff --git a/dlls/winegstreamer/media-converter/fossilize.c b/dlls/winegstreamer/media-converter/fossilize.c
index 057825ad5b5..44a9cbf7c65 100644
--- a/dlls/winegstreamer/media-converter/fossilize.c
+++ b/dlls/winegstreamer/media-converter/fossilize.c
@@ -96,24 +96,24 @@ struct payload_header
 
 struct payload_entry
 {
-    struct payload_hash hash;
+    struct fozdb_hash hash;
     struct payload_header header;
     uint64_t offset;
 };
 
 static guint hash_func(gconstpointer key)
 {
-    const struct payload_hash *payload_hash = key;
+    const struct fozdb_hash *fozdb_hash = key;
 
-    return payload_hash->hash[0]
-            ^ payload_hash->hash[1]
-            ^ payload_hash->hash[2]
-            ^ payload_hash->hash[3];
+    return fozdb_hash->hash[0]
+            ^ fozdb_hash->hash[1]
+            ^ fozdb_hash->hash[2]
+            ^ fozdb_hash->hash[3];
 }
 
 static gboolean hash_equal(gconstpointer a, gconstpointer b)
 {
-    return memcmp(a, b, sizeof(struct payload_hash)) == 0;
+    return memcmp(a, b, sizeof(struct fozdb_hash)) == 0;
 }
 
 static bool tag_from_ascii_bytes(uint32_t *tag, const uint8_t *ascii_bytes)
@@ -132,7 +132,7 @@ static bool tag_from_ascii_bytes(uint32_t *tag, const uint8_t *ascii_bytes)
     return true;
 }
 
-static bool hash_from_ascii_bytes(struct payload_hash *hash, const uint8_t *ascii_bytes)
+static bool hash_from_ascii_bytes(struct fozdb_hash *hash, const uint8_t *ascii_bytes)
 {
     unsigned int i;
 
@@ -162,7 +162,7 @@ static void tag_to_ascii_bytes(uint32_t tag, uint8_t *ascii_bytes)
     memcpy(ascii_bytes, buffer, sizeof(tag) * 2);
 }
 
-static void hash_to_ascii_bytes(const struct payload_hash *hash, uint8_t *ascii_bytes)
+static void hash_to_ascii_bytes(const struct fozdb_hash *hash, uint8_t *ascii_bytes)
 {
     char buffer[sizeof(*hash) * 2 + 1];
     sprintf(buffer, "%08x%08x%08x%08x", hash->hash[3], hash->hash[2], hash->hash[1], hash->hash[0]);
@@ -201,10 +201,10 @@ static int fozdb_read_file_header(struct fozdb *db)
 }
 
 static int fozdb_read_entry_tag_hash_header(struct fozdb *db,
-        uint32_t *out_tag, struct payload_hash *out_hash, struct payload_header *out_header)
+        uint32_t *out_tag, struct fozdb_hash *out_hash, struct payload_header *out_header)
 {
     uint8_t entry_name_and_header[ENTRY_NAME_SIZE + sizeof(struct payload_header)];
-    struct payload_hash hash;
+    struct fozdb_hash hash;
     uint32_t tag;
 
     if (!complete_read(db->file, entry_name_and_header, sizeof(entry_name_and_header)))
@@ -254,7 +254,7 @@ static bool fozdb_seek_to_next_entry(struct fozdb *db, struct payload_header *he
     return true;
 }
 
-static bool fozdb_write_entry_name(struct fozdb *db, uint32_t tag, struct payload_hash *hash)
+static bool fozdb_write_entry_name(struct fozdb *db, uint32_t tag, struct fozdb_hash *hash)
 {
     uint8_t entry_name[ENTRY_NAME_SIZE];
 
@@ -473,14 +473,14 @@ int fozdb_prepare(struct fozdb *db)
     return CONV_OK;
 }
 
-bool fozdb_has_entry(struct fozdb *db, uint32_t tag, struct payload_hash *hash)
+bool fozdb_has_entry(struct fozdb *db, uint32_t tag, struct fozdb_hash *hash)
 {
     if (tag >= db->num_tags)
         return false;
     return g_hash_table_contains(db->seen_blobs[tag], hash);
 }
 
-int fozdb_entry_size(struct fozdb *db, uint32_t tag, struct payload_hash *hash, uint32_t *size)
+int fozdb_entry_size(struct fozdb *db, uint32_t tag, struct fozdb_hash *hash, uint32_t *size)
 {
     struct payload_entry *entry;
 
@@ -504,7 +504,7 @@ void fozdb_iter_tag(struct fozdb *db, uint32_t tag, GHashTableIter *iter)
     g_hash_table_iter_init(iter, db->seen_blobs[tag]);
 }
 
-int fozdb_read_entry_data(struct fozdb *db, uint32_t tag, struct payload_hash *hash,
+int fozdb_read_entry_data(struct fozdb *db, uint32_t tag, struct fozdb_hash *hash,
         uint64_t offset, uint8_t *buffer, size_t size, size_t *read_size, bool with_crc)
 {
     struct payload_entry *entry;
@@ -544,7 +544,7 @@ int fozdb_read_entry_data(struct fozdb *db, uint32_t tag, struct payload_hash *h
     return CONV_OK;
 }
 
-int fozdb_write_entry(struct fozdb *db, uint32_t tag, struct payload_hash *hash,
+int fozdb_write_entry(struct fozdb *db, uint32_t tag, struct fozdb_hash *hash,
         void *data_src, data_read_callback read_callback, bool with_crc)
 {
     struct payload_header header;
diff --git a/dlls/winegstreamer/media-converter/media-converter.h b/dlls/winegstreamer/media-converter/media-converter.h
index 8cd4b31344a..d737040ad15 100644
--- a/dlls/winegstreamer/media-converter/media-converter.h
+++ b/dlls/winegstreamer/media-converter/media-converter.h
@@ -90,15 +90,22 @@ struct gst_buffer_reader
     size_t offset;
 };
 
-struct payload_hash
+struct fozdb_hash
 {
     uint32_t hash[4];
 };
 
+#define debugstr_fozdb_hash( hash ) debugstr_fozdb_hash_( (char[35]){0}, hash )
+static inline const char *debugstr_fozdb_hash_( char *buffer, const struct fozdb_hash *hash )
+{
+    sprintf( buffer, "0x%08x%08x%08x%08x", hash->hash[3], hash->hash[2], hash->hash[1], hash->hash[0] );
+    return buffer;
+}
+
 struct entry_name
 {
     uint32_t tag;
-    struct payload_hash hash;
+    struct fozdb_hash hash;
 };
 
 struct dump_fozdb
@@ -157,12 +164,12 @@ extern bool murmur3_x86_128(void *data_src, data_read_callback read_callback, ui
 extern int fozdb_create(const char *file_name, int open_flags, bool read_only, uint32_t num_tags, struct fozdb **out);
 extern void fozdb_release(struct fozdb *db);
 extern int fozdb_prepare(struct fozdb *db);
-extern bool fozdb_has_entry(struct fozdb *db, uint32_t tag, struct payload_hash *hash);
-extern int fozdb_entry_size(struct fozdb *db, uint32_t tag, struct payload_hash *hash, uint32_t *size);
+extern bool fozdb_has_entry(struct fozdb *db, uint32_t tag, struct fozdb_hash *hash);
+extern int fozdb_entry_size(struct fozdb *db, uint32_t tag, struct fozdb_hash *hash, uint32_t *size);
 extern void fozdb_iter_tag(struct fozdb *db, uint32_t tag, GHashTableIter *iter);
-extern int fozdb_read_entry_data(struct fozdb *db, uint32_t tag, struct payload_hash *hash,
+extern int fozdb_read_entry_data(struct fozdb *db, uint32_t tag, struct fozdb_hash *hash,
         uint64_t offset, uint8_t *buffer, size_t size, size_t *read_size, bool with_crc);
-extern int fozdb_write_entry(struct fozdb *db, uint32_t tag, struct payload_hash *hash,
+extern int fozdb_write_entry(struct fozdb *db, uint32_t tag, struct fozdb_hash *hash,
         void *data_src, data_read_callback read_callback, bool with_crc);
 extern int fozdb_discard_entries(struct fozdb *db, GList *to_discard_entries);
 
@@ -181,7 +188,7 @@ static inline bool discarding_disabled(void)
     return option_enabled("MEDIACONV_DONT_DISCARD");
 }
 
-static inline const char *format_hash(struct payload_hash *hash)
+static inline const char *format_hash(struct fozdb_hash *hash)
 {
     int hash_str_size = 2 + sizeof(*hash) * 2 + 1;
     static char buffer[1024] = {};
@@ -258,7 +265,7 @@ static inline bool file_exists(const char *file_path)
     return access(file_path, F_OK) == 0;
 }
 
-static inline struct entry_name *entry_name_create(uint32_t tag, struct payload_hash *hash)
+static inline struct entry_name *entry_name_create(uint32_t tag, struct fozdb_hash *hash)
 {
     struct entry_name *entry = calloc(1, sizeof(*entry));
     entry->tag = tag;
@@ -279,7 +286,7 @@ static inline uint32_t bytes_to_uint32(const uint8_t *bytes)
             | ((uint32_t)bytes[3] << 24);
 }
 
-static inline void payload_hash_from_bytes(struct payload_hash *hash, uint8_t *bytes)
+static inline void fozdb_hash_from_bytes(struct fozdb_hash *hash, uint8_t *bytes)
 {
     hash->hash[0] = bytes_to_uint32(bytes + 0);
     hash->hash[1] = bytes_to_uint32(bytes + 4);
diff --git a/dlls/winegstreamer/media-converter/videoconv.c b/dlls/winegstreamer/media-converter/videoconv.c
index d45e2d8be8a..b91e0e27d8c 100644
--- a/dlls/winegstreamer/media-converter/videoconv.c
+++ b/dlls/winegstreamer/media-converter/videoconv.c
@@ -99,7 +99,7 @@ enum video_conv_state_flags
 
 struct video_conv_state
 {
-    struct payload_hash transcode_hash;
+    struct fozdb_hash transcode_hash;
     struct fozdb *read_fozdb;
     int blank_file;
     uint64_t upstream_duration;
@@ -149,7 +149,7 @@ void hashes_reader_init(struct hashes_reader *reader, GList *hashes)
 
 static int hashes_reader_read(void *reader, uint8_t *buffer, size_t size, size_t *read_size)
 {
-    struct payload_hash *hash = (struct payload_hash *)buffer;
+    struct fozdb_hash *hash = (struct fozdb_hash *)buffer;
     struct hashes_reader *hashes_reader = reader;
 
     if (!size)
@@ -161,7 +161,7 @@ static int hashes_reader_read(void *reader, uint8_t *buffer, size_t size, size_t
     if (!hashes_reader->current_hash)
         return CONV_ERROR_DATA_END;
 
-    *hash = *(struct payload_hash *)(hashes_reader->current_hash->data);
+    *hash = *(struct fozdb_hash *)(hashes_reader->current_hash->data);
     hashes_reader->current_hash = hashes_reader->current_hash->next;
 
     *read_size = sizeof(*hash);
@@ -176,7 +176,7 @@ static int dump_fozdb_open_video(bool create)
 static void dump_fozdb_discard_transcoded(void)
 {
     GList *to_discard_chunks = NULL;
-    struct payload_hash *stream_id;
+    struct fozdb_hash *stream_id;
     struct fozdb *read_fozdb;
     char *read_fozdb_path;
     GHashTableIter iter;
@@ -209,7 +209,7 @@ static void dump_fozdb_discard_transcoded(void)
     fozdb_iter_tag(dump_fozdb.fozdb, VIDEO_CONV_FOZ_TAG_STREAM, &iter);
     while (g_hash_table_iter_next(&iter, (void **)&stream_id, NULL))
     {
-        struct payload_hash chunk_id;
+        struct fozdb_hash chunk_id;
         uint32_t chunks_size, i;
         size_t read_size;
 
@@ -223,7 +223,7 @@ static void dump_fozdb_discard_transcoded(void)
                 {
                     for (i = 0; i < read_size / sizeof(chunk_id); ++i)
                     {
-                        payload_hash_from_bytes(&chunk_id, buffer + i * sizeof(chunk_id));
+                        fozdb_hash_from_bytes(&chunk_id, buffer + i * sizeof(chunk_id));
                         to_discard_chunks = g_list_append(to_discard_chunks,
                                 entry_name_create(VIDEO_CONV_FOZ_TAG_VIDEODATA, &chunk_id));
                     }
@@ -396,7 +396,7 @@ static void video_conv_state_release(struct video_conv_state *state)
 }
 
 /* Return true if the file is transcoded, false if not. */
-bool video_conv_state_begin_transcode(struct video_conv_state *state, struct payload_hash *hash)
+bool video_conv_state_begin_transcode(struct video_conv_state *state, struct fozdb_hash *hash)
 {
     GST_DEBUG("state %p, hash %s.", state, format_hash(hash));
 
@@ -582,7 +582,7 @@ static bool video_conv_get_downstream_range(VideoConv *conv, uint64_t offset, ui
     return true;
 }
 
-static bool video_conv_hash_upstream_data(VideoConv *conv, struct payload_hash *hash)
+static bool video_conv_hash_upstream_data(VideoConv *conv, struct fozdb_hash *hash)
 {
     bool ret = false;
 
@@ -613,7 +613,7 @@ static int video_conv_dump_upstream_chunk(VideoConv *conv, const void *buffer, s
         GList **chunk_hashes)
 {
     struct bytes_reader bytes_reader;
-    struct payload_hash *chunk_hash;
+    struct fozdb_hash *chunk_hash;
 
     bytes_reader_init(&bytes_reader, buffer, read_size);
     chunk_hash = calloc(1, sizeof(*chunk_hash));
@@ -625,7 +625,7 @@ static int video_conv_dump_upstream_chunk(VideoConv *conv, const void *buffer, s
             &bytes_reader, bytes_reader_read, true);
 }
 
-static int video_conv_dump_upstream_data(VideoConv *conv, struct payload_hash *hash)
+static int video_conv_dump_upstream_data(VideoConv *conv, struct fozdb_hash *hash)
 {
     struct hashes_reader chunk_hashes_reader;
     struct pad_reader *pad_reader = NULL;
@@ -683,7 +683,7 @@ done:
 static void video_conv_init_transcode(VideoConv *conv)
 {
     struct video_conv_state *state = conv->state;
-    struct payload_hash hash;
+    struct fozdb_hash hash;
     int ret;
 
     if (state->state_flags & VIDEO_CONV_HAS_TRANSCODED)
@@ -725,7 +725,7 @@ static uint32_t video_conv_get_state_flags(VideoConv *conv)
     return state_flags;
 }
 
-static gboolean video_conv_push_stream_start(VideoConv *conv, struct payload_hash *hash)
+static gboolean video_conv_push_stream_start(VideoConv *conv, struct fozdb_hash *hash)
 {
     struct video_conv_state *state;
 
@@ -802,7 +802,7 @@ static gboolean video_conv_sink_event_caps(VideoConv *conv, GstEvent *event)
 static gboolean video_conv_sink_event_eos(VideoConv *conv, GstEvent *event)
 {
     struct video_conv_state *state;
-    struct payload_hash hash;
+    struct fozdb_hash hash;
     uint32_t transcode_tag;
     uint32_t state_flags;
     int ret;
@@ -1178,7 +1178,7 @@ static gboolean video_conv_src_active_mode(GstPad *pad, GstObject *parent, GstPa
 {
     VideoConv *conv = VIDEO_CONV(parent);
     struct video_conv_state *state;
-    struct payload_hash hash;
+    struct fozdb_hash hash;
     uint32_t state_flags;
 
     GST_DEBUG_OBJECT(pad, "mode %s, active %d.", gst_pad_mode_get_name(mode), active);
-- 
2.49.0

From 1bfdcd7cf664782e3f589ae0f1d0e86ae0f81074 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 5 Dec 2024 10:55:30 +0100
Subject: [PATCH 0562/1564] winegstreamer/media-converter: Rename entry_name to
 fozdb_key.

---
 dlls/winegstreamer/media-converter/audioconv.c       |  4 ++--
 dlls/winegstreamer/media-converter/fossilize.c       | 12 ++++++------
 dlls/winegstreamer/media-converter/media-converter.h |  8 ++++----
 3 files changed, 12 insertions(+), 12 deletions(-)

diff --git a/dlls/winegstreamer/media-converter/audioconv.c b/dlls/winegstreamer/media-converter/audioconv.c
index 5acce9a7915..8d69d813416 100644
--- a/dlls/winegstreamer/media-converter/audioconv.c
+++ b/dlls/winegstreamer/media-converter/audioconv.c
@@ -329,7 +329,7 @@ static void dump_fozdb_discard_transcoded(void)
 
                 for (list_iter = stream_chunks; list_iter; list_iter = list_iter->next)
                 {
-                    struct entry_name *entry = list_iter->data;
+                    struct fozdb_key *entry = list_iter->data;
                     if (has_all)
                     {
                         chunks_to_discard = g_list_append(chunks_to_discard,
@@ -358,7 +358,7 @@ static void dump_fozdb_discard_transcoded(void)
 
     for (list_iter = chunks_to_discard; list_iter; list_iter = list_iter->next)
     {
-        struct entry_name *entry = list_iter->data;
+        struct fozdb_key *entry = list_iter->data;
         if (!g_list_find_custom(chunks_to_keep, entry, entry_name_compare))
             chunks = g_list_append(chunks, entry_name_create(entry->tag, &entry->hash));
     }
diff --git a/dlls/winegstreamer/media-converter/fossilize.c b/dlls/winegstreamer/media-converter/fossilize.c
index 44a9cbf7c65..c1fadcd5242 100644
--- a/dlls/winegstreamer/media-converter/fossilize.c
+++ b/dlls/winegstreamer/media-converter/fossilize.c
@@ -272,7 +272,7 @@ static bool fozdb_write_entry_name(struct fozdb *db, uint32_t tag, struct fozdb_
 
 /* Copy an entry to write_pos. */
 static int fozdb_copy_entry(struct fozdb *db,
-        struct entry_name *name, struct payload_header *header, uint64_t entry_data_offset)
+        struct fozdb_key *key, struct payload_header *header, uint64_t entry_data_offset)
 {
     uint64_t read_offset, entry_end = entry_data_offset + header->size;
     ssize_t read_size;
@@ -285,7 +285,7 @@ static int fozdb_copy_entry(struct fozdb *db,
     }
 
     /* Write entry name. */
-    if (!fozdb_write_entry_name(db, name->tag, &name->hash))
+    if (!fozdb_write_entry_name(db, key->tag, &key->hash))
         return CONV_ERROR_WRITE_FAILED;
     db->write_pos += ENTRY_NAME_SIZE;
 
@@ -677,15 +677,15 @@ int fozdb_discard_entries(struct fozdb *db, GList *to_discard_names)
     {
         struct payload_header header;
         uint64_t entry_data_offset;
-        struct entry_name name;
+        struct fozdb_key key;
         bool truncated;
 
-        if ((ret = fozdb_read_entry_tag_hash_header(db, &name.tag, &name.hash, &header) < 0))
+        if ((ret = fozdb_read_entry_tag_hash_header(db, &key.tag, &key.hash, &header) < 0))
             return CONV_ERROR_READ_FAILED;
         entry_data_offset = lseek(db->file, 0, SEEK_CUR);
 
         /* Check if entry should be discarded. */
-        if (g_list_find_custom(to_discard_names, &name, entry_name_compare))
+        if (g_list_find_custom(to_discard_names, &key, entry_name_compare))
         {
             if (!fozdb_seek_to_next_entry(db, &header, &truncated))
                 return CONV_ERROR_SEEK_FAILED;
@@ -706,7 +706,7 @@ int fozdb_discard_entries(struct fozdb *db, GList *to_discard_names)
             else
             {
                 /* We're offset, so we have to rewrite. */
-                if ((ret = fozdb_copy_entry(db, &name, &header, entry_data_offset)) < 0)
+                if ((ret = fozdb_copy_entry(db, &key, &header, entry_data_offset)) < 0)
                     return ret;
             }
         }
diff --git a/dlls/winegstreamer/media-converter/media-converter.h b/dlls/winegstreamer/media-converter/media-converter.h
index d737040ad15..3d82681d495 100644
--- a/dlls/winegstreamer/media-converter/media-converter.h
+++ b/dlls/winegstreamer/media-converter/media-converter.h
@@ -102,7 +102,7 @@ static inline const char *debugstr_fozdb_hash_( char *buffer, const struct fozdb
     return buffer;
 }
 
-struct entry_name
+struct fozdb_key
 {
     uint32_t tag;
     struct fozdb_hash hash;
@@ -265,9 +265,9 @@ static inline bool file_exists(const char *file_path)
     return access(file_path, F_OK) == 0;
 }
 
-static inline struct entry_name *entry_name_create(uint32_t tag, struct fozdb_hash *hash)
+static inline struct fozdb_key *entry_name_create(uint32_t tag, struct fozdb_hash *hash)
 {
-    struct entry_name *entry = calloc(1, sizeof(*entry));
+    struct fozdb_key *entry = calloc(1, sizeof(*entry));
     entry->tag = tag;
     entry->hash = *hash;
     return entry;
@@ -275,7 +275,7 @@ static inline struct entry_name *entry_name_create(uint32_t tag, struct fozdb_ha
 
 static inline gint entry_name_compare(const void *a, const void *b)
 {
-    return memcmp(a, b, sizeof(struct entry_name));
+    return memcmp(a, b, sizeof(struct fozdb_key));
 }
 
 static inline uint32_t bytes_to_uint32(const uint8_t *bytes)
-- 
2.49.0

From 1159d1d781d5c8c62e6f42d74c5f3614fee79223 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 5 Dec 2024 10:57:41 +0100
Subject: [PATCH 0563/1564] winegstreamer/media-converter: Use a rb_tree rather
 than a GList.

---
 .../winegstreamer/media-converter/audioconv.c | 45 +++++++++----------
 .../winegstreamer/media-converter/fossilize.c | 34 ++++++++++++--
 .../media-converter/media-converter.h         | 26 +++++------
 .../winegstreamer/media-converter/videoconv.c | 14 +++---
 4 files changed, 69 insertions(+), 50 deletions(-)

diff --git a/dlls/winegstreamer/media-converter/audioconv.c b/dlls/winegstreamer/media-converter/audioconv.c
index 8d69d813416..e6f2c727268 100644
--- a/dlls/winegstreamer/media-converter/audioconv.c
+++ b/dlls/winegstreamer/media-converter/audioconv.c
@@ -269,8 +269,11 @@ static int dump_fozdb_open_audio(bool create)
 
 static void dump_fozdb_discard_transcoded(void)
 {
-    GList *chunks_to_discard = NULL, *chunks_to_keep = NULL, *chunks = NULL, *list_iter;
+    struct rb_tree chunks_to_discard = {fozdb_entry_compare};
+    struct rb_tree chunks_to_keep = {fozdb_entry_compare};
+    struct rb_tree chunks = {fozdb_entry_compare};
     struct fozdb_hash chunk_id, *stream_id;
+    struct fozdb_entry *chunk;
     struct fozdb *read_fozdb;
     char *read_fozdb_path;
     GHashTableIter iter;
@@ -312,7 +315,7 @@ static void dump_fozdb_discard_transcoded(void)
             if (fozdb_read_entry_data(dump_fozdb.fozdb, AUDIO_CONV_FOZ_TAG_STREAM, stream_id,
                     0, buffer, chunks_size, &read_size, true) == CONV_OK)
             {
-                GList *stream_chunks = NULL;
+                struct rb_tree stream_chunks = {fozdb_entry_compare};
                 bool has_all = true;
 
                 for (i = 0; i < read_size / sizeof(chunk_id); ++i)
@@ -323,55 +326,47 @@ static void dump_fozdb_discard_transcoded(void)
                         has_all = false;
                         break;
                     }
-                    stream_chunks = g_list_append(stream_chunks,
-                            entry_name_create(AUDIO_CONV_FOZ_TAG_AUDIODATA, &chunk_id));
+                    fozdb_entry_put(&stream_chunks, AUDIO_CONV_FOZ_TAG_AUDIODATA, &chunk_id);
                 }
 
-                for (list_iter = stream_chunks; list_iter; list_iter = list_iter->next)
+                RB_FOR_EACH_ENTRY(chunk, &stream_chunks, struct fozdb_entry, entry)
                 {
-                    struct fozdb_key *entry = list_iter->data;
                     if (has_all)
                     {
-                        chunks_to_discard = g_list_append(chunks_to_discard,
-                                entry_name_create(entry->tag, &entry->hash));
-                        chunks_to_discard = g_list_append(chunks_to_discard,
-                                entry_name_create(AUDIO_CONV_FOZ_TAG_CODECINFO, &entry->hash));
+                        fozdb_entry_put(&chunks_to_discard, chunk->key.tag, &chunk->key.hash);
+                        fozdb_entry_put(&chunks_to_discard, AUDIO_CONV_FOZ_TAG_CODECINFO, &chunk->key.hash);
                     }
                     else
                     {
-                        chunks_to_keep = g_list_append(chunks_to_keep,
-                                entry_name_create(entry->tag, &entry->hash));
-                        chunks_to_keep = g_list_append(chunks_to_keep,
-                                entry_name_create(AUDIO_CONV_FOZ_TAG_CODECINFO, &entry->hash));
+                        fozdb_entry_put(&chunks_to_keep, chunk->key.tag, &chunk->key.hash);
+                        fozdb_entry_put(&chunks_to_keep, AUDIO_CONV_FOZ_TAG_CODECINFO, &chunk->key.hash);
                     }
                 }
 
                 if (has_all)
-                    chunks_to_discard = g_list_append(chunks_to_discard,
-                            entry_name_create(AUDIO_CONV_FOZ_TAG_STREAM, stream_id));
+                    fozdb_entry_put(&chunks_to_discard, AUDIO_CONV_FOZ_TAG_STREAM, stream_id);
 
-                g_list_free_full(stream_chunks, free);
+                rb_destroy(&stream_chunks, fozdb_entry_destroy, NULL);
             }
             free(buffer);
         }
     }
 
-    for (list_iter = chunks_to_discard; list_iter; list_iter = list_iter->next)
+    RB_FOR_EACH_ENTRY(chunk, &chunks_to_discard, struct fozdb_entry, entry)
     {
-        struct fozdb_key *entry = list_iter->data;
-        if (!g_list_find_custom(chunks_to_keep, entry, entry_name_compare))
-            chunks = g_list_append(chunks, entry_name_create(entry->tag, &entry->hash));
+        if (!rb_get(&chunks_to_keep, chunk))
+            fozdb_entry_put(&chunks, chunk->key.tag, &chunk->key.hash);
     }
 
-    if ((ret = fozdb_discard_entries(dump_fozdb.fozdb, chunks)) < 0)
+    if ((ret = fozdb_discard_entries(dump_fozdb.fozdb, &chunks)) < 0)
     {
         GST_ERROR("Failed to discard entries, ret %d.", ret);
         dump_fozdb_close(&dump_fozdb);
     }
 
-    g_list_free_full(chunks, free);
-    g_list_free_full(chunks_to_keep, free);
-    g_list_free_full(chunks_to_discard, free);
+    rb_destroy(&chunks, fozdb_entry_destroy, NULL);
+    rb_destroy(&chunks_to_keep, fozdb_entry_destroy, NULL);
+    rb_destroy(&chunks_to_discard, fozdb_entry_destroy, NULL);
 }
 
 static bool need_transcode_head_create_from_caps(GstCaps *caps, struct need_transcode_head **out)
diff --git a/dlls/winegstreamer/media-converter/fossilize.c b/dlls/winegstreamer/media-converter/fossilize.c
index c1fadcd5242..08297cd861b 100644
--- a/dlls/winegstreamer/media-converter/fossilize.c
+++ b/dlls/winegstreamer/media-converter/fossilize.c
@@ -101,6 +101,34 @@ struct payload_entry
     uint64_t offset;
 };
 
+int fozdb_entry_compare( const void *key, const struct rb_entry *ptr )
+{
+    const struct fozdb_entry *entry = RB_ENTRY_VALUE( ptr, const struct fozdb_entry, entry );
+    return memcmp( key, &entry->key, sizeof(entry->key) );
+}
+
+void fozdb_entry_destroy( struct rb_entry *entry, void *context )
+{
+    struct fozdb_entry *chunk = RB_ENTRY_VALUE( entry, struct fozdb_entry, entry );
+    free( chunk );
+}
+
+struct fozdb_entry *fozdb_entry_put( struct rb_tree *tree, uint32_t tag, const struct fozdb_hash *hash )
+{
+    struct fozdb_key key = {.tag = tag, .hash = *hash};
+    struct fozdb_entry *entry;
+
+    if (!(entry = malloc( sizeof(*entry) )) ||
+        rb_put( tree, &key, &entry->entry ))
+    {
+        free( entry );
+        return NULL;
+    }
+
+    entry->key = key;
+    return entry;
+}
+
 static guint hash_func(gconstpointer key)
 {
     const struct fozdb_hash *fozdb_hash = key;
@@ -648,13 +676,13 @@ int fozdb_write_entry(struct fozdb *db, uint32_t tag, struct fozdb_hash *hash,
 }
 
 /* Rewrites the database, discarding entries listed. */
-int fozdb_discard_entries(struct fozdb *db, GList *to_discard_names)
+int fozdb_discard_entries(struct fozdb *db, struct rb_tree *to_discard)
 {
     uint8_t entry_name_and_header[ENTRY_NAME_SIZE + sizeof(struct payload_header)];
     uint64_t file_size;
     int i, ret;
 
-    GST_DEBUG("db %p, file_name %s, to_discard_entries %p.", db, db->file_name, to_discard_names);
+    GST_DEBUG("db %p, file_name %s, to_discard %p.", db, db->file_name, to_discard);
 
     /* Rewind the file and clear the entry tables. */
     if (lseek(db->file, 0, SEEK_SET) < 0)
@@ -685,7 +713,7 @@ int fozdb_discard_entries(struct fozdb *db, GList *to_discard_names)
         entry_data_offset = lseek(db->file, 0, SEEK_CUR);
 
         /* Check if entry should be discarded. */
-        if (g_list_find_custom(to_discard_names, &key, entry_name_compare))
+        if (rb_get(to_discard, &key))
         {
             if (!fozdb_seek_to_next_entry(db, &header, &truncated))
                 return CONV_ERROR_SEEK_FAILED;
diff --git a/dlls/winegstreamer/media-converter/media-converter.h b/dlls/winegstreamer/media-converter/media-converter.h
index 3d82681d495..7150c46689b 100644
--- a/dlls/winegstreamer/media-converter/media-converter.h
+++ b/dlls/winegstreamer/media-converter/media-converter.h
@@ -30,6 +30,7 @@
 #include <sys/stat.h>
 
 #include "unix_private.h"
+#include "wine/rbtree.h"
 
 GST_DEBUG_CATEGORY_EXTERN(media_converter_debug);
 #undef GST_CAT_DEFAULT
@@ -108,6 +109,16 @@ struct fozdb_key
     struct fozdb_hash hash;
 };
 
+struct fozdb_entry
+{
+    struct rb_entry entry;
+    struct fozdb_key key;
+};
+
+extern int fozdb_entry_compare( const void *key, const struct rb_entry *ptr );
+extern void fozdb_entry_destroy( struct rb_entry *entry, void *context );
+extern struct fozdb_entry *fozdb_entry_put( struct rb_tree *tree, uint32_t tag, const struct fozdb_hash *hash );
+
 struct dump_fozdb
 {
     pthread_mutex_t mutex;
@@ -171,7 +182,7 @@ extern int fozdb_read_entry_data(struct fozdb *db, uint32_t tag, struct fozdb_ha
         uint64_t offset, uint8_t *buffer, size_t size, size_t *read_size, bool with_crc);
 extern int fozdb_write_entry(struct fozdb *db, uint32_t tag, struct fozdb_hash *hash,
         void *data_src, data_read_callback read_callback, bool with_crc);
-extern int fozdb_discard_entries(struct fozdb *db, GList *to_discard_entries);
+extern int fozdb_discard_entries(struct fozdb *db, struct rb_tree *to_discard);
 
 static inline bool option_enabled(const char *env)
 {
@@ -265,19 +276,6 @@ static inline bool file_exists(const char *file_path)
     return access(file_path, F_OK) == 0;
 }
 
-static inline struct fozdb_key *entry_name_create(uint32_t tag, struct fozdb_hash *hash)
-{
-    struct fozdb_key *entry = calloc(1, sizeof(*entry));
-    entry->tag = tag;
-    entry->hash = *hash;
-    return entry;
-}
-
-static inline gint entry_name_compare(const void *a, const void *b)
-{
-    return memcmp(a, b, sizeof(struct fozdb_key));
-}
-
 static inline uint32_t bytes_to_uint32(const uint8_t *bytes)
 {
     return ((uint32_t)bytes[0] << 0)
diff --git a/dlls/winegstreamer/media-converter/videoconv.c b/dlls/winegstreamer/media-converter/videoconv.c
index b91e0e27d8c..d27a1c11a48 100644
--- a/dlls/winegstreamer/media-converter/videoconv.c
+++ b/dlls/winegstreamer/media-converter/videoconv.c
@@ -175,7 +175,7 @@ static int dump_fozdb_open_video(bool create)
 
 static void dump_fozdb_discard_transcoded(void)
 {
-    GList *to_discard_chunks = NULL;
+    struct rb_tree to_discard_chunks = {fozdb_entry_compare};
     struct fozdb_hash *stream_id;
     struct fozdb *read_fozdb;
     char *read_fozdb_path;
@@ -224,25 +224,23 @@ static void dump_fozdb_discard_transcoded(void)
                     for (i = 0; i < read_size / sizeof(chunk_id); ++i)
                     {
                         fozdb_hash_from_bytes(&chunk_id, buffer + i * sizeof(chunk_id));
-                        to_discard_chunks = g_list_append(to_discard_chunks,
-                                entry_name_create(VIDEO_CONV_FOZ_TAG_VIDEODATA, &chunk_id));
+                        fozdb_entry_put(&to_discard_chunks, VIDEO_CONV_FOZ_TAG_VIDEODATA, &chunk_id);
                     }
                 }
                 free(buffer);
             }
 
-            to_discard_chunks = g_list_append(to_discard_chunks,
-                    entry_name_create(VIDEO_CONV_FOZ_TAG_STREAM, stream_id));
+            fozdb_entry_put(&to_discard_chunks, VIDEO_CONV_FOZ_TAG_STREAM, stream_id);
         }
     }
 
-    if ((ret = fozdb_discard_entries(dump_fozdb.fozdb, to_discard_chunks)) < 0)
+    if ((ret = fozdb_discard_entries(dump_fozdb.fozdb, &to_discard_chunks)) < 0)
     {
         GST_ERROR("Failed to discard entries, ret %d.", ret);
         dump_fozdb_close(&dump_fozdb);
     }
 
-    g_list_free_full(to_discard_chunks, free);
+    rb_destroy(&to_discard_chunks, fozdb_entry_destroy, NULL);
 }
 
 struct pad_reader *pad_reader_create_with_stride(GstPad *pad, size_t stride)
@@ -1423,4 +1421,4 @@ done:
         free(buffer);
     pthread_mutex_unlock(&conv->state_mutex);
     return ret;
-}
\ No newline at end of file
+}
-- 
2.49.0

From 1b019bcecb2df6e61ac0c9bdc8e6a04485ab52c1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 5 Dec 2024 11:19:39 +0100
Subject: [PATCH 0564/1564] winegstreamer/media-converter: Use a rb tree for
 file chunks.

---
 .../winegstreamer/media-converter/audioconv.c |  23 ++--
 .../winegstreamer/media-converter/fossilize.c | 125 +++++++++---------
 .../media-converter/media-converter.h         |  16 ++-
 .../winegstreamer/media-converter/videoconv.c |  14 +-
 4 files changed, 90 insertions(+), 88 deletions(-)

diff --git a/dlls/winegstreamer/media-converter/audioconv.c b/dlls/winegstreamer/media-converter/audioconv.c
index e6f2c727268..ef085dcd6c6 100644
--- a/dlls/winegstreamer/media-converter/audioconv.c
+++ b/dlls/winegstreamer/media-converter/audioconv.c
@@ -272,11 +272,10 @@ static void dump_fozdb_discard_transcoded(void)
     struct rb_tree chunks_to_discard = {fozdb_entry_compare};
     struct rb_tree chunks_to_keep = {fozdb_entry_compare};
     struct rb_tree chunks = {fozdb_entry_compare};
-    struct fozdb_hash chunk_id, *stream_id;
-    struct fozdb_entry *chunk;
+    struct fozdb_entry *entry, *chunk;
+    struct fozdb_hash chunk_id;
     struct fozdb *read_fozdb;
     char *read_fozdb_path;
-    GHashTableIter iter;
     int ret;
 
     if (dump_fozdb.already_cleaned)
@@ -303,16 +302,15 @@ static void dump_fozdb_discard_transcoded(void)
         return;
     }
 
-    fozdb_iter_tag(dump_fozdb.fozdb, AUDIO_CONV_FOZ_TAG_STREAM, &iter);
-    while (g_hash_table_iter_next(&iter, (void *)&stream_id, NULL))
+    FOZDB_FOR_EACH_TAG_ENTRY(entry, AUDIO_CONV_FOZ_TAG_STREAM, dump_fozdb.fozdb)
     {
         uint32_t chunks_size, i;
         size_t read_size;
 
-        if (fozdb_entry_size(dump_fozdb.fozdb, AUDIO_CONV_FOZ_TAG_STREAM, stream_id, &chunks_size) == CONV_OK)
+        if (fozdb_entry_size(dump_fozdb.fozdb, AUDIO_CONV_FOZ_TAG_STREAM, &entry->key.hash, &chunks_size) == CONV_OK)
         {
             uint8_t *buffer = calloc(1, chunks_size);
-            if (fozdb_read_entry_data(dump_fozdb.fozdb, AUDIO_CONV_FOZ_TAG_STREAM, stream_id,
+            if (fozdb_read_entry_data(dump_fozdb.fozdb, AUDIO_CONV_FOZ_TAG_STREAM, &entry->key.hash,
                     0, buffer, chunks_size, &read_size, true) == CONV_OK)
             {
                 struct rb_tree stream_chunks = {fozdb_entry_compare};
@@ -344,7 +342,7 @@ static void dump_fozdb_discard_transcoded(void)
                 }
 
                 if (has_all)
-                    fozdb_entry_put(&chunks_to_discard, AUDIO_CONV_FOZ_TAG_STREAM, stream_id);
+                    fozdb_entry_put(&chunks_to_discard, AUDIO_CONV_FOZ_TAG_STREAM, &entry->key.hash);
 
                 rb_destroy(&stream_chunks, fozdb_entry_destroy, NULL);
             }
@@ -605,13 +603,12 @@ static int stream_state_write_to_foz(struct stream_state *state)
     if (!found)
     {
         /* Are there any recorded streams of which this stream is a subset? */
-        struct fozdb_hash *stream_id;
-        GHashTableIter stream_ids;
+        struct fozdb_entry *entry;
 
-        fozdb_iter_tag(dump_fozdb.fozdb, AUDIO_CONV_FOZ_TAG_STREAM, &stream_ids);
-        while (g_hash_table_iter_next(&stream_ids, (void **)&stream_id, NULL))
+        RB_FOR_EACH_ENTRY(entry, &dump_fozdb.fozdb->entries, struct fozdb_entry, entry)
         {
-            if (stream_state_is_stream_subset(state, dump_fozdb.fozdb, stream_id))
+            if (entry->key.tag != AUDIO_CONV_FOZ_TAG_STREAM) continue;
+            if (stream_state_is_stream_subset(state, dump_fozdb.fozdb, &entry->key.hash))
             {
                 found = true;
                 break;
diff --git a/dlls/winegstreamer/media-converter/fossilize.c b/dlls/winegstreamer/media-converter/fossilize.c
index 08297cd861b..36148d0c3ba 100644
--- a/dlls/winegstreamer/media-converter/fossilize.c
+++ b/dlls/winegstreamer/media-converter/fossilize.c
@@ -94,13 +94,6 @@ struct payload_header
     uint32_t full_size;
 } __attribute__((packed));
 
-struct payload_entry
-{
-    struct fozdb_hash hash;
-    struct payload_header header;
-    uint64_t offset;
-};
-
 int fozdb_entry_compare( const void *key, const struct rb_entry *ptr )
 {
     const struct fozdb_entry *entry = RB_ENTRY_VALUE( ptr, const struct fozdb_entry, entry );
@@ -129,19 +122,20 @@ struct fozdb_entry *fozdb_entry_put( struct rb_tree *tree, uint32_t tag, const s
     return entry;
 }
 
-static guint hash_func(gconstpointer key)
+struct rb_entry *fozdb_tag_head( struct rb_tree *tree, uint32_t tag )
 {
-    const struct fozdb_hash *fozdb_hash = key;
+    struct rb_entry *entry = tree->root, *head = entry;
+    struct fozdb_key key = {.tag = tag};
 
-    return fozdb_hash->hash[0]
-            ^ fozdb_hash->hash[1]
-            ^ fozdb_hash->hash[2]
-            ^ fozdb_hash->hash[3];
-}
+    while (entry)
+    {
+        int c = tree->compare( &key, entry );
+        if (!c) return entry;
+        if (c < 0) head = entry;
+        entry = c < 0 ? entry->left : entry->right;
+    }
 
-static gboolean hash_equal(gconstpointer a, gconstpointer b)
-{
-    return memcmp(a, b, sizeof(struct fozdb_hash)) == 0;
+    return head;
 }
 
 static bool tag_from_ascii_bytes(uint32_t *tag, const uint8_t *ascii_bytes)
@@ -376,7 +370,6 @@ static int fozdb_copy_entry(struct fozdb *db,
 int fozdb_create(const char *file_name, int open_flags, bool read_only, uint32_t num_tags, struct fozdb **out)
 {
     struct fozdb *db;
-    size_t i;
     int ret;
 
     GST_DEBUG("file_name %s, open_flags %d, read_only %d, num_tags %u, out %p.",
@@ -395,9 +388,7 @@ int fozdb_create(const char *file_name, int open_flags, bool read_only, uint32_t
     db->read_only = read_only;
 
     /* Create entry hash tables. */
-    db->seen_blobs = calloc(num_tags, sizeof(*db->seen_blobs));
-    for (i = 0; i < num_tags; ++i)
-        db->seen_blobs[i] = g_hash_table_new_full(hash_func, hash_equal, NULL, free);
+    rb_init(&db->entries, fozdb_entry_compare);
 
     /* Load entries. */
     if ((ret = fozdb_prepare(db)) < 0)
@@ -415,13 +406,9 @@ int fozdb_create(const char *file_name, int open_flags, bool read_only, uint32_t
 
 void fozdb_release(struct fozdb *db)
 {
-    int i;
-
     GST_DEBUG("db %p.", db);
 
-    for (i = 0; i < db->num_tags; ++i)
-        g_hash_table_destroy(db->seen_blobs[i]);
-    free(db->seen_blobs);
+    rb_destroy(&db->entries, fozdb_entry_destroy, NULL);
     close(db->file);
     free(db);
 }
@@ -464,23 +451,26 @@ int fozdb_prepare(struct fozdb *db)
         return ret;
     db->write_pos = lseek(db->file, 0, SEEK_CUR);
 
-    /* Read entries to seen_blobs. */
+    /* Read entries to chunks. */
     while (db->write_pos < file_size)
     {
-        struct payload_entry entry, *table_entry;
+        struct payload_header header;
+        struct fozdb_entry *entry;
+        struct fozdb_hash hash;
+        uint64_t offset;
         uint32_t tag;
 
         /* Read an entry. */
-        if ((ret = fozdb_read_entry_tag_hash_header(db, &tag, &entry.hash, &entry.header) < 0))
+        if ((ret = fozdb_read_entry_tag_hash_header(db, &tag, &hash, &header) < 0))
             return ret;
-        entry.offset = lseek(db->file, 0, SEEK_CUR);
+        offset = lseek(db->file, 0, SEEK_CUR);
 
-        if (!fozdb_seek_to_next_entry(db, &entry.header, NULL))
+        if (!fozdb_seek_to_next_entry(db, &header, NULL))
             return CONV_ERROR_SEEK_FAILED;
         db->write_pos = lseek(db->file, 0, SEEK_CUR);
 
         GST_INFO("Got entry: tag %u, hash %s, offset %#"PRIx64", size %#x, crc %#x.",
-                tag, format_hash(&entry.hash), entry.offset, entry.header.size, entry.header.crc);
+                tag, format_hash(&hash), offset, header.size, header.crc);
 
         /* Insert entry to hash table. */
         if (tag >= db->num_tags)
@@ -493,9 +483,15 @@ int fozdb_prepare(struct fozdb *db)
             else
                 return CONV_ERROR_INVALID_TAG;
         }
-        table_entry = calloc(1, sizeof(*table_entry));
-        *table_entry = entry;
-        g_hash_table_insert(db->seen_blobs[tag], &table_entry->hash, table_entry);
+
+        if ((entry = fozdb_entry_put( &db->entries, tag, &hash )))
+        {
+            entry->size = header.size;
+            entry->compression = header.compression;
+            entry->crc = header.crc;
+            entry->full_size = header.full_size;
+            entry->offset = offset;
+        }
     }
 
     return CONV_OK;
@@ -503,39 +499,35 @@ int fozdb_prepare(struct fozdb *db)
 
 bool fozdb_has_entry(struct fozdb *db, uint32_t tag, struct fozdb_hash *hash)
 {
+    struct fozdb_key key = {.tag = tag, .hash = *hash};
     if (tag >= db->num_tags)
         return false;
-    return g_hash_table_contains(db->seen_blobs[tag], hash);
+    return rb_get(&db->entries, &key);
 }
 
 int fozdb_entry_size(struct fozdb *db, uint32_t tag, struct fozdb_hash *hash, uint32_t *size)
 {
-    struct payload_entry *entry;
+    struct fozdb_key key = {.tag = tag, .hash = *hash};
+    struct fozdb_entry *entry;
+    struct rb_entry *ptr;
 
     if (tag >= db->num_tags)
         return CONV_ERROR_INVALID_TAG;
-    if (!(entry = g_hash_table_lookup(db->seen_blobs[tag], hash)))
+    if (!(ptr = rb_get(&db->entries, &key)))
         return CONV_ERROR_ENTRY_NOT_FOUND;
 
-    *size = entry->header.full_size;
+    entry = RB_ENTRY_VALUE(ptr, struct fozdb_entry, entry);
+    *size = entry->full_size;
 
     return CONV_OK;
 }
 
-void fozdb_iter_tag(struct fozdb *db, uint32_t tag, GHashTableIter *iter)
-{
-    if (tag > db->num_tags)
-    {
-        GST_ERROR("Invalid tag %u.", tag);
-        return;
-    }
-    g_hash_table_iter_init(iter, db->seen_blobs[tag]);
-}
-
 int fozdb_read_entry_data(struct fozdb *db, uint32_t tag, struct fozdb_hash *hash,
         uint64_t offset, uint8_t *buffer, size_t size, size_t *read_size, bool with_crc)
 {
-    struct payload_entry *entry;
+    struct fozdb_key key = {.tag = tag, .hash = *hash};
+    struct fozdb_entry *entry;
+    struct rb_entry *ptr;
     size_t to_copy;
 
     GST_DEBUG("db %p, file_name %s, tag %u, hash %s, offset %#"PRIx64", buffer %p, size %zu, read_size %p, with_crc %d.",
@@ -543,19 +535,20 @@ int fozdb_read_entry_data(struct fozdb *db, uint32_t tag, struct fozdb_hash *has
 
     if (tag >= db->num_tags)
         return CONV_ERROR_INVALID_TAG;
-    if (!(entry = g_hash_table_lookup(db->seen_blobs[tag], hash)))
+    if (!(ptr = rb_get(&db->entries, &key)))
         return CONV_ERROR_ENTRY_NOT_FOUND;
+    entry = RB_ENTRY_VALUE(ptr, struct fozdb_entry, entry);
 
-    if (entry->header.compression != FOZDB_COMPRESSION_NONE)
+    if (entry->compression != FOZDB_COMPRESSION_NONE)
         return CONV_ERROR_NOT_IMPLEMENTED;
 
-    if (offset >= entry->header.full_size)
+    if (offset >= entry->full_size)
         return CONV_OK;
 
     if (lseek(db->file, entry->offset + offset, SEEK_SET) < 0)
         return CONV_ERROR_SEEK_FAILED;
 
-    to_copy = min(entry->header.full_size - offset, size);
+    to_copy = min(entry->full_size - offset, size);
     if (!complete_read(db->file, buffer, to_copy))
     {
         GST_ERROR("Failed to read entry data.");
@@ -563,7 +556,7 @@ int fozdb_read_entry_data(struct fozdb *db, uint32_t tag, struct fozdb_hash *has
     }
     *read_size = to_copy;
 
-    if (entry->header.crc != 0 && with_crc && entry->header.crc != crc32(0, buffer, to_copy))
+    if (entry->crc != 0 && with_crc && entry->crc != crc32(0, buffer, to_copy))
     {
         GST_ERROR("Wrong check sum.");
         return CONV_ERROR_WRONG_CHECKSUM;
@@ -576,7 +569,7 @@ int fozdb_write_entry(struct fozdb *db, uint32_t tag, struct fozdb_hash *hash,
         void *data_src, data_read_callback read_callback, bool with_crc)
 {
     struct payload_header header;
-    struct payload_entry *entry;
+    struct fozdb_entry *entry;
     off_t header_offset;
     uint32_t size = 0;
     size_t read_size;
@@ -663,14 +656,17 @@ int fozdb_write_entry(struct fozdb *db, uint32_t tag, struct fozdb_hash *hash,
     }
 
     /* Success. Record entry and exit. */
-    entry = calloc(1, sizeof(*entry));
-    entry->header = header;
-    entry->hash = *hash;
-    entry->offset = offset;
-    g_hash_table_insert(db->seen_blobs[tag], &entry->hash, entry);
+    if ((entry = fozdb_entry_put( &db->entries, tag, hash )))
+    {
+        entry->size = header.size;
+        entry->compression = header.compression;
+        entry->crc = header.crc;
+        entry->full_size = header.full_size;
+        entry->offset = offset;
+    }
 
     GST_INFO("Wrote entry: tag %u, hash %s, offset %#"PRIx64", size %#x, crc %#x.",
-            tag, format_hash(&entry->hash), entry->offset, entry->header.size, entry->header.crc);
+            tag, format_hash(hash), offset, header.size, header.crc);
 
     return CONV_OK;
 }
@@ -680,7 +676,7 @@ int fozdb_discard_entries(struct fozdb *db, struct rb_tree *to_discard)
 {
     uint8_t entry_name_and_header[ENTRY_NAME_SIZE + sizeof(struct payload_header)];
     uint64_t file_size;
-    int i, ret;
+    int ret;
 
     GST_DEBUG("db %p, file_name %s, to_discard %p.", db, db->file_name, to_discard);
 
@@ -690,8 +686,7 @@ int fozdb_discard_entries(struct fozdb *db, struct rb_tree *to_discard)
         GST_ERROR("Failed to seek to file start. %s.", strerror(errno));
         return CONV_ERROR_SEEK_FAILED;
     }
-    for (i = 0; i < db->num_tags; ++i)
-        g_hash_table_remove_all(db->seen_blobs[i]);
+    rb_destroy(&db->entries, fozdb_entry_destroy, NULL);
 
     /* Read file header. */
     if ((ret = fozdb_read_file_header(db)) < 0)
diff --git a/dlls/winegstreamer/media-converter/media-converter.h b/dlls/winegstreamer/media-converter/media-converter.h
index 7150c46689b..4790f1d054e 100644
--- a/dlls/winegstreamer/media-converter/media-converter.h
+++ b/dlls/winegstreamer/media-converter/media-converter.h
@@ -113,12 +113,25 @@ struct fozdb_entry
 {
     struct rb_entry entry;
     struct fozdb_key key;
+
+    uint32_t size;
+    uint32_t compression;
+    uint32_t crc;
+    uint32_t full_size;
+
+    uint64_t offset;
 };
 
 extern int fozdb_entry_compare( const void *key, const struct rb_entry *ptr );
 extern void fozdb_entry_destroy( struct rb_entry *entry, void *context );
 extern struct fozdb_entry *fozdb_entry_put( struct rb_tree *tree, uint32_t tag, const struct fozdb_hash *hash );
 
+extern struct rb_entry *fozdb_tag_head( struct rb_tree *tree, uint32_t tag );
+#define FOZDB_FOR_EACH_TAG_ENTRY( e, t, d )                                                       \
+    for ((e) = RB_ENTRY_VALUE( fozdb_tag_head( (&(d)->entries), t ), struct fozdb_entry, entry ); \
+         (e) != RB_ENTRY_VALUE( 0, struct fozdb_entry, entry ) && (e)->key.tag == (t);            \
+         (e) = RB_ENTRY_VALUE( rb_next( &e->entry ), struct fozdb_entry, entry ))
+
 struct dump_fozdb
 {
     pthread_mutex_t mutex;
@@ -129,10 +142,10 @@ struct dump_fozdb
 struct fozdb
 {
     const char *file_name;
+    struct rb_tree entries;
     int file;
     bool read_only;
     uint64_t write_pos;
-    GHashTable **seen_blobs;
     uint32_t num_tags;
 };
 
@@ -177,7 +190,6 @@ extern void fozdb_release(struct fozdb *db);
 extern int fozdb_prepare(struct fozdb *db);
 extern bool fozdb_has_entry(struct fozdb *db, uint32_t tag, struct fozdb_hash *hash);
 extern int fozdb_entry_size(struct fozdb *db, uint32_t tag, struct fozdb_hash *hash, uint32_t *size);
-extern void fozdb_iter_tag(struct fozdb *db, uint32_t tag, GHashTableIter *iter);
 extern int fozdb_read_entry_data(struct fozdb *db, uint32_t tag, struct fozdb_hash *hash,
         uint64_t offset, uint8_t *buffer, size_t size, size_t *read_size, bool with_crc);
 extern int fozdb_write_entry(struct fozdb *db, uint32_t tag, struct fozdb_hash *hash,
diff --git a/dlls/winegstreamer/media-converter/videoconv.c b/dlls/winegstreamer/media-converter/videoconv.c
index d27a1c11a48..9d917daf92d 100644
--- a/dlls/winegstreamer/media-converter/videoconv.c
+++ b/dlls/winegstreamer/media-converter/videoconv.c
@@ -176,10 +176,9 @@ static int dump_fozdb_open_video(bool create)
 static void dump_fozdb_discard_transcoded(void)
 {
     struct rb_tree to_discard_chunks = {fozdb_entry_compare};
-    struct fozdb_hash *stream_id;
+    struct fozdb_entry *entry;
     struct fozdb *read_fozdb;
     char *read_fozdb_path;
-    GHashTableIter iter;
     int ret;
 
     if (dump_fozdb.already_cleaned)
@@ -206,19 +205,18 @@ static void dump_fozdb_discard_transcoded(void)
         return;
     }
 
-    fozdb_iter_tag(dump_fozdb.fozdb, VIDEO_CONV_FOZ_TAG_STREAM, &iter);
-    while (g_hash_table_iter_next(&iter, (void **)&stream_id, NULL))
+    FOZDB_FOR_EACH_TAG_ENTRY(entry, VIDEO_CONV_FOZ_TAG_STREAM, dump_fozdb.fozdb)
     {
         struct fozdb_hash chunk_id;
         uint32_t chunks_size, i;
         size_t read_size;
 
-        if (fozdb_has_entry(read_fozdb, VIDEO_CONV_FOZ_TAG_OGVDATA, stream_id))
+        if (fozdb_has_entry(read_fozdb, VIDEO_CONV_FOZ_TAG_OGVDATA, &entry->key.hash))
         {
-            if (fozdb_entry_size(dump_fozdb.fozdb, VIDEO_CONV_FOZ_TAG_STREAM, stream_id, &chunks_size) == CONV_OK)
+            if (fozdb_entry_size(dump_fozdb.fozdb, VIDEO_CONV_FOZ_TAG_STREAM, &entry->key.hash, &chunks_size) == CONV_OK)
             {
                 uint8_t *buffer = calloc(1, chunks_size);
-                if (fozdb_read_entry_data(dump_fozdb.fozdb, VIDEO_CONV_FOZ_TAG_STREAM, stream_id,
+                if (fozdb_read_entry_data(dump_fozdb.fozdb, VIDEO_CONV_FOZ_TAG_STREAM, &entry->key.hash,
                         0, buffer, chunks_size, &read_size, true) == CONV_OK)
                 {
                     for (i = 0; i < read_size / sizeof(chunk_id); ++i)
@@ -230,7 +228,7 @@ static void dump_fozdb_discard_transcoded(void)
                 free(buffer);
             }
 
-            fozdb_entry_put(&to_discard_chunks, VIDEO_CONV_FOZ_TAG_STREAM, stream_id);
+            fozdb_entry_put(&to_discard_chunks, VIDEO_CONV_FOZ_TAG_STREAM, &entry->key.hash);
         }
     }
 
-- 
2.49.0

From 81da423d2fe069fa655a5f6a9d6c1b52f1cc2864 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 5 Dec 2024 11:14:23 +0100
Subject: [PATCH 0565/1564] winegstreamer/media-converter: Avoid unnecessary
 fozdb_entry_size calls.

---
 dlls/winegstreamer/media-converter/audioconv.c | 8 ++++----
 dlls/winegstreamer/media-converter/videoconv.c | 8 ++++----
 2 files changed, 8 insertions(+), 8 deletions(-)

diff --git a/dlls/winegstreamer/media-converter/audioconv.c b/dlls/winegstreamer/media-converter/audioconv.c
index ef085dcd6c6..11cde2f8d4a 100644
--- a/dlls/winegstreamer/media-converter/audioconv.c
+++ b/dlls/winegstreamer/media-converter/audioconv.c
@@ -304,14 +304,14 @@ static void dump_fozdb_discard_transcoded(void)
 
     FOZDB_FOR_EACH_TAG_ENTRY(entry, AUDIO_CONV_FOZ_TAG_STREAM, dump_fozdb.fozdb)
     {
-        uint32_t chunks_size, i;
+        uint32_t i;
         size_t read_size;
 
-        if (fozdb_entry_size(dump_fozdb.fozdb, AUDIO_CONV_FOZ_TAG_STREAM, &entry->key.hash, &chunks_size) == CONV_OK)
+        if (entry->full_size)
         {
-            uint8_t *buffer = calloc(1, chunks_size);
+            uint8_t *buffer = calloc(1, entry->full_size);
             if (fozdb_read_entry_data(dump_fozdb.fozdb, AUDIO_CONV_FOZ_TAG_STREAM, &entry->key.hash,
-                    0, buffer, chunks_size, &read_size, true) == CONV_OK)
+                    0, buffer, entry->full_size, &read_size, true) == CONV_OK)
             {
                 struct rb_tree stream_chunks = {fozdb_entry_compare};
                 bool has_all = true;
diff --git a/dlls/winegstreamer/media-converter/videoconv.c b/dlls/winegstreamer/media-converter/videoconv.c
index 9d917daf92d..d8b77e5e172 100644
--- a/dlls/winegstreamer/media-converter/videoconv.c
+++ b/dlls/winegstreamer/media-converter/videoconv.c
@@ -208,16 +208,16 @@ static void dump_fozdb_discard_transcoded(void)
     FOZDB_FOR_EACH_TAG_ENTRY(entry, VIDEO_CONV_FOZ_TAG_STREAM, dump_fozdb.fozdb)
     {
         struct fozdb_hash chunk_id;
-        uint32_t chunks_size, i;
+        uint32_t i;
         size_t read_size;
 
         if (fozdb_has_entry(read_fozdb, VIDEO_CONV_FOZ_TAG_OGVDATA, &entry->key.hash))
         {
-            if (fozdb_entry_size(dump_fozdb.fozdb, VIDEO_CONV_FOZ_TAG_STREAM, &entry->key.hash, &chunks_size) == CONV_OK)
+            if (entry->full_size)
             {
-                uint8_t *buffer = calloc(1, chunks_size);
+                uint8_t *buffer = calloc(1, entry->full_size);
                 if (fozdb_read_entry_data(dump_fozdb.fozdb, VIDEO_CONV_FOZ_TAG_STREAM, &entry->key.hash,
-                        0, buffer, chunks_size, &read_size, true) == CONV_OK)
+                        0, buffer, entry->full_size, &read_size, true) == CONV_OK)
                 {
                     for (i = 0; i < read_size / sizeof(chunk_id); ++i)
                     {
-- 
2.49.0

From 1772de52ad274357bd19a6623957cf6e5ad63bf7 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 5 Dec 2024 15:00:43 +0100
Subject: [PATCH 0571/1564] HACK: winegstreamer/video_decoder: Support decoding
 theora video.

---
 dlls/winegstreamer/mfplat.c        |  1 +
 dlls/winegstreamer/video_decoder.c |  2 ++
 dlls/winegstreamer/wg_media_type.c | 11 +++++++++++
 3 files changed, 14 insertions(+)

diff --git a/dlls/winegstreamer/mfplat.c b/dlls/winegstreamer/mfplat.c
index 35777a552f9..6cde52069bc 100644
--- a/dlls/winegstreamer/mfplat.c
+++ b/dlls/winegstreamer/mfplat.c
@@ -44,6 +44,7 @@ DEFINE_MEDIATYPE_GUID(MFVideoFormat_VC1S,MAKEFOURCC('V','C','1','S'));
 DEFINE_MEDIATYPE_GUID(MFVideoFormat_IV50,MAKEFOURCC('I','V','5','0'));
 DEFINE_MEDIATYPE_GUID(MFVideoFormat_ABGR32,D3DFMT_A8B8G8R8);
 DEFINE_GUID(MEDIASUBTYPE_WMV_Unknown, 0x7ce12ca9,0xbfbf,0x43d9,0x9d,0x00,0x82,0xb8,0xed,0x54,0x31,0x6b);
+DEFINE_MEDIATYPE_GUID(MFVideoFormat_theora,MAKEFOURCC('t','h','e','o'));
 
 struct class_factory
 {
diff --git a/dlls/winegstreamer/video_decoder.c b/dlls/winegstreamer/video_decoder.c
index efedff5e983..5d928d2c03c 100644
--- a/dlls/winegstreamer/video_decoder.c
+++ b/dlls/winegstreamer/video_decoder.c
@@ -1696,6 +1696,7 @@ HRESULT WINAPI winegstreamer_create_video_decoder(IMFTransform **out)
 
 extern const GUID MEDIASUBTYPE_VC1S;
 extern const GUID MEDIASUBTYPE_WMV_Unknown;
+extern const GUID MFVideoFormat_theora;
 static const GUID *const wmv_decoder_input_types[] =
 {
     &MEDIASUBTYPE_WMV1,
@@ -1707,6 +1708,7 @@ static const GUID *const wmv_decoder_input_types[] =
     &MEDIASUBTYPE_WVC1,
     &MEDIASUBTYPE_WMV3,
     &MEDIASUBTYPE_VC1S,
+    &MFVideoFormat_theora,
 };
 static const GUID *const wmv_decoder_output_types[] =
 {
diff --git a/dlls/winegstreamer/wg_media_type.c b/dlls/winegstreamer/wg_media_type.c
index 9e204567b8b..ef4c915278e 100644
--- a/dlls/winegstreamer/wg_media_type.c
+++ b/dlls/winegstreamer/wg_media_type.c
@@ -63,6 +63,7 @@ DEFINE_MEDIATYPE_GUID(MFVideoFormat_CVID,MAKEFOURCC('c','v','i','d'));
 DEFINE_MEDIATYPE_GUID(MFVideoFormat_IV50,MAKEFOURCC('I','V','5','0'));
 DEFINE_MEDIATYPE_GUID(MFVideoFormat_VC1S,MAKEFOURCC('V','C','1','S'));
 DEFINE_MEDIATYPE_GUID(MFVideoFormat_ABGR32,D3DFMT_A8B8G8R8);
+DEFINE_MEDIATYPE_GUID(MFVideoFormat_theora,MAKEFOURCC('t','h','e','o'));
 
 static void init_caps_codec_data(GstCaps *caps, const void *codec_data, int codec_data_size)
 {
@@ -349,6 +350,14 @@ static void init_caps_from_video_mpeg(GstCaps *caps, const struct mpeg_video_for
     gst_caps_set_simple(caps, "parsed", G_TYPE_BOOLEAN, TRUE, NULL);
 }
 
+static void init_caps_from_video_theora(GstCaps *caps, const MFVIDEOFORMAT *format, UINT format_size)
+{
+    init_caps_codec_data(caps, format + 1, format_size - sizeof(*format));
+
+    gst_structure_remove_field(gst_caps_get_structure(caps, 0), "format");
+    gst_structure_set_name(gst_caps_get_structure(caps, 0), "video/x-theora");
+}
+
 static void init_caps_from_video_subtype(GstCaps *caps, const GUID *subtype, const void *format, UINT format_size)
 {
     if (IsEqualGUID(subtype, &MFVideoFormat_CVID))
@@ -369,6 +378,8 @@ static void init_caps_from_video_subtype(GstCaps *caps, const GUID *subtype, con
         return init_caps_from_video_indeo(caps, format, format_size);
     if (IsEqualGUID(subtype, &MEDIASUBTYPE_MPEG1Payload))
         return init_caps_from_video_mpeg(caps, format, format_size);
+    if (IsEqualGUID(subtype, &MFVideoFormat_theora))
+        return init_caps_from_video_theora(caps, format, format_size);
 
     GST_FIXME("Unsupported subtype " WG_GUID_FORMAT, WG_GUID_ARGS(*subtype));
 }
-- 
2.49.0

From ed71e027b81b128c2de4720ed101d51b68a419a9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 5 Dec 2024 12:06:11 +0100
Subject: [PATCH 0576/1564] mfsrcsnk: Use winedmo media source by default.

---
 dlls/mfsrcsnk/media_source.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/mfsrcsnk/media_source.c b/dlls/mfsrcsnk/media_source.c
index ac5f013d9cd..ce4d6952c25 100644
--- a/dlls/mfsrcsnk/media_source.c
+++ b/dlls/mfsrcsnk/media_source.c
@@ -1899,7 +1899,7 @@ static BOOL use_gst_byte_stream_handler(void)
                        RRF_RT_REG_DWORD, NULL, &result, &size ))
         return !result;
 
-    return TRUE;
+    return FALSE;
 }
 
 static HRESULT WINAPI asf_byte_stream_plugin_factory_CreateInstance(IClassFactory *iface,
-- 
2.49.0

From aa5aeecd3e7f7e5f70d2751ac46407e43a7b9bf2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 10 Dec 2024 09:39:19 +0100
Subject: [PATCH 0772/1564] mfsrcsnk: Implement IMFMediaShutdownNotify for the
 winedmo media source.

---
 dlls/mfsrcsnk/media_source.c | 75 ++++++++++++++++++++++++++++++++++++
 1 file changed, 75 insertions(+)

diff --git a/dlls/mfsrcsnk/media_source.c b/dlls/mfsrcsnk/media_source.c
index ce4d6952c25..4187d64b69b 100644
--- a/dlls/mfsrcsnk/media_source.c
+++ b/dlls/mfsrcsnk/media_source.c
@@ -228,6 +228,7 @@ struct media_source
     IMFGetService IMFGetService_iface;
     IMFRateSupport IMFRateSupport_iface;
     IMFRateControl IMFRateControl_iface;
+    IMFMediaShutdownNotify IMFMediaShutdownNotify_iface;
     IMFAsyncCallback async_create_iface;
     IMFAsyncCallback async_start_iface;
     IMFAsyncCallback async_stop_iface;
@@ -236,6 +237,7 @@ struct media_source
     LONG refcount;
 
     CRITICAL_SECTION cs;
+    IMFAsyncResult *shutdown_result;
     IMFMediaEventQueue *queue;
     IMFByteStream *stream;
     WCHAR *url;
@@ -1082,6 +1084,62 @@ static const IMFRateControlVtbl media_source_IMFRateControl_vtbl =
     media_source_IMFRateControl_GetRate,
 };
 
+static struct media_source *media_source_from_IMFMediaShutdownNotify(IMFMediaShutdownNotify *iface)
+{
+    return CONTAINING_RECORD(iface, struct media_source, IMFMediaShutdownNotify_iface);
+}
+
+static HRESULT WINAPI media_source_IMFMediaShutdownNotify_QueryInterface(IMFMediaShutdownNotify *iface, REFIID riid, void **obj)
+{
+    struct media_source *source = media_source_from_IMFMediaShutdownNotify(iface);
+    return IMFMediaSource_QueryInterface(&source->IMFMediaSource_iface, riid, obj);
+}
+
+static ULONG WINAPI media_source_IMFMediaShutdownNotify_AddRef(IMFMediaShutdownNotify *iface)
+{
+    struct media_source *source = media_source_from_IMFMediaShutdownNotify(iface);
+    return IMFMediaSource_AddRef(&source->IMFMediaSource_iface);
+}
+
+static ULONG WINAPI media_source_IMFMediaShutdownNotify_Release(IMFMediaShutdownNotify *iface)
+{
+    struct media_source *source = media_source_from_IMFMediaShutdownNotify(iface);
+    return IMFMediaSource_Release(&source->IMFMediaSource_iface);
+}
+
+static HRESULT WINAPI media_source_IMFMediaShutdownNotify_set_notification_callback(IMFMediaShutdownNotify *iface,
+        IMFAsyncCallback *callback, IUnknown *state)
+{
+    struct media_source *source = media_source_from_IMFMediaShutdownNotify(iface);
+    IMFAsyncResult *result = NULL;
+    HRESULT hr = S_OK;
+
+    EnterCriticalSection(&source->cs);
+
+    if (source->state == SOURCE_SHUTDOWN)
+        hr = MF_E_SHUTDOWN;
+    else if (callback && FAILED(hr = MFCreateAsyncResult(NULL, callback, state, &result)))
+        WARN("Failed to create result, hr %#lx\n", hr);
+    else
+    {
+        if (source->shutdown_result)
+            IMFAsyncResult_Release(source->shutdown_result);
+        source->shutdown_result = result;
+    }
+
+    LeaveCriticalSection(&source->cs);
+
+    return hr;
+}
+
+static const IMFMediaShutdownNotifyVtbl media_source_IMFMediaShutdownNotify_vtbl =
+{
+    media_source_IMFMediaShutdownNotify_QueryInterface,
+    media_source_IMFMediaShutdownNotify_AddRef,
+    media_source_IMFMediaShutdownNotify_Release,
+    media_source_IMFMediaShutdownNotify_set_notification_callback,
+};
+
 static HRESULT WINAPI media_source_QueryInterface(IMFMediaSource *iface, REFIID riid, void **out)
 {
     struct media_source *source = media_source_from_IMFMediaSource(iface);
@@ -1104,6 +1162,13 @@ static HRESULT WINAPI media_source_QueryInterface(IMFMediaSource *iface, REFIID
         return S_OK;
     }
 
+    if (IsEqualIID(riid, &IID_IMFMediaShutdownNotify))
+    {
+        IMFMediaShutdownNotify_AddRef(&source->IMFMediaShutdownNotify_iface);
+        *out = &source->IMFMediaShutdownNotify_iface;
+        return S_OK;
+    }
+
     FIXME("Unsupported interface %s\n", debugstr_guid(riid));
     *out = NULL;
     return E_NOINTERFACE;
@@ -1132,6 +1197,8 @@ static ULONG WINAPI media_source_Release(IMFMediaSource *iface)
         free(source->stream_map);
         free(source->streams);
 
+        if (source->shutdown_result)
+            IMFAsyncResult_Release(source->shutdown_result);
         IMFMediaEventQueue_Release(source->queue);
         IMFByteStream_Release(source->stream);
         free(source->url);
@@ -1341,6 +1408,13 @@ static HRESULT WINAPI media_source_Shutdown(IMFMediaSource *iface)
         IMFMediaStream_Release(&stream->IMFMediaStream_iface);
     }
 
+    if (source->shutdown_result)
+    {
+        MFPutWorkItemEx(MFASYNC_CALLBACK_QUEUE_STANDARD, source->shutdown_result);
+        IMFAsyncResult_Release(source->shutdown_result);
+        source->shutdown_result = NULL;
+    }
+
     LeaveCriticalSection(&source->cs);
 
     return S_OK;
@@ -1711,6 +1785,7 @@ static HRESULT media_source_create(const WCHAR *url, IMFByteStream *stream, IMFM
     source->IMFGetService_iface.lpVtbl = &media_source_IMFGetService_vtbl;
     source->IMFRateSupport_iface.lpVtbl = &media_source_IMFRateSupport_vtbl;
     source->IMFRateControl_iface.lpVtbl = &media_source_IMFRateControl_vtbl;
+    source->IMFMediaShutdownNotify_iface.lpVtbl = &media_source_IMFMediaShutdownNotify_vtbl;
     source->async_create_iface.lpVtbl = &media_source_async_create_vtbl;
     source->async_start_iface.lpVtbl = &media_source_async_start_vtbl;
     source->async_stop_iface.lpVtbl = &media_source_async_stop_vtbl;
-- 
2.49.0

From f4a63f5fb536402d8eaf4ea9f7cbb180a5f736a8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 21 Nov 2023 21:34:17 +0100
Subject: [PATCH 0844/1564] HACK: winegstreamer/wm_reader: Use OpenGL video
 processing pipeline for WMReader.

There's many 32-bit games using either the WM reader or the ASF reader
filter, and which require conversion from I420 to RGBA. However, ORC
fails to create an optimized routine as it doesn't support spilling
vector registers and it needs more than what's available in 32-bit x86.

The WM reader (and the ASF reader filter) currently reads audio and
video samples synchronously, and having a high video decoding latency
causes trouble on the audio stream.

Using OpenGL to post-process the video, and more specifically for the
color conversion makes it generally faster, enough to solve the problem
in most cases.

CW-Bug-Id: #18799
CW-Bug-Id: #18994
CW-Bug-Id: #20182
CW-Bug-Id: #20363
CW-Bug-Id: #20905
CW-Bug-Id: #20980
---
 configure.ac                       |  2 +-
 dlls/winegstreamer/gst_private.h   |  2 +-
 dlls/winegstreamer/main.c          |  3 +-
 dlls/winegstreamer/media_source.c  |  2 +-
 dlls/winegstreamer/quartz_parser.c |  2 +-
 dlls/winegstreamer/unixlib.c       | 30 +++++++++++++++++--
 dlls/winegstreamer/unixlib.h       |  1 +
 dlls/winegstreamer/wg_parser.c     | 48 +++++++++++++++++++++++++++++-
 dlls/winegstreamer/wm_reader.c     |  7 +++--
 9 files changed, 86 insertions(+), 11 deletions(-)

diff --git a/configure.ac b/configure.ac
index 34fc1785697..15e0914ca5b 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1676,7 +1676,7 @@ WINE_NOTICE_WITH(ffmpeg,[test "x$FFMPEG_LIBS" = x],
 dnl **** Check for gstreamer ****
 if test "x$with_gstreamer" != "xno"
 then
-    WINE_PACKAGE_FLAGS(GSTREAMER,[gstreamer-1.0 gstreamer-video-1.0 gstreamer-audio-1.0 gstreamer-tag-1.0],,,,
+    WINE_PACKAGE_FLAGS(GSTREAMER,[gstreamer-1.0 gstreamer-video-1.0 gstreamer-audio-1.0 gstreamer-tag-1.0 gstreamer-gl-1.0],,,,
         [AC_CHECK_HEADER([gst/gst.h],
             [AC_MSG_CHECKING([whether gint64 defined by gst/gst.h is indeed 64-bit])
               AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <gst/gst.h>]],
diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index f9f0048bbe1..aa76b4d7324 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -72,7 +72,7 @@ HRESULT wg_sample_queue_create(struct wg_sample_queue **out);
 void wg_sample_queue_destroy(struct wg_sample_queue *queue);
 void wg_sample_queue_flush(struct wg_sample_queue *queue, bool all);
 
-wg_parser_t wg_parser_create(bool output_compressed);
+wg_parser_t wg_parser_create(bool output_compressed, bool use_opengl);
 void wg_parser_destroy(wg_parser_t parser);
 
 HRESULT wg_parser_connect(wg_parser_t parser, uint64_t file_size, const WCHAR *uri);
diff --git a/dlls/winegstreamer/main.c b/dlls/winegstreamer/main.c
index d18db8b21e8..c1b7a7a7bda 100644
--- a/dlls/winegstreamer/main.c
+++ b/dlls/winegstreamer/main.c
@@ -163,11 +163,12 @@ static HRESULT wg_media_type_to_mf(const struct wg_media_type *wg_media_type, IM
     return E_NOTIMPL;
 }
 
-wg_parser_t wg_parser_create(bool output_compressed)
+wg_parser_t wg_parser_create(bool output_compressed, bool use_opengl)
 {
     struct wg_parser_create_params params =
     {
         .output_compressed = output_compressed,
+        .use_opengl = use_opengl,
         .err_on = ERR_ON(quartz),
         .warn_on = WARN_ON(quartz),
     };
diff --git a/dlls/winegstreamer/media_source.c b/dlls/winegstreamer/media_source.c
index caaf8d16b96..85075256420 100644
--- a/dlls/winegstreamer/media_source.c
+++ b/dlls/winegstreamer/media_source.c
@@ -1740,7 +1740,7 @@ static HRESULT media_source_create(struct object_context *context, IMFMediaSourc
     if (FAILED(hr = MFAllocateWorkQueue(&object->async_commands_queue)))
         goto fail;
 
-    if (!(parser = wg_parser_create(FALSE)))
+    if (!(parser = wg_parser_create(FALSE, FALSE)))
     {
         hr = E_OUTOFMEMORY;
         goto fail;
diff --git a/dlls/winegstreamer/quartz_parser.c b/dlls/winegstreamer/quartz_parser.c
index 581ea3af8ab..c1dc0d7951f 100644
--- a/dlls/winegstreamer/quartz_parser.c
+++ b/dlls/winegstreamer/quartz_parser.c
@@ -1717,7 +1717,7 @@ static HRESULT parser_create(BOOL output_compressed, struct parser **parser)
     if (!(object = calloc(1, sizeof(*object))))
         return E_OUTOFMEMORY;
 
-    if (!(object->wg_parser = wg_parser_create(output_compressed)))
+    if (!(object->wg_parser = wg_parser_create(output_compressed, FALSE)))
     {
         free(object);
         return E_OUTOFMEMORY;
diff --git a/dlls/winegstreamer/unixlib.c b/dlls/winegstreamer/unixlib.c
index a0d7286cc32..a82ebd6461b 100644
--- a/dlls/winegstreamer/unixlib.c
+++ b/dlls/winegstreamer/unixlib.c
@@ -28,10 +28,9 @@
 #include <stdarg.h>
 #include <stdio.h>
 
+#define GLIB_VERSION_MIN_REQUIRED GLIB_VERSION_2_30
 #include <gst/gst.h>
-#include <gst/video/video.h>
-#include <gst/audio/audio.h>
-#include <gst/tag/tag.h>
+#include <gst/gl/gl.h>
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -48,6 +47,7 @@
 GST_DEBUG_CATEGORY(wine);
 
 static UINT thread_count;
+GstGLDisplay *gl_display;
 
 GstStreamType stream_type_from_caps(GstCaps *caps)
 {
@@ -259,6 +259,8 @@ static ULONG popcount(ULONG val)
 
 NTSTATUS wg_init_gstreamer(void *arg)
 {
+    static GstGLContext *gl_context;
+
     struct wg_init_gstreamer_params *params = arg;
     char arg0[] = "wine";
     char arg1[] = "--gst-disable-registry-fork";
@@ -319,6 +321,28 @@ NTSTATUS wg_init_gstreamer(void *arg)
     GST_INFO("GStreamer library version %s; wine built with %d.%d.%d.",
             gst_version_string(), GST_VERSION_MAJOR, GST_VERSION_MINOR, GST_VERSION_MICRO);
 
+    if (!(gl_display = gst_gl_display_new()))
+        GST_ERROR("Failed to create OpenGL display");
+    else
+    {
+        GError *error = NULL;
+        gboolean ret;
+
+        GST_OBJECT_LOCK(gl_display);
+        ret = gst_gl_display_create_context(gl_display, NULL, &gl_context, &error);
+        GST_OBJECT_UNLOCK(gl_display);
+        g_clear_error(&error);
+
+        if (ret)
+            gst_gl_display_add_context(gl_display, gl_context);
+        else
+        {
+            GST_ERROR("Failed to create OpenGL context");
+            gst_object_unref(gl_display);
+            gl_display = NULL;
+        }
+    }
+
     if (!media_converter_init())
     {
         GST_ERROR("Failed to init media converter.");
diff --git a/dlls/winegstreamer/unixlib.h b/dlls/winegstreamer/unixlib.h
index 7e87fd56530..d12819a9b9b 100644
--- a/dlls/winegstreamer/unixlib.h
+++ b/dlls/winegstreamer/unixlib.h
@@ -220,6 +220,7 @@ struct wg_parser_create_params
 {
     wg_parser_t parser;
     UINT8 output_compressed;
+    UINT8 use_opengl;
     UINT8 err_on;
     UINT8 warn_on;
 };
diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index f3e89979d6b..0e7d18a316a 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -36,6 +36,8 @@
 #include <gst/audio/audio.h>
 #include <gst/tag/tag.h>
 
+#include <gst/gl/gl.h>
+
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include "winternl.h"
@@ -43,6 +45,8 @@
 
 #include "unix_private.h"
 
+extern GstGLDisplay *gl_display;
+
 typedef enum
 {
     GST_AUTOPLUG_SELECT_TRY,
@@ -99,6 +103,8 @@ struct wg_parser
     struct input_cache_chunk input_cache_chunks[4];
 
     bool use_mediaconv;
+    bool use_opengl;
+    GstContext *context;
 };
 static const unsigned int input_cache_chunk_size = 512 << 10;
 
@@ -928,7 +934,32 @@ static bool stream_create_post_processing_elements(GstPad *pad, struct wg_parser
     name = gst_structure_get_name(gst_caps_get_structure(caps, 0));
     gst_caps_unref(caps);
 
-    if (!strcmp(name, "video/x-raw"))
+    if (!strcmp(name, "video/x-raw") && parser->use_opengl)
+    {
+        if (!(element = create_element("glupload", "base"))
+                || !append_element(parser->container, element, &first, &last))
+            return false;
+        if (!(element = create_element("glcolorconvert", "base"))
+                || !append_element(parser->container, element, &first, &last))
+            return false;
+        if (!(element = create_element("glvideoflip", "base"))
+                || !append_element(parser->container, element, &first, &last))
+            return false;
+        stream->flip = element;
+        if (!(element = create_element("gldeinterlace", "base"))
+                || !append_element(parser->container, element, &first, &last))
+            return false;
+        if (!(element = create_element("glcolorconvert", "base"))
+                || !append_element(parser->container, element, &first, &last))
+            return false;
+        if (!(element = create_element("gldownload", "base"))
+                || !append_element(parser->container, element, &first, &last))
+            return false;
+
+        if (!link_src_to_element(pad, first) || !link_element_to_sink(last, stream->my_sink))
+            return false;
+    }
+    else if (!strcmp(name, "video/x-raw"))
     {
         /* Hack?: Flatten down the colorimetry to default values, without
          * actually modifying the video at all.
@@ -1722,6 +1753,8 @@ static NTSTATUS wg_parser_connect(void *args)
 
     parser->container = gst_bin_new(NULL);
     gst_element_set_bus(parser->container, parser->bus);
+    if (parser->context)
+        gst_element_set_context(parser->container, parser->context);
 
     parser->my_src = gst_pad_new_from_static_template(&src_template, "quartz-src");
     gst_pad_set_getrange_function(parser->my_src, src_getrange_cb);
@@ -1971,6 +2004,16 @@ static NTSTATUS wg_parser_create(void *args)
 
     if (!(parser = calloc(1, sizeof(*parser))))
         return E_OUTOFMEMORY;
+    if ((parser->use_opengl = params->use_opengl && gl_display))
+    {
+        if ((parser->context = gst_context_new(GST_GL_DISPLAY_CONTEXT_TYPE, false)))
+            gst_context_set_gl_display(parser->context, gl_display);
+        else
+        {
+            GST_ERROR("Failed to create parser context");
+            parser->use_opengl = FALSE;
+        }
+    }
 
     pthread_mutex_init(&parser->mutex, NULL);
     pthread_cond_init(&parser->init_cond, NULL);
@@ -1994,6 +2037,9 @@ static NTSTATUS wg_parser_destroy(void *args)
         gst_object_unref(parser->bus);
     }
 
+    if (parser->context)
+        gst_context_unref(parser->context);
+
     pthread_mutex_destroy(&parser->mutex);
     pthread_cond_destroy(&parser->init_cond);
     pthread_cond_destroy(&parser->read_cond);
diff --git a/dlls/winegstreamer/wm_reader.c b/dlls/winegstreamer/wm_reader.c
index e1495289fb0..950c8b018ab 100644
--- a/dlls/winegstreamer/wm_reader.c
+++ b/dlls/winegstreamer/wm_reader.c
@@ -1473,7 +1473,10 @@ static HRESULT init_stream(struct wm_reader *reader)
     HRESULT hr;
     WORD i;
 
-    if (!(wg_parser = wg_parser_create(FALSE)))
+    /* 32-bit GStreamer ORC cannot efficiently convert I420 to RGBA, use OpenGL converter
+     * in that case but keep the usual codepath otherwise.
+     */
+    if (!(wg_parser = wg_parser_create(FALSE, sizeof(void *) == 4)))
         return E_OUTOFMEMORY;
 
     reader->wg_parser = wg_parser;
@@ -1591,7 +1594,7 @@ static HRESULT reinit_stream(struct wm_reader *reader, bool read_compressed)
     wg_parser_destroy(reader->wg_parser);
     reader->wg_parser = 0;
 
-    if (!(wg_parser = wg_parser_create(read_compressed)))
+    if (!(wg_parser = wg_parser_create(read_compressed, sizeof(void *) == 4 && !read_compressed)))
         return E_OUTOFMEMORY;
 
     reader->wg_parser = wg_parser;
-- 
2.49.0

From 7e7215dbb866f7cd48fb072cb3b79e5ed4616529 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 22 Aug 2022 18:49:06 +0200
Subject: [PATCH 0847/1564] winegstreamer/wm_reader: Avoid entering sync reader
 CS in GetNextSample when aggregated.

CW-Bug-Id: #21147
---
 dlls/winegstreamer/wm_reader.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/dlls/winegstreamer/wm_reader.c b/dlls/winegstreamer/wm_reader.c
index 950c8b018ab..6fa505b7526 100644
--- a/dlls/winegstreamer/wm_reader.c
+++ b/dlls/winegstreamer/wm_reader.c
@@ -1991,7 +1991,8 @@ static HRESULT WINAPI reader_GetNextSample(IWMSyncReader2 *iface,
     if (!stream_number && !output_number && !ret_stream_number)
         return E_INVALIDARG;
 
-    EnterCriticalSection(&reader->cs);
+    if (reader->outer == &reader->IUnknown_inner)
+        EnterCriticalSection(&reader->cs);
 
     if (!stream_number)
         stream = NULL;
@@ -2029,7 +2030,8 @@ static HRESULT WINAPI reader_GetNextSample(IWMSyncReader2 *iface,
     if (ret_stream_number && (hr == S_OK || stream_number))
         *ret_stream_number = stream_number;
 
-    LeaveCriticalSection(&reader->cs);
+    if (reader->outer == &reader->IUnknown_inner)
+        LeaveCriticalSection(&reader->cs);
     return hr;
 }
 
-- 
2.49.0

From 7b8bd99870779466c564be53ece0a1ce61e66d92 Mon Sep 17 00:00:00 2001
From: Yuxuan Shui <yshui@codeweavers.com>
Date: Mon, 11 Mar 2024 23:13:41 +0000
Subject: [PATCH 0850/1564] wm_reader: Don't reinit stream if read_compressed
 didn't change.

CW-Bug-Id: #23483
---
 dlls/winegstreamer/wm_reader.c | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/dlls/winegstreamer/wm_reader.c b/dlls/winegstreamer/wm_reader.c
index 6fa505b7526..d1f3f5457d8 100644
--- a/dlls/winegstreamer/wm_reader.c
+++ b/dlls/winegstreamer/wm_reader.c
@@ -2512,8 +2512,11 @@ static HRESULT WINAPI reader_SetReadStreamSamples(IWMSyncReader2 *iface, WORD st
         return E_INVALIDARG;
     }
 
-    stream->read_compressed = compressed;
-    reinit_stream(reader, compressed);
+    if (stream->read_compressed != compressed)
+    {
+        stream->read_compressed = compressed;
+        reinit_stream(reader, compressed);
+    }
 
     LeaveCriticalSection(&reader->cs);
     return S_OK;
-- 
2.49.0

From 55e5a1ccea37d1bd889ab269d55b499bf131ddf9 Mon Sep 17 00:00:00 2001
From: Yuxuan Shui <yshui@codeweavers.com>
Date: Tue, 12 Mar 2024 13:50:23 +0000
Subject: [PATCH 0851/1564] wm_reader: Fix order of streams in reinit_stream.

CW-Bug-Id: #23483
---
 dlls/winegstreamer/wm_reader.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winegstreamer/wm_reader.c b/dlls/winegstreamer/wm_reader.c
index d1f3f5457d8..3334f811336 100644
--- a/dlls/winegstreamer/wm_reader.c
+++ b/dlls/winegstreamer/wm_reader.c
@@ -1619,7 +1619,7 @@ static HRESULT reinit_stream(struct wm_reader *reader, bool read_compressed)
         struct wm_stream *stream = &reader->streams[i];
         struct wg_format format;
 
-        stream->wg_stream = wg_parser_get_stream(reader->wg_parser, i);
+        stream->wg_stream = wg_parser_get_stream(reader->wg_parser, reader->stream_count - i - 1);
         stream->reader = reader;
         wg_parser_stream_get_current_format(stream->wg_stream, &format);
         if (stream->selection == WMT_ON)
-- 
2.49.0

From 3e1682c9e777fb5ceb0cfba8aa9a24a747f603e4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 30 Oct 2024 10:11:35 +0100
Subject: [PATCH 0852/1564] HACK: winegstreamer/wm_reader: Force faking
 compressed samples for some games.

CW-Bug-Id: #24401
---
 dlls/winegstreamer/wm_reader.c | 14 +++++++++++---
 1 file changed, 11 insertions(+), 3 deletions(-)

diff --git a/dlls/winegstreamer/wm_reader.c b/dlls/winegstreamer/wm_reader.c
index 3334f811336..0e634265f77 100644
--- a/dlls/winegstreamer/wm_reader.c
+++ b/dlls/winegstreamer/wm_reader.c
@@ -31,6 +31,7 @@ struct wm_stream
     WORD index;
     bool eos;
     bool read_compressed;
+    bool demux_compressed;
 
     struct wg_parser_buffer current_buffer;
     DWORD current_buffer_offset;
@@ -2512,9 +2513,16 @@ static HRESULT WINAPI reader_SetReadStreamSamples(IWMSyncReader2 *iface, WORD st
         return E_INVALIDARG;
     }
 
-    if (stream->read_compressed != compressed)
+    stream->read_compressed = compressed;
+
+    {
+        const char *sgi = getenv("SteamGameId");
+        if (sgi && !strcmp(sgi, "638160")) compressed = FALSE;
+    }
+
+    if (stream->demux_compressed != compressed)
     {
-        stream->read_compressed = compressed;
+        stream->demux_compressed = compressed;
         reinit_stream(reader, compressed);
     }
 
@@ -2562,7 +2570,7 @@ static HRESULT WINAPI reader_SetStreamsSelected(IWMSyncReader2 *iface,
                 FIXME("Ignoring selection %#x for stream %u; treating as enabled.\n",
                         selections[i], stream_numbers[i]);
             TRACE("Enabling stream %u.\n", stream_numbers[i]);
-            if (stream->read_compressed)
+            if (stream->demux_compressed)
             {
                 struct wg_format format;
                 wg_parser_stream_get_current_format(stream->wg_stream, &format);
-- 
2.49.0

From b237dbfeb695597792f1e7137cc0c13837b70bf1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 12 May 2023 13:34:23 +0200
Subject: [PATCH 0853/1564] winegstreamer: Introduce and use a new wg_task_pool
 helper.

To better track GStreamer threads, avoiding potential task leaks in the
default pool which keeps some thread alive.

CW-Bug-Id: #22045
---
 dlls/winegstreamer/Makefile.in    |  1 +
 dlls/winegstreamer/unix_private.h |  4 ++
 dlls/winegstreamer/wg_parser.c    | 28 +++++++++
 dlls/winegstreamer/wg_task_pool.c | 98 +++++++++++++++++++++++++++++++
 4 files changed, 131 insertions(+)
 create mode 100644 dlls/winegstreamer/wg_task_pool.c

diff --git a/dlls/winegstreamer/Makefile.in b/dlls/winegstreamer/Makefile.in
index 74f28658057..9965dc0ad6d 100644
--- a/dlls/winegstreamer/Makefile.in
+++ b/dlls/winegstreamer/Makefile.in
@@ -34,6 +34,7 @@ SOURCES = \
 	wg_muxer.c \
 	wg_parser.c \
 	wg_sample.c \
+	wg_task_pool.c \
 	wg_transform.c \
 	winegstreamer_classes.idl \
 	wm_reader.c \
diff --git a/dlls/winegstreamer/unix_private.h b/dlls/winegstreamer/unix_private.h
index a0f1d3ddafd..d8fe72b570d 100644
--- a/dlls/winegstreamer/unix_private.h
+++ b/dlls/winegstreamer/unix_private.h
@@ -94,6 +94,10 @@ extern NTSTATUS wg_muxer_push_sample(void *args);
 extern NTSTATUS wg_muxer_read_data(void *args);
 extern NTSTATUS wg_muxer_finalize(void *args);
 
+/* wg_task_pool.c */
+
+extern GstTaskPool *wg_task_pool_new(void);
+
 /* wg_allocator.c */
 
 static inline BYTE *wg_sample_data(struct wg_sample *sample)
diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index 0e7d18a316a..c56e5ded241 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -71,6 +71,7 @@ struct wg_parser
 
     GstElement *container, *decodebin;
     GstBus *bus;
+    GstTaskPool *task_pool;
     GstPad *my_src;
 
     guint64 file_size, start_offset, next_offset, stop_offset;
@@ -1566,6 +1567,24 @@ static GstBusSyncReply bus_handler_cb(GstBus *bus, GstMessage *msg, gpointer use
         }
         break;
 
+    case GST_MESSAGE_STREAM_STATUS:
+    {
+        GstStreamStatusType type;
+        GstElement *element;
+        const GValue *val;
+        GstTask *task;
+
+        gst_message_parse_stream_status(msg, &type, &element);
+        val = gst_message_get_stream_status_object(msg);
+        GST_DEBUG("parser %p, message %s, type %u, value %p (%s).", parser, GST_MESSAGE_TYPE_NAME(msg), type, val, G_VALUE_TYPE_NAME(val));
+
+        if (G_VALUE_TYPE(val) == GST_TYPE_TASK && (task = g_value_get_object(val))
+                && type == GST_STREAM_STATUS_TYPE_CREATE)
+            gst_task_set_pool(task, parser->task_pool);
+
+        break;
+    }
+
     default:
         break;
     }
@@ -1964,6 +1983,7 @@ static NTSTATUS wg_parser_disconnect(void *args)
         parser->input_cache_chunks[i].data = NULL;
     }
 
+    gst_task_pool_cleanup(parser->task_pool);
     return S_OK;
 }
 
@@ -2001,6 +2021,7 @@ static NTSTATUS wg_parser_create(void *args)
 {
     struct wg_parser_create_params *params = args;
     struct wg_parser *parser;
+    GError *error;
 
     if (!(parser = calloc(1, sizeof(*parser))))
         return E_OUTOFMEMORY;
@@ -2014,6 +2035,12 @@ static NTSTATUS wg_parser_create(void *args)
             parser->use_opengl = FALSE;
         }
     }
+    if (!(parser->task_pool = wg_task_pool_new()))
+    {
+        free(parser);
+        return E_OUTOFMEMORY;
+    }
+    gst_task_pool_prepare(parser->task_pool, &error);
 
     pthread_mutex_init(&parser->mutex, NULL);
     pthread_cond_init(&parser->init_cond, NULL);
@@ -2036,6 +2063,7 @@ static NTSTATUS wg_parser_destroy(void *args)
         gst_bus_set_sync_handler(parser->bus, NULL, NULL, NULL);
         gst_object_unref(parser->bus);
     }
+    gst_object_unref(parser->task_pool);
 
     if (parser->context)
         gst_context_unref(parser->context);
diff --git a/dlls/winegstreamer/wg_task_pool.c b/dlls/winegstreamer/wg_task_pool.c
new file mode 100644
index 00000000000..ec7da286d5f
--- /dev/null
+++ b/dlls/winegstreamer/wg_task_pool.c
@@ -0,0 +1,98 @@
+/*
+ * GStreamer task pool
+ *
+ * Copyright 2023 Rémi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include <assert.h>
+#include <stdarg.h>
+
+#include <gst/gst.h>
+
+#include "unix_private.h"
+
+typedef struct
+{
+    GstTaskPool parent;
+} WgTaskPool;
+
+typedef struct
+{
+    GstTaskPoolClass parent_class;
+} WgTaskPoolClass;
+
+G_DEFINE_TYPE(WgTaskPool, wg_task_pool, GST_TYPE_TASK_POOL);
+
+static void wg_task_pool_prepare(GstTaskPool *pool, GError **error)
+{
+    GST_LOG("pool %p, error %p", pool, error);
+}
+
+static void wg_task_pool_cleanup(GstTaskPool *pool)
+{
+    GST_LOG("pool %p", pool);
+}
+
+static gpointer wg_task_pool_push(GstTaskPool *pool, GstTaskPoolFunction func, gpointer data, GError **error)
+{
+    pthread_t *tid;
+    gint res;
+
+    GST_LOG("pool %p, func %p, data %p, error %p", pool, func, data, error);
+
+    if (!(tid = malloc(sizeof(*tid))) || !(res = pthread_create(tid, NULL, (void *)func, data)))
+        return tid;
+
+    g_set_error(error, G_THREAD_ERROR, G_THREAD_ERROR_AGAIN, "Error creating thread: %s", g_strerror(res));
+    free(tid);
+
+    return NULL;
+}
+
+static void wg_task_pool_join(GstTaskPool *pool, gpointer id)
+{
+    pthread_t *tid = id;
+
+    GST_LOG("pool %p, id %p", pool, id);
+
+    pthread_join(*tid, NULL);
+    free(tid);
+}
+
+static void wg_task_pool_class_init(WgTaskPoolClass *klass)
+{
+    GstTaskPoolClass *parent_class = (GstTaskPoolClass *)klass;
+    parent_class->prepare = wg_task_pool_prepare;
+    parent_class->cleanup = wg_task_pool_cleanup;
+    parent_class->push = wg_task_pool_push;
+    parent_class->join = wg_task_pool_join;
+}
+
+static void wg_task_pool_init(WgTaskPool *pool)
+{
+}
+
+GstTaskPool *wg_task_pool_new(void)
+{
+    return g_object_new(wg_task_pool_get_type(), NULL);
+}
-- 
2.49.0

From 3884c022d746cc328b0f1d0375861a423d8bbba9 Mon Sep 17 00:00:00 2001
From: Arkadiusz Hiler <ahiler@codeweavers.com>
Date: Wed, 28 Dec 2022 12:09:43 +0200
Subject: [PATCH 0858/1564] winegstreamer/wg_parser: Set n-threads for dav1d to
 1.

It defaults to `$(nproc)` which causes the memory footprint to skyrocet
on high core count systems.

Setting it to 1 makes it use a bit less memory that theora decoder and
is enough to decode 1080p 30fps stream on 5950x with a speed of 4x the
real time.

We may want to set it to value higher than 1 for 64bit apps where
limited address space is not an issue. 2 or 4 may be optimal for tiling
with 2 columns and 2 rosw when encoding the video.

CW-Bug-Id: #19516
---
 dlls/winegstreamer/wg_parser.c | 19 +++++++++++++++++++
 1 file changed, 19 insertions(+)

diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index c56e5ded241..ecd3e1caa6c 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -627,11 +627,30 @@ static void no_more_pads_cb(GstElement *element, gpointer user)
     pthread_mutex_unlock(&parser->mutex);
     pthread_cond_signal(&parser->init_cond);
 }
+static void set_dav1d_n_threads(GstElement *element)
+{
+    GstElementFactory *factory = NULL;
+    const char *name = NULL;
+
+    if (element)
+        factory = gst_element_get_factory(element);
+
+    if (factory)
+        name = gst_element_factory_get_longname(factory);
+
+    if (name && strstr(name, "Dav1d"))
+    {
+        GST_DEBUG("%s found, setting n-threads to 1.", name);
+        g_object_set(element, "n-threads", G_GINT64_CONSTANT(1), NULL);
+    }
+}
 
 static void deep_element_added_cb(GstBin *self, GstBin *sub_bin, GstElement *element, gpointer user)
 {
     if (element)
         set_max_threads(element);
+
+    set_dav1d_n_threads(element);
 }
 
 static gboolean sink_event_cb(GstPad *pad, GstObject *parent, GstEvent *event)
-- 
2.49.0

From 3f84b28bb1880b91026cc16f865cc06a604fb34f Mon Sep 17 00:00:00 2001
From: Arkadiusz Hiler <ahiler@codeweavers.com>
Date: Tue, 17 Jan 2023 14:38:06 +0200
Subject: [PATCH 0859/1564] winegstreamer/wg_parser: Set n-threads for dav1d to
 4 in 64 bit mode.

CW-Bug-Id: #19516
---
 dlls/winegstreamer/wg_parser.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index ecd3e1caa6c..7ac9079120a 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -640,8 +640,13 @@ static void set_dav1d_n_threads(GstElement *element)
 
     if (name && strstr(name, "Dav1d"))
     {
+#if defined(__x86_64__)
+        GST_DEBUG("%s found, setting n-threads to 4.", name);
+        g_object_set(element, "n-threads", G_GINT64_CONSTANT(4), NULL);
+#else
         GST_DEBUG("%s found, setting n-threads to 1.", name);
         g_object_set(element, "n-threads", G_GINT64_CONSTANT(1), NULL);
+#endif
     }
 }
 
-- 
2.49.0

From aaa89be55b2a5fc8bd81e05948469d99c510d314 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 11 Sep 2024 19:01:42 +0200
Subject: [PATCH 0871/1564] HACK: winegstreamer: Pass H264 codec data as
 "codec_data" for avc bitstreams.

Actually needed since we don't have FFmpeg h264_mp4toannexb BSF yet.

CW-Bug-Id: #20833
---
 dlls/winegstreamer/wg_media_type.c | 17 ++++++++++++++---
 1 file changed, 14 insertions(+), 3 deletions(-)

diff --git a/dlls/winegstreamer/wg_media_type.c b/dlls/winegstreamer/wg_media_type.c
index ef4c915278e..09a539f1c7a 100644
--- a/dlls/winegstreamer/wg_media_type.c
+++ b/dlls/winegstreamer/wg_media_type.c
@@ -65,18 +65,23 @@ DEFINE_MEDIATYPE_GUID(MFVideoFormat_VC1S,MAKEFOURCC('V','C','1','S'));
 DEFINE_MEDIATYPE_GUID(MFVideoFormat_ABGR32,D3DFMT_A8B8G8R8);
 DEFINE_MEDIATYPE_GUID(MFVideoFormat_theora,MAKEFOURCC('t','h','e','o'));
 
-static void init_caps_codec_data(GstCaps *caps, const void *codec_data, int codec_data_size)
+static void init_caps_codec_data_name(GstCaps *caps, const void *codec_data, int codec_data_size, const char *name)
 {
     GstBuffer *buffer;
 
     if (codec_data_size > 0 && (buffer = gst_buffer_new_and_alloc(codec_data_size)))
     {
         gst_buffer_fill(buffer, 0, codec_data, codec_data_size);
-        gst_caps_set_simple(caps, "codec_data", GST_TYPE_BUFFER, buffer, NULL);
+        gst_caps_set_simple(caps, name, GST_TYPE_BUFFER, buffer, NULL);
         gst_buffer_unref(buffer);
     }
 }
 
+static void init_caps_codec_data(GstCaps *caps, const void *codec_data, int codec_data_size)
+{
+    init_caps_codec_data_name(caps, codec_data, codec_data_size, "codec_data");
+}
+
 static void init_caps_from_wave_format_mpeg1(GstCaps *caps, const MPEG1WAVEFORMAT *format, UINT32 format_size)
 {
     init_caps_codec_data(caps, &format->wfx + 1, format->wfx.cbSize);
@@ -314,7 +319,13 @@ static void init_caps_from_video_h264(GstCaps *caps, const MFVIDEOFORMAT *format
     if (format_size > sizeof(*format) && (buffer = gst_buffer_new_and_alloc(format_size - sizeof(*format))))
     {
         gst_buffer_fill(buffer, 0, format + 1, format_size - sizeof(*format));
-        gst_caps_set_simple(caps, "streamheader", GST_TYPE_BUFFER, buffer, NULL);
+        if (format_size - sizeof(*format) >= sizeof(UINT32) && *(UINT32 *)(format + 1) == 0x01000000)
+            gst_caps_set_simple(caps, "streamheader", GST_TYPE_BUFFER, buffer, NULL);
+        else
+        {
+            gst_caps_set_simple(caps, "codec_data", GST_TYPE_BUFFER, buffer, NULL);
+            gst_caps_set_simple(caps, "stream-format", G_TYPE_STRING, "avc", NULL);
+        }
         gst_buffer_unref(buffer);
     }
 }
-- 
2.49.0

From afb5af3630f4e7dd0a32fdc6e1f457485a5f481e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 18 Dec 2024 22:43:23 +0100
Subject: [PATCH 1000/1564] winegstreamer/media-converter: Initialize read_size
 to 0 for errors and EOD cases.

---
 dlls/winegstreamer/media-converter/fossilize.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/winegstreamer/media-converter/fossilize.c b/dlls/winegstreamer/media-converter/fossilize.c
index 5f531f0ff38..420f201ef57 100644
--- a/dlls/winegstreamer/media-converter/fossilize.c
+++ b/dlls/winegstreamer/media-converter/fossilize.c
@@ -552,6 +552,7 @@ int fozdb_read_entry_data(struct fozdb *db, uint32_t tag, struct fozdb_hash *has
     GST_DEBUG("db %p, file_name %s, tag %u, hash %s, offset %#"PRIx64", buffer %p, size %zu, read_size %p, with_crc %d.",
             db, db->file_name, tag, format_hash(hash), offset, buffer, size, read_size, with_crc);
 
+    *read_size = 0;
     if (tag >= db->num_tags)
         return CONV_ERROR_INVALID_TAG;
     if (!(ptr = rb_get(&db->entries, &key)))
-- 
2.49.0

From d765389a6723a26906772d18e624584d379f3eaf Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 24 Dec 2024 10:08:24 +0100
Subject: [PATCH 1014/1564] HACK: winegstreamer: Expose AV1 decoding support.

---
 dlls/winegstreamer/video_decoder.c |  1 +
 dlls/winegstreamer/wg_media_type.c | 10 ++++++++++
 2 files changed, 11 insertions(+)

diff --git a/dlls/winegstreamer/video_decoder.c b/dlls/winegstreamer/video_decoder.c
index 5d928d2c03c..a6d5d7d8c62 100644
--- a/dlls/winegstreamer/video_decoder.c
+++ b/dlls/winegstreamer/video_decoder.c
@@ -1709,6 +1709,7 @@ static const GUID *const wmv_decoder_input_types[] =
     &MEDIASUBTYPE_WMV3,
     &MEDIASUBTYPE_VC1S,
     &MFVideoFormat_theora,
+    &MFVideoFormat_AV1,
 };
 static const GUID *const wmv_decoder_output_types[] =
 {
diff --git a/dlls/winegstreamer/wg_media_type.c b/dlls/winegstreamer/wg_media_type.c
index 09a539f1c7a..085a69e7d32 100644
--- a/dlls/winegstreamer/wg_media_type.c
+++ b/dlls/winegstreamer/wg_media_type.c
@@ -369,6 +369,14 @@ static void init_caps_from_video_theora(GstCaps *caps, const MFVIDEOFORMAT *form
     gst_structure_set_name(gst_caps_get_structure(caps, 0), "video/x-theora");
 }
 
+static void init_caps_from_video_av1(GstCaps *caps, const MFVIDEOFORMAT *format, UINT format_size)
+{
+    init_caps_codec_data(caps, format + 1, format_size - sizeof(*format));
+
+    gst_structure_remove_field(gst_caps_get_structure(caps, 0), "format");
+    gst_structure_set_name(gst_caps_get_structure(caps, 0), "video/x-av1");
+}
+
 static void init_caps_from_video_subtype(GstCaps *caps, const GUID *subtype, const void *format, UINT format_size)
 {
     if (IsEqualGUID(subtype, &MFVideoFormat_CVID))
@@ -391,6 +399,8 @@ static void init_caps_from_video_subtype(GstCaps *caps, const GUID *subtype, con
         return init_caps_from_video_mpeg(caps, format, format_size);
     if (IsEqualGUID(subtype, &MFVideoFormat_theora))
         return init_caps_from_video_theora(caps, format, format_size);
+    if (IsEqualGUID(subtype, &MFVideoFormat_AV1))
+        return init_caps_from_video_av1(caps, format, format_size);
 
     GST_FIXME("Unsupported subtype " WG_GUID_FORMAT, WG_GUID_ARGS(*subtype));
 }
-- 
2.49.0

From 15f2f5f480faf291898666b23da5d97133e196cf Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 24 Dec 2024 10:48:22 +0100
Subject: [PATCH 1016/1564] mf/sar: Only allow the output audio media subtype
 as input.

---
 dlls/mf/sar.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/mf/sar.c b/dlls/mf/sar.c
index 970063497b1..96459ad57ea 100644
--- a/dlls/mf/sar.c
+++ b/dlls/mf/sar.c
@@ -1522,6 +1522,7 @@ static HRESULT check_media_type(IMFMediaType *type, IMFMediaType *current)
 {
     static const GUID *required_attrs[] =
     {
+        &MF_MT_SUBTYPE,
         &MF_MT_AUDIO_SAMPLES_PER_SECOND,
         &MF_MT_AUDIO_NUM_CHANNELS,
         &MF_MT_AUDIO_BITS_PER_SAMPLE,
-- 
2.49.0

From b7a47b1ef52fe9b113fc771e7dddfc78b57880de Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 24 Dec 2024 10:11:38 +0100
Subject: [PATCH 1017/1564] HACK: winegstreamer: Expose Opus decoding support.

---
 dlls/winegstreamer/audio_decoder.c |  2 ++
 dlls/winegstreamer/wg_media_type.c | 14 ++++++++++++++
 2 files changed, 16 insertions(+)

diff --git a/dlls/winegstreamer/audio_decoder.c b/dlls/winegstreamer/audio_decoder.c
index a675ef84f35..a2b0dbeb641 100644
--- a/dlls/winegstreamer/audio_decoder.c
+++ b/dlls/winegstreamer/audio_decoder.c
@@ -669,6 +669,8 @@ static WAVEFORMATEXTENSIBLE audio_decoder_input_types[] =
     {.Format = {.wFormatTag = WAVE_FORMAT_EXTENSIBLE, .nChannels = 6, .nSamplesPerSec = 48000, .nAvgBytesPerSec = 1152000, \
                 .nBlockAlign = 24, .wBitsPerSample = 32, .cbSize = sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX)}, \
      .SubFormat = {0x8d2fd10b,0x5841,0x4a6b,{0x89,0x05,0x58,0x8f,0xec,0x1a,0xde,0xd9}}},
+    {.Format = {.wFormatTag = WAVE_FORMAT_OPUS, .nChannels = 6, .nSamplesPerSec = 48000, .nAvgBytesPerSec = 1152000,
+                .nBlockAlign = 24, .wBitsPerSample = 32, .cbSize = sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX)}},
 };
 
 HRESULT audio_decoder_create(REFIID riid, void **ret)
diff --git a/dlls/winegstreamer/wg_media_type.c b/dlls/winegstreamer/wg_media_type.c
index 085a69e7d32..7038a9ed0e1 100644
--- a/dlls/winegstreamer/wg_media_type.c
+++ b/dlls/winegstreamer/wg_media_type.c
@@ -180,6 +180,18 @@ static void init_caps_from_wave_format_vorbis(GstCaps *caps, const WAVEFORMATEX
     gst_caps_set_simple(caps, "bitrate", G_TYPE_INT, format->nAvgBytesPerSec * 8, NULL);
 }
 
+static void init_caps_from_wave_format_opus(GstCaps *caps, const WAVEFORMATEX *format, UINT32 format_size)
+{
+    init_caps_codec_data(caps, format + 1, format->cbSize);
+
+    gst_structure_remove_field(gst_caps_get_structure(caps, 0), "format");
+    gst_structure_set_name(gst_caps_get_structure(caps, 0), "audio/x-opus");
+    gst_caps_set_simple(caps, "channel-mapping-family", G_TYPE_INT, 0, NULL);
+    gst_caps_set_simple(caps, "block_align", G_TYPE_INT, format->nBlockAlign, NULL);
+    gst_caps_set_simple(caps, "depth", G_TYPE_INT, format->wBitsPerSample, NULL);
+    gst_caps_set_simple(caps, "bitrate", G_TYPE_INT, format->nAvgBytesPerSec * 8, NULL);
+}
+
 static void init_caps_from_wave_format(GstCaps *caps, const GUID *subtype,
         const void *format, UINT32 format_size)
 {
@@ -201,6 +213,8 @@ static void init_caps_from_wave_format(GstCaps *caps, const GUID *subtype,
         return init_caps_from_wave_format_wma3(caps, format, format_size, 4);
     if (IsEqualGUID(subtype, &MFAudioFormat_Vorbis))
         return init_caps_from_wave_format_vorbis(caps, format, format_size);
+    if (IsEqualGUID(subtype, &MFAudioFormat_Opus))
+        return init_caps_from_wave_format_opus(caps, format, format_size);
 
     GST_FIXME("Unsupported subtype " WG_GUID_FORMAT, WG_GUID_ARGS(*subtype));
 }
-- 
2.49.0

From 188024baccb8c10a3a535af812fe588e711b9afe Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 24 Dec 2024 10:11:38 +0100
Subject: [PATCH 1018/1564] HACK: msauddecmft: Expose Opus decoding support.

---
 dlls/msauddecmft/msauddecmft.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/msauddecmft/msauddecmft.c b/dlls/msauddecmft/msauddecmft.c
index dd6f91fe5b6..672389564a2 100644
--- a/dlls/msauddecmft/msauddecmft.c
+++ b/dlls/msauddecmft/msauddecmft.c
@@ -124,6 +124,7 @@ HRESULT WINAPI DllRegisterServer(void)
     MFT_REGISTER_TYPE_INFO audio_decoder_mft_inputs[] =
     {
         {MFMediaType_Audio, MFAudioFormat_Vorbis},
+        {MFMediaType_Audio, MFAudioFormat_Opus},
     };
     MFT_REGISTER_TYPE_INFO audio_decoder_mft_outputs[] =
     {
-- 
2.49.0

From fed10bb4f9c7124f7d0479906ecf3de501e10b0e Mon Sep 17 00:00:00 2001
From: Conor McCarthy <cmccarthy@codeweavers.com>
Date: Tue, 10 Dec 2024 00:19:53 +1000
Subject: [PATCH 1020/1564] mf: Propagate errors from session_collect_nodes()
 to the caller of session_set_current_topology().

---
 dlls/mf/session.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/dlls/mf/session.c b/dlls/mf/session.c
index d2cfc4db995..9d6514df8a5 100644
--- a/dlls/mf/session.c
+++ b/dlls/mf/session.c
@@ -2014,7 +2014,8 @@ static HRESULT session_set_current_topology(struct media_session *session, IMFTo
 
     session->source_shutdown_handled = FALSE;
 
-    session_collect_nodes(session);
+    if (FAILED(hr = session_collect_nodes(session)))
+        return hr;
 
     LIST_FOR_EACH_ENTRY(node, &session->presentation.nodes, struct topo_node, entry)
     {
-- 
2.49.0

From cda3fe890881966e63da5de442f85083ffa40f81 Mon Sep 17 00:00:00 2001
From: Conor McCarthy <cmccarthy@codeweavers.com>
Date: Tue, 10 Dec 2024 00:23:16 +1000
Subject: [PATCH 1021/1564] mf: Do not set the topo status if a source has been
 shut down.

The status must remain MF_TOPOSTATUS_INVALID because the topology is
invalid and must be handled as such in session_start().
---
 dlls/mf/session.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/mf/session.c b/dlls/mf/session.c
index 9d6514df8a5..5fc4bdabc12 100644
--- a/dlls/mf/session.c
+++ b/dlls/mf/session.c
@@ -521,7 +521,7 @@ static void session_set_topo_status(struct media_session *session, HRESULT statu
     IMFMediaEvent *event;
     PROPVARIANT param;
 
-    if (topo_status == MF_TOPOSTATUS_INVALID)
+    if (topo_status == MF_TOPOSTATUS_INVALID || status == MF_E_SHUTDOWN)
         return;
 
     if (list_empty(&session->topologies))
-- 
2.49.0

From b4d616a1b1982c8223d0404c4d0d6360e9226a0f Mon Sep 17 00:00:00 2001
From: Conor McCarthy <cmccarthy@codeweavers.com>
Date: Tue, 10 Dec 2024 00:30:14 +1000
Subject: [PATCH 1022/1564] mf/tests: Add a test for source shutdown after
 setting the topology.

---
 dlls/mf/tests/mf.c | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/dlls/mf/tests/mf.c b/dlls/mf/tests/mf.c
index 73526802b63..faf82f676db 100644
--- a/dlls/mf/tests/mf.c
+++ b/dlls/mf/tests/mf.c
@@ -6453,6 +6453,7 @@ static void test_media_session_source_shutdown(void)
     HRESULT hr;
     enum
     {
+        TEST_TOPOLOGY,
         TEST_START,
         TEST_RESTART,
         TEST_PAUSE,
@@ -6465,7 +6466,7 @@ static void test_media_session_source_shutdown(void)
 
     /* These tests don't cover asynchronous shutdown, which is difficult to consistently test. */
 
-    for (shutdown_point = TEST_START; shutdown_point <= TEST_CLOSE; ++shutdown_point)
+    for (shutdown_point = TEST_TOPOLOGY; shutdown_point <= TEST_CLOSE; ++shutdown_point)
     {
         winetest_push_context("Test %d", shutdown_point);
 
@@ -6489,6 +6490,8 @@ static void test_media_session_source_shutdown(void)
         hr = MFCreateMediaSession(NULL, &session);
         ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
         topology = create_test_topology(source, sink_activate, &duration);
+        if (shutdown_point == TEST_TOPOLOGY)
+            IMFMediaSource_Shutdown(source);
         hr = IMFMediaSession_SetTopology(session, 0, topology);
         ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
         IMFTopology_Release(topology);
@@ -6501,7 +6504,7 @@ static void test_media_session_source_shutdown(void)
             IMFMediaSource_Shutdown(source);
         ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
         hr = wait_media_event(session, callback, MESessionStarted, 5000, &propvar);
-        ok(hr == (shutdown_point == TEST_START ? MF_E_INVALIDREQUEST : S_OK), "Unexpected hr %#lx.\n", hr);
+        ok(hr == (shutdown_point <= TEST_START ? MF_E_INVALIDREQUEST : S_OK), "Unexpected hr %#lx.\n", hr);
 
         switch (shutdown_point)
         {
-- 
2.49.0

From b7f8b7996800882d069991bd3d64fa1d2c6a19b8 Mon Sep 17 00:00:00 2001
From: Brendan McGrath <bmcgrath@codeweavers.com>
Date: Wed, 8 Jan 2025 13:37:52 +1100
Subject: [PATCH 1028/1564] mfmediaengine: Use D3D resource when scaling.

The D3D resource is currently only used when no scaling is required.
This patch allows the D3D resource to be used on the scaling path (when
availble).

This addressess a performance regression in MSFS as a result of the Wine
merge.

CW-Bug-Id: #22403
---
 dlls/mfmediaengine/main.c | 69 +++++++++++++++++++++++++--------------
 1 file changed, 45 insertions(+), 24 deletions(-)

diff --git a/dlls/mfmediaengine/main.c b/dlls/mfmediaengine/main.c
index 8457ba0853d..5b6c762ca48 100644
--- a/dlls/mfmediaengine/main.c
+++ b/dlls/mfmediaengine/main.c
@@ -2389,11 +2389,39 @@ static void media_engine_adjust_destination_for_ratio(const struct media_engine
     }
 }
 
+static HRESULT get_d3d11_resource_from_sample(IMFSample *sample, ID3D11Texture2D **resource, UINT *subresource)
+{
+    IMFDXGIBuffer *dxgi_buffer;
+    IMFMediaBuffer *buffer;
+    HRESULT hr;
+
+    *resource = NULL;
+    *subresource = 0;
+
+    if (FAILED(hr = IMFSample_GetBufferByIndex(sample, 0, &buffer)))
+        return hr;
+
+    if (SUCCEEDED(hr = IMFMediaBuffer_QueryInterface(buffer, &IID_IMFDXGIBuffer, (void **)&dxgi_buffer)))
+    {
+        IMFDXGIBuffer_GetSubresourceIndex(dxgi_buffer, subresource);
+        hr = IMFDXGIBuffer_GetResource(dxgi_buffer, &IID_ID3D11Texture2D, (void **)resource);
+        IMFDXGIBuffer_Release(dxgi_buffer);
+    }
+
+    IMFMediaBuffer_Release(buffer);
+    return hr;
+}
+
 static void media_engine_update_d3d11_frame_surface(ID3D11DeviceContext *context, struct media_engine *engine)
 {
     D3D11_TEXTURE2D_DESC surface_desc;
+    D3D11_TEXTURE2D_DESC src_desc;
     IMFMediaBuffer *media_buffer;
+    ID3D11Texture2D *src_texture;
+    ID3D11Device *device;
     IMFSample *sample;
+    UINT subresource;
+    HRESULT hr;
 
     if (!video_frame_sink_get_sample(engine->presentation.frame_sink, &sample))
         return;
@@ -2411,7 +2439,23 @@ static void media_engine_update_d3d11_frame_surface(ID3D11DeviceContext *context
         surface_desc.Width = 0;
     }
 
-    if (SUCCEEDED(IMFSample_ConvertToContiguousBuffer(sample, &media_buffer)))
+    if (SUCCEEDED(hr = get_d3d11_resource_from_sample(sample, &src_texture, &subresource)))
+    {
+
+        ID3D11Texture2D_GetDesc(src_texture, &src_desc);
+
+        if (SUCCEEDED(hr = media_engine_lock_d3d_device(engine, &device)))
+        {
+            ID3D11Device_GetImmediateContext(device, &context);
+            ID3D11DeviceContext_CopyResource(context, (ID3D11Resource *)engine->video_frame.d3d11.source, (ID3D11Resource *)src_texture);
+            ID3D11DeviceContext_Release(context);
+            media_engine_unlock_d3d_device(engine, device);
+        }
+
+        ID3D11Texture2D_Release(src_texture);
+    }
+
+    if (FAILED(hr) && SUCCEEDED(IMFSample_ConvertToContiguousBuffer(sample, &media_buffer)))
     {
         BYTE *buffer;
         DWORD buffer_size;
@@ -2431,29 +2475,6 @@ static void media_engine_update_d3d11_frame_surface(ID3D11DeviceContext *context
     IMFSample_Release(sample);
 }
 
-static HRESULT get_d3d11_resource_from_sample(IMFSample *sample, ID3D11Texture2D **resource, UINT *subresource)
-{
-    IMFDXGIBuffer *dxgi_buffer;
-    IMFMediaBuffer *buffer;
-    HRESULT hr;
-
-    *resource = NULL;
-    *subresource = 0;
-
-    if (FAILED(hr = IMFSample_GetBufferByIndex(sample, 0, &buffer)))
-        return hr;
-
-    if (SUCCEEDED(hr = IMFMediaBuffer_QueryInterface(buffer, &IID_IMFDXGIBuffer, (void **)&dxgi_buffer)))
-    {
-        IMFDXGIBuffer_GetSubresourceIndex(dxgi_buffer, subresource);
-        hr = IMFDXGIBuffer_GetResource(dxgi_buffer, &IID_ID3D11Texture2D, (void **)resource);
-        IMFDXGIBuffer_Release(dxgi_buffer);
-    }
-
-    IMFMediaBuffer_Release(buffer);
-    return hr;
-}
-
 static HRESULT media_engine_transfer_d3d11(struct media_engine *engine, ID3D11Texture2D *dst_texture,
         const MFVideoNormalizedRect *src_rect, const RECT *dst_rect, const MFARGB *color)
 {
-- 
2.49.0

From 59ae8cb1568d7cdde40a133a5bbb89eeb459fb6e Mon Sep 17 00:00:00 2001
From: Conor McCarthy <cmccarthy@codeweavers.com>
Date: Mon, 13 Jan 2025 15:37:56 +1000
Subject: [PATCH 1049/1564] winegstreamer: Do not unref the buffer in
 push_vorbis_headers().

gst_value_get_buffer() does not return a reference to the buffer.
---
 dlls/winegstreamer/wg_transform.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
index 18a6599f7b9..78cca8c2d4d 100644
--- a/dlls/winegstreamer/wg_transform.c
+++ b/dlls/winegstreamer/wg_transform.c
@@ -534,7 +534,6 @@ static void push_vorbis_headers(struct wg_transform *transform)
 
 failed:
     gst_buffer_unmap(codec_data, &info);
-    gst_buffer_unref(codec_data);
 }
 
 
-- 
2.49.0

From dbf857a2d56e6ecca524bb96efc00f2893f28253 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 14 Jan 2025 11:44:00 +0100
Subject: [PATCH 1051/1564] HACK: mfplat: Use the MP4 bytestream handler as a
 fallback.

Instead of falling back directly to GStreamer media source, giving a
chance to winedmo.

This fixes Twisted Sails video playback, as it plays a MP4 file with
a ".resource" extension, no MIME type, and doesn't set the
MF_RESOLUTION_CONTENT_DOES_NOT_HAVE_TO_MATCH_EXTENSION_OR_MIME_TYPE
flag on resolver creation.

This is a hack as it probably is something wrong with the resolver
creation, which should likely find the MP4 bytestream handler on its
own, even if that flag isn't set, but it will also make sure the MF
pipelines are used all the time as default, similar to Proton 9 NMS.

CW-Bug-Id: #24673
---
 dlls/mfplat/main.c | 12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)

diff --git a/dlls/mfplat/main.c b/dlls/mfplat/main.c
index 8e15abc4de0..839f54a9cb4 100644
--- a/dlls/mfplat/main.c
+++ b/dlls/mfplat/main.c
@@ -43,6 +43,7 @@
 #include "strsafe.h"
 #undef INITGUID
 #include "evr.h"
+#include "wine/mfinternal.h"
 /* mfd3d12 guids are not included in mfuuid */
 #define INITGUID
 #undef EXTERN_GUID
@@ -6292,10 +6293,9 @@ static HRESULT resolver_get_bytestream_url_hint(IMFByteStream *stream, WCHAR con
     return S_OK;
 }
 
-static HRESULT resolver_create_gstreamer_handler(IMFByteStreamHandler **handler)
+static HRESULT resolver_create_default_handler(IMFByteStreamHandler **handler)
 {
-    static const GUID CLSID_GStreamerByteStreamHandler = {0x317df618, 0x5e5a, 0x468a, {0x9f, 0x15, 0xd8, 0x27, 0xa9, 0xa0, 0x81, 0x62}};
-    return CoCreateInstance(&CLSID_GStreamerByteStreamHandler, NULL, CLSCTX_INPROC_SERVER, &IID_IMFByteStreamHandler, (void **)handler);
+    return CoCreateInstance(&CLSID_MPEG4ByteStreamHandlerPlugin, NULL, CLSCTX_INPROC_SERVER, &IID_IMFByteStreamHandler, (void **)handler);
 }
 
 static HRESULT resolver_get_bytestream_handler(IMFByteStream *stream, const WCHAR *url, DWORD flags,
@@ -6331,12 +6331,14 @@ static HRESULT resolver_get_bytestream_handler(IMFByteStream *stream, const WCHA
        this handler for all possible types.
      */
 
+    TRACE( "url_ext %s mimeW %s\n", debugstr_w(url_ext), debugstr_w(mimeW) );
+
     if (url_ext || mimeW)
     {
         hr = resolver_create_bytestream_handler(stream, flags, mimeW, url_ext, handler);
 
         if (FAILED(hr))
-            hr = resolver_create_gstreamer_handler(handler);
+            hr = resolver_create_default_handler(handler);
     }
 
     CoTaskMemFree(mimeW);
@@ -6354,7 +6356,7 @@ static HRESULT resolver_get_bytestream_handler(IMFByteStream *stream, const WCHA
     hr = resolver_create_bytestream_handler(stream, flags, NULL, url_ext, handler);
 
     if (FAILED(hr))
-        hr = resolver_create_gstreamer_handler(handler);
+        hr = resolver_create_default_handler(handler);
 
     return hr;
 }
-- 
2.49.0

From 5ff0d9c8bd93c1f5dbd80b994b52e6912d215fc3 Mon Sep 17 00:00:00 2001
From: Conor McCarthy <cmccarthy@codeweavers.com>
Date: Fri, 17 Jan 2025 14:29:47 +1000
Subject: [PATCH 1064/1564] HACK: mfreadwrite: Flag ENDOFSTREAM for all source
 streams for Darksiders Warmastered Edition.

CW-Bug-Id: #24656
---
 dlls/mfreadwrite/reader.c | 21 +++++++++++++++++++--
 1 file changed, 19 insertions(+), 2 deletions(-)

diff --git a/dlls/mfreadwrite/reader.c b/dlls/mfreadwrite/reader.c
index 79425be0bbb..f98c98b91d8 100644
--- a/dlls/mfreadwrite/reader.c
+++ b/dlls/mfreadwrite/reader.c
@@ -175,6 +175,9 @@ struct source_reader
     CONDITION_VARIABLE sample_event;
     CONDITION_VARIABLE state_event;
     CONDITION_VARIABLE stop_event;
+
+    BOOL flag_eos_for_all_streams;
+    DWORD next_stream_eos_index;
 };
 
 static inline struct source_reader *impl_from_IMFSourceReaderEx(IMFSourceReaderEx *iface)
@@ -1344,9 +1347,11 @@ static HRESULT source_reader_get_next_selected_stream(struct source_reader *read
     }
 
     /* If all selected streams reached EOS, use first selected. */
-    if (first_selected != ~0u)
+    if (first_selected != ~0u && min_ts == MAXLONGLONG)
     {
-        if (min_ts == MAXLONGLONG)
+        if (reader->flag_eos_for_all_streams)
+            *stream_index = reader->next_stream_eos_index++ % reader->stream_count;
+        else
             *stream_index = first_selected;
     }
 
@@ -2644,6 +2649,8 @@ static HRESULT create_source_reader_from_source(IMFMediaSource *source, IMFAttri
     unsigned int i;
     HRESULT hr;
 
+    const char *sgi;
+
     object = calloc(1, sizeof(*object));
     if (!object)
         return E_OUTOFMEMORY;
@@ -2765,6 +2772,16 @@ static HRESULT create_source_reader_from_source(IMFMediaSource *source, IMFAttri
         }
     }
 
+    if (object->stream_count > 1 && (sgi = getenv("SteamGameId")) && strcmp(sgi, "462780") == 0)
+    {
+        /* Darksiders Warmastered Edition ends media sampling only when MF_SOURCE_READERF_ENDOFSTREAM
+         * is returned for all streams. If audio and video end simultaneously then ENDOFSTREAM is
+         * flagged only for stream 0, therefore the game depends on a slight time difference which
+         * usually does not occur for the fourth splash video. */
+        WARN("HACK: enabled flagging ENDOFSTREAM for all streams.\n");
+        object->flag_eos_for_all_streams = TRUE;
+    }
+
     if (FAILED(hr = MFLockSharedWorkQueue(L"", 0, NULL, &object->queue)))
         WARN("Failed to acquired shared queue, hr %#lx.\n", hr);
 
-- 
2.49.0

From ef11cac2d0d6fc8ec7aa5519ad617929e793fa8f Mon Sep 17 00:00:00 2001
From: Brendan McGrath <bmcgrath@codeweavers.com>
Date: Fri, 17 Jan 2025 18:03:20 +1100
Subject: [PATCH 1079/1564] mf: HACK: VRChat (438100) Drop late audio packets.

VRChat requires audio packets that are late to be dropped prior to
being passed to an MFT.

CW-Bug-Id: #24665
---
 dlls/mf/session.c | 25 ++++++++++++++++++++++---
 1 file changed, 22 insertions(+), 3 deletions(-)

diff --git a/dlls/mf/session.c b/dlls/mf/session.c
index 5fc4bdabc12..62efa0d75f9 100644
--- a/dlls/mf/session.c
+++ b/dlls/mf/session.c
@@ -3724,13 +3724,32 @@ static HRESULT transform_node_push_sample(const struct media_session *session, s
     struct transform_stream *stream = &topo_node->u.transform.inputs[input];
     UINT id = transform_node_get_stream_id(topo_node, FALSE, input);
     IMFTransform *transform = topo_node->object.transform;
+    MFTIME pts, clocktime;
+    IMFMediaType *type;
+    GUID major_type;
+    const char *sgi;
     HRESULT hr;
 
     if (sample)
     {
-        hr = IMFTransform_ProcessInput(transform, id, sample, 0);
-        if (hr == MF_E_NOTACCEPTING)
-            hr = transform_stream_push_sample(stream, sample);
+        /* HACK: VRChat (438100) requires audio packets that are late to be dropped prior to being passed to an MFT */
+        if((sgi = getenv("SteamGameId")) && !strcmp(sgi, "438100") &&
+            SUCCEEDED(IMFTransform_GetOutputCurrentType(transform, id, &type)) &&
+            SUCCEEDED(IMFMediaType_GetMajorType(type, &major_type)) &&
+            IsEqualGUID(&major_type, &MFMediaType_Audio) &&
+            SUCCEEDED(IMFSample_GetSampleTime(sample, &pts)) && pts != MINLONGLONG &&
+            SUCCEEDED(IMFPresentationClock_GetTime(session->clock, &clocktime)) &&
+            clocktime > pts)
+        {
+            hr = S_OK;
+            FIXME("dropping audio sample clocktime %I64d pts %I64d jitter: %I64d\n", clocktime, pts, clocktime - pts);
+        }
+        else
+        {
+            hr = IMFTransform_ProcessInput(transform, id, sample, 0);
+            if (hr == MF_E_NOTACCEPTING)
+                hr = transform_stream_push_sample(stream, sample);
+        }
     }
     else
     {
-- 
2.49.0

From fcb6691d44c7e8f2e12c83316d0c617258ab831a Mon Sep 17 00:00:00 2001
From: Yuxuan Shui <yshui@codeweavers.com>
Date: Tue, 9 Jan 2024 11:31:50 +0000
Subject: [PATCH 1080/1564] HACK: winegstreamer: Implement URI media source
 with uridecodebin.

This overrides Urlmon based scheme handlers. The urlmon scheme handlers
only support playback of the media after it has been fully downloaded
from the internet, and has no streaming support. This is undesirable for
games like VRChat.

Link: https://github.com/ValveSoftware/wine/pull/142
CW-Bug-Id: #20485
CW-Bug-Id: #23217
---
 dlls/mf/mf.rgs                               |   8 -
 dlls/winegstreamer/gst_private.h             |   1 +
 dlls/winegstreamer/media_source.c            | 262 +++++++++++++++++++
 dlls/winegstreamer/mfplat.c                  |   3 +
 dlls/winegstreamer/wg_parser.c               |  14 +-
 dlls/winegstreamer/winegstreamer.rgs         |  28 ++
 dlls/winegstreamer/winegstreamer_classes.idl |   7 +
 7 files changed, 312 insertions(+), 11 deletions(-)

diff --git a/dlls/mf/mf.rgs b/dlls/mf/mf.rgs
index f06576baccb..f127df76321 100644
--- a/dlls/mf/mf.rgs
+++ b/dlls/mf/mf.rgs
@@ -12,14 +12,6 @@ HKLM
                     {
                         val '{477ec299-1421-4bdd-971f-7ccb933f21ad}' = s 'File Scheme Handler'
                     }
-                    'http:'
-                    {
-                        val '{9ec4b4f9-3029-45ad-947b-344de2a249e2}' = s 'Urlmon Scheme Handler'
-                    }
-                    'https:'
-                    {
-                        val '{9ec4b4f9-3029-45ad-947b-344de2a249e2}' = s 'Urlmon Scheme Handler'
-                    }
                 }
             }
         }
diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index aa76b4d7324..f935ca79f58 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -187,6 +187,7 @@ HRESULT audio_decoder_create(REFIID riid, void **ret);
 HRESULT aac_decoder_create(REFIID riid, void **ret);
 HRESULT h264_decoder_create(REFIID riid, void **ret);
 HRESULT video_processor_create(REFIID riid, void **ret);
+HRESULT gstreamer_scheme_handler_create(REFIID riid, void **ret);
 
 HRESULT h264_encoder_create(REFIID riid, void **ret);
 
diff --git a/dlls/winegstreamer/media_source.c b/dlls/winegstreamer/media_source.c
index 85075256420..0bb2c6b4000 100644
--- a/dlls/winegstreamer/media_source.c
+++ b/dlls/winegstreamer/media_source.c
@@ -2170,3 +2170,265 @@ HRESULT gstreamer_byte_stream_handler_create(REFIID riid, void **obj)
 
     return hr;
 }
+
+struct scheme_handler
+{
+    IMFSchemeHandler IMFSchemeHandler_iface;
+    IMFAsyncCallback IMFAsyncCallback_iface;
+    LONG refcount;
+    struct list results;
+    CRITICAL_SECTION cs;
+};
+
+static struct scheme_handler *impl_from_IMFSchemeHandler(IMFSchemeHandler *iface)
+{
+    return CONTAINING_RECORD(iface, struct scheme_handler, IMFSchemeHandler_iface);
+}
+
+static struct scheme_handler *scheme_handler_from_IMFAsyncCallback(IMFAsyncCallback *iface)
+{
+    return CONTAINING_RECORD(iface, struct scheme_handler, IMFAsyncCallback_iface);
+}
+
+static struct result_entry *scheme_handler_find_result_entry(struct scheme_handler *handler, IMFAsyncResult *result)
+{
+    struct result_entry *entry;
+
+    EnterCriticalSection(&handler->cs);
+    LIST_FOR_EACH_ENTRY(entry, &handler->results, struct result_entry, entry)
+    {
+        if (result == entry->result)
+        {
+            list_remove(&entry->entry);
+            LeaveCriticalSection(&handler->cs);
+            return entry;
+        }
+    }
+    LeaveCriticalSection(&handler->cs);
+
+    return NULL;
+}
+
+
+static HRESULT WINAPI scheme_handler_QueryIntace(IMFSchemeHandler *iface, REFIID riid, void **obj)
+{
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), obj);
+
+    if (IsEqualIID(riid, &IID_IMFSchemeHandler) ||
+            IsEqualIID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+        IMFSchemeHandler_AddRef(iface);
+        return S_OK;
+    }
+
+    WARN("Unsupported %s.\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI scheme_handler_AddRef(IMFSchemeHandler *iface)
+{
+    struct scheme_handler *handler = impl_from_IMFSchemeHandler(iface);
+    ULONG refcount = InterlockedIncrement(&handler->refcount);
+
+    TRACE("%p, refcount %lu.\n", handler, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI scheme_handler_Release(IMFSchemeHandler *iface)
+{
+    struct scheme_handler *handler = impl_from_IMFSchemeHandler(iface);
+    ULONG refcount = InterlockedDecrement(&handler->refcount);
+    struct result_entry *result, *next;
+
+    TRACE("%p, refcount %lu.\n", iface, refcount);
+
+    if (!refcount)
+    {
+        LIST_FOR_EACH_ENTRY_SAFE(result, next, &handler->results, struct result_entry, entry)
+            result_entry_destroy(result);
+        DeleteCriticalSection(&handler->cs);
+        free(handler);
+    }
+
+    return refcount;
+}
+
+static HRESULT WINAPI scheme_handler_BeginCreateObject(IMFSchemeHandler *iface, const WCHAR *url, DWORD flags,
+        IPropertyStore *props, IUnknown **cancel_cookie, IMFAsyncCallback *callback, IUnknown *state)
+{
+    struct scheme_handler *handler = impl_from_IMFSchemeHandler(iface);
+    IMFByteStream *bytestream;
+    IMFAsyncResult *result;
+    IUnknown *context;
+    IStream *stream;
+    HRESULT hr;
+
+    TRACE("%p, %s, %#lx, %p, %p, %p, %p.\n", iface, debugstr_w(url), flags, props, cancel_cookie, callback, state);
+
+    if (cancel_cookie)
+        *cancel_cookie = NULL;
+
+    if (FAILED(hr = CreateStreamOnHGlobal(0, TRUE, &stream)))
+        return hr;
+
+    hr = MFCreateMFByteStreamOnStream(stream, &bytestream);
+    IStream_Release(stream);
+    if (FAILED(hr))
+        return hr;
+
+    if (FAILED(hr = MFCreateAsyncResult(NULL, callback, state, &result)))
+        return hr;
+    if (FAILED(hr = object_context_create(flags, bytestream, url, -1, result, &context)))
+    {
+        IMFAsyncResult_Release(result);
+        return hr;
+    }
+
+    hr = MFPutWorkItem(MFASYNC_CALLBACK_QUEUE_IO, &handler->IMFAsyncCallback_iface, context);
+    IUnknown_Release(context);
+    IMFAsyncResult_Release(result);
+
+    return hr;
+}
+
+static HRESULT WINAPI scheme_handler_EndCreateObject(IMFSchemeHandler *iface, IMFAsyncResult *result,
+        MF_OBJECT_TYPE *obj_type, IUnknown **object)
+{
+    struct scheme_handler *handler = impl_from_IMFSchemeHandler(iface);
+    struct result_entry *entry;
+    HRESULT hr;
+
+    TRACE("%p, %p, %p, %p.\n", iface, result, obj_type, object);
+
+    if (!(entry = scheme_handler_find_result_entry(handler, result)))
+    {
+        *obj_type = MF_OBJECT_INVALID;
+        *object = NULL;
+        return MF_E_UNEXPECTED;
+    }
+
+    hr = IMFAsyncResult_GetStatus(entry->result);
+    *obj_type = MF_OBJECT_MEDIASOURCE;
+    *object = entry->object;
+    IUnknown_AddRef(*object);
+    result_entry_destroy(entry);
+
+    return hr;
+}
+
+static HRESULT WINAPI scheme_handler_CancelObjectCreation(IMFSchemeHandler *iface, IUnknown *cancel_cookie)
+{
+    /* Cancellation is not supported. */
+    TRACE("%p, %p.\n", iface, cancel_cookie);
+    return MF_E_UNEXPECTED;
+}
+
+static const IMFSchemeHandlerVtbl scheme_handler_vtbl =
+{
+    scheme_handler_QueryIntace,
+    scheme_handler_AddRef,
+    scheme_handler_Release,
+    scheme_handler_BeginCreateObject,
+    scheme_handler_EndCreateObject,
+    scheme_handler_CancelObjectCreation,
+};
+
+static HRESULT WINAPI scheme_handler_callback_QueryInterface(IMFAsyncCallback *iface, REFIID riid, void **obj)
+{
+    if (IsEqualIID(riid, &IID_IMFAsyncCallback) ||
+            IsEqualIID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+        IMFAsyncCallback_AddRef(iface);
+        return S_OK;
+    }
+
+    WARN("Unsupported %s.\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI scheme_handler_callback_AddRef(IMFAsyncCallback *iface)
+{
+    struct scheme_handler *handler = scheme_handler_from_IMFAsyncCallback(iface);
+    return IMFSchemeHandler_AddRef(&handler->IMFSchemeHandler_iface);
+}
+
+static ULONG WINAPI scheme_handler_callback_Release(IMFAsyncCallback *iface)
+{
+    struct scheme_handler *handler = scheme_handler_from_IMFAsyncCallback(iface);
+    return IMFSchemeHandler_Release(&handler->IMFSchemeHandler_iface);
+}
+
+static HRESULT WINAPI scheme_handler_callback_GetParameters(IMFAsyncCallback *iface, DWORD *flags, DWORD *queue)
+{
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI scheme_handler_callback_Invoke(IMFAsyncCallback *iface, IMFAsyncResult *result)
+{
+    struct scheme_handler *handler = scheme_handler_from_IMFAsyncCallback(iface);
+    IUnknown *object, *state = IMFAsyncResult_GetStateNoAddRef(result);
+    struct object_context *context;
+    struct result_entry *entry;
+    HRESULT hr;
+
+    if (!state || !(context = impl_from_IUnknown(state)))
+        return E_INVALIDARG;
+
+    if (FAILED(hr = media_source_create(context, (IMFMediaSource **)&object)))
+        WARN("Failed to create media source, hr %#lx\n", hr);
+    else
+    {
+        if (FAILED(hr = result_entry_create(context->result, MF_OBJECT_MEDIASOURCE, object, &entry)))
+            WARN("Failed to create handler result, hr %#lx\n", hr);
+        else
+        {
+            EnterCriticalSection(&handler->cs);
+            list_add_tail(&handler->results, &entry->entry);
+            LeaveCriticalSection(&handler->cs);
+        }
+
+        IUnknown_Release(object);
+    }
+
+    IMFAsyncResult_SetStatus(context->result, hr);
+    MFInvokeCallback(context->result);
+
+    return S_OK;
+}
+
+static const IMFAsyncCallbackVtbl scheme_handler_callback_vtbl =
+{
+    scheme_handler_callback_QueryInterface,
+    scheme_handler_callback_AddRef,
+    scheme_handler_callback_Release,
+    scheme_handler_callback_GetParameters,
+    scheme_handler_callback_Invoke,
+};
+
+HRESULT gstreamer_scheme_handler_create(REFIID riid, void **obj)
+{
+    struct scheme_handler *handler;
+    HRESULT hr;
+
+    TRACE("%s, %p.\n", debugstr_guid(riid), obj);
+
+    if (!(handler = calloc(1, sizeof(*handler))))
+        return E_OUTOFMEMORY;
+
+    list_init(&handler->results);
+    InitializeCriticalSection(&handler->cs);
+
+    handler->IMFSchemeHandler_iface.lpVtbl = &scheme_handler_vtbl;
+    handler->IMFAsyncCallback_iface.lpVtbl = &scheme_handler_callback_vtbl;
+    handler->refcount = 1;
+
+    hr = IMFSchemeHandler_QueryInterface(&handler->IMFSchemeHandler_iface, riid, obj);
+    IMFSchemeHandler_Release(&handler->IMFSchemeHandler_iface);
+
+    return hr;
+}
diff --git a/dlls/winegstreamer/mfplat.c b/dlls/winegstreamer/mfplat.c
index 6cde52069bc..89bc213213d 100644
--- a/dlls/winegstreamer/mfplat.c
+++ b/dlls/winegstreamer/mfplat.c
@@ -129,6 +129,8 @@ static const GUID CLSID_wg_aac_decoder = {0xe7889a8a,0x2083,0x4844,{0x83,0x70,0x
 static const GUID CLSID_wg_h264_decoder = {0x1f1e273d,0x12c0,0x4b3a,{0x8e,0x9b,0x19,0x33,0xc2,0x49,0x8a,0xea}};
 static const GUID CLSID_wg_h264_encoder = {0x6c34de69,0x4670,0x46cd,{0x8c,0xb4,0x1f,0x2f,0xa1,0xdf,0xfb,0x65}};
 
+static const GUID CLSID_GStreamerSchemePlugin = {0x587eeb6a,0x7336,0x4ebd,{0xa4,0xf2,0x91,0xc9,0x48,0xde,0x62,0x2c}};
+
 static const struct class_object
 {
     const GUID *clsid;
@@ -139,6 +141,7 @@ class_objects[] =
     { &CLSID_wg_video_processor, &video_processor_create },
     { &CLSID_GStreamerAudioDecoder, &audio_decoder_create },
     { &CLSID_GStreamerByteStreamHandler, &gstreamer_byte_stream_handler_create },
+    { &CLSID_GStreamerSchemePlugin, &gstreamer_scheme_handler_create },
     { &CLSID_wg_aac_decoder, &aac_decoder_create },
     { &CLSID_wg_h264_decoder, &h264_decoder_create },
     { &CLSID_wg_h264_encoder, &h264_encoder_create },
diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index 7ac9079120a..9bf7b5ecd28 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -2014,14 +2014,22 @@ static NTSTATUS wg_parser_disconnect(void *args)
 static BOOL decodebin_parser_init_gst(struct wg_parser *parser)
 {
     GstElement *element;
+    const char *type;
 
-    if (!(element = create_element("decodebin", "base")))
+    type = parser->uri && (!strncmp(parser->uri, "http://", 7) || !strncmp(parser->uri, "https://", 8) ||
+                            !strncmp(parser->uri, "rtsp://", 7)) ? "uridecodebin" : "decodebin";
+    if (!(element = create_element(type, "base")))
         return FALSE;
+    GST_INFO("creating %s element for uri \"%s\"", type, parser->uri ? parser->uri : "(null)");
 
     gst_bin_add(GST_BIN(parser->container), element);
     parser->decodebin = element;
 
-    g_object_set(element, "max-size-bytes", G_MAXUINT, NULL);
+    if (!strcmp(type, "decodebin"))
+        g_object_set(element, "max-size-bytes", G_MAXUINT, NULL);
+    else
+        g_object_set(element, "uri", parser->uri, NULL);
+
     g_signal_connect(element, "pad-added", G_CALLBACK(pad_added_cb), parser);
     g_signal_connect(element, "pad-removed", G_CALLBACK(pad_removed_cb), parser);
     g_signal_connect(element, "autoplug-continue", G_CALLBACK(autoplug_continue_cb), parser);
@@ -2034,7 +2042,7 @@ static BOOL decodebin_parser_init_gst(struct wg_parser *parser)
     parser->no_more_pads = false;
     pthread_mutex_unlock(&parser->mutex);
 
-    if (!link_src_to_element(parser->my_src, element))
+    if (!strcmp(type, "decodebin") && !link_src_to_element(parser->my_src, element))
         return FALSE;
 
     return TRUE;
diff --git a/dlls/winegstreamer/winegstreamer.rgs b/dlls/winegstreamer/winegstreamer.rgs
index 923ba673f8c..c50d3a05747 100644
--- a/dlls/winegstreamer/winegstreamer.rgs
+++ b/dlls/winegstreamer/winegstreamer.rgs
@@ -12,3 +12,31 @@ HKCR
         }
     }
 }
+
+HKLM
+{
+    NoRemove 'Software'
+    {
+        NoRemove 'Microsoft'
+        {
+            NoRemove 'Windows Media Foundation'
+            {
+                NoRemove 'SchemeHandlers'
+                {
+                    'http:'
+                    {
+                        val '{587eeb6a-7336-4ebd-a4f2-91c948de622c}' = s 'GStreamer Scheme Handler'
+                    }
+                    'https:'
+                    {
+                        val '{587eeb6a-7336-4ebd-a4f2-91c948de622c}' = s 'GStreamer Scheme Handler'
+                    }
+                    'rtsp:'
+                    {
+                        val '{587eeb6a-7336-4ebd-a4f2-91c948de622c}' = s 'GStreamer Scheme Handler'
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/dlls/winegstreamer/winegstreamer_classes.idl b/dlls/winegstreamer/winegstreamer_classes.idl
index d435ea68232..ec16e14a6bb 100644
--- a/dlls/winegstreamer/winegstreamer_classes.idl
+++ b/dlls/winegstreamer/winegstreamer_classes.idl
@@ -77,6 +77,13 @@ coclass wg_video_processor {}
 ]
 coclass GStreamerByteStreamHandler {}
 
+[
+    helpstring("GStreamer scheme handler"),
+    threading(both),
+    uuid(587eeb6a-7336-4ebd-a4f2-91c948de622c)
+]
+coclass GStreamerSchemePlugin { }
+
 [
     threading(both),
     uuid(480b1517-c8e9-4eae-b006-e6300718d85d)
-- 
2.49.0

From 13315afc0eb8ea23c51f18489b10e139cd21877b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 29 Jan 2025 12:21:13 +0100
Subject: [PATCH 1087/1564] HACK: winegstreamer/quartz_parser: Allow
 conversions between raw formats in the parser.

This should instead be done with PE-side color conversion in the DShow
pipeline, but dshow pipelines are not yet ready for that.

CW-Bug-Id: #24739
---
 dlls/winegstreamer/quartz_parser.c | 54 ++++++++++++++++++++----------
 1 file changed, 36 insertions(+), 18 deletions(-)

diff --git a/dlls/winegstreamer/quartz_parser.c b/dlls/winegstreamer/quartz_parser.c
index c1dc0d7951f..5eb2cae8d15 100644
--- a/dlls/winegstreamer/quartz_parser.c
+++ b/dlls/winegstreamer/quartz_parser.c
@@ -1654,11 +1654,8 @@ static HRESULT decodebin_parser_source_query_accept(struct parser_source *pin, c
     return amt_to_wg_format(mt, &format) ? S_OK : S_FALSE;
 }
 
-static HRESULT decodebin_parser_source_get_media_type(struct parser_source *pin,
-        unsigned int index, AM_MEDIA_TYPE *mt)
+static HRESULT get_raw_media_type(struct wg_format *format, unsigned int index, AM_MEDIA_TYPE *mt)
 {
-    struct wg_format format;
-
     static const enum wg_video_format video_formats[] =
     {
         /* Try to prefer YUV formats over RGB ones. Most decoders output in the
@@ -1678,31 +1675,29 @@ static HRESULT decodebin_parser_source_get_media_type(struct parser_source *pin,
         WG_VIDEO_FORMAT_RGB15,
     };
 
-    wg_parser_stream_get_current_format(pin->wg_stream, &format);
-
     memset(mt, 0, sizeof(AM_MEDIA_TYPE));
 
-    if (amt_from_wg_format(mt, &format, false))
+    if (amt_from_wg_format(mt, format, false))
     {
         if (!index--)
             return S_OK;
         FreeMediaType(mt);
     }
 
-    if (format.major_type == WG_MAJOR_TYPE_VIDEO && index < ARRAY_SIZE(video_formats))
+    if (format->major_type == WG_MAJOR_TYPE_VIDEO && index < ARRAY_SIZE(video_formats))
     {
-        format.u.video.format = video_formats[index];
+        format->u.video.format = video_formats[index];
         /* Downstream filters probably expect RGB video to be bottom-up. */
-        if (format.u.video.height > 0 && wg_video_format_is_rgb(video_formats[index]))
-            format.u.video.height = -format.u.video.height;
-        if (!amt_from_wg_format(mt, &format, false))
+        if (format->u.video.height > 0 && wg_video_format_is_rgb(video_formats[index]))
+            format->u.video.height = -format->u.video.height;
+        if (!amt_from_wg_format(mt, format, false))
             return E_OUTOFMEMORY;
         return S_OK;
     }
-    else if (format.major_type == WG_MAJOR_TYPE_AUDIO && !index)
+    else if (format->major_type == WG_MAJOR_TYPE_AUDIO && !index)
     {
-        format.u.audio.format = WG_AUDIO_FORMAT_S16LE;
-        if (!amt_from_wg_format(mt, &format, false))
+        format->u.audio.format = WG_AUDIO_FORMAT_S16LE;
+        if (!amt_from_wg_format(mt, format, false))
             return E_OUTOFMEMORY;
         return S_OK;
     }
@@ -1710,6 +1705,17 @@ static HRESULT decodebin_parser_source_get_media_type(struct parser_source *pin,
     return VFW_S_NO_MORE_ITEMS;
 }
 
+static HRESULT decodebin_parser_source_get_media_type(struct parser_source *pin,
+        unsigned int index, AM_MEDIA_TYPE *mt)
+{
+    struct wg_format format;
+
+    TRACE("pin %p, index %d, mt %p.\n", pin, (int)index, mt);
+
+    wg_parser_stream_get_current_format(pin->wg_stream, &format);
+    return get_raw_media_type(&format, index, mt);
+}
+
 static HRESULT parser_create(BOOL output_compressed, struct parser **parser)
 {
     struct parser *object;
@@ -2286,6 +2292,8 @@ static HRESULT wave_parser_source_query_accept(struct parser_source *pin, const
     HRESULT hr;
 
     wg_parser_stream_get_current_format(pin->wg_stream, &format);
+    if (format.major_type == WG_MAJOR_TYPE_VIDEO || format.major_type == WG_MAJOR_TYPE_AUDIO)
+        return amt_to_wg_format(mt, &format) ? S_OK : S_FALSE;
     if (!amt_from_wg_format(&pad_mt, &format, false))
         return E_OUTOFMEMORY;
     hr = compare_media_types(mt, &pad_mt) ? S_OK : S_FALSE;
@@ -2298,9 +2306,11 @@ static HRESULT wave_parser_source_get_media_type(struct parser_source *pin,
 {
     struct wg_format format;
 
+    wg_parser_stream_get_current_format(pin->wg_stream, &format);
+    if (format.major_type == WG_MAJOR_TYPE_VIDEO || format.major_type == WG_MAJOR_TYPE_AUDIO)
+        return get_raw_media_type(&format, index, mt);
     if (index > 0)
         return VFW_S_NO_MORE_ITEMS;
-    wg_parser_stream_get_current_format(pin->wg_stream, &format);
     if (!amt_from_wg_format(mt, &format, false))
         return E_OUTOFMEMORY;
     return S_OK;
@@ -2367,6 +2377,8 @@ static HRESULT avi_splitter_source_query_accept(struct parser_source *pin, const
     HRESULT hr;
 
     wg_parser_stream_get_current_format(pin->wg_stream, &format);
+    if (format.major_type == WG_MAJOR_TYPE_VIDEO || format.major_type == WG_MAJOR_TYPE_AUDIO)
+        return amt_to_wg_format(mt, &format) ? S_OK : S_FALSE;
     if (!amt_from_wg_format(&pad_mt, &format, false))
         return E_OUTOFMEMORY;
     hr = compare_media_types(mt, &pad_mt) ? S_OK : S_FALSE;
@@ -2379,9 +2391,11 @@ static HRESULT avi_splitter_source_get_media_type(struct parser_source *pin,
 {
     struct wg_format format;
 
+    wg_parser_stream_get_current_format(pin->wg_stream, &format);
+    if (format.major_type == WG_MAJOR_TYPE_VIDEO || format.major_type == WG_MAJOR_TYPE_AUDIO)
+        return get_raw_media_type(&format, index, mt);
     if (index > 0)
         return VFW_S_NO_MORE_ITEMS;
-    wg_parser_stream_get_current_format(pin->wg_stream, &format);
     if (!amt_from_wg_format(mt, &format, false))
         return E_OUTOFMEMORY;
     return S_OK;
@@ -2506,6 +2520,8 @@ static HRESULT mpeg_splitter_source_query_accept(struct parser_source *pin, cons
     HRESULT hr;
 
     wg_parser_stream_get_current_format(pin->wg_stream, &format);
+    if (format.major_type == WG_MAJOR_TYPE_VIDEO || format.major_type == WG_MAJOR_TYPE_AUDIO)
+        return amt_to_wg_format(mt, &format) ? S_OK : S_FALSE;
     if (!amt_from_wg_format(&pad_mt, &format, false))
         return E_OUTOFMEMORY;
     hr = compare_media_types(mt, &pad_mt) ? S_OK : S_FALSE;
@@ -2518,9 +2534,11 @@ static HRESULT mpeg_splitter_source_get_media_type(struct parser_source *pin,
 {
     struct wg_format format;
 
+    wg_parser_stream_get_current_format(pin->wg_stream, &format);
+    if (format.major_type == WG_MAJOR_TYPE_VIDEO || format.major_type == WG_MAJOR_TYPE_AUDIO)
+        return get_raw_media_type(&format, index, mt);
     if (index > 0)
         return VFW_S_NO_MORE_ITEMS;
-    wg_parser_stream_get_current_format(pin->wg_stream, &format);
     if (!amt_from_wg_format(mt, &format, false))
         return E_OUTOFMEMORY;
     return S_OK;
-- 
2.49.0

From c1ee57e3d787485733ced1b16faef88de8616120 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 27 Jan 2025 15:31:41 +0100
Subject: [PATCH 1088/1564] winegstreamer/media-converter: Try mediaconv even
 if compressed output is requested.

CW-Bug-Id: #24739
---
 dlls/winegstreamer/wg_parser.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index 9bf7b5ecd28..c4156dc891d 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -1581,7 +1581,7 @@ static GstBusSyncReply bus_handler_cb(GstBus *bus, GstMessage *msg, gpointer use
         if (gst_structure_has_name(structure, "missing-plugin"))
         {
             pthread_mutex_lock(&parser->mutex);
-            if (!parser->use_mediaconv && !parser->output_compressed)
+            if (!parser->use_mediaconv)
             {
                 GST_WARNING("Autoplugged element failed to initialise, trying again with protonvideoconvert.");
                 parser->error = true;
@@ -1818,7 +1818,7 @@ static NTSTATUS wg_parser_connect(void *args)
 
     if (ret == GST_STATE_CHANGE_FAILURE)
     {
-        if (!parser->use_mediaconv && !parser->output_compressed)
+        if (!parser->use_mediaconv)
         {
             GST_WARNING("Failed to play media, trying again with protonvideoconvert.");
             use_mediaconv = true;
@@ -1834,7 +1834,7 @@ static NTSTATUS wg_parser_connect(void *args)
         pthread_cond_wait(&parser->init_cond, &parser->mutex);
     if (parser->error)
     {
-        if (!parser->use_mediaconv && !parser->output_compressed)
+        if (!parser->use_mediaconv)
             use_mediaconv = true;
         pthread_mutex_unlock(&parser->mutex);
         goto out;
-- 
2.49.0

From 67633822442396fe8239c389e175fe2cc217ba17 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 29 Jan 2025 16:22:29 +0100
Subject: [PATCH 1089/1564] winegstreamer/video_decoder: Support VP9 format
 decoding.

CW-Bug-Id: #24789
---
 dlls/winegstreamer/video_decoder.c |  1 +
 dlls/winegstreamer/wg_media_type.c | 10 ++++++++++
 2 files changed, 11 insertions(+)

diff --git a/dlls/winegstreamer/video_decoder.c b/dlls/winegstreamer/video_decoder.c
index 3a2deafe685..3d51c2f6300 100644
--- a/dlls/winegstreamer/video_decoder.c
+++ b/dlls/winegstreamer/video_decoder.c
@@ -1728,6 +1728,7 @@ static const GUID *const wmv_decoder_input_types[] =
     &MEDIASUBTYPE_VC1S,
     &MFVideoFormat_theora,
     &MFVideoFormat_AV1,
+    &MFVideoFormat_VP90,
 };
 static const GUID *const wmv_decoder_output_types[] =
 {
diff --git a/dlls/winegstreamer/wg_media_type.c b/dlls/winegstreamer/wg_media_type.c
index 7038a9ed0e1..eeb5b19bcb4 100644
--- a/dlls/winegstreamer/wg_media_type.c
+++ b/dlls/winegstreamer/wg_media_type.c
@@ -391,6 +391,14 @@ static void init_caps_from_video_av1(GstCaps *caps, const MFVIDEOFORMAT *format,
     gst_structure_set_name(gst_caps_get_structure(caps, 0), "video/x-av1");
 }
 
+static void init_caps_from_video_vp9(GstCaps *caps, const MFVIDEOFORMAT *format, UINT format_size)
+{
+    init_caps_codec_data(caps, format + 1, format_size - sizeof(*format));
+
+    gst_structure_remove_field(gst_caps_get_structure(caps, 0), "format");
+    gst_structure_set_name(gst_caps_get_structure(caps, 0), "video/x-vp9");
+}
+
 static void init_caps_from_video_subtype(GstCaps *caps, const GUID *subtype, const void *format, UINT format_size)
 {
     if (IsEqualGUID(subtype, &MFVideoFormat_CVID))
@@ -415,6 +423,8 @@ static void init_caps_from_video_subtype(GstCaps *caps, const GUID *subtype, con
         return init_caps_from_video_theora(caps, format, format_size);
     if (IsEqualGUID(subtype, &MFVideoFormat_AV1))
         return init_caps_from_video_av1(caps, format, format_size);
+    if (IsEqualGUID(subtype, &MFVideoFormat_VP90))
+        return init_caps_from_video_vp9(caps, format, format_size);
 
     GST_FIXME("Unsupported subtype " WG_GUID_FORMAT, WG_GUID_ARGS(*subtype));
 }
-- 
2.49.0

From 510248b9ee6dfaba0324a0af9efb1fc908ba46a3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 10 Feb 2025 21:21:48 +0100
Subject: [PATCH 1114/1564] mfreadwrite/reader: Fixup MFVideoFormat_IYUV format
 to NV12 when enumerating decoders.

CW-Bug-Id: #24770
---
 dlls/mfreadwrite/reader.c | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/dlls/mfreadwrite/reader.c b/dlls/mfreadwrite/reader.c
index f98c98b91d8..e7e92647ca3 100644
--- a/dlls/mfreadwrite/reader.c
+++ b/dlls/mfreadwrite/reader.c
@@ -1956,6 +1956,15 @@ static HRESULT source_reader_create_transform(struct source_reader *reader, BOOL
         out_type.guidSubtype = MFVideoFormat_RGB32;
     }
 
+    if (IsEqualGUID(&out_type.guidMajorType, &MFMediaType_Video) && IsEqualGUID(&out_type.guidSubtype, &MFVideoFormat_IYUV)
+            && IsEqualGUID(&category, &MFT_CATEGORY_VIDEO_DECODER))
+    {
+        /* The WMV video decoder isn't registered for MFVideoFormat_IYUV, but selecting it as an output format still succeeds,
+         * the host decoders usually support IYUV as well, so fixup the subtype for MFTEnumEx.
+         */
+        WARN("Fixing up MFVideoFormat_IYUV subtype for the video processor\n");
+        out_type.guidSubtype = MFVideoFormat_NV12;
+    }
 
     count = 0;
     if (SUCCEEDED(hr = MFTEnumEx(category, 0, &in_type, allow_processor ? NULL : &out_type, &activates, &count)))
-- 
2.49.0

From 483fb8e9bae87ddd6edeca491047532719463dd2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 14 Feb 2025 15:19:25 +0100
Subject: [PATCH 1143/1564] HACK: winegstreamer/wm_reader: Return the stream
 format when faking compressed output.

CW-Bug-Id: #24875
CW-Bug-Id: #24876
CW-Bug-Id: #24884
---
 dlls/winegstreamer/wm_reader.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winegstreamer/wm_reader.c b/dlls/winegstreamer/wm_reader.c
index 0e634265f77..d60a160380e 100644
--- a/dlls/winegstreamer/wm_reader.c
+++ b/dlls/winegstreamer/wm_reader.c
@@ -555,7 +555,7 @@ static HRESULT WINAPI stream_props_GetMediaType(IWMMediaProps *iface, WM_MEDIA_T
     TRACE("iface %p, mt %p, size %p.\n", iface, mt, size);
 
     wg_parser_stream_get_codec_format(config->stream->wg_stream, &codec_format);
-    format = (codec_format.major_type != WG_MAJOR_TYPE_UNKNOWN) ? &codec_format : &config->stream->format;
+    format = (codec_format.major_type != WG_MAJOR_TYPE_UNKNOWN && config->stream->demux_compressed) ? &codec_format : &config->stream->format;
     if (!amt_from_wg_format(&stream_mt, format, true))
         return E_OUTOFMEMORY;
 
-- 
2.49.0

From 84f7deda2a99aeb42e83b01f3e367123e57ed76d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 14 Feb 2025 15:20:18 +0100
Subject: [PATCH 1144/1564] HACK: winegstreamer/wm_reader: Fake RGB32 output
 for more games.

CW-Bug-Id: #24875
CW-Bug-Id: #24876
CW-Bug-Id: #24884
---
 dlls/winegstreamer/wm_reader.c | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/dlls/winegstreamer/wm_reader.c b/dlls/winegstreamer/wm_reader.c
index d60a160380e..6973f519cef 100644
--- a/dlls/winegstreamer/wm_reader.c
+++ b/dlls/winegstreamer/wm_reader.c
@@ -1544,8 +1544,13 @@ static HRESULT init_stream(struct wm_reader *reader)
 
                 const char *id = getenv("SteamGameId");
 
-                if (id && !strcmp(id, "1113000"))
+                if (id && (0
+                    || !strcmp(id, "1113000")
+                    || !strcmp(id, "638160")
+                    ))
+                {
                     stream->format.u.video.format = WG_VIDEO_FORMAT_BGRx;
+                }
             }
         }
         wg_parser_stream_enable(stream->wg_stream, &stream->format);
-- 
2.49.0

From 44e0aa093a5c5c8f3074fcf36aba1be44428ecbb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 14 Feb 2025 19:04:34 +0100
Subject: [PATCH 1147/1564] mfsrcsnk: Ignore streams with unsupported media
 types.

CW-Bug-Id: #24803
---
 dlls/mfsrcsnk/media_source.c | 14 ++++++++------
 1 file changed, 8 insertions(+), 6 deletions(-)

diff --git a/dlls/mfsrcsnk/media_source.c b/dlls/mfsrcsnk/media_source.c
index 138cb29b705..a5ec3beba81 100644
--- a/dlls/mfsrcsnk/media_source.c
+++ b/dlls/mfsrcsnk/media_source.c
@@ -1497,10 +1497,12 @@ static void media_source_init_stream_map(struct media_source *source, UINT strea
 
     if (wcscmp(source->mime_type, L"video/mp4"))
     {
-        for (i = stream_count - 1; i >= 0; i--)
+        for (i = 0; i < stream_count; i++)
         {
-            TRACE("mapping source %p stream %u to demuxer stream %u\n", source, i, i);
-            source->stream_map[i] = i;
+            if (FAILED(get_stream_media_type(source->winedmo_demuxer, i, &major, NULL)))
+                continue;
+            TRACE("mapping source %p stream %u to demuxer stream %u\n", source, n, i);
+            source->stream_map[n++] = i;
         }
         return;
     }
@@ -1592,11 +1594,11 @@ static void media_source_init_descriptors(struct media_source *source)
         NTSTATUS status;
         GUID major;
 
-        if (FAILED(status = winedmo_demuxer_stream_lang(source->winedmo_demuxer, source->stream_map[i], buffer, ARRAY_SIZE(buffer)))
+        if ((status = winedmo_demuxer_stream_lang(source->winedmo_demuxer, source->stream_map[i], buffer, ARRAY_SIZE(buffer)))
                 || (!wcscmp(source->mime_type, L"video/mp4") && FAILED(normalize_mp4_language_code(source, buffer)))
                 || FAILED(IMFStreamDescriptor_SetString(stream->descriptor, &MF_SD_LANGUAGE, buffer)))
             WARN("Failed to set stream descriptor language, status %#lx\n", status);
-        if (FAILED(status = winedmo_demuxer_stream_name(source->winedmo_demuxer, source->stream_map[i], buffer, ARRAY_SIZE(buffer)))
+        if ((status = winedmo_demuxer_stream_name(source->winedmo_demuxer, source->stream_map[i], buffer, ARRAY_SIZE(buffer)))
                 || FAILED(IMFStreamDescriptor_SetString(stream->descriptor, &MF_SD_STREAM_NAME, buffer)))
             WARN("Failed to set stream descriptor name, status %#lx\n", status);
 
@@ -1734,7 +1736,7 @@ static HRESULT media_source_async_create(struct media_source *source, IMFAsyncRe
         GUID major;
 
         if (FAILED(hr = get_stream_media_type(source->winedmo_demuxer, source->stream_map[i], &major, &media_type)))
-            goto done;
+            continue;
         if (SUCCEEDED(hr = stream_descriptor_create(i + 1, media_type, &descriptor)))
         {
             if (SUCCEEDED(hr = media_stream_create(&source->IMFMediaSource_iface, descriptor, &source->streams[i])))
-- 
2.49.0

From b29ed5cf083c854d23ebf7b42a3cbf2ec08787b9 Mon Sep 17 00:00:00 2001
From: Brendan McGrath <bmcgrath@codeweavers.com>
Date: Tue, 18 Feb 2025 17:19:16 +1100
Subject: [PATCH 1153/1564] mfreadwrite: HACK: Force use of Processor when
 requesting RGB32.

The WMV video decoder doesn't supply MFVideoFormat_RGB32 directly on Windows.
It will output NV12 and a processor converts this to MFVideoFormat_RGB32.
This also ensures the image is the correct way up.

CW-Bug-Id: #24869
---
 dlls/mfreadwrite/reader.c | 16 +++++++++++++---
 1 file changed, 13 insertions(+), 3 deletions(-)

diff --git a/dlls/mfreadwrite/reader.c b/dlls/mfreadwrite/reader.c
index e7e92647ca3..8055f52305c 100644
--- a/dlls/mfreadwrite/reader.c
+++ b/dlls/mfreadwrite/reader.c
@@ -1907,6 +1907,7 @@ static HRESULT source_reader_create_transform(struct source_reader *reader, BOOL
     GUID category;
     IMFTransform *transform;
     UINT i, count;
+    BOOL force_processor = FALSE;
     HRESULT hr;
 
     if (FAILED(hr = IMFMediaType_GetMajorType(input_type, &in_type.guidMajorType))
@@ -1946,6 +1947,16 @@ static HRESULT source_reader_create_transform(struct source_reader *reader, BOOL
             entry->min_buffer_size = max(entry->min_buffer_size, bytes_per_second);
     }
 
+    if (IsEqualGUID(&in_type.guidMajorType, &MFMediaType_Video) && IsEqualGUID(&in_type.guidSubtype, &MFVideoFormat_VP90)
+            && IsEqualGUID(&out_type.guidSubtype, &MFVideoFormat_RGB32) && allow_processor
+            && IsEqualGUID(&category, &MFT_CATEGORY_VIDEO_DECODER))
+    {
+        /* The WMV video decoder doesn't supply MFVideoFormat_RGB32 directly on Windows. It will output NV12 and a processor converts
+         * this to MFVideoFormat_RGB32. This also ensures the image is the correct way up.
+         */
+        force_processor = TRUE;
+    }
+
     if (IsEqualGUID(&out_type.guidMajorType, &MFMediaType_Video) && IsEqualGUID(&out_type.guidSubtype, &MFVideoFormat_ABGR32)
             && IsEqualGUID(&category, &MFT_CATEGORY_VIDEO_PROCESSOR))
     {
@@ -1965,7 +1976,6 @@ static HRESULT source_reader_create_transform(struct source_reader *reader, BOOL
         WARN("Fixing up MFVideoFormat_IYUV subtype for the video processor\n");
         out_type.guidSubtype = MFVideoFormat_NV12;
     }
-
     count = 0;
     if (SUCCEEDED(hr = MFTEnumEx(category, 0, &in_type, allow_processor ? NULL : &out_type, &activates, &count)))
     {
@@ -2008,8 +2018,8 @@ static HRESULT source_reader_create_transform(struct source_reader *reader, BOOL
                     && SUCCEEDED(hr = IMFTransform_GetInputCurrentType(transform, 0, &media_type)))
             {
                 if (SUCCEEDED(hr = update_media_type_from_upstream(output_type, media_type))
-                        && FAILED(hr = IMFTransform_SetOutputType(transform, 0, output_type, 0))
-                        && FAILED(hr = set_matching_transform_output_type(transform, output_type)) && allow_processor
+                        && (force_processor || (FAILED(hr = IMFTransform_SetOutputType(transform, 0, output_type, 0))
+                        && FAILED(hr = set_matching_transform_output_type(transform, output_type)) && allow_processor))
                         && SUCCEEDED(hr = IMFTransform_GetOutputAvailableType(transform, 0, 0, &media_type)))
                 {
                     struct transform_entry *converter;
-- 
2.49.0

From c616a8499191c2fe1a268acf2f4de1e7f440f0dd Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 18 Feb 2025 09:28:19 +0100
Subject: [PATCH 1154/1564] HACK: winegstreamer: Set GST_GL_WINDOW environment
 variable.

CW-Bug-Id: #24900
---
 dlls/winegstreamer/unixlib.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/winegstreamer/unixlib.c b/dlls/winegstreamer/unixlib.c
index a82ebd6461b..95d732da631 100644
--- a/dlls/winegstreamer/unixlib.c
+++ b/dlls/winegstreamer/unixlib.c
@@ -278,6 +278,7 @@ NTSTATUS wg_init_gstreamer(void *arg)
     if (params->err_on)
         setenv("GST_DEBUG", "1", FALSE);
     setenv("GST_DEBUG_NO_COLOR", "1", FALSE);
+    setenv("GST_GL_WINDOW", "x11", 1);
 
     /* GStreamer installs a temporary SEGV handler when it loads plugins
      * to initialize its registry calling exit(-1) when any fault is caught.
-- 
2.49.0

From f67089c10513e976fc2c1d1586f456dfa62933cb Mon Sep 17 00:00:00 2001
From: Brendan McGrath <bmcgrath@codeweavers.com>
Date: Wed, 19 Feb 2025 18:58:06 +1100
Subject: [PATCH 1155/1564] Revert "mfreadwrite: HACK: Force use of Processor
 when requesting RGB32."

This reverts commit ff2db8bae620edcc621c4f6d486a619a72593051.
---
 dlls/mfreadwrite/reader.c | 16 +++-------------
 1 file changed, 3 insertions(+), 13 deletions(-)

diff --git a/dlls/mfreadwrite/reader.c b/dlls/mfreadwrite/reader.c
index 8055f52305c..e7e92647ca3 100644
--- a/dlls/mfreadwrite/reader.c
+++ b/dlls/mfreadwrite/reader.c
@@ -1907,7 +1907,6 @@ static HRESULT source_reader_create_transform(struct source_reader *reader, BOOL
     GUID category;
     IMFTransform *transform;
     UINT i, count;
-    BOOL force_processor = FALSE;
     HRESULT hr;
 
     if (FAILED(hr = IMFMediaType_GetMajorType(input_type, &in_type.guidMajorType))
@@ -1947,16 +1946,6 @@ static HRESULT source_reader_create_transform(struct source_reader *reader, BOOL
             entry->min_buffer_size = max(entry->min_buffer_size, bytes_per_second);
     }
 
-    if (IsEqualGUID(&in_type.guidMajorType, &MFMediaType_Video) && IsEqualGUID(&in_type.guidSubtype, &MFVideoFormat_VP90)
-            && IsEqualGUID(&out_type.guidSubtype, &MFVideoFormat_RGB32) && allow_processor
-            && IsEqualGUID(&category, &MFT_CATEGORY_VIDEO_DECODER))
-    {
-        /* The WMV video decoder doesn't supply MFVideoFormat_RGB32 directly on Windows. It will output NV12 and a processor converts
-         * this to MFVideoFormat_RGB32. This also ensures the image is the correct way up.
-         */
-        force_processor = TRUE;
-    }
-
     if (IsEqualGUID(&out_type.guidMajorType, &MFMediaType_Video) && IsEqualGUID(&out_type.guidSubtype, &MFVideoFormat_ABGR32)
             && IsEqualGUID(&category, &MFT_CATEGORY_VIDEO_PROCESSOR))
     {
@@ -1976,6 +1965,7 @@ static HRESULT source_reader_create_transform(struct source_reader *reader, BOOL
         WARN("Fixing up MFVideoFormat_IYUV subtype for the video processor\n");
         out_type.guidSubtype = MFVideoFormat_NV12;
     }
+
     count = 0;
     if (SUCCEEDED(hr = MFTEnumEx(category, 0, &in_type, allow_processor ? NULL : &out_type, &activates, &count)))
     {
@@ -2018,8 +2008,8 @@ static HRESULT source_reader_create_transform(struct source_reader *reader, BOOL
                     && SUCCEEDED(hr = IMFTransform_GetInputCurrentType(transform, 0, &media_type)))
             {
                 if (SUCCEEDED(hr = update_media_type_from_upstream(output_type, media_type))
-                        && (force_processor || (FAILED(hr = IMFTransform_SetOutputType(transform, 0, output_type, 0))
-                        && FAILED(hr = set_matching_transform_output_type(transform, output_type)) && allow_processor))
+                        && FAILED(hr = IMFTransform_SetOutputType(transform, 0, output_type, 0))
+                        && FAILED(hr = set_matching_transform_output_type(transform, output_type)) && allow_processor
                         && SUCCEEDED(hr = IMFTransform_GetOutputAvailableType(transform, 0, 0, &media_type)))
                 {
                     struct transform_entry *converter;
-- 
2.49.0

From 63d24077a61e4052af36df69ad1344942179700e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 20 Feb 2025 16:17:41 +0100
Subject: [PATCH 1158/1564] winegstreamer/wma_decoder: Return S_FALSE when more
 input is needed.

CW-Bug-Id: #21303
CW-Bug-Id: #21304
CW-Bug-Id: #23630
CW-Bug-Id: #24374
CW-Bug-Id: #24857
---
 dlls/winegstreamer/wma_decoder.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/winegstreamer/wma_decoder.c b/dlls/winegstreamer/wma_decoder.c
index ccde829e988..cdf879d1119 100644
--- a/dlls/winegstreamer/wma_decoder.c
+++ b/dlls/winegstreamer/wma_decoder.c
@@ -976,6 +976,8 @@ static HRESULT WINAPI media_object_ProcessOutput(IMediaObject *iface, DWORD flag
         wg_sample_queue_flush(decoder->wg_sample_queue, false);
     }
 
+    if (hr == MF_E_TRANSFORM_NEED_MORE_INPUT)
+        return S_FALSE;
     return hr;
 }
 
-- 
2.49.0

From 5f8be66743d0b095d4ad4df76e3b9130edfa3065 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 20 Feb 2025 16:17:41 +0100
Subject: [PATCH 1159/1564] winegstreamer/video_decoder: Return S_FALSE when
 more input is needed.

CW-Bug-Id: #21303
CW-Bug-Id: #21304
CW-Bug-Id: #23630
CW-Bug-Id: #24374
CW-Bug-Id: #24857
---
 dlls/winegstreamer/video_decoder.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/winegstreamer/video_decoder.c b/dlls/winegstreamer/video_decoder.c
index dfea084fbc7..90a367c667b 100644
--- a/dlls/winegstreamer/video_decoder.c
+++ b/dlls/winegstreamer/video_decoder.c
@@ -1469,6 +1469,8 @@ static HRESULT WINAPI media_object_ProcessOutput(IMediaObject *iface, DWORD flag
     if (SUCCEEDED(hr))
         wg_sample_queue_flush(decoder->wg_sample_queue, false);
 
+    if (hr == MF_E_TRANSFORM_NEED_MORE_INPUT)
+        return S_FALSE;
     return hr;
 }
 
-- 
2.49.0

From 283e68121a5521dfa5709427c73f831f2ecfe45c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 20 Feb 2025 14:45:13 +0100
Subject: [PATCH 1161/1564] HACK: winegstreamer/wm_reader: Disable OpenGL
 pipeline for KiriKiri games.

CW-Bug-Id: #21303
CW-Bug-Id: #21304
CW-Bug-Id: #23630
CW-Bug-Id: #24374
CW-Bug-Id: #24857
---
 dlls/winegstreamer/wm_reader.c | 30 ++++++++++++++++++++++++++++--
 1 file changed, 28 insertions(+), 2 deletions(-)

diff --git a/dlls/winegstreamer/wm_reader.c b/dlls/winegstreamer/wm_reader.c
index 6973f519cef..a7c312576ea 100644
--- a/dlls/winegstreamer/wm_reader.c
+++ b/dlls/winegstreamer/wm_reader.c
@@ -1470,14 +1470,27 @@ static void destroy_stream(struct wm_reader *reader)
 
 static HRESULT init_stream(struct wm_reader *reader)
 {
+    BOOL enable_opengl = sizeof(void *) == 4;
     wg_parser_t wg_parser;
     HRESULT hr;
     WORD i;
 
+{
+    const char *sgi = getenv("SteamGameId");
+    if (sgi && (0
+        || !strcmp(sgi, "802870")
+        || !strcmp(sgi, "1083650")
+        || !strcmp(sgi, "1097880")
+        || !strcmp(sgi, "1230140")
+        || !strcmp(sgi, "2515070")
+    ))
+    enable_opengl = FALSE;
+}
+
     /* 32-bit GStreamer ORC cannot efficiently convert I420 to RGBA, use OpenGL converter
      * in that case but keep the usual codepath otherwise.
      */
-    if (!(wg_parser = wg_parser_create(FALSE, sizeof(void *) == 4)))
+    if (!(wg_parser = wg_parser_create(FALSE, enable_opengl)))
         return E_OUTOFMEMORY;
 
     reader->wg_parser = wg_parser;
@@ -1583,10 +1596,23 @@ out_destroy_parser:
 
 static HRESULT reinit_stream(struct wm_reader *reader, bool read_compressed)
 {
+    BOOL enable_opengl = sizeof(void *) == 4 && !read_compressed;
     wg_parser_t wg_parser;
     HRESULT hr;
     WORD i;
 
+{
+    const char *sgi = getenv("SteamGameId");
+    if (sgi && (0
+        || !strcmp(sgi, "802870")
+        || !strcmp(sgi, "1083650")
+        || !strcmp(sgi, "1097880")
+        || !strcmp(sgi, "1230140")
+        || !strcmp(sgi, "2515070")
+    ))
+    enable_opengl = FALSE;
+}
+
     ReleaseSemaphore(reader->read_sem, 1, NULL);
     wg_parser_disconnect(reader->wg_parser);
 
@@ -1600,7 +1626,7 @@ static HRESULT reinit_stream(struct wm_reader *reader, bool read_compressed)
     wg_parser_destroy(reader->wg_parser);
     reader->wg_parser = 0;
 
-    if (!(wg_parser = wg_parser_create(read_compressed, sizeof(void *) == 4 && !read_compressed)))
+    if (!(wg_parser = wg_parser_create(read_compressed, enable_opengl)))
         return E_OUTOFMEMORY;
 
     reader->wg_parser = wg_parser;
-- 
2.49.0

From 07c1d94d9a4fa212e01a867d81cc41dde84242eb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 20 Feb 2025 14:45:13 +0100
Subject: [PATCH 1162/1564] HACK: winegstreamer/wm_reader: Read compressed
 samples for KiriKiri games.

CW-Bug-Id: #21303
CW-Bug-Id: #21304
CW-Bug-Id: #23630
CW-Bug-Id: #24374
CW-Bug-Id: #24857
---
 dlls/winegstreamer/wm_reader.c | 10 +++++++++-
 1 file changed, 9 insertions(+), 1 deletion(-)

diff --git a/dlls/winegstreamer/wm_reader.c b/dlls/winegstreamer/wm_reader.c
index a7c312576ea..4c2e276499b 100644
--- a/dlls/winegstreamer/wm_reader.c
+++ b/dlls/winegstreamer/wm_reader.c
@@ -2548,7 +2548,15 @@ static HRESULT WINAPI reader_SetReadStreamSamples(IWMSyncReader2 *iface, WORD st
 
     {
         const char *sgi = getenv("SteamGameId");
-        if (sgi && !strcmp(sgi, "638160")) compressed = FALSE;
+        if (sgi && (0
+            || !strcmp(sgi, "638160")
+            || !strcmp(sgi, "802870")
+            || !strcmp(sgi, "1083650")
+            || !strcmp(sgi, "1097880")
+            || !strcmp(sgi, "1230140")
+            || !strcmp(sgi, "2515070")
+            ))
+            compressed = FALSE;
     }
 
     if (stream->demux_compressed != compressed)
-- 
2.49.0

From 828e2bc9f443ea8a397a3db3f2d05ee79cbb4cd2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 20 Feb 2025 14:45:13 +0100
Subject: [PATCH 1163/1564] HACK: winegstreamer/wm_reader: Fake compressed
 output formats for KiriKiri games.

CW-Bug-Id: #21303
CW-Bug-Id: #21304
CW-Bug-Id: #23630
CW-Bug-Id: #24374
CW-Bug-Id: #24857
---
 dlls/winegstreamer/wm_reader.c | 39 ++++++++++++++++++++++++++++++++++
 1 file changed, 39 insertions(+)

diff --git a/dlls/winegstreamer/wm_reader.c b/dlls/winegstreamer/wm_reader.c
index 4c2e276499b..9145f59f474 100644
--- a/dlls/winegstreamer/wm_reader.c
+++ b/dlls/winegstreamer/wm_reader.c
@@ -556,6 +556,45 @@ static HRESULT WINAPI stream_props_GetMediaType(IWMMediaProps *iface, WM_MEDIA_T
 
     wg_parser_stream_get_codec_format(config->stream->wg_stream, &codec_format);
     format = (codec_format.major_type != WG_MAJOR_TYPE_UNKNOWN && config->stream->demux_compressed) ? &codec_format : &config->stream->format;
+
+{
+    const char *sgi = getenv("SteamGameId");
+    if (format->major_type == WG_MAJOR_TYPE_VIDEO && sgi && (0
+        || !strcmp(sgi, "802870")
+        || !strcmp(sgi, "1083650")
+        || !strcmp(sgi, "1097880")
+        || !strcmp(sgi, "1230140")
+    ))
+    {
+        codec_format = config->stream->format;
+        codec_format.major_type = WG_MAJOR_TYPE_VIDEO_WMV;
+        codec_format.u.video.format = WG_VIDEO_FORMAT_WMV3;
+        codec_format.u.video.height = abs(codec_format.u.video.height);
+        format = &codec_format;
+    }
+    if (format->major_type == WG_MAJOR_TYPE_VIDEO && sgi && (0
+        || !strcmp(sgi, "2515070")
+    ))
+    {
+        codec_format = config->stream->format;
+        codec_format.major_type = WG_MAJOR_TYPE_VIDEO_WMV;
+        codec_format.u.video.format = WG_VIDEO_FORMAT_WVC1;
+        codec_format.u.video.height = abs(codec_format.u.video.height);
+        format = &codec_format;
+    }
+    if (format->major_type == WG_MAJOR_TYPE_AUDIO && sgi && (0
+        || !strcmp(sgi, "802870")
+        || !strcmp(sgi, "1230140")
+        || !strcmp(sgi, "2515070")
+    ))
+    {
+        codec_format = config->stream->format;
+        codec_format.major_type = WG_MAJOR_TYPE_AUDIO_WMA;
+        codec_format.u.audio.version = 2;
+        format = &codec_format;
+    }
+}
+
     if (!amt_from_wg_format(&stream_mt, format, true))
         return E_OUTOFMEMORY;
 
-- 
2.49.0

From d81e4c61f7363479aaa335aa0c3fa2163079d84e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 20 Feb 2025 15:09:01 +0100
Subject: [PATCH 1164/1564] HACK: winegstreamer/video_decoder: Fake decoder
 input format for KiriKiri games.

CW-Bug-Id: #21303
CW-Bug-Id: #21304
CW-Bug-Id: #23630
CW-Bug-Id: #24374
CW-Bug-Id: #24857
---
 dlls/winegstreamer/video_decoder.c | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/dlls/winegstreamer/video_decoder.c b/dlls/winegstreamer/video_decoder.c
index 90a367c667b..879e4d391a0 100644
--- a/dlls/winegstreamer/video_decoder.c
+++ b/dlls/winegstreamer/video_decoder.c
@@ -1261,6 +1261,22 @@ static HRESULT WINAPI media_object_SetInputType(IMediaObject *iface, DWORD index
         decoder->wg_transform = 0;
     }
 
+{
+    const char *sgi = getenv("SteamGameId");
+    if (sgi && (0
+        || !strcmp(sgi, "802870")
+        || !strcmp(sgi, "1083650")
+        || !strcmp(sgi, "1097880")
+        || !strcmp(sgi, "1230140")
+        || !strcmp(sgi, "2515070")
+    ))
+    {
+        VIDEOINFOHEADER *vih = (VIDEOINFOHEADER *)decoder->dmo_input_type.pbFormat;
+        decoder->dmo_input_type.subtype = MFVideoFormat_RGB24;
+        vih->bmiHeader.biCompression = BI_RGB;
+    }
+}
+
     return S_OK;
 }
 
-- 
2.49.0

From b34d1eb260123c817e2a89b4223f50122d8047d4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 20 Feb 2025 16:18:19 +0100
Subject: [PATCH 1165/1564] HACK: winegstreamer/wma_decoder: Fake decoder input
 format for KiriKiri games.

CW-Bug-Id: #21303
CW-Bug-Id: #21304
CW-Bug-Id: #23630
CW-Bug-Id: #24374
CW-Bug-Id: #24857
---
 dlls/winegstreamer/wma_decoder.c | 15 +++++++++++++++
 1 file changed, 15 insertions(+)

diff --git a/dlls/winegstreamer/wma_decoder.c b/dlls/winegstreamer/wma_decoder.c
index cdf879d1119..e7f073cd83e 100644
--- a/dlls/winegstreamer/wma_decoder.c
+++ b/dlls/winegstreamer/wma_decoder.c
@@ -762,6 +762,21 @@ static HRESULT WINAPI media_object_SetInputType(IMediaObject *iface, DWORD index
         decoder->wg_transform = 0;
     }
 
+{
+    const char *sgi = getenv("SteamGameId");
+    if (sgi && (0
+        || !strcmp(sgi, "802870")
+        || !strcmp(sgi, "1230140")
+        || !strcmp(sgi, "2515070")
+    ))
+    {
+        WAVEFORMATEX *wfx = (WAVEFORMATEX *)decoder->input_type.pbFormat;
+        decoder->input_type.subtype = MFAudioFormat_PCM;
+        wfx->wFormatTag = WAVE_FORMAT_PCM;
+        wfx->wBitsPerSample = 16;
+    }
+}
+
     return S_OK;
 }
 
-- 
2.49.0

From bb2d2cd12e8c123b86da42d8073a333d22a270f7 Mon Sep 17 00:00:00 2001
From: Conor McCarthy <cmccarthy@codeweavers.com>
Date: Tue, 4 Mar 2025 17:39:20 +1000
Subject: [PATCH 1269/1564] mfplat: Do not zero-init memory buffers.

This takes significant time for videos with a large frame size, which
can delay audio sampling enough to cause samples to be dropped.

CW-Bug-Id: #24914
---
 dlls/mfplat/buffer.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/dlls/mfplat/buffer.c b/dlls/mfplat/buffer.c
index f3eb7f9222e..76894d31175 100644
--- a/dlls/mfplat/buffer.c
+++ b/dlls/mfplat/buffer.c
@@ -1353,7 +1353,6 @@ static HRESULT memory_buffer_init(struct buffer *buffer, DWORD max_length, DWORD
 
     if (!(buffer->data = _aligned_malloc(max_length, alignment)))
         return E_OUTOFMEMORY;
-    memset(buffer->data, 0, max_length);
 
     buffer->IMFMediaBuffer_iface.lpVtbl = vtbl;
     buffer->refcount = 1;
-- 
2.49.0

From 36212c14da315c1c1db997320a65ef4da2d7860a Mon Sep 17 00:00:00 2001
From: Conor McCarthy <cmccarthy@codeweavers.com>
Date: Mon, 3 Mar 2025 12:21:21 +1000
Subject: [PATCH 1399/1564] mf: Move transform node reset to a helper function.

---
 dlls/mf/session.c | 32 +++++++++++++++++++-------------
 1 file changed, 19 insertions(+), 13 deletions(-)

diff --git a/dlls/mf/session.c b/dlls/mf/session.c
index 62efa0d75f9..eee3952ed04 100644
--- a/dlls/mf/session.c
+++ b/dlls/mf/session.c
@@ -1068,13 +1068,29 @@ static void session_handle_start_error(struct media_session *session, HRESULT hr
     session_command_complete_with_event(session, MESessionStarted, hr, NULL);
 }
 
+static void session_reset_transforms(struct media_session *session)
+{
+    struct topo_node *topo_node;
+    UINT i;
+
+    LIST_FOR_EACH_ENTRY(topo_node, &session->presentation.nodes, struct topo_node, entry)
+    {
+        if (topo_node->type != MF_TOPOLOGY_TRANSFORM_NODE)
+            continue;
+
+        for (i = 0; i < topo_node->u.transform.input_count; i++)
+        {
+            struct transform_stream *stream = &topo_node->u.transform.inputs[i];
+            stream->draining = FALSE;
+        }
+    }
+}
+
 static void session_start(struct media_session *session, const GUID *time_format, const PROPVARIANT *start_position)
 {
     struct media_source *source;
-    struct topo_node *topo_node;
     MFTIME duration;
     HRESULT hr;
-    UINT i;
 
     switch (session->state)
     {
@@ -1110,17 +1126,7 @@ static void session_start(struct media_session *session, const GUID *time_format
                 }
             }
 
-            LIST_FOR_EACH_ENTRY(topo_node, &session->presentation.nodes, struct topo_node, entry)
-            {
-                if (topo_node->type == MF_TOPOLOGY_TRANSFORM_NODE)
-                {
-                    for (i = 0; i < topo_node->u.transform.input_count; i++)
-                    {
-                        struct transform_stream *stream = &topo_node->u.transform.inputs[i];
-                        stream->draining = FALSE;
-                    }
-                }
-            }
+            session_reset_transforms(session);
 
             session->state = SESSION_STATE_STARTING_SOURCES;
             break;
-- 
2.49.0

From 33c085fc923f2e8b6d6184beadec32e359fe270f Mon Sep 17 00:00:00 2001
From: Conor McCarthy <cmccarthy@codeweavers.com>
Date: Mon, 31 Mar 2025 23:54:27 +1000
Subject: [PATCH 1400/1564] mf: Reset transforms before restarting a paused
 source instead of after.

---
 dlls/mf/session.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/mf/session.c b/dlls/mf/session.c
index eee3952ed04..485e28a4158 100644
--- a/dlls/mf/session.c
+++ b/dlls/mf/session.c
@@ -1116,6 +1116,8 @@ static void session_start(struct media_session *session, const GUID *time_format
                 return;
             }
 
+            session_reset_transforms(session);
+
             LIST_FOR_EACH_ENTRY(source, &session->presentation.sources, struct media_source, entry)
             {
                 if (FAILED(hr = IMFMediaSource_Start(source->source, source->pd, &GUID_NULL, start_position)))
@@ -1126,8 +1128,6 @@ static void session_start(struct media_session *session, const GUID *time_format
                 }
             }
 
-            session_reset_transforms(session);
-
             session->state = SESSION_STATE_STARTING_SOURCES;
             break;
         case SESSION_STATE_STARTED:
-- 
2.49.0

From 6839fa7a1c7f7fb96ec73afc2dce0d42deca94f6 Mon Sep 17 00:00:00 2001
From: Conor McCarthy <cmccarthy@codeweavers.com>
Date: Mon, 31 Mar 2025 23:56:29 +1000
Subject: [PATCH 1401/1564] mf: Drop transform node input events when unpausing
 at a specific position.

The start position is empty when starting at the current position from
the paused state, but if it is not empty, this is a seek operation.

CW-Bug-Id: #24657
---
 dlls/mf/session.c | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/dlls/mf/session.c b/dlls/mf/session.c
index 485e28a4158..b8febde4ad2 100644
--- a/dlls/mf/session.c
+++ b/dlls/mf/session.c
@@ -1068,7 +1068,7 @@ static void session_handle_start_error(struct media_session *session, HRESULT hr
     session_command_complete_with_event(session, MESessionStarted, hr, NULL);
 }
 
-static void session_reset_transforms(struct media_session *session)
+static void session_reset_transforms(struct media_session *session, BOOL drop)
 {
     struct topo_node *topo_node;
     UINT i;
@@ -1082,6 +1082,8 @@ static void session_reset_transforms(struct media_session *session)
         {
             struct transform_stream *stream = &topo_node->u.transform.inputs[i];
             stream->draining = FALSE;
+            if (drop)
+                transform_stream_drop_events(stream);
         }
     }
 }
@@ -1089,6 +1091,7 @@ static void session_reset_transforms(struct media_session *session)
 static void session_start(struct media_session *session, const GUID *time_format, const PROPVARIANT *start_position)
 {
     struct media_source *source;
+    BOOL unpause_seek;
     MFTIME duration;
     HRESULT hr;
 
@@ -1116,7 +1119,8 @@ static void session_start(struct media_session *session, const GUID *time_format
                 return;
             }
 
-            session_reset_transforms(session);
+            unpause_seek = start_position->vt == VT_I8;
+            session_reset_transforms(session, unpause_seek);
 
             LIST_FOR_EACH_ENTRY(source, &session->presentation.sources, struct media_source, entry)
             {
-- 
2.49.0

From 162dea9e492688651387759607ea81ec73753e25 Mon Sep 17 00:00:00 2001
From: Conor McCarthy <cmccarthy@codeweavers.com>
Date: Mon, 31 Mar 2025 23:57:10 +1000
Subject: [PATCH 1402/1564] mf: Flush nodes before restarting a paused source
 at a specific position.

Behaviour in Windows is to send MFT_MESSAGE_COMMAND_FLUSH before calling
Start() on the source.
---
 dlls/mf/session.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/mf/session.c b/dlls/mf/session.c
index b8febde4ad2..bf87ed49e6c 100644
--- a/dlls/mf/session.c
+++ b/dlls/mf/session.c
@@ -1120,6 +1120,8 @@ static void session_start(struct media_session *session, const GUID *time_format
             }
 
             unpause_seek = start_position->vt == VT_I8;
+            if (unpause_seek)
+                session_flush_nodes(session);
             session_reset_transforms(session, unpause_seek);
 
             LIST_FOR_EACH_ENTRY(source, &session->presentation.sources, struct media_source, entry)
-- 
2.49.0

From d32da138a806bad4350bdcc4eb4e4e79476d61c7 Mon Sep 17 00:00:00 2001
From: Conor McCarthy <cmccarthy@codeweavers.com>
Date: Mon, 3 Mar 2025 12:27:18 +1000
Subject: [PATCH 1403/1564] mf: Reset transform node outputs when seeking.

CW-Bug-Id: #24657
---
 dlls/mf/session.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/dlls/mf/session.c b/dlls/mf/session.c
index bf87ed49e6c..3059762b917 100644
--- a/dlls/mf/session.c
+++ b/dlls/mf/session.c
@@ -1085,6 +1085,16 @@ static void session_reset_transforms(struct media_session *session, BOOL drop)
             if (drop)
                 transform_stream_drop_events(stream);
         }
+
+        if (!drop)
+            continue;
+
+        for (i = 0; i < topo_node->u.transform.output_count; ++i)
+        {
+            struct transform_stream *stream = &topo_node->u.transform.outputs[i];
+            transform_stream_drop_events(stream);
+            stream->requests = 0;
+        }
     }
 }
 
-- 
2.49.0

From 63944eaab571600c4da06f41502cc038e44cc618 Mon Sep 17 00:00:00 2001
From: Conor McCarthy <cmccarthy@codeweavers.com>
Date: Fri, 28 Feb 2025 14:03:34 +1000
Subject: [PATCH 1404/1564] mf: Initialise the grabber sample count when
 setting state after a seek.

If sample_count is zero in this case, we end up with no samples being
requested.
---
 dlls/mf/samplegrabber.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/dlls/mf/samplegrabber.c b/dlls/mf/samplegrabber.c
index de599139736..4d54afc1d31 100644
--- a/dlls/mf/samplegrabber.c
+++ b/dlls/mf/samplegrabber.c
@@ -1195,6 +1195,10 @@ static HRESULT sample_grabber_set_state(struct sample_grabber *grabber, enum sin
 
             if (state == SINK_STATE_RUNNING && grabber->state != SINK_STATE_RUNNING)
             {
+                /* Unpause at a position is a seek operation which drops everything pending. */
+                if (grabber->state == SINK_STATE_PAUSED && offset != PRESENTATION_CURRENT_POSITION)
+                    grabber->sample_count = MAX_SAMPLE_QUEUE_LENGTH;
+
                 /* Every transition to running state sends a bunch requests to build up initial queue. */
                 for (i = 0; i < grabber->sample_count; ++i)
                 {
-- 
2.49.0

From b11d349b90dbbdffa73fc6451146729a38a3e23c Mon Sep 17 00:00:00 2001
From: Conor McCarthy <cmccarthy@codeweavers.com>
Date: Fri, 28 Feb 2025 14:08:49 +1000
Subject: [PATCH 1405/1564] mf: Reset transform nodes when seeking.

---
 dlls/mf/session.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/mf/session.c b/dlls/mf/session.c
index 3059762b917..3f4eb4f5489 100644
--- a/dlls/mf/session.c
+++ b/dlls/mf/session.c
@@ -1171,6 +1171,8 @@ static void session_start(struct media_session *session, const GUID *time_format
                 }
             }
 
+            session_reset_transforms(session, TRUE);
+
             session->presentation.time_format = *time_format;
             session->presentation.start_position.vt = VT_EMPTY;
             PropVariantCopy(&session->presentation.start_position, start_position);
-- 
2.49.0

From 308361547e0e4bcb63fcbc1530ea244e86f7a7ed Mon Sep 17 00:00:00 2001
From: Brendan McGrath <bmcgrath@codeweavers.com>
Date: Mon, 23 Sep 2024 15:30:04 +1000
Subject: [PATCH 1411/1564] winegstreamer: HACK: Use last scanline for bottom
 padding.

This mirrors what the Windows H.264 decoder does with a DXGI manager.

CW-Bug-Id: #24253
---
 dlls/winegstreamer/wg_transform.c | 33 +++++++++++++++++++++++++++++--
 1 file changed, 31 insertions(+), 2 deletions(-)

diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
index b8797ad327f..db72bd4d55a 100644
--- a/dlls/winegstreamer/wg_transform.c
+++ b/dlls/winegstreamer/wg_transform.c
@@ -1075,12 +1075,38 @@
     return needs_copy;
 }
 
+static void fill_frame_padded_bits(GstBuffer *buffer, const GstVideoAlignment *align, const GstVideoInfo *info)
+{
+    guint i, plane, padded_height, height, stride, padding = align->padding_bottom;
+    GstVideoFrame frame;
+
+    if (!padding || !gst_video_frame_map(&frame, info, buffer, GST_MAP_WRITE)) return;
+
+    /* Windows uses the data in the last scanline for its bottom padding */
+    for (plane = 0; plane < GST_VIDEO_FRAME_N_PLANES(&frame); plane++)
+    {
+        guint8 *data = GST_VIDEO_FRAME_PLANE_DATA(&frame, plane);
+        gint comp[GST_VIDEO_MAX_COMPONENTS];
+
+        gst_video_format_info_component(frame.info.finfo, plane, comp);
+        padded_height = GST_VIDEO_FORMAT_INFO_SCALE_HEIGHT(frame.info.finfo, comp[0], info->height + padding);
+        height = GST_VIDEO_FRAME_COMP_HEIGHT(&frame, comp[0]);
+        stride = GST_VIDEO_FRAME_PLANE_STRIDE(&frame, plane);
+        data += height * stride;
+
+        for (i = 0; i < padded_height - height; i++) memcpy(data + i * stride, data - stride, stride);
+    }
+
+    gst_video_frame_unmap(&frame);
+}
+
 static NTSTATUS read_transform_output_video(struct wg_sample *sample, GstBuffer *buffer,
-        GstVideoInfo *src_video_info, GstVideoInfo *dst_video_info)
+        const GstVideoInfo *src_video_info, const GstVideoInfo *dst_video_info, const GstVideoAlignment *align)
 {
     gsize total_size;
     NTSTATUS status;
     bool needs_copy;
+    const char *sgi;
 
     if (!(needs_copy = sample_needs_buffer_copy(sample, buffer, &total_size)))
         status = STATUS_SUCCESS;
@@ -1094,6 +1120,9 @@ static NTSTATUS read_transform_output_video(struct wg_sample *sample, GstBuffer
         return status;
     }
 
+    if ((sgi = getenv("SteamGameId")) && !strcmp(sgi, "1449280"))
+        fill_frame_padded_bits(buffer, align, dst_video_info);
+
     set_sample_flags_from_buffer(sample, buffer, total_size);
 
     if (needs_copy)
@@ -1252,7 +1281,7 @@ NTSTATUS wg_transform_read_data(void *args)
 
     if (!strcmp(output_mime, "video/x-raw"))
         status = read_transform_output_video(sample, output_buffer,
-                &src_video_info, &dst_video_info);
+                &src_video_info, &dst_video_info, &align);
     else
         status = read_transform_output(sample, output_buffer);
 
-- 
2.49.0

From 27b71460604f0f90ac2189ea8b5d6dc00e820529 Mon Sep 17 00:00:00 2001
From: Charlotte Pabst <cpabst@codeweavers.com>
Date: Tue, 8 Apr 2025 23:30:58 +0200
Subject: [PATCH 1421/1564] mfplat: Set current buffer length in
 copy_2d_buffer.

---
 dlls/mfplat/sample.c | 13 ++++++++-----
 1 file changed, 8 insertions(+), 5 deletions(-)

diff --git a/dlls/mfplat/sample.c b/dlls/mfplat/sample.c
index 4b9151b56b2..60d78dc8bf0 100644
--- a/dlls/mfplat/sample.c
+++ b/dlls/mfplat/sample.c
@@ -791,17 +791,16 @@ static HRESULT WINAPI sample_GetTotalLength(IMFSample *iface, DWORD *total_lengt
     return S_OK;
 }
 
-static HRESULT copy_2d_buffer_from_contiguous(IMFMediaBuffer *src, IMF2DBuffer *dst)
+static HRESULT copy_2d_buffer_from_contiguous(IMFMediaBuffer *src, IMF2DBuffer *dst, DWORD *current_length)
 {
-    DWORD current_length;
     HRESULT hr, hr2;
     BYTE *ptr;
 
-    hr = IMFMediaBuffer_Lock(src, &ptr, NULL, &current_length);
+    hr = IMFMediaBuffer_Lock(src, &ptr, NULL, current_length);
 
     if (SUCCEEDED(hr))
     {
-        hr = IMF2DBuffer_ContiguousCopyFrom(dst, ptr, current_length);
+        hr = IMF2DBuffer_ContiguousCopyFrom(dst, ptr, *current_length);
 
         hr2 = IMFMediaBuffer_Unlock(src);
         if (FAILED(hr2))
@@ -818,6 +817,7 @@ static HRESULT copy_2d_buffer(IMFMediaBuffer *src, IMFMediaBuffer *dst)
     IMF2DBuffer2 *src2d2 = NULL, *dst2d2 = NULL;
     IMF2DBuffer *dst2 = NULL;
     HRESULT hr;
+    DWORD current_length;
 
     hr = IMFMediaBuffer_QueryInterface(src, &IID_IMF2DBuffer2, (void **)&src2d2);
 
@@ -839,7 +839,10 @@ static HRESULT copy_2d_buffer(IMFMediaBuffer *src, IMFMediaBuffer *dst)
     hr = IMFMediaBuffer_QueryInterface(dst, &IID_IMF2DBuffer, (void **)&dst2);
 
     if (SUCCEEDED(hr))
-        hr = copy_2d_buffer_from_contiguous(src, dst2);
+        hr = copy_2d_buffer_from_contiguous(src, dst2, &current_length);
+
+    if (SUCCEEDED(hr))
+        IMFMediaBuffer_SetCurrentLength(dst, current_length);
 
     if (dst2)
         IMF2DBuffer_Release(dst2);
-- 
2.49.0

From 4e1fa716ba88a40a89aaad33dcac32dce0e28575 Mon Sep 17 00:00:00 2001
From: Charlotte Pabst <cpabst@codeweavers.com>
Date: Thu, 20 Mar 2025 01:07:12 +0100
Subject: [PATCH 1422/1564] winegstreamer: Add stub implementation for
 IMFVideoProcessorControl to video_processor.

CW-Bug-Id: #24703
---
 dlls/winegstreamer/video_processor.c | 80 ++++++++++++++++++++++++++++
 1 file changed, 80 insertions(+)

diff --git a/dlls/winegstreamer/video_processor.c b/dlls/winegstreamer/video_processor.c
index 5ecc736718b..6e107f0300e 100644
--- a/dlls/winegstreamer/video_processor.c
+++ b/dlls/winegstreamer/video_processor.c
@@ -93,6 +93,8 @@ struct video_processor
 
     IUnknown *device_manager;
     IMFVideoSampleAllocatorEx *allocator;
+
+    IMFVideoProcessorControl IMFVideoProcessorControl_iface;
 };
 
 static void update_video_aperture(MFVideoInfo *input_info, MFVideoInfo *output_info)
@@ -474,6 +476,8 @@ static HRESULT WINAPI video_processor_QueryInterface(IMFTransform *iface, REFIID
 
     if (IsEqualGUID(iid, &IID_IMFTransform))
         *out = &impl->IMFTransform_iface;
+    else if (IsEqualGUID(iid, &IID_IMFVideoProcessorControl))
+        *out = &impl->IMFVideoProcessorControl_iface;
     else
     {
         *out = NULL;
@@ -1036,6 +1040,81 @@ static const IMFTransformVtbl video_processor_vtbl =
     video_processor_ProcessOutput,
 };
 
+static struct video_processor *impl_from_IMFVideoProcessorControl(IMFVideoProcessorControl *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_processor, IMFVideoProcessorControl_iface);
+}
+
+static HRESULT WINAPI video_processor_control_QueryInterface(IMFVideoProcessorControl *iface, REFIID iid, void **out)
+{
+    return video_processor_QueryInterface(&impl_from_IMFVideoProcessorControl(iface)->IMFTransform_iface, iid, out);
+}
+
+static ULONG WINAPI video_processor_control_AddRef(IMFVideoProcessorControl *iface)
+{
+    return video_processor_AddRef(&impl_from_IMFVideoProcessorControl(iface)->IMFTransform_iface);
+}
+
+static ULONG WINAPI video_processor_control_Release(IMFVideoProcessorControl *iface)
+{
+    return video_processor_Release(&impl_from_IMFVideoProcessorControl(iface)->IMFTransform_iface);
+}
+
+static HRESULT WINAPI video_processor_control_SetBorderColor(IMFVideoProcessorControl *iface, MFARGB *color)
+{
+    FIXME("iface %p, color %p: stub.\n", iface, color);
+    //return E_NOTIMPL;
+    return S_OK;
+}
+
+static HRESULT WINAPI video_processor_control_SetSourceRectangle(IMFVideoProcessorControl *iface, RECT *rect)
+{
+    FIXME("iface %p, rect %p: stub.\n", iface, rect);
+    //return E_NOTIMPL;
+    return S_OK;
+}
+
+static HRESULT WINAPI video_processor_control_SetDestinationRectangle(IMFVideoProcessorControl *iface, RECT *rect)
+{
+    FIXME("iface %p, rect %p: stub.\n", iface, rect);
+    //return E_NOTIMPL;
+    return S_OK;
+}
+
+static HRESULT WINAPI video_processor_control_SetMirror(IMFVideoProcessorControl *iface, MF_VIDEO_PROCESSOR_MIRROR mirror)
+{
+    FIXME("iface %p, mirror %d: stub.\n", iface, mirror);
+    //return E_NOTIMPL;
+    return S_OK;
+}
+
+static HRESULT WINAPI video_processor_control_SetRotation(IMFVideoProcessorControl *iface, MF_VIDEO_PROCESSOR_ROTATION rotation)
+{
+    FIXME("iface %p, rotation %d: stub.\n", iface, rotation);
+    //return E_NOTIMPL;
+    return S_OK;
+}
+
+static HRESULT WINAPI video_processor_control_SetConstrictionSize(IMFVideoProcessorControl *iface, SIZE *size)
+{
+    FIXME("iface %p, size %p: stub.\n", iface, size);
+    //return E_NOTIMPL;
+    return S_OK;
+}
+
+static const IMFVideoProcessorControlVtbl video_processor_control_vtbl =
+{
+    video_processor_control_QueryInterface,
+    video_processor_control_AddRef,
+    video_processor_control_Release,
+    video_processor_control_SetBorderColor,
+    video_processor_control_SetSourceRectangle,
+    video_processor_control_SetDestinationRectangle,
+    video_processor_control_SetMirror,
+    video_processor_control_SetRotation,
+    video_processor_control_SetConstrictionSize,
+};
+
 HRESULT video_processor_create(REFIID riid, void **ret)
 {
     const MFVIDEOFORMAT input_format =
@@ -1077,6 +1156,7 @@ HRESULT video_processor_create(REFIID riid, void **ret)
         goto failed;
 
     impl->IMFTransform_iface.lpVtbl = &video_processor_vtbl;
+    impl->IMFVideoProcessorControl_iface.lpVtbl = &video_processor_control_vtbl;
     impl->refcount = 1;
 
     *ret = &impl->IMFTransform_iface;
-- 
2.49.0

From 7f51f01b15bd96defb2d0af880751fd9db36d23a Mon Sep 17 00:00:00 2001
From: Brendan McGrath <bmcgrath@codeweavers.com>
Date: Fri, 10 May 2024 15:57:19 +1000
Subject: [PATCH 1441/1564] winegstreamer: Don't send stream_start in PULL
 mode.

This fixes a deadlock that can occur when the stream-start is dropped
by the demuxer when it is in PULL mode.

CW-Bug-Id: #22403
---
 dlls/winegstreamer/media-converter/videoconv.c | 17 ++++++++++++++++-
 1 file changed, 16 insertions(+), 1 deletion(-)

diff --git a/dlls/winegstreamer/media-converter/videoconv.c b/dlls/winegstreamer/media-converter/videoconv.c
index d8b77e5e172..4fe0805db86 100644
--- a/dlls/winegstreamer/media-converter/videoconv.c
+++ b/dlls/winegstreamer/media-converter/videoconv.c
@@ -725,7 +725,9 @@ static gboolean video_conv_push_stream_start(VideoConv *conv, struct fozdb_hash
 {
     struct video_conv_state *state;
 
-    push_event(conv->src_pad, gst_event_new_stream_start(format_hash(hash)));
+    /* we don't send a stream-start in pull mode, as it can cause a deadlock */
+    if (conv->active_mode == GST_PAD_MODE_PUSH)
+        push_event(conv->src_pad, gst_event_new_stream_start(format_hash(hash)));
 
     if (!(state = video_conv_lock_state(conv)))
     {
@@ -1165,6 +1167,19 @@ static gboolean video_conv_src_query(GstPad *pad, GstObject *parent, GstQuery *q
         gst_query_set_duration(query, GST_FORMAT_BYTES, duration);
         return true;
 
+    case GST_QUERY_URI:
+        if (!gst_pad_query_default(pad, parent, query))
+        {
+            if (!(state = video_conv_lock_state(conv)))
+                return false;
+            /* if we don't already have a uri, we will use the hash. This is to ensure
+             * downstream will use a consistent stream-id */
+            gst_query_set_uri(query, format_hash(&state->transcode_hash));
+            pthread_mutex_unlock(&conv->state_mutex);
+            GST_LOG_OBJECT(pad, "Responding with %" GST_PTR_FORMAT, query);
+        }
+        return true;
+
     default:
         return gst_pad_query_default(pad, parent, query);
     }
-- 
2.49.0

From cb7895fc7c9fea450e5d5c8d3f85e857939db17e Mon Sep 17 00:00:00 2001
From: Brendan McGrath <bmcgrath@codeweavers.com>
Date: Mon, 2 Dec 2024 18:40:52 +1100
Subject: [PATCH 1449/1564] winegstreamer: Avoid pre-condition assertion
 failures.

Both gst_audio_info_from_caps and gst_video_info_from_caps perform
the following pre-condition assertion:
g_return_val_if_fail (gst_caps_is_fixed (caps), FALSE);

The documentation for this assertion states:
Any failure of such a pre-condition assertion is considered a
programming error on the part of the caller of the public API,
and the program is considered to be in an undefined state afterwards.
---
 dlls/winegstreamer/wg_format.c | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/dlls/winegstreamer/wg_format.c b/dlls/winegstreamer/wg_format.c
index afbc8eab137..70842d1ae9e 100644
--- a/dlls/winegstreamer/wg_format.c
+++ b/dlls/winegstreamer/wg_format.c
@@ -583,15 +583,19 @@ void wg_format_from_caps(struct wg_format *format, const GstCaps *caps)
     {
         GstAudioInfo info;
 
-        if (gst_audio_info_from_caps(&info, caps))
+        if (gst_caps_is_fixed(caps) && gst_audio_info_from_caps(&info, caps))
             wg_format_from_audio_info(format, &info);
+        else
+            GST_WARNING("Unable to get audio info from caps");
     }
     else if (!strcmp(name, "video/x-raw"))
     {
         GstVideoInfo info;
 
-        if (gst_video_info_from_caps(&info, caps))
+        if (gst_caps_is_fixed(caps) && gst_video_info_from_caps(&info, caps))
             wg_format_from_video_info(format, &info);
+        else
+            GST_WARNING("Unable to get video info from caps");
     }
     else if (!strcmp(name, "audio/mpeg") && gst_structure_get_boolean(structure, "parsed", &parsed) && parsed)
     {
-- 
2.49.0

From 311e5298724574f36270f7b25e035d7e6311f15c Mon Sep 17 00:00:00 2001
From: Brendan McGrath <bmcgrath@codeweavers.com>
Date: Wed, 30 Apr 2025 11:18:40 +1000
Subject: [PATCH 1503/1564] mfmediaengine: Check we have a frame_sink before
 access.

This fixes a crash that occurs when the media has no video (either because
it is audio only, or because there was an error decoding the video).

CW-Bug-Id: #25294
---
 dlls/mfmediaengine/main.c | 41 +++++++++++++++++++++------------------
 1 file changed, 22 insertions(+), 19 deletions(-)

diff --git a/dlls/mfmediaengine/main.c b/dlls/mfmediaengine/main.c
index 5b6c762ca48..d7d3383ab00 100644
--- a/dlls/mfmediaengine/main.c
+++ b/dlls/mfmediaengine/main.c
@@ -821,31 +821,34 @@ static void media_engine_get_frame_size(struct media_engine *engine)
     engine->video_frame.ratio.cx = 1;
     engine->video_frame.ratio.cy = 1;
 
-    video_frame_sink_query_iface(engine->presentation.frame_sink, &IID_IMFMediaTypeHandler, (void**)&handler);
-    if (SUCCEEDED(IMFMediaTypeHandler_GetCurrentMediaType(handler, &media_type)))
+    if (engine->presentation.frame_sink &&
+                SUCCEEDED(video_frame_sink_query_iface(engine->presentation.frame_sink, &IID_IMFMediaTypeHandler, (void**)&handler)))
     {
-        UINT64 size;
-        HRESULT hr = IMFMediaType_GetUINT64(media_type, &MF_MT_FRAME_SIZE, &size);
-        if (SUCCEEDED(hr))
+        if (SUCCEEDED(IMFMediaTypeHandler_GetCurrentMediaType(handler, &media_type)))
         {
-            unsigned int gcd;
-            engine->video_frame.size.cx = size >> 32;
-            engine->video_frame.size.cy = size;
-
-            if ((gcd = get_gcd(engine->video_frame.size.cx, engine->video_frame.size.cy)))
+            UINT64 size;
+            HRESULT hr = IMFMediaType_GetUINT64(media_type, &MF_MT_FRAME_SIZE, &size);
+            if (SUCCEEDED(hr))
             {
-                engine->video_frame.ratio.cx = engine->video_frame.size.cx / gcd;
-                engine->video_frame.ratio.cy = engine->video_frame.size.cy / gcd;
+                unsigned int gcd;
+                engine->video_frame.size.cx = size >> 32;
+                engine->video_frame.size.cy = size;
+
+                if ((gcd = get_gcd(engine->video_frame.size.cx, engine->video_frame.size.cy)))
+                {
+                    engine->video_frame.ratio.cx = engine->video_frame.size.cx / gcd;
+                    engine->video_frame.ratio.cy = engine->video_frame.size.cy / gcd;
+                }
+            }
+            else
+            {
+                WARN("Failed to get frame size %#lx.\n", hr);
             }
-        }
-        else
-        {
-            WARN("Failed to get frame size %#lx.\n", hr);
-        }
 
-        IMFMediaType_Release(media_type);
+            IMFMediaType_Release(media_type);
+        }
+        IMFMediaTypeHandler_Release(handler);
     }
-    IMFMediaTypeHandler_Release(handler);
 }
 
 static void media_engine_apply_volume(const struct media_engine *engine)
-- 
2.49.0

From 5f215d48d123cf49aa49daaf5755ab7d08699982 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty
 <45927311+Etaash-mathamsetty@users.noreply.github.com>
Date: Sun, 4 May 2025 14:13:08 -0400
Subject: [PATCH] use surfaceless for GST

---
 dlls/winegstreamer/unixlib.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/dlls/winegstreamer/unixlib.c b/dlls/winegstreamer/unixlib.c
index 0d1b3b6f65a..cd631535b50 100644
--- a/dlls/winegstreamer/unixlib.c
+++ b/dlls/winegstreamer/unixlib.c
@@ -278,7 +278,6 @@ NTSTATUS wg_init_gstreamer(void *arg)
     if (params->err_on)
         setenv("GST_DEBUG", "1", FALSE);
     setenv("GST_DEBUG_NO_COLOR", "1", FALSE);
-    setenv("GST_GL_WINDOW", "x11", 1);
 
     /* GStreamer installs a temporary SEGV handler when it loads plugins
      * to initialize its registry calling exit(-1) when any fault is caught.
@@ -322,7 +321,7 @@ NTSTATUS wg_init_gstreamer(void *arg)
     GST_INFO("GStreamer library version %s; wine built with %d.%d.%d.",
             gst_version_string(), GST_VERSION_MAJOR, GST_VERSION_MINOR, GST_VERSION_MICRO);
 
-    if (!(gl_display = gst_gl_display_new()))
+    if (!(gl_display = gst_gl_display_new_with_type(GST_GL_DISPLAY_TYPE_EGL_SURFACELESS)))
         GST_ERROR("Failed to create OpenGL display");
     else
     {
-- 
2.49.0


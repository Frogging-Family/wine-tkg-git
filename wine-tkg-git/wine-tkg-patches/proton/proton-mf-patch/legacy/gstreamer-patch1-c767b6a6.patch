From 160a200105244206f1f7d5a6bf69c676b5a9d57f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 21 Nov 2023 18:42:14 +0100
Subject: [PATCH 0188/1564] HACK: winegstreamer/wma_decoder: Support XMAudio2
 input format in WMA decoder.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=51931
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52391
CW-Bug-Id: #16839
CW-Bug-Id: #18678
CW-Bug-Id: #19362

Wine-Staging: mfplat-streaming-support

CW-Bug-Id: #20833
---
 dlls/winegstreamer/mfplat.c        | 11 ++++++++++-
 dlls/winegstreamer/quartz_parser.c | 14 ++++++++++++--
 dlls/winegstreamer/unixlib.h       |  1 +
 dlls/winegstreamer/wg_format.c     | 18 ++++++++++++++----
 dlls/winegstreamer/wma_decoder.c   |  3 +++
 5 files changed, 40 insertions(+), 7 deletions(-)

diff --git a/dlls/winegstreamer/mfplat.c b/dlls/winegstreamer/mfplat.c
index fd2c6995d8c..7e332b29eb2 100644
--- a/dlls/winegstreamer/mfplat.c
+++ b/dlls/winegstreamer/mfplat.c
@@ -39,6 +39,7 @@ DEFINE_GUID(DMOVideoFormat_RGB565,D3DFMT_R5G6B5,0x524f,0x11ce,0x9f,0x53,0x00,0x2
 DEFINE_GUID(DMOVideoFormat_RGB555,D3DFMT_X1R5G5B5,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
 DEFINE_GUID(DMOVideoFormat_RGB8,D3DFMT_P8,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
 DEFINE_MEDIATYPE_GUID(MFAudioFormat_RAW_AAC,WAVE_FORMAT_RAW_AAC1);
+DEFINE_MEDIATYPE_GUID(MFAudioFormat_XMAudio2, 0x0166);
 DEFINE_MEDIATYPE_GUID(MFVideoFormat_VC1S,MAKEFOURCC('V','C','1','S'));
 DEFINE_MEDIATYPE_GUID(MFVideoFormat_IV50,MAKEFOURCC('I','V','5','0'));
 DEFINE_MEDIATYPE_GUID(MFVideoFormat_ABGR32,D3DFMT_A8B8G8R8);
@@ -668,6 +669,7 @@ static void mf_media_type_to_wg_format_audio_wma(IMFMediaType *type, const GUID
 {
     UINT32 rate, depth, channels, block_align, bytes_per_second, codec_data_len;
     BYTE codec_data[64];
+    bool is_xma = false;
     UINT32 version;
 
     if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, &rate)))
@@ -709,6 +711,11 @@ static void mf_media_type_to_wg_format_audio_wma(IMFMediaType *type, const GUID
         version = 3;
     else if (IsEqualGUID(subtype, &MFAudioFormat_WMAudio_Lossless))
         version = 4;
+    else if (IsEqualGUID(subtype, &MFAudioFormat_XMAudio2))
+    {
+        version = 2;
+        is_xma = true;
+    }
     else
     {
         assert(0);
@@ -724,6 +731,7 @@ static void mf_media_type_to_wg_format_audio_wma(IMFMediaType *type, const GUID
     format->u.audio.block_align = block_align;
     format->u.audio.codec_data_len = codec_data_len;
     memcpy(format->u.audio.codec_data, codec_data, codec_data_len);
+    format->u.audio.is_xma = is_xma;
 }
 
 static void mf_media_type_to_wg_format_video_h264(IMFMediaType *type, struct wg_format *format)
@@ -880,7 +888,8 @@ void mf_media_type_to_wg_format(IMFMediaType *type, struct wg_format *format)
         else if (IsEqualGUID(&subtype, &MEDIASUBTYPE_MSAUDIO1) ||
                 IsEqualGUID(&subtype, &MFAudioFormat_WMAudioV8) ||
                 IsEqualGUID(&subtype, &MFAudioFormat_WMAudioV9) ||
-                IsEqualGUID(&subtype, &MFAudioFormat_WMAudio_Lossless))
+                IsEqualGUID(&subtype, &MFAudioFormat_WMAudio_Lossless) ||
+                IsEqualGUID(&subtype, &MFAudioFormat_XMAudio2))
             mf_media_type_to_wg_format_audio_wma(type, &subtype, format);
         else if (IsEqualGUID(&subtype, &MFAudioFormat_AAC) || IsEqualGUID(&subtype, &MFAudioFormat_RAW_AAC))
             mf_media_type_to_wg_format_audio_mpeg4(type, &subtype, format);
diff --git a/dlls/winegstreamer/quartz_parser.c b/dlls/winegstreamer/quartz_parser.c
index 19b104d55df..581ea3af8ab 100644
--- a/dlls/winegstreamer/quartz_parser.c
+++ b/dlls/winegstreamer/quartz_parser.c
@@ -41,6 +41,7 @@ static const GUID MEDIASUBTYPE_VC1S = {mmioFOURCC('V','C','1','S'), 0x0000, 0x00
 static const GUID MEDIASUBTYPE_MP3  = {WAVE_FORMAT_MPEGLAYER3, 0x0000, 0x0010, {0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}};
 static const GUID MEDIASUBTYPE_WMV_Unknown = {0x7ce12ca9, 0xbfbf, 0x43d9, {0x9d, 0x00, 0x82, 0xb8, 0xed, 0x54, 0x31, 0x6b}};
 DEFINE_GUID(MEDIASUBTYPE_ABGR32,D3DFMT_A8B8G8R8,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
+static const GUID MEDIASUBTYPE_XMAUDIO2 = {0x0166, 0x0000, 0x0010, {0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}};
 
 struct parser
 {
@@ -304,6 +305,11 @@ static bool amt_from_wg_format_audio_wma(AM_MEDIA_TYPE *mt, const struct wg_form
             subtype = &MEDIASUBTYPE_WMAUDIO2;
             codec_data_len = WMAUDIO2_WFX_EXTRA_BYTES;
             fmt_tag = WAVE_FORMAT_WMAUDIO2;
+            if (format->u.audio.is_xma)
+            {
+                subtype = &MEDIASUBTYPE_XMAUDIO2;
+                fmt_tag = 0x0166;
+            }
             break;
         case 3:
             subtype = &MEDIASUBTYPE_WMAUDIO3;
@@ -876,7 +882,8 @@ static bool amt_to_wg_format_audio_mpeg1_layer3(const AM_MEDIA_TYPE *mt, struct
     return true;
 }
 
-static bool amt_to_wg_format_audio_wma(const AM_MEDIA_TYPE *mt, struct wg_format *format)
+static bool amt_to_wg_format_audio_wma(const AM_MEDIA_TYPE *mt, struct wg_format *format,
+        bool is_xma)
 {
     const WAVEFORMATEX *audio_format = (const WAVEFORMATEX *)mt->pbFormat;
 
@@ -902,6 +909,7 @@ static bool amt_to_wg_format_audio_wma(const AM_MEDIA_TYPE *mt, struct wg_format
     else
         assert(false);
     format->major_type = WG_MAJOR_TYPE_AUDIO_WMA;
+    format->u.audio.is_xma = is_xma;
     format->u.audio.bitrate = audio_format->nAvgBytesPerSec * 8;
     format->u.audio.rate = audio_format->nSamplesPerSec;
     format->u.audio.depth = audio_format->wBitsPerSample;
@@ -1107,7 +1115,9 @@ bool amt_to_wg_format(const AM_MEDIA_TYPE *mt, struct wg_format *format)
                 || IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_WMAUDIO2)
                 || IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_WMAUDIO3)
                 || IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_WMAUDIO_LOSSLESS))
-            return amt_to_wg_format_audio_wma(mt, format);
+            return amt_to_wg_format_audio_wma(mt, format, false);
+        if (IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_XMAUDIO2))
+            return amt_to_wg_format_audio_wma(mt, format, true);
         return amt_to_wg_format_audio(mt, format);
     }
 
diff --git a/dlls/winegstreamer/unixlib.h b/dlls/winegstreamer/unixlib.h
index 19270bd731b..7e87fd56530 100644
--- a/dlls/winegstreamer/unixlib.h
+++ b/dlls/winegstreamer/unixlib.h
@@ -144,6 +144,7 @@ struct wg_format
             uint32_t payload_type;
             uint32_t codec_data_len;
             unsigned char codec_data[64];
+            UINT8 is_xma;
         } audio;
 
         /* Valid members for different video formats:
diff --git a/dlls/winegstreamer/wg_format.c b/dlls/winegstreamer/wg_format.c
index 12fee8c4923..fd8f99c256b 100644
--- a/dlls/winegstreamer/wg_format.c
+++ b/dlls/winegstreamer/wg_format.c
@@ -833,10 +833,20 @@ static GstCaps *wg_format_to_caps_audio_wma(const struct wg_format *format)
     GstBuffer *buffer;
     GstCaps *caps;
 
-    if (!(caps = gst_caps_new_empty_simple("audio/x-wma")))
-        return NULL;
-    if (format->u.audio.version)
-        gst_caps_set_simple(caps, "wmaversion", G_TYPE_INT, format->u.audio.version, NULL);
+    if (format->u.audio.is_xma)
+    {
+        if (!(caps = gst_caps_new_empty_simple("audio/x-xma")))
+            return NULL;
+        if (format->u.audio.version)
+            gst_caps_set_simple(caps, "xmaversion", G_TYPE_INT, format->u.audio.version, NULL);
+    }
+    else
+    {
+        if (!(caps = gst_caps_new_empty_simple("audio/x-wma")))
+            return NULL;
+        if (format->u.audio.version)
+            gst_caps_set_simple(caps, "wmaversion", G_TYPE_INT, format->u.audio.version, NULL);
+    }
 
     if (format->u.audio.bitrate)
         gst_caps_set_simple(caps, "bitrate", G_TYPE_INT, format->u.audio.bitrate, NULL);
diff --git a/dlls/winegstreamer/wma_decoder.c b/dlls/winegstreamer/wma_decoder.c
index 09b2ee647b3..6c1e5ed2ea8 100644
--- a/dlls/winegstreamer/wma_decoder.c
+++ b/dlls/winegstreamer/wma_decoder.c
@@ -32,12 +32,15 @@
 WINE_DEFAULT_DEBUG_CHANNEL(wmadec);
 WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
+extern const GUID MFAudioFormat_XMAudio2;
+
 static const GUID *const wma_decoder_input_types[] =
 {
     &MEDIASUBTYPE_MSAUDIO1,
     &MFAudioFormat_WMAudioV8,
     &MFAudioFormat_WMAudioV9,
     &MFAudioFormat_WMAudio_Lossless,
+    &MFAudioFormat_XMAudio2,
 };
 static const GUID *const wma_decoder_output_types[] =
 {
-- 
2.49.0

From 6dd9c6214278901e019d58e0c80ba0523176cc57 Mon Sep 17 00:00:00 2001
From: Ziqing Hui <zhui@codeweavers.com>
Date: Wed, 15 Nov 2023 11:43:21 +0800
Subject: [PATCH 0189/1564] winegstreamer: Integrate media-converter to
 winegstreamer.

CW-Bug-Id: #23225
---
 dlls/winegstreamer/Makefile.in                |    6 +
 .../winegstreamer/media-converter/audioconv.c | 1102 +++++++++++++++++
 .../media-converter/audioconvbin.c            |  148 +++
 .../winegstreamer/media-converter/fossilize.c |  722 +++++++++++
 dlls/winegstreamer/media-converter/lib.c      |  329 +++++
 .../media-converter/media-converter.h         |  290 +++++
 dlls/winegstreamer/media-converter/murmur3.c  |  371 ++++++
 .../winegstreamer/media-converter/videoconv.c |  938 ++++++++++++++
 dlls/winegstreamer/unixlib.c                  |    9 +
 9 files changed, 3915 insertions(+)
 create mode 100644 dlls/winegstreamer/media-converter/audioconv.c
 create mode 100644 dlls/winegstreamer/media-converter/audioconvbin.c
 create mode 100644 dlls/winegstreamer/media-converter/fossilize.c
 create mode 100644 dlls/winegstreamer/media-converter/lib.c
 create mode 100644 dlls/winegstreamer/media-converter/media-converter.h
 create mode 100644 dlls/winegstreamer/media-converter/murmur3.c
 create mode 100644 dlls/winegstreamer/media-converter/videoconv.c

diff --git a/dlls/winegstreamer/Makefile.in b/dlls/winegstreamer/Makefile.in
index 63ca3f61fdf..e2cc1123f10 100644
--- a/dlls/winegstreamer/Makefile.in
+++ b/dlls/winegstreamer/Makefile.in
@@ -10,6 +10,12 @@ SOURCES = \
 	aac_decoder.c \
 	color_convert.c \
 	main.c \
+	media-converter/audioconv.c \
+	media-converter/audioconvbin.c \
+	media-converter/fossilize.c \
+	media-converter/lib.c \
+	media-converter/murmur3.c \
+	media-converter/videoconv.c \
 	media_sink.c \
 	media_source.c \
 	mfplat.c \
diff --git a/dlls/winegstreamer/media-converter/audioconv.c b/dlls/winegstreamer/media-converter/audioconv.c
new file mode 100644
index 00000000000..71612cbfddd
--- /dev/null
+++ b/dlls/winegstreamer/media-converter/audioconv.c
@@ -0,0 +1,1102 @@
+/*
+ * Copyright 2024 Ziqing Hui for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+/* Algorithm
+ * ---------
+ *
+ * The application feeds encoded audio into XAudio2 in chunks. Since we don't have access to all
+ * chunks in a stream on initialization (as we do with the video converter), we continuously hash
+ * the stream as it is sent to us. Each "chunk" is identified as the hash of the entire stream up
+ * to that chunk.
+ *
+ * Since chunks are small (~2 kilobytes), this leads to a significant possibility of two different
+ * streams having identical intro chunks (imagine two streams that start with several seconds of
+ * silence). This means we need a tree of chunks. Suppose two incoming streams with chunks that
+ * hash as shown (i.e. identical intro chunks that diverge later):
+ *
+ * Stream 1: [AA BB CC DD]
+ *
+ * Stream 2: [AA BB YY ZZ]
+ *
+ * We record a tree and the transcoder will walk it depth-first in order to reconstruct each unique
+ * stream:
+ *
+ * AA => aa.ptna
+ * AA+BB => bb.ptna
+ * AA+BB+CC => cc.ptna
+ * AA+BB+CC+DD => dd.ptna
+ * AA+BB+YY => yy.ptna
+ * AA+BB+YY+ZZ => zz.ptna
+ *
+ * Upon playback, we chain each transcoded stream chunk together as the packets come in:
+ *
+ * AA -> start stream with aa.ptna
+ * BB -> play bb.ptna
+ * CC -> play cc.ptna
+ * DD -> play dd.ptna
+ *
+ * or:
+ *
+ * AA -> start stream with aa.ptna
+ * BB -> play bb.ptna
+ * YY -> play yy.ptna
+ * ZZ -> play zz.ptna
+ *
+ * or:
+ *
+ * AA -> start stream with aa.ptna
+ * NN -> not recognized, instead play blank.ptna and mark this stream as needs-transcoding
+ * OO -> play blank.ptna
+ * PP -> play blank.ptna
+ * When the Stream is destroyed, we'll record AA+NN+OO+PP into the needs-transcode database
+ * for the transcoder to convert later.
+ *
+ *
+ * Physical Format
+ * ---------------
+ *
+ * All stored values are little-endian.
+ *
+ * Transcoded audio is stored in the "transcoded" Fossilize database under the
+ * AUDIO_CONV_FOZ_TAG_PTNADATA tag. Each chunk is stored in one entry with as many of the following
+ * "Proton Audio" (ptna) packets as are required to store the entire transcoded chunk:
+ *
+ *     uint32_t packet_header: Information about the upcoming packet, see bitmask:
+ *        MSB [FFFF PPPP PPPP PPPP PPPP LLLL LLLL LLLL] LSB
+ *        L: Number of _bytes_ in this packet following this header.
+ *        P: Number of _samples_ at the end of this packet which are padding and should be skipped.
+ *        F: Flag bits:
+ *           0x1: This packet is an Opus header
+ *           0x2, 0x4, 0x8: Reserved for future use.
+ *
+ *     If the Opus header flag is set:
+ *        Following packet is an Opus identification header, as defined in RFC 7845 "Ogg
+ *        Encapsulation for the Opus Audio Codec" Section 5.1.
+ *        <https://tools.ietf.org/html/rfc7845#section-5.1>
+ *
+ *     If the header flag is not set:
+ *        Following packet is raw Opus data to be sent to an Opus decoder.
+ *
+ *
+ * If we encounter a stream which needs transcoding, we record the buffers and metadata in
+ * a Fossilize database. The database has three tag types:
+ *
+ * AUDIO_CONV_FOZ_TAG_STREAM: This identifies each unique stream of buffers. For example:
+ *   [hash(AA+BB+CC+DD)] -> [AA, BB, CC, DD]
+ *   [hash(AA+BB+XX+YY)] -> [AA, BB, XX, YY]
+ *
+ * AUDIO_CONV_FOZ_TAG_AUDIODATA: This contans the actual encoded audio data. For example:
+ *   [AA] -> [AA's buffer data]
+ *   [BB] -> [BB's buffer data]
+ *
+ * AUDIO_CONV_FOZ_TAG_CODECINFO: This contans the codec data required to decode the buffer. Only
+ * the "head" of each stream is recorded. For example:
+ *   [AA] -> [
+ *     uint32_t wmaversion                 (from WAVEFORMATEX.wFormatTag)
+ *     uint32_t bitrate                    (from WAVEFORMATEX.nAvgBytesPerSec)
+ *     uint32_t channels                   (WAVEFORMATEX.nChannels)
+ *     uint32_t rate                       (WAVEFORMATEX.nSamplesPerSec)
+ *     uint32_t block_align                (WAVEFORMATEX.nBlockAlign)
+ *     uint32_t depth                      (WAVEFORMATEX.wBitsPerSample)
+ *     char[remainder of entry] codec_data (codec data which follows WAVEFORMATEX)
+ *   ]
+ *
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "media-converter.h"
+
+#include <gst/audio/audio.h>
+#include <errno.h>
+#include <string.h>
+#include <assert.h>
+
+GST_DEBUG_CATEGORY_EXTERN(media_converter_debug);
+#undef GST_CAT_DEFAULT
+#define GST_CAT_DEFAULT media_converter_debug
+
+#define AUDIO_CONV_ENCODED_LENGTH_MASK  0x00000fff /* 4kB fits in here. */
+#define AUDIO_CONV_PADDING_LENGTH_MASK  0x0ffff000 /* 120ms of samples at 48kHz fits in here. */
+#define AUDIO_CONV_PADDING_LENGTH_SHIFT 12
+#define AUDIO_CONV_FLAG_MASK            0xf0000000
+#define AUDIO_CONV_FLAG_HEADER          0x10000000 /* This chunk is the Opus header. */
+#define _AUDIO_CONV_FLAG_RESERVED1      0x20000000 /* Not yet used */
+#define _AUDIO_CONV_FLAG_RESERVED2      0x40000000 /* Not yet used */
+#define _AUDIO_CONV_FLAG_V2             0x80000000 /* Indicates a "version 2" header, process somehow differently (TBD). */
+
+/* Properties of the "blank" audio file. */
+#define _BLANK_AUDIO_FILE_LENGTH_MS 10.0
+#define _BLANK_AUDIO_FILE_RATE      48000.0
+
+#define AUDIO_CONV_FOZ_TAG_STREAM    0
+#define AUDIO_CONV_FOZ_TAG_CODECINFO 1
+#define AUDIO_CONV_FOZ_TAG_AUDIODATA 2
+#define AUDIO_CONV_FOZ_TAG_PTNADATA  3
+#define AUDIO_CONV_FOZ_NUM_TAGS      4
+
+typedef enum
+{
+    NO_LOOP,
+    LOOPING,
+    LOOP_ENDED,
+    LOOP_ERROR,
+} loop_state;
+
+struct buffer_entry
+{
+    struct payload_hash hash;
+    GstBuffer *buffer;
+};
+
+/* Followed by codec_data_size bytes codec data. */
+struct need_transcode_head
+{
+    size_t codec_data_size;
+    uint32_t wmaversion;
+    uint32_t bitrate;
+    uint32_t channels;
+    uint32_t rate;
+    uint32_t block_align;
+    uint32_t depth;
+} __attribute__((packed));
+
+/* Represents a Stream, a sequence of buffers. */
+struct stream_state
+{
+    struct murmur3_128_state hash_state;
+    struct payload_hash current_hash;
+    GList *buffers;      /* Entry type: struct buffer_entry. */
+    GList *loop_buffers; /* Entry type: struct buffer_entry. */
+    struct need_transcode_head *codec_info;
+    bool needs_dump;
+};
+
+struct stream_state_serializer
+{
+    struct stream_state *state;
+    int index;
+};
+
+struct audio_conv_state
+{
+    bool sent_header;
+    struct need_transcode_head *codec_data;
+    struct murmur3_128_state hash_state;
+    struct murmur3_128_state loop_hash_state;
+    struct stream_state *stream_state;
+    struct fozdb *read_fozdb;
+};
+
+typedef struct
+{
+    GstElement element;
+    GstPad *sink_pad, *src_pad;
+    pthread_mutex_t state_mutex;
+    struct audio_conv_state *state;
+} AudioConv;
+
+typedef struct
+{
+    GstElementClass class;
+} AudioConvClass;
+
+G_DEFINE_TYPE(AudioConv, audio_conv, GST_TYPE_ELEMENT);
+#define AUDIO_CONV_TYPE (audio_conv_get_type())
+#define AUDIO_CONV(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), AUDIO_CONV_TYPE, AudioConv))
+#define parent_class    (audio_conv_parent_class)
+GST_ELEMENT_REGISTER_DEFINE(protonaudioconverter, "protonaudioconverter",
+        GST_RANK_MARGINAL, AUDIO_CONV_TYPE);
+
+static GstStaticPadTemplate audio_conv_sink_template = GST_STATIC_PAD_TEMPLATE("sink",
+        GST_PAD_SINK, GST_PAD_ALWAYS,
+        GST_STATIC_CAPS("audio/x-wma;"));
+
+static GstStaticPadTemplate audio_conv_src_template = GST_STATIC_PAD_TEMPLATE("src",
+        GST_PAD_SRC, GST_PAD_ALWAYS,
+        GST_STATIC_CAPS("audio/x-opus;"));
+
+static struct dump_fozdb dump_fozdb = {PTHREAD_MUTEX_INITIALIZER, NULL, false};
+
+static struct buffer_entry *buffer_entry_create(struct payload_hash *hash, GstBuffer *buffer)
+{
+    struct buffer_entry *entry = calloc(1, sizeof(*entry));
+    entry->hash = *hash;
+    entry->buffer = gst_buffer_ref(buffer);
+    return entry;
+}
+
+static void buffer_entry_release(void *arg)
+{
+    struct buffer_entry *entry = arg;
+    gst_buffer_unref(entry->buffer);
+    free(entry);
+}
+
+static bool dumping_disabled(void)
+{
+    return option_enabled("MEDIACONV_AUDIO_DONT_DUMP");
+}
+
+static bool hash_data(const uint8_t *data, size_t size, struct murmur3_128_state *hash_state, struct payload_hash *hash)
+{
+    struct bytes_reader reader;
+    bytes_reader_init(&reader, data, size);
+    return murmur3_128_full(&reader, bytes_reader_read, hash_state, hash);
+}
+
+static int dump_fozdb_open_audio(bool create)
+{
+    return dump_fozdb_open(&dump_fozdb, create, "MEDIACONV_AUDIO_DUMP_FILE", AUDIO_CONV_FOZ_NUM_TAGS);
+}
+
+static void dump_fozdb_discard_transcoded(void)
+{
+    GList *chunks_to_discard = NULL, *chunks_to_keep = NULL, *chunks = NULL, *list_iter;
+    struct payload_hash chunk_id, *stream_id;
+    struct fozdb *read_fozdb;
+    char *read_fozdb_path;
+    GHashTableIter iter;
+    int ret;
+
+    if (dump_fozdb.already_cleaned)
+        return;
+    dump_fozdb.already_cleaned = true;
+
+    if (discarding_disabled())
+        return;
+    if (!file_exists(getenv("MEDIACONV_AUDIO_DUMP_FILE")))
+        return;
+
+    if ((dump_fozdb_open_audio(false)) < 0)
+        return;
+
+    if (!(read_fozdb_path = getenv("MEDIACONV_AUDIO_TRANSCODED_FILE")))
+    {
+        GST_ERROR("Env MEDIACONV_AUDIO_TRANSCODED_FILE not set.");
+        return;
+    }
+
+    if ((ret = fozdb_create(read_fozdb_path, O_RDONLY, true /* Read-only?  */, AUDIO_CONV_FOZ_NUM_TAGS, &read_fozdb)) < 0)
+    {
+        GST_ERROR("Failed to create read fozdb, ret %d.", ret);
+        return;
+    }
+
+    fozdb_iter_tag(dump_fozdb.fozdb, AUDIO_CONV_FOZ_TAG_STREAM, &iter);
+    while (g_hash_table_iter_next(&iter, (void *)&stream_id, NULL))
+    {
+        uint32_t chunks_size, i;
+        size_t read_size;
+
+        if (fozdb_entry_size(dump_fozdb.fozdb, AUDIO_CONV_FOZ_TAG_STREAM, stream_id, &chunks_size) == CONV_OK)
+        {
+            uint8_t *buffer = calloc(1, chunks_size);
+            if (fozdb_read_entry_data(dump_fozdb.fozdb, AUDIO_CONV_FOZ_TAG_STREAM, stream_id,
+                    0, buffer, chunks_size, &read_size, true) == CONV_OK)
+            {
+                GList *stream_chunks = NULL;
+                bool has_all = true;
+
+                for (i = 0; i < read_size / sizeof(chunk_id); ++i)
+                {
+                    payload_hash_from_bytes(&chunk_id, buffer + i * sizeof(chunk_id));
+                    if (!fozdb_has_entry(read_fozdb, AUDIO_CONV_FOZ_TAG_PTNADATA, &chunk_id))
+                    {
+                        has_all = false;
+                        break;
+                    }
+                    stream_chunks = g_list_append(stream_chunks,
+                            entry_name_create(AUDIO_CONV_FOZ_TAG_AUDIODATA, &chunk_id));
+                }
+
+                for (list_iter = stream_chunks; list_iter; list_iter = list_iter->next)
+                {
+                    struct entry_name *entry = list_iter->data;
+                    if (has_all)
+                    {
+                        chunks_to_discard = g_list_append(chunks_to_discard,
+                                entry_name_create(entry->tag, &entry->hash));
+                        chunks_to_discard = g_list_append(chunks_to_discard,
+                                entry_name_create(AUDIO_CONV_FOZ_TAG_CODECINFO, &entry->hash));
+                    }
+                    else
+                    {
+                        chunks_to_keep = g_list_append(chunks_to_keep,
+                                entry_name_create(entry->tag, &entry->hash));
+                        chunks_to_keep = g_list_append(chunks_to_keep,
+                                entry_name_create(AUDIO_CONV_FOZ_TAG_CODECINFO, &entry->hash));
+                    }
+                }
+
+                if (has_all)
+                    chunks_to_discard = g_list_append(chunks_to_discard,
+                            entry_name_create(AUDIO_CONV_FOZ_TAG_STREAM, stream_id));
+
+                g_list_free_full(stream_chunks, free);
+            }
+            free(buffer);
+        }
+    }
+
+    for (list_iter = chunks_to_discard; list_iter; list_iter = list_iter->next)
+    {
+        struct entry_name *entry = list_iter->data;
+        if (!g_list_find_custom(chunks_to_keep, entry, entry_name_compare))
+            chunks = g_list_append(chunks, entry_name_create(entry->tag, &entry->hash));
+    }
+
+    if ((ret = fozdb_discard_entries(dump_fozdb.fozdb, chunks)) < 0)
+    {
+        GST_ERROR("Failed to discard entries, ret %d.", ret);
+        dump_fozdb_close(&dump_fozdb);
+    }
+
+    g_list_free_full(chunks, free);
+    g_list_free_full(chunks_to_keep, free);
+    g_list_free_full(chunks_to_discard, free);
+}
+
+static bool need_transcode_head_create_from_caps(GstCaps *caps, struct need_transcode_head **out)
+{
+    int wmaversion, bitrate, channels, rate, block_align, depth;
+    const GstStructure *structure = gst_caps_get_structure(caps, 0);
+    struct need_transcode_head *head;
+    const GValue *codec_data_value;
+    GstBuffer *codec_data_buffer;
+    gsize codec_data_size;
+
+    GST_DEBUG("caps %"GST_PTR_FORMAT", out %p.", caps, out);
+
+    if (!gst_structure_get_int(structure, "wmaversion", &wmaversion))
+    {
+        GST_ERROR("Caps have no wmaversion field.");
+        return false;
+    }
+    if (!gst_structure_get_int(structure, "bitrate", &bitrate))
+    {
+        GST_ERROR("Caps have no bitrate field.");
+        return false;
+    }
+    if (!gst_structure_get_int(structure, "channels", &channels))
+    {
+        GST_ERROR("Caps have no channels field.");
+        return false;
+    }
+    if (!gst_structure_get_int(structure, "rate", &rate))
+    {
+        GST_ERROR("Caps have no rate field.");
+        return false;
+    }
+    if (!gst_structure_get_int(structure, "block_align", &block_align))
+    {
+        GST_ERROR("Caps have no block_align field.");
+        return false;
+    }
+    if (!gst_structure_get_int(structure, "depth", &depth))
+    {
+        GST_ERROR("Caps have no depth field.");
+        return false;
+    }
+    if (!(codec_data_value = gst_structure_get_value(structure, "codec_data"))
+             || !(codec_data_buffer = gst_value_get_buffer(codec_data_value)))
+    {
+        GST_ERROR("Caps have no codec_data field.");
+        return false;
+    }
+
+    codec_data_size = gst_buffer_get_size(codec_data_buffer);
+    head = calloc(1, sizeof(*head) + codec_data_size);
+    head->codec_data_size = codec_data_size;
+    head->wmaversion = wmaversion;
+    head->bitrate = bitrate;
+    head->channels = channels;
+    head->rate = rate;
+    head->block_align = block_align;
+    head->depth = depth;
+    gst_buffer_extract(codec_data_buffer, 0, head + 1, codec_data_size);
+
+    *out = head;
+    return true;
+}
+
+static struct need_transcode_head *need_transcode_head_dup(struct need_transcode_head *head)
+{
+    size_t size = sizeof(*head) + head->codec_data_size;
+    struct need_transcode_head *dup;
+
+    dup = calloc(1, size);
+    memcpy(dup, head, size);
+
+    return dup;
+}
+
+
+static void need_transcode_head_serialize(struct need_transcode_head *head,
+        uint8_t *buffer, size_t buffer_size, size_t *out_size)
+{
+    *out_size = sizeof(*head) - sizeof(head->codec_data_size) + head->codec_data_size;
+
+    if (buffer_size < *out_size)
+    {
+        GST_ERROR("Buffer too small: buffer size %zu, out size %zu.", buffer_size, *out_size);
+        return;
+    }
+    memcpy(buffer, &head->wmaversion, *out_size);
+}
+
+static void stream_state_serializer_init(struct stream_state_serializer *serializer, struct stream_state *state)
+{
+    serializer->state = state;
+    serializer->index = 0;
+}
+
+static int stream_state_serializer_read(void *data_reader, uint8_t *buffer, size_t size, size_t *read_size)
+{
+    struct stream_state_serializer *serializer = data_reader;
+    struct buffer_entry *entry;
+
+    if (!size)
+    {
+        *read_size = 0;
+        return CONV_OK;
+    }
+
+    if (serializer->index >= g_list_length(serializer->state->buffers))
+        return CONV_ERROR_DATA_END;
+
+    entry = g_list_nth_data(serializer->state->buffers, serializer->index++);
+    memcpy(buffer, &entry->hash, sizeof(entry->hash));
+
+    *read_size = sizeof(entry->hash);
+    return CONV_OK;
+}
+
+static struct stream_state *stream_state_create(void)
+{
+    struct stream_state *state;
+    state = calloc(1, sizeof(*state));
+    murmur3_128_state_init(&state->hash_state, HASH_SEED);
+    return state;
+}
+
+static void stream_state_release(struct stream_state *state)
+{
+    g_list_free_full(state->buffers, buffer_entry_release);
+    g_list_free_full(state->loop_buffers, buffer_entry_release);
+    if (state->codec_info)
+        free(state->codec_info);
+    free(state);
+}
+
+static void stream_state_reset(struct stream_state *state)
+{
+    murmur3_128_state_reset(&state->hash_state);
+    memset(&state->current_hash, 0, sizeof(state->current_hash));
+    g_list_free_full(g_steal_pointer(&state->buffers), buffer_entry_release);
+    g_list_free_full(g_steal_pointer(&state->loop_buffers), buffer_entry_release);
+    free(state->codec_info);
+    state->codec_info = NULL;
+    state->needs_dump = false;
+}
+
+static loop_state stream_state_record_buffer(struct stream_state *state, struct payload_hash *buffer_hash,
+        struct payload_hash *loop_hash, GstBuffer *buffer, struct need_transcode_head *codec_info)
+{
+    if (!state->codec_info && codec_info)
+        state->codec_info = need_transcode_head_dup(codec_info);
+
+    if (g_list_length(state->loop_buffers) < g_list_length(state->buffers))
+    {
+        struct buffer_entry *entry = g_list_nth_data(state->buffers, g_list_length(state->loop_buffers));
+        if (!memcmp(&entry->hash, loop_hash, sizeof(*loop_hash)))
+        {
+            state->loop_buffers = g_list_append(state->loop_buffers,
+                    buffer_entry_create(buffer_hash /* Not loop_hash! */, buffer));
+            if (g_list_length(state->loop_buffers) == g_list_length(state->buffers))
+            {
+                /* Full loop, just drop them. */
+                g_list_free_full(g_steal_pointer(&state->loop_buffers), buffer_entry_release);
+                return LOOP_ENDED;
+            }
+
+            return LOOPING;
+        }
+    }
+
+    /* Partial loop, track them and then continue */
+    if (state->loop_buffers)
+        state->buffers = g_list_concat(state->buffers, g_steal_pointer(&state->loop_buffers));
+
+    state->buffers = g_list_append(state->buffers, buffer_entry_create(buffer_hash, buffer));
+
+    if (!hash_data((const uint8_t *)buffer_hash, sizeof(*buffer_hash), &state->hash_state, &state->current_hash))
+        return LOOP_ERROR;
+
+    return NO_LOOP;
+}
+
+static bool stream_state_is_stream_subset(struct stream_state *state, struct fozdb *db, struct payload_hash *stream_id)
+{
+    uint64_t offset = 0;
+    GList *list_iter;
+
+    for (list_iter = state->buffers; list_iter; list_iter = list_iter->next)
+    {
+        struct buffer_entry *entry = list_iter->data;
+        struct payload_hash buffer_id;
+        size_t read_size;
+
+        if ((fozdb_read_entry_data(db, AUDIO_CONV_FOZ_TAG_STREAM, stream_id,
+                offset, (uint8_t *)&buffer_id, sizeof(buffer_id), &read_size, true)) < 0
+                || read_size != sizeof(buffer_id))
+            return false;
+
+        if (memcmp(&buffer_id, &entry->hash, sizeof(buffer_id)) != 0)
+            return false;
+
+        offset += sizeof(buffer_id);
+    }
+
+    GST_LOG("Stream id %s is a subset of %s, so not recording stream.",
+            format_hash(&state->current_hash), format_hash(stream_id));
+
+    return true;
+}
+
+static int stream_state_write_to_foz(struct stream_state *state)
+{
+    struct stream_state_serializer serializer;
+    struct buffer_entry *entry;
+    struct bytes_reader reader;
+    uint8_t buffer[1024];
+    size_t header_size;
+    GList *list_iter;
+    bool found;
+    int ret;
+
+    GST_DEBUG("state %p, current hash %s.", state, format_hash(&state->current_hash));
+
+    if (!state->needs_dump || !state->buffers)
+        return CONV_OK;
+
+    pthread_mutex_lock(&dump_fozdb.mutex);
+
+    if ((ret = dump_fozdb_open_audio(true)) < 0)
+    {
+        GST_ERROR("Failed to open audio dump fozdb, ret %d.", ret);
+        pthread_mutex_unlock(&dump_fozdb.mutex);
+        return ret;
+    }
+
+    found = fozdb_has_entry(dump_fozdb.fozdb, AUDIO_CONV_FOZ_TAG_STREAM, &state->current_hash);
+    if (!found)
+    {
+        /* Are there any recorded streams of which this stream is a subset? */
+        struct payload_hash *stream_id;
+        GHashTableIter stream_ids;
+
+        fozdb_iter_tag(dump_fozdb.fozdb, AUDIO_CONV_FOZ_TAG_STREAM, &stream_ids);
+        while (g_hash_table_iter_next(&stream_ids, (void **)&stream_id, NULL))
+        {
+            if (stream_state_is_stream_subset(state, dump_fozdb.fozdb, stream_id))
+            {
+                found = true;
+                break;
+            }
+        }
+    }
+
+    if (!found)
+    {
+        if (dumping_disabled())
+        {
+            GST_LOG("Dumping disabled, so not recording stream id %s.", format_hash(&state->current_hash));
+        }
+        else
+        {
+            GST_LOG("Recording stream id %s.", format_hash(&state->current_hash));
+
+            need_transcode_head_serialize(state->codec_info, buffer, sizeof(buffer), &header_size);
+            bytes_reader_init(&reader, buffer, header_size);
+            entry = state->buffers->data;
+            if ((ret = fozdb_write_entry(dump_fozdb.fozdb, AUDIO_CONV_FOZ_TAG_CODECINFO, &entry->hash,
+                    &reader, bytes_reader_read, true)) < 0)
+            {
+                GST_ERROR("Unable to write stream header, ret %d.\n", ret);
+                pthread_mutex_unlock(&dump_fozdb.mutex);
+                return ret;
+            }
+
+            stream_state_serializer_init(&serializer, state);
+            if ((ret = fozdb_write_entry(dump_fozdb.fozdb, AUDIO_CONV_FOZ_TAG_STREAM, &state->current_hash,
+                    &serializer, stream_state_serializer_read, true)) < 0)
+            {
+                GST_ERROR("Unable to write stream, ret %d.\n", ret);
+                pthread_mutex_unlock(&dump_fozdb.mutex);
+                return ret;
+            }
+
+            for (list_iter = state->buffers; list_iter; list_iter = list_iter->next)
+            {
+                struct gst_buffer_reader buffer_reader;
+
+                entry = list_iter->data;
+                gst_buffer_reader_init(&buffer_reader, entry->buffer);
+                if ((ret = fozdb_write_entry(dump_fozdb.fozdb, AUDIO_CONV_FOZ_TAG_AUDIODATA, &entry->hash,
+                        &buffer_reader, gst_buffer_reader_read, true)) < 0)
+                {
+                    GST_ERROR("Unable to write audio data, ret %d.\n", ret);
+                    pthread_mutex_unlock(&dump_fozdb.mutex);
+                    return ret;
+                }
+            }
+        }
+    }
+
+    pthread_mutex_unlock(&dump_fozdb.mutex);
+    return CONV_OK;
+}
+
+static int audio_conv_state_create(struct audio_conv_state **out)
+{
+    struct audio_conv_state *state;
+    struct fozdb *fozdb = NULL;
+    char *read_fozdb_path;
+    int ret;
+
+    if (!(read_fozdb_path = getenv("MEDIACONV_AUDIO_TRANSCODED_FILE")))
+    {
+        GST_ERROR("Env MEDIACONV_AUDIO_TRANSCODED_FILE is not set!");
+        return CONV_ERROR_ENV_NOT_SET;
+    }
+
+    if ((ret = fozdb_create(read_fozdb_path, O_RDONLY, true /* Read-only? */, AUDIO_CONV_FOZ_NUM_TAGS, &fozdb)) < 0)
+        GST_ERROR("Failed to create fozdb from %s, ret %d.", read_fozdb_path, ret);
+
+    state = calloc(1, sizeof(*state));
+    murmur3_128_state_init(&state->hash_state, HASH_SEED);
+    murmur3_128_state_init(&state->loop_hash_state, HASH_SEED);
+    state->stream_state = stream_state_create();
+    state->read_fozdb = fozdb;
+
+    *out = state;
+    return CONV_OK;
+}
+
+static void audio_conv_state_release(struct audio_conv_state *state)
+{
+    free(state->codec_data);
+    stream_state_release(state->stream_state);
+    if (state->read_fozdb)
+        fozdb_release(state->read_fozdb);
+    free(state);
+}
+
+static void audio_conv_state_reset(struct audio_conv_state *state)
+{
+    if (stream_state_write_to_foz(state->stream_state) < 0)
+        GST_ERROR("Failed to write stream to dump fozdb.");
+
+    stream_state_reset(state->stream_state);
+    murmur3_128_state_reset(&state->hash_state);
+    murmur3_128_state_reset(&state->loop_hash_state);
+}
+
+/* Allocate a buffer on success, free it after usage. */
+static int audio_conv_state_open_transcode_file(struct audio_conv_state *state, GstBuffer *buffer,
+        uint8_t **out_data, size_t *out_size)
+{
+    struct payload_hash hash, loop_hash;
+    uint32_t transcoded_size;
+    const char *blank_audio;
+    bool try_loop, hash_ok;
+    GstMapInfo map_info;
+    uint64_t file_size;
+    loop_state loop;
+    uint8_t *data;
+    size_t size;
+    int fd;
+
+    /* Hash buffer. */
+    if (!gst_buffer_map(buffer, &map_info, GST_MAP_READ))
+        return CONV_ERROR;
+    hash_ok = hash_data(map_info.data, map_info.size, &state->hash_state, &hash)
+            && hash_data(map_info.data, map_info.size, &state->loop_hash_state, &loop_hash);
+    gst_buffer_unmap(buffer, &map_info);
+    if (!hash_ok)
+    {
+        GST_ERROR("Failed to hash buffer.");
+        return CONV_ERROR;
+    }
+
+    loop = stream_state_record_buffer(state->stream_state, &hash, &loop_hash, buffer, state->codec_data);
+    gst_buffer_unref(buffer); /* Buffer has been recorded, so unref it. */
+    switch (loop)
+    {
+    case NO_LOOP:
+        murmur3_128_state_reset(&state->loop_hash_state);
+        try_loop = false;
+        break;
+
+    case LOOP_ENDED:
+        murmur3_128_state_reset(&state->loop_hash_state);
+    case LOOPING:
+        try_loop = true;
+        break;
+
+    case LOOP_ERROR:
+    default:
+        return CONV_ERROR;
+    }
+
+    if (try_loop)
+        GST_INFO("Buffer hash: %s (Loop: %s).", format_hash(&hash), format_hash(&loop_hash));
+    else
+        GST_INFO("Buffer hash: %s.", format_hash(&hash));
+
+    /* Try to read transcoded data. */
+    if (state->read_fozdb)
+    {
+        if (fozdb_entry_size(state->read_fozdb,
+                AUDIO_CONV_FOZ_TAG_PTNADATA, &hash, &transcoded_size) == CONV_OK)
+        {
+            data = calloc(1, transcoded_size);
+            if (fozdb_read_entry_data(state->read_fozdb, AUDIO_CONV_FOZ_TAG_PTNADATA, &hash, 0,
+                    data, transcoded_size, &size, false) == CONV_OK)
+            {
+                *out_data = data;
+                *out_size = size;
+                return CONV_OK;
+            }
+            free(data);
+        }
+
+        if (try_loop && fozdb_entry_size(state->read_fozdb,
+                AUDIO_CONV_FOZ_TAG_PTNADATA, &loop_hash, &transcoded_size) == CONV_OK)
+        {
+            data = calloc(1, transcoded_size);
+            if (fozdb_read_entry_data(state->read_fozdb, AUDIO_CONV_FOZ_TAG_PTNADATA, &loop_hash, 0,
+                    data, transcoded_size, &size, false) == CONV_OK)
+            {
+                *out_data = data;
+                *out_size = size;
+                return CONV_OK;
+            }
+            free(data);
+        }
+    }
+
+    /* If we can't, return the blank file */
+    state->stream_state->needs_dump = true;
+    if (!(blank_audio = getenv("MEDIACONV_BLANK_AUDIO_FILE")))
+    {
+        GST_ERROR("Env MEDIACONV_BLANK_AUDIO_FILE not set.");
+        return CONV_ERROR_ENV_NOT_SET;
+    }
+    if (!open_file(blank_audio, O_RDONLY, &fd))
+        return CONV_ERROR_OPEN_FAILED;
+    if (!get_file_size(fd, &file_size))
+    {
+        close(fd);
+        return CONV_ERROR;
+    }
+    data = calloc(1, file_size);
+    if (!complete_read(fd, data, file_size))
+    {
+        free(data);
+        close(fd);
+        return CONV_ERROR_READ_FAILED;
+    }
+
+    create_placeholder_file("placeholder-audio-used");
+
+    *out_data = data;
+    *out_size = file_size;
+
+    return CONV_OK;
+}
+
+/* Call pthread_mutex_unlock() to unlock after usage. */
+static struct audio_conv_state *audio_conv_lock_state(AudioConv *conv)
+{
+    pthread_mutex_lock(&conv->state_mutex);
+    if (!conv->state)
+        pthread_mutex_unlock(&conv->state_mutex);
+    return conv->state;
+}
+
+static GstStateChangeReturn audio_conv_change_state(GstElement *element, GstStateChange transition)
+{
+    AudioConv *conv = AUDIO_CONV(element);
+    struct audio_conv_state *state;
+    int ret;
+
+    GST_DEBUG_OBJECT(element, "State transition %s.", gst_state_change_get_name(transition));
+
+    switch (transition)
+    {
+    case GST_STATE_CHANGE_NULL_TO_READY:
+        /* Do runtime setup. */
+
+        /* Open fozdb here; this is the right place to fail
+        * and opening may be expensive. */
+        pthread_mutex_lock(&dump_fozdb.mutex);
+        dump_fozdb_discard_transcoded();
+        ret = dump_fozdb_open_audio(true);
+        pthread_mutex_unlock(&dump_fozdb.mutex);
+        if (ret < 0)
+        {
+            GST_ERROR("Failed to open dump fozdb, ret %d.", ret);
+            return GST_STATE_CHANGE_FAILURE;
+        }
+
+        /* Create audio conv state. */
+        if ((ret = audio_conv_state_create(&state)) < 0)
+        {
+            GST_ERROR("Failed to create audio conv state, ret %d.", ret);
+            return GST_STATE_CHANGE_FAILURE;
+        }
+        pthread_mutex_lock(&conv->state_mutex);
+        assert(!conv->state);
+        conv->state = state;
+        pthread_mutex_unlock(&conv->state_mutex);
+        break;
+
+    case GST_STATE_CHANGE_READY_TO_NULL:
+        /* Do runtime teardown. */
+        pthread_mutex_lock(&conv->state_mutex);
+        state = conv->state;
+        conv->state = NULL;
+        pthread_mutex_unlock(&conv->state_mutex);
+
+        if (state && (ret = stream_state_write_to_foz(state->stream_state)) < 0)
+            GST_WARNING("Error writing out stream data, ret %d.", ret);
+        audio_conv_state_release(state);
+        break;
+
+    default:
+        break;
+    }
+
+    return GST_ELEMENT_CLASS(parent_class)->change_state(element, transition);
+
+    /* XXX on ReadyToNull, sodium drops state _again_ here... why? */
+}
+
+static gboolean audio_conv_sink_event(GstPad *pad, GstObject *parent, GstEvent *event)
+{
+    AudioConv *conv = AUDIO_CONV(parent);
+    struct audio_conv_state *state;
+    GstCaps *caps;
+    bool ret;
+
+    GST_DEBUG_OBJECT(pad, "Got sink event %"GST_PTR_FORMAT".", event);
+
+    switch (event->type)
+    {
+    case GST_EVENT_CAPS:
+        if ((state = audio_conv_lock_state(conv)))
+        {
+            gst_event_parse_caps(event, &caps);
+            if (!need_transcode_head_create_from_caps(caps, &state->codec_data))
+            {
+                GST_ERROR("Invalid WMA caps!");
+                pthread_mutex_unlock(&conv->state_mutex);
+                return false;
+            }
+            pthread_mutex_unlock(&conv->state_mutex);
+        }
+
+        caps = gst_caps_from_string("audio/x-opus, channel-mapping-family=0");
+        ret = push_event(conv->src_pad, gst_event_new_caps(caps));
+        gst_caps_unref(caps);
+        return ret;
+
+    case GST_EVENT_FLUSH_STOP:
+        if ((state = audio_conv_lock_state(conv)))
+        {
+            audio_conv_state_reset(state);
+            pthread_mutex_unlock(&conv->state_mutex);
+        }
+        return gst_pad_event_default(pad, parent, event);
+
+    default:
+        return gst_pad_event_default(pad, parent, event);
+    }
+}
+
+static GstFlowReturn audio_conv_chain(GstPad *pad, GstObject *parent, GstBuffer *buffer)
+{
+    size_t ptna_data_size, offset, encoded_len;
+    GstFlowReturn flow_ret = GST_FLOW_ERROR;
+    AudioConv *conv = AUDIO_CONV(parent);
+    struct audio_conv_state *state;
+    uint8_t *ptna_data = NULL;
+    int ret;
+
+    GST_LOG_OBJECT(pad, "Handling buffer <%"GST_PTR_FORMAT">.", buffer);
+
+    if (!(state = audio_conv_lock_state(conv)))
+        return flow_ret;
+
+    if ((ret = audio_conv_state_open_transcode_file(state, buffer, &ptna_data, &ptna_data_size)) < 0)
+    {
+        GST_ERROR("Failed to read transcoded audio, ret %d. Things will go badly...", ret);
+        goto done;
+    }
+
+    for (offset = 0; offset < ptna_data_size; offset += encoded_len)
+    {
+        uint32_t packet_header, flags, padding_len;
+        GstBuffer *new_buffer;
+        bool packet_is_header;
+
+        if (offset + 4 >= ptna_data_size)
+        {
+            GST_WARNING( "Short read on ptna header?");
+            break;
+        }
+
+        packet_header = bytes_to_uint32(&ptna_data[offset]);
+        offset += 4;
+
+        flags = packet_header & AUDIO_CONV_FLAG_MASK,
+        padding_len = (packet_header & AUDIO_CONV_PADDING_LENGTH_MASK) >> AUDIO_CONV_PADDING_LENGTH_SHIFT;
+        encoded_len = packet_header & AUDIO_CONV_ENCODED_LENGTH_MASK;
+
+        if (offset + encoded_len > ptna_data_size)
+        {
+            GST_WARNING("Short read on ptna data?");
+            break;
+        }
+
+        packet_is_header = flags & AUDIO_CONV_FLAG_HEADER;
+        if (packet_is_header && state->sent_header)
+            continue; /* Only send one header. */
+
+        /* TODO: can we use a GstBuffer cache here? */
+        new_buffer = gst_buffer_new_and_alloc(encoded_len);
+        if (!packet_is_header && padding_len > 0)
+            gst_buffer_add_audio_clipping_meta(new_buffer, GST_FORMAT_DEFAULT, 0, padding_len);
+        gst_buffer_fill(new_buffer, 0, ptna_data + offset, encoded_len);
+
+        GST_LOG("Pushing one packet of len %zu.", encoded_len);
+        if ((flow_ret = gst_pad_push(conv->src_pad, new_buffer)) < 0)
+        {
+            GST_ERROR("Failed to push buffer <%"GST_PTR_FORMAT"> to src pad %"GST_PTR_FORMAT,
+                    new_buffer, conv->src_pad);
+            goto done;
+        }
+
+        if (packet_is_header)
+            state->sent_header = true;
+    }
+
+    flow_ret = GST_FLOW_OK;
+
+done:
+    if (ptna_data)
+        free(ptna_data);
+    pthread_mutex_unlock(&conv->state_mutex);
+    return flow_ret;
+}
+
+static gboolean audio_conv_src_query(GstPad *pad, GstObject *parent, GstQuery *query)
+{
+    AudioConv *conv = AUDIO_CONV(parent);
+    GstSchedulingFlags flags;
+    gint min, max, align;
+    GstQuery *peer_query;
+
+    GST_DEBUG_OBJECT(pad, "Got query %"GST_PTR_FORMAT".", query);
+
+    switch (query->type)
+    {
+    case GST_QUERY_SCHEDULING:
+        peer_query = gst_query_new_scheduling();
+        if (!gst_pad_peer_query(conv->sink_pad, peer_query))
+        {
+            gst_query_unref(peer_query);
+            return false;
+        }
+        gst_query_parse_scheduling(peer_query, &flags, &min, &max, &align);
+        gst_query_unref(peer_query);
+        gst_query_set_scheduling(query, flags, min, max, align);
+        return true;
+
+    default:
+        return gst_pad_query_default(pad, parent, query);
+    }
+
+}
+
+static gboolean audio_conv_active_mode(GstPad *pad, GstObject *parent, GstPadMode mode, gboolean active)
+{
+    AudioConv *conv = AUDIO_CONV(parent);
+    return gst_pad_activate_mode(conv->sink_pad, mode, active);
+}
+
+static void audio_conv_finalize(GObject *object)
+{
+    AudioConv *conv = AUDIO_CONV(object);
+
+    pthread_mutex_destroy(&conv->state_mutex);
+    if (conv->state)
+        audio_conv_state_release(conv->state);
+
+    G_OBJECT_CLASS(parent_class)->finalize(object);
+}
+
+static void audio_conv_class_init(AudioConvClass *klass)
+{
+    GstElementClass *element_class = GST_ELEMENT_CLASS(klass);
+    GObjectClass *object_class = G_OBJECT_CLASS(klass);
+
+    gst_element_class_set_metadata(element_class,
+            "Proton audio converter",
+            "Codec/Demuxer",
+            "Converts audio for Proton",
+            "Andrew Eikum <aeikum@codeweavers.com>, Ziqing Hui <zhui@codeweavers.com>");
+
+    element_class->change_state = audio_conv_change_state;
+    object_class->finalize = audio_conv_finalize;
+
+    gst_element_class_add_pad_template(element_class, gst_static_pad_template_get(&audio_conv_sink_template));
+    gst_element_class_add_pad_template(element_class, gst_static_pad_template_get(&audio_conv_src_template));
+}
+
+static void audio_conv_init(AudioConv *conv)
+{
+    GstElement *element = GST_ELEMENT(conv);
+
+    conv->sink_pad = gst_pad_new_from_static_template(&audio_conv_sink_template, "sink");
+    gst_pad_set_event_function(conv->sink_pad, GST_DEBUG_FUNCPTR(audio_conv_sink_event));
+    gst_pad_set_chain_function(conv->sink_pad, GST_DEBUG_FUNCPTR(audio_conv_chain));
+    gst_element_add_pad(element, conv->sink_pad);
+
+    conv->src_pad = gst_pad_new_from_static_template(&audio_conv_src_template, "src");
+    gst_pad_set_query_function(conv->src_pad, GST_DEBUG_FUNCPTR(audio_conv_src_query));
+    gst_pad_set_activatemode_function(conv->src_pad, GST_DEBUG_FUNCPTR(audio_conv_active_mode));
+    gst_element_add_pad(element, conv->src_pad);
+
+    pthread_mutex_init(&conv->state_mutex, NULL);
+    conv->state = NULL;
+}
diff --git a/dlls/winegstreamer/media-converter/audioconvbin.c b/dlls/winegstreamer/media-converter/audioconvbin.c
new file mode 100644
index 00000000000..9857a0ff507
--- /dev/null
+++ b/dlls/winegstreamer/media-converter/audioconvbin.c
@@ -0,0 +1,148 @@
+/*
+ * Copyright 2024 Ziqing Hui for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "media-converter.h"
+
+GST_DEBUG_CATEGORY_EXTERN(media_converter_debug);
+#undef GST_CAT_DEFAULT
+#define GST_CAT_DEFAULT media_converter_debug
+
+typedef struct
+{
+    GstBin bin;
+    GstElement *audio_conv, *opus_dec, *caps_setter;
+    GstPad *sink_pad, *src_pad; /* Ghost pads. */
+} AudioConvBin;
+
+typedef struct
+{
+    GstBinClass class;
+} AudioConvBinClass;
+
+G_DEFINE_TYPE(AudioConvBin, audio_conv_bin, GST_TYPE_BIN);
+#define AUDIO_CONV_BIN_TYPE (audio_conv_bin_get_type())
+#define AUDIO_CONV_BIN(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), AUDIO_CONV_BIN_TYPE, AudioConvBin))
+GST_ELEMENT_REGISTER_DEFINE(protonaudioconverterbin, "protonaudioconverterbin",
+        GST_RANK_MARGINAL + 1, AUDIO_CONV_BIN_TYPE);
+
+static GstStaticPadTemplate audio_conv_bin_sink_template = GST_STATIC_PAD_TEMPLATE("sink",
+        GST_PAD_SINK, GST_PAD_ALWAYS,
+        GST_STATIC_CAPS("audio/x-wma;"));
+
+static GstStaticPadTemplate audio_conv_bin_src_template = GST_STATIC_PAD_TEMPLATE("src",
+        GST_PAD_SRC, GST_PAD_ALWAYS,
+        GST_STATIC_CAPS("audio/x-raw, format=S16LE;"));
+
+static void link_elements(GstElement *src_element, GstElement *sink_element)
+{
+    if (!gst_element_link(src_element, sink_element))
+        GST_ERROR("Failed to link src element %"GST_PTR_FORMAT" to sink element %"GST_PTR_FORMAT".",
+                src_element, sink_element);
+}
+
+static gboolean audio_conv_bin_sink_event(GstPad *pad, GstObject *parent, GstEvent *event)
+{
+    AudioConvBin * bin = AUDIO_CONV_BIN(parent);
+    GstCaps *caps, *rate_caps;
+    GstStructure *structure;
+    GstPad *audio_conv_sink;
+    gint override_rate;
+    gboolean ret;
+
+    GST_DEBUG_OBJECT(pad, "Got sink event %"GST_PTR_FORMAT".", event);
+
+    switch (event->type)
+    {
+    case GST_EVENT_CAPS:
+        gst_event_parse_caps(event, &caps);
+        if ((structure = gst_caps_get_structure(caps, 0))
+                && gst_structure_get_int(structure, "rate", &override_rate))
+        {
+            rate_caps = gst_caps_new_simple("audio/x-raw", "rate", G_TYPE_INT, override_rate, NULL);
+            g_object_set(bin->caps_setter, "caps", rate_caps, NULL);
+        }
+        else
+        {
+            GST_WARNING("Event has no rate.");
+        }
+
+        /* Forward on to the real pad. */
+        audio_conv_sink = gst_element_get_static_pad(bin->audio_conv, "sink");
+        ret = gst_pad_send_event(audio_conv_sink, event);
+        gst_object_unref(audio_conv_sink);
+        return ret;
+
+    default:
+        return gst_pad_event_default(pad, parent, event);
+    }
+}
+
+static void audio_conv_bin_class_init(AudioConvBinClass * klass)
+{
+    GstElementClass *element_class = GST_ELEMENT_CLASS(klass);
+
+    gst_element_class_set_metadata(element_class,
+            "Proton audio converter with rate fixup",
+            "Codec/Decoder/Audio",
+            "Converts audio for Proton, fixing up samplerates",
+            "Andrew Eikum <aeikum@codeweavers.com>, Ziqing Hui <zhui@codeweavers.com>");
+
+    gst_element_class_add_pad_template(element_class, gst_static_pad_template_get(&audio_conv_bin_sink_template));
+    gst_element_class_add_pad_template(element_class, gst_static_pad_template_get(&audio_conv_bin_src_template));
+}
+
+static void audio_conv_bin_init(AudioConvBin *bin)
+{
+    GstElement *element = GST_ELEMENT(bin);
+    GstPad *sink, *src;
+
+    bin->sink_pad = gst_ghost_pad_new_no_target_from_template("sink",
+            gst_element_get_pad_template(element, "sink"));
+    bin->src_pad = gst_ghost_pad_new_no_target_from_template("src",
+           gst_element_get_pad_template(element, "src"));
+    gst_pad_set_event_function(bin->sink_pad, GST_DEBUG_FUNCPTR(audio_conv_bin_sink_event));
+
+    bin->audio_conv = create_element("protonaudioconverter", "protonmediaconverter");
+    bin->opus_dec = create_element("opusdec", "base");
+    bin->caps_setter = create_element("capssetter", "good");
+
+    gst_bin_add(GST_BIN(bin), bin->audio_conv);
+    gst_bin_add(GST_BIN(bin), bin->opus_dec);
+    gst_bin_add(GST_BIN(bin), bin->caps_setter);
+
+    link_elements(bin->audio_conv, bin->opus_dec);
+    link_elements(bin->opus_dec, bin->caps_setter);
+
+    sink = gst_element_get_static_pad(bin->audio_conv, "sink");
+    src = gst_element_get_static_pad(bin->caps_setter, "src");
+    gst_ghost_pad_set_target(GST_GHOST_PAD(bin->sink_pad), sink);
+    gst_ghost_pad_set_target(GST_GHOST_PAD(bin->src_pad), src);
+    gst_object_unref(src);
+    gst_object_unref(sink);
+
+    gst_element_add_pad(element, bin->sink_pad);
+    gst_element_add_pad(element, bin->src_pad);
+
+    GST_INFO("Initialized AudioConvBin %"GST_PTR_FORMAT": audio_conv %"GST_PTR_FORMAT", opus_dec %"GST_PTR_FORMAT", "
+            "caps_setter %"GST_PTR_FORMAT", sink_pad %"GST_PTR_FORMAT", src_pad %"GST_PTR_FORMAT".",
+            bin, bin->audio_conv, bin->opus_dec, bin->caps_setter, bin->sink_pad, bin->src_pad);
+}
diff --git a/dlls/winegstreamer/media-converter/fossilize.c b/dlls/winegstreamer/media-converter/fossilize.c
new file mode 100644
index 00000000000..057825ad5b5
--- /dev/null
+++ b/dlls/winegstreamer/media-converter/fossilize.c
@@ -0,0 +1,722 @@
+/*
+ * Copyright 2024 Ziqing Hui for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ *
+ * Based on "Fossilize," which is
+ * Copyright (c) 2018-2019 Hans-Kristian Arntzen
+ * https://github.com/ValveSoftware/Fossilize/
+ */
+
+/* This is a read/write implementation of the Fossilize database format.
+ *
+ * https://github.com/ValveSoftware/Fossilize/
+ *
+ * That C++ implementation is specific to Vulkan, while this one tries to be generic to store any
+ * type of data.
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "media-converter.h"
+
+/* Fossilize StreamArchive database format version 6:
+ *
+ * The file consists of a header, followed by an unlimited series of "entries".
+ *
+ * All multi-byte entities are little-endian.
+ *
+ * The file header is as follows:
+ *
+ * Field           Type           Description
+ * -----           ----           -----------
+ * magic_number    uint8_t[12]    Constant value: "\x81""FOSSILIZEDB"
+ * version         uint32_t       StreamArchive version: 6
+ *
+ *
+ * Each entry follows this format:
+ *
+ * Field           Type                    Description
+ * -----           ----                    -----------
+ * name            unsigned char[40]       Application-defined entry identifier, stored in hexadecimal big-endian
+ *                                         ASCII. Usually N-char tag followed by (40 - N)-char hash.
+ * size            uint32_t                Size of the payload as stored in this file.
+ * flags           uint32_t                Flags for this entry (e.g. compression). See below.
+ * crc32           uint32_t                CRC32 of the payload as stored in this file.
+ * full_size       uint32_t                Size of this payload after decompression.
+ * payload         uint8_t[stored_size]    Entry data.
+ *
+ * The flags field may contain:
+ *     0x1: No compression.
+ *     0x2: Deflate compression.
+ */
+
+#define FOZDB_MIN_COMPAT_VERSION  5
+#define FOZDB_VERSION             6
+
+#define FOZDB_COMPRESSION_NONE    1
+#define FOZDB_COMPRESSION_DEFLATE 2
+
+#define ENTRY_NAME_SIZE  40
+
+#define BUFFER_COPY_BYTES (8 * 1024 * 1024) /* Tuneable. */
+
+static const uint8_t FOZDB_MAGIC[] = {0x81, 'F', 'O', 'S', 'S', 'I', 'L', 'I', 'Z', 'E', 'D', 'B'};
+
+struct file_header
+{
+    uint8_t magic[12];
+    uint8_t unused1;
+    uint8_t unused2;
+    uint8_t unused3;
+    uint8_t version;
+} __attribute__((packed));
+
+struct payload_header
+{
+    uint32_t size;
+    uint32_t compression;
+    uint32_t crc;
+    uint32_t full_size;
+} __attribute__((packed));
+
+struct payload_entry
+{
+    struct payload_hash hash;
+    struct payload_header header;
+    uint64_t offset;
+};
+
+static guint hash_func(gconstpointer key)
+{
+    const struct payload_hash *payload_hash = key;
+
+    return payload_hash->hash[0]
+            ^ payload_hash->hash[1]
+            ^ payload_hash->hash[2]
+            ^ payload_hash->hash[3];
+}
+
+static gboolean hash_equal(gconstpointer a, gconstpointer b)
+{
+    return memcmp(a, b, sizeof(struct payload_hash)) == 0;
+}
+
+static bool tag_from_ascii_bytes(uint32_t *tag, const uint8_t *ascii_bytes)
+{
+    char str[sizeof(*tag) * 2 + 1] = {};
+
+    memcpy(str, ascii_bytes, sizeof(*tag) * 2);
+
+    *tag = strtoul(str, NULL, 16);
+    if (errno != 0)
+    {
+        GST_ERROR("Failed to convert string \"%s\" to tag. %s.", str, strerror(errno));
+        return false;
+    }
+
+    return true;
+}
+
+static bool hash_from_ascii_bytes(struct payload_hash *hash, const uint8_t *ascii_bytes)
+{
+    unsigned int i;
+
+    for (i = 0; i < ARRAY_SIZE(hash->hash); ++i)
+    {
+        uint32_t *hash_part = &hash->hash[ARRAY_SIZE(hash->hash) - 1 - i];
+        char str[sizeof(hash_part) * 2 + 1] = {};
+
+        memcpy(str, ascii_bytes + sizeof(*hash_part) * 2 * i, sizeof(*hash_part) * 2);
+
+        *hash_part = strtoul(str, NULL, 16);
+
+        if (errno != 0)
+        {
+            GST_ERROR("Failed to convert string \"%s\" to hash part %u. %s.", str, 4 - i, strerror(errno));
+            return false;
+        }
+    }
+
+    return true;
+}
+
+static void tag_to_ascii_bytes(uint32_t tag, uint8_t *ascii_bytes)
+{
+    char buffer[sizeof(tag) * 2 + 1];
+    sprintf(buffer, "%08x", tag);
+    memcpy(ascii_bytes, buffer, sizeof(tag) * 2);
+}
+
+static void hash_to_ascii_bytes(const struct payload_hash *hash, uint8_t *ascii_bytes)
+{
+    char buffer[sizeof(*hash) * 2 + 1];
+    sprintf(buffer, "%08x%08x%08x%08x", hash->hash[3], hash->hash[2], hash->hash[1], hash->hash[0]);
+    memcpy(ascii_bytes, buffer, sizeof(*hash) * 2);
+}
+
+static void payload_header_from_bytes(struct payload_header *header, const uint8_t *bytes)
+{
+    header->size        = bytes_to_uint32(bytes);
+    header->compression = bytes_to_uint32(bytes + 4);
+    header->crc         = bytes_to_uint32(bytes + 8);
+    header->full_size   = bytes_to_uint32(bytes + 12);
+}
+
+static int fozdb_read_file_header(struct fozdb *db)
+{
+    struct file_header header;
+
+    if (!complete_read(db->file, &header, sizeof(header)))
+    {
+        GST_ERROR("Failed to read file header.");
+        return CONV_ERROR_READ_FAILED;
+    }
+    if (memcmp(&header.magic, FOZDB_MAGIC, sizeof(FOZDB_MAGIC)) != 0)
+    {
+        GST_ERROR("Bad magic.");
+        return CONV_ERROR_CORRUPT_DATABASE;
+    }
+    if (header.version < FOZDB_MIN_COMPAT_VERSION || header.version > FOZDB_VERSION)
+    {
+        GST_ERROR("Incompatible version %u.", header.version);
+        return CONV_ERROR_CORRUPT_DATABASE;
+    }
+
+    return CONV_OK;
+}
+
+static int fozdb_read_entry_tag_hash_header(struct fozdb *db,
+        uint32_t *out_tag, struct payload_hash *out_hash, struct payload_header *out_header)
+{
+    uint8_t entry_name_and_header[ENTRY_NAME_SIZE + sizeof(struct payload_header)];
+    struct payload_hash hash;
+    uint32_t tag;
+
+    if (!complete_read(db->file, entry_name_and_header, sizeof(entry_name_and_header)))
+    {
+        GST_ERROR("Failed to read entry name and header.");
+        return CONV_ERROR_READ_FAILED;
+    }
+
+    if (!tag_from_ascii_bytes(&tag, entry_name_and_header)
+            || !hash_from_ascii_bytes(&hash, entry_name_and_header + sizeof(tag) * 2))
+        return CONV_ERROR_CORRUPT_DATABASE;
+
+    payload_header_from_bytes(out_header, entry_name_and_header + ENTRY_NAME_SIZE);
+
+    *out_tag = tag;
+    *out_hash = hash;
+    return CONV_OK;
+}
+
+static bool fozdb_seek_to_next_entry(struct fozdb *db, struct payload_header *header, bool *truncated)
+{
+    uint64_t file_size = 0, data_offset = lseek(db->file, 0, SEEK_CUR);
+
+    if (truncated)
+        *truncated = false;
+
+    get_file_size(db->file, &file_size);
+
+    if (lseek(db->file, header->size, SEEK_CUR) < 0)
+    {
+        GST_ERROR("Failed to seek to next entry. %s. "
+                "Entry data offset %#"PRIx64", size %#x, file size %#"PRIx64".",
+                strerror(errno), data_offset, header->size, file_size);
+        return false;
+    }
+
+    if (file_size && data_offset + header->size > file_size)
+    {
+        /* Truncated chunk is not fatal. */
+        GST_WARNING("Entry data larger than file, truncating database here. "
+            "Entry data offset %#"PRIx64", size %#x, file size %#"PRIx64".",
+                data_offset, header->size, file_size);
+        if (truncated)
+            *truncated = true;
+    }
+
+    return true;
+}
+
+static bool fozdb_write_entry_name(struct fozdb *db, uint32_t tag, struct payload_hash *hash)
+{
+    uint8_t entry_name[ENTRY_NAME_SIZE];
+
+    tag_to_ascii_bytes(tag, entry_name);
+    hash_to_ascii_bytes(hash, entry_name + sizeof(tag) * 2);
+
+    if (!complete_write(db->file, entry_name, sizeof(entry_name)))
+    {
+        GST_ERROR("Failed to write entry name.");
+        return false;
+    }
+
+    return true;
+}
+
+/* Copy an entry to write_pos. */
+static int fozdb_copy_entry(struct fozdb *db,
+        struct entry_name *name, struct payload_header *header, uint64_t entry_data_offset)
+{
+    uint64_t read_offset, entry_end = entry_data_offset + header->size;
+    ssize_t read_size;
+    uint8_t *buffer;
+
+    if (lseek(db->file, db->write_pos, SEEK_SET) < 0)
+    {
+        GST_ERROR("Failed to seek file to write_pos.");
+        return CONV_ERROR_SEEK_FAILED;
+    }
+
+    /* Write entry name. */
+    if (!fozdb_write_entry_name(db, name->tag, &name->hash))
+        return CONV_ERROR_WRITE_FAILED;
+    db->write_pos += ENTRY_NAME_SIZE;
+
+    /* Write entry header. */
+    if (!complete_write(db->file, header, sizeof(*header)))
+    {
+        GST_ERROR("Failed to write entry header.");
+        return CONV_ERROR_WRITE_FAILED;
+    }
+    db->write_pos += sizeof(*header);
+
+    /* Copy entry data. */
+    buffer = calloc(1, BUFFER_COPY_BYTES);
+    for (read_offset = entry_data_offset; read_offset < entry_end; read_offset += read_size)
+    {
+        size_t to_read = min(entry_end - read_offset, BUFFER_COPY_BYTES);
+
+        /* Read data from entry. */
+        if (lseek(db->file, read_offset, SEEK_SET) < 0)
+        {
+            GST_ERROR("Failed to seek to read offset. %s.", strerror(errno));
+            free(buffer);
+            return CONV_ERROR_SEEK_FAILED;
+        }
+        if ((read_size = read(db->file, buffer, to_read)) < 0)
+        {
+            GST_ERROR("Failed to read entry data. %s.", strerror(errno));
+            free(buffer);
+            return CONV_ERROR_READ_FAILED;
+        }
+        if (read_size == 0)
+            break;
+
+        /* Write data to write_pos. */
+        if (lseek(db->file, db->write_pos, SEEK_SET) < 0)
+        {
+            GST_ERROR("Failed to seek to write_pos. %s.", strerror(errno));
+            free(buffer);
+            return CONV_ERROR_SEEK_FAILED;
+        }
+        if (!complete_write(db->file, buffer, read_size))
+        {
+            GST_ERROR("Failed to write entry data to write_pos.");
+            free(buffer);
+            return CONV_ERROR_WRITE_FAILED;
+        }
+        db->write_pos += read_size;
+    }
+    free(buffer);
+
+    if (lseek(db->file, read_offset, SEEK_SET) < 0)
+    {
+        GST_ERROR("Failed to seek to read offset. %s.", strerror(errno));
+        return CONV_ERROR_SEEK_FAILED;
+    }
+
+    return CONV_OK;
+}
+
+int fozdb_create(const char *file_name, int open_flags, bool read_only, uint32_t num_tags, struct fozdb **out)
+{
+    struct fozdb *db;
+    size_t i;
+    int ret;
+
+    GST_DEBUG("file_name %s, open_flags %d, read_only %d, num_tags %u, out %p.",
+            file_name, open_flags, read_only, num_tags, out);
+
+    db = calloc(1, sizeof(*db));
+
+    if (!open_file(file_name, open_flags, &db->file))
+    {
+        free(db);
+        return CONV_ERROR_OPEN_FAILED;
+    }
+
+    db->file_name = file_name;
+    db->num_tags = num_tags;
+    db->read_only = read_only;
+
+    /* Create entry hash tables. */
+    db->seen_blobs = calloc(num_tags, sizeof(*db->seen_blobs));
+    for (i = 0; i < num_tags; ++i)
+        db->seen_blobs[i] = g_hash_table_new_full(hash_func, hash_equal, NULL, free);
+
+    /* Load entries. */
+    if ((ret = fozdb_prepare(db)) < 0)
+    {
+        GST_ERROR("Failed to prepare fozdb, ret %d.", ret);
+        fozdb_release(db);
+        return ret;
+    }
+
+    GST_INFO("Created fozdb %p from %s.", db, file_name);
+
+    *out = db;
+    return CONV_OK;
+}
+
+void fozdb_release(struct fozdb *db)
+{
+    int i;
+
+    GST_DEBUG("db %p.", db);
+
+    for (i = 0; i < db->num_tags; ++i)
+        g_hash_table_destroy(db->seen_blobs[i]);
+    free(db->seen_blobs);
+    close(db->file);
+    free(db);
+}
+
+int fozdb_prepare(struct fozdb *db)
+{
+    uint64_t file_size;
+    int ret;
+
+    GST_DEBUG("db %p, file_name %s, read_only %d, num_tags %u.",
+            db, db->file_name, db->read_only, db->num_tags);
+
+    db->write_pos = lseek(db->file, 0, SEEK_SET);
+    if (!get_file_size(db->file, &file_size))
+        return CONV_ERROR;
+
+    /* New file, write foz header. */
+    if (!file_size)
+    {
+        struct file_header file_header;
+
+        memcpy(file_header.magic, FOZDB_MAGIC, sizeof(FOZDB_MAGIC));
+        file_header.unused1 = 0;
+        file_header.unused2 = 0;
+        file_header.unused3 = 0;
+        file_header.version = FOZDB_VERSION;
+
+        if (!complete_write(db->file, &file_header, sizeof(file_header)))
+        {
+            GST_ERROR("Failed to write file header.");
+            return CONV_ERROR_WRITE_FAILED;
+        }
+        db->write_pos = sizeof(file_header);
+
+        return CONV_OK;
+    }
+
+    /* Read file header. */
+    if ((ret = fozdb_read_file_header(db)) < 0)
+        return ret;
+    db->write_pos = lseek(db->file, 0, SEEK_CUR);
+
+    /* Read entries to seen_blobs. */
+    while (db->write_pos < file_size)
+    {
+        struct payload_entry entry, *table_entry;
+        uint32_t tag;
+
+        /* Read an entry. */
+        if ((ret = fozdb_read_entry_tag_hash_header(db, &tag, &entry.hash, &entry.header) < 0))
+            return ret;
+        entry.offset = lseek(db->file, 0, SEEK_CUR);
+
+        if (!fozdb_seek_to_next_entry(db, &entry.header, NULL))
+            return CONV_ERROR_SEEK_FAILED;
+        db->write_pos = lseek(db->file, 0, SEEK_CUR);
+
+        GST_INFO("Got entry: tag %u, hash %s, offset %#"PRIx64", size %#x, crc %#x.",
+                tag, format_hash(&entry.hash), entry.offset, entry.header.size, entry.header.crc);
+
+        /* Insert entry to hash table. */
+        if (tag >= db->num_tags)
+        {
+            GST_WARNING("Invalid tag %u.", tag);
+
+            /* Ignore unknown tags for read-only DBs. */
+            if (db->read_only)
+                continue;
+            else
+                return CONV_ERROR_INVALID_TAG;
+        }
+        table_entry = calloc(1, sizeof(*table_entry));
+        *table_entry = entry;
+        g_hash_table_insert(db->seen_blobs[tag], &table_entry->hash, table_entry);
+    }
+
+    return CONV_OK;
+}
+
+bool fozdb_has_entry(struct fozdb *db, uint32_t tag, struct payload_hash *hash)
+{
+    if (tag >= db->num_tags)
+        return false;
+    return g_hash_table_contains(db->seen_blobs[tag], hash);
+}
+
+int fozdb_entry_size(struct fozdb *db, uint32_t tag, struct payload_hash *hash, uint32_t *size)
+{
+    struct payload_entry *entry;
+
+    if (tag >= db->num_tags)
+        return CONV_ERROR_INVALID_TAG;
+    if (!(entry = g_hash_table_lookup(db->seen_blobs[tag], hash)))
+        return CONV_ERROR_ENTRY_NOT_FOUND;
+
+    *size = entry->header.full_size;
+
+    return CONV_OK;
+}
+
+void fozdb_iter_tag(struct fozdb *db, uint32_t tag, GHashTableIter *iter)
+{
+    if (tag > db->num_tags)
+    {
+        GST_ERROR("Invalid tag %u.", tag);
+        return;
+    }
+    g_hash_table_iter_init(iter, db->seen_blobs[tag]);
+}
+
+int fozdb_read_entry_data(struct fozdb *db, uint32_t tag, struct payload_hash *hash,
+        uint64_t offset, uint8_t *buffer, size_t size, size_t *read_size, bool with_crc)
+{
+    struct payload_entry *entry;
+    size_t to_copy;
+
+    GST_DEBUG("db %p, file_name %s, tag %u, hash %s, offset %#"PRIx64", buffer %p, size %zu, read_size %p, with_crc %d.",
+            db, db->file_name, tag, format_hash(hash), offset, buffer, size, read_size, with_crc);
+
+    if (tag >= db->num_tags)
+        return CONV_ERROR_INVALID_TAG;
+    if (!(entry = g_hash_table_lookup(db->seen_blobs[tag], hash)))
+        return CONV_ERROR_ENTRY_NOT_FOUND;
+
+    if (entry->header.compression != FOZDB_COMPRESSION_NONE)
+        return CONV_ERROR_NOT_IMPLEMENTED;
+
+    if (offset >= entry->header.full_size)
+        return CONV_OK;
+
+    if (lseek(db->file, entry->offset + offset, SEEK_SET) < 0)
+        return CONV_ERROR_SEEK_FAILED;
+
+    to_copy = min(entry->header.full_size - offset, size);
+    if (!complete_read(db->file, buffer, to_copy))
+    {
+        GST_ERROR("Failed to read entry data.");
+        return CONV_ERROR_READ_FAILED;
+    }
+    *read_size = to_copy;
+
+    if (entry->header.crc != 0 && with_crc && entry->header.crc != crc32(0, buffer, to_copy))
+    {
+        GST_ERROR("Wrong check sum.");
+        return CONV_ERROR_WRONG_CHECKSUM;
+    }
+
+    return CONV_OK;
+}
+
+int fozdb_write_entry(struct fozdb *db, uint32_t tag, struct payload_hash *hash,
+        void *data_src, data_read_callback read_callback, bool with_crc)
+{
+    struct payload_header header;
+    struct payload_entry *entry;
+    off_t header_offset;
+    uint32_t size = 0;
+    size_t read_size;
+    uint8_t *buffer;
+    uint64_t offset;
+    int ret;
+
+    GST_DEBUG("db %p, file_name %s, tag %u, hash %s, data_src %p, read_callback %p, with_crc %d.",
+            db, db->file_name, tag, format_hash(hash), data_src, read_callback, with_crc);
+
+    if (tag >= db->num_tags)
+    {
+        GST_ERROR("Invalid tag %u.", tag);
+        return CONV_ERROR_INVALID_TAG;
+    }
+    if (fozdb_has_entry(db, tag, hash))
+        return CONV_OK;
+
+    if (lseek(db->file, db->write_pos, SEEK_SET) < 0)
+    {
+        GST_ERROR("Failed to seek file to write_pos %#"PRIx64".", db->write_pos);
+        return CONV_ERROR_SEEK_FAILED;
+    }
+
+    /* Write entry name. */
+    if (!fozdb_write_entry_name(db, tag, hash))
+        return CONV_ERROR_WRITE_FAILED;
+
+    /* Write payload header first. */
+    header_offset = lseek(db->file, 0, SEEK_CUR);
+    header.size = UINT32_MAX;      /* Will be filled later. */
+    header.compression = FOZDB_COMPRESSION_NONE;
+    header.crc = 0;                /* Will be filled later. */
+    header.full_size = UINT32_MAX; /* Will be filled later. */
+    if (!complete_write(db->file, &header, sizeof(header)))
+    {
+        GST_ERROR("Failed to write entry header.");
+        return CONV_ERROR_WRITE_FAILED;
+    }
+    offset = lseek(db->file, 0, SEEK_CUR);
+
+    /* Write data. */
+    buffer = calloc(1, BUFFER_COPY_BYTES);
+    while ((ret = read_callback(data_src, buffer, BUFFER_COPY_BYTES, &read_size)) == CONV_OK)
+    {
+        if (size + read_size > UINT32_MAX)
+        {
+            GST_ERROR("Data too large. Fossilize format only supports 4 GB entries.");
+            free(buffer);
+            return CONV_ERROR;
+        }
+
+        size += read_size;
+        if (!complete_write(db->file, buffer, read_size))
+        {
+            GST_ERROR("Failed to write entry data.");
+            free(buffer);
+            return CONV_ERROR_WRITE_FAILED;
+        }
+
+        if (with_crc)
+            header.crc = crc32(header.crc, buffer, read_size);
+    }
+    db->write_pos = lseek(db->file, 0, SEEK_CUR);
+    free(buffer);
+    if (ret != CONV_ERROR_DATA_END)
+    {
+        GST_ERROR("Failed to read data from data src, ret %d.", ret);
+        return ret;
+    }
+
+    /* Seek back and fill in the size to header. */
+    if (lseek(db->file, header_offset, SEEK_SET) < 0)
+    {
+        GST_ERROR("Failed to seek back to entry header. %s.", strerror(errno));
+        return CONV_ERROR_SEEK_FAILED;
+    }
+    header.size = size;
+    header.full_size = size;
+    if (!complete_write(db->file, &header, sizeof(header)))
+    {
+        GST_ERROR("Failed to write entry header.");
+        return CONV_ERROR_WRITE_FAILED;
+    }
+
+    /* Success. Record entry and exit. */
+    entry = calloc(1, sizeof(*entry));
+    entry->header = header;
+    entry->hash = *hash;
+    entry->offset = offset;
+    g_hash_table_insert(db->seen_blobs[tag], &entry->hash, entry);
+
+    GST_INFO("Wrote entry: tag %u, hash %s, offset %#"PRIx64", size %#x, crc %#x.",
+            tag, format_hash(&entry->hash), entry->offset, entry->header.size, entry->header.crc);
+
+    return CONV_OK;
+}
+
+/* Rewrites the database, discarding entries listed. */
+int fozdb_discard_entries(struct fozdb *db, GList *to_discard_names)
+{
+    uint8_t entry_name_and_header[ENTRY_NAME_SIZE + sizeof(struct payload_header)];
+    uint64_t file_size;
+    int i, ret;
+
+    GST_DEBUG("db %p, file_name %s, to_discard_entries %p.", db, db->file_name, to_discard_names);
+
+    /* Rewind the file and clear the entry tables. */
+    if (lseek(db->file, 0, SEEK_SET) < 0)
+    {
+        GST_ERROR("Failed to seek to file start. %s.", strerror(errno));
+        return CONV_ERROR_SEEK_FAILED;
+    }
+    for (i = 0; i < db->num_tags; ++i)
+        g_hash_table_remove_all(db->seen_blobs[i]);
+
+    /* Read file header. */
+    if ((ret = fozdb_read_file_header(db)) < 0)
+        return ret;
+    db->write_pos = lseek(db->file, 0, SEEK_CUR);
+
+    /* Read each entry and see if it should be discarded. */
+    if (!get_file_size(db->file, &file_size))
+        return CONV_ERROR;
+    while (lseek(db->file, 0, SEEK_CUR) < file_size)
+    {
+        struct payload_header header;
+        uint64_t entry_data_offset;
+        struct entry_name name;
+        bool truncated;
+
+        if ((ret = fozdb_read_entry_tag_hash_header(db, &name.tag, &name.hash, &header) < 0))
+            return CONV_ERROR_READ_FAILED;
+        entry_data_offset = lseek(db->file, 0, SEEK_CUR);
+
+        /* Check if entry should be discarded. */
+        if (g_list_find_custom(to_discard_names, &name, entry_name_compare))
+        {
+            if (!fozdb_seek_to_next_entry(db, &header, &truncated))
+                return CONV_ERROR_SEEK_FAILED;
+            if (truncated)
+                break;
+        }
+        else
+        {
+            if (db->write_pos == entry_data_offset - sizeof(entry_name_and_header))
+            {
+                /* If we haven't dropped any chunks, we can just skip it rather than rewrite it. */
+                if (!fozdb_seek_to_next_entry(db, &header, &truncated))
+                    return CONV_ERROR_SEEK_FAILED;
+                if (truncated)
+                    break;
+                db->write_pos = lseek(db->file, 0, SEEK_CUR);
+            }
+            else
+            {
+                /* We're offset, so we have to rewrite. */
+                if ((ret = fozdb_copy_entry(db, &name, &header, entry_data_offset)) < 0)
+                    return ret;
+            }
+        }
+    }
+
+    if (ftruncate(db->file, db->write_pos) < 0)
+    {
+        GST_ERROR("Failed to truncate file. %s.", strerror(errno));
+        return CONV_ERROR;
+    }
+
+    return fozdb_prepare(db);
+}
diff --git a/dlls/winegstreamer/media-converter/lib.c b/dlls/winegstreamer/media-converter/lib.c
new file mode 100644
index 00000000000..852bf7b6bc4
--- /dev/null
+++ b/dlls/winegstreamer/media-converter/lib.c
@@ -0,0 +1,329 @@
+/*
+ * Copyright 2024 Ziqing Hui for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "media-converter.h"
+
+GST_ELEMENT_REGISTER_DECLARE(protonvideoconverter);
+GST_ELEMENT_REGISTER_DECLARE(protonaudioconverter);
+GST_ELEMENT_REGISTER_DECLARE(protonaudioconverterbin);
+
+GST_DEBUG_CATEGORY(media_converter_debug);
+
+static void get_dirname(const char *path, char *result)
+{
+    size_t i;
+
+    for (i = strlen(path) - 1; i > 0; --i)
+    {
+        if (path[i] == '\\' || path[i] == '/')
+            break;
+    }
+
+    memcpy(result, path, i);
+    result[i] = 0;
+}
+
+static void path_concat(char *result, const char *a, const char *b)
+{
+    size_t a_len, b_offset;
+
+    a_len = strlen(a);
+    b_offset = a_len;
+    memcpy(result, a, a_len);
+
+    if (result[a_len - 1] != '/')
+    {
+        result[a_len] = '/';
+        ++b_offset;
+    }
+
+    strcpy(result + b_offset, b);
+}
+
+static bool create_all_dir(const char *dir)
+{
+    char *ptr, buffer[4096] = {0};
+
+    strcpy(buffer, dir);
+    if (buffer[strlen(dir) - 1] != '/')
+        buffer[strlen(dir)] = '/';
+
+    ptr = strchr(buffer + 1, '/');
+    while (ptr)
+    {
+        *ptr = '\0';
+
+        if (mkdir(buffer, 0777) < 0)
+        {
+            if (errno != EEXIST)
+            {
+                GST_ERROR("Failed to make directory %s. %s.", buffer, strerror(errno));
+                return false;
+            }
+        }
+        *ptr = '/';
+
+        ptr = strchr(ptr + 1, '/');
+    }
+    return true;
+}
+
+static int create_file(const char *file_name)
+{
+    int fd, ret = CONV_OK;
+    char dir[4096];
+
+    get_dirname(file_name, dir);
+    if (access(dir, F_OK) < 0 && !create_all_dir(dir))
+        return CONV_ERROR_PATH_NOT_FOUND;
+
+    if ((fd = open(file_name, O_CREAT,  S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) < 0)
+    {
+        GST_WARNING("Failed to open file %s with O_CREAT. %s.", file_name, strerror(errno));
+        return CONV_ERROR_OPEN_FAILED;
+    }
+
+    if (futimens(fd, NULL) < 0)
+    {
+        GST_WARNING("Failed to set file %s timestamps. %s.", file_name, strerror(errno));
+        ret = CONV_ERROR;
+    }
+
+    close(fd);
+
+    return ret;
+}
+
+bool open_file(const char *file_name, int open_flags, int *out_fd)
+{
+    int fd;
+
+    if ((fd = open(file_name, open_flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) < 0)
+    {
+        GST_WARNING("Failed to open %s with flags %d. %s.", file_name, open_flags, strerror(errno));
+        return false;
+    }
+
+    *out_fd = fd;
+    return true;
+}
+
+bool get_file_size(int fd, uint64_t *file_size)
+{
+    struct stat file_info;
+
+    if (fstat(fd, &file_info) < 0)
+    {
+        GST_WARNING("Failed to fstat fd %d. %s.", fd, strerror(errno));
+        return false;
+    }
+
+    *file_size = file_info.st_size;
+    return true;
+}
+
+bool complete_read(int file, void *buffer, size_t size)
+{
+    size_t current_read = 0;
+    ssize_t read_size;
+    errno = 0;
+
+    while (current_read < size)
+    {
+        read_size = read(file, ((char *)buffer) + current_read, size - current_read);
+        if(read_size <= 0)
+        {
+            if(errno != EINTR && errno != EAGAIN)
+                return false;
+        }
+        else
+        {
+            current_read += read_size;
+        }
+    }
+
+    return current_read == size;
+}
+
+bool complete_write(int file, const void *buffer, size_t size)
+{
+    size_t current_write = 0;
+    ssize_t write_size;
+    errno = 0;
+
+    while (current_write < size)
+    {
+        write_size = write(file, (const char *)buffer + current_write, size - current_write);
+        if(write_size < 0)
+        {
+            if(errno != EINTR && errno != EAGAIN)
+                return false;
+        }
+        else
+        {
+            current_write += write_size;
+        }
+    }
+
+    return current_write == size;
+}
+
+uint32_t crc32(uint32_t crc, const uint8_t *ptr, size_t buf_len)
+{
+    static const uint32_t s_crc_table[256] =
+    {
+        0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535,
+        0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd,
+        0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d,
+        0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec,
+        0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,
+        0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
+        0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac,
+        0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
+        0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab,
+        0xb6662d3d, 0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,
+        0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb,
+        0x086d3d2d, 0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
+        0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea,
+        0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, 0x4db26158, 0x3ab551ce,
+        0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,
+        0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
+        0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409,
+        0xce61e49f, 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
+        0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739,
+        0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
+        0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344, 0x8708a3d2, 0x1e01f268,
+        0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0,
+        0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8,
+        0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
+        0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,
+        0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703,
+        0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7,
+        0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a,
+        0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae,
+        0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
+        0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777, 0x88085ae6,
+        0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
+        0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d,
+        0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5,
+        0x47b2cf7f, 0x30b5ffe9, 0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,
+        0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
+        0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d,
+    };
+    uint32_t crc32 = (uint32_t)crc ^ 0xffffffff;
+    const uint8_t *buffer = (const uint8_t *)ptr;
+
+    while (buf_len >= 4)
+    {
+        crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ buffer[0]) & 0xff];
+        crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ buffer[1]) & 0xff];
+        crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ buffer[2]) & 0xff];
+        crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ buffer[3]) & 0xff];
+        buffer += 4;
+        buf_len -= 4;
+    }
+
+    while (buf_len)
+    {
+        crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ buffer[0]) & 0xff];
+        ++buffer;
+        --buf_len;
+    }
+
+    return ~crc32;
+}
+
+int create_placeholder_file(const char *file_name)
+{
+    const char *shader_path;
+    char path[1024];
+    int ret;
+
+    if ((shader_path = getenv("STEAM_COMPAT_TRANSCODED_MEDIA_PATH")))
+    {
+        path_concat(path, shader_path, file_name);
+        if ((ret = create_file(path)) < 0)
+            GST_ERROR("Failed to create %s file, ret %d.", file_name, ret);
+    }
+    else
+    {
+        GST_ERROR("Env STEAM_COMPAT_TRANSCODED_MEDIA_PATH not set.");
+        ret = CONV_ERROR_ENV_NOT_SET;
+    }
+
+    return ret;
+}
+
+int dump_fozdb_open(struct dump_fozdb *db, bool create, const char *file_path_env, int num_tags)
+{
+    char *dump_file_path;
+
+    if (db->fozdb)
+        return CONV_OK;
+
+    if (!(dump_file_path = getenv(file_path_env)))
+    {
+        GST_ERROR("Env %s not set.", file_path_env);
+        return CONV_ERROR_ENV_NOT_SET;
+    }
+
+    if (create)
+        create_file(dump_file_path);
+
+    return fozdb_create(dump_file_path, O_RDWR, false, num_tags, &db->fozdb);
+}
+
+void dump_fozdb_close(struct dump_fozdb *db)
+{
+    if (db->fozdb)
+    {
+        fozdb_release(db->fozdb);
+        db->fozdb = NULL;
+    }
+}
+
+bool media_converter_init(void)
+{
+    GST_DEBUG_CATEGORY_INIT(media_converter_debug,
+            "protonmediaconverter", GST_DEBUG_FG_YELLOW, "Proton media converter");
+
+    if (!GST_ELEMENT_REGISTER(protonvideoconverter, NULL))
+    {
+        GST_ERROR("Failed to register protonvideoconverter.");
+        return false;
+    }
+
+    if (!GST_ELEMENT_REGISTER(protonaudioconverter, NULL))
+    {
+        GST_ERROR("Failed to register protonaudioconverter.");
+        return false;
+    }
+
+    if (!GST_ELEMENT_REGISTER(protonaudioconverterbin, NULL))
+    {
+        GST_ERROR("Failed to register protonaudioconverterbin.");
+        return false;
+    }
+
+    return true;
+}
diff --git a/dlls/winegstreamer/media-converter/media-converter.h b/dlls/winegstreamer/media-converter/media-converter.h
new file mode 100644
index 00000000000..8cd4b31344a
--- /dev/null
+++ b/dlls/winegstreamer/media-converter/media-converter.h
@@ -0,0 +1,290 @@
+/*
+ * Copyright 2024 Ziqing Hui for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __MEDIA_CONVERTER_H__
+#define __MEDIA_CONVERTER_H__
+
+#define _FILE_OFFSET_BITS 64
+
+#include <string.h>
+#include <utime.h>
+#include <stdarg.h>
+#include <inttypes.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+
+#include "unix_private.h"
+
+GST_DEBUG_CATEGORY_EXTERN(media_converter_debug);
+#undef GST_CAT_DEFAULT
+#define GST_CAT_DEFAULT media_converter_debug
+
+typedef int (*data_read_callback)(void *data_reader, uint8_t *buffer, size_t size, size_t *read_size);
+
+/* Changing this will invalidate the cache. You MUST clear it. */
+#define HASH_SEED 0x4AA61F63
+
+enum conv_ret
+{
+    CONV_OK = 0,
+    CONV_ERROR = -1,
+    CONV_ERROR_NOT_IMPLEMENTED = -2,
+    CONV_ERROR_INVALID_ARGUMENT = -3,
+    CONV_ERROR_OPEN_FAILED = -4,
+    CONV_ERROR_READ_FAILED = -5,
+    CONV_ERROR_WRITE_FAILED = -6,
+    CONV_ERROR_SEEK_FAILED = -7,
+    CONV_ERROR_CORRUPT_DATABASE = -8,
+    CONV_ERROR_WRONG_CHECKSUM = -9,
+    CONV_ERROR_ENTRY_NOT_FOUND = -10,
+    CONV_ERROR_ENV_NOT_SET = -11,
+    CONV_ERROR_PATH_NOT_FOUND = -12,
+    CONV_ERROR_INVALID_TAG = -13,
+    CONV_ERROR_DATA_END = -14,
+};
+
+struct murmur3_x64_128_state
+{
+    uint32_t seed;
+    uint64_t h1;
+    uint64_t h2;
+    size_t processed;
+};
+
+struct murmur3_x86_128_state
+{
+    uint32_t seed;
+    uint32_t h1;
+    uint32_t h2;
+    uint32_t h3;
+    uint32_t h4;
+    size_t processed;
+};
+
+struct bytes_reader
+{
+    const uint8_t *data;
+    size_t size;
+    size_t offset;
+};
+
+struct gst_buffer_reader
+{
+    GstBuffer *buffer; /* No ref here, no need to unref. */
+    size_t offset;
+};
+
+struct payload_hash
+{
+    uint32_t hash[4];
+};
+
+struct entry_name
+{
+    uint32_t tag;
+    struct payload_hash hash;
+};
+
+struct dump_fozdb
+{
+    pthread_mutex_t mutex;
+    struct fozdb *fozdb;
+    bool already_cleaned;
+};
+
+struct fozdb
+{
+    const char *file_name;
+    int file;
+    bool read_only;
+    uint64_t write_pos;
+    GHashTable **seen_blobs;
+    uint32_t num_tags;
+};
+
+/* lib.c. */
+extern bool open_file(const char *file_name, int open_flags, int *out_fd);
+extern bool get_file_size(int fd, uint64_t *file_size);
+extern bool complete_read(int file, void *buffer, size_t size);
+extern bool complete_write(int file, const void *buffer, size_t size);
+extern uint32_t crc32(uint32_t crc, const uint8_t *ptr, size_t buf_len);
+extern int create_placeholder_file(const char *file_name);
+extern int dump_fozdb_open(struct dump_fozdb *db, bool create, const char *file_path_env, int num_tags);
+extern void dump_fozdb_close(struct dump_fozdb *db);
+
+/* murmur3.c. */
+extern void murmur3_x64_128_state_init(struct murmur3_x64_128_state *state, uint32_t seed);
+extern void murmur3_x64_128_state_reset(struct murmur3_x64_128_state *state);
+extern bool murmur3_x64_128_full(void *data_src, data_read_callback read_callback,
+        struct murmur3_x64_128_state* state, void *out);
+extern bool murmur3_x64_128(void *data_src, data_read_callback read_callback, uint32_t seed, void *out);
+extern void murmur3_x86_128_state_init(struct murmur3_x86_128_state *state, uint32_t seed);
+extern void murmur3_x86_128_state_reset(struct murmur3_x86_128_state *state);
+extern bool murmur3_x86_128_full(void *data_src, data_read_callback read_callback,
+        struct murmur3_x86_128_state* state, void *out);
+extern bool murmur3_x86_128(void *data_src, data_read_callback read_callback, uint32_t seed, void *out);
+#if defined(__x86_64__) || defined(__aarch64__)
+#define murmur3_128_state       murmur3_x64_128_state
+#define murmur3_128_state_init  murmur3_x64_128_state_init
+#define murmur3_128_state_reset murmur3_x64_128_state_reset
+#define murmur3_128_full        murmur3_x64_128_full
+#define murmur3_128             murmur3_x64_128
+#elif defined(__i386__)
+#define murmur3_128_state       murmur3_x86_128_state
+#define murmur3_128_state_init  murmur3_x86_128_state_init
+#define murmur3_128_state_reset murmur3_x86_128_state_reset
+#define murmur3_128_full        murmur3_x86_128_full
+#define murmur3_128             murmur3_x86_128
+#endif /* __x86_64__ */
+
+/* fossilize.c. */
+extern int fozdb_create(const char *file_name, int open_flags, bool read_only, uint32_t num_tags, struct fozdb **out);
+extern void fozdb_release(struct fozdb *db);
+extern int fozdb_prepare(struct fozdb *db);
+extern bool fozdb_has_entry(struct fozdb *db, uint32_t tag, struct payload_hash *hash);
+extern int fozdb_entry_size(struct fozdb *db, uint32_t tag, struct payload_hash *hash, uint32_t *size);
+extern void fozdb_iter_tag(struct fozdb *db, uint32_t tag, GHashTableIter *iter);
+extern int fozdb_read_entry_data(struct fozdb *db, uint32_t tag, struct payload_hash *hash,
+        uint64_t offset, uint8_t *buffer, size_t size, size_t *read_size, bool with_crc);
+extern int fozdb_write_entry(struct fozdb *db, uint32_t tag, struct payload_hash *hash,
+        void *data_src, data_read_callback read_callback, bool with_crc);
+extern int fozdb_discard_entries(struct fozdb *db, GList *to_discard_entries);
+
+static inline bool option_enabled(const char *env)
+{
+    const char *env_var;
+
+    if (!(env_var = getenv(env)))
+        return false;
+
+    return strcmp(env_var, "0") != 0;
+}
+
+static inline bool discarding_disabled(void)
+{
+    return option_enabled("MEDIACONV_DONT_DISCARD");
+}
+
+static inline const char *format_hash(struct payload_hash *hash)
+{
+    int hash_str_size = 2 + sizeof(*hash) * 2 + 1;
+    static char buffer[1024] = {};
+    static int offset = 0;
+    char *ret;
+
+    if (offset + hash_str_size > sizeof(buffer))
+        offset = 0;
+
+    ret = buffer + offset;
+    sprintf(ret, "0x%08x%08x%08x%08x", hash->hash[3], hash->hash[2], hash->hash[1], hash->hash[0]);
+    offset += hash_str_size;
+
+    return ret;
+}
+
+static inline void bytes_reader_init(struct bytes_reader *reader, const uint8_t *data, size_t size)
+{
+    reader->data = data;
+    reader->size = size;
+    reader->offset = 0;
+}
+
+static inline int bytes_reader_read(void *data_reader, uint8_t *buffer, size_t size, size_t *read_size)
+{
+    struct bytes_reader *reader = data_reader;
+    size_t data_size, to_copy;
+
+    if (!size)
+    {
+        *read_size = 0;
+        return CONV_OK;
+    }
+
+    if (!(data_size = reader->size - reader->offset))
+        return CONV_ERROR_DATA_END;
+
+    to_copy = min(data_size, size);
+    memcpy(buffer, reader->data + reader->offset, to_copy);
+    reader->offset += to_copy;
+
+    *read_size = to_copy;
+    return CONV_OK;
+}
+
+static inline void gst_buffer_reader_init(struct gst_buffer_reader *reader, GstBuffer *buffer)
+{
+    reader->buffer = buffer; /* No ref here, so no need to unref. */
+    reader->offset = 0;
+}
+
+static inline int gst_buffer_reader_read(void *data_reader, uint8_t *buffer, size_t size, size_t *read_size)
+{
+    struct gst_buffer_reader *reader = data_reader;
+
+    if (!size)
+    {
+        *read_size = 0;
+        return CONV_OK;
+    }
+
+    *read_size = gst_buffer_extract(reader->buffer, reader->offset, buffer, size);
+    reader->offset += *read_size;
+    if (!*read_size)
+        return CONV_ERROR_DATA_END;
+
+    return CONV_OK;
+}
+
+static inline bool file_exists(const char *file_path)
+{
+    if (!file_path)
+        return false;
+    return access(file_path, F_OK) == 0;
+}
+
+static inline struct entry_name *entry_name_create(uint32_t tag, struct payload_hash *hash)
+{
+    struct entry_name *entry = calloc(1, sizeof(*entry));
+    entry->tag = tag;
+    entry->hash = *hash;
+    return entry;
+}
+
+static inline gint entry_name_compare(const void *a, const void *b)
+{
+    return memcmp(a, b, sizeof(struct entry_name));
+}
+
+static inline uint32_t bytes_to_uint32(const uint8_t *bytes)
+{
+    return ((uint32_t)bytes[0] << 0)
+            | ((uint32_t)bytes[1] << 8)
+            | ((uint32_t)bytes[2] << 16)
+            | ((uint32_t)bytes[3] << 24);
+}
+
+static inline void payload_hash_from_bytes(struct payload_hash *hash, uint8_t *bytes)
+{
+    hash->hash[0] = bytes_to_uint32(bytes + 0);
+    hash->hash[1] = bytes_to_uint32(bytes + 4);
+    hash->hash[2] = bytes_to_uint32(bytes + 8);
+    hash->hash[3] = bytes_to_uint32(bytes + 12);
+}
+
+#endif /* __MEDIA_CONVERTER_H__ */
diff --git a/dlls/winegstreamer/media-converter/murmur3.c b/dlls/winegstreamer/media-converter/murmur3.c
new file mode 100644
index 00000000000..014345e61d5
--- /dev/null
+++ b/dlls/winegstreamer/media-converter/murmur3.c
@@ -0,0 +1,371 @@
+/*
+ * Copyright 2024 Ziqing Hui for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "media-converter.h"
+
+static uint64_t rotl64(uint64_t value, uint8_t shift)
+{
+    return (value << shift) | (value >> (64 - shift));
+}
+
+static uint32_t rotl32(uint32_t value, uint8_t shift)
+{
+    return (value << shift) | (value >> (32 - shift));
+}
+
+static uint64_t fmix64(uint64_t h)
+{
+    const uint64_t c1 = 0xff51afd7ed558ccd;
+    const uint64_t c2 = 0xc4ceb9fe1a85ec53;
+    const uint32_t r = 33;
+
+    h ^= h >> r;
+    h *= c1;
+    h ^= h >> r;
+    h *= c2;
+    h ^= h >> r;
+
+    return h;
+}
+
+static uint32_t fmix32 (uint32_t h)
+{
+    const uint32_t c1 = 0x85ebca6b;
+    const uint32_t c2 = 0xc2b2ae35;
+    const uint32_t r1 = 16;
+    const uint32_t r2 = 13;
+
+    h ^= h >> r1;
+    h *= c1;
+    h ^= h >> r2;
+    h *= c2;
+    h ^= h >> r1;
+
+    return h;
+}
+
+void murmur3_x64_128_state_init(struct murmur3_x64_128_state *state, uint32_t seed)
+{
+    state->seed = seed;
+    state->h1 = seed;
+    state->h2 = seed;
+    state->processed = 0;
+}
+
+void murmur3_x64_128_state_reset(struct murmur3_x64_128_state *state)
+{
+    state->h1 = state->seed;
+    state->h2 = state->seed;
+    state->processed = 0;
+}
+
+bool murmur3_x64_128_full(void *data_reader, data_read_callback read_callback,
+        struct murmur3_x64_128_state* state, void *out)
+{
+    const uint64_t c1 = 0x87c37b91114253d5, c2 = 0x4cf5ad432745937f, c3 = 0x52dce729, c4 = 0x38495ab5, m = 5;
+    size_t read_size, processed = state->processed;
+    const uint32_t r1 = 27, r2 = 31, r3 = 33;
+    uint64_t h1 = state->h1, h2 = state->h2;
+    uint8_t buffer[16] = {0};
+    uint64_t k1, k2;
+    int ret;
+
+    while ((ret = read_callback(data_reader, buffer, sizeof(buffer), &read_size)) == CONV_OK)
+    {
+        processed += read_size;
+
+        if (read_size == 16)
+        {
+            k1 = *(uint64_t *)&buffer[0];
+            k2 = *(uint64_t *)&buffer[8];
+
+            k1 *= c1;
+            k1 = rotl64(k1, r2);
+            k1 *= c2;
+            h1 ^= k1;
+            h1 = rotl64(h1, r1);
+            h1 += h2;
+            h1 = h1 * m + c3;
+
+            k2 *= c2;
+            k2 = rotl64(k2, r3);
+            k2 *= c1;
+            h2 ^= k2;
+            h2 = rotl64(h2, r2);
+            h2 += h1;
+            h2 = h2 * m + c4;
+        }
+        else
+        {
+            k1 = 0;
+            k2 = 0;
+
+            switch (read_size)
+            {
+            case 15:
+                k2 ^= ((uint64_t)buffer[14]) << 48;
+            case 14:
+                k2 ^= ((uint64_t)buffer[13]) << 40;
+            case 13:
+                k2 ^= ((uint64_t)buffer[12]) << 32;
+            case 12:
+                k2 ^= ((uint64_t)buffer[11]) << 24;
+            case 11:
+                k2 ^= ((uint64_t)buffer[10]) << 16;
+            case 10:
+                k2 ^= ((uint64_t)buffer[9]) << 8;
+            case 9:
+                k2 ^= ((uint64_t)buffer[8]) << 0;
+                k2 *= c2;
+                k2  = rotl64(k2, r3);
+                k2 *= c1;
+                h2 ^= k2;
+            case 8:
+                k1 ^= ((uint64_t)buffer[7]) << 56;
+            case 7:
+                k1 ^= ((uint64_t)buffer[6]) << 48;
+            case 6:
+                k1 ^= ((uint64_t)buffer[5]) << 40;
+            case 5:
+                k1 ^= ((uint64_t)buffer[4]) << 32;
+            case 4:
+                k1 ^= ((uint64_t)buffer[3]) << 24;
+            case 3:
+                k1 ^= ((uint64_t)buffer[2]) << 16;
+            case 2:
+                k1 ^= ((uint64_t)buffer[1]) << 8;
+            case 1:
+                k1 ^= ((uint64_t)buffer[0]) << 0;
+                k1 *= c1;
+                k1  = rotl64(k1, r2);
+                k1 *= c2;
+                h1 ^= k1;
+            }
+        }
+    }
+
+    if (ret != CONV_ERROR_DATA_END)
+        return false;
+
+    state->processed = processed;
+    state->h1 = h1;
+    state->h2 = h2;
+
+    h1 ^= (uint64_t)processed;
+    h2 ^= (uint64_t)processed;
+    h1 += h2;
+    h2 += h1;
+    h1 = fmix64(h1);
+    h2 = fmix64(h2);
+    h1 += h2;
+    h2 += h1;
+
+    ((uint64_t *)out)[0] = h1;
+    ((uint64_t *)out)[1] = h2;
+
+    return true;
+}
+
+bool murmur3_x64_128(void *data_src, data_read_callback read_callback, uint32_t seed, void *out)
+{
+    struct murmur3_x64_128_state state;
+    murmur3_x64_128_state_init(&state, seed);
+    return murmur3_x64_128_full(data_src, read_callback, &state, out);
+}
+
+void murmur3_x86_128_state_init(struct murmur3_x86_128_state *state, uint32_t seed)
+{
+    state->seed = seed;
+    state->h1 = seed;
+    state->h2 = seed;
+    state->h3 = seed;
+    state->h4 = seed;
+    state->processed = 0;
+}
+
+void murmur3_x86_128_state_reset(struct murmur3_x86_128_state *state)
+{
+    state->h1 = state->seed;
+    state->h2 = state->seed;
+    state->h3 = state->seed;
+    state->h4 = state->seed;
+    state->processed = 0;
+}
+
+bool murmur3_x86_128_full(void *data_reader, data_read_callback read_callback,
+        struct murmur3_x86_128_state *state, void *out)
+{
+    const uint32_t c1 = 0x239b961b, c2 = 0xab0e9789, c3 = 0x38b34ae5, c4 = 0xa1e38b93;
+    const uint32_t c5 = 0x561ccd1b, c6 = 0x0bcaa747, c7 = 0x96cd1c35, c8 = 0x32ac3b17;
+    uint32_t h1 = state->h1, h2 = state->h2, h3 = state->h3, h4 = state->h4;
+    size_t read_size, processed = state->processed;
+    unsigned char buffer[16] = {0};
+    uint64_t k1, k2, k3, k4;
+    const uint32_t m = 5;
+    int ret;
+
+    while ((ret = read_callback(data_reader, buffer, sizeof(buffer), &read_size)) == CONV_OK)
+    {
+        processed += read_size;
+
+        if (read_size == 16)
+        {
+            k1 = *(uint32_t*)&buffer[0];
+            k2 = *(uint32_t*)&buffer[4];
+            k3 = *(uint32_t*)&buffer[8];
+            k4 = *(uint32_t*)&buffer[12];
+
+            k1 *= c1;
+            k1 = rotl32(k1, 15);
+            k1 *= c2;
+            h1 ^= k1;
+            h1 = rotl32(h1, 19);
+            h1 += h2;
+            h1 = h1 * m + c5;
+
+            k2 *= c2;
+            k2 = rotl32(k2, 16);
+            k2 *= c3;
+            h2 ^= k2;
+            h2 = rotl32(h2, 17);
+            h2 += h3;
+            h2 = h2 * m + c6;
+
+            k3 *= c3;
+            k3 = rotl32(k3, 17);
+            k3 *= c4;
+            h3 ^= k3;
+            h3 = rotl32(h3, 15);
+            h3 += h4;
+            h3 = h3 * m + c7;
+
+            k4 *= c4;
+            k4 = rotl32(k4, 18);
+            k4 *= c1;
+            h4 ^= k4;
+            h4 = rotl32(h4, 13);
+            h4 += h1;
+            h4 = h4 * m + c8;
+        }
+        else
+        {
+            k1 = 0;
+            k2 = 0;
+            k3 = 0;
+            k4 = 0;
+
+            switch (read_size)
+            {
+            case 15:
+                k4 ^= buffer[14] << 16;
+            case 14:
+                k4 ^= buffer[13] << 8;
+            case 13:
+                k4 ^= buffer[12] << 0;
+                k4 *= c4;
+                k4 = rotl32(k4,18);
+                k4 *= c1;
+                h4 ^= k4;
+            case 12:
+                k3 ^= buffer[11] << 24;
+            case 11:
+                k3 ^= buffer[10] << 16;
+            case 10:
+                k3 ^= buffer[9] << 8;
+            case 9:
+                k3 ^= buffer[8] << 0;
+                k3 *= c3;
+                k3 = rotl32(k3, 17);
+                k3 *= c4;
+                h3 ^= k3;
+            case 8:
+                k2 ^= buffer[7] << 24;
+            case 7:
+                k2 ^= buffer[6] << 16;
+            case 6:
+                k2 ^= buffer[5] << 8;
+            case 5:
+                k2 ^= buffer[4] << 0;
+                k2 *= c2;
+                k2 = rotl32(k2, 16);
+                k2 *= c3;
+                h2 ^= k2;
+            case 4:
+                k1 ^= buffer[3] << 24;
+            case 3:
+                k1 ^= buffer[2] << 16;
+            case 2:
+                k1 ^= buffer[1] << 8;
+            case 1:
+                k1 ^= buffer[0] << 0;
+                k1 *= c1;
+                k1 = rotl32(k1, 15);
+                k1 *= c2;
+                h1 ^= k1;
+            }
+        }
+    }
+
+    if (ret != CONV_ERROR_DATA_END)
+        return false;
+
+    state->processed = processed;
+    state->h1 = h1;
+    state->h2 = h2;
+    state->h3 = h3;
+    state->h4 = h4;
+
+    h1 ^= processed;
+    h2 ^= processed;
+    h3 ^= processed;
+    h4 ^= processed;
+    h1 += h2;
+    h1 += h3;
+    h1 += h4;
+    h2 += h1;
+    h3 += h1;
+    h4 += h1;
+    h1 = fmix32(h1);
+    h2 = fmix32(h2);
+    h3 = fmix32(h3);
+    h4 = fmix32(h4);
+    h1 += h2;
+    h1 += h3;
+    h1 += h4;
+    h2 += h1;
+    h3 += h1;
+    h4 += h1;
+
+    ((uint32_t*)out)[0] = h1;
+    ((uint32_t*)out)[1] = h2;
+    ((uint32_t*)out)[2] = h3;
+    ((uint32_t*)out)[3] = h4;
+
+    return true;
+}
+
+bool murmur3_x86_128(void *data_src, data_read_callback read_callback, uint32_t seed, void *out)
+{
+    struct murmur3_x86_128_state state;
+    murmur3_x86_128_state_init(&state, seed);
+    return murmur3_x86_128_full(data_src, read_callback, &state, out);
+}
diff --git a/dlls/winegstreamer/media-converter/videoconv.c b/dlls/winegstreamer/media-converter/videoconv.c
new file mode 100644
index 00000000000..b91aa96f1bf
--- /dev/null
+++ b/dlls/winegstreamer/media-converter/videoconv.c
@@ -0,0 +1,938 @@
+/*
+ * Copyright 2024 Ziqing Hui for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+/* Algorithm
+ * ---------
+ *
+ * Nicely, both Quartz and Media Foundation allow us random access to the entire data stream. So we
+ * can easily hash the entire incoming stream and substitute it with our Ogg Theora video. If there
+ * is a cache miss, then we dump the entire incoming stream. In case of a cache hit, we dump
+ * nothing.
+ *
+ * Incoming video data is stored in the video.foz Fossilize database.
+ *
+ * Transcoded video data is stored in the transcoded_video.foz Fossilize database.
+ *
+ *
+ * Hashing algorithm
+ * -----------------
+ *
+ * We use murmur3 hash with the seed given below. We use the x32 variant for 32-bit programs, and
+ * the x64 variant for 64-bit programs.
+ *
+ * For speed when hashing, we specify a stride which will skip over chunks of the input. However,
+ * we will always hash the first "stride" number of bytes, to try to avoid collisions on smaller
+ * files with size between chunk and stride.
+ *
+ * For example, the 'H's below are hashed, the 'x's are skipped:
+ *
+ * int chunk = 4;
+ * int stride = chunk * 3;
+ * H = hashed, x = skipped
+ * [HHHH HHHH HHHH HHHH xxxx xxxx HHHH xxxx xxxx HHHH xxxx] < data stream
+ *  ^^^^ ^^^^ ^^^^ stride prefix, hashed
+ *                 ^^^^ chunk
+ *                 ^^^^ ^^^^ ^^^^ stride
+ *                                ^^^^ chunk
+ *                                ^^^^ ^^^^ ^^^^ stride
+ *                                               ^^^^ chunk
+ *                                               ^^^^ ^^^^ stride
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "media-converter.h"
+
+#include <assert.h>
+
+#define HASH_CHUNK_SIZE (8 * 1024 * 1024) /* 8 MB. */
+#define HASH_STRIDE     (HASH_CHUNK_SIZE * 6)
+
+#define VIDEO_CONV_FOZ_TAG_VIDEODATA 0
+#define VIDEO_CONV_FOZ_TAG_OGVDATA   1
+#define VIDEO_CONV_FOZ_TAG_STREAM    2
+#define VIDEO_CONV_FOZ_TAG_MKVDATA   3
+#define VIDEO_CONV_FOZ_NUM_TAGS      4
+
+#define DURATION_NONE (UINT64_MAX)
+
+struct pad_reader
+{
+    GstPad *pad;
+    size_t offset;
+    uint8_t *chunk;
+    size_t chunk_offset;
+    size_t chunk_end;
+    size_t stride; /* Set to SIZE_MAX to skip no bytes. */
+};
+
+struct hashes_reader
+{
+    GList *current_hash;
+};
+
+struct video_conv_state
+{
+    struct payload_hash transcode_hash;
+    struct fozdb *read_fozdb;
+    uint64_t upstream_duration;
+    uint64_t our_duration;
+    uint32_t transcoded_tag;
+    bool has_transcoded, need_stream_start;
+};
+
+typedef struct
+{
+    GstElement element;
+    GstPad *sink_pad, *src_pad;
+    pthread_mutex_t state_mutex;
+    struct video_conv_state *state;
+} VideoConv;
+
+typedef struct
+{
+    GstElementClass class;
+} VideoConvClass;
+
+G_DEFINE_TYPE(VideoConv, video_conv, GST_TYPE_ELEMENT);
+#define VIDEO_CONV_TYPE (video_conv_get_type())
+#define VIDEO_CONV(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), VIDEO_CONV_TYPE, VideoConv))
+#define parent_class    (video_conv_parent_class)
+GST_ELEMENT_REGISTER_DEFINE(protonvideoconverter, "protonvideoconverter",
+        GST_RANK_MARGINAL, VIDEO_CONV_TYPE);
+
+static GstStaticPadTemplate video_conv_sink_template = GST_STATIC_PAD_TEMPLATE("sink",
+        GST_PAD_SINK, GST_PAD_ALWAYS,
+        GST_STATIC_CAPS("video/x-ms-asf; video/x-msvideo; video/mpeg; video/quicktime;"));
+
+static GstStaticPadTemplate video_conv_src_template = GST_STATIC_PAD_TEMPLATE("src",
+        GST_PAD_SRC, GST_PAD_ALWAYS,
+        GST_STATIC_CAPS("video/x-matroska; application/ogg;"));
+
+static struct dump_fozdb dump_fozdb = {PTHREAD_MUTEX_INITIALIZER, NULL, false};
+
+void hashes_reader_init(struct hashes_reader *reader, GList *hashes)
+{
+    reader->current_hash = hashes;
+}
+
+static int hashes_reader_read(void *reader, uint8_t *buffer, size_t size, size_t *read_size)
+{
+    struct payload_hash *hash = (struct payload_hash *)buffer;
+    struct hashes_reader *hashes_reader = reader;
+
+    if (!size)
+    {
+        *read_size = 0;
+        return CONV_OK;
+    }
+
+    if (!hashes_reader->current_hash)
+        return CONV_ERROR_DATA_END;
+
+    *hash = *(struct payload_hash *)(hashes_reader->current_hash->data);
+    hashes_reader->current_hash = hashes_reader->current_hash->next;
+
+    *read_size = sizeof(*hash);
+    return CONV_OK;
+}
+
+static int dump_fozdb_open_video(bool create)
+{
+    return dump_fozdb_open(&dump_fozdb, create, "MEDIACONV_VIDEO_DUMP_FILE", VIDEO_CONV_FOZ_NUM_TAGS);
+}
+
+static void dump_fozdb_discard_transcoded(void)
+{
+    GList *to_discard_chunks = NULL;
+    struct payload_hash *stream_id;
+    struct fozdb *read_fozdb;
+    char *read_fozdb_path;
+    GHashTableIter iter;
+    int ret;
+
+    if (dump_fozdb.already_cleaned)
+        return;
+    dump_fozdb.already_cleaned = true;
+
+    if (discarding_disabled())
+        return;
+    if (!file_exists(getenv("MEDIACONV_VIDEO_DUMP_FILE")))
+        return;
+
+    if (dump_fozdb_open_video(false) < 0)
+        return;
+
+    if (!(read_fozdb_path = getenv("MEDIACONV_VIDEO_TRANSCODED_FILE")))
+    {
+        GST_ERROR("Env MEDIACONV_VIDEO_TRANSCODED_FILE not set.");
+        return;
+    }
+
+    if ((ret = fozdb_create(read_fozdb_path, O_RDONLY, true /* Read-only?  */, VIDEO_CONV_FOZ_NUM_TAGS, &read_fozdb)) < 0)
+    {
+        GST_ERROR("Failed to create read fozdb, ret %d.", ret);
+        return;
+    }
+
+    fozdb_iter_tag(dump_fozdb.fozdb, VIDEO_CONV_FOZ_TAG_STREAM, &iter);
+    while (g_hash_table_iter_next(&iter, (void **)&stream_id, NULL))
+    {
+        struct payload_hash chunk_id;
+        uint32_t chunks_size, i;
+        size_t read_size;
+
+        if (fozdb_has_entry(read_fozdb, VIDEO_CONV_FOZ_TAG_OGVDATA, stream_id))
+        {
+            if (fozdb_entry_size(dump_fozdb.fozdb, VIDEO_CONV_FOZ_TAG_STREAM, stream_id, &chunks_size) == CONV_OK)
+            {
+                uint8_t *buffer = calloc(1, chunks_size);
+                if (fozdb_read_entry_data(dump_fozdb.fozdb, VIDEO_CONV_FOZ_TAG_STREAM, stream_id,
+                        0, buffer, chunks_size, &read_size, true) == CONV_OK)
+                {
+                    for (i = 0; i < read_size / sizeof(chunk_id); ++i)
+                    {
+                        payload_hash_from_bytes(&chunk_id, buffer + i * sizeof(chunk_id));
+                        to_discard_chunks = g_list_append(to_discard_chunks,
+                                entry_name_create(VIDEO_CONV_FOZ_TAG_VIDEODATA, &chunk_id));
+                    }
+                }
+                free(buffer);
+            }
+
+            to_discard_chunks = g_list_append(to_discard_chunks,
+                    entry_name_create(VIDEO_CONV_FOZ_TAG_STREAM, stream_id));
+        }
+    }
+
+    if ((ret = fozdb_discard_entries(dump_fozdb.fozdb, to_discard_chunks)) < 0)
+    {
+        GST_ERROR("Failed to discard entries, ret %d.", ret);
+        dump_fozdb_close(&dump_fozdb);
+    }
+
+    g_list_free_full(to_discard_chunks, free);
+}
+
+struct pad_reader *pad_reader_create_with_stride(GstPad *pad, size_t stride)
+{
+    struct pad_reader *pad_reader;
+
+    pad_reader = calloc(1, sizeof(*pad_reader));
+    pad_reader->chunk = calloc(HASH_CHUNK_SIZE, sizeof(*pad_reader->chunk));
+    pad_reader->stride = stride;
+    gst_object_ref((pad_reader->pad = pad));
+
+    return pad_reader;
+}
+
+struct pad_reader *pad_reader_create(GstPad *pad)
+{
+    return pad_reader_create_with_stride(pad, SIZE_MAX);
+}
+
+void pad_reader_release(struct pad_reader *reader)
+{
+    gst_object_unref(reader->pad);
+    free(reader->chunk);
+    free(reader);
+}
+
+int pad_reader_read(void *data_src, uint8_t *buffer, size_t size, size_t *read_size)
+{
+    struct pad_reader *reader = data_src;
+    GstBuffer *gst_buffer = NULL;
+    GstFlowReturn gst_ret;
+    size_t to_copy;
+
+    if (!size)
+    {
+        *read_size = 0;
+        return CONV_OK;
+    }
+
+    if (reader->chunk_offset >= reader->chunk_end)
+    {
+        reader->chunk_offset = 0;
+        reader->chunk_end = 0;
+
+        if ((gst_ret = gst_pad_pull_range(reader->pad,
+                reader->offset, HASH_CHUNK_SIZE, &gst_buffer)) == GST_FLOW_OK)
+        {
+            gsize buffer_size = gst_buffer_get_size(gst_buffer);
+
+            if (reader->offset + buffer_size < reader->stride)
+            {
+                to_copy = buffer_size;
+                reader->offset += to_copy;
+            }
+            else if (reader->offset < reader->stride)
+            {
+                to_copy = reader->stride - reader->offset;
+                reader->offset = reader->stride;
+            }
+            else
+            {
+                to_copy = buffer_size;
+                reader->offset += reader->stride;
+            }
+
+            if (size >= to_copy) /* Copy directly into out buffer and return. */
+            {
+                *read_size = gst_buffer_extract(gst_buffer, 0, buffer, to_copy);
+                gst_buffer_unref(gst_buffer);
+                return CONV_OK;
+            }
+            else
+            {
+                reader->chunk_end = gst_buffer_extract(gst_buffer, 0, reader->chunk, to_copy);
+                gst_buffer_unref(gst_buffer);
+            }
+        }
+        else if (gst_ret == GST_FLOW_EOS)
+        {
+            return CONV_ERROR_DATA_END;
+        }
+        else
+        {
+            GST_WARNING("Failed to pull data from %"GST_PTR_FORMAT", reason %s.",
+                    reader->pad, gst_flow_get_name(gst_ret));
+            return CONV_ERROR;
+        }
+    }
+
+    /* Copy chunk data to output buffer. */
+    to_copy = min(reader->chunk_end - reader->chunk_offset, size);
+    memcpy(buffer, reader->chunk + reader->chunk_offset, to_copy);
+    reader->chunk_offset += to_copy;
+
+    *read_size = to_copy;
+    return CONV_OK;
+}
+
+static int video_conv_state_create(struct video_conv_state **out)
+{
+    struct video_conv_state *state;
+    struct fozdb *fozdb = NULL;
+    char *read_fozdb_path;
+    int ret;
+
+    if (!(read_fozdb_path = getenv("MEDIACONV_VIDEO_TRANSCODED_FILE")))
+    {
+        GST_ERROR("MEDIACONV_VIDEO_TRANSCODED_FILE is not set.");
+        return CONV_ERROR_ENV_NOT_SET;
+    }
+
+    if ((ret = fozdb_create(read_fozdb_path, O_RDONLY, true /* Read-only? */, VIDEO_CONV_FOZ_NUM_TAGS, &fozdb)) < 0)
+        GST_ERROR("Failed to create read fozdb from %s, ret %d.", read_fozdb_path, ret);
+
+    state = calloc(1, sizeof(*state));
+    state->read_fozdb = fozdb;
+    state->upstream_duration = DURATION_NONE;
+    state->our_duration = DURATION_NONE;
+    state->transcoded_tag = VIDEO_CONV_FOZ_TAG_MKVDATA;
+    state->need_stream_start = true;
+
+    *out = state;
+    return CONV_OK;
+}
+
+static void video_conv_state_release(struct video_conv_state *state)
+{
+    if (state->read_fozdb)
+        fozdb_release(state->read_fozdb);
+    free(state);
+}
+
+/* Return true if the file is transcoded, false if not. */
+bool video_conv_state_begin_transcode(struct video_conv_state *state, struct payload_hash *hash)
+{
+    const char *blank_video;
+    uint64_t file_size = 0;
+    int fd;
+
+    GST_DEBUG("state %p, hash %s.", state, format_hash(hash));
+
+    if (state->read_fozdb)
+    {
+        uint32_t entry_size;
+
+        if (fozdb_entry_size(state->read_fozdb, VIDEO_CONV_FOZ_TAG_MKVDATA, hash, &entry_size) == CONV_OK)
+        {
+            GST_DEBUG("Found an MKV video for hash %s.", format_hash(hash));
+            state->transcode_hash = *hash;
+            state->our_duration = entry_size;
+            state->transcoded_tag = VIDEO_CONV_FOZ_TAG_MKVDATA;
+            state->has_transcoded = true;
+            return true;
+        }
+
+        if (fozdb_entry_size(state->read_fozdb, VIDEO_CONV_FOZ_TAG_OGVDATA, hash, &entry_size) == CONV_OK)
+        {
+            GST_DEBUG("Found an OGV video for hash %s.", format_hash(hash));
+            state->transcode_hash = *hash;
+            state->our_duration = entry_size;
+            state->transcoded_tag = VIDEO_CONV_FOZ_TAG_OGVDATA;
+            state->has_transcoded = true;
+            return true;
+        }
+    }
+
+    GST_INFO("No transcoded video for %s. Substituting a blank video.", format_hash(hash));
+
+    if (!(blank_video = getenv("MEDIACONV_BLANK_VIDEO_FILE")))
+    {
+        GST_ERROR("Env MEDIACONV_BLANK_VIDEO_FILE not set.");
+        return false;
+    }
+    if (open_file(blank_video, O_RDONLY, &fd))
+    {
+        get_file_size(fd, &file_size);
+        close(fd);
+    }
+    state->our_duration = file_size;
+    state->has_transcoded = false;
+
+    create_placeholder_file("placeholder-video-used");
+
+    return false;
+}
+
+int video_conv_state_fill_buffer(struct video_conv_state *state, uint64_t offset,
+        uint8_t *buffer, size_t size, size_t *fill_size)
+{
+    const char *blank_video;
+    uint64_t file_size;
+    size_t to_copy;
+    bool read_ok;
+    int fd, ret;
+
+    if (state->has_transcoded)
+    {
+        if ((ret = fozdb_read_entry_data(state->read_fozdb, state->transcoded_tag, &state->transcode_hash,
+                offset, buffer, size, fill_size, false)) < 0)
+            GST_ERROR("Failed to read entry data, ret %d.", ret);
+        return ret;
+    }
+    else /* Fill blank video data to buffer. */
+    {
+        if (!(blank_video = getenv("MEDIACONV_BLANK_VIDEO_FILE")))
+        {
+            GST_ERROR("Env MEDIACONV_BLANK_VIDEO_FILE not set.");
+            return CONV_ERROR_ENV_NOT_SET;
+        }
+        if (!open_file(blank_video, O_RDONLY, &fd))
+            return CONV_ERROR_OPEN_FAILED;
+        if (!get_file_size(fd, &file_size))
+        {
+            close(fd);
+            return CONV_ERROR;
+        }
+
+        /* Get copy size. */
+        if (offset >= file_size)
+        {
+            close(fd);
+            return CONV_OK;
+        }
+        to_copy = min(file_size - offset, size);
+
+        /* Copy data. */
+        if (lseek(fd, offset, SEEK_SET) < 0)
+        {
+            GST_ERROR("Failed to seek %s to %#"PRIx64". %s.", blank_video, offset, strerror(errno));
+            close(fd);
+            return CONV_ERROR;
+        }
+        read_ok = complete_read(fd, buffer, to_copy);
+        close(fd);
+
+        if (!read_ok)
+        {
+            GST_ERROR("Failed to read blank video data.");
+            return CONV_ERROR_READ_FAILED;
+        }
+        *fill_size = to_copy;
+        return CONV_OK;
+    }
+}
+
+/* Call pthread_mutex_unlock() to unlock after usage. */
+static struct video_conv_state *video_conv_lock_state(VideoConv *conv)
+{
+    pthread_mutex_lock(&conv->state_mutex);
+    if (!conv->state)
+        pthread_mutex_unlock(&conv->state_mutex);
+    return conv->state;
+}
+
+static GstStateChangeReturn video_conv_change_state(GstElement *element, GstStateChange transition)
+{
+    VideoConv *conv = VIDEO_CONV(element);
+    struct video_conv_state *state;
+    int ret;
+
+    GST_INFO_OBJECT(element, "State transition: %s.", gst_state_change_get_name(transition));
+
+    switch (transition)
+    {
+    case GST_STATE_CHANGE_NULL_TO_READY:
+        /* Do runtime setup. */
+        if ((ret = video_conv_state_create(&state)) < 0)
+        {
+            GST_ERROR("Failed to create video conv state, ret %d.", ret);
+            return GST_STATE_CHANGE_FAILURE;
+        }
+        pthread_mutex_lock(&conv->state_mutex);
+        assert(!conv->state);
+        conv->state = state;
+        pthread_mutex_unlock(&conv->state_mutex);
+        break;
+
+    case GST_STATE_CHANGE_READY_TO_NULL:
+        /* Do runtime teardown. */
+        pthread_mutex_lock(&conv->state_mutex);
+        video_conv_state_release(conv->state);
+        conv->state = NULL;
+        pthread_mutex_unlock(&conv->state_mutex);
+        break;
+
+    default:
+        break;
+    }
+
+    return GST_ELEMENT_CLASS(parent_class)->change_state(element, transition);
+
+    /* XXX on ReadyToNull, sodium drops state _again_ here... why? */
+}
+
+static uint64_t video_conv_duration_ours_to_upstream(VideoConv *conv, uint64_t pos)
+{
+    struct video_conv_state *state = conv->state;
+
+    if (state->upstream_duration != DURATION_NONE && state->our_duration != DURATION_NONE)
+        return pos * state->upstream_duration / state->our_duration;
+    else
+        return DURATION_NONE;
+}
+
+static void video_conv_query_upstream_duration(VideoConv *conv)
+{
+    gint64 duration;
+
+    if (gst_pad_peer_query_duration(conv->sink_pad, GST_FORMAT_BYTES, &duration))
+        conv->state->upstream_duration = duration;
+    else
+        GST_ERROR_OBJECT(conv, "Failed to query upstream duration.");
+}
+
+static bool video_conv_get_upstream_range(VideoConv *conv, uint64_t offset, uint32_t requested_size,
+        uint64_t *upstream_offset, uint64_t *upstream_requested_size)
+{
+    struct video_conv_state *state;
+
+    if (!(state = video_conv_lock_state(conv)))
+        return false;
+
+    if (state->upstream_duration == DURATION_NONE)
+        video_conv_query_upstream_duration(conv);
+
+    *upstream_offset = video_conv_duration_ours_to_upstream(conv, offset);
+    *upstream_requested_size = video_conv_duration_ours_to_upstream(conv, requested_size);
+
+    pthread_mutex_unlock(&conv->state_mutex);
+
+    return true;
+}
+
+static bool video_conv_hash_upstream_data(VideoConv *conv, struct payload_hash *hash)
+{
+    struct pad_reader *reader;
+    bool ret;
+
+    memset(hash, 0, sizeof(*hash));
+
+    reader = pad_reader_create_with_stride(conv->sink_pad, HASH_STRIDE);
+    ret = murmur3_128(reader, pad_reader_read, HASH_SEED, hash);
+    pad_reader_release(reader);
+
+    return ret;
+}
+
+static int video_conv_dump_upstream_data(VideoConv *conv, struct payload_hash *hash)
+{
+    struct hashes_reader chunk_hashes_reader;
+    struct pad_reader *pad_reader = NULL;
+    GList *chunk_hashes = NULL;
+    uint8_t *buffer = NULL;
+    size_t read_size;
+    int ret;
+
+    GST_DEBUG("Dumping upstream data, hash %s.", format_hash(hash));
+
+    if ((ret = dump_fozdb_open_video(true)) < 0)
+    {
+        GST_ERROR("Failed to open video dump fozdb, ret %d.", ret);
+        goto done;
+    }
+
+    buffer = calloc(1, HASH_CHUNK_SIZE);
+    pad_reader = pad_reader_create(conv->sink_pad);
+    while ((ret = pad_reader_read(pad_reader, buffer, HASH_CHUNK_SIZE, &read_size)) == CONV_OK)
+    {
+        struct bytes_reader bytes_reader;
+        struct payload_hash *chunk_hash;
+
+        bytes_reader_init(&bytes_reader, buffer, read_size);
+        chunk_hash = calloc(1, sizeof(*chunk_hash));
+        murmur3_128(&bytes_reader, bytes_reader_read, HASH_SEED, chunk_hash);
+        chunk_hashes = g_list_append(chunk_hashes, chunk_hash);
+
+        bytes_reader_init(&bytes_reader, buffer, read_size);
+        if ((ret = fozdb_write_entry(dump_fozdb.fozdb, VIDEO_CONV_FOZ_TAG_VIDEODATA, chunk_hash,
+                &bytes_reader, bytes_reader_read, true)) < 0)
+        {
+            GST_ERROR("Error writing video data to fozdb, ret %d.", ret);
+            goto done;
+        }
+    }
+
+    if (ret != CONV_ERROR_DATA_END)
+    {
+        GST_ERROR("Failed to read data from pad reader, ret %d.", ret);
+        goto done;
+    }
+
+    hashes_reader_init(&chunk_hashes_reader, chunk_hashes);
+    if ((ret = fozdb_write_entry(dump_fozdb.fozdb, VIDEO_CONV_FOZ_TAG_STREAM, hash,
+            &chunk_hashes_reader, hashes_reader_read, true)) < 0)
+        GST_ERROR("Error writing stream data to fozdb, ret %d.", ret);
+
+done:
+    if (chunk_hashes)
+        g_list_free_full(chunk_hashes, free);
+    if (pad_reader)
+        pad_reader_release(pad_reader);
+    if (buffer)
+        free(buffer);
+    return ret;
+}
+
+static void video_conv_init_transcode(VideoConv *conv)
+{
+    struct video_conv_state *state = conv->state;
+    struct payload_hash hash;
+    int ret;
+
+    if (state->has_transcoded)
+        return;
+
+    pthread_mutex_lock(&dump_fozdb.mutex);
+
+    dump_fozdb_discard_transcoded();
+
+    if (video_conv_hash_upstream_data(conv, &hash))
+    {
+        GST_INFO("Got upstream data hash: %s.", format_hash(&hash));
+        if (!video_conv_state_begin_transcode(state, &hash)
+                && (ret = video_conv_dump_upstream_data(conv, &hash)) < 0)
+            GST_ERROR("Failed to dump upstream data, ret %d.", ret);
+    }
+    else
+    {
+        GST_WARNING("Failed to hash upstream data.");
+    }
+
+    pthread_mutex_unlock(&dump_fozdb.mutex);
+}
+
+static gboolean video_conv_sink_event(GstPad *pad, GstObject *parent, GstEvent *event)
+{
+    VideoConv *conv = VIDEO_CONV(parent);
+    bool ret;
+
+    GST_DEBUG_OBJECT(pad, "Got event %"GST_PTR_FORMAT".", event);
+
+    if (event->type == GST_EVENT_CAPS)
+    {
+        struct video_conv_state *state;
+        uint32_t transcode_tag;
+        GstCaps *caps;
+
+        /* push_event, below, can also grab state and cause a deadlock, so make sure it's
+         * unlocked before calling */
+        if (!(state = video_conv_lock_state(conv)))
+        {
+            GST_ERROR("VideoConv not yet in READY state?");
+            return false;
+        }
+
+        if (!gst_pad_activate_mode(conv->sink_pad, GST_PAD_MODE_PULL, true))
+        {
+            GST_ERROR("Failed to activate sink pad in pull mode.");
+            pthread_mutex_unlock(&conv->state_mutex);
+            return false;
+        }
+
+        video_conv_init_transcode(conv);
+        transcode_tag = state->transcoded_tag;
+
+        pthread_mutex_unlock(&conv->state_mutex);
+
+        if (transcode_tag == VIDEO_CONV_FOZ_TAG_MKVDATA)
+            caps = gst_caps_from_string("video/x-matroska");
+        else if (transcode_tag == VIDEO_CONV_FOZ_TAG_OGVDATA)
+            caps = gst_caps_from_string("application/ogg");
+        else
+            return false;
+
+        ret = push_event(conv->src_pad, gst_event_new_caps(caps));
+        gst_caps_unref(caps);
+        return ret;
+    }
+
+    return gst_pad_event_default(pad, parent, event);
+}
+
+static GstFlowReturn video_conv_src_get_range(GstPad *pad, GstObject *parent,
+        guint64 offset, guint request_size, GstBuffer **buffer)
+{
+    GstBuffer *my_buffer, *upstream_buffer = NULL, *new_buffer = NULL;
+    uint64_t upstream_offset, upstream_request_size;
+    GstFlowReturn flow_ret = GST_FLOW_ERROR;
+    VideoConv *conv = VIDEO_CONV(parent);
+    struct video_conv_state *state;
+    size_t fill_size;
+    GstMapInfo map;
+    int ret;
+
+    if (!video_conv_get_upstream_range(conv, offset, request_size, &upstream_offset, &upstream_request_size))
+        return flow_ret;
+
+    if (!(state = video_conv_lock_state(conv)))
+        return flow_ret;
+
+    /* Read and ignore upstream bytes. */
+    if ((flow_ret = gst_pad_pull_range(conv->sink_pad, upstream_offset, upstream_request_size, &upstream_buffer)) < 0)
+    {
+        GST_ERROR("Failed to pull upstream data from %"GST_PTR_FORMAT", offset %#"PRIx64", size %#"PRIx64", reason %s.",
+                conv->sink_pad, upstream_offset, upstream_request_size, gst_flow_get_name(flow_ret));
+        goto done;
+    }
+    gst_buffer_unref(upstream_buffer);
+
+    /* Allocate and map buffer. */
+    my_buffer = *buffer;
+    if (!my_buffer)
+    {
+        /* XXX: can we use a buffer cache here? */
+        if (!(new_buffer = gst_buffer_new_and_alloc(request_size)))
+        {
+            GST_ERROR("Failed to allocate buffer of %u bytes.", request_size);
+            goto done;
+        }
+        my_buffer = new_buffer;
+    }
+    if (!gst_buffer_map(my_buffer, &map, GST_MAP_READWRITE))
+    {
+        GST_ERROR("Failed to map buffer <%"GST_PTR_FORMAT">.", my_buffer);
+        goto done;
+    }
+
+    /* Fill buffer. */
+    ret = video_conv_state_fill_buffer(state, offset, map.data, map.size, &fill_size);
+    gst_buffer_unmap(my_buffer, &map);
+    if (ret < 0)
+    {
+        GST_ERROR("Failed to fill buffer, ret %d.", ret);
+        goto done;
+    }
+
+    if (fill_size > 0 || !gst_buffer_get_size(my_buffer))
+    {
+        gst_buffer_set_size(my_buffer, fill_size);
+        *buffer = my_buffer;
+        flow_ret = GST_FLOW_OK;
+    }
+    else
+    {
+        flow_ret = GST_FLOW_EOS;
+    }
+
+done:
+    if (flow_ret < 0 && new_buffer)
+        gst_buffer_unref(new_buffer);
+    pthread_mutex_unlock(&conv->state_mutex);
+    return flow_ret;
+}
+
+static gboolean video_conv_src_query(GstPad *pad, GstObject *parent, GstQuery *query)
+{
+    VideoConv *conv = VIDEO_CONV(parent);
+    struct video_conv_state *state;
+    GstSchedulingFlags flags;
+    gint min, max, align;
+    GstQuery *peer_query;
+    uint64_t duration;
+    GstFormat format;
+
+    GST_DEBUG_OBJECT(pad, "Got query %"GST_PTR_FORMAT".", query);
+
+    switch (query->type)
+    {
+    case GST_QUERY_SCHEDULING:
+        peer_query = gst_query_new_scheduling();
+        if (!gst_pad_peer_query(conv->sink_pad, peer_query))
+        {
+            GST_ERROR_OBJECT(conv->sink_pad, "Failed to query scheduling from peer.");
+            gst_query_unref(peer_query);
+            return false;
+        }
+        gst_query_parse_scheduling(peer_query, &flags, &min, &max, &align);
+        gst_query_unref(peer_query);
+
+        gst_query_set_scheduling(query, flags, min, max, align);
+        gst_query_add_scheduling_mode(query, GST_PAD_MODE_PULL);
+
+        return true;
+
+    case GST_QUERY_DURATION:
+        gst_query_parse_duration(query, &format, NULL);
+        if (format != GST_FORMAT_BYTES)
+        {
+            GST_WARNING("Duration query format is not GST_FORMAT_BYTES.");
+            return false;
+        }
+
+        if (!(state = video_conv_lock_state(conv)))
+            return false;
+        if (state->upstream_duration == DURATION_NONE)
+            video_conv_query_upstream_duration(conv);
+        duration = state->our_duration;
+        pthread_mutex_unlock(&conv->state_mutex);
+
+        if (duration == DURATION_NONE)
+            return false;
+        gst_query_set_duration(query, GST_FORMAT_BYTES, duration);
+        return true;
+
+    default:
+        return gst_pad_query_default(pad, parent, query);
+    }
+}
+
+static gboolean video_conv_src_active_mode(GstPad *pad, GstObject *parent, GstPadMode mode, gboolean active)
+{
+    VideoConv *conv = VIDEO_CONV(parent);
+    struct video_conv_state *state;
+    struct payload_hash hash;
+    bool need_stream_start;
+    bool has_transcoded;
+
+    GST_DEBUG_OBJECT(pad, "mode %s, active %d.", gst_pad_mode_get_name(mode), active);
+
+    if (!gst_pad_activate_mode(conv->sink_pad, mode, active))
+    {
+        GST_ERROR_OBJECT(conv->sink_pad, "Failed to active sink pad: mode %s, active %d.",
+                gst_pad_mode_get_name(mode), active);
+        return false;
+    }
+
+    if (mode != GST_PAD_MODE_PULL)
+        return true;
+
+    if (!(state = video_conv_lock_state(conv)))
+    {
+        GST_ERROR("VideoConv not yet in READY state?");
+        return false;
+    }
+
+    video_conv_init_transcode(conv);
+    hash = state->transcode_hash;
+    need_stream_start = state->need_stream_start;
+    has_transcoded = state->has_transcoded;
+
+    /* push_event, below, can also grab state and cause a deadlock, so make sure it's
+     * unlocked before calling */
+    pthread_mutex_unlock(&conv->state_mutex);
+
+    if (need_stream_start && active && has_transcoded)
+    {
+        push_event(conv->src_pad, gst_event_new_stream_start(format_hash(&hash)));
+
+        if (!(state = video_conv_lock_state(conv)))
+        {
+            GST_ERROR("VideoConv not yet in READY state?");
+            return false;
+        }
+        state->need_stream_start = false;
+        pthread_mutex_unlock(&conv->state_mutex);
+    }
+
+    return true;
+}
+
+
+static void video_conv_finalize(GObject *object)
+{
+    VideoConv *conv = VIDEO_CONV(object);
+
+    pthread_mutex_destroy(&conv->state_mutex);
+    if (conv->state)
+        video_conv_state_release(conv->state);
+
+    G_OBJECT_CLASS(parent_class)->finalize(object);
+}
+
+static void video_conv_class_init(VideoConvClass * klass)
+{
+    GstElementClass *element_class = GST_ELEMENT_CLASS(klass);
+    GObjectClass *object_class = G_OBJECT_CLASS(klass);
+
+    gst_element_class_set_metadata(element_class,
+            "Proton video converter",
+            "Codec/Demuxer",
+            "Converts video for Proton",
+            "Andrew Eikum <aeikum@codeweavers.com>, Ziqing Hui <zhui@codeweavers.com>");
+
+    element_class->change_state = video_conv_change_state;
+    object_class->finalize = video_conv_finalize;
+
+    gst_element_class_add_pad_template(element_class, gst_static_pad_template_get(&video_conv_sink_template));
+    gst_element_class_add_pad_template(element_class, gst_static_pad_template_get(&video_conv_src_template));
+}
+
+static void video_conv_init(VideoConv *conv)
+{
+    GstElement *element = GST_ELEMENT(conv);
+
+    conv->sink_pad = gst_pad_new_from_static_template(&video_conv_sink_template, "sink");
+    gst_pad_set_event_function(conv->sink_pad, GST_DEBUG_FUNCPTR(video_conv_sink_event));
+    gst_element_add_pad(element, conv->sink_pad);
+
+    conv->src_pad = gst_pad_new_from_static_template(&video_conv_src_template, "src");
+    gst_pad_set_getrange_function(conv->src_pad, GST_DEBUG_FUNCPTR(video_conv_src_get_range));
+    gst_pad_set_query_function(conv->src_pad, GST_DEBUG_FUNCPTR(video_conv_src_query));
+    gst_pad_set_activatemode_function(conv->src_pad, GST_DEBUG_FUNCPTR(video_conv_src_active_mode));
+    gst_element_add_pad(element, conv->src_pad);
+
+    pthread_mutex_init(&conv->state_mutex, NULL);
+    conv->state = NULL;
+}
diff --git a/dlls/winegstreamer/unixlib.c b/dlls/winegstreamer/unixlib.c
index 729008e1f46..644f700027d 100644
--- a/dlls/winegstreamer/unixlib.c
+++ b/dlls/winegstreamer/unixlib.c
@@ -47,6 +47,8 @@
 
 GST_DEBUG_CATEGORY(wine);
 
+extern bool media_converter_init(void);
+
 static UINT thread_count;
 
 GstStreamType stream_type_from_caps(GstCaps *caps)
@@ -300,7 +302,13 @@ NTSTATUS wg_init_gstreamer(void *arg)
 
     GST_INFO("GStreamer library version %s; wine built with %d.%d.%d.",
             gst_version_string(), GST_VERSION_MAJOR, GST_VERSION_MINOR, GST_VERSION_MICRO);
 
+    if (!media_converter_init())
+    {
+        GST_ERROR("Failed to init media converter.");
+        return STATUS_UNSUCCESSFUL;
+    }
+
     if (!gst_element_register_winegstreamerstepper(NULL))
         GST_ERROR("Failed to register the stepper element");
 
-- 
2.49.0

From 42b420cec9e4d6c93ab3c4a9dd785a85d9a6f7d4 Mon Sep 17 00:00:00 2001
From: Ziqing Hui <zhui@codeweavers.com>
Date: Thu, 23 May 2024 13:22:53 +0800
Subject: [PATCH 0190/1564] winegstreamer/media-converter: Continue creating
 state object even if env is not set.

This make sure media-converter work with steam shader cache disabled.

STEAM_COMPAT_MEDIA_PATH and STEAM_COMPAT_TRANSCODED_MEDIA_PATH won't be set with
steam shader cache disabled, resuling in other media-converter envs missing.

CW-Bug-Id: #23856
---
 .../winegstreamer/media-converter/audioconv.c | 18 +++++++--------
 .../winegstreamer/media-converter/videoconv.c | 22 +++++++++----------
 2 files changed, 20 insertions(+), 20 deletions(-)

diff --git a/dlls/winegstreamer/media-converter/audioconv.c b/dlls/winegstreamer/media-converter/audioconv.c
index 71612cbfddd..462cec16a8a 100644
--- a/dlls/winegstreamer/media-converter/audioconv.c
+++ b/dlls/winegstreamer/media-converter/audioconv.c
@@ -682,15 +682,18 @@ static int audio_conv_state_create(struct audio_conv_state **out)
     char *read_fozdb_path;
     int ret;
 
-    if (!(read_fozdb_path = getenv("MEDIACONV_AUDIO_TRANSCODED_FILE")))
+    if ((read_fozdb_path = getenv("MEDIACONV_AUDIO_TRANSCODED_FILE")))
+    {
+        if ((ret = fozdb_create(read_fozdb_path, O_RDONLY, true /* Read-only? */,
+                AUDIO_CONV_FOZ_NUM_TAGS, &fozdb)) < 0)
+            GST_ERROR("Failed to create fozdb from %s, ret %d.", read_fozdb_path, ret);
+    }
+    else
     {
         GST_ERROR("Env MEDIACONV_AUDIO_TRANSCODED_FILE is not set!");
-        return CONV_ERROR_ENV_NOT_SET;
+        ret = CONV_ERROR_ENV_NOT_SET;
     }
 
-    if ((ret = fozdb_create(read_fozdb_path, O_RDONLY, true /* Read-only? */, AUDIO_CONV_FOZ_NUM_TAGS, &fozdb)) < 0)
-        GST_ERROR("Failed to create fozdb from %s, ret %d.", read_fozdb_path, ret);
-
     state = calloc(1, sizeof(*state));
     murmur3_128_state_init(&state->hash_state, HASH_SEED);
     murmur3_128_state_init(&state->loop_hash_state, HASH_SEED);
@@ -698,7 +701,7 @@ static int audio_conv_state_create(struct audio_conv_state **out)
     state->read_fozdb = fozdb;
 
     *out = state;
-    return CONV_OK;
+    return ret;
 }
 
 static void audio_conv_state_release(struct audio_conv_state *state)
@@ -870,10 +873,7 @@ static GstStateChangeReturn audio_conv_change_state(GstElement *element, GstStat
 
         /* Create audio conv state. */
         if ((ret = audio_conv_state_create(&state)) < 0)
-        {
             GST_ERROR("Failed to create audio conv state, ret %d.", ret);
-            return GST_STATE_CHANGE_FAILURE;
-        }
         pthread_mutex_lock(&conv->state_mutex);
         assert(!conv->state);
         conv->state = state;
diff --git a/dlls/winegstreamer/media-converter/videoconv.c b/dlls/winegstreamer/media-converter/videoconv.c
index b91aa96f1bf..a73292a59eb 100644
--- a/dlls/winegstreamer/media-converter/videoconv.c
+++ b/dlls/winegstreamer/media-converter/videoconv.c
@@ -334,14 +334,17 @@ static int video_conv_state_create(struct video_conv_state **out)
     char *read_fozdb_path;
     int ret;
 
-    if (!(read_fozdb_path = getenv("MEDIACONV_VIDEO_TRANSCODED_FILE")))
+    if ((read_fozdb_path = getenv("MEDIACONV_VIDEO_TRANSCODED_FILE")))
     {
-        GST_ERROR("MEDIACONV_VIDEO_TRANSCODED_FILE is not set.");
-        return CONV_ERROR_ENV_NOT_SET;
+        if ((ret = fozdb_create(read_fozdb_path, O_RDONLY, true /* Read-only? */,
+                VIDEO_CONV_FOZ_NUM_TAGS, &fozdb)) < 0)
+            GST_ERROR("Failed to create read fozdb from %s, ret %d.", read_fozdb_path, ret);
+    }
+    else
+    {
+        GST_ERROR("Env MEDIACONV_VIDEO_TRANSCODED_FILE is not set.");
+        ret = CONV_ERROR_ENV_NOT_SET;
     }
-
-    if ((ret = fozdb_create(read_fozdb_path, O_RDONLY, true /* Read-only? */, VIDEO_CONV_FOZ_NUM_TAGS, &fozdb)) < 0)
-        GST_ERROR("Failed to create read fozdb from %s, ret %d.", read_fozdb_path, ret);
 
     state = calloc(1, sizeof(*state));
     state->read_fozdb = fozdb;
@@ -351,7 +354,7 @@ static int video_conv_state_create(struct video_conv_state **out)
     state->need_stream_start = true;
 
     *out = state;
-    return CONV_OK;
+    return ret;
 }
 
 static void video_conv_state_release(struct video_conv_state *state)
@@ -486,7 +489,7 @@ static struct video_conv_state *video_conv_lock_state(VideoConv *conv)
 static GstStateChangeReturn video_conv_change_state(GstElement *element, GstStateChange transition)
 {
     VideoConv *conv = VIDEO_CONV(element);
-    struct video_conv_state *state;
+    struct video_conv_state *state = NULL;
     int ret;
 
     GST_INFO_OBJECT(element, "State transition: %s.", gst_state_change_get_name(transition));
@@ -496,10 +499,7 @@ static GstStateChangeReturn video_conv_change_state(GstElement *element, GstStat
     case GST_STATE_CHANGE_NULL_TO_READY:
         /* Do runtime setup. */
         if ((ret = video_conv_state_create(&state)) < 0)
-        {
             GST_ERROR("Failed to create video conv state, ret %d.", ret);
-            return GST_STATE_CHANGE_FAILURE;
-        }
         pthread_mutex_lock(&conv->state_mutex);
         assert(!conv->state);
         conv->state = state;
-- 
2.49.0

From 4365f425b91e7bce55a9375a9c9ab7d047a7e754 Mon Sep 17 00:00:00 2001
From: Ziqing Hui <zhui@codeweavers.com>
Date: Wed, 7 Aug 2024 09:05:43 +0800
Subject: [PATCH 0191/1564] winegstreamer/media-converter: Log error if failed
 to pull data from upstream.

---
 dlls/winegstreamer/media-converter/videoconv.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/winegstreamer/media-converter/videoconv.c b/dlls/winegstreamer/media-converter/videoconv.c
index a73292a59eb..2dd7446cedb 100644
--- a/dlls/winegstreamer/media-converter/videoconv.c
+++ b/dlls/winegstreamer/media-converter/videoconv.c
@@ -312,7 +312,7 @@ int pad_reader_read(void *data_src, uint8_t *buffer, size_t size, size_t *read_s
         }
         else
         {
-            GST_WARNING("Failed to pull data from %"GST_PTR_FORMAT", reason %s.",
+            GST_ERROR("Failed to pull data from %"GST_PTR_FORMAT", reason %s.",
                     reader->pad, gst_flow_get_name(gst_ret));
             return CONV_ERROR;
         }
@@ -657,7 +657,7 @@ static void video_conv_init_transcode(VideoConv *conv)
     }
     else
     {
-        GST_WARNING("Failed to hash upstream data.");
+        GST_ERROR("Failed to hash upstream data.");
     }
 
     pthread_mutex_unlock(&dump_fozdb.mutex);
-- 
2.49.0

From 5828ad84759d46ec6004b6dc94bdcf31dc5bdb98 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 5 Mar 2024 10:55:06 +0100
Subject: [PATCH 0192/1564] winegstreamer/media-converter: Split videoconv caps
 event handler to a separate helper.

CW-Bug-Id: #22319
---
 .../winegstreamer/media-converter/videoconv.c | 71 ++++++++++---------
 1 file changed, 38 insertions(+), 33 deletions(-)

diff --git a/dlls/winegstreamer/media-converter/videoconv.c b/dlls/winegstreamer/media-converter/videoconv.c
index 2dd7446cedb..9c82f0a9cbf 100644
--- a/dlls/winegstreamer/media-converter/videoconv.c
+++ b/dlls/winegstreamer/media-converter/videoconv.c
@@ -663,50 +663,55 @@ static void video_conv_init_transcode(VideoConv *conv)
     pthread_mutex_unlock(&dump_fozdb.mutex);
 }
 
-static gboolean video_conv_sink_event(GstPad *pad, GstObject *parent, GstEvent *event)
+static gboolean video_conv_sink_event_caps(VideoConv *conv, GstEvent *event)
 {
-    VideoConv *conv = VIDEO_CONV(parent);
+    struct video_conv_state *state;
+    uint32_t transcode_tag;
+    GstCaps *caps;
     bool ret;
 
-    GST_DEBUG_OBJECT(pad, "Got event %"GST_PTR_FORMAT".", event);
+    gst_event_unref(event);
 
-    if (event->type == GST_EVENT_CAPS)
+    /* push_event, below, can also grab state and cause a deadlock, so make sure it's
+     * unlocked before calling */
+    if (!(state = video_conv_lock_state(conv)))
     {
-        struct video_conv_state *state;
-        uint32_t transcode_tag;
-        GstCaps *caps;
+        GST_ERROR("VideoConv not yet in READY state?");
+        return false;
+    }
 
-        /* push_event, below, can also grab state and cause a deadlock, so make sure it's
-         * unlocked before calling */
-        if (!(state = video_conv_lock_state(conv)))
-        {
-            GST_ERROR("VideoConv not yet in READY state?");
-            return false;
-        }
+    if (!gst_pad_activate_mode(conv->sink_pad, GST_PAD_MODE_PULL, true))
+    {
+        GST_ERROR("Failed to activate sink pad in pull mode.");
+        pthread_mutex_unlock(&conv->state_mutex);
+        return false;
+    }
 
-        if (!gst_pad_activate_mode(conv->sink_pad, GST_PAD_MODE_PULL, true))
-        {
-            GST_ERROR("Failed to activate sink pad in pull mode.");
-            pthread_mutex_unlock(&conv->state_mutex);
-            return false;
-        }
+    video_conv_init_transcode(conv);
+    transcode_tag = state->transcoded_tag;
 
-        video_conv_init_transcode(conv);
-        transcode_tag = state->transcoded_tag;
+    pthread_mutex_unlock(&conv->state_mutex);
 
-        pthread_mutex_unlock(&conv->state_mutex);
+    if (transcode_tag == VIDEO_CONV_FOZ_TAG_MKVDATA)
+        caps = gst_caps_from_string("video/x-matroska");
+    else if (transcode_tag == VIDEO_CONV_FOZ_TAG_OGVDATA)
+        caps = gst_caps_from_string("application/ogg");
+    else
+        return false;
 
-        if (transcode_tag == VIDEO_CONV_FOZ_TAG_MKVDATA)
-            caps = gst_caps_from_string("video/x-matroska");
-        else if (transcode_tag == VIDEO_CONV_FOZ_TAG_OGVDATA)
-            caps = gst_caps_from_string("application/ogg");
-        else
-            return false;
+    ret = push_event(conv->src_pad, gst_event_new_caps(caps));
+    gst_caps_unref(caps);
+    return ret;
+}
 
-        ret = push_event(conv->src_pad, gst_event_new_caps(caps));
-        gst_caps_unref(caps);
-        return ret;
-    }
+static gboolean video_conv_sink_event(GstPad *pad, GstObject *parent, GstEvent *event)
+{
+    VideoConv *conv = VIDEO_CONV(parent);
+
+    GST_DEBUG_OBJECT(pad, "Got event %"GST_PTR_FORMAT".", event);
+
+    if (event->type == GST_EVENT_CAPS)
+        return video_conv_sink_event_caps(conv, event);
 
     return gst_pad_event_default(pad, parent, event);
 }
-- 
2.49.0

From 3478d88e1bd6d5cda1165e7ecc4c0dd322647cf8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 5 Mar 2024 11:04:31 +0100
Subject: [PATCH 0193/1564] winegstreamer/media-converter: Split videoconv
 upstream chunk dump to a separate helper.

CW-Bug-Id: #22319
---
 .../winegstreamer/media-converter/videoconv.c | 28 +++++++++++--------
 1 file changed, 17 insertions(+), 11 deletions(-)

diff --git a/dlls/winegstreamer/media-converter/videoconv.c b/dlls/winegstreamer/media-converter/videoconv.c
index 9c82f0a9cbf..1d691a10ad2 100644
--- a/dlls/winegstreamer/media-converter/videoconv.c
+++ b/dlls/winegstreamer/media-converter/videoconv.c
@@ -576,6 +576,22 @@ static bool video_conv_hash_upstream_data(VideoConv *conv, struct payload_hash *
     return ret;
 }
 
+static int video_conv_dump_upstream_chunk(VideoConv *conv, void *buffer, size_t read_size,
+        GList **chunk_hashes)
+{
+    struct bytes_reader bytes_reader;
+    struct payload_hash *chunk_hash;
+
+    bytes_reader_init(&bytes_reader, buffer, read_size);
+    chunk_hash = calloc(1, sizeof(*chunk_hash));
+    murmur3_128(&bytes_reader, bytes_reader_read, HASH_SEED, chunk_hash);
+    *chunk_hashes = g_list_append(*chunk_hashes, chunk_hash);
+
+    bytes_reader_init(&bytes_reader, buffer, read_size);
+    return fozdb_write_entry(dump_fozdb.fozdb, VIDEO_CONV_FOZ_TAG_VIDEODATA, chunk_hash,
+            &bytes_reader, bytes_reader_read, true);
+}
+
 static int video_conv_dump_upstream_data(VideoConv *conv, struct payload_hash *hash)
 {
     struct hashes_reader chunk_hashes_reader;
@@ -597,17 +613,7 @@ static int video_conv_dump_upstream_data(VideoConv *conv, struct payload_hash *h
     pad_reader = pad_reader_create(conv->sink_pad);
     while ((ret = pad_reader_read(pad_reader, buffer, HASH_CHUNK_SIZE, &read_size)) == CONV_OK)
     {
-        struct bytes_reader bytes_reader;
-        struct payload_hash *chunk_hash;
-
-        bytes_reader_init(&bytes_reader, buffer, read_size);
-        chunk_hash = calloc(1, sizeof(*chunk_hash));
-        murmur3_128(&bytes_reader, bytes_reader_read, HASH_SEED, chunk_hash);
-        chunk_hashes = g_list_append(chunk_hashes, chunk_hash);
-
-        bytes_reader_init(&bytes_reader, buffer, read_size);
-        if ((ret = fozdb_write_entry(dump_fozdb.fozdb, VIDEO_CONV_FOZ_TAG_VIDEODATA, chunk_hash,
-                &bytes_reader, bytes_reader_read, true)) < 0)
+        if ((ret = video_conv_dump_upstream_chunk(conv, buffer, read_size, &chunk_hashes)) < 0)
         {
             GST_ERROR("Error writing video data to fozdb, ret %d.", ret);
             goto done;
-- 
2.49.0

From 1fb58b9be4938b6a58aa9c8cc9fddd6c23163bc8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 5 Mar 2024 11:52:12 +0100
Subject: [PATCH 0194/1564] winegstreamer/media-converter: Split videoconv
 stream-start event push to a separate helper.

CW-Bug-Id: #22319
---
 .../winegstreamer/media-converter/videoconv.c | 30 +++++++++++--------
 1 file changed, 18 insertions(+), 12 deletions(-)

diff --git a/dlls/winegstreamer/media-converter/videoconv.c b/dlls/winegstreamer/media-converter/videoconv.c
index 1d691a10ad2..fd5a2dfab67 100644
--- a/dlls/winegstreamer/media-converter/videoconv.c
+++ b/dlls/winegstreamer/media-converter/videoconv.c
@@ -669,6 +669,23 @@ static void video_conv_init_transcode(VideoConv *conv)
     pthread_mutex_unlock(&dump_fozdb.mutex);
 }
 
+static gboolean video_conv_push_stream_start(VideoConv *conv, struct payload_hash *hash)
+{
+    struct video_conv_state *state;
+
+    push_event(conv->src_pad, gst_event_new_stream_start(format_hash(hash)));
+
+    if (!(state = video_conv_lock_state(conv)))
+    {
+        GST_ERROR("VideoConv not yet in READY state?");
+        return false;
+    }
+    state->need_stream_start = false;
+    pthread_mutex_unlock(&conv->state_mutex);
+
+    return true;
+}
+
 static gboolean video_conv_sink_event_caps(VideoConv *conv, GstEvent *event)
 {
     struct video_conv_state *state;
@@ -885,18 +902,7 @@ static gboolean video_conv_src_active_mode(GstPad *pad, GstObject *parent, GstPa
     pthread_mutex_unlock(&conv->state_mutex);
 
     if (need_stream_start && active && has_transcoded)
-    {
-        push_event(conv->src_pad, gst_event_new_stream_start(format_hash(&hash)));
-
-        if (!(state = video_conv_lock_state(conv)))
-        {
-            GST_ERROR("VideoConv not yet in READY state?");
-            return false;
-        }
-        state->need_stream_start = false;
-        pthread_mutex_unlock(&conv->state_mutex);
-    }
-
+        return video_conv_push_stream_start(conv, &hash);
     return true;
 }
 
-- 
2.49.0

From 7ea0c77c5675cc4d3aeb3bfb33f9257ed89ac755 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 5 Mar 2024 17:10:58 +0100
Subject: [PATCH 0195/1564] winegstreamer/media-converter: Split videoconv
 event caps push to a separate helper.

CW-Bug-Id: #22319
---
 .../winegstreamer/media-converter/videoconv.c | 30 +++++++++++--------
 1 file changed, 18 insertions(+), 12 deletions(-)

diff --git a/dlls/winegstreamer/media-converter/videoconv.c b/dlls/winegstreamer/media-converter/videoconv.c
index fd5a2dfab67..e47e1822abe 100644
--- a/dlls/winegstreamer/media-converter/videoconv.c
+++ b/dlls/winegstreamer/media-converter/videoconv.c
@@ -686,12 +686,27 @@ static gboolean video_conv_push_stream_start(VideoConv *conv, struct payload_has
     return true;
 }
 
+static gboolean video_conv_push_caps(VideoConv *conv, uint32_t transcode_tag)
+{
+    GstCaps *caps;
+    gboolean ret;
+
+    if (transcode_tag == VIDEO_CONV_FOZ_TAG_MKVDATA)
+        caps = gst_caps_from_string("video/x-matroska");
+    else if (transcode_tag == VIDEO_CONV_FOZ_TAG_OGVDATA)
+        caps = gst_caps_from_string("application/ogg");
+    else
+        return false;
+
+    ret = push_event(conv->src_pad, gst_event_new_caps(caps));
+    gst_caps_unref(caps);
+    return ret;
+}
+
 static gboolean video_conv_sink_event_caps(VideoConv *conv, GstEvent *event)
 {
     struct video_conv_state *state;
     uint32_t transcode_tag;
-    GstCaps *caps;
-    bool ret;
 
     gst_event_unref(event);
 
@@ -715,16 +730,7 @@ static gboolean video_conv_sink_event_caps(VideoConv *conv, GstEvent *event)
 
     pthread_mutex_unlock(&conv->state_mutex);
 
-    if (transcode_tag == VIDEO_CONV_FOZ_TAG_MKVDATA)
-        caps = gst_caps_from_string("video/x-matroska");
-    else if (transcode_tag == VIDEO_CONV_FOZ_TAG_OGVDATA)
-        caps = gst_caps_from_string("application/ogg");
-    else
-        return false;
-
-    ret = push_event(conv->src_pad, gst_event_new_caps(caps));
-    gst_caps_unref(caps);
-    return ret;
+    return video_conv_push_caps(conv, transcode_tag);
 }
 
 static gboolean video_conv_sink_event(GstPad *pad, GstObject *parent, GstEvent *event)
-- 
2.49.0

From 8571e0ea3367d266d9d27c2ad04869f77bd17bd1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 5 Mar 2024 10:54:28 +0100
Subject: [PATCH 0196/1564] winegstreamer/media-converter: Open the blank file
 on videoconv state creation.

CW-Bug-Id: #22319
---
 .../winegstreamer/media-converter/videoconv.c | 73 +++++++------------
 1 file changed, 26 insertions(+), 47 deletions(-)

diff --git a/dlls/winegstreamer/media-converter/videoconv.c b/dlls/winegstreamer/media-converter/videoconv.c
index e47e1822abe..9a8ba4f73a7 100644
--- a/dlls/winegstreamer/media-converter/videoconv.c
+++ b/dlls/winegstreamer/media-converter/videoconv.c
@@ -92,6 +92,7 @@ struct video_conv_state
 {
     struct payload_hash transcode_hash;
     struct fozdb *read_fozdb;
+    int blank_file;
     uint64_t upstream_duration;
     uint64_t our_duration;
     uint32_t transcoded_tag;
@@ -331,8 +332,9 @@ static int video_conv_state_create(struct video_conv_state **out)
 {
     struct video_conv_state *state;
     struct fozdb *fozdb = NULL;
-    char *read_fozdb_path;
-    int ret;
+    char *read_fozdb_path, *blank_video;
+    uint64_t blank_file_size;
+    int ret, fd;
 
     if ((read_fozdb_path = getenv("MEDIACONV_VIDEO_TRANSCODED_FILE")))
     {
@@ -345,11 +347,25 @@ static int video_conv_state_create(struct video_conv_state **out)
         GST_ERROR("Env MEDIACONV_VIDEO_TRANSCODED_FILE is not set.");
         ret = CONV_ERROR_ENV_NOT_SET;
     }
+    if (!(blank_video = getenv("MEDIACONV_BLANK_VIDEO_FILE")))
+    {
+        GST_ERROR("Env MEDIACONV_BLANK_VIDEO_FILE not set.");
+        return CONV_ERROR_ENV_NOT_SET;
+    }
+
+    if (!open_file(blank_video, O_RDONLY, &fd))
+        return CONV_ERROR_OPEN_FAILED;
+    if (!get_file_size(fd, &blank_file_size))
+    {
+        close(fd);
+        return CONV_ERROR_OPEN_FAILED;
+    }
 
     state = calloc(1, sizeof(*state));
     state->read_fozdb = fozdb;
+    state->blank_file = fd;
     state->upstream_duration = DURATION_NONE;
-    state->our_duration = DURATION_NONE;
+    state->our_duration = blank_file_size;
     state->transcoded_tag = VIDEO_CONV_FOZ_TAG_MKVDATA;
     state->need_stream_start = true;
 
@@ -361,16 +377,13 @@ static void video_conv_state_release(struct video_conv_state *state)
 {
     if (state->read_fozdb)
         fozdb_release(state->read_fozdb);
+    close(state->blank_file);
     free(state);
 }
 
 /* Return true if the file is transcoded, false if not. */
 bool video_conv_state_begin_transcode(struct video_conv_state *state, struct payload_hash *hash)
 {
-    const char *blank_video;
-    uint64_t file_size = 0;
-    int fd;
-
     GST_DEBUG("state %p, hash %s.", state, format_hash(hash));
 
     if (state->read_fozdb)
@@ -399,18 +412,6 @@ bool video_conv_state_begin_transcode(struct video_conv_state *state, struct pay
     }
 
     GST_INFO("No transcoded video for %s. Substituting a blank video.", format_hash(hash));
-
-    if (!(blank_video = getenv("MEDIACONV_BLANK_VIDEO_FILE")))
-    {
-        GST_ERROR("Env MEDIACONV_BLANK_VIDEO_FILE not set.");
-        return false;
-    }
-    if (open_file(blank_video, O_RDONLY, &fd))
-    {
-        get_file_size(fd, &file_size);
-        close(fd);
-    }
-    state->our_duration = file_size;
     state->has_transcoded = false;
 
     create_placeholder_file("placeholder-video-used");
@@ -421,11 +422,9 @@ bool video_conv_state_begin_transcode(struct video_conv_state *state, struct pay
 int video_conv_state_fill_buffer(struct video_conv_state *state, uint64_t offset,
         uint8_t *buffer, size_t size, size_t *fill_size)
 {
-    const char *blank_video;
-    uint64_t file_size;
     size_t to_copy;
     bool read_ok;
-    int fd, ret;
+    int ret;
 
     if (state->has_transcoded)
     {
@@ -436,38 +435,18 @@ int video_conv_state_fill_buffer(struct video_conv_state *state, uint64_t offset
     }
     else /* Fill blank video data to buffer. */
     {
-        if (!(blank_video = getenv("MEDIACONV_BLANK_VIDEO_FILE")))
-        {
-            GST_ERROR("Env MEDIACONV_BLANK_VIDEO_FILE not set.");
-            return CONV_ERROR_ENV_NOT_SET;
-        }
-        if (!open_file(blank_video, O_RDONLY, &fd))
-            return CONV_ERROR_OPEN_FAILED;
-        if (!get_file_size(fd, &file_size))
-        {
-            close(fd);
-            return CONV_ERROR;
-        }
-
         /* Get copy size. */
-        if (offset >= file_size)
-        {
-            close(fd);
+        if (offset >= state->our_duration)
             return CONV_OK;
-        }
-        to_copy = min(file_size - offset, size);
+        to_copy = min(state->our_duration - offset, size);
 
         /* Copy data. */
-        if (lseek(fd, offset, SEEK_SET) < 0)
+        if (lseek(state->blank_file, offset, SEEK_SET) < 0)
         {
-            GST_ERROR("Failed to seek %s to %#"PRIx64". %s.", blank_video, offset, strerror(errno));
-            close(fd);
+            GST_ERROR("Failed to seek to %#"PRIx64". %s.", offset, strerror(errno));
             return CONV_ERROR;
         }
-        read_ok = complete_read(fd, buffer, to_copy);
-        close(fd);
-
-        if (!read_ok)
+        if (!(read_ok = complete_read(state->blank_file, buffer, to_copy)))
         {
             GST_ERROR("Failed to read blank video data.");
             return CONV_ERROR_READ_FAILED;
-- 
2.49.0

From 659a03a51b6b40a1cbb7aa49c7f4228eafe227c9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 5 Mar 2024 10:54:28 +0100
Subject: [PATCH 0197/1564] winegstreamer/media-converter: Use an enum for
 video conv state flags.

CW-Bug-Id: #22319
---
 .../winegstreamer/media-converter/videoconv.c | 29 ++++++++++---------
 1 file changed, 16 insertions(+), 13 deletions(-)

diff --git a/dlls/winegstreamer/media-converter/videoconv.c b/dlls/winegstreamer/media-converter/videoconv.c
index 9a8ba4f73a7..25cda8cc331 100644
--- a/dlls/winegstreamer/media-converter/videoconv.c
+++ b/dlls/winegstreamer/media-converter/videoconv.c
@@ -88,6 +88,12 @@ struct hashes_reader
     GList *current_hash;
 };
 
+enum video_conv_state_flags
+{
+    VIDEO_CONV_STREAM_STARTED = 1,
+    VIDEO_CONV_HAS_TRANSCODED = 2,
+};
+
 struct video_conv_state
 {
     struct payload_hash transcode_hash;
@@ -96,7 +102,7 @@ struct video_conv_state
     uint64_t upstream_duration;
     uint64_t our_duration;
     uint32_t transcoded_tag;
-    bool has_transcoded, need_stream_start;
+    uint32_t state_flags;
 };
 
 typedef struct
@@ -367,7 +373,6 @@ static int video_conv_state_create(struct video_conv_state **out)
     state->upstream_duration = DURATION_NONE;
     state->our_duration = blank_file_size;
     state->transcoded_tag = VIDEO_CONV_FOZ_TAG_MKVDATA;
-    state->need_stream_start = true;
 
     *out = state;
     return ret;
@@ -396,7 +401,7 @@ bool video_conv_state_begin_transcode(struct video_conv_state *state, struct pay
             state->transcode_hash = *hash;
             state->our_duration = entry_size;
             state->transcoded_tag = VIDEO_CONV_FOZ_TAG_MKVDATA;
-            state->has_transcoded = true;
+            state->state_flags |= VIDEO_CONV_HAS_TRANSCODED;
             return true;
         }
 
@@ -406,13 +411,13 @@ bool video_conv_state_begin_transcode(struct video_conv_state *state, struct pay
             state->transcode_hash = *hash;
             state->our_duration = entry_size;
             state->transcoded_tag = VIDEO_CONV_FOZ_TAG_OGVDATA;
-            state->has_transcoded = true;
+            state->state_flags |= VIDEO_CONV_HAS_TRANSCODED;
             return true;
         }
     }
 
     GST_INFO("No transcoded video for %s. Substituting a blank video.", format_hash(hash));
-    state->has_transcoded = false;
+    state->state_flags &= ~VIDEO_CONV_HAS_TRANSCODED;
 
     create_placeholder_file("placeholder-video-used");
 
@@ -426,7 +431,7 @@ int video_conv_state_fill_buffer(struct video_conv_state *state, uint64_t offset
     bool read_ok;
     int ret;
 
-    if (state->has_transcoded)
+    if (state->state_flags & VIDEO_CONV_HAS_TRANSCODED)
     {
         if ((ret = fozdb_read_entry_data(state->read_fozdb, state->transcoded_tag, &state->transcode_hash,
                 offset, buffer, size, fill_size, false)) < 0)
@@ -626,7 +631,7 @@ static void video_conv_init_transcode(VideoConv *conv)
     struct payload_hash hash;
     int ret;
 
-    if (state->has_transcoded)
+    if (state->state_flags & VIDEO_CONV_HAS_TRANSCODED)
         return;
 
     pthread_mutex_lock(&dump_fozdb.mutex);
@@ -659,7 +664,7 @@ static gboolean video_conv_push_stream_start(VideoConv *conv, struct payload_has
         GST_ERROR("VideoConv not yet in READY state?");
         return false;
     }
-    state->need_stream_start = false;
+    state->state_flags |= VIDEO_CONV_STREAM_STARTED;
     pthread_mutex_unlock(&conv->state_mutex);
 
     return true;
@@ -856,8 +861,7 @@ static gboolean video_conv_src_active_mode(GstPad *pad, GstObject *parent, GstPa
     VideoConv *conv = VIDEO_CONV(parent);
     struct video_conv_state *state;
     struct payload_hash hash;
-    bool need_stream_start;
-    bool has_transcoded;
+    uint32_t state_flags;
 
     GST_DEBUG_OBJECT(pad, "mode %s, active %d.", gst_pad_mode_get_name(mode), active);
 
@@ -879,14 +883,13 @@ static gboolean video_conv_src_active_mode(GstPad *pad, GstObject *parent, GstPa
 
     video_conv_init_transcode(conv);
     hash = state->transcode_hash;
-    need_stream_start = state->need_stream_start;
-    has_transcoded = state->has_transcoded;
+    state_flags = state->state_flags;
 
     /* push_event, below, can also grab state and cause a deadlock, so make sure it's
      * unlocked before calling */
     pthread_mutex_unlock(&conv->state_mutex);
 
-    if (need_stream_start && active && has_transcoded)
+    if (active && !(state_flags & VIDEO_CONV_STREAM_STARTED) && (state_flags & VIDEO_CONV_HAS_TRANSCODED))
         return video_conv_push_stream_start(conv, &hash);
     return true;
 }
-- 
2.49.0

From f46c3f0b0b179f88aab17c1d5ca172b72d7e5873 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 29 Mar 2024 15:17:07 +0100
Subject: [PATCH 0198/1564] winegstreamer/media-converter: Wrap around the
 blank video if shorter than upstream data.

CW-Bug-Id: #22319
---
 dlls/winegstreamer/media-converter/videoconv.c | 4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)

diff --git a/dlls/winegstreamer/media-converter/videoconv.c b/dlls/winegstreamer/media-converter/videoconv.c
index 25cda8cc331..8bb35ad41fe 100644
--- a/dlls/winegstreamer/media-converter/videoconv.c
+++ b/dlls/winegstreamer/media-converter/videoconv.c
@@ -440,9 +440,7 @@ int video_conv_state_fill_buffer(struct video_conv_state *state, uint64_t offset
     }
     else /* Fill blank video data to buffer. */
     {
-        /* Get copy size. */
-        if (offset >= state->our_duration)
-            return CONV_OK;
+        offset = offset % state->our_duration;
         to_copy = min(state->our_duration - offset, size);
 
         /* Copy data. */
-- 
2.49.0

From ecb309b51fae74340dbf5ca12568ad4121966297 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 29 Mar 2024 15:17:07 +0100
Subject: [PATCH 0199/1564] winegstreamer/media-converter: Use
 gst_util_uint64_scale_round to round upstream position.

CW-Bug-Id: #22319
---
 dlls/winegstreamer/media-converter/videoconv.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winegstreamer/media-converter/videoconv.c b/dlls/winegstreamer/media-converter/videoconv.c
index 8bb35ad41fe..97c7e1d35f3 100644
--- a/dlls/winegstreamer/media-converter/videoconv.c
+++ b/dlls/winegstreamer/media-converter/videoconv.c
@@ -510,7 +510,7 @@ static uint64_t video_conv_duration_ours_to_upstream(VideoConv *conv, uint64_t p
     struct video_conv_state *state = conv->state;
 
     if (state->upstream_duration != DURATION_NONE && state->our_duration != DURATION_NONE)
-        return pos * state->upstream_duration / state->our_duration;
+        return gst_util_uint64_scale_round(pos, state->upstream_duration, state->our_duration);
     else
         return DURATION_NONE;
 }
-- 
2.49.0

From c6b239a1b8cac64c47cc2e23c8af06491c2696e0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 29 Mar 2024 15:17:07 +0100
Subject: [PATCH 0200/1564] winegstreamer/media-converter: Implement support
 for push mode in videoconv.

CW-Bug-Id: #22319
---
 .../winegstreamer/media-converter/videoconv.c | 334 +++++++++++++++++-
 1 file changed, 319 insertions(+), 15 deletions(-)

diff --git a/dlls/winegstreamer/media-converter/videoconv.c b/dlls/winegstreamer/media-converter/videoconv.c
index 97c7e1d35f3..97bb098f311 100644
--- a/dlls/winegstreamer/media-converter/videoconv.c
+++ b/dlls/winegstreamer/media-converter/videoconv.c
@@ -59,6 +59,7 @@
 #endif
 
 #include "media-converter.h"
+#include <gst/base/gstadapter.h>
 
 #include <assert.h>
 
@@ -92,6 +93,7 @@ enum video_conv_state_flags
 {
     VIDEO_CONV_STREAM_STARTED = 1,
     VIDEO_CONV_HAS_TRANSCODED = 2,
+    VIDEO_CONV_IS_DUMPING = 4,
 };
 
 struct video_conv_state
@@ -103,6 +105,8 @@ struct video_conv_state
     uint64_t our_duration;
     uint32_t transcoded_tag;
     uint32_t state_flags;
+    uint64_t read_offset;
+    GList *chunk_hashes;
 };
 
 typedef struct
@@ -111,6 +115,8 @@ typedef struct
     GstPad *sink_pad, *src_pad;
     pthread_mutex_t state_mutex;
     struct video_conv_state *state;
+    GstPadMode active_mode;
+    GstAdapter *adapter;
 } VideoConv;
 
 typedef struct
@@ -391,6 +397,8 @@ bool video_conv_state_begin_transcode(struct video_conv_state *state, struct pay
 {
     GST_DEBUG("state %p, hash %s.", state, format_hash(hash));
 
+    state->transcode_hash = *hash;
+
     if (state->read_fozdb)
     {
         uint32_t entry_size;
@@ -398,7 +406,6 @@ bool video_conv_state_begin_transcode(struct video_conv_state *state, struct pay
         if (fozdb_entry_size(state->read_fozdb, VIDEO_CONV_FOZ_TAG_MKVDATA, hash, &entry_size) == CONV_OK)
         {
             GST_DEBUG("Found an MKV video for hash %s.", format_hash(hash));
-            state->transcode_hash = *hash;
             state->our_duration = entry_size;
             state->transcoded_tag = VIDEO_CONV_FOZ_TAG_MKVDATA;
             state->state_flags |= VIDEO_CONV_HAS_TRANSCODED;
@@ -408,7 +415,6 @@ bool video_conv_state_begin_transcode(struct video_conv_state *state, struct pay
         if (fozdb_entry_size(state->read_fozdb, VIDEO_CONV_FOZ_TAG_OGVDATA, hash, &entry_size) == CONV_OK)
         {
             GST_DEBUG("Found an OGV video for hash %s.", format_hash(hash));
-            state->transcode_hash = *hash;
             state->our_duration = entry_size;
             state->transcoded_tag = VIDEO_CONV_FOZ_TAG_OGVDATA;
             state->state_flags |= VIDEO_CONV_HAS_TRANSCODED;
@@ -544,21 +550,63 @@ static bool video_conv_get_upstream_range(VideoConv *conv, uint64_t offset, uint
     return true;
 }
 
+static uint64_t video_conv_duration_ours_to_downstream(VideoConv *conv, uint64_t pos)
+{
+    struct video_conv_state *state = conv->state;
+
+    if (state->upstream_duration != DURATION_NONE && state->our_duration != DURATION_NONE)
+        return gst_util_uint64_scale_round(pos, state->our_duration, state->upstream_duration);
+    else
+        return DURATION_NONE;
+}
+
+static bool video_conv_get_downstream_range(VideoConv *conv, uint64_t offset, uint32_t end,
+        uint64_t *downstream_offset, uint64_t *downstream_end)
+{
+    struct video_conv_state *state;
+
+    if (!(state = video_conv_lock_state(conv)))
+        return false;
+
+    if (state->upstream_duration == DURATION_NONE)
+        video_conv_query_upstream_duration(conv);
+
+    *downstream_offset = video_conv_duration_ours_to_downstream(conv, offset);
+    *downstream_end = video_conv_duration_ours_to_downstream(conv, end);
+
+    pthread_mutex_unlock(&conv->state_mutex);
+
+    return true;
+}
+
 static bool video_conv_hash_upstream_data(VideoConv *conv, struct payload_hash *hash)
 {
-    struct pad_reader *reader;
-    bool ret;
+    bool ret = false;
 
     memset(hash, 0, sizeof(*hash));
 
-    reader = pad_reader_create_with_stride(conv->sink_pad, HASH_STRIDE);
-    ret = murmur3_128(reader, pad_reader_read, HASH_SEED, hash);
-    pad_reader_release(reader);
+    if (conv->active_mode == GST_PAD_MODE_PUSH && gst_adapter_available(conv->adapter) > 0)
+    {
+        struct bytes_reader bytes_reader;
+        gsize read_size = gst_adapter_available(conv->adapter);
+        const void *buffer = gst_adapter_map(conv->adapter, read_size);
+        bytes_reader_init(&bytes_reader, buffer, read_size);
+        ret = murmur3_128(&bytes_reader, bytes_reader_read, HASH_SEED, hash);
+        gst_adapter_unmap(conv->adapter);
+        gst_adapter_clear(conv->adapter);
+    }
+    else if (gst_pad_activate_mode(conv->sink_pad, GST_PAD_MODE_PULL, true))
+    {
+        struct pad_reader *reader = pad_reader_create_with_stride(conv->sink_pad, HASH_STRIDE);
+        ret = murmur3_128(reader, pad_reader_read, HASH_SEED, hash);
+        pad_reader_release(reader);
+        conv->active_mode = GST_PAD_MODE_PULL;
+    }
 
     return ret;
 }
 
-static int video_conv_dump_upstream_chunk(VideoConv *conv, void *buffer, size_t read_size,
+static int video_conv_dump_upstream_chunk(VideoConv *conv, const void *buffer, size_t read_size,
         GList **chunk_hashes)
 {
     struct bytes_reader bytes_reader;
@@ -591,6 +639,12 @@ static int video_conv_dump_upstream_data(VideoConv *conv, struct payload_hash *h
         goto done;
     }
 
+    if (conv->active_mode == GST_PAD_MODE_PUSH)
+    {
+        conv->state->state_flags |= VIDEO_CONV_IS_DUMPING;
+        return 0;
+    }
+
     buffer = calloc(1, HASH_CHUNK_SIZE);
     pad_reader = pad_reader_create(conv->sink_pad);
     while ((ret = pad_reader_read(pad_reader, buffer, HASH_CHUNK_SIZE, &read_size)) == CONV_OK)
@@ -648,7 +702,24 @@ static void video_conv_init_transcode(VideoConv *conv)
         GST_ERROR("Failed to hash upstream data.");
     }
 
-    pthread_mutex_unlock(&dump_fozdb.mutex);
+    if (!(state->state_flags & VIDEO_CONV_IS_DUMPING))
+        pthread_mutex_unlock(&dump_fozdb.mutex);
+}
+
+static uint32_t video_conv_get_state_flags(VideoConv *conv)
+{
+    struct video_conv_state *state;
+    uint32_t state_flags;
+
+    if (!(state = video_conv_lock_state(conv)))
+    {
+        GST_ERROR("VideoConv not yet in READY state?");
+        return 0;
+    }
+    state_flags = state->state_flags;
+    pthread_mutex_unlock(&conv->state_mutex);
+
+    return state_flags;
 }
 
 static gboolean video_conv_push_stream_start(VideoConv *conv, struct payload_hash *hash)
@@ -700,19 +771,81 @@ static gboolean video_conv_sink_event_caps(VideoConv *conv, GstEvent *event)
         return false;
     }
 
-    if (!gst_pad_activate_mode(conv->sink_pad, GST_PAD_MODE_PULL, true))
+    video_conv_init_transcode(conv);
+    transcode_tag = state->transcoded_tag;
+
+    pthread_mutex_unlock(&conv->state_mutex);
+
+    return video_conv_push_caps(conv, transcode_tag);
+}
+
+static gboolean video_conv_sink_event_eos(VideoConv *conv, GstEvent *event)
+{
+    struct video_conv_state *state;
+    struct payload_hash hash;
+    uint32_t transcode_tag;
+    uint32_t state_flags;
+    int ret;
+
+    gst_event_unref(event);
+
+    if (!(state = video_conv_lock_state(conv)))
+        return false;
+
+    if (state->state_flags & VIDEO_CONV_IS_DUMPING)
     {
-        GST_ERROR("Failed to activate sink pad in pull mode.");
+        struct hashes_reader chunk_hashes_reader;
+        gsize read_bytes;
+
+        if ((read_bytes = gst_adapter_available(conv->adapter)))
+        {
+            const void *buffer = gst_adapter_map(conv->adapter, read_bytes);
+
+            if ((ret = video_conv_dump_upstream_chunk(conv, buffer, read_bytes, &state->chunk_hashes)) < 0)
+                GST_ERROR("Error writing stream data to fozdb, ret %d.", ret);
+
+            gst_adapter_unmap(conv->adapter);
+            gst_adapter_clear(conv->adapter);
+        }
+
+        hashes_reader_init(&chunk_hashes_reader, state->chunk_hashes);
+        if ((ret = fozdb_write_entry(dump_fozdb.fozdb, VIDEO_CONV_FOZ_TAG_STREAM, &state->transcode_hash,
+                &chunk_hashes_reader, hashes_reader_read, true)) < 0)
+            GST_ERROR("Error writing stream data to fozdb, ret %d.", ret);
+
+        if (state->chunk_hashes)
+            g_list_free_full(state->chunk_hashes, free);
+
+        pthread_mutex_unlock(&dump_fozdb.mutex);
+        state->state_flags &= ~VIDEO_CONV_IS_DUMPING;
         pthread_mutex_unlock(&conv->state_mutex);
-        return false;
+
+        return gst_pad_push_event(conv->src_pad, gst_event_new_eos());
     }
 
     video_conv_init_transcode(conv);
+    hash = state->transcode_hash;
+    state_flags = state->state_flags;
     transcode_tag = state->transcoded_tag;
 
     pthread_mutex_unlock(&conv->state_mutex);
 
-    return video_conv_push_caps(conv, transcode_tag);
+    if (!(state_flags & VIDEO_CONV_STREAM_STARTED))
+    {
+        /* rewind and start a new stream for dumping or playback */
+        if (!push_event(conv->sink_pad, gst_event_new_seek(1.0, GST_FORMAT_BYTES, GST_SEEK_FLAG_FLUSH,
+                GST_SEEK_TYPE_SET, 0, GST_SEEK_TYPE_NONE, -1)))
+            return false;
+        if (!video_conv_push_stream_start(conv, &hash))
+            return false;
+        if (!video_conv_push_caps(conv, transcode_tag))
+            return false;
+
+        /* return false to cancel upstream pads EOS event handling and avoid setting EOS flag */
+        return false;
+    }
+
+    return gst_pad_push_event(conv->src_pad, gst_event_new_eos());
 }
 
 static gboolean video_conv_sink_event(GstPad *pad, GstObject *parent, GstEvent *event)
@@ -723,8 +856,167 @@ static gboolean video_conv_sink_event(GstPad *pad, GstObject *parent, GstEvent *
 
     if (event->type == GST_EVENT_CAPS)
         return video_conv_sink_event_caps(conv, event);
+    if (event->type == GST_EVENT_EOS)
+        return video_conv_sink_event_eos(conv, event);
+
+    if (video_conv_get_state_flags(conv) & VIDEO_CONV_STREAM_STARTED)
+        return gst_pad_event_default(pad, parent, event);
+
+    gst_event_unref(event);
+    return true;
+}
+
+static gboolean video_conv_src_event_seek(VideoConv *conv, GstEvent *event)
+{
+    guint seqnum = gst_event_get_seqnum(event);
+    guint64 upstream_offset, upstream_size;
+    GstSeekType offset_type, stop_type;
+    struct video_conv_state *state;
+    gint64 offset, stop;
+    GstSeekFlags flags;
+    GstFormat format;
+    gdouble rate;
+
+    gst_event_parse_seek(event, &rate, &format, &flags, &offset_type, &offset, &stop_type, &stop);
+    gst_event_unref(event);
+    if (format != GST_FORMAT_BYTES)
+        return false;
+
+    GST_TRACE("conv %p, rate %f, format %s, flags %#x, offset_type %u, cur %#" G_GINT64_MODIFIER "x, "
+            "stop_type %u, stop %#" G_GINT64_MODIFIER "x.", conv, rate, gst_format_get_name(format),
+            flags, offset_type, offset, stop_type, stop);
+
+    if (!(state = video_conv_lock_state(conv)))
+        return GST_FLOW_ERROR;
+    if (state->state_flags & VIDEO_CONV_IS_DUMPING)
+    {
+        pthread_mutex_unlock(&conv->state_mutex);
+        return true;
+    }
+    pthread_mutex_unlock(&conv->state_mutex);
+
+    if (!video_conv_get_upstream_range(conv, offset, HASH_CHUNK_SIZE, &upstream_offset, &upstream_size))
+        return false;
+
+    if ((event = gst_event_new_seek(1.0, GST_FORMAT_BYTES, GST_SEEK_FLAG_FLUSH,
+            GST_SEEK_TYPE_SET, upstream_offset, GST_SEEK_TYPE_NONE, -1)))
+        gst_event_set_seqnum(event, seqnum);
+    return push_event(conv->sink_pad, event);
+}
+
+static gboolean video_conv_src_event(GstPad *pad, GstObject *parent, GstEvent *event)
+{
+    VideoConv *conv = VIDEO_CONV(parent);
+
+    GST_DEBUG_OBJECT(pad, "Got event %"GST_PTR_FORMAT".", event);
+
+    if (event->type == GST_EVENT_SEEK)
+        return video_conv_src_event_seek(conv, event);
+
+    if (video_conv_get_state_flags(conv) & VIDEO_CONV_STREAM_STARTED)
+        return gst_pad_event_default(pad, parent, event);
+
+    gst_event_unref(event);
+    return true;
+}
+
+static void video_conv_dump_buffered_chunks(VideoConv *conv, gsize bytes_available)
+{
+    struct video_conv_state *state = conv->state;
+    int ret;
+
+    while (bytes_available >= HASH_CHUNK_SIZE)
+    {
+        const void *buffer = gst_adapter_map(conv->adapter, HASH_CHUNK_SIZE);
+        if ((ret = video_conv_dump_upstream_chunk(conv, buffer, HASH_CHUNK_SIZE, &state->chunk_hashes)) < 0)
+        {
+            pthread_mutex_unlock(&dump_fozdb.mutex);
+            state->state_flags &= ~VIDEO_CONV_IS_DUMPING;
+            break;
+        }
+
+        gst_adapter_unmap(conv->adapter);
+        gst_adapter_flush(conv->adapter, HASH_CHUNK_SIZE);
+        bytes_available -= HASH_CHUNK_SIZE;
+    }
+}
+
+static GstFlowReturn video_conv_sink_chain(GstPad *pad, GstObject *parent, GstBuffer *buffer)
+{
+    gsize buffer_size = gst_buffer_get_size(buffer), buffer_offset = GST_BUFFER_OFFSET(buffer);
+    uint64_t downstream_offset, downstream_end, seek_offset = -1;
+    VideoConv *conv = VIDEO_CONV(parent);
+    struct video_conv_state *state;
+    GstBuffer *transcoded = NULL;
+    uint32_t state_flags;
+    int ret = 0;
+
+    GST_DEBUG_OBJECT(pad, "Got buffer %"GST_PTR_FORMAT".", buffer);
+
+    if (!(state = video_conv_lock_state(conv)))
+        return GST_FLOW_ERROR;
+    state_flags = state->state_flags;
+
+    if ((state_flags & VIDEO_CONV_IS_DUMPING) || !(state_flags & VIDEO_CONV_STREAM_STARTED))
+    {
+        gsize bytes_available = gst_adapter_available(conv->adapter) + buffer_size;
+        gst_adapter_push(conv->adapter, buffer);
+
+        if (state_flags & VIDEO_CONV_IS_DUMPING)
+            video_conv_dump_buffered_chunks(conv, bytes_available);
+        else if (!(bytes_available % HASH_CHUNK_SIZE) && bytes_available >= HASH_STRIDE)
+        {
+            state->read_offset += HASH_STRIDE;
+            seek_offset = state->read_offset;
+        }
+    }
+
+    pthread_mutex_unlock(&conv->state_mutex);
+
+    if (ret < 0)
+    {
+        GST_ERROR("Failed to dump or read transcoded buffer, error %d.", ret);
+        if (transcoded)
+            gst_buffer_unref(transcoded);
+        return GST_FLOW_ERROR;
+    }
+
+    if (seek_offset != -1 && !push_event(pad, gst_event_new_seek(1.0, GST_FORMAT_BYTES, GST_SEEK_FLAG_FLUSH,
+            GST_SEEK_TYPE_SET, seek_offset, GST_SEEK_TYPE_NONE, -1)))
+        return GST_FLOW_ERROR;
+    if (!(state_flags & VIDEO_CONV_STREAM_STARTED))
+        return GST_FLOW_OK;
 
-    return gst_pad_event_default(pad, parent, event);
+    if (!video_conv_get_downstream_range(conv, buffer_offset, buffer_offset + buffer_size,
+            &downstream_offset, &downstream_end))
+        return GST_FLOW_ERROR;
+
+    if (downstream_end == downstream_offset)
+        return GST_FLOW_OK;
+    if (!(transcoded = gst_buffer_new_and_alloc(downstream_end - downstream_offset)))
+        return GST_FLOW_ERROR;
+    else
+    {
+        GstBufferMapInfo map;
+        size_t fill_size = 0;
+
+        if (gst_buffer_map(transcoded, &map, GST_MAP_READWRITE))
+        {
+            ret = video_conv_state_fill_buffer(state, downstream_offset, map.data, map.size, &fill_size);
+            gst_buffer_unmap(transcoded, &map);
+            gst_buffer_set_size(transcoded, fill_size);
+        }
+
+        if (gst_buffer_get_size(transcoded))
+        {
+            GST_BUFFER_OFFSET(transcoded) = downstream_offset;
+            return gst_pad_push(conv->src_pad, transcoded);
+        }
+
+        gst_buffer_unref(transcoded);
+    }
+
+    return GST_FLOW_OK;
 }
 
 static GstFlowReturn video_conv_src_get_range(GstPad *pad, GstObject *parent,
@@ -825,7 +1117,13 @@ static gboolean video_conv_src_query(GstPad *pad, GstObject *parent, GstQuery *q
         gst_query_unref(peer_query);
 
         gst_query_set_scheduling(query, flags, min, max, align);
-        gst_query_add_scheduling_mode(query, GST_PAD_MODE_PULL);
+        if (conv->active_mode != GST_PAD_MODE_NONE)
+            gst_query_add_scheduling_mode(query, conv->active_mode);
+        else
+        {
+            gst_query_add_scheduling_mode(query, GST_PAD_MODE_PULL);
+            gst_query_add_scheduling_mode(query, GST_PAD_MODE_PUSH);
+        }
 
         return true;
 
@@ -870,6 +1168,7 @@ static gboolean video_conv_src_active_mode(GstPad *pad, GstObject *parent, GstPa
         return false;
     }
 
+    conv->active_mode = mode;
     if (mode != GST_PAD_MODE_PULL)
         return true;
 
@@ -897,6 +1196,7 @@ static void video_conv_finalize(GObject *object)
 {
     VideoConv *conv = VIDEO_CONV(object);
 
+    gst_object_unref(conv->adapter);
     pthread_mutex_destroy(&conv->state_mutex);
     if (conv->state)
         video_conv_state_release(conv->state);
@@ -928,9 +1228,11 @@ static void video_conv_init(VideoConv *conv)
 
     conv->sink_pad = gst_pad_new_from_static_template(&video_conv_sink_template, "sink");
     gst_pad_set_event_function(conv->sink_pad, GST_DEBUG_FUNCPTR(video_conv_sink_event));
+    gst_pad_set_chain_function(conv->sink_pad, GST_DEBUG_FUNCPTR(video_conv_sink_chain));
     gst_element_add_pad(element, conv->sink_pad);
 
     conv->src_pad = gst_pad_new_from_static_template(&video_conv_src_template, "src");
+    gst_pad_set_event_function(conv->src_pad, GST_DEBUG_FUNCPTR(video_conv_src_event));
     gst_pad_set_getrange_function(conv->src_pad, GST_DEBUG_FUNCPTR(video_conv_src_get_range));
     gst_pad_set_query_function(conv->src_pad, GST_DEBUG_FUNCPTR(video_conv_src_query));
     gst_pad_set_activatemode_function(conv->src_pad, GST_DEBUG_FUNCPTR(video_conv_src_active_mode));
@@ -938,4 +1240,6 @@ static void video_conv_init(VideoConv *conv)
 
     pthread_mutex_init(&conv->state_mutex, NULL);
     conv->state = NULL;
+    conv->adapter = gst_adapter_new();
+    conv->active_mode = GST_PAD_MODE_NONE;
 }
-- 
2.49.0

From 8181dd33d9ea7959e78ee3c179db8c3be5e0d62e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 5 Mar 2024 10:54:28 +0100
Subject: [PATCH 0201/1564] winegstreamer/media-converter: Wrap videoconv and a
 demuxer in a new protondemuxer bin.

CW-Bug-Id: #22319
---
 dlls/winegstreamer/Makefile.in                |   1 +
 dlls/winegstreamer/media-converter/lib.c      |   7 +
 .../media-converter/protondemuxer.c           | 223 ++++++++++++++++++
 .../winegstreamer/media-converter/videoconv.c |   2 +-
 4 files changed, 232 insertions(+), 1 deletion(-)
 create mode 100644 dlls/winegstreamer/media-converter/protondemuxer.c

diff --git a/dlls/winegstreamer/Makefile.in b/dlls/winegstreamer/Makefile.in
index e2cc1123f10..c623b90f896 100644
--- a/dlls/winegstreamer/Makefile.in
+++ b/dlls/winegstreamer/Makefile.in
@@ -15,6 +15,7 @@ SOURCES = \
 	media-converter/fossilize.c \
 	media-converter/lib.c \
 	media-converter/murmur3.c \
+	media-converter/protondemuxer.c \
 	media-converter/videoconv.c \
 	media_sink.c \
 	media_source.c \
diff --git a/dlls/winegstreamer/media-converter/lib.c b/dlls/winegstreamer/media-converter/lib.c
index 852bf7b6bc4..97c5e0f0ec3 100644
--- a/dlls/winegstreamer/media-converter/lib.c
+++ b/dlls/winegstreamer/media-converter/lib.c
@@ -26,6 +26,7 @@
 GST_ELEMENT_REGISTER_DECLARE(protonvideoconverter);
 GST_ELEMENT_REGISTER_DECLARE(protonaudioconverter);
 GST_ELEMENT_REGISTER_DECLARE(protonaudioconverterbin);
+GST_ELEMENT_REGISTER_DECLARE(protondemuxer);
 
 GST_DEBUG_CATEGORY(media_converter_debug);
 
@@ -325,5 +326,11 @@ bool media_converter_init(void)
         return false;
     }
 
+    if (!GST_ELEMENT_REGISTER(protondemuxer, NULL))
+    {
+        GST_ERROR("Failed to register protondemuxer.");
+        return false;
+    }
+
     return true;
 }
diff --git a/dlls/winegstreamer/media-converter/protondemuxer.c b/dlls/winegstreamer/media-converter/protondemuxer.c
new file mode 100644
index 00000000000..9ab4be5ae3c
--- /dev/null
+++ b/dlls/winegstreamer/media-converter/protondemuxer.c
@@ -0,0 +1,223 @@
+/*
+ * Copyright 2024 Remi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "media-converter.h"
+
+GST_DEBUG_CATEGORY_EXTERN(media_converter_debug);
+#undef GST_CAT_DEFAULT
+#define GST_CAT_DEFAULT media_converter_debug
+
+typedef struct
+{
+    GstBin bin;
+    GstElement *video_conv, *demuxer;
+    GstPad *sink_pad; /* Ghost pad. */
+    GstPad *inner_sink, *inner_src;
+} ProtonDemuxer;
+
+typedef struct
+{
+    GstBinClass class;
+} ProtonDemuxerClass;
+
+G_DEFINE_TYPE(ProtonDemuxer, proton_demuxer, GST_TYPE_BIN);
+#define PROTON_DEMUXER_TYPE (proton_demuxer_get_type())
+#define PROTON_DEMUXER(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), PROTON_DEMUXER_TYPE, ProtonDemuxer))
+GST_ELEMENT_REGISTER_DEFINE(protondemuxer, "protondemuxer", GST_RANK_MARGINAL, PROTON_DEMUXER_TYPE);
+
+static GstStaticPadTemplate proton_demuxer_sink_template = GST_STATIC_PAD_TEMPLATE("sink", GST_PAD_SINK,
+        GST_PAD_ALWAYS, GST_STATIC_CAPS("video/x-ms-asf; video/x-msvideo; video/mpeg; video/quicktime;"));
+static GstStaticPadTemplate proton_demuxer_src_template = GST_STATIC_PAD_TEMPLATE("src", GST_PAD_SRC,
+        GST_PAD_ALWAYS, GST_STATIC_CAPS_ANY);
+
+static gboolean proton_demuxer_sink_event(GstPad *pad, GstObject *parent, GstEvent *event)
+{
+    GST_DEBUG_OBJECT(pad, "Got sink event %"GST_PTR_FORMAT".", event);
+    return gst_pad_event_default(pad, parent, event);
+}
+
+static void proton_demuxer_pad_added(GstElement *element, GstPad *pad, gpointer user)
+{
+    ProtonDemuxer *bin = PROTON_DEMUXER(user);
+    GstPad *ghost_src;
+    GstEvent *event;
+
+    GST_DEBUG_OBJECT(element, "Got inner pad added %"GST_PTR_FORMAT".", pad);
+
+    ghost_src = gst_ghost_pad_new(GST_PAD_NAME(pad), pad);
+    gst_pad_set_active(ghost_src, true);
+
+    if ((event = gst_pad_get_sticky_event(pad, GST_EVENT_STREAM_START, 0)))
+    {
+        gst_pad_store_sticky_event(ghost_src, event);
+        gst_event_unref(event);
+    }
+
+    gst_element_add_pad(GST_ELEMENT(&bin->bin), ghost_src);
+}
+
+static void proton_demuxer_no_more_pads(GstElement *element, gpointer user)
+{
+    ProtonDemuxer *bin = PROTON_DEMUXER(user);
+    GST_DEBUG_OBJECT(element, "Got inner no-more-pads.");
+    gst_element_no_more_pads(GST_ELEMENT(&bin->bin));
+}
+
+static GstFlowReturn proton_demuxer_inner_sink_chain(GstPad *pad, GstObject *parent, GstBuffer *buffer)
+{
+    ProtonDemuxer *bin = PROTON_DEMUXER(gst_pad_get_element_private(pad));
+    GST_DEBUG_OBJECT(pad, "Got inner sink buffer %"GST_PTR_FORMAT".", buffer);
+    return gst_pad_push(bin->inner_src, buffer);
+}
+
+static gboolean proton_demuxer_inner_sink_event_caps(ProtonDemuxer *bin, GstEvent *event)
+{
+    GstCaps *src_caps, *any_caps;
+    GstEvent *stream_start;
+    GstPad *src;
+
+    gst_event_parse_caps(event, &src_caps);
+
+    if (!bin->demuxer)
+    {
+        if (!(any_caps = gst_caps_new_any()))
+            return false;
+        if (!(bin->demuxer = find_element(GST_ELEMENT_FACTORY_TYPE_DECODABLE, src_caps, any_caps)))
+        {
+            gst_caps_unref(any_caps);
+            return false;
+        }
+        gst_caps_unref(any_caps);
+        g_signal_connect(bin->demuxer, "pad-added", G_CALLBACK(proton_demuxer_pad_added), bin);
+        g_signal_connect(bin->demuxer, "no-more-pads", G_CALLBACK(proton_demuxer_no_more_pads), bin);
+
+        if ((src = gst_element_get_static_pad(bin->demuxer, "src")))
+        {
+            GstPad *ghost_src = gst_ghost_pad_new_no_target_from_template(GST_PAD_NAME(src),
+               gst_element_get_pad_template(GST_ELEMENT(&bin->bin), "src"));
+            gst_ghost_pad_set_target(GST_GHOST_PAD(ghost_src), src);
+            gst_element_add_pad(GST_ELEMENT(&bin->bin), ghost_src);
+            gst_object_unref(src);
+
+            gst_element_no_more_pads(GST_ELEMENT(&bin->bin));
+        }
+
+        gst_bin_add(GST_BIN(bin), bin->demuxer);
+        link_src_to_element(bin->inner_src, bin->demuxer);
+        gst_pad_set_active(bin->inner_src, true);
+
+        if ((stream_start = gst_pad_get_sticky_event(bin->inner_sink, GST_EVENT_STREAM_START, 0)))
+            push_event(bin->inner_src, stream_start);
+
+        gst_element_sync_state_with_parent(bin->demuxer);
+    }
+
+    return gst_pad_push_event(bin->inner_src, event);
+}
+
+static gboolean proton_demuxer_inner_sink_event(GstPad *pad, GstObject *parent, GstEvent *event)
+{
+    ProtonDemuxer *bin = PROTON_DEMUXER(gst_pad_get_element_private(pad));
+
+    GST_DEBUG_OBJECT(pad, "Got inner sink event %"GST_PTR_FORMAT".", event);
+
+    if (event->type == GST_EVENT_CAPS)
+        return proton_demuxer_inner_sink_event_caps(bin, event);
+    if (!bin->demuxer)
+        return gst_pad_event_default(pad, parent, event);
+    if (event->type == GST_EVENT_STREAM_START)
+    {
+        GstEvent *stream_start;
+        if ((stream_start = gst_pad_get_sticky_event(bin->inner_src, GST_EVENT_STREAM_START, 0)))
+            push_event(bin->inner_src, stream_start);
+        return gst_pad_event_default(pad, parent, event);
+    }
+
+    return gst_pad_push_event(bin->inner_src, event);
+}
+
+static gboolean proton_demuxer_inner_src_query(GstPad *pad, GstObject *parent, GstQuery *query)
+{
+    ProtonDemuxer *bin = PROTON_DEMUXER(gst_pad_get_element_private(pad));
+
+    GST_DEBUG_OBJECT(pad, "Got inner src query %"GST_PTR_FORMAT".", query);
+
+    if (!bin->demuxer)
+        return gst_pad_query_default(pad, parent, query);
+    return gst_pad_peer_query(bin->inner_sink, query);
+}
+
+static gboolean proton_demuxer_inner_src_event(GstPad *pad, GstObject *parent, GstEvent *event)
+{
+    ProtonDemuxer *bin = PROTON_DEMUXER(gst_pad_get_element_private(pad));
+    GST_DEBUG_OBJECT(pad, "Got inner src event %"GST_PTR_FORMAT".", event);
+    return gst_pad_push_event(bin->inner_sink, event);
+}
+
+static void proton_demuxer_class_init(ProtonDemuxerClass * klass)
+{
+    GstElementClass *element_class = GST_ELEMENT_CLASS(klass);
+
+    /* wg_parser autoplugging ordering relies on the element "Proton video converter" name */
+    gst_element_class_set_metadata(element_class, "Proton video converter", "Codec/Demuxer", "Demuxes video for Proton",
+            "Andrew Eikum <aeikum@codeweavers.com>, Ziqing Hui <zhui@codeweavers.com>");
+
+    gst_element_class_add_pad_template(element_class, gst_static_pad_template_get(&proton_demuxer_sink_template));
+    gst_element_class_add_pad_template(element_class, gst_static_pad_template_get(&proton_demuxer_src_template));
+}
+
+static void proton_demuxer_init(ProtonDemuxer *bin)
+{
+    GstStaticPadTemplate inner_sink_template = GST_STATIC_PAD_TEMPLATE("inner-sink",
+            GST_PAD_SINK, GST_PAD_ALWAYS, GST_STATIC_CAPS_ANY);
+    GstStaticPadTemplate inner_src_template = GST_STATIC_PAD_TEMPLATE("inner-src",
+            GST_PAD_SRC, GST_PAD_ALWAYS, GST_STATIC_CAPS_ANY);
+    GstElement *element = GST_ELEMENT(bin);
+    GstPad *sink;
+
+    bin->sink_pad = gst_ghost_pad_new_no_target_from_template("sink", gst_element_get_pad_template(element, "sink"));
+    gst_pad_set_event_function(bin->sink_pad, GST_DEBUG_FUNCPTR(proton_demuxer_sink_event));
+
+    bin->inner_sink = gst_pad_new_from_static_template(&inner_sink_template, "inner-sink");
+    gst_pad_set_chain_function(bin->inner_sink, GST_DEBUG_FUNCPTR(proton_demuxer_inner_sink_chain));
+    gst_pad_set_event_function(bin->inner_sink, GST_DEBUG_FUNCPTR(proton_demuxer_inner_sink_event));
+    gst_pad_set_element_private(bin->inner_sink, bin);
+
+    bin->inner_src = gst_pad_new_from_static_template(&inner_src_template, "inner-src");
+    gst_pad_set_query_function(bin->inner_src, GST_DEBUG_FUNCPTR(proton_demuxer_inner_src_query));
+    gst_pad_set_event_function(bin->inner_src, GST_DEBUG_FUNCPTR(proton_demuxer_inner_src_event));
+    gst_pad_set_element_private(bin->inner_src, bin);
+
+    bin->video_conv = create_element("protonvideoconverter", "protonmediaconverter");
+    gst_bin_add(GST_BIN(bin), bin->video_conv);
+    link_element_to_sink(bin->video_conv, bin->inner_sink);
+    gst_pad_set_active(bin->inner_sink, true);
+
+    sink = gst_element_get_static_pad(bin->video_conv, "sink");
+    gst_ghost_pad_set_target(GST_GHOST_PAD(bin->sink_pad), sink);
+    gst_object_unref(sink);
+
+    gst_element_add_pad(element, bin->sink_pad);
+
+    GST_INFO("Initialized ProtonDemuxer %"GST_PTR_FORMAT": video_conv %"GST_PTR_FORMAT", demuxer %"GST_PTR_FORMAT", "
+            "sink_pad %"GST_PTR_FORMAT".", bin, bin->video_conv, bin->demuxer, bin->sink_pad);
+}
diff --git a/dlls/winegstreamer/media-converter/videoconv.c b/dlls/winegstreamer/media-converter/videoconv.c
index 97bb098f311..cecac16c85a 100644
--- a/dlls/winegstreamer/media-converter/videoconv.c
+++ b/dlls/winegstreamer/media-converter/videoconv.c
@@ -129,7 +129,7 @@ G_DEFINE_TYPE(VideoConv, video_conv, GST_TYPE_ELEMENT);
 #define VIDEO_CONV(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), VIDEO_CONV_TYPE, VideoConv))
 #define parent_class    (video_conv_parent_class)
 GST_ELEMENT_REGISTER_DEFINE(protonvideoconverter, "protonvideoconverter",
-        GST_RANK_MARGINAL, VIDEO_CONV_TYPE);
+        GST_RANK_MARGINAL + 1, VIDEO_CONV_TYPE);
 
 static GstStaticPadTemplate video_conv_sink_template = GST_STATIC_PAD_TEMPLATE("sink",
         GST_PAD_SINK, GST_PAD_ALWAYS,
-- 
2.49.0

From 49cd1cda74626432b7b5e4b1df7eb6e30d7847e0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 5 Mar 2024 22:23:44 +0100
Subject: [PATCH 0202/1564] winegstreamer/media-converter: Automatically add an
 audio decoder to protondemuxer.

CW-Bug-Id: #22319
---
 .../media-converter/protondemuxer.c           | 33 +++++++++++++++++--
 1 file changed, 30 insertions(+), 3 deletions(-)

diff --git a/dlls/winegstreamer/media-converter/protondemuxer.c b/dlls/winegstreamer/media-converter/protondemuxer.c
index 9ab4be5ae3c..124d105ca46 100644
--- a/dlls/winegstreamer/media-converter/protondemuxer.c
+++ b/dlls/winegstreamer/media-converter/protondemuxer.c
@@ -58,13 +58,39 @@ static gboolean proton_demuxer_sink_event(GstPad *pad, GstObject *parent, GstEve
 static void proton_demuxer_pad_added(GstElement *element, GstPad *pad, gpointer user)
 {
     ProtonDemuxer *bin = PROTON_DEMUXER(user);
-    GstPad *ghost_src;
+    GstPad *ghost_src, *src_pad;
+    GstElement *decoder = NULL;
     GstEvent *event;
+    GstCaps *caps;
 
     GST_DEBUG_OBJECT(element, "Got inner pad added %"GST_PTR_FORMAT".", pad);
 
-    ghost_src = gst_ghost_pad_new(GST_PAD_NAME(pad), pad);
-    gst_pad_set_active(ghost_src, true);
+    if ((caps = gst_pad_get_current_caps(pad)))
+    {
+        const char *mime_type = gst_structure_get_name(gst_caps_get_structure(caps, 0));
+        GST_DEBUG_OBJECT(element, "Got inner pad caps %"GST_PTR_FORMAT".", caps);
+
+        if (!strcmp(mime_type, "audio/x-vorbis"))
+            decoder = create_element("vorbisdec", "base");
+        else if (!strcmp(mime_type, "audio/x-opus"))
+            decoder = create_element("opusdec", "base");
+
+        gst_caps_unref(caps);
+    }
+
+    if (!decoder)
+        ghost_src = gst_ghost_pad_new(GST_PAD_NAME(pad), pad);
+    else
+    {
+        gst_bin_add(GST_BIN(bin), decoder);
+        link_src_to_element(pad, decoder);
+
+        src_pad = gst_element_get_static_pad(decoder, "src");
+        ghost_src = gst_ghost_pad_new(GST_PAD_NAME(src_pad), src_pad);
+        gst_object_unref(src_pad);
+
+        gst_element_sync_state_with_parent(decoder);
+    }
 
     if ((event = gst_pad_get_sticky_event(pad, GST_EVENT_STREAM_START, 0)))
     {
@@ -72,6 +98,7 @@ static void proton_demuxer_pad_added(GstElement *element, GstPad *pad, gpointer
         gst_event_unref(event);
     }
 
+    gst_pad_set_active(ghost_src, true);
     gst_element_add_pad(GST_ELEMENT(&bin->bin), ghost_src);
 }
 
-- 
2.49.0

From 5aa4a0af6d4b5f5ce72cc1d11e54c65b92ad3e28 Mon Sep 17 00:00:00 2001
From: Ziqing Hui <zhui@codeweavers.com>
Date: Mon, 29 Apr 2024 16:49:51 +0800
Subject: [PATCH 0203/1564] winegstreamer/media-converter: Expose untranscoded
 stream codec format.

For transcoded videos, codec formats change. However, some games rely on
the untranscoded codec format. So we have to expose the untranscoded codec
formats for them.

This also needs transcoded files holding untranscoded stream codec info.

CW-Bug-Id: #21303
CW-Bug-Id: #22008
---
 .../winegstreamer/media-converter/videoconv.c | 164 +++++++++++++++++-
 dlls/winegstreamer/unix_private.h             |   5 +
 dlls/winegstreamer/unixlib.c                  |   2 -
 3 files changed, 167 insertions(+), 4 deletions(-)

diff --git a/dlls/winegstreamer/media-converter/videoconv.c b/dlls/winegstreamer/media-converter/videoconv.c
index cecac16c85a..51e78c39ec0 100644
--- a/dlls/winegstreamer/media-converter/videoconv.c
+++ b/dlls/winegstreamer/media-converter/videoconv.c
@@ -70,7 +70,8 @@
 #define VIDEO_CONV_FOZ_TAG_OGVDATA   1
 #define VIDEO_CONV_FOZ_TAG_STREAM    2
 #define VIDEO_CONV_FOZ_TAG_MKVDATA   3
-#define VIDEO_CONV_FOZ_NUM_TAGS      4
+#define VIDEO_CONV_FOZ_TAG_CODEC     4
+#define VIDEO_CONV_FOZ_NUM_TAGS      5
 
 #define DURATION_NONE (UINT64_MAX)
 
@@ -1191,7 +1192,6 @@ static gboolean video_conv_src_active_mode(GstPad *pad, GstObject *parent, GstPa
     return true;
 }
 
-
 static void video_conv_finalize(GObject *object)
 {
     VideoConv *conv = VIDEO_CONV(object);
@@ -1243,3 +1243,163 @@ static void video_conv_init(VideoConv *conv)
     conv->adapter = gst_adapter_new();
     conv->active_mode = GST_PAD_MODE_NONE;
 }
+
+static bool codec_info_to_wg_format(char *codec_info, struct wg_format *codec_format)
+{
+    char *codec_name = codec_info;
+
+    /* Get codec name. */
+    while (*codec_info && *codec_info != ' ')
+        ++codec_info;
+    *(codec_info++) = 0;
+
+    /* FIXME: Get width, height, fps etc. from codec info string. */
+    if (strcmp(codec_name, "cinepak") == 0)
+    {
+        codec_format->major_type = WG_MAJOR_TYPE_VIDEO_CINEPAK;
+    }
+    else if (strcmp(codec_name, "h264") == 0)
+    {
+        codec_format->major_type = WG_MAJOR_TYPE_VIDEO_H264;
+    }
+    else if (strcmp(codec_name, "wmv1") == 0)
+    {
+        codec_format->major_type = WG_MAJOR_TYPE_VIDEO_WMV;
+        codec_format->u.video.format = WG_VIDEO_FORMAT_WMV1;
+    }
+    else if (strcmp(codec_name, "wmv2") == 0)
+    {
+        codec_format->major_type = WG_MAJOR_TYPE_VIDEO_WMV;
+        codec_format->u.video.format = WG_VIDEO_FORMAT_WMV2;
+    }
+    else if (strcmp(codec_name, "wmv3") == 0)
+    {
+        codec_format->major_type = WG_MAJOR_TYPE_VIDEO_WMV;
+        codec_format->u.video.format = WG_VIDEO_FORMAT_WMV3;
+    }
+    else if  (strcmp(codec_name, "vc1") == 0)
+    {
+        codec_format->major_type = WG_MAJOR_TYPE_VIDEO_WMV;
+        codec_format->u.video.format = WG_VIDEO_FORMAT_WVC1;
+    }
+    else if  (strcmp(codec_name, "wmav1") == 0)
+    {
+        codec_format->major_type = WG_MAJOR_TYPE_AUDIO_WMA;
+        codec_format->u.audio.version = 1;
+    }
+    else if  (strcmp(codec_name, "wmav2") == 0)
+    {
+        codec_format->major_type = WG_MAJOR_TYPE_AUDIO_WMA;
+        codec_format->u.audio.version = 2;
+    }
+    else if  (strcmp(codec_name, "wmapro") == 0)
+    {
+        codec_format->major_type = WG_MAJOR_TYPE_AUDIO_WMA;
+        codec_format->u.audio.version = 3;
+    }
+    else if  (strcmp(codec_name, "wmalossless") == 0)
+    {
+        codec_format->major_type = WG_MAJOR_TYPE_AUDIO_WMA;
+        codec_format->u.audio.version = 4;
+    }
+    else if  (strcmp(codec_name, "xma1") == 0)
+    {
+        codec_format->major_type = WG_MAJOR_TYPE_AUDIO_WMA;
+        codec_format->u.audio.version = 1;
+        codec_format->u.audio.is_xma = true;
+    }
+    else if  (strcmp(codec_name, "xma2") == 0)
+    {
+        codec_format->major_type = WG_MAJOR_TYPE_AUDIO_WMA;
+        codec_format->u.audio.version = 2;
+        codec_format->u.audio.is_xma = true;
+    }
+    else
+    {
+        GST_FIXME("Unsupported codec name: %s.\n", codec_name);
+        return false;
+    }
+
+    GST_INFO("Got codec format major type %u.", codec_format->major_type);
+
+    return true;
+}
+
+gint compare_type(const GValue *value_element, GType type)
+{
+    GstElement *element = g_value_get_object(value_element);
+    return !G_TYPE_CHECK_INSTANCE_TYPE(element, type);
+}
+
+static GstElement *gst_bin_get_by_type(GstBin * bin, GType type)
+{
+    GstElement *element = NULL;
+    GstIterator *children;
+    GValue result = {0};
+    gboolean found;
+
+    children = gst_bin_iterate_recurse(bin);
+    found = gst_iterator_find_custom(children, (GCompareFunc)compare_type,
+            &result, (gpointer)type);
+    gst_iterator_free(children);
+
+    if (found)
+    {
+        element = g_value_dup_object(&result);
+        g_value_unset (&result);
+    }
+
+    return element;
+}
+
+bool get_untranscoded_stream_format(GstElement *container, uint32_t stream_index, struct wg_format *codec_format)
+{
+    struct video_conv_state *state;
+    uint8_t *buffer = NULL;
+    uint32_t entry_size, i;
+    char *codec_info;
+    size_t read_size;
+    bool ret = false;
+    VideoConv *conv;
+    int conv_ret;
+
+    if (!(conv = VIDEO_CONV(gst_bin_get_by_type(GST_BIN(container), VIDEO_CONV_TYPE))))
+    {
+        GST_WARNING("Failed to find video converter from %"GST_PTR_FORMAT".", container);
+        return false;
+    }
+
+    if (!(state = video_conv_lock_state(conv)))
+        return false;
+    if (!(state->state_flags & VIDEO_CONV_HAS_TRANSCODED))
+        goto done;
+
+    if (fozdb_entry_size(state->read_fozdb, VIDEO_CONV_FOZ_TAG_CODEC, &state->transcode_hash, &entry_size) < 0)
+    {
+        GST_WARNING("Failed to find codec info entry for stream %s.", format_hash(&state->transcode_hash));
+        goto done;
+    }
+
+    buffer = calloc(1, entry_size + 1);
+    if ((conv_ret = fozdb_read_entry_data(state->read_fozdb, VIDEO_CONV_FOZ_TAG_CODEC, &state->transcode_hash, 0,
+            buffer, entry_size, &read_size, false)) < 0)
+    {
+        GST_ERROR("Failed to read codec info, ret %d.", ret);
+        goto done;
+    }
+
+    /* Get stream codec info line by line. */
+    codec_info = strtok((char *)buffer, "\n");
+    for (i = 0; codec_info && i < stream_index; ++i)
+        codec_info = strtok(NULL, "\n");
+
+    GST_INFO("Got codec info \"%s\" for stream %d.\n", codec_info, stream_index);
+
+   ret = codec_info_to_wg_format(codec_info, codec_format);
+
+done:
+    if (buffer)
+        free(buffer);
+    pthread_mutex_unlock(&conv->state_mutex);
+    return ret;
+}
\ No newline at end of file
diff --git a/dlls/winegstreamer/unix_private.h b/dlls/winegstreamer/unix_private.h
index b2cc036c914..4a887849577 100644
--- a/dlls/winegstreamer/unix_private.h
+++ b/dlls/winegstreamer/unix_private.h
@@ -104,4 +104,9 @@ extern void wg_allocator_provide_sample(GstAllocator *allocator, struct wg_sampl
 extern void wg_allocator_release_sample(GstAllocator *allocator, struct wg_sample *sample,
         bool discard_data);
 
+/* media-converter */
+extern bool media_converter_init(void);
+extern bool get_untranscoded_stream_format(GstElement *container, uint32_t stream_index,
+        struct wg_format *codec_format);
+
 #endif /* __WINE_WINEGSTREAMER_UNIX_PRIVATE_H */
diff --git a/dlls/winegstreamer/unixlib.c b/dlls/winegstreamer/unixlib.c
index 644f700027d..406c6f4f5f9 100644
--- a/dlls/winegstreamer/unixlib.c
+++ b/dlls/winegstreamer/unixlib.c
@@ -47,8 +47,6 @@
 
 GST_DEBUG_CATEGORY(wine);
 
-extern bool media_converter_init(void);
-
 static UINT thread_count;
 
 GstStreamType stream_type_from_caps(GstCaps *caps)
-- 
2.49.0

From bdebcca3b01f65ba5f3e61660e675c03a64a93c9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 15 May 2024 21:12:06 +0200
Subject: [PATCH 0204/1564] winegstreamer/media-converter: Push segment event
 before data in push mode.

CW-Bug-Id: #20833
---
 .../winegstreamer/media-converter/videoconv.c | 19 +++++++++++++++++++
 1 file changed, 19 insertions(+)

diff --git a/dlls/winegstreamer/media-converter/videoconv.c b/dlls/winegstreamer/media-converter/videoconv.c
index 51e78c39ec0..c9ec31be422 100644
--- a/dlls/winegstreamer/media-converter/videoconv.c
+++ b/dlls/winegstreamer/media-converter/videoconv.c
@@ -757,6 +757,23 @@ static gboolean video_conv_push_caps(VideoConv *conv, uint32_t transcode_tag)
     return ret;
 }
 
+static gboolean video_conv_push_segment(VideoConv *conv)
+{
+    struct video_conv_state *state;
+    GstSegment segment;
+
+    gst_segment_init(&segment, GST_FORMAT_BYTES);
+    if (!(state = video_conv_lock_state(conv)))
+    {
+        GST_ERROR("VideoConv not yet in READY state?");
+        return false;
+    }
+    segment.stop = state->our_duration;
+    pthread_mutex_unlock(&conv->state_mutex);
+
+    return push_event(conv->src_pad, gst_event_new_segment(&segment));
+}
+
 static gboolean video_conv_sink_event_caps(VideoConv *conv, GstEvent *event)
 {
     struct video_conv_state *state;
@@ -841,6 +858,8 @@ static gboolean video_conv_sink_event_eos(VideoConv *conv, GstEvent *event)
             return false;
         if (!video_conv_push_caps(conv, transcode_tag))
             return false;
+        if (!video_conv_push_segment(conv))
+            return false;
 
         /* return false to cancel upstream pads EOS event handling and avoid setting EOS flag */
         return false;
-- 
2.49.0

From 37b304e027e6561f71cf0615d32deaae97c6632b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 9 Jul 2024 15:22:33 +0200
Subject: [PATCH 0205/1564] winegstreamer/media-converter: Avoid leaking lock
 when dumping is interrupted.

CW-Bug-Id: #20833
---
 dlls/winegstreamer/media-converter/videoconv.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/winegstreamer/media-converter/videoconv.c b/dlls/winegstreamer/media-converter/videoconv.c
index c9ec31be422..d45e2d8be8a 100644
--- a/dlls/winegstreamer/media-converter/videoconv.c
+++ b/dlls/winegstreamer/media-converter/videoconv.c
@@ -387,6 +387,8 @@ static int video_conv_state_create(struct video_conv_state **out)
 
 static void video_conv_state_release(struct video_conv_state *state)
 {
+    if ((state->state_flags & VIDEO_CONV_IS_DUMPING))
+        pthread_mutex_unlock(&dump_fozdb.mutex);
     if (state->read_fozdb)
         fozdb_release(state->read_fozdb);
     close(state->blank_file);
-- 
2.49.0

From 3fa6b13db39a154c3dbc1a12a96de39fe299b47c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 23 Nov 2023 00:45:55 +0100
Subject: [PATCH 0206/1564] HACK: winegstreamer: Use a different gst registry
 file per architecture

---
 dlls/winegstreamer/unixlib.c | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/dlls/winegstreamer/unixlib.c b/dlls/winegstreamer/unixlib.c
index 406c6f4f5f9..a0d7286cc32 100644
--- a/dlls/winegstreamer/unixlib.c
+++ b/dlls/winegstreamer/unixlib.c
@@ -265,6 +265,7 @@ NTSTATUS wg_init_gstreamer(void *arg)
     char *args[] = {arg0, arg1, NULL};
     int argc = ARRAY_SIZE(args) - 1;
     char **argv = args;
+    const char *e;
     GError *err;
     DWORD_PTR process_mask;
 
@@ -283,6 +284,23 @@ NTSTATUS wg_init_gstreamer(void *arg)
      */
     gst_segtrap_set_enabled(false);
 
+    if ((e = getenv("WINE_GST_REGISTRY_DIR")))
+    {
+        char gst_reg[PATH_MAX];
+#if defined(__x86_64__)
+        const char *arch = "/registry.x86_64.bin";
+#elif defined(__i386__)
+        const char *arch = "/registry.i386.bin";
+#elif defined(__aarch64__)
+        const char *arch = "/registry.aarch64.bin";
+#else
+#error Bad arch
+#endif
+        strcpy(gst_reg, e);
+        strcat(gst_reg, arch);
+        setenv("GST_REGISTRY_1_0", gst_reg, 1);
+    }
+
     if (!gst_init_check(&argc, &argv, &err))
     {
         fprintf(stderr, "winegstreamer: failed to initialize GStreamer: %s\n", err->message);
-- 
2.49.0

From 89c9406c8ee567d50726467a797866040be23f4a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 23 Nov 2023 00:53:28 +0100
Subject: [PATCH 0207/1564] HACK: winegstreamer/wg_parser: Enable
 protonvideoconv when decodebin fails.

Squashed with:

HACK: winegstreamer/wg_parser: Fail to plug elements when parser has an error.

CW-Bug-Id: #20819

winegstreamer/wg_parser: Block protonvideoconvert autoplug when not trying for it.
---
 dlls/winegstreamer/wg_parser.c | 77 +++++++++++++++++++++++++++++++++-
 1 file changed, 76 insertions(+), 1 deletion(-)

diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index 710cfe6a0a5..f7735aec373 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -30,6 +30,7 @@
 #include <stdarg.h>
 #include <stdio.h>
 
+#define GLIB_VERSION_MIN_REQUIRED GLIB_VERSION_2_30
 #include <gst/gst.h>
 #include <gst/video/video.h>
 #include <gst/audio/audio.h>
@@ -96,6 +97,8 @@ struct wg_parser
     gchar *sink_caps;
 
     struct input_cache_chunk input_cache_chunks[4];
+
+    bool use_mediaconv;
 };
 static const unsigned int input_cache_chunk_size = 512 << 10;
 
@@ -538,6 +541,8 @@ static GstAutoplugSelectResult autoplug_select_cb(GstElement *bin, GstPad *pad,
 
     GST_INFO("Using \"%s\".", name);
 
+    if (parser->error)
+        return GST_AUTOPLUG_SELECT_SKIP;
     if (strstr(name, "Player protection"))
     {
         GST_WARNING("Blacklisted a/52 decoder because it only works in Totem.");
@@ -548,6 +553,11 @@ static GstAutoplugSelectResult autoplug_select_cb(GstElement *bin, GstPad *pad,
         GST_WARNING("Disabled video acceleration since it breaks in wine.");
         return GST_AUTOPLUG_SELECT_SKIP;
     }
+    if (!strcmp(name, "Proton video converter") && !parser->use_mediaconv)
+    {
+        GST_INFO("Skipping \"Proton video converter\".");
+        return GST_AUTOPLUG_SELECT_SKIP;
+    }
 
     if (!parser->sink_caps && strstr(klass, GST_ELEMENT_FACTORY_KLASS_DEMUXER))
         parser->sink_caps = g_strdup(gst_structure_get_name(gst_caps_get_structure(caps, 0)));
@@ -555,6 +565,34 @@ static GstAutoplugSelectResult autoplug_select_cb(GstElement *bin, GstPad *pad,
     return GST_AUTOPLUG_SELECT_TRY;
 }
 
+static gint find_videoconv_cb(gconstpointer a, gconstpointer b)
+{
+    const GValue *val_a = a, *val_b = b;
+    GstElementFactory *factory_a = g_value_get_object(val_a), *factory_b = g_value_get_object(val_b);
+    const char *name_a = gst_element_factory_get_longname(factory_a), *name_b = gst_element_factory_get_longname(factory_b);
+
+    if (!strcmp(name_a, "Proton video converter"))
+        return -1;
+    if (!strcmp(name_b, "Proton video converter"))
+        return 1;
+    return 0;
+}
+
+static GValueArray *autoplug_sort_cb(GstElement *bin, GstPad *pad,
+        GstCaps *caps, GValueArray *factories, gpointer user)
+{
+    struct wg_parser *parser = user;
+    GValueArray *ret = g_value_array_copy(factories);
+
+    if (!parser->use_mediaconv)
+        return NULL;
+
+    GST_DEBUG("parser %p.", parser);
+
+    g_value_array_sort(ret, find_videoconv_cb);
+    return ret;
+}
+
 static void no_more_pads_cb(GstElement *element, gpointer user)
 {
     struct wg_parser *parser = user;
@@ -1369,6 +1407,7 @@ static gboolean src_activate_mode_cb(GstPad *pad, GstObject *parent, GstPadMode
 static GstBusSyncReply bus_handler_cb(GstBus *bus, GstMessage *msg, gpointer user)
 {
     struct wg_parser *parser = user;
+    const GstStructure *structure;
     gchar *dbg_info = NULL;
     GError *err = NULL;
 
@@ -1409,6 +1448,21 @@ static GstBusSyncReply bus_handler_cb(GstBus *bus, GstMessage *msg, gpointer use
         pthread_cond_signal(&parser->init_cond);
         break;
 
+    case GST_MESSAGE_ELEMENT:
+        structure = gst_message_get_structure(msg);
+        if (gst_structure_has_name(structure, "missing-plugin"))
+        {
+            pthread_mutex_lock(&parser->mutex);
+            if (!parser->use_mediaconv && !parser->output_compressed)
+            {
+                GST_WARNING("Autoplugged element failed to initialise, trying again with protonvideoconvert.");
+                parser->error = true;
+                pthread_cond_signal(&parser->init_cond);
+            }
+            pthread_mutex_unlock(&parser->mutex);
+        }
+        break;
+
     default:
         break;
     }
@@ -1574,6 +1628,8 @@ static NTSTATUS wg_parser_connect(void *args)
     unsigned int i;
     int ret;
 
+    bool use_mediaconv = false;
+
     parser->file_size = params->file_size;
     parser->sink_connected = true;
     if (uri)
@@ -1611,9 +1667,16 @@ static NTSTATUS wg_parser_connect(void *args)
 
     gst_element_set_state(parser->container, GST_STATE_PAUSED);
     ret = gst_element_get_state(parser->container, NULL, NULL, -1);
+
     if (ret == GST_STATE_CHANGE_FAILURE)
     {
-        GST_ERROR("Failed to play stream.");
+        if (!parser->use_mediaconv && !parser->output_compressed)
+        {
+            GST_WARNING("Failed to play media, trying again with protonvideoconvert.");
+            use_mediaconv = true;
+        }
+        else
+            GST_ERROR("Failed to play stream.");
         goto out;
     }
 
@@ -1623,6 +1686,8 @@ static NTSTATUS wg_parser_connect(void *args)
         pthread_cond_wait(&parser->init_cond, &parser->mutex);
     if (parser->error)
     {
+        if (!parser->use_mediaconv && !parser->output_compressed)
+            use_mediaconv = true;
         pthread_mutex_unlock(&parser->mutex);
         goto out;
     }
@@ -1739,6 +1804,15 @@ out:
     pthread_mutex_unlock(&parser->mutex);
     pthread_cond_signal(&parser->read_cond);
 
+    if (use_mediaconv)
+    {
+        HRESULT hr;
+        parser->use_mediaconv = true;
+        hr = wg_parser_connect(args);
+        parser->use_mediaconv = false;
+        return hr;
+    }
+
     return E_FAIL;
 }
 
@@ -1802,6 +1876,7 @@ static BOOL decodebin_parser_init_gst(struct wg_parser *parser)
     g_signal_connect(element, "pad-removed", G_CALLBACK(pad_removed_cb), parser);
     g_signal_connect(element, "autoplug-continue", G_CALLBACK(autoplug_continue_cb), parser);
     g_signal_connect(element, "autoplug-select", G_CALLBACK(autoplug_select_cb), parser);
+    g_signal_connect(element, "autoplug-sort", G_CALLBACK(autoplug_sort_cb), parser);
     g_signal_connect(element, "autoplug-query", G_CALLBACK(autoplug_query_cb), parser);
     g_signal_connect(element, "no-more-pads", G_CALLBACK(no_more_pads_cb), parser);
     g_signal_connect(element, "deep-element-added", G_CALLBACK(deep_element_added_cb), parser);
-- 
2.49.0

From da52b13d085344fd9d21ba7526fb356c3eba8531 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 22 Feb 2022 21:31:55 +0100
Subject: [PATCH 0208/1564] HACK: winegstreamer/wg_transform: Check if the
 decoder accepted our caps.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=51931
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52391
CW-Bug-Id: #19854
CW-Bug-Id: #20966

CW-Bug-Id: #20833
---
 dlls/winegstreamer/wg_transform.c | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
index 558f6572a1b..196180035fa 100644
--- a/dlls/winegstreamer/wg_transform.c
+++ b/dlls/winegstreamer/wg_transform.c
@@ -653,6 +653,20 @@ NTSTATUS wg_transform_create(void *args)
             || !push_event(transform->my_src, event))
         goto out;
 
+    /* Check that the caps event have been accepted */
+    if (!strcmp(input_mime, "video/x-h264"))
+    {
+        GstPad *peer;
+        if (!(peer = gst_pad_get_peer(transform->my_src)))
+            goto out;
+        else if (!gst_pad_has_current_caps(peer))
+        {
+            gst_object_unref(peer);
+            goto out;
+        }
+        gst_object_unref(peer);
+    }
+
     /* We need to use GST_FORMAT_TIME here because it's the only format
      * some elements such avdec_wmav2 correctly support. */
     gst_segment_init(&transform->segment, GST_FORMAT_TIME);
-- 
2.49.0

From 720cad5fac4679bcdfd8ef0300664947c22599d3 Mon Sep 17 00:00:00 2001
From: Arkadiusz Hiler <ahiler@codeweavers.com>
Date: Thu, 3 Nov 2022 18:54:06 +0200
Subject: [PATCH 0209/1564] HACK: winegstreamer: Detect h264 use and create a
 tag file.

CW-Bug-Id: #21473

CW-Bug-Id: #20833
---
 dlls/winegstreamer/unix_private.h | 35 +++++++++++++++++++++++++++++++
 dlls/winegstreamer/wg_parser.c    | 15 +++++++++++++
 dlls/winegstreamer/wg_transform.c |  3 +++
 3 files changed, 53 insertions(+)

diff --git a/dlls/winegstreamer/unix_private.h b/dlls/winegstreamer/unix_private.h
index 4a887849577..a0f1d3ddafd 100644
--- a/dlls/winegstreamer/unix_private.h
+++ b/dlls/winegstreamer/unix_private.h
@@ -27,6 +27,11 @@
 #include <gst/gst.h>
 #include <gst/audio/audio.h>
 
+#include <stdio.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+
 /* unixlib.c */
 
 GST_DEBUG_CATEGORY_EXTERN(wine);
@@ -109,4 +114,34 @@ extern bool media_converter_init(void);
 extern bool get_untranscoded_stream_format(GstElement *container, uint32_t stream_index,
         struct wg_format *codec_format);
 
+static inline void touch_h264_used_tag(void)
+{
+    const char *e;
+
+    GST_LOG("h264 is used");
+
+    if ((e = getenv("STEAM_COMPAT_TRANSCODED_MEDIA_PATH")))
+    {
+        char buffer[PATH_MAX];
+        int fd;
+
+        snprintf(buffer, sizeof(buffer), "%s/h264-used", e);
+
+        fd = open(buffer, O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);
+        if (fd == -1)
+        {
+            GST_WARNING("Failed to open/create \"%s/h264-used\"", e);
+            return;
+        }
+
+        futimens(fd, NULL);
+
+        close(fd);
+    }
+    else
+    {
+        GST_WARNING("STEAM_COMPAT_TRANSCODED_MEDIA_PATH not set, cannot create h264-used file");
+    }
+}
+
 #endif /* __WINE_WINEGSTREAMER_UNIX_PRIVATE_H */
diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index f7735aec373..3c28c4926f8 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -532,6 +532,19 @@ static gboolean autoplug_continue_cb(GstElement * decodebin, GstPad *pad, GstCap
     return !caps_is_compressed(caps);
 }
 
+gboolean caps_detect_h264(GstCapsFeatures *features, GstStructure *structure, gpointer user_data)
+{
+    const char *cap_name = gst_structure_get_name(structure);
+
+    if (!strcmp(cap_name, "video/x-h264"))
+    {
+        touch_h264_used_tag();
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
 static GstAutoplugSelectResult autoplug_select_cb(GstElement *bin, GstPad *pad,
         GstCaps *caps, GstElementFactory *fact, gpointer user)
 {
@@ -541,6 +554,8 @@ static GstAutoplugSelectResult autoplug_select_cb(GstElement *bin, GstPad *pad,
 
     GST_INFO("Using \"%s\".", name);
 
+    gst_caps_foreach(caps, caps_detect_h264, NULL);
+
     if (parser->error)
         return GST_AUTOPLUG_SELECT_SKIP;
     if (strstr(name, "Player protection"))
diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
index 196180035fa..61fdae40d11 100644
--- a/dlls/winegstreamer/wg_transform.c
+++ b/dlls/winegstreamer/wg_transform.c
@@ -592,6 +592,9 @@ NTSTATUS wg_transform_create(void *args)
     GST_INFO("transform %p input caps %"GST_PTR_FORMAT, transform, transform->input_caps);
     input_mime = gst_structure_get_name(gst_caps_get_structure(transform->input_caps, 0));
 
+    if (!strcmp(input_mime, "video/x-h264"))
+        touch_h264_used_tag();
+
     if (!(transform->output_caps = caps_from_media_type(&params->output_type)))
         goto out;
     GST_INFO("transform %p output caps %"GST_PTR_FORMAT, transform, transform->output_caps);
-- 
2.49.0

From 790f525d9b7092426e478927d731c70b1f2e32e7 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 10 Aug 2022 19:11:51 +0200
Subject: [PATCH 0210/1564] HACK: winegstreamer/wg_parser: Use capssetter to
 ignore non-default YUV color spaces.

---
 dlls/winegstreamer/wg_parser.c | 43 ++++++++++++++++++++++++++++++++++
 1 file changed, 43 insertions(+)

diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index 3c28c4926f8..130a3e5669d 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -923,6 +923,49 @@ static bool stream_create_post_processing_elements(GstPad *pad, struct wg_parser
 
     if (!strcmp(name, "video/x-raw"))
     {
+        /* Hack?: Flatten down the colorimetry to default values, without
+         * actually modifying the video at all.
+         *
+         * We want to do color matrix conversions when converting from YUV to
+         * RGB or vice versa. We do *not* want to do color matrix conversions
+         * when converting YUV <-> YUV or RGB <-> RGB, because these are slow
+         * (it essentially means always using the slow path, never going through
+         * liborc). However, we have two videoconvert elements, and it's
+         * basically impossible to know what conversions each is going to do
+         * until caps are negotiated (without depending on some implementation
+         * details, and even then it'snot exactly trivial). And setting
+         * matrix-mode after caps are negotiated has no effect.
+         *
+         * Nor can we just retain colorimetry information the way we retain
+         * other caps values, because videoconvert automatically clears it if
+         * not doing passthrough. I think that this would only happen if we have
+         * to do a double conversion, but that is possible. Not likely, but I
+         * don't want to have to be the one to find out that there's still a
+         * game broken.
+         *
+         * [Note that we'd actually kind of like to retain colorimetry
+         * information, just in case it does ever become relevant to pass that
+         * on to the next DirectShow filter. Hence I think the correct solution
+         * for upstream is to get videoconvert to Not Do That.]
+         *
+         * So as a fallback solution, we force an identity transformation of
+         * the caps to those with a "default" color matrixi.e. transform the
+         * caps, but not the data. We do this by *pre*pending a capssetter to
+         * the front of the chain, and we remove the matrix-mode setting for the
+         * videoconvert elements.
+         */
+        if (!(element = create_element("capssetter", "good"))
+                || !append_element(parser->container, element, &first, &last))
+            return false;
+        gst_util_set_object_arg(G_OBJECT(element), "join", "true");
+        /* Actually, this is invalid, but it causes videoconvert to use default
+         * colorimetry as a result. Yes, this is depending on undocumented
+         * implementation details. It's a hack.
+         *
+         * Sadly there doesn't seem to be a way to get capssetter to clear
+         * certain fields while leaving others untouched. */
+        gst_util_set_object_arg(G_OBJECT(element), "caps", "video/x-raw,colorimetry=0:0:0:0");
+
         /* DirectShow can express interlaced video, but downstream filters can't
          * necessarily consume it. In particular, the video renderer can't. */
         if (!(element = create_element("deinterlace", "good"))
-- 
2.49.0

From 64c78f4438d3226595844b1500fc6ce196d54f89 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 12 May 2023 12:20:17 +0200
Subject: [PATCH 0211/1564] HACK: winegstreamer/wg_parser: Unlink sink pad when
 freeing streams.

As a hack as it is should not be necessary, but, sometimes it looks like
the reference leaks.

CW-Bug-Id: #22045
---
 dlls/winegstreamer/wg_parser.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index 130a3e5669d..09bf94a3c73 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -888,8 +888,14 @@ static struct wg_parser_stream *create_stream(struct wg_parser *parser)
 
 static void free_stream(struct wg_parser_stream *stream)
 {
+    GstPad *peer;
     unsigned int i;
 
+    if ((peer = gst_pad_get_peer(stream->my_sink)))
+    {
+        gst_pad_unlink(peer, stream->my_sink);
+        gst_object_unref(peer);
+    }
     gst_object_unref(stream->my_sink);
 
     if (stream->buffer)
-- 
2.49.0

From e3f03cba8cbbf55010365b976dd528f2cb75465c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 15 Jun 2022 19:12:54 +0200
Subject: [PATCH 0212/1564] HACK: winegstreamer/wg_parser: Set unlimited
 decodebin buffered size.

Fixes problems with Persona 4 while keeping the memory usage lower.

CW-Bug-Id: #18799
CW-Bug-Id: #18994
CW-Bug-Id: #20182
CW-Bug-Id: #20363
CW-Bug-Id: #20905
CW-Bug-Id: #20980
---
 dlls/winegstreamer/wg_parser.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index 09bf94a3c73..b4c8dba0c13 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -1936,6 +1936,7 @@ static BOOL decodebin_parser_init_gst(struct wg_parser *parser)
     gst_bin_add(GST_BIN(parser->container), element);
     parser->decodebin = element;
 
+    g_object_set(element, "max-size-bytes", G_MAXUINT, NULL);
     g_signal_connect(element, "pad-added", G_CALLBACK(pad_added_cb), parser);
     g_signal_connect(element, "pad-removed", G_CALLBACK(pad_removed_cb), parser);
     g_signal_connect(element, "autoplug-continue", G_CALLBACK(autoplug_continue_cb), parser);
-- 
2.49.0

From 4df93391b0ee6e6630bd5e402cd75d02df4606ca Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 16 May 2023 12:41:04 +0200
Subject: [PATCH 0213/1564] winegstreamer/wg_parser: Request live latency with
 WINE_ENABLE_GST_LIVE_LATENCY=1.

Effectively greatly reducing the memory overhead from avdec_h264, which
otherwise starts one decoding thread per frame.

CW-Bug-Id: #22045
---
 dlls/winegstreamer/wg_parser.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index b4c8dba0c13..93e3da291c0 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -1367,6 +1367,13 @@ static gboolean src_query_cb(GstPad *pad, GstObject *parent, GstQuery *query)
             }
             return FALSE;
 
+        case GST_QUERY_LATENCY:
+        {
+            const char *live = getenv("WINE_ENABLE_GST_LIVE_LATENCY");
+            gst_query_set_latency(query, live && !strcmp(live, "1"), 0, 0);
+            return TRUE;
+        }
+
         default:
             GST_WARNING("Unhandled query type %s.", GST_QUERY_TYPE_NAME(query));
             return FALSE;
-- 
2.49.0

From 04a5ef18c39405aef030d7d335f1b3680079f4df Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 2 Aug 2022 10:50:35 +0200
Subject: [PATCH 0215/1564] HACK: winegstreamer/wma_decoder: Allow WMA decoder
 DMO to pass-through buffers.

CW-Bug-Id: #18799
CW-Bug-Id: #18994
CW-Bug-Id: #20182
CW-Bug-Id: #20905

CW-Bug-Id: #20833
---
 dlls/winegstreamer/wma_decoder.c | 24 ------------------------
 1 file changed, 24 deletions(-)

diff --git a/dlls/winegstreamer/wma_decoder.c b/dlls/winegstreamer/wma_decoder.c
index 6c1e5ed2ea8..352d2c6a8e7 100644
--- a/dlls/winegstreamer/wma_decoder.c
+++ b/dlls/winegstreamer/wma_decoder.c
@@ -30,7 +30,6 @@
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(wmadec);
-WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
 extern const GUID MFAudioFormat_XMAudio2;
 
@@ -712,7 +711,6 @@ static HRESULT WINAPI media_object_SetInputType(IMediaObject *iface, DWORD index
         const DMO_MEDIA_TYPE *type, DWORD flags)
 {
     struct wma_decoder *decoder = impl_from_IMediaObject(iface);
-    unsigned int i;
 
     TRACE("iface %p, index %lu, type %p, flags %#lx.\n", iface, index, type, flags);
 
@@ -740,12 +738,6 @@ static HRESULT WINAPI media_object_SetInputType(IMediaObject *iface, DWORD index
     if (!IsEqualGUID(&type->majortype, &MEDIATYPE_Audio))
         return DMO_E_TYPE_NOT_ACCEPTED;
 
-    for (i = 0; i < ARRAY_SIZE(wma_decoder_input_types); ++i)
-        if (IsEqualGUID(&type->subtype, wma_decoder_input_types[i]))
-            break;
-    if (i == ARRAY_SIZE(wma_decoder_input_types))
-        return DMO_E_TYPE_NOT_ACCEPTED;
-
     if (flags & DMO_SET_TYPEF_TEST_ONLY)
         return S_OK;
 
@@ -1057,27 +1049,11 @@ static const IPropertyBagVtbl property_bag_vtbl =
 
 HRESULT wma_decoder_create(IUnknown *outer, IUnknown **out)
 {
-    static const WAVEFORMATEX output_format =
-    {
-        .wFormatTag = WAVE_FORMAT_IEEE_FLOAT, .wBitsPerSample = 32, .nSamplesPerSec = 44100, .nChannels = 1,
-    };
-    static const WMAUDIO2WAVEFORMAT input_format =
-    {
-        .wfx = {.wFormatTag = WAVE_FORMAT_WMAUDIO2, .wBitsPerSample = 16, .nSamplesPerSec = 44100, .nChannels = 1,
-                .nAvgBytesPerSec = 3000, .nBlockAlign = 139, .cbSize = sizeof(input_format) - sizeof(WAVEFORMATEX)},
-        .wEncodeOptions = 1,
-    };
     struct wma_decoder *decoder;
     HRESULT hr;
 
     TRACE("outer %p, out %p.\n", outer, out);
 
-    if (FAILED(hr = check_audio_transform_support(&input_format.wfx, &output_format)))
-    {
-        ERR_(winediag)("GStreamer doesn't support WMA decoding, please install appropriate plugins.\n");
-        return hr;
-    }
-
     if (!(decoder = calloc(1, sizeof(*decoder))))
         return E_OUTOFMEMORY;
 
-- 
2.49.0

From e50e41c57aa16533080c59cea77d41c9ca3bdbfb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 21 Nov 2023 14:11:01 +0100
Subject: [PATCH 0216/1564] HACK: winegstreamer/wmv_decoder: Implement
 WMVDecMediaObject pass-through DMO.

CW-Bug-Id: #18799
CW-Bug-Id: #18994
CW-Bug-Id: #20182

CW-Bug-Id: #20833
---
 dlls/winegstreamer/video_decoder.c | 25 -------------------------
 1 file changed, 25 deletions(-)

diff --git a/dlls/winegstreamer/video_decoder.c b/dlls/winegstreamer/video_decoder.c
index 83fb713d5da..f8d5bee25e2 100644
--- a/dlls/winegstreamer/video_decoder.c
+++ b/dlls/winegstreamer/video_decoder.c
@@ -1137,7 +1137,6 @@ static HRESULT WINAPI media_object_SetInputType(IMediaObject *iface, DWORD index
 {
     struct video_decoder *decoder = impl_from_IMediaObject(iface);
     IMFMediaType *media_type;
-    unsigned int i;
 
     TRACE("iface %p, index %lu, type %p, flags %#lx.\n", iface, index, type, flags);
 
@@ -1163,12 +1162,6 @@ static HRESULT WINAPI media_object_SetInputType(IMediaObject *iface, DWORD index
     if (!IsEqualGUID(&type->majortype, &MEDIATYPE_Video))
         return DMO_E_TYPE_NOT_ACCEPTED;
 
-    for (i = 0; i < decoder->input_type_count; ++i)
-        if (IsEqualGUID(&type->subtype, get_dmo_subtype(decoder->input_types[i])))
-            break;
-    if (i == decoder->input_type_count)
-        return DMO_E_TYPE_NOT_ACCEPTED;
-
     if (FAILED(MFCreateMediaTypeFromRepresentation(AM_MEDIA_TYPE_REPRESENTATION,
             (void *)type, &media_type)))
         return DMO_E_TYPE_NOT_ACCEPTED;
@@ -1722,29 +1715,11 @@ static const GUID *const wmv_decoder_output_types[] =
 
 HRESULT wmv_decoder_create(IUnknown *outer, IUnknown **out)
 {
-    const MFVIDEOFORMAT output_format =
-    {
-        .dwSize = sizeof(MFVIDEOFORMAT),
-        .videoInfo = {.dwWidth = 1920, .dwHeight = 1080},
-        .guidFormat = MFVideoFormat_I420,
-    };
-    const MFVIDEOFORMAT input_format =
-    {
-        .dwSize = sizeof(MFVIDEOFORMAT),
-        .videoInfo = {.dwWidth = 1920, .dwHeight = 1080},
-        .guidFormat = MFVideoFormat_WMV3,
-    };
     struct video_decoder *decoder;
     HRESULT hr;
 
     TRACE("outer %p, out %p.\n", outer, out);
 
-    if (FAILED(hr = check_video_transform_support(&input_format, &output_format)))
-    {
-        ERR_(winediag)("GStreamer doesn't support WMV decoding, please install appropriate plugins\n");
-        return hr;
-    }
-
     if (FAILED(hr = video_decoder_create_with_types(wmv_decoder_input_types, ARRAY_SIZE(wmv_decoder_input_types),
             wmv_decoder_output_types, ARRAY_SIZE(wmv_decoder_output_types), outer, &decoder)))
         return hr;
-- 
2.49.0

From 0ead1ac80f89678fc0a9751ff9f4f51a2d18e4e9 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Fri, 4 Feb 2022 16:44:54 -0600
Subject: [PATCH 0217/1564] HACK: winegstreamer/wm_reader: Report BGRx for
 Persona 4 Golden.

---
 dlls/winegstreamer/wm_reader.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/dlls/winegstreamer/wm_reader.c b/dlls/winegstreamer/wm_reader.c
index ce79aa04cd7..dac5c0064c4 100644
--- a/dlls/winegstreamer/wm_reader.c
+++ b/dlls/winegstreamer/wm_reader.c
@@ -1531,6 +1531,18 @@ static HRESULT init_stream(struct wm_reader *reader)
             /* API consumers expect RGB video to be bottom-up. */
             if (stream->format.u.video.height > 0)
                 stream->format.u.video.height = -stream->format.u.video.height;
+
+            {
+                /* HACK: Persona 4 Golden tries to read compressed samples, and
+                 * then autoplug them via quartz to a filter that only accepts
+                 * BGRx. This is not trivial to implement. Return BGRx from the
+                 * wmvcore reader for now. */
+
+                const char *id = getenv("SteamGameId");
+
+                if (id && !strcmp(id, "1113000"))
+                    stream->format.u.video.format = WG_VIDEO_FORMAT_BGRx;
+            }
         }
         wg_parser_stream_enable(stream->wg_stream, &stream->format);
     }
-- 
2.49.0

From e00f170e80aa1d6779890d45f880d448ff528449 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 16 Jun 2022 16:50:42 +0200
Subject: [PATCH 0218/1564] HACK: winegstreamer/wm_reader: Expose BGRA video
 format from wm_reader.

For Deadly Premonition.

CW-Bug-Id: #18799
---
 dlls/winegstreamer/wm_reader.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/winegstreamer/wm_reader.c b/dlls/winegstreamer/wm_reader.c
index dac5c0064c4..e1495289fb0 100644
--- a/dlls/winegstreamer/wm_reader.c
+++ b/dlls/winegstreamer/wm_reader.c
@@ -1664,6 +1664,7 @@ static const enum wg_video_format video_formats[] =
     WG_VIDEO_FORMAT_YUY2,
     WG_VIDEO_FORMAT_UYVY,
     WG_VIDEO_FORMAT_YVYU,
+    WG_VIDEO_FORMAT_BGRA,
     WG_VIDEO_FORMAT_BGRx,
     WG_VIDEO_FORMAT_BGR,
     WG_VIDEO_FORMAT_RGB16,
-- 
2.49.0

From 6d2c347225b00d6bfd5bac36ec6c472fbd95e613 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 2 Aug 2022 11:26:20 +0200
Subject: [PATCH 0221/1564] winegstreamer/wg_transform: Allow more input buffer
 to be queued for uncompressed formats.

CW-Bug-Id: #18799
CW-Bug-Id: #18994
CW-Bug-Id: #20182
CW-Bug-Id: #20905
---
 dlls/winegstreamer/wg_transform.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
index 61fdae40d11..d1d35197f81 100644
--- a/dlls/winegstreamer/wg_transform.c
+++ b/dlls/winegstreamer/wg_transform.c
@@ -478,7 +478,10 @@ static bool transform_create_decoder_elements(struct wg_transform *transform,
     bool ret = false;
 
     if (!strcmp(input_mime, "audio/x-raw") || !strcmp(input_mime, "video/x-raw"))
+    {
+        transform->attrs.input_queue_length = 16;
         return true;
+    }
 
     if (!(parsed_caps = transform_get_parsed_caps(transform->input_caps, input_mime)))
         return false;
-- 
2.49.0

From a516d6f4235f01ceb0f35c3fabca6b5a60874f57 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Sun, 17 Nov 2024 20:50:13 +0100
Subject: [PATCH 0222/1564] HACK: winegstreamer/h264_decoder: Do not report
 live latency for some games.

CW-Bug-Id: #22581
---
 dlls/winegstreamer/video_decoder.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/dlls/winegstreamer/video_decoder.c b/dlls/winegstreamer/video_decoder.c
index f8d5bee25e2..3efd36c85c0 100644
--- a/dlls/winegstreamer/video_decoder.c
+++ b/dlls/winegstreamer/video_decoder.c
@@ -272,6 +272,12 @@ static HRESULT try_create_wg_transform(struct video_decoder *decoder, IMFMediaTy
     if (SUCCEEDED(IMFAttributes_GetUINT32(decoder->attributes, &MF_LOW_LATENCY, &low_latency)))
         decoder->wg_transform_attrs.low_latency = !!low_latency;
 
+    {
+        const char *sgi;
+        if ((sgi = getenv("SteamGameId")) && (!strcmp(sgi, "2009100") || !strcmp(sgi, "2555360") || !strcmp(sgi, "1630110")))
+            decoder->wg_transform_attrs.low_latency = FALSE;
+    }
+
     return wg_transform_create_mf(decoder->input_type, output_type, &decoder->wg_transform_attrs, &decoder->wg_transform);
 }
 
-- 
2.49.0

From 6b2ac9c45723b04638881bfa06f140983900c32e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Sun, 17 Nov 2024 20:53:02 +0100
Subject: [PATCH 0223/1564] HACK: winegstreamer/h264_decoder: Disable
 MF_SA_D3D11_AWARE for some games.

CW-Bug-Id: #22581
---
 dlls/winegstreamer/video_decoder.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/dlls/winegstreamer/video_decoder.c b/dlls/winegstreamer/video_decoder.c
index 3efd36c85c0..efedff5e983 100644
--- a/dlls/winegstreamer/video_decoder.c
+++ b/dlls/winegstreamer/video_decoder.c
@@ -1563,6 +1563,12 @@ static HRESULT video_decoder_create_with_types(const GUID *const *input_types, U
                     &MFT_DECODER_EXPOSE_OUTPUT_TYPES_IN_NATIVE_ORDER, FALSE)))
         goto failed;
 
+    {
+        const char *sgi;
+        if ((sgi = getenv("SteamGameId")) && ((!strcmp(sgi, "2009100")) || (!strcmp(sgi, "2555360"))))
+            IMFAttributes_SetUINT32(decoder->attributes, &MF_SA_D3D11_AWARE, FALSE);
+    }
+
     if (FAILED(hr = MFCreateAttributes(&decoder->output_attributes, 0)))
         goto failed;
     if (FAILED(hr = wg_sample_queue_create(&decoder->wg_sample_queue)))
-- 
2.49.0

From ad48bd69657c355b5b2f02fd48de79b3b5864075 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 8 Dec 2023 15:42:32 +0100
Subject: [PATCH 0224/1564] mf/evr: Increase the number of prerolled samples to
 3.

Native seems to only preroll 2 samples, but it still stutters a bit in
Secret of Mana without at least 3 buffers. This is probably caused by
a different sample decoding pattern, and 3 buffers in flight should be
fine.

CW-Bug-Id: #21713
---
 dlls/mf/evr.c     | 15 ++++++++++++---
 dlls/mf/session.c |  2 +-
 2 files changed, 13 insertions(+), 4 deletions(-)

diff --git a/dlls/mf/evr.c b/dlls/mf/evr.c
index eb366ea599a..f09cf43f8bf 100644
--- a/dlls/mf/evr.c
+++ b/dlls/mf/evr.c
@@ -64,6 +64,7 @@ struct video_stream
     LONG refcount;
     unsigned int id;
     unsigned int flags;
+    unsigned int preroll_count;
     struct video_renderer *parent;
     IMFMediaEventQueue *event_queue;
     IMFVideoSampleAllocator *allocator;
@@ -426,9 +427,16 @@ static HRESULT WINAPI video_stream_sink_ProcessSample(IMFStreamSink *iface, IMFS
 
         if (stream->flags & EVR_STREAM_PREROLLING)
         {
-            IMFMediaEventQueue_QueueEventParamVar(stream->event_queue, MEStreamSinkPrerolled, &GUID_NULL, S_OK, NULL);
-            stream->flags &= ~EVR_STREAM_PREROLLING;
-            stream->flags |= EVR_STREAM_PREROLLED;
+            if (stream->preroll_count--)
+                IMFMediaEventQueue_QueueEventParamVar(stream->event_queue, MEStreamSinkRequestSample,
+                        &GUID_NULL, S_OK, NULL);
+            else
+            {
+                IMFMediaEventQueue_QueueEventParamVar(stream->event_queue, MEStreamSinkPrerolled,
+                        &GUID_NULL, S_OK, NULL);
+                stream->flags &= ~EVR_STREAM_PREROLLING;
+                stream->flags |= EVR_STREAM_PREROLLED;
+            }
         }
     }
 
@@ -1534,6 +1542,7 @@ static HRESULT WINAPI video_renderer_preroll_NotifyPreroll(IMFMediaSinkPreroll *
                 IMFMediaEventQueue_QueueEventParamVar(stream->event_queue, MEStreamSinkRequestSample,
                         &GUID_NULL, S_OK, NULL);
                 stream->flags |= EVR_STREAM_PREROLLING;
+                stream->preroll_count = 3;
             }
             LeaveCriticalSection(&stream->cs);
         }
diff --git a/dlls/mf/session.c b/dlls/mf/session.c
index 483ea6f904f..b4297581800 100644
--- a/dlls/mf/session.c
+++ b/dlls/mf/session.c
@@ -1879,7 +1879,7 @@ static HRESULT session_append_node(struct media_session *session, IMFTopologyNod
                         &IID_IMFVideoSampleAllocator, (void **)&topo_node->u.sink.allocator)))
                     {
                         if (FAILED(hr = IMFVideoSampleAllocator_InitializeSampleAllocator(topo_node->u.sink.allocator,
-                                2, media_type)))
+                                4, media_type)))
                         {
                             WARN("Failed to initialize sample allocator for the stream, hr %#lx.\n", hr);
                         }
-- 
2.49.0

From bb3068a898d49f1752b12fac24e1327ca70b572b Mon Sep 17 00:00:00 2001
From: Giovanni Mascellani <gmascellani@codeweavers.com>
Date: Thu, 27 May 2021 19:40:45 +0200
Subject: [PATCH 0227/1564] HACK: mfreadwrite: Ignore source reader flushes for
 The Medium.

---
 dlls/mfreadwrite/reader.c | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/dlls/mfreadwrite/reader.c b/dlls/mfreadwrite/reader.c
index 4d223f1de6e..19e1bf6b1f9 100644
--- a/dlls/mfreadwrite/reader.c
+++ b/dlls/mfreadwrite/reader.c
@@ -2492,8 +2492,19 @@ static HRESULT WINAPI src_reader_Flush(IMFSourceReaderEx *iface, DWORD index)
     struct source_reader *reader = impl_from_IMFSourceReaderEx(iface);
     HRESULT hr;
 
+    const char *sgi;
+
     TRACE("%p, %#lx.\n", iface, index);
 
+    sgi = getenv("SteamGameId");
+    if (sgi && strcmp(sgi, "1293160") == 0)
+    {
+        /* In The Medium flushes sometimes lead to the callback
+           calling objects that have already been destroyed. */
+        WARN("ignoring flush\n");
+        return S_OK;
+    }
+
     EnterCriticalSection(&reader->cs);
 
     if (reader->async_callback)
-- 
2.49.0

From 164af86dd770f975cdff3e09884f14ebc14b856b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 4 Mar 2024 09:54:09 +0100
Subject: [PATCH 0228/1564] mfreadwrite/reader: Rely on the video processor
 sample allocator.

CW-Bug-Id: #20833
---
 dlls/mfreadwrite/reader.c | 143 --------------------------------------
 1 file changed, 143 deletions(-)

diff --git a/dlls/mfreadwrite/reader.c b/dlls/mfreadwrite/reader.c
index 19e1bf6b1f9..fcb8d8dec94 100644
--- a/dlls/mfreadwrite/reader.c
+++ b/dlls/mfreadwrite/reader.c
@@ -89,7 +89,6 @@ struct media_stream
     IMFMediaStream *stream;
     IMFMediaType *current;
     struct list transforms;
-    IMFVideoSampleAllocatorEx *allocator;
     IMFTransform *transform_service;
     DWORD id;
     unsigned int index;
@@ -232,8 +231,6 @@ static void media_stream_destroy(struct media_stream *stream)
         IMFMediaStream_Release(stream->stream);
     if (stream->current)
         IMFMediaType_Release(stream->current);
-    if (stream->allocator)
-        IMFVideoSampleAllocatorEx_Release(stream->allocator);
 }
 
 static ULONG source_reader_release(struct source_reader *reader)
@@ -429,39 +426,6 @@ static void source_reader_response_ready(struct source_reader *reader, struct st
     stream->requests--;
 }
 
-static void source_reader_copy_sample_buffer(IMFSample *src, IMFSample *dst)
-{
-    IMFMediaBuffer *buffer;
-    LONGLONG time;
-    DWORD flags;
-    HRESULT hr;
-
-    IMFSample_CopyAllItems(src, (IMFAttributes *)dst);
-
-    IMFSample_SetSampleDuration(dst, 0);
-    IMFSample_SetSampleTime(dst, 0);
-    IMFSample_SetSampleFlags(dst, 0);
-
-    if (SUCCEEDED(IMFSample_GetSampleDuration(src, &time)))
-        IMFSample_SetSampleDuration(dst, time);
-
-    if (SUCCEEDED(IMFSample_GetSampleTime(src, &time)))
-        IMFSample_SetSampleTime(dst, time);
-
-    if (SUCCEEDED(IMFSample_GetSampleFlags(src, &flags)))
-        IMFSample_SetSampleFlags(dst, flags);
-
-    if (SUCCEEDED(IMFSample_ConvertToContiguousBuffer(src, NULL)))
-    {
-        if (SUCCEEDED(IMFSample_GetBufferByIndex(dst, 0, &buffer)))
-        {
-            if (FAILED(hr = IMFSample_CopyToBuffer(src, buffer)))
-                WARN("Failed to copy a buffer, hr %#lx.\n", hr);
-            IMFMediaBuffer_Release(buffer);
-        }
-    }
-}
-
 static HRESULT source_reader_queue_response(struct source_reader *reader, struct media_stream *stream, HRESULT status,
         DWORD stream_flags, LONGLONG timestamp, IMFSample *sample)
 {
@@ -1219,8 +1183,6 @@ static struct stream_response * media_stream_detach_response(struct source_reade
 static struct stream_response *media_stream_pop_response(struct source_reader *reader, struct media_stream *stream)
 {
     struct stream_response *response;
-    IMFSample *sample;
-    HRESULT hr;
 
     LIST_FOR_EACH_ENTRY(response, &reader->responses, struct stream_response, entry)
     {
@@ -1229,26 +1191,6 @@ static struct stream_response *media_stream_pop_response(struct source_reader *r
 
         if (!stream) stream = &reader->streams[response->stream_index];
 
-        if (response->sample && stream->allocator)
-        {
-            /* Return allocation error to the caller, while keeping original response sample in for later. */
-            if (SUCCEEDED(hr = IMFVideoSampleAllocatorEx_AllocateSample(stream->allocator, &sample)))
-            {
-                source_reader_copy_sample_buffer(response->sample, sample);
-                IMFSample_Release(response->sample);
-                response->sample = sample;
-            }
-            else
-            {
-                if (!(response = calloc(1, sizeof(*response))))
-                    return NULL;
-
-                response->status = hr;
-                response->stream_flags = MF_SOURCE_READERF_ERROR;
-                return response;
-            }
-        }
-
         return media_stream_detach_response(reader, response);
     }
 
@@ -1661,7 +1603,6 @@ static ULONG WINAPI src_reader_Release(IMFSourceReaderEx *iface)
 {
     struct source_reader *reader = impl_from_IMFSourceReaderEx(iface);
     ULONG refcount = InterlockedDecrement(&reader->public_refcount);
-    unsigned int i;
 
     TRACE("%p, refcount %lu.\n", iface, refcount);
 
@@ -1681,23 +1622,6 @@ static ULONG WINAPI src_reader_Release(IMFSourceReaderEx *iface)
             LeaveCriticalSection(&reader->cs);
         }
 
-        for (i = 0; i < reader->stream_count; ++i)
-        {
-            struct media_stream *stream = &reader->streams[i];
-            IMFVideoSampleAllocatorCallback *callback;
-
-            if (!stream->allocator)
-                continue;
-
-            if (SUCCEEDED(IMFVideoSampleAllocatorEx_QueryInterface(stream->allocator, &IID_IMFVideoSampleAllocatorCallback,
-                    (void **)&callback)))
-            {
-                IMFVideoSampleAllocatorCallback_SetCallback(callback, NULL);
-                IMFVideoSampleAllocatorCallback_Release(callback);
-            }
-        }
-
-        MFUnlockWorkQueue(reader->queue);
         source_reader_release(reader);
     }
 
@@ -1948,71 +1872,6 @@ static HRESULT source_reader_set_compatible_media_type(struct source_reader *rea
     return type_set ? S_OK : S_FALSE;
 }
 
-static HRESULT source_reader_create_sample_allocator_attributes(const struct source_reader *reader,
-        IMFAttributes **attributes)
-{
-    UINT32 shared = 0, shared_without_mutex = 0;
-    HRESULT hr;
-
-    if (FAILED(hr = MFCreateAttributes(attributes, 1)))
-        return hr;
-
-    IMFAttributes_GetUINT32(reader->attributes, &MF_SA_D3D11_SHARED, &shared);
-    IMFAttributes_GetUINT32(reader->attributes, &MF_SA_D3D11_SHARED_WITHOUT_MUTEX, &shared_without_mutex);
-
-    if (shared_without_mutex)
-        hr = IMFAttributes_SetUINT32(*attributes, &MF_SA_D3D11_SHARED_WITHOUT_MUTEX, TRUE);
-    else if (shared)
-        hr = IMFAttributes_SetUINT32(*attributes, &MF_SA_D3D11_SHARED, TRUE);
-
-    return hr;
-}
-
-static HRESULT source_reader_setup_sample_allocator(struct source_reader *reader, unsigned int index)
-{
-    struct media_stream *stream = &reader->streams[index];
-    IMFAttributes *attributes = NULL;
-    GUID major = { 0 };
-    HRESULT hr;
-
-    IMFMediaType_GetMajorType(stream->current, &major);
-    if (!IsEqualGUID(&major, &MFMediaType_Video))
-        return S_OK;
-
-    if (!(reader->flags & SOURCE_READER_HAS_DEVICE_MANAGER))
-        return S_OK;
-
-    if (!stream->allocator)
-    {
-        if (FAILED(hr = MFCreateVideoSampleAllocatorEx(&IID_IMFVideoSampleAllocatorEx, (void **)&stream->allocator)))
-        {
-            WARN("Failed to create sample allocator, hr %#lx.\n", hr);
-            return hr;
-        }
-    }
-
-    IMFVideoSampleAllocatorEx_UninitializeSampleAllocator(stream->allocator);
-    if (FAILED(hr = IMFVideoSampleAllocatorEx_SetDirectXManager(stream->allocator, reader->device_manager)))
-    {
-        WARN("Failed to set device manager, hr %#lx.\n", hr);
-        return hr;
-    }
-
-    if (FAILED(hr = source_reader_create_sample_allocator_attributes(reader, &attributes)))
-        WARN("Failed to create allocator attributes, hr %#lx.\n", hr);
-
-    if (FAILED(hr = IMFVideoSampleAllocatorEx_InitializeSampleAllocatorEx(stream->allocator, 2, 8,
-            attributes, stream->current)))
-    {
-        WARN("Failed to initialize sample allocator, hr %#lx.\n", hr);
-    }
-
-    if (attributes)
-        IMFAttributes_Release(attributes);
-
-    return hr;
-}
-
 static BOOL source_reader_allow_video_processor(struct source_reader *reader, BOOL *advanced)
 {
     UINT32 value;
@@ -2265,8 +2124,6 @@ static HRESULT WINAPI src_reader_SetCurrentMediaType(IMFSourceReaderEx *iface, D
     hr = source_reader_set_compatible_media_type(reader, index, type);
     if (hr == S_FALSE)
         hr = source_reader_create_decoder_for_stream(reader, index, type);
-    if (SUCCEEDED(hr))
-        hr = source_reader_setup_sample_allocator(reader, index);
 
     LeaveCriticalSection(&reader->cs);
 
-- 
2.49.0

From 0216ca22cdf2f391f366b038b6a4923921ac2899 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 4 Mar 2024 09:54:09 +0100
Subject: [PATCH 0229/1564] mfreadwrite/reader: Use
 MFCreateMediaBufferFromMediaType to allocate samples.

CW-Bug-Id: #20833
---
 dlls/mfreadwrite/reader.c       | 23 ++++++++++++++---------
 dlls/mfreadwrite/tests/mfplat.c |  6 +++---
 2 files changed, 17 insertions(+), 12 deletions(-)

diff --git a/dlls/mfreadwrite/reader.c b/dlls/mfreadwrite/reader.c
index fcb8d8dec94..465071c9dc0 100644
--- a/dlls/mfreadwrite/reader.c
+++ b/dlls/mfreadwrite/reader.c
@@ -644,26 +644,31 @@ static ULONG WINAPI source_reader_stream_events_callback_Release(IMFAsyncCallbac
     return source_reader_release(reader);
 }
 
-static HRESULT source_reader_allocate_stream_sample(MFT_OUTPUT_STREAM_INFO *info, IMFSample **out)
+static HRESULT source_reader_allocate_stream_sample(IMFTransform *transform, MFT_OUTPUT_STREAM_INFO *info, IMFSample **out)
 {
+    IMFMediaType *media_type;
     IMFMediaBuffer *buffer;
     IMFSample *sample;
     HRESULT hr;
 
     *out = NULL;
-    if (FAILED(hr = MFCreateSample(&sample)))
+    if (SUCCEEDED(hr = IMFTransform_GetOutputCurrentType(transform, 0, &media_type)))
+    {
+        hr = MFCreateMediaBufferFromMediaType(media_type, 10000000, info->cbSize, info->cbAlignment, &buffer);
+        IMFMediaType_Release(media_type);
+    }
+    if (FAILED(hr) && FAILED(hr = MFCreateAlignedMemoryBuffer(info->cbSize, info->cbAlignment, &buffer)))
         return hr;
-    if (SUCCEEDED(hr = MFCreateAlignedMemoryBuffer(info->cbSize, info->cbAlignment, &buffer)))
+
+    if (SUCCEEDED(hr = MFCreateSample(&sample)))
     {
         if (SUCCEEDED(hr = IMFSample_AddBuffer(sample, buffer)))
-        {
             *out = sample;
-            IMFSample_AddRef(sample);
-        }
-        IMFMediaBuffer_Release(buffer);
+        else
+            IMFSample_Release(sample);
     }
 
-    IMFSample_Release(sample);
+    IMFMediaBuffer_Release(buffer);
     return hr;
 }
 
@@ -849,7 +854,7 @@ static HRESULT source_reader_pull_transform_samples(struct source_reader *reader
         IMFMediaType *media_type;
 
         if (!(stream_info.dwFlags & (MFT_OUTPUT_STREAM_PROVIDES_SAMPLES | MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES))
-                && FAILED(hr = source_reader_allocate_stream_sample(&stream_info, &out_buffer.pSample)))
+                && FAILED(hr = source_reader_allocate_stream_sample(entry->transform, &stream_info, &out_buffer.pSample)))
             break;
 
         if (SUCCEEDED(hr = IMFTransform_ProcessOutput(entry->transform, 0, 1, &out_buffer, &status)))
diff --git a/dlls/mfreadwrite/tests/mfplat.c b/dlls/mfreadwrite/tests/mfplat.c
index b6981479a1b..e90931253fc 100644
--- a/dlls/mfreadwrite/tests/mfplat.c
+++ b/dlls/mfreadwrite/tests/mfplat.c
@@ -2644,11 +2644,11 @@ static HRESULT WINAPI test_decoder_ProcessOutput(IMFTransform *iface, DWORD flag
 
         hr = IMFSample_GetBufferByIndex(data->pSample, 0, &buffer);
         ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-        todo_wine check_interface(buffer, &IID_IMF2DBuffer2, TRUE);
-        todo_wine check_interface(buffer, &IID_IMFGetService, TRUE);
+        check_interface(buffer, &IID_IMF2DBuffer2, TRUE);
+        check_interface(buffer, &IID_IMFGetService, TRUE);
         check_interface(buffer, &IID_IMFDXGIBuffer, FALSE);
         hr = MFGetService((IUnknown *)buffer, &MR_BUFFER_SERVICE, &IID_IDirect3DSurface9, (void **)&unknown);
-        todo_wine ok(hr == E_NOTIMPL, "Unexpected hr %#lx.\n", hr);
+        ok(hr == E_NOTIMPL, "Unexpected hr %#lx.\n", hr);
         IMFMediaBuffer_Release(buffer);
     }
 
-- 
2.49.0

From 622812dc89ad361e8ea012158de2ec5a778e18b8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 21 May 2024 13:37:08 +0200
Subject: [PATCH 0230/1564] mfreadwrite/reader: Make a copy of the output type
 in SetCurrentMediaType.

CW-Bug-Id: #20833
---
 dlls/mfreadwrite/reader.c | 14 ++++++++++++--
 1 file changed, 12 insertions(+), 2 deletions(-)

diff --git a/dlls/mfreadwrite/reader.c b/dlls/mfreadwrite/reader.c
index 465071c9dc0..36b9fdbe5be 100644
--- a/dlls/mfreadwrite/reader.c
+++ b/dlls/mfreadwrite/reader.c
@@ -2103,6 +2103,7 @@ static HRESULT WINAPI src_reader_SetCurrentMediaType(IMFSourceReaderEx *iface, D
         IMFMediaType *type)
 {
     struct source_reader *reader = impl_from_IMFSourceReaderEx(iface);
+    IMFMediaType *output_type;
     HRESULT hr;
 
     TRACE("%p, %#lx, %p, %p.\n", iface, index, reserved, type);
@@ -2122,16 +2123,25 @@ static HRESULT WINAPI src_reader_SetCurrentMediaType(IMFSourceReaderEx *iface, D
     if (index >= reader->stream_count)
         return MF_E_INVALIDSTREAMNUMBER;
 
+    if (FAILED(hr = MFCreateMediaType(&output_type)))
+        return hr;
+    if (FAILED(IMFMediaType_CopyAllItems(type, (IMFAttributes *)output_type)))
+    {
+        IMFMediaType_Release(output_type);
+        return hr;
+    }
+
     /* FIXME: setting the output type while streaming should trigger a flush */
 
     EnterCriticalSection(&reader->cs);
 
-    hr = source_reader_set_compatible_media_type(reader, index, type);
+    hr = source_reader_set_compatible_media_type(reader, index, output_type);
     if (hr == S_FALSE)
-        hr = source_reader_create_decoder_for_stream(reader, index, type);
+        hr = source_reader_create_decoder_for_stream(reader, index, output_type);
 
     LeaveCriticalSection(&reader->cs);
 
+    IMFMediaType_Release(output_type);
     return hr;
 }
 
-- 
2.49.0

From ed055fabe5dc252615631f0c3d82e302df03032b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 21 May 2024 13:37:08 +0200
Subject: [PATCH 0231/1564] mfreadwrite/reader: Set MF_MT_AUDIO_BITS_PER_SAMPLE
 attribute when missing.

CW-Bug-Id: #20833
---
 dlls/mfreadwrite/reader.c | 15 ++++++++++++---
 1 file changed, 12 insertions(+), 3 deletions(-)

diff --git a/dlls/mfreadwrite/reader.c b/dlls/mfreadwrite/reader.c
index 36b9fdbe5be..79425be0bbb 100644
--- a/dlls/mfreadwrite/reader.c
+++ b/dlls/mfreadwrite/reader.c
@@ -1923,12 +1923,21 @@ static HRESULT source_reader_create_transform(struct source_reader *reader, BOOL
     list_init(&entry->entry);
     entry->category = category;
 
-    if (IsEqualGUID(&out_type.guidMajorType, &MFMediaType_Audio)
-            && SUCCEEDED(IMFMediaType_GetUINT32(output_type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &entry->min_buffer_size)))
+    if (IsEqualGUID(&out_type.guidMajorType, &MFMediaType_Audio))
     {
         UINT32 bytes_per_second;
 
-        if (SUCCEEDED(IMFMediaType_GetUINT32(output_type, &MF_MT_AUDIO_AVG_BYTES_PER_SECOND, &bytes_per_second)))
+        /* decoders require to have MF_MT_AUDIO_BITS_PER_SAMPLE attribute set, but the source reader doesn't */
+        if (FAILED(IMFMediaType_GetItem(output_type, &MF_MT_AUDIO_BITS_PER_SAMPLE, NULL)))
+        {
+            if (IsEqualGUID(&out_type.guidSubtype, &MFAudioFormat_PCM))
+                IMFMediaType_SetUINT32(output_type, &MF_MT_AUDIO_BITS_PER_SAMPLE, 16);
+            else if (IsEqualGUID(&out_type.guidSubtype, &MFAudioFormat_Float))
+                IMFMediaType_SetUINT32(output_type, &MF_MT_AUDIO_BITS_PER_SAMPLE, 32);
+        }
+
+        if (SUCCEEDED(IMFMediaType_GetUINT32(output_type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &entry->min_buffer_size))
+                && SUCCEEDED(IMFMediaType_GetUINT32(output_type, &MF_MT_AUDIO_AVG_BYTES_PER_SECOND, &bytes_per_second)))
             entry->min_buffer_size = max(entry->min_buffer_size, bytes_per_second);
     }
 
-- 
2.49.0

From 6b553ef12c9a32d7cf70b27f966d5d65d4a0e5ce Mon Sep 17 00:00:00 2001
From: Brendan McGrath <bmcgrath@codeweavers.com>
Date: Wed, 24 Jul 2024 12:02:34 +1000
Subject: [PATCH 0232/1564] mfmediaengine: Retrieve frame size from frame sink.

This was previously retrieved from the media source, but this may no
longer know the frame size (as parsing/decoding occurs in the MFT).

CW-Bug-Id: #23810
---
 dlls/mfmediaengine/main.c | 73 ++++++++++++---------------------------
 1 file changed, 23 insertions(+), 50 deletions(-)

diff --git a/dlls/mfmediaengine/main.c b/dlls/mfmediaengine/main.c
index 27249f09fa6..8457ba0853d 100644
--- a/dlls/mfmediaengine/main.c
+++ b/dlls/mfmediaengine/main.c
@@ -811,55 +811,41 @@ static unsigned int get_gcd(unsigned int a, unsigned int b)
     return a;
 }
 
-static void media_engine_get_frame_size(struct media_engine *engine, IMFTopology *topology)
+static void media_engine_get_frame_size(struct media_engine *engine)
 {
     IMFMediaTypeHandler *handler;
     IMFMediaType *media_type;
-    IMFStreamDescriptor *sd;
-    IMFTopologyNode *node;
-    unsigned int gcd;
-    UINT64 size;
-    HRESULT hr;
 
     engine->video_frame.size.cx = 0;
     engine->video_frame.size.cy = 0;
     engine->video_frame.ratio.cx = 1;
     engine->video_frame.ratio.cy = 1;
 
-    if (FAILED(IMFTopology_GetNodeByID(topology, engine->video_frame.node_id, &node)))
-        return;
-
-    hr = IMFTopologyNode_GetUnknown(node, &MF_TOPONODE_STREAM_DESCRIPTOR,
-            &IID_IMFStreamDescriptor, (void **)&sd);
-    IMFTopologyNode_Release(node);
-    if (FAILED(hr))
-        return;
-
-    hr = IMFStreamDescriptor_GetMediaTypeHandler(sd, &handler);
-    IMFStreamDescriptor_Release(sd);
-    if (FAILED(hr))
-        return;
-
-    hr = IMFMediaTypeHandler_GetCurrentMediaType(handler, &media_type);
-    IMFMediaTypeHandler_Release(handler);
-    if (FAILED(hr))
+    video_frame_sink_query_iface(engine->presentation.frame_sink, &IID_IMFMediaTypeHandler, (void**)&handler);
+    if (SUCCEEDED(IMFMediaTypeHandler_GetCurrentMediaType(handler, &media_type)))
     {
-        WARN("Failed to get current media type %#lx.\n", hr);
-        return;
-    }
-
-    IMFMediaType_GetUINT64(media_type, &MF_MT_FRAME_SIZE, &size);
+        UINT64 size;
+        HRESULT hr = IMFMediaType_GetUINT64(media_type, &MF_MT_FRAME_SIZE, &size);
+        if (SUCCEEDED(hr))
+        {
+            unsigned int gcd;
+            engine->video_frame.size.cx = size >> 32;
+            engine->video_frame.size.cy = size;
 
-    engine->video_frame.size.cx = size >> 32;
-    engine->video_frame.size.cy = size;
+            if ((gcd = get_gcd(engine->video_frame.size.cx, engine->video_frame.size.cy)))
+            {
+                engine->video_frame.ratio.cx = engine->video_frame.size.cx / gcd;
+                engine->video_frame.ratio.cy = engine->video_frame.size.cy / gcd;
+            }
+        }
+        else
+        {
+            WARN("Failed to get frame size %#lx.\n", hr);
+        }
 
-    if ((gcd = get_gcd(engine->video_frame.size.cx, engine->video_frame.size.cy)))
-    {
-        engine->video_frame.ratio.cx = engine->video_frame.size.cx / gcd;
-        engine->video_frame.ratio.cy = engine->video_frame.size.cy / gcd;
+        IMFMediaType_Release(media_type);
     }
-
-    IMFMediaType_Release(media_type);
+    IMFMediaTypeHandler_Release(handler);
 }
 
 static void media_engine_apply_volume(const struct media_engine *engine)
@@ -941,32 +927,19 @@ static HRESULT WINAPI media_engine_session_events_Invoke(IMFAsyncCallback *iface
         case MESessionTopologyStatus:
         {
             UINT32 topo_status = 0;
-            IMFTopology *topology;
             PROPVARIANT value;
 
             IMFMediaEvent_GetUINT32(event, &MF_EVENT_TOPOLOGY_STATUS, &topo_status);
             if (topo_status != MF_TOPOSTATUS_READY)
                 break;
 
-            value.vt = VT_EMPTY;
-            if (FAILED(IMFMediaEvent_GetValue(event, &value)))
-                break;
-
-            if (value.vt != VT_UNKNOWN)
-            {
-                PropVariantClear(&value);
-                break;
-            }
-
-            topology = (IMFTopology *)value.punkVal;
-
             EnterCriticalSection(&engine->cs);
 
             media_engine_apply_volume(engine);
 
             engine->ready_state = MF_MEDIA_ENGINE_READY_HAVE_METADATA;
 
-            media_engine_get_frame_size(engine, topology);
+            media_engine_get_frame_size(engine);
 
             IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_DURATIONCHANGE, 0, 0);
             IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_LOADEDMETADATA, 0, 0);
-- 
2.49.0

From 541b9e83ccb766d28d29ada3012cd8c7a8b9c6ee Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 23 Nov 2023 00:45:19 +0100
Subject: [PATCH 0233/1564] HACK: mfplat: Stub out MFCreateDXGIDeviceManager,
 to avoid the d3d path.

Squashed with:

HACK: mfplat: Return E_NOTIMPL from MFCreateDXGIDeviceManager for TOHU.

Without this the game renders the videos as garbage.

CW-Bug-Id: #20194

HACK: mfplat: Move MFDXGIDeviceManager hack appid list to proton script

mfplat: Remove comment about games requiring MFCreateDXGIDeviceManager() hack.

It is not outdated and partially incorrect.

CW-Bug-Id: #19126
CW-Bug-Id: #20985
---
 dlls/mfplat/main.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/dlls/mfplat/main.c b/dlls/mfplat/main.c
index 4ed607686f1..8e15abc4de0 100644
--- a/dlls/mfplat/main.c
+++ b/dlls/mfplat/main.c
@@ -9210,9 +9210,16 @@ static const IMFDXGIDeviceManagerVtbl dxgi_device_manager_vtbl =
 HRESULT WINAPI MFCreateDXGIDeviceManager(UINT *token, IMFDXGIDeviceManager **manager)
 {
     struct dxgi_device_manager *object;
+    const char *do_not_create = getenv("WINE_DO_NOT_CREATE_DXGI_DEVICE_MANAGER");
 
     TRACE("%p, %p.\n", token, manager);
 
+    if (do_not_create && do_not_create[0] != '\0')
+    {
+        FIXME("stubbing out\n");
+        return E_NOTIMPL;
+    }
+
     if (!token || !manager)
         return E_POINTER;
 
-- 
2.49.0

From 93c63b6da595380f897560f677860ae61dea9354 Mon Sep 17 00:00:00 2001
From: Giovanni Mascellani <gmascellani@codeweavers.com>
Date: Mon, 6 Jun 2022 13:37:48 +0200
Subject: [PATCH 0234/1564] mfplat/sample: Use Copy2DTo when copying samples,
 if available.

CW-Bug-Id: #19126
---
 dlls/mfplat/sample.c | 31 +++++++++++++++++++++++++++++++
 1 file changed, 31 insertions(+)

diff --git a/dlls/mfplat/sample.c b/dlls/mfplat/sample.c
index 4d75924b939..9ce102ba539 100644
--- a/dlls/mfplat/sample.c
+++ b/dlls/mfplat/sample.c
@@ -791,6 +791,28 @@ static HRESULT WINAPI sample_GetTotalLength(IMFSample *iface, DWORD *total_lengt
     return S_OK;
 }
 
+static HRESULT copy_2d_buffer(IMFMediaBuffer *src, IMFMediaBuffer *dst)
+{
+    IMF2DBuffer2 *src2d = NULL, *dst2d = NULL;
+    HRESULT hr = S_OK;
+
+    hr = IMFMediaBuffer_QueryInterface(src, &IID_IMF2DBuffer2, (void **)&src2d);
+
+    if (SUCCEEDED(hr))
+        hr = IMFMediaBuffer_QueryInterface(dst, &IID_IMF2DBuffer2, (void **)&dst2d);
+
+    if (SUCCEEDED(hr))
+        hr = IMF2DBuffer2_Copy2DTo(src2d, dst2d);
+
+    if (src2d)
+        IMF2DBuffer2_Release(src2d);
+
+    if (dst2d)
+        IMF2DBuffer2_Release(dst2d);
+
+    return hr;
+}
+
 static HRESULT WINAPI sample_CopyToBuffer(IMFSample *iface, IMFMediaBuffer *buffer)
 {
     struct sample *sample = impl_from_IMFSample(iface);
@@ -805,6 +827,15 @@ static HRESULT WINAPI sample_CopyToBuffer(IMFSample *iface, IMFMediaBuffer *buff
 
     EnterCriticalSection(&sample->attributes.cs);
 
+    if (sample->buffer_count == 1)
+    {
+        if (SUCCEEDED(hr = copy_2d_buffer(sample->buffers[0], buffer)))
+        {
+            LeaveCriticalSection(&sample->attributes.cs);
+            return hr;
+        }
+    }
+
     total_length = sample_get_total_length(sample);
     dst_current_length = 0;
 
-- 
2.49.0

From 89824d78e95f6f8929a55a25a0fc1e98c0afad1a Mon Sep 17 00:00:00 2001
From: Giovanni Mascellani <gmascellani@codeweavers.com>
Date: Mon, 6 Jun 2022 14:56:34 +0200
Subject: [PATCH 0235/1564] mfplat/sample: Use contiguous copy.

CW-Bug-Id: #19126
---
 dlls/mfplat/sample.c | 52 ++++++++++++++++++++++++++++++++++++--------
 1 file changed, 43 insertions(+), 9 deletions(-)

diff --git a/dlls/mfplat/sample.c b/dlls/mfplat/sample.c
index 9ce102ba539..4b9151b56b2 100644
--- a/dlls/mfplat/sample.c
+++ b/dlls/mfplat/sample.c
@@ -791,24 +791,58 @@ static HRESULT WINAPI sample_GetTotalLength(IMFSample *iface, DWORD *total_lengt
     return S_OK;
 }
 
+static HRESULT copy_2d_buffer_from_contiguous(IMFMediaBuffer *src, IMF2DBuffer *dst)
+{
+    DWORD current_length;
+    HRESULT hr, hr2;
+    BYTE *ptr;
+
+    hr = IMFMediaBuffer_Lock(src, &ptr, NULL, &current_length);
+
+    if (SUCCEEDED(hr))
+    {
+        hr = IMF2DBuffer_ContiguousCopyFrom(dst, ptr, current_length);
+
+        hr2 = IMFMediaBuffer_Unlock(src);
+        if (FAILED(hr2))
+            WARN("Unlocking source buffer %p failed with hr %#lx.\n", src, hr2);
+        if (FAILED(hr2) && SUCCEEDED(hr))
+            hr = hr2;
+    }
+
+    return hr;
+}
+
 static HRESULT copy_2d_buffer(IMFMediaBuffer *src, IMFMediaBuffer *dst)
 {
-    IMF2DBuffer2 *src2d = NULL, *dst2d = NULL;
-    HRESULT hr = S_OK;
+    IMF2DBuffer2 *src2d2 = NULL, *dst2d2 = NULL;
+    IMF2DBuffer *dst2 = NULL;
+    HRESULT hr;
 
-    hr = IMFMediaBuffer_QueryInterface(src, &IID_IMF2DBuffer2, (void **)&src2d);
+    hr = IMFMediaBuffer_QueryInterface(src, &IID_IMF2DBuffer2, (void **)&src2d2);
+
+    if (SUCCEEDED(hr))
+        hr = IMFMediaBuffer_QueryInterface(dst, &IID_IMF2DBuffer2, (void **)&dst2d2);
 
     if (SUCCEEDED(hr))
-        hr = IMFMediaBuffer_QueryInterface(dst, &IID_IMF2DBuffer2, (void **)&dst2d);
+        hr = IMF2DBuffer2_Copy2DTo(src2d2, dst2d2);
+
+    if (src2d2)
+        IMF2DBuffer2_Release(src2d2);
+
+    if (dst2d2)
+        IMF2DBuffer2_Release(dst2d2);
 
     if (SUCCEEDED(hr))
-        hr = IMF2DBuffer2_Copy2DTo(src2d, dst2d);
+        return hr;
 
-    if (src2d)
-        IMF2DBuffer2_Release(src2d);
+    hr = IMFMediaBuffer_QueryInterface(dst, &IID_IMF2DBuffer, (void **)&dst2);
+
+    if (SUCCEEDED(hr))
+        hr = copy_2d_buffer_from_contiguous(src, dst2);
 
-    if (dst2d)
-        IMF2DBuffer2_Release(dst2d);
+    if (dst2)
+        IMF2DBuffer_Release(dst2);
 
     return hr;
 }
-- 
2.49.0

From a055ab387a962d9909f4f3624bed27ace3c96afc Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 16 Jul 2024 10:51:02 +0200
Subject: [PATCH 0236/1564] mfplat: Flush D3D11 context after
 CopySubresourceRegion on unmap.

Fixes some garbled video frames when the texture is later used as input
by the video processor.

CW-Bug-Id: #20833
---
 dlls/mfplat/buffer.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/mfplat/buffer.c b/dlls/mfplat/buffer.c
index 65fab78d427..f3eb7f9222e 100644
--- a/dlls/mfplat/buffer.c
+++ b/dlls/mfplat/buffer.c
@@ -1004,6 +1004,7 @@ static void dxgi_surface_buffer_unmap(struct buffer *buffer, MF2DBuffer_LockFlag
     {
         ID3D11DeviceContext_CopySubresourceRegion(immediate_context, (ID3D11Resource *)buffer->dxgi_surface.texture,
                 buffer->dxgi_surface.sub_resource_idx, 0, 0, 0, (ID3D11Resource *)buffer->dxgi_surface.rb_texture, 0, NULL);
+        ID3D11DeviceContext_Flush(immediate_context);
     }
 
     ID3D11DeviceContext_Release(immediate_context);
-- 
2.49.0

From 454b8a6088fc8db7bcf64cd126c3e541a79fb113 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 31 Oct 2022 10:34:38 +0100
Subject: [PATCH 0238/1564] HACK: mf: Return E_NOTIMPL from media session
 SetRate if rate is 0 (scrubbing).

CW-Bug-Id: #21498
---
 dlls/mf/session.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/dlls/mf/session.c b/dlls/mf/session.c
index c9d003cf3e8..a5c60334321 100644
--- a/dlls/mf/session.c
+++ b/dlls/mf/session.c
@@ -4731,6 +4731,13 @@ static HRESULT WINAPI session_rate_control_SetRate(IMFRateControl *iface, BOOL t
 
     TRACE("%p, %d, %f.\n", iface, thin, rate);
 
+    if (!rate)
+    {
+        /* The Anacrusis fails to play its video if we succeed here */
+        ERR("Scrubbing not implemented!\n");
+        return E_NOTIMPL;
+    }
+
     if (FAILED(hr = create_session_op(SESSION_CMD_SET_RATE, &op)))
         return hr;
 
-- 
2.49.0

From d03926aae719efd5854a819e7a15fc92684acfeb Mon Sep 17 00:00:00 2001
From: Santino Mazza <smazza@codeweavers.com>
Date: Tue, 31 Oct 2023 20:44:53 -0300
Subject: [PATCH 0240/1564] mf: Signal event_cond in wg_parser_stream_disable.

A workaround to fix a hang in media_source_Shutdown in old media
source, because the wg_parser receives an EOS signal after
media_source_Shutdown disabled the streams, and event_cond
never gets signaled so it never stops being busy.

Cw-Bug-Id: #21809
---
 dlls/winegstreamer/wg_parser.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index 93e3da291c0..f3e89979d6b 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -295,6 +295,7 @@ static NTSTATUS wg_parser_stream_disable(void *args)
         stream->desired_caps = NULL;
     }
     pthread_mutex_unlock(&parser->mutex);
+    pthread_cond_signal(&stream->event_cond);
     pthread_cond_signal(&stream->event_empty_cond);
     return S_OK;
 }
-- 
2.49.0

From 5f38aaebdb73d3b7a0ec02f20ee23fcaa38cb2f8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 13 Jan 2023 09:08:33 +0100
Subject: [PATCH 0241/1564] mf: Drop late samples in audio renderer.

CW-Bug-Id: #21159

Squashed with:

mf: Don't leak dropped samples.

CW-Bug-Id: #22798
---
 dlls/mf/sar.c | 33 ++++++++++++++++++++++++++-------
 1 file changed, 26 insertions(+), 7 deletions(-)

diff --git a/dlls/mf/sar.c b/dlls/mf/sar.c
index 84824f954dd..970063497b1 100644
--- a/dlls/mf/sar.c
+++ b/dlls/mf/sar.c
@@ -1339,6 +1339,7 @@ static HRESULT stream_queue_sample(struct audio_renderer *renderer, IMFSample *s
 {
     struct queued_object *object;
     DWORD sample_len, sample_frames;
+    MFTIME time, clocktime, systime;
     HRESULT hr;
 
     if (FAILED(hr = IMFSample_GetTotalLength(sample, &sample_len)))
@@ -1346,15 +1347,33 @@ static HRESULT stream_queue_sample(struct audio_renderer *renderer, IMFSample *s
 
     sample_frames = sample_len / renderer->frame_size;
 
-    if (!(object = calloc(1, sizeof(*object))))
-        return E_OUTOFMEMORY;
+    if (FAILED(hr = IMFSample_GetSampleTime(sample, &time)))
+    {
+        WARN("Failed to get sample time, hr %#lx.\n", hr);
+        return hr;
+    }
 
-    object->type = OBJECT_TYPE_SAMPLE;
-    object->u.sample.sample = sample;
-    IMFSample_AddRef(object->u.sample.sample);
+    if (!renderer->clock)
+        clocktime = time;
+    else if (FAILED(hr = IMFPresentationClock_GetCorrelatedTime(renderer->clock, 0, &clocktime, &systime)))
+    {
+        WARN("Failed to get clock time, hr %#lx.\n", hr);
+        return hr;
+    }
 
-    list_add_tail(&renderer->queue, &object->entry);
-    renderer->queued_frames += sample_frames;
+    if (time < clocktime)
+        FIXME("Dropping sample %p, time %I64u, clocktime %I64u, systime %I64u.\n", sample, time, clocktime, systime);
+    else
+    {
+        if (!(object = calloc(1, sizeof(*object))))
+            return E_OUTOFMEMORY;
+
+        object->type = OBJECT_TYPE_SAMPLE;
+        object->u.sample.sample = sample;
+        IMFSample_AddRef(object->u.sample.sample);
+        list_add_tail(&renderer->queue, &object->entry);
+        renderer->queued_frames += sample_frames;
+    }
 
     return S_OK;
 }
-- 
2.49.0

From c56fdfd4239ab9afd57ce3247173fc9b326758fb Mon Sep 17 00:00:00 2001
From: Yuxuan Shui <yshui@codeweavers.com>
Date: Thu, 12 Oct 2023 11:28:45 +0100
Subject: [PATCH 0242/1564] mf: Don't make stream sink shutdown dependent on
 IMFActivate presence in node.

Base on Bernhard's upstream MR: https://gitlab.winehq.org/wine/wine/-/merge_requests/3067
This fixes a media engine leak after it's shut down.

CW-Bug-Id: #22798
---
 dlls/mf/session.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/mf/session.c b/dlls/mf/session.c
index 8ceb7c3e88c..87c46673cca 100644
--- a/dlls/mf/session.c
+++ b/dlls/mf/session.c
@@ -840,7 +840,7 @@ static void session_shutdown_current_topology(struct media_session *session)
                         WARN("Failed to shut down activation object for the sink, hr %#lx.\n", hr);
                     IMFActivate_Release(activate);
                 }
-                else if (SUCCEEDED(topology_node_get_object(node, &IID_IMFStreamSink, (void **)&stream_sink)))
+                if (SUCCEEDED(topology_node_get_object(node, &IID_IMFStreamSink, (void **)&stream_sink)))
                 {
                     if (SUCCEEDED(IMFStreamSink_GetMediaSink(stream_sink, &sink)))
                     {
-- 
2.49.0

From 9eb2d28c07e50780310c0218b04d3af7979d42ab Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 2 Apr 2024 13:08:27 +0200
Subject: [PATCH 0243/1564] mf/session: Keep previously allocated sample with
 the transform streams.

CW-Bug-Id: #20833
---
 dlls/mf/session.c | 28 ++++++++++++++++++++++++----
 1 file changed, 24 insertions(+), 4 deletions(-)

diff --git a/dlls/mf/session.c b/dlls/mf/session.c
index 87c46673cca..e5e24b36ffb 100644
--- a/dlls/mf/session.c
+++ b/dlls/mf/session.c
@@ -159,6 +159,7 @@ struct transform_stream
     struct list samples;
     unsigned int requests;
     unsigned int min_buffer_size;
+    IMFSample *allocated_sample;
     BOOL draining;
 };
 
@@ -762,6 +763,12 @@ static void transform_stream_drop_events(struct transform_stream *stream)
 {
     IMFMediaEvent *event;
 
+    if (stream->allocated_sample)
+    {
+        IMFSample_Release(stream->allocated_sample);
+        stream->allocated_sample = NULL;
+    }
+
     while (SUCCEEDED(transform_stream_pop_event(stream, &event)))
         IMFMediaEvent_Release(event);
 }
@@ -3424,12 +3431,22 @@ static void session_set_sink_stream_state(struct media_session *session, IMFStre
 static HRESULT transform_get_external_output_sample(const struct media_session *session, struct topo_node *transform,
         DWORD output, const MFT_OUTPUT_STREAM_INFO *stream_info, IMFSample **sample)
 {
+    struct transform_stream *stream = &transform->u.transform.outputs[output];
+    DWORD buffer_size, sample_size, input;
     IMFMediaBuffer *buffer = NULL;
     struct topo_node *topo_node;
-    unsigned int buffer_size;
-    DWORD input;
     HRESULT hr;
 
+    buffer_size = max(stream_info->cbSize, stream->min_buffer_size);
+    if ((*sample = stream->allocated_sample))
+    {
+        stream->allocated_sample = NULL;
+        if (SUCCEEDED(IMFSample_GetTotalLength(*sample, &sample_size)) && sample_size >= buffer_size)
+            return S_OK;
+        IMFSample_Release(*sample);
+        *sample = NULL;
+    }
+
     if (!(topo_node = session_get_topo_node_output(session, transform, output, &input)))
     {
         WARN("Failed to node %p/%lu output.\n", transform, output);
@@ -3442,8 +3459,6 @@ static HRESULT transform_get_external_output_sample(const struct media_session *
     }
     else
     {
-        buffer_size = max(stream_info->cbSize, transform->u.transform.outputs[output].min_buffer_size);
-
         hr = MFCreateAlignedMemoryBuffer(buffer_size, stream_info->cbAlignment, &buffer);
         if (SUCCEEDED(hr))
             hr = MFCreateSample(sample);
@@ -3661,6 +3676,11 @@ static HRESULT transform_node_pull_samples(const struct media_session *session,
             if (FAILED(hr = transform_stream_push_sample(stream, buffers[i].pSample)))
                 WARN("Failed to queue output sample, hr %#lx\n", hr);
         }
+        else if (hr == MF_E_TRANSFORM_NEED_MORE_INPUT && !stream->allocated_sample)
+        {
+            stream->allocated_sample = buffers[i].pSample;
+            buffers[i].pSample = NULL;
+        }
     }
 
 done:
-- 
2.49.0

From a7f51d661284d0a827a60c64301891ab9809868f Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 25 Jan 2022 10:29:58 -0600
Subject: [PATCH 0244/1564] HACK: mf: Always allow enumerating source types in
 topology

This lets us connect directly to a source format without a color
converter.

CW-Bug-Id: #19516
CW-Bug-Id: #19859
---
 dlls/mf/session.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/mf/session.c b/dlls/mf/session.c
index e5e24b36ffb..d2cfc4db995 100644
--- a/dlls/mf/session.c
+++ b/dlls/mf/session.c
@@ -2092,6 +2092,8 @@ static void session_set_topology(struct media_session *session, DWORD flags, IMF
         {
             hr = session_bind_output_nodes(topology);
 
+            IMFTopology_SetUINT32(topology, &MF_TOPOLOGY_ENUMERATE_SOURCE_TYPES, TRUE);
+
             if (SUCCEEDED(hr))
                 hr = IMFTopoLoader_Load(session->topo_loader, topology, &resolved_topology, NULL /* FIXME? */);
             if (SUCCEEDED(hr))
-- 
2.49.0

From b489302007fda617baa16af1e1a6849c90cf1e3a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 18 Aug 2022 16:38:19 +0200
Subject: [PATCH 0245/1564] HACK: mf/topology_loader: Force initialize
 downstream media type if it's not.

---
 dlls/mf/topology_loader.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/dlls/mf/topology_loader.c b/dlls/mf/topology_loader.c
index 73f70e62bc6..a1b201fd4d2 100644
--- a/dlls/mf/topology_loader.c
+++ b/dlls/mf/topology_loader.c
@@ -383,7 +383,10 @@ static HRESULT get_first_supported_media_type(IMFMediaTypeHandler *handler, IMFM
 
     for (i = 0; SUCCEEDED(hr = IMFMediaTypeHandler_GetMediaTypeByIndex(handler, i, &media_type)); i++)
     {
-        if (SUCCEEDED(hr = IMFMediaTypeHandler_IsMediaTypeSupported(handler, media_type, NULL)))
+        /* HACK: Force initialize media type here, this is now something the topology laoder should do
+         * according to conformance tests but it should hopefully going to solve uninitialized audio
+         * renderer issues. */
+        if (SUCCEEDED(hr = IMFMediaTypeHandler_SetCurrentMediaType(handler, media_type)))
         {
             *type = media_type;
             return hr;
-- 
2.49.0

From d365fd58b46174f88239a594ea6daf0db2969088 Mon Sep 17 00:00:00 2001
From: Arkadiusz Hiler <ahiler@codeweavers.com>
Date: Thu, 23 Nov 2023 10:25:57 +0200
Subject: [PATCH 0254/1564] winegstreamer: Support WMA with 5.1 and 7.1 audio.

---
 dlls/winegstreamer/mfplat.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/dlls/winegstreamer/mfplat.c b/dlls/winegstreamer/mfplat.c
index 7e332b29eb2..93f787a9040 100644
--- a/dlls/winegstreamer/mfplat.c
+++ b/dlls/winegstreamer/mfplat.c
@@ -492,6 +492,10 @@ static void mf_media_type_to_wg_format_audio(IMFMediaType *type, const GUID *sub
             channel_mask = KSAUDIO_SPEAKER_MONO;
         else if (channels == 2)
             channel_mask = KSAUDIO_SPEAKER_STEREO;
+        else if (channels == 6)
+            channel_mask = KSAUDIO_SPEAKER_5POINT1;
+        else if (channels == 8)
+            channel_mask = KSAUDIO_SPEAKER_7POINT1;
         else
         {
             FIXME("Channel mask is not set.\n");
-- 
2.49.0

From ca7957d4ab83bd9677f5a48d22c489cb9a992657 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 20 Jan 2023 14:50:38 -0600
Subject: [PATCH 0255/1564] winegstreamer: Implement MFT_MESSAGE_COMMAND_DRAIN
 for wma decoder.

CW-Bug-Id: #21804
CW-Bug-Id: #22299
---
 dlls/winegstreamer/wma_decoder.c | 13 ++++++++++++-
 1 file changed, 12 insertions(+), 1 deletion(-)

diff --git a/dlls/winegstreamer/wma_decoder.c b/dlls/winegstreamer/wma_decoder.c
index 352d2c6a8e7..ccde829e988 100644
--- a/dlls/winegstreamer/wma_decoder.c
+++ b/dlls/winegstreamer/wma_decoder.c
@@ -506,7 +506,18 @@ static HRESULT WINAPI transform_ProcessEvent(IMFTransform *iface, DWORD id, IMFM
 
 static HRESULT WINAPI transform_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
 {
-    FIXME("iface %p, message %#x, param %p stub!\n", iface, message, (void *)param);
+    struct wma_decoder *decoder = impl_from_IMFTransform(iface);
+
+    TRACE("iface %p, message %#x, param %p.\n", iface, message, (void *)param);
+
+    if (!decoder->wg_transform)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (message == MFT_MESSAGE_COMMAND_DRAIN)
+        return wg_transform_drain(decoder->wg_transform);
+
+    FIXME("Ignoring message %#x.\n", message);
+
     return S_OK;
 }
 
-- 
2.49.0

From 73c04249ef8c348585ebf4e551308f74fbc28c0a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 10 May 2024 12:07:07 +0200
Subject: [PATCH 0256/1564] winegstreamer: Support hardware buffer conversion
 with D3D11 video processor.

CW-Bug-Id: #20833
---
 dlls/winegstreamer/video_processor.c | 270 ++++++++++++++++++++++++++-
 1 file changed, 262 insertions(+), 8 deletions(-)

diff --git a/dlls/winegstreamer/video_processor.c b/dlls/winegstreamer/video_processor.c
index 3cb2c1a5bc6..c7f43ec328f 100644
--- a/dlls/winegstreamer/video_processor.c
+++ b/dlls/winegstreamer/video_processor.c
@@ -23,6 +23,9 @@
 #include "mftransform.h"
 #include "wmcodecdsp.h"
 
+#include "initguid.h"
+#include "d3d11.h"
+
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
@@ -84,6 +87,7 @@ struct video_processor
     IMFMediaType *output_type;
     MFT_OUTPUT_STREAM_INFO output_info;
 
+    IMFSample *input_sample;
     wg_transform_t wg_transform;
     struct wg_sample_queue *wg_sample_queue;
 
@@ -212,6 +216,237 @@ static HRESULT video_processor_uninit_allocator(struct video_processor *processo
     return hr;
 }
 
+static HRESULT video_processor_get_d3d11_resource(IMFSample *sample, ID3D11Resource **resource)
+{
+    IMFMediaBuffer *buffer;
+    DWORD count;
+    HRESULT hr;
+
+    if (FAILED(IMFSample_GetBufferCount(sample, &count)) || count > 1)
+        return E_FAIL;
+
+    if (SUCCEEDED(hr = IMFSample_GetBufferByIndex(sample, 0, &buffer)))
+    {
+        IMFDXGIBuffer *dxgi_buffer;
+
+        if (SUCCEEDED(hr = IMFMediaBuffer_QueryInterface(buffer, &IID_IMFDXGIBuffer, (void **)&dxgi_buffer)))
+        {
+            hr = IMFDXGIBuffer_GetResource(dxgi_buffer, &IID_ID3D11Resource, (void **)resource);
+            IMFDXGIBuffer_Release(dxgi_buffer);
+        }
+
+        IMFMediaBuffer_Release(buffer);
+    }
+
+    return hr;
+}
+
+static HRESULT get_d3d11_video_device(ID3D11Resource *resource, ID3D11VideoDevice **video_device)
+{
+    ID3D11Device *device;
+    HRESULT hr;
+
+    ID3D11Resource_GetDevice(resource, &device);
+    hr = ID3D11Device_QueryInterface(device, &IID_ID3D11VideoDevice, (void **)video_device);
+    ID3D11Device_Release(device);
+    return hr;
+}
+
+static HRESULT get_d3d11_video_context(ID3D11Resource *resource, ID3D11VideoContext **video_context)
+{
+    ID3D11DeviceContext *context;
+    ID3D11Device *device;
+    HRESULT hr;
+
+    ID3D11Resource_GetDevice(resource, &device);
+    ID3D11Device_GetImmediateContext(device, &context);
+    hr = ID3D11DeviceContext_QueryInterface(context, &IID_ID3D11VideoContext, (void **)video_context);
+    ID3D11DeviceContext_Release(context);
+    ID3D11Device_Release(device);
+    return hr;
+}
+
+static HRESULT create_video_processor_enumerator(ID3D11Resource *resource, UINT64 input_size, UINT64 output_size,
+        ID3D11VideoDevice **video_device, ID3D11VideoProcessorEnumerator **enumerator)
+{
+    D3D11_VIDEO_PROCESSOR_CONTENT_DESC enum_desc = {0};
+    HRESULT hr;
+
+    enum_desc.InputFrameFormat = D3D11_VIDEO_FRAME_FORMAT_PROGRESSIVE;
+    enum_desc.InputFrameRate.Denominator = 1;
+    enum_desc.InputFrameRate.Numerator = 1;
+    enum_desc.InputWidth = input_size >> 32;
+    enum_desc.InputHeight = (UINT32)input_size;
+    enum_desc.OutputFrameRate.Denominator = 1;
+    enum_desc.OutputFrameRate.Numerator = 1;
+    enum_desc.OutputWidth = output_size >> 32;
+    enum_desc.OutputHeight = (UINT32)output_size;
+    enum_desc.Usage = D3D11_VIDEO_USAGE_PLAYBACK_NORMAL;
+
+    if (FAILED(hr = get_d3d11_video_device(resource, video_device)))
+        return hr;
+    if (FAILED(hr = ID3D11VideoDevice_CreateVideoProcessorEnumerator(*video_device, &enum_desc, enumerator)))
+    {
+        ID3D11VideoDevice_Release(*video_device);
+        *video_device = NULL;
+    }
+
+    return hr;
+}
+
+struct resource_desc
+{
+    GUID subtype;
+    UINT64 frame_size;
+};
+
+static HRESULT init_d3d11_video_processor(const struct resource_desc *input_desc, ID3D11Resource *input,
+        const struct resource_desc *output_desc, ID3D11Resource *output, ID3D11VideoProcessor **processor,
+        ID3D11VideoProcessorInputView **input_view, ID3D11VideoProcessorOutputView **output_view)
+{
+    D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC output_view_desc = {0};
+    D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC input_view_desc = {0};
+    ID3D11VideoProcessorEnumerator *enumerator;
+    UINT input_flags = 0, output_flags = 0;
+    ID3D11VideoDevice *device;
+    HRESULT hr;
+
+    *processor = NULL;
+    *input_view = NULL;
+    *output_view = NULL;
+
+    input_view_desc.FourCC = input_desc->subtype.Data1;
+    input_view_desc.ViewDimension = D3D11_VPIV_DIMENSION_TEXTURE2D;
+    input_view_desc.Texture2D.MipSlice = 0;
+    input_view_desc.Texture2D.ArraySlice = 0;
+
+    output_view_desc.ViewDimension = D3D11_VPOV_DIMENSION_TEXTURE2D;
+    output_view_desc.Texture2D.MipSlice = 0;
+
+    /* assume input and output have the same device */
+    if (FAILED(hr = create_video_processor_enumerator(input, input_desc->frame_size,
+            output_desc->frame_size, &device, &enumerator)))
+        return hr;
+
+    if (FAILED(hr = ID3D11VideoProcessorEnumerator_CheckVideoProcessorFormat(enumerator,
+            input_desc->subtype.Data1, &input_flags))
+            || FAILED(hr = ID3D11VideoProcessorEnumerator_CheckVideoProcessorFormat(enumerator,
+            output_desc->subtype.Data1, &output_flags)))
+        goto failed;
+    if (!(input_flags & D3D11_VIDEO_PROCESSOR_FORMAT_SUPPORT_INPUT)
+            || !(output_flags & D3D11_VIDEO_PROCESSOR_FORMAT_SUPPORT_OUTPUT))
+    {
+        hr = MF_E_INVALIDMEDIATYPE;
+        goto failed;
+    }
+
+    if (FAILED(hr = ID3D11VideoDevice_CreateVideoProcessorInputView(device, input, enumerator,
+            &input_view_desc, input_view)))
+        goto failed;
+    if (FAILED(hr = ID3D11VideoDevice_CreateVideoProcessorOutputView(device, output, enumerator,
+            &output_view_desc, output_view)))
+    {
+        ID3D11VideoProcessorInputView_Release(*input_view);
+        *input_view = NULL;
+        goto failed;
+    }
+
+    if (FAILED(hr = ID3D11VideoDevice_CreateVideoProcessor(device, enumerator, 0, processor)))
+    {
+        ID3D11VideoProcessorOutputView_Release(*output_view);
+        *output_view = NULL;
+        ID3D11VideoProcessorInputView_Release(*input_view);
+        *input_view = NULL;
+        goto failed;
+    }
+
+failed:
+    ID3D11VideoProcessorEnumerator_Release(enumerator);
+    ID3D11VideoDevice_Release(device);
+    return hr;
+}
+
+static HRESULT video_processor_process_output_d3d11(struct video_processor *processor,
+        IMFSample *input_sample, IMFSample *output_sample)
+{
+    D3D11_VIDEO_PROCESSOR_STREAM streams = {0};
+    struct resource_desc input_desc, output_desc;
+    ID3D11VideoProcessorOutputView *output_view;
+    ID3D11VideoProcessorInputView *input_view;
+    ID3D11VideoProcessor *video_processor;
+    ID3D11VideoContext *video_context;
+    ID3D11Resource *input, *output;
+    MFVideoArea aperture;
+    RECT rect = {0};
+    LONGLONG time;
+    DWORD flags;
+    HRESULT hr;
+
+    if (FAILED(hr = IMFMediaType_GetUINT64(processor->input_type, &MF_MT_FRAME_SIZE, &input_desc.frame_size))
+            || FAILED(hr = IMFMediaType_GetGUID(processor->input_type, &MF_MT_SUBTYPE, &input_desc.subtype))
+            || FAILED(hr = IMFMediaType_GetUINT64(processor->output_type, &MF_MT_FRAME_SIZE, &output_desc.frame_size))
+            || FAILED(hr = IMFMediaType_GetGUID(processor->output_type, &MF_MT_SUBTYPE, &output_desc.subtype)))
+        return hr;
+
+    if (FAILED(hr = video_processor_get_d3d11_resource(input_sample, &input)))
+        return hr;
+    if (FAILED(hr = video_processor_get_d3d11_resource(output_sample, &output)))
+    {
+        ID3D11Resource_Release(input);
+        return hr;
+    }
+
+    if (FAILED(hr = get_d3d11_video_context(input, &video_context)))
+        goto failed;
+    if (FAILED(hr = init_d3d11_video_processor(&input_desc, input, &output_desc, output,
+            &video_processor, &input_view, &output_view)))
+    {
+        ID3D11VideoContext_Release(video_context);
+        goto failed;
+    }
+
+    streams.Enable = TRUE;
+    streams.OutputIndex = 0;
+    streams.InputFrameOrField = 0;
+    streams.PastFrames = 0;
+    streams.FutureFrames = 0;
+    streams.pInputSurface = input_view;
+
+    if (SUCCEEDED(IMFMediaType_GetBlob(processor->input_type, &MF_MT_MINIMUM_DISPLAY_APERTURE, (BYTE *)&aperture, sizeof(aperture), NULL)))
+        SetRect(&rect, aperture.OffsetX.value, aperture.OffsetY.value, aperture.OffsetX.value + aperture.Area.cx,
+                aperture.OffsetY.value + aperture.Area.cy);
+    else
+        SetRect(&rect, 0, 0, input_desc.frame_size >> 32, (UINT32)input_desc.frame_size);
+    ID3D11VideoContext_VideoProcessorSetStreamSourceRect(video_context, video_processor, 0, TRUE, &rect);
+
+    if (SUCCEEDED(IMFMediaType_GetBlob(processor->output_type, &MF_MT_MINIMUM_DISPLAY_APERTURE, (BYTE *)&aperture, sizeof(aperture), NULL)))
+        SetRect(&rect, aperture.OffsetX.value, aperture.OffsetY.value, aperture.OffsetX.value + aperture.Area.cx,
+                aperture.OffsetY.value + aperture.Area.cy);
+    else
+        SetRect(&rect, 0, 0, output_desc.frame_size >> 32, (UINT32)output_desc.frame_size);
+    ID3D11VideoContext_VideoProcessorSetStreamDestRect(video_context, video_processor, 0, TRUE, &rect);
+
+    ID3D11VideoContext_VideoProcessorBlt(video_context, video_processor, output_view, 0, 1, &streams);
+
+    IMFSample_CopyAllItems(input_sample, (IMFAttributes *)output_sample);
+    if (SUCCEEDED(IMFSample_GetSampleDuration(input_sample, &time)))
+        IMFSample_SetSampleDuration(output_sample, time);
+    if (SUCCEEDED(IMFSample_GetSampleTime(input_sample, &time)))
+        IMFSample_SetSampleTime(output_sample, time);
+    if (SUCCEEDED(IMFSample_GetSampleFlags(input_sample, &flags)))
+        IMFSample_SetSampleFlags(output_sample, flags);
+
+    ID3D11VideoProcessorOutputView_Release(output_view);
+    ID3D11VideoProcessorInputView_Release(input_view);
+    ID3D11VideoProcessor_Release(video_processor);
+    ID3D11VideoContext_Release(video_context);
+
+failed:
+    ID3D11Resource_Release(output);
+    ID3D11Resource_Release(input);
+    return hr;
+}
+
 static struct video_processor *impl_from_IMFTransform(IMFTransform *iface)
 {
     return CONTAINING_RECORD(iface, struct video_processor, IMFTransform_iface);
@@ -685,8 +920,12 @@ static HRESULT WINAPI video_processor_ProcessInput(IMFTransform *iface, DWORD id
 
     if (!impl->wg_transform)
         return MF_E_TRANSFORM_TYPE_NOT_SET;
+    if (impl->input_sample)
+        return MF_E_NOTACCEPTING;
 
-    return wg_transform_push_mf(impl->wg_transform, sample, impl->wg_sample_queue);
+    impl->input_sample = sample;
+    IMFSample_AddRef(impl->input_sample);
+    return S_OK;
 }
 
 static HRESULT WINAPI video_processor_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
@@ -694,7 +933,7 @@ static HRESULT WINAPI video_processor_ProcessOutput(IMFTransform *iface, DWORD f
 {
     struct video_processor *impl = impl_from_IMFTransform(iface);
     MFT_OUTPUT_STREAM_INFO info;
-    IMFSample *output_sample;
+    IMFSample *input_sample, *output_sample;
     HRESULT hr;
 
     TRACE("iface %p, flags %#lx, count %lu, samples %p, status %p.\n", iface, flags, count, samples, status);
@@ -956,23 +956,37 @@
 
     provide_samples = (impl->output_info.dwFlags & MFT_OUTPUT_STREAM_PROVIDES_SAMPLES) && !playback_mode;
 
+    if (!(input_sample = impl->input_sample))
+        return MF_E_TRANSFORM_NEED_MORE_INPUT;
+    impl->input_sample = NULL;
+
     if (provide_samples)
     {
-        if (FAILED(hr = video_processor_init_allocator(impl)))
-            return hr;
-        if (FAILED(hr = IMFVideoSampleAllocatorEx_AllocateSample(impl->allocator, &output_sample)))
+        if (FAILED(hr = video_processor_init_allocator(impl))
+                || FAILED(hr = IMFVideoSampleAllocatorEx_AllocateSample(impl->allocator, &output_sample)))
+        {
+            IMFSample_Release(input_sample);
             return hr;
+        }
     }
     else
     {
         if (!(output_sample = samples->pSample))
+        {
+            IMFSample_Release(input_sample);
             return E_INVALIDARG;
+        }
         IMFSample_AddRef(output_sample);
     }
 
-    if (FAILED(hr = wg_transform_read_mf(impl->wg_transform, output_sample, info.cbSize, &samples->dwStatus, NULL)))
-        goto done;
-    wg_sample_queue_flush(impl->wg_sample_queue, false);
+    if (FAILED(hr = video_processor_process_output_d3d11(impl, input_sample, output_sample)))
+    {
+        if (FAILED(hr = wg_transform_push_mf(impl->wg_transform, input_sample, impl->wg_sample_queue)))
+            goto done;
+        if (FAILED(hr = wg_transform_read_mf(impl->wg_transform, output_sample, info.cbSize, &samples->dwStatus, NULL)))
+            goto done;
+        wg_sample_queue_flush(impl->wg_sample_queue, false);
+    }
 
     if (provide_samples)
     {
@@ -735,6 +988,7 @@ static HRESULT WINAPI video_processor_ProcessOutput(IMFTransform *iface, DWORD f
 
 done:
     IMFSample_Release(output_sample);
+    IMFSample_Release(input_sample);
     return hr;
 }
 
-- 
2.49.0

From 29633bbaa8d09e3850b0088bb295b8f016ee3a91 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 11 Sep 2024 18:21:13 +0200
Subject: [PATCH 0257/1564] winegstreamer/video_processor: Support colorspace
 range in the D3D11 video processor.

CW-Bug-Id: #24235
---
 dlls/winegstreamer/video_processor.c | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/dlls/winegstreamer/video_processor.c b/dlls/winegstreamer/video_processor.c
index c7f43ec328f..5ecc736718b 100644
--- a/dlls/winegstreamer/video_processor.c
+++ b/dlls/winegstreamer/video_processor.c
@@ -369,6 +369,7 @@ failed:
 static HRESULT video_processor_process_output_d3d11(struct video_processor *processor,
         IMFSample *input_sample, IMFSample *output_sample)
 {
+    D3D11_VIDEO_PROCESSOR_COLOR_SPACE color_space;
     D3D11_VIDEO_PROCESSOR_STREAM streams = {0};
     struct resource_desc input_desc, output_desc;
     ID3D11VideoProcessorOutputView *output_view;
@@ -379,6 +380,7 @@ static HRESULT video_processor_process_output_d3d11(struct video_processor *proc
     MFVideoArea aperture;
     RECT rect = {0};
     LONGLONG time;
+    UINT32 value;
     DWORD flags;
     HRESULT hr;
 
@@ -426,6 +428,18 @@ static HRESULT video_processor_process_output_d3d11(struct video_processor *proc
         SetRect(&rect, 0, 0, output_desc.frame_size >> 32, (UINT32)output_desc.frame_size);
     ID3D11VideoContext_VideoProcessorSetStreamDestRect(video_context, video_processor, 0, TRUE, &rect);
 
+    memset(&color_space, 0, sizeof(color_space));
+    if (SUCCEEDED(IMFMediaType_GetUINT32(processor->input_type, &MF_MT_VIDEO_NOMINAL_RANGE, &value)))
+        color_space.Nominal_Range = value == MFNominalRange_Wide ? D3D11_VIDEO_PROCESSOR_NOMINAL_RANGE_16_235
+                                                                 : D3D11_VIDEO_PROCESSOR_NOMINAL_RANGE_0_255;
+    ID3D11VideoContext_VideoProcessorSetStreamColorSpace(video_context, video_processor, 0, &color_space);
+
+    memset(&color_space, 0, sizeof(color_space));
+    if (SUCCEEDED(IMFMediaType_GetUINT32(processor->output_type, &MF_MT_VIDEO_NOMINAL_RANGE, &value)))
+        color_space.Nominal_Range = value == MFNominalRange_Wide ? D3D11_VIDEO_PROCESSOR_NOMINAL_RANGE_16_235
+                                                                 : D3D11_VIDEO_PROCESSOR_NOMINAL_RANGE_0_255;
+    ID3D11VideoContext_VideoProcessorSetOutputColorSpace(video_context, video_processor, &color_space);
+
     ID3D11VideoContext_VideoProcessorBlt(video_context, video_processor, output_view, 0, 1, &streams);
 
     IMFSample_CopyAllItems(input_sample, (IMFAttributes *)output_sample);
-- 
2.49.0

From f7d01c7f23dab2ab46d2d3dc297683bd11c0ee34 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 13 Aug 2024 19:19:33 +0200
Subject: [PATCH 0258/1564] winegstreamer: Avoid using the aperture for padding
 with the H264 decoder.

It can change stream sizes during playback, and the video info aren't
updated accordingly.

CW-Bug-Id: #20833
---
 dlls/winegstreamer/wg_transform.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
index d1d35197f81..7fb43bdbc93 100644
--- a/dlls/winegstreamer/wg_transform.c
+++ b/dlls/winegstreamer/wg_transform.c
@@ -81,7 +81,7 @@ static void align_video_info_planes(MFVideoInfo *video_info, gsize plane_align,
     align->padding_right = ((plane_align + 1) - (info->width & plane_align)) & plane_align;
     align->padding_bottom = ((plane_align + 1) - (info->height & plane_align)) & plane_align;
 
-    if (!is_mf_video_area_empty(aperture))
+    if (!is_mf_video_area_empty(aperture) && !plane_align)
     {
         align->padding_right = max(align->padding_right, video_info->dwWidth - aperture->OffsetX.value - aperture->Area.cx);
         align->padding_bottom = max(align->padding_bottom, video_info->dwHeight - aperture->OffsetY.value - aperture->Area.cy);
-- 
2.49.0

From 9cbf94fb0c8d26f9d623216b0fbef631a6cc6b50 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 16 Aug 2024 14:22:51 +0200
Subject: [PATCH 0260/1564] winegstreamer/resampler: Use WAVEFORMATEX for
 input/output media types.

CW-Bug-Id: #20833
---
 dlls/winegstreamer/resampler.c | 123 ++++++++++++++++-----------------
 1 file changed, 60 insertions(+), 63 deletions(-)

diff --git a/dlls/winegstreamer/resampler.c b/dlls/winegstreamer/resampler.c
index c1ce9897ef1..38478b22ecc 100644
--- a/dlls/winegstreamer/resampler.c
+++ b/dlls/winegstreamer/resampler.c
@@ -45,18 +45,20 @@ struct resampler
     IUnknown *outer;
     LONG refcount;
 
-    IMFMediaType *input_type;
+    WAVEFORMATEX *input_format;
     MFT_INPUT_STREAM_INFO input_info;
-    IMFMediaType *output_type;
+    WAVEFORMATEX *output_format;
     MFT_OUTPUT_STREAM_INFO output_info;
 
     wg_transform_t wg_transform;
     struct wg_sample_queue *wg_sample_queue;
 };
 
-static HRESULT try_create_wg_transform(struct resampler *impl)
+static HRESULT try_create_wg_transform(struct resampler *impl, WAVEFORMATEX *input_format, WAVEFORMATEX *output_format)
 {
+    IMFMediaType *input_type, *output_type;
     struct wg_transform_attrs attrs = {0};
+    HRESULT hr;
 
     if (impl->wg_transform)
     {
@@ -64,7 +66,18 @@ static HRESULT try_create_wg_transform(struct resampler *impl)
         impl->wg_transform = 0;
     }
 
-    return wg_transform_create_mf(impl->input_type, impl->output_type, &attrs, &impl->wg_transform);
+    if (FAILED(hr = MFCreateAudioMediaType(input_format, (IMFAudioMediaType **)&input_type)))
+        return hr;
+    if (FAILED(hr = MFCreateAudioMediaType(output_format, (IMFAudioMediaType **)&output_type)))
+    {
+        IMFMediaType_Release(input_type);
+        return hr;
+    }
+
+    hr = wg_transform_create_mf(input_type, output_type, &attrs, &impl->wg_transform);
+    IMFMediaType_Release(input_type);
+    IMFMediaType_Release(output_type);
+    return hr;
 }
 
 static inline struct resampler *impl_from_IUnknown(IUnknown *iface)
@@ -122,10 +135,10 @@ static ULONG WINAPI unknown_Release(IUnknown *iface)
     {
         if (impl->wg_transform)
             wg_transform_destroy(impl->wg_transform);
-        if (impl->input_type)
-            IMFMediaType_Release(impl->input_type);
-        if (impl->output_type)
-            IMFMediaType_Release(impl->output_type);
+        if (impl->input_format)
+            CoTaskMemFree(impl->input_format);
+        if (impl->output_format)
+            CoTaskMemFree(impl->output_format);
 
         wg_sample_queue_destroy(impl->wg_sample_queue);
         free(impl);
@@ -191,7 +204,7 @@ static HRESULT WINAPI transform_GetInputStreamInfo(IMFTransform *iface, DWORD id
 
     TRACE("iface %p, id %#lx, info %p.\n", iface, id, info);
 
-    if (!impl->input_type || !impl->output_type)
+    if (!impl->input_format || !impl->output_format)
     {
         memset(info, 0, sizeof(*info));
         return MF_E_TRANSFORM_TYPE_NOT_SET;
@@ -207,7 +220,7 @@ static HRESULT WINAPI transform_GetOutputStreamInfo(IMFTransform *iface, DWORD i
 
     TRACE("iface %p, id %#lx, info %p.\n", iface, id, info);
 
-    if (!impl->input_type || !impl->output_type)
+    if (!impl->input_format || !impl->output_format)
     {
         memset(info, 0, sizeof(*info));
         return MF_E_TRANSFORM_TYPE_NOT_SET;
@@ -359,34 +372,34 @@ static HRESULT check_media_type(IMFMediaType *type)
 static HRESULT WINAPI transform_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
 {
     struct resampler *impl = impl_from_IMFTransform(iface);
-    UINT32 block_alignment;
+    WAVEFORMATEX *format;
+    UINT32 value;
     HRESULT hr;
 
     TRACE("iface %p, id %#lx, type %p, flags %#lx.\n", iface, id, type, flags);
 
     if (FAILED(hr = check_media_type(type)))
         return hr;
-    if (FAILED(hr = IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &block_alignment)))
+    if (FAILED(hr = IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &value)))
         return MF_E_INVALIDMEDIATYPE;
     if (flags & MFT_SET_TYPE_TEST_ONLY)
         return S_OK;
 
-    if (!impl->input_type && FAILED(hr = MFCreateMediaType(&impl->input_type)))
-        return hr;
-
-    if (impl->output_type)
+    if (impl->input_format)
     {
-        IMFMediaType_Release(impl->output_type);
-        impl->output_type = NULL;
+        CoTaskMemFree(impl->input_format);
+        impl->input_format = NULL;
+    }
+    if (impl->output_format)
+    {
+        CoTaskMemFree(impl->output_format);
+        impl->output_format = NULL;
     }
 
-    if (SUCCEEDED(hr = IMFMediaType_CopyAllItems(type, (IMFAttributes *)impl->input_type)))
-        impl->input_info.cbSize = block_alignment;
-    else
+    if (SUCCEEDED(hr = MFCreateWaveFormatExFromMFMediaType(type, &format, &value, 0)))
     {
-        IMFMediaType_Release(impl->input_type);
-        impl->input_info.cbSize = 0;
-        impl->input_type = NULL;
+        impl->input_info.cbSize = format->nBlockAlign;
+        impl->input_format = format;
     }
 
     return hr;
@@ -395,82 +408,66 @@ static HRESULT WINAPI transform_SetInputType(IMFTransform *iface, DWORD id, IMFM
 static HRESULT WINAPI transform_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
 {
     struct resampler *impl = impl_from_IMFTransform(iface);
-    UINT32 block_alignment;
+    WAVEFORMATEX *format;
+    UINT32 value;
     HRESULT hr;
 
     TRACE("iface %p, id %#lx, type %p, flags %#lx.\n", iface, id, type, flags);
 
-    if (!impl->input_type)
+    if (!impl->input_format)
         return MF_E_TRANSFORM_TYPE_NOT_SET;
 
     if (FAILED(hr = check_media_type(type)))
         return hr;
-    if (FAILED(hr = IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &block_alignment)))
+    if (FAILED(hr = IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &value)))
         return MF_E_INVALIDMEDIATYPE;
     if (flags & MFT_SET_TYPE_TEST_ONLY)
         return S_OK;
 
-    if (!impl->output_type && FAILED(hr = MFCreateMediaType(&impl->output_type)))
-        return hr;
-
-    if (FAILED(hr = IMFMediaType_CopyAllItems(type, (IMFAttributes *)impl->output_type)))
-        goto failed;
-
-    if (FAILED(hr = try_create_wg_transform(impl)))
-        goto failed;
+    if (impl->output_format)
+    {
+        CoTaskMemFree(impl->output_format);
+        impl->output_format = NULL;
+    }
 
-    impl->output_info.cbSize = block_alignment;
-    return hr;
+    if (SUCCEEDED(hr = MFCreateWaveFormatExFromMFMediaType(type, &format, &value, 0)))
+    {
+        if (FAILED(hr = try_create_wg_transform(impl, impl->input_format, format)))
+            CoTaskMemFree(format);
+        else
+        {
+            impl->output_info.cbSize = format->nBlockAlign;
+            impl->output_format = format;
+        }
+    }
 
-failed:
-    IMFMediaType_Release(impl->output_type);
-    impl->output_info.cbSize = 0;
-    impl->output_type = NULL;
     return hr;
 }
 
 static HRESULT WINAPI transform_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
 {
     struct resampler *impl = impl_from_IMFTransform(iface);
-    HRESULT hr;
 
     TRACE("iface %p, id %#lx, type %p.\n", iface, id, type);
 
     if (id != 0)
         return MF_E_INVALIDSTREAMNUMBER;
-
-    if (!impl->input_type)
+    if (!impl->input_format)
         return MF_E_TRANSFORM_TYPE_NOT_SET;
-
-    if (FAILED(hr = MFCreateMediaType(type)))
-        return hr;
-
-    if (FAILED(hr = IMFMediaType_CopyAllItems(impl->input_type, (IMFAttributes *)*type)))
-        IMFMediaType_Release(*type);
-
-    return hr;
+    return MFCreateAudioMediaType(impl->input_format, (IMFAudioMediaType **)type);
 }
 
 static HRESULT WINAPI transform_GetOutputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
 {
     struct resampler *impl = impl_from_IMFTransform(iface);
-    HRESULT hr;
 
     TRACE("iface %p, id %#lx, type %p.\n", iface, id, type);
 
     if (id != 0)
         return MF_E_INVALIDSTREAMNUMBER;
-
-    if (!impl->output_type)
+    if (!impl->output_format)
         return MF_E_TRANSFORM_TYPE_NOT_SET;
-
-    if (FAILED(hr = MFCreateMediaType(type)))
-        return hr;
-
-    if (FAILED(hr = IMFMediaType_CopyAllItems(impl->output_type, (IMFAttributes *)*type)))
-        IMFMediaType_Release(*type);
-
-    return hr;
+    return MFCreateAudioMediaType(impl->output_format, (IMFAudioMediaType **)type);
 }
 
 static HRESULT WINAPI transform_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
-- 
2.49.0

From 969f918a9b9902583df0007d566c5da69267012a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 16 Aug 2024 14:22:56 +0200
Subject: [PATCH 0261/1564] winegstreamer/resampler: Recalculate resampler
 nBlockAlign and avgBytesPerSec values.

CW-Bug-Id: #20833
---
 dlls/winegstreamer/resampler.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/dlls/winegstreamer/resampler.c b/dlls/winegstreamer/resampler.c
index 38478b22ecc..c9c81cde555 100644
--- a/dlls/winegstreamer/resampler.c
+++ b/dlls/winegstreamer/resampler.c
@@ -398,6 +398,8 @@ static HRESULT WINAPI transform_SetInputType(IMFTransform *iface, DWORD id, IMFM
 
     if (SUCCEEDED(hr = MFCreateWaveFormatExFromMFMediaType(type, &format, &value, 0)))
     {
+        format->nBlockAlign = format->wBitsPerSample * format->nChannels / 8;
+        format->nAvgBytesPerSec = format->nSamplesPerSec * format->nBlockAlign;
         impl->input_info.cbSize = format->nBlockAlign;
         impl->input_format = format;
     }
@@ -432,6 +434,9 @@ static HRESULT WINAPI transform_SetOutputType(IMFTransform *iface, DWORD id, IMF
 
     if (SUCCEEDED(hr = MFCreateWaveFormatExFromMFMediaType(type, &format, &value, 0)))
     {
+        format->nBlockAlign = format->wBitsPerSample * format->nChannels / 8;
+        format->nAvgBytesPerSec = format->nSamplesPerSec * format->nBlockAlign;
+
         if (FAILED(hr = try_create_wg_transform(impl, impl->input_format, format)))
             CoTaskMemFree(format);
         else
-- 
2.49.0

From 561f4b87ddafbc92cc72b089770247c2cca3a2f0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 17 Nov 2023 11:13:35 +0100
Subject: [PATCH 0262/1564] winegstreamer: Rename aac_decoder to audio_decoder.

CW-Bug-Id: #21953

CW-Bug-Id: #20833
---
 dlls/winegstreamer/Makefile.in                |  2 +-
 .../{aac_decoder.c => audio_decoder.c}        | 54 +++++++++----------
 2 files changed, 28 insertions(+), 28 deletions(-)
 rename dlls/winegstreamer/{aac_decoder.c => audio_decoder.c} (91%)

diff --git a/dlls/winegstreamer/Makefile.in b/dlls/winegstreamer/Makefile.in
index c623b90f896..74f28658057 100644
--- a/dlls/winegstreamer/Makefile.in
+++ b/dlls/winegstreamer/Makefile.in
@@ -7,7 +7,7 @@ UNIX_CFLAGS  = $(GSTREAMER_CFLAGS)
 UNIX_LIBS    = $(GSTREAMER_LIBS) $(PTHREAD_LIBS)
 
 SOURCES = \
-	aac_decoder.c \
+	audio_decoder.c \
 	color_convert.c \
 	main.c \
 	media-converter/audioconv.c \
diff --git a/dlls/winegstreamer/aac_decoder.c b/dlls/winegstreamer/audio_decoder.c
similarity index 91%
rename from dlls/winegstreamer/aac_decoder.c
rename to dlls/winegstreamer/audio_decoder.c
index d8e8246e1ca..7490362e5b4 100644
--- a/dlls/winegstreamer/aac_decoder.c
+++ b/dlls/winegstreamer/audio_decoder.c
@@ -1,4 +1,4 @@
-/* AAC Decoder Transform
+/* Audio Decoder Transform
  *
  * Copyright 2022 Rmi Bernon for CodeWeavers
  *
@@ -34,7 +34,7 @@ WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
 #define NEXT_WAVEFORMATEXTENSIBLE(format) (WAVEFORMATEXTENSIBLE *)((BYTE *)(&(format)->Format + 1) + (format)->Format.cbSize)
 
-static WAVEFORMATEXTENSIBLE const aac_decoder_output_types[] =
+static WAVEFORMATEXTENSIBLE const audio_decoder_output_types[] =
 {
     {.Format = {.wFormatTag = WAVE_FORMAT_IEEE_FLOAT, .wBitsPerSample = 32, .nSamplesPerSec = 48000, .nChannels = 2,
                 .cbSize = sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX)}},
@@ -53,7 +53,7 @@ static const UINT32 default_channel_mask[7] =
     KSAUDIO_SPEAKER_5POINT1,
 };
 
-struct aac_decoder
+struct audio_decoder
 {
     IMFTransform IMFTransform_iface;
     LONG refcount;
@@ -68,12 +68,12 @@ struct aac_decoder
     struct wg_sample_queue *wg_sample_queue;
 };
 
-static struct aac_decoder *impl_from_IMFTransform(IMFTransform *iface)
+static struct audio_decoder *impl_from_IMFTransform(IMFTransform *iface)
 {
-    return CONTAINING_RECORD(iface, struct aac_decoder, IMFTransform_iface);
+    return CONTAINING_RECORD(iface, struct audio_decoder, IMFTransform_iface);
 }
 
-static HRESULT try_create_wg_transform(struct aac_decoder *decoder)
+static HRESULT try_create_wg_transform(struct audio_decoder *decoder)
 {
     struct wg_transform_attrs attrs = {0};
 
@@ -88,7 +88,7 @@ static HRESULT try_create_wg_transform(struct aac_decoder *decoder)
 
 static HRESULT WINAPI transform_QueryInterface(IMFTransform *iface, REFIID iid, void **out)
 {
-    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    struct audio_decoder *decoder = impl_from_IMFTransform(iface);
 
     TRACE("iface %p, iid %s, out %p.\n", iface, debugstr_guid(iid), out);
 
@@ -107,7 +107,7 @@ static HRESULT WINAPI transform_QueryInterface(IMFTransform *iface, REFIID iid,
 
 static ULONG WINAPI transform_AddRef(IMFTransform *iface)
 {
-    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    struct audio_decoder *decoder = impl_from_IMFTransform(iface);
     ULONG refcount = InterlockedIncrement(&decoder->refcount);
     TRACE("iface %p increasing refcount to %lu.\n", decoder, refcount);
     return refcount;
@@ -115,7 +115,7 @@ static ULONG WINAPI transform_AddRef(IMFTransform *iface)
 
 static ULONG WINAPI transform_Release(IMFTransform *iface)
 {
-    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    struct audio_decoder *decoder = impl_from_IMFTransform(iface);
     ULONG refcount = InterlockedDecrement(&decoder->refcount);
 
     TRACE("iface %p decreasing refcount to %lu.\n", decoder, refcount);
@@ -220,7 +220,7 @@ static HRESULT WINAPI transform_AddInputStreams(IMFTransform *iface, DWORD strea
 static HRESULT WINAPI transform_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
         IMFMediaType **type)
 {
-    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    struct audio_decoder *decoder = impl_from_IMFTransform(iface);
     const WAVEFORMATEXTENSIBLE *format = decoder->input_types;
     UINT count = decoder->input_type_count;
 
@@ -237,7 +237,7 @@ static HRESULT WINAPI transform_GetInputAvailableType(IMFTransform *iface, DWORD
 static HRESULT WINAPI transform_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
         IMFMediaType **type)
 {
-    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    struct audio_decoder *decoder = impl_from_IMFTransform(iface);
     UINT32 channel_count, sample_rate;
     WAVEFORMATEXTENSIBLE wfx = {{0}};
     IMFMediaType *media_type;
@@ -252,7 +252,7 @@ static HRESULT WINAPI transform_GetOutputAvailableType(IMFTransform *iface, DWOR
     if (!decoder->input_type)
         return MF_E_TRANSFORM_TYPE_NOT_SET;
 
-    wfx = aac_decoder_output_types[index % ARRAY_SIZE(aac_decoder_output_types)];
+    wfx = audio_decoder_output_types[index % ARRAY_SIZE(audio_decoder_output_types)];
 
     if (FAILED(hr = IMFMediaType_GetUINT32(decoder->input_type, &MF_MT_AUDIO_NUM_CHANNELS, &channel_count))
             || !channel_count)
@@ -263,15 +263,15 @@ static HRESULT WINAPI transform_GetOutputAvailableType(IMFTransform *iface, DWOR
     if (channel_count >= ARRAY_SIZE(default_channel_mask))
         return MF_E_INVALIDMEDIATYPE;
 
-    if (channel_count > 2 && index >= ARRAY_SIZE(aac_decoder_output_types))
+    if (channel_count > 2 && index >= ARRAY_SIZE(audio_decoder_output_types))
     {
         /* If there are more than two channels in the input type GetOutputAvailableType additionally lists
          * types with 2 channels. */
-        index -= ARRAY_SIZE(aac_decoder_output_types);
+        index -= ARRAY_SIZE(audio_decoder_output_types);
         channel_count = 2;
     }
 
-    if (index >= ARRAY_SIZE(aac_decoder_output_types))
+    if (index >= ARRAY_SIZE(audio_decoder_output_types))
         return MF_E_NO_MORE_TYPES;
 
     wfx.Format.nChannels = channel_count;
@@ -314,7 +314,7 @@ static BOOL matches_format(const WAVEFORMATEXTENSIBLE *a, const WAVEFORMATEXTENS
 
 static HRESULT WINAPI transform_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
 {
-    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    struct audio_decoder *decoder = impl_from_IMFTransform(iface);
     UINT32 size, count = decoder->input_type_count;
     WAVEFORMATEXTENSIBLE *format, wfx;
     HRESULT hr;
@@ -375,7 +375,7 @@ static HRESULT WINAPI transform_SetInputType(IMFTransform *iface, DWORD id, IMFM
 
 static HRESULT WINAPI transform_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
 {
-    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    struct audio_decoder *decoder = impl_from_IMFTransform(iface);
     WAVEFORMATEXTENSIBLE *format, wfx;
     UINT32 size;
     HRESULT hr;
@@ -411,10 +411,10 @@ static HRESULT WINAPI transform_SetOutputType(IMFTransform *iface, DWORD id, IMF
     wfx = *format;
     CoTaskMemFree(format);
 
-    for (i = 0; i < ARRAY_SIZE(aac_decoder_output_types); ++i)
-        if (matches_format(&aac_decoder_output_types[i], &wfx))
+    for (i = 0; i < ARRAY_SIZE(audio_decoder_output_types); ++i)
+        if (matches_format(&audio_decoder_output_types[i], &wfx))
             break;
-    if (i == ARRAY_SIZE(aac_decoder_output_types))
+    if (i == ARRAY_SIZE(audio_decoder_output_types))
         return MF_E_INVALIDMEDIATYPE;
 
     if (!wfx.Format.wBitsPerSample || !wfx.Format.nChannels || !wfx.Format.nSamplesPerSec)
@@ -441,7 +441,7 @@ failed:
 
 static HRESULT WINAPI transform_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **out)
 {
-    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    struct audio_decoder *decoder = impl_from_IMFTransform(iface);
     IMFMediaType *type;
     HRESULT hr;
 
@@ -463,7 +463,7 @@ static HRESULT WINAPI transform_GetInputCurrentType(IMFTransform *iface, DWORD i
 
 static HRESULT WINAPI transform_GetOutputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **out)
 {
-    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    struct audio_decoder *decoder = impl_from_IMFTransform(iface);
     IMFMediaType *type;
     HRESULT hr;
 
@@ -485,7 +485,7 @@ static HRESULT WINAPI transform_GetOutputCurrentType(IMFTransform *iface, DWORD
 
 static HRESULT WINAPI transform_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
 {
-    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    struct audio_decoder *decoder = impl_from_IMFTransform(iface);
     bool accepts_input;
 
     TRACE("iface %p, id %#lx, flags %p.\n", iface, id, flags);
@@ -526,7 +526,7 @@ static HRESULT WINAPI transform_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_
 
 static HRESULT WINAPI transform_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
 {
-    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    struct audio_decoder *decoder = impl_from_IMFTransform(iface);
 
     TRACE("iface %p, id %#lx, sample %p, flags %#lx.\n", iface, id, sample, flags);
 
@@ -539,7 +539,7 @@ static HRESULT WINAPI transform_ProcessInput(IMFTransform *iface, DWORD id, IMFS
 static HRESULT WINAPI transform_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
         MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
 {
-    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    struct audio_decoder *decoder = impl_from_IMFTransform(iface);
     MFT_OUTPUT_STREAM_INFO info;
     HRESULT hr;
 
@@ -615,12 +615,12 @@ static HEAACWAVEINFO aac_decoder_input_types[] =
 
 HRESULT aac_decoder_create(REFIID riid, void **ret)
 {
-    struct aac_decoder *decoder;
+    struct audio_decoder *decoder;
     HRESULT hr;
 
     TRACE("riid %s, ret %p.\n", debugstr_guid(riid), ret);
 
-    if (FAILED(hr = check_audio_transform_support(&aac_decoder_input_types[0].wfx, &aac_decoder_output_types[0].Format)))
+    if (FAILED(hr = check_audio_transform_support(&aac_decoder_input_types[0].wfx, &audio_decoder_output_types[0].Format)))
     {
         ERR_(winediag)("GStreamer doesn't support AAC decoding, please install appropriate plugins\n");
         return hr;
-- 
2.49.0


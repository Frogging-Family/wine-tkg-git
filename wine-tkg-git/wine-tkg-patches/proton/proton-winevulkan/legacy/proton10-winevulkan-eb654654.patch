diff --git b/dlls/win32u/d3dkmt.c a/dlls/win32u/d3dkmt.c
index 1e731ded520..85474a00ec1 100644
--- b/dlls/win32u/d3dkmt.c
+++ a/dlls/win32u/d3dkmt.c
@@ -31,117 +31,8 @@
 #include "win32u_private.h"
 #include "ntuser_private.h"
 
-#include <d3d9types.h>
-#include <dxgi.h>
-#include <d3d10.h>
-#include <d3d11.h>
-#include <d3d12.h>
-
 WINE_DEFAULT_DEBUG_CHANNEL(d3dkmt);
 
-/* D3DKMT runtime descriptors */
-
-struct d3dkmt_dxgi_desc
-{
-    UINT                        size;
-    UINT                        version;
-    UINT                        width;
-    UINT                        height;
-    DXGI_FORMAT                 format;
-    UINT                        unknown_0;
-    UINT                        unknown_1;
-    UINT                        keyed_mutex;
-    D3DKMT_HANDLE               mutex_handle;
-    D3DKMT_HANDLE               sync_handle;
-    UINT                        nt_shared;
-    UINT                        unknown_2;
-    UINT                        unknown_3;
-    UINT                        unknown_4;
-};
-
-struct d3dkmt_d3d9_desc
-{
-    struct d3dkmt_dxgi_desc     dxgi;
-    D3DFORMAT                   format;
-    D3DRESOURCETYPE             type;
-    UINT                        usage;
-    union
-    {
-        struct
-        {
-            UINT                unknown_0;
-            UINT                width;
-            UINT                height;
-            UINT                levels;
-            UINT                depth;
-        } texture;
-        struct
-        {
-            UINT                unknown_0;
-            UINT                unknown_1;
-            UINT                unknown_2;
-            UINT                width;
-            UINT                height;
-        } surface;
-        struct
-        {
-            UINT                unknown_0;
-            UINT                width;
-            UINT                format;
-            UINT                unknown_1;
-            UINT                unknown_2;
-        } buffer;
-    };
-};
-
-C_ASSERT( sizeof(struct d3dkmt_d3d9_desc) == 0x58 );
-
-struct d3dkmt_d3d11_desc
-{
-    struct d3dkmt_dxgi_desc     dxgi;
-    D3D11_RESOURCE_DIMENSION    dimension;
-    union
-    {
-        D3D10_BUFFER_DESC       d3d10_buf;
-        D3D10_TEXTURE1D_DESC    d3d10_1d;
-        D3D10_TEXTURE2D_DESC    d3d10_2d;
-        D3D10_TEXTURE3D_DESC    d3d10_3d;
-        D3D11_BUFFER_DESC       d3d11_buf;
-        D3D11_TEXTURE1D_DESC    d3d11_1d;
-        D3D11_TEXTURE2D_DESC    d3d11_2d;
-        D3D11_TEXTURE3D_DESC    d3d11_3d;
-    };
-};
-
-C_ASSERT( sizeof(struct d3dkmt_d3d11_desc) == 0x68 );
-
-struct d3dkmt_d3d12_desc
-{
-    struct d3dkmt_d3d11_desc    d3d11;
-    UINT                        unknown_5[4];
-    UINT                        resource_size;
-    UINT                        unknown_6[7];
-    UINT                        resource_align;
-    UINT                        unknown_7[9];
-    union
-    {
-        D3D12_RESOURCE_DESC     desc;
-        D3D12_RESOURCE_DESC1    desc1;
-    };
-    UINT64                      unknown_8[1];
-};
-
-C_ASSERT( sizeof(struct d3dkmt_d3d12_desc) == 0x108 );
-C_ASSERT( offsetof(struct d3dkmt_d3d12_desc, unknown_5) == sizeof(struct d3dkmt_d3d11_desc) );
-
-union d3dkmt_desc
-{
-    struct d3dkmt_dxgi_desc     dxgi;
-    struct d3dkmt_d3d9_desc     d3d9;
-    struct d3dkmt_d3d11_desc    d3d11;
-    struct d3dkmt_d3d12_desc    d3d12;
-};
-
 struct d3dkmt_object
 {
     enum d3dkmt_type    type;           /* object type */
@@ -1522,7 +1413,7 @@ NTSTATUS WINAPI NtGdiDdDDICreateKeyedMutex( D3DKMT_CREATEKEYEDMUTEX *params )
     return status;
 }
 
-NTSTATUS d3dkmt_destroy_mutex( D3DKMT_HANDLE local )
+static NTSTATUS d3dkmt_destroy_mutex( D3DKMT_HANDLE local )
 {
     struct d3dkmt_mutex *mutex;
     BOOL owned;
@@ -1912,21 +1803,15 @@ failed:
  */
 NTSTATUS WINAPI NtGdiDdDDIDestroySynchronizationObject( const D3DKMT_DESTROYSYNCHRONIZATIONOBJECT *params )
 {
+    struct d3dkmt_object *sync;
+
     TRACE( "params %p\n", params );
 
-    return d3dkmt_destroy_sync( params->hSyncObject );
-}
+    if (!(sync = get_d3dkmt_object( params->hSyncObject, D3DKMT_SYNC )))
+        return STATUS_INVALID_PARAMETER;
+    d3dkmt_object_free( sync );
 
-static void get_resource_global_keyed_mutex( struct d3dkmt_dxgi_desc *desc, D3DKMT_HANDLE *mutex_global, D3DKMT_HANDLE *sync_global )
-{
-    if ((desc->size != sizeof(struct d3dkmt_d3d9_desc) && desc->size != sizeof(struct d3dkmt_d3d11_desc)) ||
-        (desc->version != 0 && desc->version != 1 && desc->version != 4))
-        WARN( "Unsupported runtime data size %#x version %#x\n", desc->size, desc->version );
-    else if (desc->keyed_mutex && !desc->nt_shared)
-    {
-        *mutex_global = desc->mutex_handle;
-        *sync_global = desc->sync_handle;
-    }
+    return STATUS_SUCCESS;
 }
 
 /* get a locally opened D3DKMT object host-specific fd */
@@ -1975,55 +1860,28 @@ failed:
 }
 
 /* open a D3DKMT global or shared resource */
-D3DKMT_HANDLE d3dkmt_open_resource( D3DKMT_HANDLE global, HANDLE shared, D3DKMT_HANDLE *mutex_local, D3DKMT_HANDLE *sync_local )
+D3DKMT_HANDLE d3dkmt_open_resource( D3DKMT_HANDLE global, HANDLE shared )
 {
-    struct d3dkmt_object *allocation = NULL, *mutex = NULL, *sync = NULL;
-    UINT runtime_size, mutex_size = 0, sync_size = 0;
-    D3DKMT_HANDLE mutex_global = 0, sync_global = 0;
+    struct d3dkmt_object *allocation = NULL;
     struct d3dkmt_resource *resource = NULL;
-    void *runtime_data = NULL;
     NTSTATUS status;
+    UINT dummy = 0;
 
     TRACE( "global %#x, shared %p\n", global, shared );
 
-    if ((status = d3dkmt_object_query( D3DKMT_RESOURCE, global, shared, &runtime_size ))) goto failed;
-    if (runtime_size && !(runtime_data = malloc( runtime_size ))) goto failed;
-
-    if ((status = d3dkmt_object_alloc( sizeof(*sync), D3DKMT_SYNC, (void **)&sync ))) goto failed;
-    if ((status = d3dkmt_object_alloc( sizeof(*mutex), D3DKMT_MUTEX, (void **)&mutex ))) goto failed;
     if ((status = d3dkmt_object_alloc( sizeof(*resource), D3DKMT_RESOURCE, (void **)&resource ))) goto failed;
     if ((status = d3dkmt_object_alloc( sizeof(*allocation), D3DKMT_ALLOCATION, (void **)&allocation ))) goto failed;
-    if ((status = d3dkmt_object_open( &resource->obj, global, shared, runtime_data, &runtime_size ))) goto failed;
+    if ((status = d3dkmt_object_open( &resource->obj, global, shared, NULL, &dummy ))) goto failed;
 
     if ((status = alloc_object_handle( allocation ))) goto failed;
     resource->allocation = allocation->local;
 
-    if (!runtime_data || runtime_size <= sizeof(struct d3dkmt_dxgi_desc)) WARN( "Unsupported runtime data size %#x\n", runtime_size );
-    else get_resource_global_keyed_mutex( runtime_data, &mutex_global, &sync_global );
-
-    if (!d3dkmt_object_open( mutex, mutex_global, shared, NULL, &mutex_size ) &&
-        !d3dkmt_object_open( sync, sync_global, shared, NULL, &sync_size ))
-    {
-        *mutex_local = mutex->local;
-        *sync_local = sync->local;
-    }
-    else
-    {
-        d3dkmt_object_free( mutex );
-        d3dkmt_object_free( sync );
-        *mutex_local = *sync_local = 0;
-    }
-
-    free( runtime_data );
     return resource->obj.local;
 
 failed:
     WARN( "Failed to open resource, status %#x\n", status );
     if (allocation) d3dkmt_object_free( allocation );
     if (resource) d3dkmt_object_free( &resource->obj );
-    if (mutex) d3dkmt_object_free( mutex );
-    if (sync) d3dkmt_object_free( sync );
-    free( runtime_data );
     return 0;
 }
 
@@ -2036,7 +1894,7 @@ NTSTATUS d3dkmt_destroy_resource( D3DKMT_HANDLE local )
     TRACE( "local %#x\n", local );
 
     if (!(resource = get_d3dkmt_object( local, D3DKMT_RESOURCE ))) return STATUS_INVALID_PARAMETER;
-    if ((allocation = get_d3dkmt_object( resource->allocation, D3DKMT_ALLOCATION ))) d3dkmt_object_free( allocation );
+    if ((allocation = get_d3dkmt_object( resource->allocation, D3DKMT_RESOURCE ))) d3dkmt_object_free( allocation );
     d3dkmt_object_free( &resource->obj );
 
     return STATUS_SUCCESS;
diff --git b/dlls/win32u/vulkan.c a/dlls/win32u/vulkan.c
index c075fad1c37..017b84df8c3 100644
--- b/dlls/win32u/vulkan.c
+++ a/dlls/win32u/vulkan.c
@@ -68,9 +68,6 @@ struct device_memory
     D3DKMT_HANDLE local;
     D3DKMT_HANDLE global;
     HANDLE shared;
-
-    D3DKMT_HANDLE sync;
-    D3DKMT_HANDLE mutex;
 };
 
 static inline struct device_memory *device_memory_from_handle( VkDeviceMemory handle )
@@ -282,8 +279,8 @@ static VkResult win32u_vkAllocateMemory( VkDevice client_device, const VkMemoryA
     VkImportMemoryHostPointerInfoEXT host_pointer_info, *pointer_info = NULL;
     VkExportMemoryWin32HandleInfoKHR export_win32 = {.dwAccess = GENERIC_ALL};
     VkImportMemoryWin32HandleInfoKHR *import_win32 = NULL;
-    VkDeviceMemory host_device_memory = VK_NULL_HANDLE;
     VkExportMemoryAllocateInfo *export_info = NULL;
+    VkDeviceMemory host_device_memory;
     struct device_memory *memory;
     BOOL nt_shared = FALSE;
     uint32_t mem_flags;
@@ -341,7 +338,7 @@ static VkResult win32u_vkAllocateMemory( VkDevice client_device, const VkMemoryA
         case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
         case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT:
             memory->global = PtrToUlong( import_win32->handle );
-            memory->local = d3dkmt_open_resource( memory->global, NULL, &memory->mutex, &memory->sync );
+            memory->local = d3dkmt_open_resource( memory->global, NULL );
             break;
         case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT:
         case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT:
@@ -350,7 +347,7 @@ static VkResult win32u_vkAllocateMemory( VkDevice client_device, const VkMemoryA
         {
             HANDLE shared = import_win32->handle;
             if (import_win32->name && !(shared = open_shared_resource_from_name( import_win32->name ))) break;
-            memory->local = d3dkmt_open_resource( 0, shared, &memory->mutex, &memory->sync );
+            memory->local = d3dkmt_open_resource( 0, shared );
             if (shared && shared != import_win32->handle) NtClose( shared );
             break;
         }
@@ -361,8 +358,8 @@ static VkResult win32u_vkAllocateMemory( VkDevice client_device, const VkMemoryA
 
         if ((fd_info.fd = d3dkmt_object_get_fd( memory->local )) < 0)
         {
-            res = VK_ERROR_INVALID_EXTERNAL_HANDLE;
-            goto failed;
+            free( memory );
+            return VK_ERROR_INVALID_EXTERNAL_HANDLE;
         }
 
         fd_info.handleType = get_host_external_memory_type();
@@ -370,7 +367,12 @@ static VkResult win32u_vkAllocateMemory( VkDevice client_device, const VkMemoryA
         alloc_info->pNext = &fd_info;
     }
 
-    if ((res = device->p_vkAllocateMemory( device->host.device, alloc_info, NULL, &host_device_memory ))) goto failed;
+    if ((res = device->p_vkAllocateMemory( device->host.device, alloc_info, NULL, &host_device_memory )))
+    {
+        if (memory->local) d3dkmt_destroy_resource( memory->local );
+        free( memory );
+        return res;
+    }
 
     if (export_info)
     {
@@ -408,10 +410,8 @@ static VkResult win32u_vkAllocateMemory( VkDevice client_device, const VkMemoryA
 
 failed:
     WARN( "Failed to allocate memory, res %d\n", res );
-    if (host_device_memory) device->p_vkFreeMemory( device->host.device, host_device_memory, NULL );
-    d3dkmt_destroy_resource( memory->local );
-    d3dkmt_destroy_mutex( memory->mutex );
-    d3dkmt_destroy_sync( memory->sync );
+    device->p_vkFreeMemory( device->host.device, host_device_memory, NULL );
+    if (memory->local) d3dkmt_destroy_resource( memory->local );
     free( memory );
     return VK_ERROR_OUT_OF_HOST_MEMORY;
 }
@@ -447,9 +447,7 @@ static void win32u_vkFreeMemory( VkDevice client_device, VkDeviceMemory client_m
     }
 
     if (memory->shared) NtClose( memory->shared );
-    d3dkmt_destroy_resource( memory->local );
-    d3dkmt_destroy_mutex( memory->mutex );
-    d3dkmt_destroy_sync( memory->sync );
+    if (memory->local) d3dkmt_destroy_resource( memory->local );
     free( memory );
 }
 
@@ -1569,7 +1567,7 @@ static VkResult win32u_vkCreateSemaphore( VkDevice client_device, const VkSemaph
 failed:
     WARN( "Failed to create semaphore, res %d\n", res );
     device->p_vkDestroySemaphore( device->host.device, host_semaphore, NULL );
-    d3dkmt_destroy_sync( semaphore->local );
+    if (semaphore->local) d3dkmt_destroy_sync( semaphore->local );
     free( semaphore );
     return VK_ERROR_OUT_OF_HOST_MEMORY;
 }
@@ -1588,7 +1586,7 @@ static void win32u_vkDestroySemaphore( VkDevice client_device, VkSemaphore clien
     instance->p_remove_object( instance, &semaphore->obj.obj );
 
     if (semaphore->shared) NtClose( semaphore->shared );
-    d3dkmt_destroy_sync( semaphore->local );
+    if (semaphore->local) d3dkmt_destroy_sync( semaphore->local );
     free( semaphore );
 }
 
@@ -1672,7 +1670,7 @@ static VkResult win32u_vkImportSemaphoreWin32HandleKHR( VkDevice client_device,
     else
     {
         if (semaphore->shared) NtClose( semaphore->shared );
-        d3dkmt_destroy_sync( semaphore->local );
+        if (semaphore->local) d3dkmt_destroy_sync( semaphore->local );
         semaphore->shared = shared;
         semaphore->global = global;
         semaphore->local = local;
@@ -1777,7 +1775,7 @@ static VkResult win32u_vkCreateFence( VkDevice client_device, const VkFenceCreat
 failed:
     WARN( "Failed to create fence, res %d\n", res );
     device->p_vkDestroyFence( device->host.device, host_fence, NULL );
-    d3dkmt_destroy_sync( fence->local );
+    if (fence->local) d3dkmt_destroy_sync( fence->local );
     free( fence );
     return VK_ERROR_OUT_OF_HOST_MEMORY;
 }
@@ -1796,7 +1794,7 @@ static void win32u_vkDestroyFence( VkDevice client_device, VkFence client_fence,
     instance->p_remove_object( instance, &fence->obj.obj );
 
     if (fence->shared) NtClose( fence->shared );
-    d3dkmt_destroy_sync( fence->local );
+    if (fence->local) d3dkmt_destroy_sync( fence->local );
     free( fence );
 }
 
diff --git b/dlls/win32u/win32u_private.h a/dlls/win32u/win32u_private.h
index ba0a9834d9f..7bca9db4226 100644
--- b/dlls/win32u/win32u_private.h
+++ a/dlls/win32u/win32u_private.h
@@ -207,10 +207,9 @@ extern BOOL get_vulkan_uuid_from_luid( const LUID *luid, GUID *uuid );
 extern BOOL get_luid_from_vulkan_uuid( const GUID *uuid, LUID *luid, UINT32 *node_mask );
 
 extern int d3dkmt_object_get_fd( D3DKMT_HANDLE local );
-extern NTSTATUS d3dkmt_destroy_mutex( D3DKMT_HANDLE local );
 
 extern D3DKMT_HANDLE d3dkmt_create_resource( int fd, D3DKMT_HANDLE *global );
-extern D3DKMT_HANDLE d3dkmt_open_resource( D3DKMT_HANDLE global, HANDLE shared, D3DKMT_HANDLE *mutex_local, D3DKMT_HANDLE *sync_local );
+extern D3DKMT_HANDLE d3dkmt_open_resource( D3DKMT_HANDLE global, HANDLE shared );
 extern NTSTATUS d3dkmt_destroy_resource( D3DKMT_HANDLE local );
 
 extern D3DKMT_HANDLE d3dkmt_create_sync( int fd, D3DKMT_HANDLE *global );

diff --git b/dlls/win32u/d3dkmt.c a/dlls/win32u/d3dkmt.c
index 85474a00ec1..c54145f6090 100644
--- b/dlls/win32u/d3dkmt.c
+++ a/dlls/win32u/d3dkmt.c
@@ -42,12 +42,6 @@ struct d3dkmt_object
     HANDLE              handle;         /* internal handle of the server object */
 };
 
-struct d3dkmt_mutex
-{
-    struct d3dkmt_object obj;
-    BOOL owned;
-};
-
 struct d3dkmt_resource
 {
     struct d3dkmt_object obj;
@@ -186,8 +180,7 @@ static NTSTATUS d3dkmt_object_alloc( UINT size, enum d3dkmt_type type, void **ob
 }
 
 /* create a global D3DKMT object, either with a global handle or later shareable */
-static NTSTATUS d3dkmt_object_create( struct d3dkmt_object *object, int fd, UINT value, BOOL shared,
-                                      const void *runtime, UINT runtime_size )
+static NTSTATUS d3dkmt_object_create( struct d3dkmt_object *object, int fd, BOOL shared, const void *runtime, UINT runtime_size )
 {
     NTSTATUS status;
 
@@ -197,7 +190,6 @@ static NTSTATUS d3dkmt_object_create( struct d3dkmt_object *object, int fd, UINT
     {
         req->type = object->type;
         req->fd = fd;
-        req->value = value;
         if (runtime_size) wine_server_add_data( req, runtime, runtime_size );
         status = wine_server_call( req );
         object->handle = wine_server_ptr_handle( reply->handle );
@@ -1061,7 +1053,7 @@ NTSTATUS WINAPI NtGdiDdDDICreateAllocation2( D3DKMT_CREATEALLOCATION *params )
         if ((status = d3dkmt_object_alloc( sizeof(*allocation), D3DKMT_ALLOCATION, (void **)&allocation ))) goto failed;
 
         if (!params->Flags.CreateShared) status = alloc_object_handle( &resource->obj );
-        else status = d3dkmt_object_create( &resource->obj, -1, 0, params->Flags.NtSecuritySharing,
+        else status = d3dkmt_object_create( &resource->obj, -1, params->Flags.NtSecuritySharing,
                                             params->pPrivateRuntimeData, params->PrivateRuntimeDataSize );
         if (status) goto failed;
 
@@ -1245,8 +1237,7 @@ failed:
  */
 NTSTATUS WINAPI NtGdiDdDDIOpenResourceFromNtHandle( D3DKMT_OPENRESOURCEFROMNTHANDLE *params )
 {
-    struct d3dkmt_object *sync = NULL;
-    struct d3dkmt_mutex *mutex = NULL;
+    struct d3dkmt_object *mutex = NULL, *sync = NULL;
     struct d3dkmt_resource *resource = NULL;
     NTSTATUS status;
     UINT dummy = 0;
@@ -1267,9 +1258,9 @@ NTSTATUS WINAPI NtGdiDdDDIOpenResourceFromNtHandle( D3DKMT_OPENRESOURCEFROMNTHAN
                                       &params->PrivateRuntimeDataSize )))
         goto failed;
 
-    if (d3dkmt_object_open( &mutex->obj, 0, params->hNtHandle, params->pKeyedMutexPrivateRuntimeData, &params->KeyedMutexPrivateRuntimeDataSize ))
+    if (d3dkmt_object_open( mutex, 0, params->hNtHandle, params->pKeyedMutexPrivateRuntimeData, &params->KeyedMutexPrivateRuntimeDataSize ))
     {
-        d3dkmt_object_free( &mutex->obj );
+        d3dkmt_object_free( mutex );
         mutex = NULL;
     }
 
@@ -1280,7 +1271,7 @@ NTSTATUS WINAPI NtGdiDdDDIOpenResourceFromNtHandle( D3DKMT_OPENRESOURCEFROMNTHAN
     }
 
     params->hResource = resource->obj.local;
-    params->hKeyedMutex = mutex ? mutex->obj.local : 0;
+    params->hKeyedMutex = mutex ? mutex->local : 0;
     params->hSyncObject = sync ? sync->local : 0;
     params->TotalPrivateDriverDataBufferSize = 0;
     params->ResourcePrivateDriverDataSize = 0;
@@ -1288,7 +1279,7 @@ NTSTATUS WINAPI NtGdiDdDDIOpenResourceFromNtHandle( D3DKMT_OPENRESOURCEFROMNTHAN
 
 failed:
     if (sync) d3dkmt_object_free( sync );
-    if (mutex) d3dkmt_object_free( &mutex->obj );
+    if (mutex) d3dkmt_object_free( mutex );
     if (resource) d3dkmt_object_free( &resource->obj );
     return status;
 }
@@ -1373,7 +1364,7 @@ NTSTATUS WINAPI NtGdiDdDDIQueryResourceInfoFromNtHandle( D3DKMT_QUERYRESOURCEINF
  */
 NTSTATUS WINAPI NtGdiDdDDICreateKeyedMutex2( D3DKMT_CREATEKEYEDMUTEX2 *params )
 {
-    struct d3dkmt_mutex *mutex;
+    struct d3dkmt_object *mutex;
     NTSTATUS status;
 
     FIXME( "params %p semi-stub!\n", params );
@@ -1381,16 +1372,16 @@ NTSTATUS WINAPI NtGdiDdDDICreateKeyedMutex2( D3DKMT_CREATEKEYEDMUTEX2 *params )
     if (!params) return STATUS_INVALID_PARAMETER;
 
     if ((status = d3dkmt_object_alloc( sizeof(*mutex), D3DKMT_MUTEX, (void **)&mutex ))) return status;
-    if ((status = d3dkmt_object_create( &mutex->obj, -1, params->InitialValue, params->Flags.NtSecuritySharing,
+    if ((status = d3dkmt_object_create( mutex, -1, params->Flags.NtSecuritySharing,
                                         params->pPrivateRuntimeData, params->PrivateRuntimeDataSize )))
         goto failed;
 
-    params->hSharedHandle = mutex->obj.shared ? 0 : mutex->obj.global;
-    params->hKeyedMutex = mutex->obj.local;
+    params->hSharedHandle = mutex->shared ? 0 : mutex->global;
+    params->hKeyedMutex = mutex->local;
     return STATUS_SUCCESS;
 
 failed:
-    d3dkmt_object_free( &mutex->obj );
+    d3dkmt_object_free( mutex );
     return status;
 }
 
@@ -1413,42 +1404,20 @@ NTSTATUS WINAPI NtGdiDdDDICreateKeyedMutex( D3DKMT_CREATEKEYEDMUTEX *params )
     return status;
 }
 
-static NTSTATUS d3dkmt_destroy_mutex( D3DKMT_HANDLE local )
-{
-    struct d3dkmt_mutex *mutex;
-    BOOL owned;
-
-    TRACE( "local %#x\n", local );
-
-    if (!(mutex = get_d3dkmt_object( local, D3DKMT_MUTEX ))) return STATUS_INVALID_PARAMETER;
-
-    pthread_mutex_lock( &d3dkmt_lock );
-    owned = mutex->owned;
-    pthread_mutex_unlock( &d3dkmt_lock );
-
-    if (owned)
-    {
-        SERVER_START_REQ( d3dkmt_mutex_release )
-        {
-            req->mutex = mutex->obj.global;
-            req->abandon = 1;
-            wine_server_call( req );
-        }
-        SERVER_END_REQ;
-    }
-
-    d3dkmt_object_free( &mutex->obj );
-    return STATUS_SUCCESS;
-}
-
 /******************************************************************************
  *           NtGdiDdDDIDestroyKeyedMutex    (win32u.@)
  */
 NTSTATUS WINAPI NtGdiDdDDIDestroyKeyedMutex( const D3DKMT_DESTROYKEYEDMUTEX *params )
 {
+    struct d3dkmt_object *mutex;
+
     TRACE( "params %p\n", params );
 
-    return d3dkmt_destroy_mutex( params->hKeyedMutex );
+    if (!(mutex = get_d3dkmt_object( params->hKeyedMutex, D3DKMT_MUTEX )))
+        return STATUS_INVALID_PARAMETER;
+    d3dkmt_object_free( mutex );
+
+    return STATUS_SUCCESS;
 }
 
 /******************************************************************************
@@ -1456,7 +1425,7 @@ NTSTATUS WINAPI NtGdiDdDDIDestroyKeyedMutex( const D3DKMT_DESTROYKEYEDMUTEX *par
  */
 NTSTATUS WINAPI NtGdiDdDDIOpenKeyedMutex2( D3DKMT_OPENKEYEDMUTEX2 *params )
 {
-    struct d3dkmt_mutex *mutex;
+    struct d3dkmt_object *mutex;
     UINT runtime_size;
     NTSTATUS status;
 
@@ -1469,13 +1438,13 @@ NTSTATUS WINAPI NtGdiDdDDIOpenKeyedMutex2( D3DKMT_OPENKEYEDMUTEX2 *params )
     if ((status = d3dkmt_object_alloc( sizeof(*mutex), D3DKMT_MUTEX, (void **)&mutex ))) return status;
 
     runtime_size = params->PrivateRuntimeDataSize;
-    if ((status = d3dkmt_object_open( &mutex->obj, params->hSharedHandle, NULL, params->pPrivateRuntimeData, &runtime_size ))) goto failed;
+    if ((status = d3dkmt_object_open( mutex, params->hSharedHandle, NULL, params->pPrivateRuntimeData, &runtime_size ))) goto failed;
 
-    params->hKeyedMutex = mutex->obj.local;
+    params->hKeyedMutex = mutex->local;
     return STATUS_SUCCESS;
 
 failed:
-    d3dkmt_object_free( &mutex->obj );
+    d3dkmt_object_free( mutex );
     return status;
 }
 
@@ -1502,21 +1471,21 @@ NTSTATUS WINAPI NtGdiDdDDIOpenKeyedMutex( D3DKMT_OPENKEYEDMUTEX *params )
  */
 NTSTATUS WINAPI NtGdiDdDDIOpenKeyedMutexFromNtHandle( D3DKMT_OPENKEYEDMUTEXFROMNTHANDLE *params )
 {
-    struct d3dkmt_mutex *mutex;
+    struct d3dkmt_object *mutex;
     NTSTATUS status;
 
     FIXME( "params %p semi-stub!\n", params );
 
     if ((status = d3dkmt_object_alloc( sizeof(*mutex), D3DKMT_MUTEX, (void **)&mutex ))) return status;
-    if ((status = d3dkmt_object_open( &mutex->obj, 0, params->hNtHandle, params->pPrivateRuntimeData,
+    if ((status = d3dkmt_object_open( mutex, 0, params->hNtHandle, params->pPrivateRuntimeData,
                                       &params->PrivateRuntimeDataSize )))
         goto failed;
 
-    params->hKeyedMutex = mutex->obj.local;
+    params->hKeyedMutex = mutex->local;
     return STATUS_SUCCESS;
 
 failed:
-    d3dkmt_object_free( &mutex->obj );
+    d3dkmt_object_free( mutex );
     return status;
 }
 
@@ -1525,46 +1494,8 @@ failed:
  */
 NTSTATUS WINAPI NtGdiDdDDIAcquireKeyedMutex2( D3DKMT_ACQUIREKEYEDMUTEX2 *params )
 {
-    NTSTATUS status = STATUS_SUCCESS;
-    LARGE_INTEGER now, *timeout;
-    struct d3dkmt_mutex *mutex;
-    HANDLE wait_handle = NULL;
-
-    TRACE( "params %p\n", params );
-
-    if ((timeout = params->pTimeout) && timeout->QuadPart < 0)
-    {
-        NtQuerySystemTime( &now );
-        now.QuadPart -= timeout->QuadPart;
-        timeout = &now;
-    }
-
-    if (!(mutex = get_d3dkmt_object( params->hKeyedMutex, D3DKMT_MUTEX ))) return STATUS_INVALID_PARAMETER;
-
-    do
-    {
-        if (wait_handle) status = NtWaitForSingleObject( wait_handle, FALSE, timeout );
-        SERVER_START_REQ( d3dkmt_mutex_acquire )
-        {
-            req->mutex = mutex->obj.global;
-            req->key_value = params->Key;
-            req->wait_handle = wine_server_obj_handle( wait_handle );
-            req->wait_status = status;
-
-            status = wine_server_call( req );
-            params->FenceValue = reply->fence_value;
-            wait_handle = wine_server_ptr_handle( reply->wait_handle );
-        }
-        SERVER_END_REQ;
-    } while (status == STATUS_PENDING);
-
-    if (!status)
-    {
-        pthread_mutex_lock( &d3dkmt_lock );
-        mutex->owned = TRUE;
-        pthread_mutex_unlock( &d3dkmt_lock );
-    }
-    return status;
+    FIXME( "params %p stub!\n", params );
+    return STATUS_NOT_IMPLEMENTED;
 }
 
 /******************************************************************************
@@ -1593,30 +1524,8 @@ NTSTATUS WINAPI NtGdiDdDDIAcquireKeyedMutex( D3DKMT_ACQUIREKEYEDMUTEX *params )
  */
 NTSTATUS WINAPI NtGdiDdDDIReleaseKeyedMutex2( D3DKMT_RELEASEKEYEDMUTEX2 *params )
 {
-    struct d3dkmt_mutex *mutex;
-    NTSTATUS status;
-
-    TRACE( "params %p\n", params );
-
-    if (!(mutex = get_d3dkmt_object( params->hKeyedMutex, D3DKMT_MUTEX ))) return STATUS_INVALID_PARAMETER;
-
-    SERVER_START_REQ( d3dkmt_mutex_release )
-    {
-        req->mutex = mutex->obj.global;
-        req->key_value = params->Key;
-        req->fence_value = params->FenceValue;
-        status = wine_server_call( req );
-    }
-    SERVER_END_REQ;
-
-    if (!status)
-    {
-        pthread_mutex_lock( &d3dkmt_lock );
-        mutex->owned = FALSE;
-        pthread_mutex_unlock( &d3dkmt_lock );
-    }
-
-    return status;
+    FIXME( "params %p stub!\n", params );
+    return STATUS_NOT_IMPLEMENTED;
 }
 
 /******************************************************************************
@@ -1657,7 +1566,7 @@ NTSTATUS WINAPI NtGdiDdDDICreateSynchronizationObject2( D3DKMT_CREATESYNCHRONIZA
 
     if ((status = d3dkmt_object_alloc( sizeof(*sync), D3DKMT_SYNC, (void **)&sync ))) return status;
     if (!params->Info.Flags.Shared) status = alloc_object_handle( sync );
-    else status = d3dkmt_object_create( sync, -1, 0, params->Info.Flags.NtSecuritySharing, NULL, 0 );
+    else status = d3dkmt_object_create( sync, -1, params->Info.Flags.NtSecuritySharing, NULL, 0 );
     if (status) goto failed;
 
     if (params->Info.Flags.Shared) params->Info.SharedHandle = sync->shared ? 0 : sync->global;
@@ -1844,7 +1753,7 @@ D3DKMT_HANDLE d3dkmt_create_resource( int fd, D3DKMT_HANDLE *global )
 
     if ((status = d3dkmt_object_alloc( sizeof(*resource), D3DKMT_RESOURCE, (void **)&resource ))) goto failed;
     if ((status = d3dkmt_object_alloc( sizeof(*allocation), D3DKMT_ALLOCATION, (void **)&allocation ))) goto failed;
-    if ((status = d3dkmt_object_create( &resource->obj, fd, 0, !global, NULL, 0 ))) goto failed;
+    if ((status = d3dkmt_object_create( &resource->obj, fd, !global, NULL, 0 ))) goto failed;
 
     if ((status = alloc_object_handle( allocation ))) goto failed;
     resource->allocation = allocation->local;
@@ -1909,7 +1818,7 @@ D3DKMT_HANDLE d3dkmt_create_sync( int fd, D3DKMT_HANDLE *global )
     TRACE( "global %p\n", global );
 
     if ((status = d3dkmt_object_alloc( sizeof(*sync), D3DKMT_SYNC, (void **)&sync ))) goto failed;
-    if ((status = d3dkmt_object_create( sync, fd, 0, !global, NULL, 0 ))) goto failed;
+    if ((status = d3dkmt_object_create( sync, fd, !global, NULL, 0 ))) goto failed;
     if (global) *global = sync->global;
     return sync->local;
 
diff --git b/dlls/win32u/tests/d3dkmt.c a/dlls/win32u/tests/d3dkmt.c
index b3a9baf4785..4c9e6e5704d 100644
--- b/dlls/win32u/tests/d3dkmt.c
+++ a/dlls/win32u/tests/d3dkmt.c
@@ -2074,7 +2074,7 @@ static void test_D3DKMTCreateKeyedMutex( void )
 static DWORD WINAPI test_acquire_mutex( void *arg )
 {
     NTSTATUS status = D3DKMTAcquireKeyedMutex( arg );
-    ok_nt( STATUS_ABANDONED, status );
+    todo_wine ok_nt( STATUS_ABANDONED, status );
     return 0;
 }
 
@@ -2104,7 +2104,7 @@ static void test_D3DKMTAcquireKeyedMutex( void )
     acquire.pTimeout = &timeout;
     acquire.FenceValue = 0xdeadbeef;
     status = D3DKMTAcquireKeyedMutex( &acquire );
-    ok_nt( STATUS_INVALID_PARAMETER, status );
+    todo_wine ok_nt( STATUS_INVALID_PARAMETER, status );
     ok_x4( acquire.Key, ==, 0xdeadbeef );
     ok_x8( acquire.FenceValue, ==, 0xdeadbeef );
 
@@ -2112,17 +2112,17 @@ static void test_D3DKMTAcquireKeyedMutex( void )
     acquire.Key = 0xdeadbeef;
     acquire.FenceValue = 0xdeadbeef;
     status = D3DKMTAcquireKeyedMutex( &acquire );
-    ok_nt( STATUS_TIMEOUT, status );
+    todo_wine ok_nt( STATUS_TIMEOUT, status );
     ok_x4( acquire.Key, ==, 0xdeadbeef );
-    ok_x8( acquire.FenceValue, ==, 0 );
+    todo_wine ok_x8( acquire.FenceValue, ==, 0 );
 
     acquire.hKeyedMutex = create.hKeyedMutex;
     acquire.Key = 0;
     acquire.FenceValue = 0xdeadbeef;
     status = D3DKMTAcquireKeyedMutex( &acquire );
-    ok_nt( STATUS_SUCCESS, status );
+    todo_wine ok_nt( STATUS_SUCCESS, status );
     ok_x4( acquire.Key, ==, 0 );
-    ok_x8( acquire.FenceValue, ==, 0 );
+    todo_wine ok_x8( acquire.FenceValue, ==, 0 );
 
     status = D3DKMTReleaseKeyedMutex( NULL );
     ok_nt( STATUS_INVALID_PARAMETER, status );
@@ -2130,42 +2130,42 @@ static void test_D3DKMTAcquireKeyedMutex( void )
     release.Key = 0xdeadbeef;
     release.FenceValue = 0xdeadbeef;
     status = D3DKMTReleaseKeyedMutex( &release );
-    ok_nt( STATUS_INVALID_PARAMETER, status );
+    todo_wine ok_nt( STATUS_INVALID_PARAMETER, status );
     ok_x4( release.Key, ==, 0xdeadbeef );
     ok_x8( release.FenceValue, ==, 0xdeadbeef );
     release.hKeyedMutex = create.hKeyedMutex;
     release.Key = 1;
     release.FenceValue = 1234;
     status = D3DKMTReleaseKeyedMutex( &release );
-    ok_nt( STATUS_SUCCESS, status );
+    todo_wine ok_nt( STATUS_SUCCESS, status );
     ok_x4( release.Key, ==, 1 );
     ok_x8( release.FenceValue, ==, 1234 );
     release.FenceValue = 0xdeadbeef;
     status = D3DKMTReleaseKeyedMutex( &release );
-    ok_nt( STATUS_INVALID_PARAMETER, status );
+    todo_wine ok_nt( STATUS_INVALID_PARAMETER, status );
     ok_x4( release.Key, ==, 1 );
     ok_x8( release.FenceValue, ==, 0xdeadbeef );
 
     acquire.Key = 0;
     acquire.FenceValue = 0xdeadbeef;
     status = D3DKMTAcquireKeyedMutex( &acquire );
-    ok_nt( STATUS_TIMEOUT, status );
-    ok_x8( acquire.FenceValue, ==, 0 );
+    todo_wine ok_nt( STATUS_TIMEOUT, status );
+    todo_wine ok_x8( acquire.FenceValue, ==, 0 );
     acquire.Key = 1;
     acquire.FenceValue = 0xdeadbeef;
     status = D3DKMTAcquireKeyedMutex( &acquire );
-    ok_nt( STATUS_SUCCESS, status );
-    ok_x8( acquire.FenceValue, ==, 1234 );
+    todo_wine ok_nt( STATUS_SUCCESS, status );
+    todo_wine ok_x8( acquire.FenceValue, ==, 1234 );
 
     release.Key = 0;
     release.FenceValue = 0;
     status = D3DKMTReleaseKeyedMutex( &release );
-    ok_nt( STATUS_SUCCESS, status );
+    todo_wine ok_nt( STATUS_SUCCESS, status );
     acquire.Key = 0;
     acquire.FenceValue = 0xdeadbeef;
     status = D3DKMTAcquireKeyedMutex( &acquire );
-    ok_nt( STATUS_SUCCESS, status );
-    ok_x8( acquire.FenceValue, ==, 0 );
+    todo_wine ok_nt( STATUS_SUCCESS, status );
+    todo_wine ok_x8( acquire.FenceValue, ==, 0 );
 
     open.hSharedHandle = create.hSharedHandle;
     open.hKeyedMutex = 0xdeadbeef;
@@ -2180,7 +2180,7 @@ static void test_D3DKMTAcquireKeyedMutex( void )
     thread = CreateThread( NULL, 0, test_acquire_mutex, &acquire, 0, NULL );
     ok_ptr( thread, !=, NULL );
     ret = WaitForSingleObject( thread, 100 );
-    ok_u4( ret, ==, WAIT_TIMEOUT );
+    todo_wine ok_u4( ret, ==, WAIT_TIMEOUT );
 
     destroy.hKeyedMutex = create.hKeyedMutex;
     status = D3DKMTDestroyKeyedMutex( &destroy );
@@ -2193,11 +2193,11 @@ static void test_D3DKMTAcquireKeyedMutex( void )
     acquire.FenceValue = 0xdeadbeef;
     timeout.QuadPart = 100 * -10000;
     status = D3DKMTAcquireKeyedMutex( &acquire );
-    ok_nt( STATUS_ABANDONED, status );
-    ok_x8( acquire.FenceValue, ==, 0 );
+    todo_wine ok_nt( STATUS_ABANDONED, status );
+    todo_wine ok_x8( acquire.FenceValue, ==, 0 );
     status = D3DKMTAcquireKeyedMutex( &acquire );
-    ok_nt( STATUS_ABANDONED, status );
-    ok_x8( acquire.FenceValue, ==, 0 );
+    todo_wine ok_nt( STATUS_ABANDONED, status );
+    todo_wine ok_x8( acquire.FenceValue, ==, 0 );
 
     destroy.hKeyedMutex = open.hKeyedMutex;
     status = D3DKMTDestroyKeyedMutex( &destroy );
diff --git b/include/wine/server_protocol.h a/include/wine/server_protocol.h
index b3203fe5082..573c944ebe2 100644
--- b/include/wine/server_protocol.h
+++ a/include/wine/server_protocol.h
@@ -6015,8 +6015,8 @@ struct d3dkmt_object_create_request
     struct request_header __header;
     unsigned int        type;
     int                 fd;
-    unsigned int        value;
     /* VARARG(runtime,bytes); */
+    char __pad_20[4];
 };
 struct d3dkmt_object_create_reply
 {
@@ -6114,44 +6114,6 @@ struct d3dkmt_object_open_name_reply
 };
 
 
-
-struct d3dkmt_mutex_acquire_request
-{
-    struct request_header __header;
-    d3dkmt_handle_t     mutex;
-    unsigned int        key_value;
-    obj_handle_t        wait_handle;
-    unsigned int        wait_status;
-    char __pad_28[4];
-};
-struct d3dkmt_mutex_acquire_reply
-{
-    struct reply_header __header;
-    unsigned __int64    fence_value;
-    data_size_t         runtime_size;
-    obj_handle_t        wait_handle;
-    /* VARARG(runtime,bytes); */
-};
-
-
-
-struct d3dkmt_mutex_release_request
-{
-    struct request_header __header;
-    d3dkmt_handle_t     mutex;
-    int                 abandon;
-    unsigned int        key_value;
-    unsigned __int64    fence_value;
-    data_size_t         runtime_size;
-    /* VARARG(runtime,bytes); */
-    char __pad_36[4];
-};
-struct d3dkmt_mutex_release_reply
-{
-    struct reply_header __header;
-};
-
-
 enum request
 {
     REQ_new_process,
@@ -6458,8 +6420,6 @@ enum request
     REQ_d3dkmt_object_open,
     REQ_d3dkmt_share_objects,
     REQ_d3dkmt_object_open_name,
-    REQ_d3dkmt_mutex_acquire,
-    REQ_d3dkmt_mutex_release,
     REQ_NB_REQUESTS
 };
 
@@ -6771,8 +6731,6 @@ union generic_request
     struct d3dkmt_object_open_request d3dkmt_object_open_request;
     struct d3dkmt_share_objects_request d3dkmt_share_objects_request;
     struct d3dkmt_object_open_name_request d3dkmt_object_open_name_request;
-    struct d3dkmt_mutex_acquire_request d3dkmt_mutex_acquire_request;
-    struct d3dkmt_mutex_release_request d3dkmt_mutex_release_request;
 };
 union generic_reply
 {
@@ -7082,10 +7040,8 @@ union generic_reply
     struct d3dkmt_object_open_reply d3dkmt_object_open_reply;
     struct d3dkmt_share_objects_reply d3dkmt_share_objects_reply;
     struct d3dkmt_object_open_name_reply d3dkmt_object_open_name_reply;
-    struct d3dkmt_mutex_acquire_reply d3dkmt_mutex_acquire_reply;
-    struct d3dkmt_mutex_release_reply d3dkmt_mutex_release_reply;
 };
 
-#define SERVER_PROTOCOL_VERSION 926
+#define SERVER_PROTOCOL_VERSION 924
 
 #endif /* __WINE_WINE_SERVER_PROTOCOL_H */
diff --git b/server/d3dkmt.c a/server/d3dkmt.c
index 6c8c971dc44..4d30ec65966 100644
--- b/server/d3dkmt.c
+++ a/server/d3dkmt.c
@@ -95,53 +95,6 @@ static const struct fd_ops d3dkmt_fd_ops =
     default_fd_reselect_async     /* reselect_async */
 };
 
-struct keyed_wait
-{
-    struct list     entry;
-    int             key;
-    int             waiters;
-    struct object  *sync;
-};
-
-struct d3dkmt_mutex
-{
-    struct d3dkmt_object base;
-    unsigned int         key_value;      /* last released key value */
-    unsigned __int64     fence_value;    /* last released fence value */
-    bool                 abandoned;      /* mutex has been abandonned */
-    struct thread       *owner;          /* current owner thread */
-    struct list          waits;          /* list of pending keyed_waits */
-    struct list          entry;          /* entry in owner d3dkmt_mutexes */
-};
-
-static void d3dkmt_mutex_dump( struct object *obj, int verbose );
-static void d3dkmt_mutex_destroy( struct object *obj );
-
-static const struct object_ops d3dkmt_mutex_ops =
-{
-    sizeof(struct d3dkmt_mutex),    /* size */
-    &no_type,                       /* type */
-    d3dkmt_mutex_dump,              /* dump */
-    no_add_queue,                   /* add_queue */
-    NULL,                           /* remove_queue */
-    NULL,                           /* signaled */
-    NULL,                           /* satisfied */
-    no_signal,                      /* signal */
-    no_get_fd,                      /* get_fd */
-    default_get_sync,               /* get_sync */
-    default_map_access,             /* map_access */
-    default_get_sd,                 /* get_sd */
-    default_set_sd,                 /* set_sd */
-    no_get_full_name,               /* get_full_name */
-    no_lookup_name,                 /* lookup_name */
-    no_link_name,                   /* link_name */
-    NULL,                           /* unlink_name */
-    no_open_file,                   /* open_file */
-    no_kernel_obj_list,             /* get_kernel_obj_list */
-    no_close_handle,                /* close_handle */
-    d3dkmt_mutex_destroy,           /* destroy */
-};
-
 #define DXGK_SHARED_SYNC_QUERY_STATE  0x0001
 #define DXGK_SHARED_SYNC_MODIFY_STATE 0x0002
 #define DXGK_SHARED_SYNC_ALL_ACCESS   (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3)
@@ -417,131 +370,6 @@ static struct d3dkmt_object *d3dkmt_object_create( enum d3dkmt_type type, data_s
     return object;
 }
 
-static void d3dkmt_mutex_dump( struct object *obj, int verbose )
-{
-    struct d3dkmt_mutex *mutex = (struct d3dkmt_mutex *)obj;
-    assert( obj->ops == &d3dkmt_mutex_ops );
-
-    fprintf( stderr, "d3dkmt mutex global=%#x\n", mutex->base.global );
-}
-
-static void d3dkmt_mutex_destroy( struct object *obj )
-{
-    struct d3dkmt_mutex *mutex = (struct d3dkmt_mutex *)obj;
-    struct keyed_wait *wait, *next;
-
-    assert( obj->ops == &d3dkmt_mutex_ops );
-
-    LIST_FOR_EACH_ENTRY_SAFE( wait, next, &mutex->waits, struct keyed_wait, entry )
-    {
-        release_object( wait->sync );
-        list_remove( &wait->entry );
-        free( wait );
-    }
-
-    if (mutex->base.global) free_object_handle( mutex->base.global );
-    free( mutex->base.runtime );
-}
-
-static struct d3dkmt_object *d3dkmt_mutex_create( unsigned int key_value, data_size_t runtime_size, const void *runtime )
-{
-    struct d3dkmt_mutex *object;
-
-    if (!(object = alloc_object( &d3dkmt_mutex_ops ))) return NULL;
-    object->base.type            = D3DKMT_MUTEX;
-    object->base.global          = 0;
-    object->base.runtime_size    = runtime_size;
-    object->base.fd              = NULL;
-    object->key_value            = key_value;
-    object->fence_value          = 0;
-    object->abandoned            = false;
-    object->owner                = NULL;
-    list_init( &object->waits );
-
-    if (!(object->base.runtime = memdup( runtime, runtime_size )) ||
-        !(object->base.global = alloc_object_handle( &object->base )))
-    {
-        release_object( object );
-        return NULL;
-    }
-
-    return &object->base;
-}
-
-static struct object *keyed_wait_grab( struct d3dkmt_mutex *mutex, int key )
-{
-    struct keyed_wait *wait;
-
-    LIST_FOR_EACH_ENTRY( wait, &mutex->waits, struct keyed_wait, entry )
-    {
-        if (wait->key != key) continue;
-        wait->waiters++;
-        return grab_object( wait->sync );
-    }
-
-    if (!(wait = mem_alloc( sizeof(*wait) ))) return NULL;
-    wait->key       = key;
-    wait->waiters   = 1;
-    if (!(wait->sync = create_internal_sync( 0, 0 )))
-    {
-        free( wait );
-        return NULL;
-    }
-
-    list_add_tail( &mutex->waits, &wait->entry );
-    return grab_object( wait->sync );
-}
-
-static void keyed_wait_release( struct d3dkmt_mutex *mutex, int key )
-{
-    struct keyed_wait *wait;
-
-    LIST_FOR_EACH_ENTRY( wait, &mutex->waits, struct keyed_wait, entry )
-    {
-        if (wait->key == key && !--wait->waiters)
-        {
-            release_object( wait->sync );
-            list_remove( &wait->entry );
-            free( wait );
-            break;
-        }
-    }
-}
-
-static void mutex_grab( struct d3dkmt_mutex *mutex )
-{
-    grab_object( mutex );
-    list_add_tail( &current->d3dkmt_mutexes, &mutex->entry );
-    mutex->owner = current;
-}
-
-static void mutex_release( struct d3dkmt_mutex *mutex, bool abandon )
-{
-    struct keyed_wait *wait;
-
-    LIST_FOR_EACH_ENTRY( wait, &mutex->waits, struct keyed_wait, entry )
-    {
-        if (abandon || wait->key == mutex->key_value)
-        {
-            signal_sync( wait->sync );
-            if (!abandon) break;
-        }
-    }
-    if (abandon) mutex->abandoned = true;
-
-    mutex->owner = NULL;
-    list_remove( &mutex->entry );
-    release_object( mutex );
-}
-
-void abandon_d3dkmt_mutexes( struct thread *thread )
-{
-    struct d3dkmt_mutex *mutex, *next;
-
-    LIST_FOR_EACH_ENTRY_SAFE( mutex, next, &thread->d3dkmt_mutexes, struct d3dkmt_mutex, entry )
-        mutex_release( mutex, true );
-}
-
 /* return a pointer to a d3dkmt object from its global handle */
 static void *d3dkmt_object_open( d3dkmt_handle_t global, enum d3dkmt_type type )
 {
@@ -598,16 +426,7 @@ DECL_HANDLER(d3dkmt_object_create)
         if (!(fd = create_anonymous_fd( NULL, unix_fd, NULL, 0 ))) return;
     }
 
-    switch (req->type)
-    {
-    case D3DKMT_MUTEX:
-        if (!(object = d3dkmt_mutex_create( req->value, get_req_data_size(), get_req_data() ))) goto done;
-        break;
-    default:
-        if (!(object = d3dkmt_object_create( req->type, get_req_data_size(), get_req_data() ))) goto done;
-        break;
-    }
-
+    if (!(object = d3dkmt_object_create( req->type, get_req_data_size(), get_req_data() ))) goto done;
     if (fd)
     {
         set_fd_user( fd, &d3dkmt_fd_ops, &object->obj );
@@ -746,54 +565,3 @@ DECL_HANDLER(d3dkmt_object_open_name)
         break;
     }
 }
-
-/* Acquire a global d3dkmt keyed mutex */
-DECL_HANDLER(d3dkmt_mutex_acquire)
-{
-    struct d3dkmt_mutex *mutex;
-    struct object *sync;
-
-    if (!(mutex = d3dkmt_object_open( req->mutex, D3DKMT_MUTEX ))) goto done;
-
-    if (req->wait_status) set_error( req->wait_status );
-    else if (mutex->abandoned) set_error( STATUS_ABANDONED );
-    else if (mutex->key_value == req->key_value && !mutex->owner)
-    {
-        reply->fence_value = mutex->fence_value;
-        mutex_grab( mutex );
-    }
-    else if ((reply->wait_handle = req->wait_handle)) set_error( STATUS_PENDING );
-    else if ((sync = keyed_wait_grab( mutex, req->key_value )))
-    {
-        if ((reply->wait_handle = alloc_handle( current->process, sync, SYNCHRONIZE, 0 ))) set_error( STATUS_PENDING );
-        release_object( sync );
-    }
-
-    release_object( mutex );
-
-done:
-    if (get_error() != STATUS_PENDING && req->wait_handle)
-    {
-        close_handle( current->process, req->wait_handle );
-        if (mutex) keyed_wait_release( mutex, req->key_value );
-    }
-}
-
-/* Release a global d3dkmt keyed mutex */
-DECL_HANDLER(d3dkmt_mutex_release)
-{
-    struct d3dkmt_mutex *mutex;
-
-    if (!(mutex = d3dkmt_object_open( req->mutex, D3DKMT_MUTEX ))) return;
-
-    if (mutex->abandoned) set_error( STATUS_ABANDONED );
-    else if (mutex->owner != current) set_error( STATUS_INVALID_PARAMETER );
-    else
-    {
-        mutex->key_value = req->key_value;
-        mutex->fence_value = req->fence_value;
-        mutex_release( mutex, req->abandon );
-    }
-
-    release_object( mutex );
-}
diff --git b/server/object.h a/server/object.h
index cab8ad25a59..2a0ecfc2cf2 100644
--- b/server/object.h
+++ a/server/object.h
@@ -240,7 +240,6 @@ extern void reset_event( struct event *event );
 /* mutex functions */
 
 extern void abandon_mutexes( struct thread *thread );
-extern void abandon_d3dkmt_mutexes( struct thread *thread );
 
 /* in-process synchronization functions */
 
diff --git b/server/protocol.def a/server/protocol.def
index 93e574b61a3..cb46a5ff2dc 100644
--- b/server/protocol.def
+++ a/server/protocol.def
@@ -4179,7 +4179,6 @@ enum inproc_sync_type
 @REQ(d3dkmt_object_create)
     unsigned int        type;           /* d3dkmt object type */
     int                 fd;             /* host specific fd */
-    unsigned int        value;          /* initial value for keyed mutex */
     VARARG(runtime,bytes);              /* client runtime data */
 @REPLY
     d3dkmt_handle_t     global;         /* global d3dkmt handle */
@@ -4240,28 +4239,3 @@ enum inproc_sync_type
 @REPLY
     obj_handle_t        handle;         /* shared object handle */
 @END
-
-
-/* Acquire a global d3dkmt keyed mutex */
-@REQ(d3dkmt_mutex_acquire)
-    d3dkmt_handle_t     mutex;          /* mutex global handle */
-    unsigned int        key_value;      /* the key to acquire/wait for */
-    obj_handle_t        wait_handle;    /* previously returned wait handle */
-    unsigned int        wait_status;    /* status returned from previous wait */
-@REPLY
-    unsigned __int64    fence_value;    /* semaphore fence value */
-    data_size_t         runtime_size;   /* size of client runtime data */
-    obj_handle_t        wait_handle;    /* wait handle for pending acquire */
-    VARARG(runtime,bytes);              /* client runtime data */
-@END
-
-
-/* Release a global d3dkmt keyed mutex */
-@REQ(d3dkmt_mutex_release)
-    d3dkmt_handle_t     mutex;          /* mutex global handle */
-    int                 abandon;        /* mutex is being abandonned */
-    unsigned int        key_value;      /* the key to release */
-    unsigned __int64    fence_value;    /* semaphore fence value */
-    data_size_t         runtime_size;   /* size of client runtime data */
-    VARARG(runtime,bytes);              /* client runtime data */
-@END
diff --git b/server/request_handlers.h a/server/request_handlers.h
index 0f6c6f42f07..6d866a744fe 100644
--- b/server/request_handlers.h
+++ a/server/request_handlers.h
@@ -311,8 +311,6 @@ DECL_HANDLER(d3dkmt_object_query);
 DECL_HANDLER(d3dkmt_object_open);
 DECL_HANDLER(d3dkmt_share_objects);
 DECL_HANDLER(d3dkmt_object_open_name);
-DECL_HANDLER(d3dkmt_mutex_acquire);
-DECL_HANDLER(d3dkmt_mutex_release);
 
 typedef void (*req_handler)( const void *req, void *reply );
 static const req_handler req_handlers[REQ_NB_REQUESTS] =
@@ -621,8 +619,6 @@ static const req_handler req_handlers[REQ_NB_REQUESTS] =
     (req_handler)req_d3dkmt_object_open,
     (req_handler)req_d3dkmt_share_objects,
     (req_handler)req_d3dkmt_object_open_name,
-    (req_handler)req_d3dkmt_mutex_acquire,
-    (req_handler)req_d3dkmt_mutex_release,
 };
 
 C_ASSERT( sizeof(abstime_t) == 8 );
@@ -2316,7 +2312,6 @@ C_ASSERT( offsetof(struct get_inproc_alert_fd_reply, handle) == 8 );
 C_ASSERT( sizeof(struct get_inproc_alert_fd_reply) == 16 );
 C_ASSERT( offsetof(struct d3dkmt_object_create_request, type) == 12 );
 C_ASSERT( offsetof(struct d3dkmt_object_create_request, fd) == 16 );
-C_ASSERT( offsetof(struct d3dkmt_object_create_request, value) == 20 );
 C_ASSERT( sizeof(struct d3dkmt_object_create_request) == 24 );
 C_ASSERT( offsetof(struct d3dkmt_object_create_reply, global) == 8 );
 C_ASSERT( offsetof(struct d3dkmt_object_create_reply, handle) == 12 );
@@ -2352,18 +2347,3 @@ C_ASSERT( offsetof(struct d3dkmt_object_open_name_request, rootdir) == 24 );
 C_ASSERT( sizeof(struct d3dkmt_object_open_name_request) == 32 );
 C_ASSERT( offsetof(struct d3dkmt_object_open_name_reply, handle) == 8 );
 C_ASSERT( sizeof(struct d3dkmt_object_open_name_reply) == 16 );
-C_ASSERT( offsetof(struct d3dkmt_mutex_acquire_request, mutex) == 12 );
-C_ASSERT( offsetof(struct d3dkmt_mutex_acquire_request, key_value) == 16 );
-C_ASSERT( offsetof(struct d3dkmt_mutex_acquire_request, wait_handle) == 20 );
-C_ASSERT( offsetof(struct d3dkmt_mutex_acquire_request, wait_status) == 24 );
-C_ASSERT( sizeof(struct d3dkmt_mutex_acquire_request) == 32 );
-C_ASSERT( offsetof(struct d3dkmt_mutex_acquire_reply, fence_value) == 8 );
-C_ASSERT( offsetof(struct d3dkmt_mutex_acquire_reply, runtime_size) == 16 );
-C_ASSERT( offsetof(struct d3dkmt_mutex_acquire_reply, wait_handle) == 20 );
-C_ASSERT( sizeof(struct d3dkmt_mutex_acquire_reply) == 24 );
-C_ASSERT( offsetof(struct d3dkmt_mutex_release_request, mutex) == 12 );
-C_ASSERT( offsetof(struct d3dkmt_mutex_release_request, abandon) == 16 );
-C_ASSERT( offsetof(struct d3dkmt_mutex_release_request, key_value) == 20 );
-C_ASSERT( offsetof(struct d3dkmt_mutex_release_request, fence_value) == 24 );
-C_ASSERT( offsetof(struct d3dkmt_mutex_release_request, runtime_size) == 32 );
-C_ASSERT( sizeof(struct d3dkmt_mutex_release_request) == 40 );
diff --git b/server/request_trace.h a/server/request_trace.h
index 7445f0e8120..ba0aaf42c61 100644
--- b/server/request_trace.h
+++ a/server/request_trace.h
@@ -3398,7 +3398,6 @@ static void dump_d3dkmt_object_create_request( const struct d3dkmt_object_create
 {
     fprintf( stderr, " type=%08x", req->type );
     fprintf( stderr, ", fd=%d", req->fd );
-    fprintf( stderr, ", value=%08x", req->value );
     dump_varargs_bytes( ", runtime=", cur_size );
 }
 
@@ -3470,32 +3469,6 @@ static void dump_d3dkmt_object_open_name_reply( const struct d3dkmt_object_open_
     fprintf( stderr, " handle=%04x", req->handle );
 }
 
-static void dump_d3dkmt_mutex_acquire_request( const struct d3dkmt_mutex_acquire_request *req )
-{
-    fprintf( stderr, " mutex=%08x", req->mutex );
-    fprintf( stderr, ", key_value=%08x", req->key_value );
-    fprintf( stderr, ", wait_handle=%04x", req->wait_handle );
-    fprintf( stderr, ", wait_status=%08x", req->wait_status );
-}
-
-static void dump_d3dkmt_mutex_acquire_reply( const struct d3dkmt_mutex_acquire_reply *req )
-{
-    dump_uint64( " fence_value=", &req->fence_value );
-    fprintf( stderr, ", runtime_size=%u", req->runtime_size );
-    fprintf( stderr, ", wait_handle=%04x", req->wait_handle );
-    dump_varargs_bytes( ", runtime=", cur_size );
-}
-
-static void dump_d3dkmt_mutex_release_request( const struct d3dkmt_mutex_release_request *req )
-{
-    fprintf( stderr, " mutex=%08x", req->mutex );
-    fprintf( stderr, ", abandon=%d", req->abandon );
-    fprintf( stderr, ", key_value=%08x", req->key_value );
-    dump_uint64( ", fence_value=", &req->fence_value );
-    fprintf( stderr, ", runtime_size=%u", req->runtime_size );
-    dump_varargs_bytes( ", runtime=", cur_size );
-}
-
 typedef void (*dump_func)( const void *req );
 
 static const dump_func req_dumpers[REQ_NB_REQUESTS] =
@@ -3804,8 +3777,6 @@ static const dump_func req_dumpers[REQ_NB_REQUESTS] =
     (dump_func)dump_d3dkmt_object_open_request,
     (dump_func)dump_d3dkmt_share_objects_request,
     (dump_func)dump_d3dkmt_object_open_name_request,
-    (dump_func)dump_d3dkmt_mutex_acquire_request,
-    (dump_func)dump_d3dkmt_mutex_release_request,
 };
 
 static const dump_func reply_dumpers[REQ_NB_REQUESTS] =
@@ -4114,8 +4085,6 @@ static const dump_func reply_dumpers[REQ_NB_REQUESTS] =
     (dump_func)dump_d3dkmt_object_open_reply,
     (dump_func)dump_d3dkmt_share_objects_reply,
     (dump_func)dump_d3dkmt_object_open_name_reply,
-    (dump_func)dump_d3dkmt_mutex_acquire_reply,
-    NULL,
 };
 
 static const char * const req_names[REQ_NB_REQUESTS] =
@@ -4424,8 +4393,6 @@ static const char * const req_names[REQ_NB_REQUESTS] =
     "d3dkmt_object_open",
     "d3dkmt_share_objects",
     "d3dkmt_object_open_name",
-    "d3dkmt_mutex_acquire",
-    "d3dkmt_mutex_release",
 };
 
 static const struct
@@ -4434,7 +4401,6 @@ static const struct
     unsigned int value;
 } status_names[] =
 {
-    { "ABANDONED",                   STATUS_ABANDONED },
     { "ABANDONED_WAIT_0",            STATUS_ABANDONED_WAIT_0 },
     { "ACCESS_DENIED",               STATUS_ACCESS_DENIED },
     { "ACCESS_VIOLATION",            STATUS_ACCESS_VIOLATION },
diff --git b/server/thread.c a/server/thread.c
index 3aed496450a..6a1b1f8c559 100644
--- b/server/thread.c
+++ a/server/thread.c
@@ -434,7 +434,6 @@ static inline void init_thread_structure( struct thread *thread )
     thread->completion_wait = NULL;
 
     list_init( &thread->mutex_list );
-    list_init( &thread->d3dkmt_mutexes );
     list_init( &thread->system_apc );
     list_init( &thread->user_apc );
     list_init( &thread->kernel_object );
diff --git b/server/thread.h a/server/thread.h
index 77ea355483d..fb77901ba7c 100644
--- b/server/thread.h
+++ a/server/thread.h
@@ -58,7 +58,6 @@ struct thread
     struct process        *process;
     thread_id_t            id;            /* thread id */
     struct list            mutex_list;    /* list of currently owned mutexes */
-    struct list            d3dkmt_mutexes;/* list of currently owned d3dkmt mutexes */
     unsigned int           system_regs;   /* which system regs have been set */
     struct msg_queue      *queue;         /* message queue */
     struct thread_wait    *wait;          /* current wait condition if sleeping */

diff --git b/dlls/win32u/d3dkmt.c a/dlls/win32u/d3dkmt.c
index b60639374b3..ded774215fe 100644
--- b/dlls/win32u/d3dkmt.c
+++ a/dlls/win32u/d3dkmt.c
@@ -1755,7 +1755,7 @@ NTSTATUS d3dkmt_destroy_resource( D3DKMT_HANDLE local )
 }
 
 /* create a D3DKMT global or shared sync */
-D3DKMT_HANDLE d3dkmt_create_sync( int fd, D3DKMT_HANDLE *global )
+D3DKMT_HANDLE d3dkmt_create_sync( D3DKMT_HANDLE *global )
 {
     struct d3dkmt_object *sync = NULL;
     NTSTATUS status;
@@ -1763,7 +1763,7 @@ D3DKMT_HANDLE d3dkmt_create_sync( int fd, D3DKMT_HANDLE *global )
     TRACE( "global %p\n", global );
 
     if ((status = d3dkmt_object_alloc( sizeof(*sync), D3DKMT_SYNC, (void **)&sync ))) goto failed;
-    if ((status = d3dkmt_object_create( sync, fd, !global, NULL, 0 ))) goto failed;
+    if ((status = d3dkmt_object_create( sync, -1, !global, NULL, 0 ))) goto failed;
     if (global) *global = sync->global;
     return sync->local;
 
diff --git b/dlls/win32u/vulkan.c a/dlls/win32u/vulkan.c
index 017b84df8c3..cddd5feacec 100644
--- b/dlls/win32u/vulkan.c
+++ a/dlls/win32u/vulkan.c
@@ -1541,20 +1541,9 @@ static VkResult win32u_vkCreateSemaphore( VkDevice client_device, const VkSemaph
 
     if (export_info)
     {
-        VkSemaphoreGetFdInfoKHR fd_info = {.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR, .semaphore = host_semaphore};
-        int fd = -1;
+        FIXME( "Exporting semaphore handle not yet implemented!\n" );
 
-        switch ((fd_info.handleType = get_host_external_semaphore_type()))
-        {
-        case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT:
-            if ((res = device->p_vkGetSemaphoreFdKHR( device->host.device, &fd_info, &fd ))) goto failed;
-            break;
-        default:
-            FIXME( "Unsupported handle type %#x\n", fd_info.handleType );
-            break;
-        }
-
-        if (!(semaphore->local = d3dkmt_create_sync( fd, nt_shared ? NULL : &semaphore->global ))) goto failed;
+        if (!(semaphore->local = d3dkmt_create_sync( nt_shared ? NULL : &semaphore->global ))) goto failed;
         if (nt_shared && !(semaphore->shared = create_shared_semaphore_handle( semaphore->local, &export_win32 ))) goto failed;
     }
 
@@ -1565,7 +1554,6 @@ static VkResult win32u_vkCreateSemaphore( VkDevice client_device, const VkSemaph
     return res;
 
 failed:
-    WARN( "Failed to create semaphore, res %d\n", res );
     device->p_vkDestroySemaphore( device->host.device, host_semaphore, NULL );
     if (semaphore->local) d3dkmt_destroy_sync( semaphore->local );
     free( semaphore );
@@ -1618,11 +1606,9 @@ static VkResult win32u_vkGetSemaphoreWin32HandleKHR( VkDevice client_device, con
 
 static VkResult win32u_vkImportSemaphoreWin32HandleKHR( VkDevice client_device, const VkImportSemaphoreWin32HandleInfoKHR *handle_info )
 {
-    VkImportSemaphoreFdInfoKHR fd_info = {.sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR};
     struct vulkan_device *device = vulkan_device_from_handle( client_device );
     struct semaphore *semaphore = semaphore_from_handle( handle_info->semaphore );
     D3DKMT_HANDLE local, global = 0;
-    VkResult res = VK_SUCCESS;
     HANDLE shared = NULL;
 
     TRACE( "device %p, handle_info %p\n", device, handle_info );
@@ -1652,16 +1638,9 @@ static VkResult win32u_vkImportSemaphoreWin32HandleKHR( VkDevice client_device,
         return VK_ERROR_INVALID_EXTERNAL_HANDLE;
     }
 
-    if ((fd_info.fd = d3dkmt_object_get_fd( local )) < 0) res = VK_ERROR_INVALID_EXTERNAL_HANDLE;
-    else
-    {
-        fd_info.handleType = get_host_external_semaphore_type();
-        fd_info.semaphore = semaphore->obj.host.semaphore;
-        fd_info.flags = handle_info->flags;
-        res = device->p_vkImportSemaphoreFdKHR( device->host.device, &fd_info );
-    }
+    FIXME( "Importing memory handle not yet implemented!\n" );
 
-    if (res || handle_info->flags & VK_SEMAPHORE_IMPORT_TEMPORARY_BIT)
+    if (handle_info->flags & VK_SEMAPHORE_IMPORT_TEMPORARY_BIT)
     {
         /* FIXME: Should we still keep the temporary handles for vkGetSemaphoreWin32HandleKHR? */
         if (shared) NtClose( shared );
@@ -1675,7 +1654,7 @@ static VkResult win32u_vkImportSemaphoreWin32HandleKHR( VkDevice client_device,
         semaphore->global = global;
         semaphore->local = local;
     }
-    return res;
+    return VK_SUCCESS;
 }
 
 static void win32u_vkGetPhysicalDeviceExternalSemaphoreProperties( VkPhysicalDevice client_physical_device, const VkPhysicalDeviceExternalSemaphoreInfo *client_semaphore_info,
@@ -1749,20 +1728,9 @@ static VkResult win32u_vkCreateFence( VkDevice client_device, const VkFenceCreat
 
     if (export_info)
     {
-        VkFenceGetFdInfoKHR fd_info = {.sType = VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR, .fence = host_fence};
-        int fd = -1;
+        FIXME( "Exporting fence handle not yet implemented!\n" );
 
-        switch ((fd_info.handleType = get_host_external_fence_type()))
-        {
-        case VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT:
-            if ((res = device->p_vkGetFenceFdKHR( device->host.device, &fd_info, &fd ))) goto failed;
-            break;
-        default:
-            FIXME( "Unsupported handle type %#x\n", fd_info.handleType );
-            break;
-        }
-
-        if (!(fence->local = d3dkmt_create_sync( fd, nt_shared ? NULL : &fence->global ))) goto failed;
+        if (!(fence->local = d3dkmt_create_sync( nt_shared ? NULL : &fence->global ))) goto failed;
         if (nt_shared && !(fence->shared = create_shared_semaphore_handle( fence->local, &export_win32 ))) goto failed;
     }
 
@@ -1773,7 +1741,6 @@ static VkResult win32u_vkCreateFence( VkDevice client_device, const VkFenceCreat
     return res;
 
 failed:
-    WARN( "Failed to create fence, res %d\n", res );
     device->p_vkDestroyFence( device->host.device, host_fence, NULL );
     if (fence->local) d3dkmt_destroy_sync( fence->local );
     free( fence );
@@ -1825,12 +1792,10 @@ static VkResult win32u_vkGetFenceWin32HandleKHR( VkDevice client_device, const V
 
 static VkResult win32u_vkImportFenceWin32HandleKHR( VkDevice client_device, const VkImportFenceWin32HandleInfoKHR *handle_info )
 {
-    VkImportFenceFdInfoKHR fd_info = {.sType = VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR};
     struct vulkan_device *device = vulkan_device_from_handle( client_device );
     struct fence *fence = fence_from_handle( handle_info->fence );
     D3DKMT_HANDLE local, global = 0;
     HANDLE shared = NULL;
-    VkResult res;
 
     TRACE( "device %p, handle_info %p\n", device, handle_info );
 
@@ -1858,16 +1823,9 @@ static VkResult win32u_vkImportFenceWin32HandleKHR( VkDevice client_device, cons
         return VK_ERROR_INVALID_EXTERNAL_HANDLE;
     }
 
-    if ((fd_info.fd = d3dkmt_object_get_fd( local )) < 0) res = VK_ERROR_INVALID_EXTERNAL_HANDLE;
-    else
-    {
-        fd_info.handleType = get_host_external_fence_type();
-        fd_info.fence = fence->obj.host.fence;
-        fd_info.flags = handle_info->flags;
-        res = device->p_vkImportFenceFdKHR( device->host.device, &fd_info );
-    }
+    FIXME( "Importing memory handle not yet implemented!\n" );
 
-    if (res || handle_info->flags & VK_FENCE_IMPORT_TEMPORARY_BIT)
+    if (handle_info->flags & VK_FENCE_IMPORT_TEMPORARY_BIT)
     {
         /* FIXME: Should we still keep the temporary handles for vkGetFenceWin32HandleKHR? */
         if (shared) NtClose( shared );
diff --git b/dlls/win32u/win32u_private.h a/dlls/win32u/win32u_private.h
index 7bca9db4226..cce3af26c0e 100644
--- b/dlls/win32u/win32u_private.h
+++ a/dlls/win32u/win32u_private.h
@@ -212,7 +212,7 @@ extern D3DKMT_HANDLE d3dkmt_create_resource( int fd, D3DKMT_HANDLE *global );
 extern D3DKMT_HANDLE d3dkmt_open_resource( D3DKMT_HANDLE global, HANDLE shared );
 extern NTSTATUS d3dkmt_destroy_resource( D3DKMT_HANDLE local );
 
-extern D3DKMT_HANDLE d3dkmt_create_sync( int fd, D3DKMT_HANDLE *global );
+extern D3DKMT_HANDLE d3dkmt_create_sync( D3DKMT_HANDLE *global );
 extern D3DKMT_HANDLE d3dkmt_open_sync( D3DKMT_HANDLE global, HANDLE shared );
 extern NTSTATUS d3dkmt_destroy_sync( D3DKMT_HANDLE local );
 
diff --git b/dlls/ntdll/unix/server.c a/dlls/ntdll/unix/server.c
index 258a959de72..ee34c5e9cd8 100644
--- b/dlls/ntdll/unix/server.c
+++ a/dlls/ntdll/unix/server.c
@@ -939,7 +939,7 @@ unsigned int server_queue_process_apc( HANDLE process, const union apc_call *cal
  *
  * Send a file descriptor to the server.
  */
-void CDECL wine_server_send_fd( int fd )
+void wine_server_send_fd( int fd )
 {
     struct send_fd data;
     struct msghdr msghdr;
diff --git b/dlls/ntdll/unix/unix_private.h a/dlls/ntdll/unix/unix_private.h
index 5d374017101..4e7af70bf25 100644
--- b/dlls/ntdll/unix/unix_private.h
+++ a/dlls/ntdll/unix/unix_private.h
@@ -233,6 +233,7 @@ extern unsigned int server_queue_process_apc( HANDLE process, const union apc_ca
                                               union apc_result *result );
 extern int server_get_unix_fd( HANDLE handle, unsigned int wanted_access, int *unix_fd,
                                int *needs_close, enum server_fd_type *type, unsigned int *options );
+extern void wine_server_send_fd( int fd );
 extern int wine_server_receive_fd( obj_handle_t *handle );
 extern void process_exit_wrapper( int status ) DECLSPEC_NORETURN;
 extern size_t server_init_process(void);
diff --git b/dlls/win32u/d3dkmt.c a/dlls/win32u/d3dkmt.c
index ded774215fe..23640cb39be 100644
--- b/dlls/win32u/d3dkmt.c
+++ a/dlls/win32u/d3dkmt.c
@@ -180,16 +180,13 @@ static NTSTATUS d3dkmt_object_alloc( UINT size, enum d3dkmt_type type, void **ob
 }
 
 /* create a global D3DKMT object, either with a global handle or later shareable */
-static NTSTATUS d3dkmt_object_create( struct d3dkmt_object *object, int fd, BOOL shared, const void *runtime, UINT runtime_size )
+static NTSTATUS d3dkmt_object_create( struct d3dkmt_object *object, BOOL shared, const void *runtime, UINT runtime_size )
 {
     NTSTATUS status;
 
-    if (fd >= 0) wine_server_send_fd( fd );
-
     SERVER_START_REQ( d3dkmt_object_create )
     {
         req->type = object->type;
-        req->fd = fd;
         if (runtime_size) wine_server_add_data( req, runtime, runtime_size );
         status = wine_server_call( req );
         object->handle = wine_server_ptr_handle( reply->handle );
@@ -205,21 +202,23 @@ static NTSTATUS d3dkmt_object_create( struct d3dkmt_object *object, int fd, BOOL
     return status;
 }
 
-static NTSTATUS d3dkmt_object_update( struct d3dkmt_object *object, const void *runtime, UINT runtime_size )
+static NTSTATUS d3dkmt_object_update( enum d3dkmt_type type, D3DKMT_HANDLE global, HANDLE handle,
+                                      const void *runtime, UINT runtime_size )
 {
     NTSTATUS status;
 
     SERVER_START_REQ( d3dkmt_object_update )
     {
-        req->type = object->type;
-        req->global = object->global;
+        req->type = type;
+        req->global = global;
+        req->handle = wine_server_obj_handle( handle );
         if (runtime_size) wine_server_add_data( req, runtime, runtime_size );
         status = wine_server_call( req );
     }
     SERVER_END_REQ;
 
-    if (status) WARN( "Failed to update object %#x/%p global %#x, status %#x\n", object->local, object, object->global, status );
-    else TRACE( "Updated object %#x/%p global %#x\n", object->local, object, object->global );
+    if (status) WARN( "Failed to update global object %#x/%p, status %#x\n", global, handle, status );
+    else TRACE( "Updated global object %#x/%p\n", global, handle );
     return status;
 }
 
@@ -456,18 +455,19 @@ NTSTATUS WINAPI NtGdiDdDDIOpenAdapterFromHdc( D3DKMT_OPENADAPTERFROMHDC *desc )
  */
 NTSTATUS WINAPI NtGdiDdDDIEscape( const D3DKMT_ESCAPE *desc )
 {
+    HANDLE shared;
+
     switch (desc->Type)
     {
     case D3DKMT_ESCAPE_UPDATE_RESOURCE_WINE:
-    {
-        struct d3dkmt_resource *resource;
-
         TRACE( "D3DKMT_ESCAPE_UPDATE_RESOURCE_WINE hContext %#x, pPrivateDriverData %p, PrivateDriverDataSize %#x\n",
                desc->hContext, desc->pPrivateDriverData, desc->PrivateDriverDataSize );
 
-        if (!(resource = get_d3dkmt_object( desc->hContext, D3DKMT_RESOURCE ))) return STATUS_INVALID_PARAMETER;
-        return d3dkmt_object_update( &resource->obj, desc->pPrivateDriverData, desc->PrivateDriverDataSize );
-    }
+        if (is_d3dkmt_global( desc->hContext )) shared = NULL;
+        else shared = UlongToHandle( desc->hContext );
+
+        return d3dkmt_object_update( D3DKMT_RESOURCE, shared ? 0 : desc->hContext, shared,
+                                     desc->pPrivateDriverData, desc->PrivateDriverDataSize );
 
     default:
         FIXME( "(%p): stub\n", desc );
@@ -1053,7 +1053,7 @@ NTSTATUS WINAPI NtGdiDdDDICreateAllocation2( D3DKMT_CREATEALLOCATION *params )
         if ((status = d3dkmt_object_alloc( sizeof(*allocation), D3DKMT_ALLOCATION, (void **)&allocation ))) goto failed;
 
         if (!params->Flags.CreateShared) status = alloc_object_handle( &resource->obj );
-        else status = d3dkmt_object_create( &resource->obj, -1, params->Flags.NtSecuritySharing,
+        else status = d3dkmt_object_create( &resource->obj, params->Flags.NtSecuritySharing,
                                             params->pPrivateRuntimeData, params->PrivateRuntimeDataSize );
         if (status) goto failed;
 
@@ -1372,7 +1372,7 @@ NTSTATUS WINAPI NtGdiDdDDICreateKeyedMutex2( D3DKMT_CREATEKEYEDMUTEX2 *params )
     if (!params) return STATUS_INVALID_PARAMETER;
 
     if ((status = d3dkmt_object_alloc( sizeof(*mutex), D3DKMT_MUTEX, (void **)&mutex ))) return status;
-    if ((status = d3dkmt_object_create( mutex, -1, params->Flags.NtSecuritySharing,
+    if ((status = d3dkmt_object_create( mutex, params->Flags.NtSecuritySharing,
                                         params->pPrivateRuntimeData, params->PrivateRuntimeDataSize )))
         goto failed;
 
@@ -1511,7 +1511,7 @@ NTSTATUS WINAPI NtGdiDdDDICreateSynchronizationObject2( D3DKMT_CREATESYNCHRONIZA
 
     if ((status = d3dkmt_object_alloc( sizeof(*sync), D3DKMT_SYNC, (void **)&sync ))) return status;
     if (!params->Info.Flags.Shared) status = alloc_object_handle( sync );
-    else status = d3dkmt_object_create( sync, -1, params->Info.Flags.NtSecuritySharing, NULL, 0 );
+    else status = d3dkmt_object_create( sync, params->Info.Flags.NtSecuritySharing, NULL, 0 );
     if (status) goto failed;
 
     if (params->Info.Flags.Shared) params->Info.SharedHandle = sync->shared ? 0 : sync->global;
@@ -1668,37 +1668,18 @@ NTSTATUS WINAPI NtGdiDdDDIDestroySynchronizationObject( const D3DKMT_DESTROYSYNC
     return STATUS_SUCCESS;
 }
 
-/* get a locally opened D3DKMT object host-specific fd */
-int d3dkmt_object_get_fd( D3DKMT_HANDLE local )
-{
-    struct d3dkmt_object *object;
-    NTSTATUS status;
-    int fd;
-
-    TRACE( "local %#x\n", local );
-
-    if (!(object = get_d3dkmt_object( local, -1 ))) return -1;
-    if ((status = wine_server_handle_to_fd( object->handle, GENERIC_ALL, &fd, NULL )))
-    {
-        WARN( "Failed to receive object %p/%#x fd, status %#x\n", object, local, status );
-        return -1;
-    }
-
-    return fd;
-}
-
-/* create a D3DKMT global or shared resource from a host-specific fd */
-D3DKMT_HANDLE d3dkmt_create_resource( int fd, D3DKMT_HANDLE *global )
+/* create a D3DKMT global or shared resource */
+D3DKMT_HANDLE d3dkmt_create_resource( D3DKMT_HANDLE *global )
 {
     struct d3dkmt_resource *resource = NULL;
     struct d3dkmt_object *allocation = NULL;
     NTSTATUS status;
 
-    TRACE( "fd %d, global %p\n", fd, global );
+    TRACE( "global %p\n", global );
 
     if ((status = d3dkmt_object_alloc( sizeof(*resource), D3DKMT_RESOURCE, (void **)&resource ))) goto failed;
     if ((status = d3dkmt_object_alloc( sizeof(*allocation), D3DKMT_ALLOCATION, (void **)&allocation ))) goto failed;
-    if ((status = d3dkmt_object_create( &resource->obj, fd, !global, NULL, 0 ))) goto failed;
+    if ((status = d3dkmt_object_create( &resource->obj, !global, NULL, 0 ))) goto failed;
 
     if ((status = alloc_object_handle( allocation ))) goto failed;
     resource->allocation = allocation->local;
@@ -1763,7 +1744,7 @@ D3DKMT_HANDLE d3dkmt_create_sync( D3DKMT_HANDLE *global )
     TRACE( "global %p\n", global );
 
     if ((status = d3dkmt_object_alloc( sizeof(*sync), D3DKMT_SYNC, (void **)&sync ))) goto failed;
-    if ((status = d3dkmt_object_create( sync, -1, !global, NULL, 0 ))) goto failed;
+    if ((status = d3dkmt_object_create( sync, !global, NULL, 0 ))) goto failed;
     if (global) *global = sync->global;
     return sync->local;
 
diff --git b/dlls/win32u/tests/d3dkmt.c a/dlls/win32u/tests/d3dkmt.c
index 0987403efe9..ba25286642e 100644
--- b/dlls/win32u/tests/d3dkmt.c
+++ a/dlls/win32u/tests/d3dkmt.c
@@ -3330,7 +3330,6 @@ static struct vulkan_device *create_vulkan_device( LUID *luid )
     struct vulkan_device *dev;
     float priority = 0.0f;
     uint32_t count;
-    BOOL is_wow64;
     VkResult vr;
 
     dev = calloc( 1, sizeof(*dev) );
@@ -3396,17 +3395,7 @@ static struct vulkan_device *create_vulkan_device( LUID *luid )
 
     p_vkCreateDevice = (void *)p_vkGetInstanceProcAddr( dev->instance, "vkCreateDevice" );
     vr = p_vkCreateDevice( dev->physical_device, &create_info, NULL, &dev->device );
-    /* currently fails on llvmpipe on WOW64 without placed memory */
-    todo_wine_if(IsWow64Process(GetCurrentProcess(), &is_wow64) && is_wow64 && vr == VK_ERROR_EXTENSION_NOT_PRESENT)
     ok_vk( VK_SUCCESS, vr );
-    if (vr != VK_SUCCESS)
-    {
-        PFN_vkDestroyInstance p_vkDestroyInstance;
-        p_vkDestroyInstance = (void *)p_vkGetInstanceProcAddr( dev->instance, "vkDestroyInstance" );
-        p_vkDestroyInstance( dev->instance, NULL );
-        free( dev );
-        return NULL;
-    }
     ok_ptr( dev->device, !=, VK_NULL_HANDLE );
 
     return dev;
@@ -4648,42 +4637,36 @@ static void test_shared_resources(void)
 
         case MAKETEST(4, 0, 0):
         {
-            if (!vulkan_exp) break;
             buf = export_vulkan_buffer( vulkan_exp, resource_size, NULL, VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT, &handle );
             get_d3dkmt_resource_desc( luid, handle, FALSE, 0, runtime_desc );
             break;
         }
         case MAKETEST(4, 0, 1):
         {
-            if (!vulkan_exp) break;
             buf = export_vulkan_buffer( vulkan_exp, resource_size, NULL, VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT, &handle );
             get_d3dkmt_resource_desc( luid, handle, TRUE, 0, runtime_desc );
             break;
         }
         case MAKETEST(4, 1, 0):
         {
-            if (!vulkan_exp) break;
             img = export_vulkan_image( vulkan_exp, width_1d, 1, array_1d, NULL, VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT, &handle );
             get_d3dkmt_resource_desc( luid, handle, FALSE, 0, runtime_desc );
             break;
         }
         case MAKETEST(4, 2, 0):
         {
-            if (!vulkan_exp) break;
             img = export_vulkan_image( vulkan_exp, width_2d, height_2d, 1, NULL, VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT, &handle );
             get_d3dkmt_resource_desc( luid, handle, FALSE, 0, runtime_desc );
             break;
         }
         case MAKETEST(4, 2, 1):
         {
-            if (!vulkan_exp) break;
             img = export_vulkan_image( vulkan_exp, width_2d, height_2d, 1, NULL, VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT, &handle );
             get_d3dkmt_resource_desc( luid, handle, TRUE, 0, runtime_desc );
             break;
         }
         case MAKETEST(4, 3, 0):
         {
-            if (!vulkan_exp) break;
             img = export_vulkan_image( vulkan_exp, width_3d, height_3d, depth_3d, NULL, VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT, &handle );
             get_d3dkmt_resource_desc( luid, handle, FALSE, 0, runtime_desc );
             break;
@@ -4835,18 +4818,17 @@ static void test_shared_resources(void)
         {
             hr = ID3D12Device_OpenSharedHandle( d3d12_imp, handle, &IID_ID3D12Resource, (void **)&import );
             ok_hr( S_OK, hr );
-            ok_ptr( import, !=, NULL );
             if (import) ok_ref( 0, IUnknown_Release( import ) );
 
             if (name)
             {
-                HANDLE other = 0;
+                HANDLE other;
 
                 hr = ID3D12Device_OpenSharedHandleByName( d3d12_imp, name, GENERIC_ALL, &other );
                 ok_hr( S_OK, hr );
                 hr = ID3D12Device_OpenSharedHandle( d3d12_imp, other, &IID_ID3D12Resource, (void **)&import );
                 ok_hr( S_OK, hr );
-                if (other) CloseHandle( other );
+                CloseHandle( other );
 
                 if (import) ok_ref( 0, IUnknown_Release( import ) );
             }
diff --git b/dlls/win32u/vulkan.c a/dlls/win32u/vulkan.c
index bb660fd5d0c..cb6684fc7f6 100644
--- b/dlls/win32u/vulkan.c
+++ a/dlls/win32u/vulkan.c
@@ -26,7 +26,6 @@
 
 #include <dlfcn.h>
 #include <pthread.h>
-#include <unistd.h>
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -228,8 +227,8 @@ static void init_shared_resource_path( const WCHAR *name, UNICODE_STRING *str )
     str->Length = str->MaximumLength - sizeof(WCHAR);
 
     memcpy( str->Buffer + str->Length / sizeof(WCHAR), name, (len + 1) * sizeof(WCHAR) );
-    str->MaximumLength += len * sizeof(WCHAR);
-    str->Length += len * sizeof(WCHAR);
+    str->MaximumLength += len;
+    str->Length += len;
 }
 
 static HANDLE create_shared_resource_handle( D3DKMT_HANDLE local, const VkExportMemoryWin32HandleInfoKHR *info )
@@ -270,7 +269,6 @@ static HANDLE open_shared_resource_from_name( const WCHAR *name )
 static VkResult win32u_vkAllocateMemory( VkDevice client_device, const VkMemoryAllocateInfo *client_alloc_info,
                                          const VkAllocationCallbacks *allocator, VkDeviceMemory *ret )
 {
-    VkImportMemoryFdInfoKHR fd_info = {.sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR};
     VkMemoryAllocateInfo *alloc_info = (VkMemoryAllocateInfo *)client_alloc_info; /* cast away const, chain has been copied in the thunks */
     VkBaseOutStructure **next, *prev = (VkBaseOutStructure *)alloc_info;
     struct vulkan_device *device = vulkan_device_from_handle( client_device );
@@ -356,15 +354,13 @@ static VkResult win32u_vkAllocateMemory( VkDevice client_device, const VkMemoryA
             break;
         }
 
-        if ((fd_info.fd = d3dkmt_object_get_fd( memory->local )) < 0)
+        if (!memory->local)
         {
             free( memory );
             return VK_ERROR_INVALID_EXTERNAL_HANDLE;
         }
 
-        fd_info.handleType = get_host_external_memory_type();
-        fd_info.pNext = alloc_info->pNext;
-        alloc_info->pNext = &fd_info;
+        FIXME( "Importing memory handle not yet implemented!\n" );
     }
 
     if ((res = device->p_vkAllocateMemory( device->host.device, alloc_info, NULL, &host_device_memory )))
@@ -376,27 +372,9 @@ static VkResult win32u_vkAllocateMemory( VkDevice client_device, const VkMemoryA
 
     if (export_info)
     {
-        if (!memory->local)
-        {
-            VkMemoryGetFdInfoKHR get_fd_info = {.sType = VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR, .memory = host_device_memory};
-            int fd = -1;
-
-            switch ((get_fd_info.handleType = get_host_external_memory_type()))
-            {
-            case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT:
-            case VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT:
-                if ((res = device->p_vkGetMemoryFdKHR( device->host.device, &get_fd_info, &fd ))) goto failed;
-                break;
-            default:
-                FIXME( "Unsupported handle type %#x\n", get_fd_info.handleType );
-                break;
-            }
+        FIXME( "Exporting memory handle not yet implemented!\n" );
 
-            memory->local = d3dkmt_create_resource( fd, nt_shared ? NULL : &memory->global );
-            close( fd );
-
-            if (!memory->local) goto failed;
-        }
+        if (!memory->local && !(memory->local = d3dkmt_create_resource( nt_shared ? NULL : &memory->global ))) goto failed;
         if (nt_shared && !(memory->shared = create_shared_resource_handle( memory->local, &export_win32 ))) goto failed;
     }
 
@@ -409,7 +387,6 @@ static VkResult win32u_vkAllocateMemory( VkDevice client_device, const VkMemoryA
     return VK_SUCCESS;
 
 failed:
-    WARN( "Failed to allocate memory, res %d\n", res );
     device->p_vkFreeMemory( device->host.device, host_device_memory, NULL );
     if (memory->local) d3dkmt_destroy_resource( memory->local );
     free( memory );
diff --git b/dlls/win32u/win32u_private.h a/dlls/win32u/win32u_private.h
index 99762011ba0..4d4570f06f5 100644
--- b/dlls/win32u/win32u_private.h
+++ a/dlls/win32u/win32u_private.h
@@ -205,9 +205,7 @@ extern BOOL get_vulkan_gpus( struct list *gpus );
 extern void free_vulkan_gpu( struct vulkan_gpu *gpu );
 extern BOOL get_vulkan_uuid_from_luid( const LUID *luid, GUID *uuid );
 
-extern int d3dkmt_object_get_fd( D3DKMT_HANDLE local );
-
-extern D3DKMT_HANDLE d3dkmt_create_resource( int fd, D3DKMT_HANDLE *global );
+extern D3DKMT_HANDLE d3dkmt_create_resource( D3DKMT_HANDLE *global );
 extern D3DKMT_HANDLE d3dkmt_open_resource( D3DKMT_HANDLE global, HANDLE shared );
 extern NTSTATUS d3dkmt_destroy_resource( D3DKMT_HANDLE local );
 
diff --git b/dlls/winevulkan/make_vulkan a/dlls/winevulkan/make_vulkan
index 48a0134a092..22cca40f15b 100755
--- b/dlls/winevulkan/make_vulkan
+++ a/dlls/winevulkan/make_vulkan
@@ -2989,7 +2989,7 @@ class VkGenerator(object):
         # Note: unions are stored in structs for dependency reasons,
         # see comment in parsing section.
         for struct in self.registry.structs:
-            if struct.required and struct.name != "SECURITY_ATTRIBUTES":
+            if struct.required:
                 LOGGER.debug("Generating struct: {0}".format(struct.name))
                 f.write(struct.definition(align=True))
                 f.write("\n")
@@ -3128,7 +3128,6 @@ class VkRegistry(object):
         self.video_copyright = video_root.find('./comment').text
 
         root.extend(video_root)
-        root.extend(ET.parse("winevk.xml").getroot())
 
         self._parse_enums(root)
         self._parse_types(root)
diff --git b/dlls/winevulkan/vulkan.c a/dlls/winevulkan/vulkan.c
index 3ff313e5b83..04b2085ac9b 100644
--- b/dlls/winevulkan/vulkan.c
+++ a/dlls/winevulkan/vulkan.c
@@ -398,6 +398,31 @@ static VkResult vulkan_physical_device_init(struct vulkan_physical_device *physi
         goto err;
     }
 
+    for (i = 0, j = 0; i < num_host_properties; i++)
+    {
+        if (!strcmp(host_properties[i].extensionName, vk_funcs->p_get_host_extension("VK_KHR_external_memory_win32")))
+        {
+            strcpy(physical_device->extensions[j].extensionName, "VK_KHR_external_memory_win32");
+            physical_device->extensions[j++].specVersion = VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION;
+        }
+        else if (!strcmp(host_properties[i].extensionName, vk_funcs->p_get_host_extension("VK_KHR_external_semaphore_win32")))
+        {
+            strcpy(physical_device->extensions[j].extensionName, "VK_KHR_external_semaphore_win32");
+            physical_device->extensions[j++].specVersion = VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION;
+        }
+        else if (!strcmp(host_properties[i].extensionName, vk_funcs->p_get_host_extension("VK_KHR_external_fence_win32")))
+        {
+            strcpy(physical_device->extensions[j].extensionName, "VK_KHR_external_fence_win32");
+            physical_device->extensions[j++].specVersion = VK_KHR_EXTERNAL_FENCE_WIN32_SPEC_VERSION;
+        }
+        else if (wine_vk_device_extension_supported(host_properties[i].extensionName))
+        {
+            physical_device->extensions[j] = host_properties[i];
+            j++;
+        }
+    }
+    physical_device->extension_count = num_properties;
+
     if (zero_bits && have_memory_placed && have_map_memory2)
     {
         VkPhysicalDeviceMapMemoryPlacedFeaturesEXT map_placed_feature =
@@ -447,36 +472,6 @@ static VkResult vulkan_physical_device_init(struct vulkan_physical_device *physi
                   physical_device->external_memory_align);
     }
 
-    for (i = 0, j = 0; i < num_host_properties; i++)
-    {
-        if (!strcmp(host_properties[i].extensionName, vk_funcs->p_get_host_extension("VK_KHR_external_memory_win32")))
-        {
-            if (zero_bits && !physical_device->map_placed_align)
-            {
-                WARN("Cannot export WOW64 memory without VK_EXT_map_memory_placed\n");
-                continue;
-            }
-            strcpy(physical_device->extensions[j].extensionName, "VK_KHR_external_memory_win32");
-            physical_device->extensions[j++].specVersion = VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION;
-        }
-        else if (!strcmp(host_properties[i].extensionName, vk_funcs->p_get_host_extension("VK_KHR_external_semaphore_win32")))
-        {
-            strcpy(physical_device->extensions[j].extensionName, "VK_KHR_external_semaphore_win32");
-            physical_device->extensions[j++].specVersion = VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION;
-        }
-        else if (!strcmp(host_properties[i].extensionName, vk_funcs->p_get_host_extension("VK_KHR_external_fence_win32")))
-        {
-            strcpy(physical_device->extensions[j].extensionName, "VK_KHR_external_fence_win32");
-            physical_device->extensions[j++].specVersion = VK_KHR_EXTERNAL_FENCE_WIN32_SPEC_VERSION;
-        }
-        else if (wine_vk_device_extension_supported(host_properties[i].extensionName))
-        {
-            physical_device->extensions[j] = host_properties[i];
-            j++;
-        }
-    }
-    physical_device->extension_count = j;
-
     free(host_properties);
     return VK_SUCCESS;
 
@@ -595,11 +590,6 @@ static VkResult wine_vk_device_convert_create_info(struct vulkan_physical_device
         if (!strcmp(*extension, "VK_KHR_swapchain")) has_swapchain = true;
         if (!strcmp(*extension, "VK_KHR_external_memory_win32"))
         {
-            if (zero_bits && !physical_device->map_placed_align)
-            {
-                FIXME("Cannot export WOW64 memory without VK_EXT_map_memory_placed\n");
-                return VK_ERROR_EXTENSION_NOT_PRESENT;
-            }
             device->has_external_memory_win32 = true;
             *extension = vk_funcs->p_get_host_extension("VK_KHR_external_memory_win32");
             if (!strcmp(*extension, "VK_EXT_external_memory_dma_buf")) extensions[count++] = "VK_KHR_external_memory_fd";
diff --git b/dlls/winevulkan/vulkan_thunks.c a/dlls/winevulkan/vulkan_thunks.c
index ba79adb23db..f2ceb7b7fed 100644
--- b/dlls/winevulkan/vulkan_thunks.c
+++ a/dlls/winevulkan/vulkan_thunks.c
@@ -578,13 +578,6 @@ typedef struct VkVideoPictureResourceInfoKHR32
     VkImageView DECLSPEC_ALIGN(8) imageViewBinding;
 } VkVideoPictureResourceInfoKHR32;
 
-typedef struct SECURITY_ATTRIBUTES32
-{
-    DWORD nLength;
-    PTR32 lpSecurityDescriptor;
-    BOOL bInheritHandle;
-} SECURITY_ATTRIBUTES32;
-
 typedef struct StdVideoAV1SequenceHeader32
 {
     StdVideoAV1SequenceHeaderFlags flags;
@@ -9965,31 +9958,6 @@ static void convert_VkMemoryAllocateInfo_win64_to_host(struct conversion_context
 }
 #endif /* _WIN64 */
 
-static void convert_SECURITY_ATTRIBUTES_win32_to_host(const SECURITY_ATTRIBUTES32 *in, SECURITY_ATTRIBUTES *out)
-{
-    if (!in) return;
-
-    out->nLength = in->nLength;
-    out->lpSecurityDescriptor = UlongToPtr(in->lpSecurityDescriptor);
-    out->bInheritHandle = in->bInheritHandle;
-}
-
-static const SECURITY_ATTRIBUTES *convert_SECURITY_ATTRIBUTES_array_win32_to_host(struct conversion_context *ctx, const SECURITY_ATTRIBUTES32 *in, uint32_t count)
-{
-    SECURITY_ATTRIBUTES *out;
-    unsigned int i;
-
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
-    {
-        convert_SECURITY_ATTRIBUTES_win32_to_host(&in[i], &out[i]);
-    }
-
-    return out;
-}
-
 static void convert_VkMemoryAllocateInfo_win32_to_host(struct conversion_context *ctx, const VkMemoryAllocateInfo32 *in, VkMemoryAllocateInfo *out)
 {
     const VkBaseInStructure32 *in_header;
@@ -10035,7 +10003,7 @@ static void convert_VkMemoryAllocateInfo_win32_to_host(struct conversion_context
             const VkExportMemoryWin32HandleInfoKHR32 *in_ext = (const VkExportMemoryWin32HandleInfoKHR32 *)in_header;
             out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
             out_ext->pNext = NULL;
-            out_ext->pAttributes = convert_SECURITY_ATTRIBUTES_array_win32_to_host(ctx, (const SECURITY_ATTRIBUTES32 *)UlongToPtr(in_ext->pAttributes), 1);
+            out_ext->pAttributes = UlongToPtr(in_ext->pAttributes);
             out_ext->dwAccess = in_ext->dwAccess;
             out_ext->name = (LPCWSTR)UlongToPtr(in_ext->name);
             out_header->pNext = (void *)out_ext;
@@ -22531,7 +22499,7 @@ static void convert_VkFenceCreateInfo_win32_to_host(struct conversion_context *c
             const VkExportFenceWin32HandleInfoKHR32 *in_ext = (const VkExportFenceWin32HandleInfoKHR32 *)in_header;
             out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR;
             out_ext->pNext = NULL;
-            out_ext->pAttributes = convert_SECURITY_ATTRIBUTES_array_win32_to_host(ctx, (const SECURITY_ATTRIBUTES32 *)UlongToPtr(in_ext->pAttributes), 1);
+            out_ext->pAttributes = UlongToPtr(in_ext->pAttributes);
             out_ext->dwAccess = in_ext->dwAccess;
             out_ext->name = (LPCWSTR)UlongToPtr(in_ext->name);
             out_header->pNext = (void *)out_ext;
@@ -26422,7 +26390,7 @@ static void convert_VkSemaphoreCreateInfo_win32_to_host(struct conversion_contex
             const VkExportSemaphoreWin32HandleInfoKHR32 *in_ext = (const VkExportSemaphoreWin32HandleInfoKHR32 *)in_header;
             out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;
             out_ext->pNext = NULL;
-            out_ext->pAttributes = convert_SECURITY_ATTRIBUTES_array_win32_to_host(ctx, (const SECURITY_ATTRIBUTES32 *)UlongToPtr(in_ext->pAttributes), 1);
+            out_ext->pAttributes = UlongToPtr(in_ext->pAttributes);
             out_ext->dwAccess = in_ext->dwAccess;
             out_ext->name = (LPCWSTR)UlongToPtr(in_ext->name);
             out_header->pNext = (void *)out_ext;
diff --git b/dlls/winevulkan/winevk.xml a/dlls/winevulkan/winevk.xml
deleted file mode 100644
index 58421b063e0..00000000000
--- b/dlls/winevulkan/winevk.xml
+++ /dev/null
@@ -1,11 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<registry>
-    <types>
-        <type requires="windows.h" name="BOOL"/>
-        <type category="struct" name="SECURITY_ATTRIBUTES">
-            <member><type>DWORD</type> <name>nLength</name></member>
-            <member><type>void</type>* <name>lpSecurityDescriptor</name></member>
-            <member><type>BOOL</type> <name>bInheritHandle</name></member>
-        </type>
-    </types>
-</registry>
diff --git b/include/wine/server.h a/include/wine/server.h
index d982675d603..458c33c27b5 100644
--- b/include/wine/server.h
+++ a/include/wine/server.h
@@ -49,7 +49,6 @@ struct __server_request_info
     struct __server_iovec data[__SERVER_MAX_DATA];  /* request variable size data */
 };
 
-NTSYSAPI void CDECL wine_server_send_fd( int fd );
 NTSYSAPI unsigned int CDECL wine_server_call( void *req_ptr );
 NTSYSAPI NTSTATUS CDECL wine_server_fd_to_handle( int fd, unsigned int access, unsigned int attributes, HANDLE *handle );
 NTSYSAPI NTSTATUS CDECL wine_server_handle_to_fd( HANDLE handle, unsigned int access, int *unix_fd, unsigned int *options );
diff --git b/include/wine/server_protocol.h a/include/wine/server_protocol.h
index 3f6ddbb39e2..d9f1099f154 100644
--- b/include/wine/server_protocol.h
+++ a/include/wine/server_protocol.h
@@ -6014,9 +6014,7 @@ struct d3dkmt_object_create_request
 {
     struct request_header __header;
     unsigned int        type;
-    int                 fd;
     /* VARARG(runtime,bytes); */
-    char __pad_20[4];
 };
 struct d3dkmt_object_create_reply
 {
@@ -6032,8 +6030,8 @@ struct d3dkmt_object_update_request
     struct request_header __header;
     unsigned int        type;
     d3dkmt_handle_t     global;
+    obj_handle_t        handle;
     /* VARARG(runtime,bytes); */
-    char __pad_20[4];
 };
 struct d3dkmt_object_update_reply
 {
diff --git b/server/d3dkmt.c a/server/d3dkmt.c
index 4d30ec65966..c253740a7bb 100644
--- b/server/d3dkmt.c
+++ a/server/d3dkmt.c
@@ -42,11 +42,9 @@ struct d3dkmt_object
     d3dkmt_handle_t     global;         /* object global handle */
     void               *runtime;        /* client runtime data */
     data_size_t         runtime_size;   /* size of client runtime data */
-    struct fd          *fd;             /* fd object for unix fds */
 };
 
 static void d3dkmt_object_dump( struct object *obj, int verbose );
-static struct fd *d3dkmt_object_get_fd( struct object *obj );
 static void d3dkmt_object_destroy( struct object *obj );
 
 static const struct object_ops d3dkmt_object_ops =
@@ -59,7 +57,7 @@ static const struct object_ops d3dkmt_object_ops =
     NULL,                           /* signaled */
     NULL,                           /* satisfied */
     no_signal,                      /* signal */
-    d3dkmt_object_get_fd,           /* get_fd */
+    no_get_fd,                      /* get_fd */
     default_get_sync,               /* get_sync */
     default_map_access,             /* map_access */
     default_get_sd,                 /* get_sd */
@@ -74,27 +72,6 @@ static const struct object_ops d3dkmt_object_ops =
     d3dkmt_object_destroy,          /* destroy */
 };
 
-static enum server_fd_type d3dkmt_get_fd_type( struct fd *fd )
-{
-    return FD_TYPE_INVALID;
-}
-
-static const struct fd_ops d3dkmt_fd_ops =
-{
-    default_fd_get_poll_events,   /* get_poll_events */
-    default_poll_event,           /* poll_event */
-    d3dkmt_get_fd_type,           /* get_fd_type */
-    no_fd_read,                   /* read */
-    no_fd_write,                  /* write */
-    no_fd_flush,                  /* flush */
-    no_fd_get_file_info,          /* get_file_info */
-    no_fd_get_volume_info,        /* get_volume_info */
-    no_fd_ioctl,                  /* ioctl */
-    default_fd_cancel_async,      /* cancel_async */
-    no_fd_queue_async,            /* queue_async */
-    default_fd_reselect_async     /* reselect_async */
-};
-
 #define DXGK_SHARED_SYNC_QUERY_STATE  0x0001
 #define DXGK_SHARED_SYNC_MODIFY_STATE 0x0002
 #define DXGK_SHARED_SYNC_ALL_ACCESS   (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3)
@@ -329,24 +306,12 @@ static void d3dkmt_object_dump( struct object *obj, int verbose )
     fprintf( stderr, "type=%#x global=%#x\n", object->type, object->global );
 }
 
-static struct fd *d3dkmt_object_get_fd( struct object *obj )
-{
-    struct d3dkmt_object *object = (struct d3dkmt_object *)obj;
-    assert( obj->ops == &d3dkmt_object_ops );
-
-    if (object->fd) return (struct fd *)grab_object( object->fd );
-
-    set_error( STATUS_NO_SUCH_FILE );
-    return NULL;
-}
-
 static void d3dkmt_object_destroy( struct object *obj )
 {
     struct d3dkmt_object *object = (struct d3dkmt_object *)obj;
     assert( obj->ops == &d3dkmt_object_ops );
 
     if (object->global) free_object_handle( object->global );
-    if (object->fd) release_object( object->fd );
     free( object->runtime );
 }
 
@@ -358,7 +323,6 @@ static struct d3dkmt_object *d3dkmt_object_create( enum d3dkmt_type type, data_s
     object->type            = type;
     object->global          = 0;
     object->runtime_size    = runtime_size;
-    object->fd              = NULL;
 
     if (!(object->runtime = memdup( runtime, runtime_size )) ||
         !(object->global = alloc_object_handle( object )))
@@ -417,28 +381,11 @@ static struct d3dkmt_object *d3dkmt_object_open_shared( obj_handle_t handle, enu
 DECL_HANDLER(d3dkmt_object_create)
 {
     struct d3dkmt_object *object;
-    struct fd *fd = NULL;
-
-    if (req->fd >= 0)
-    {
-        int unix_fd;
-        if ((unix_fd = thread_get_inflight_fd( current, req->fd )) < 0) return;
-        if (!(fd = create_anonymous_fd( NULL, unix_fd, NULL, 0 ))) return;
-    }
-
-    if (!(object = d3dkmt_object_create( req->type, get_req_data_size(), get_req_data() ))) goto done;
-    if (fd)
-    {
-        set_fd_user( fd, &d3dkmt_fd_ops, &object->obj );
-        object->fd = (struct fd *)grab_object( fd );
-    }
 
+    if (!(object = d3dkmt_object_create( req->type, get_req_data_size(), get_req_data() ))) return;
     reply->handle = alloc_handle( current->process, object, STANDARD_RIGHTS_ALL, OBJ_INHERIT );
     reply->global = object->global;
     release_object( object );
-
-done:
-    if (fd) release_object( fd );
 }
 
 /* update a global d3dkmt object */
@@ -451,7 +398,10 @@ DECL_HANDLER(d3dkmt_object_update)
     if (!(size = get_req_data_size())) runtime = NULL;
     else if (!(runtime = memdup( get_req_data(), size ))) return;
 
-    if (!(object = d3dkmt_object_open( req->global, req->type ))) goto done;
+    if (req->global) object = d3dkmt_object_open( req->global, req->type );
+    else object = d3dkmt_object_open_shared( req->handle, req->type );
+    if (!object) goto done;
+
     tmp = object->runtime;
     object->runtime = runtime;
     object->runtime_size = size;
diff --git b/server/protocol.def a/server/protocol.def
index 5a102060160..87b8730f92a 100644
--- b/server/protocol.def
+++ a/server/protocol.def
@@ -4177,7 +4177,6 @@ enum inproc_sync_type
 /* Create a global d3dkmt object */
 @REQ(d3dkmt_object_create)
     unsigned int        type;           /* d3dkmt object type */
-    int                 fd;             /* host specific fd */
     VARARG(runtime,bytes);              /* client runtime data */
 @REPLY
     d3dkmt_handle_t     global;         /* global d3dkmt handle */
@@ -4189,6 +4188,7 @@ enum inproc_sync_type
 @REQ(d3dkmt_object_update)
     unsigned int        type;           /* d3dkmt object type */
     d3dkmt_handle_t     global;         /* global d3dkmt handle */
+    obj_handle_t        handle;         /* shared object handle */
     VARARG(runtime,bytes);              /* client runtime data */
 @END
 
diff --git b/server/request_handlers.h a/server/request_handlers.h
index c7cc0545242..6bef45d4ff9 100644
--- b/server/request_handlers.h
+++ a/server/request_handlers.h
@@ -2310,13 +2310,13 @@ C_ASSERT( sizeof(struct get_inproc_alert_fd_request) == 16 );
 C_ASSERT( offsetof(struct get_inproc_alert_fd_reply, handle) == 8 );
 C_ASSERT( sizeof(struct get_inproc_alert_fd_reply) == 16 );
 C_ASSERT( offsetof(struct d3dkmt_object_create_request, type) == 12 );
-C_ASSERT( offsetof(struct d3dkmt_object_create_request, fd) == 16 );
-C_ASSERT( sizeof(struct d3dkmt_object_create_request) == 24 );
+C_ASSERT( sizeof(struct d3dkmt_object_create_request) == 16 );
 C_ASSERT( offsetof(struct d3dkmt_object_create_reply, global) == 8 );
 C_ASSERT( offsetof(struct d3dkmt_object_create_reply, handle) == 12 );
 C_ASSERT( sizeof(struct d3dkmt_object_create_reply) == 16 );
 C_ASSERT( offsetof(struct d3dkmt_object_update_request, type) == 12 );
 C_ASSERT( offsetof(struct d3dkmt_object_update_request, global) == 16 );
+C_ASSERT( offsetof(struct d3dkmt_object_update_request, handle) == 20 );
 C_ASSERT( sizeof(struct d3dkmt_object_update_request) == 24 );
 C_ASSERT( offsetof(struct d3dkmt_object_query_request, type) == 12 );
 C_ASSERT( offsetof(struct d3dkmt_object_query_request, global) == 16 );
diff --git b/server/request_trace.h a/server/request_trace.h
index 4171d432dc2..8090f80eb76 100644
--- b/server/request_trace.h
+++ a/server/request_trace.h
@@ -3396,7 +3396,6 @@ static void dump_get_inproc_alert_fd_reply( const struct get_inproc_alert_fd_rep
 static void dump_d3dkmt_object_create_request( const struct d3dkmt_object_create_request *req )
 {
     fprintf( stderr, " type=%08x", req->type );
-    fprintf( stderr, ", fd=%d", req->fd );
     dump_varargs_bytes( ", runtime=", cur_size );
 }
 
@@ -3410,6 +3409,7 @@ static void dump_d3dkmt_object_update_request( const struct d3dkmt_object_update
 {
     fprintf( stderr, " type=%08x", req->type );
     fprintf( stderr, ", global=%08x", req->global );
+    fprintf( stderr, ", handle=%04x", req->handle );
     dump_varargs_bytes( ", runtime=", cur_size );
 }
 
diff --git b/dlls/win32u/vulkan.c a/dlls/win32u/vulkan.c
index 5a9a31410be..441009f50e3 100644
--- b/dlls/win32u/vulkan.c
+++ a/dlls/win32u/vulkan.c
@@ -55,8 +55,6 @@ static const UINT EXTERNAL_MEMORY_WIN32_BITS = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OP
 static const UINT EXTERNAL_SEMAPHORE_WIN32_BITS = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT |
                                                   VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT |
                                                   VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT;
-static const UINT EXTERNAL_FENCE_WIN32_BITS = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT |
-                                              VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT;
 
 struct device_memory
 {
@@ -118,9 +116,6 @@ static struct semaphore *semaphore_from_handle( VkSemaphore handle )
 struct fence
 {
     struct vulkan_fence obj;
-    D3DKMT_HANDLE local;
-    D3DKMT_HANDLE global;
-    HANDLE shared;
 };
 
 static struct fence *fence_from_handle( VkFence handle )
@@ -208,14 +203,6 @@ static VkExternalSemaphoreHandleTypeFlagBits get_host_external_semaphore_type(vo
     return 0;
 }
 
-static VkExternalFenceHandleTypeFlagBits get_host_external_fence_type(void)
-{
-    const char *host_extension = driver_funcs->p_get_host_extension( "VK_KHR_external_fence_win32" );
-    if (!strcmp( host_extension, "VK_KHR_external_fence_fd" )) return VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT;
-    if (!strcmp( host_extension, "VK_KHR_external_fence_capabilities" )) return VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT;
-    return 0;
-}
-
 static void init_shared_resource_path( const WCHAR *name, UNICODE_STRING *str )
 {
     UINT len = wcslen( name );
@@ -1593,11 +1580,8 @@ static VkResult win32u_vkCreateFence( VkDevice client_device, const VkFenceCreat
 {
     VkFenceCreateInfo *create_info = (VkFenceCreateInfo *)client_create_info; /* cast away const, chain has been copied in the thunks */
     struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    VkExportSemaphoreWin32HandleInfoKHR export_win32 = {.dwAccess = GENERIC_ALL};
     VkBaseOutStructure **next, *prev = (VkBaseOutStructure *)create_info;
     struct vulkan_instance *instance = device->physical_device->instance;
-    VkExportFenceCreateInfoKHR *export_info = NULL;
-    BOOL nt_shared = FALSE;
     struct fence *fence;
     VkFence host_fence;
     VkResult res;
@@ -1609,25 +1593,13 @@ static VkResult win32u_vkCreateFence( VkDevice client_device, const VkFenceCreat
         switch ((*next)->sType)
         {
         case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
-            export_info = (VkExportFenceCreateInfoKHR *)*next;
-            if (!(export_info->handleTypes & EXTERNAL_FENCE_WIN32_BITS))
-                FIXME( "Unsupported handle types %#x\n", export_info->handleTypes );
-            else
-            {
-                nt_shared = !(export_info->handleTypes & VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT);
-                export_info->handleTypes = get_host_external_fence_type();
-            }
+            FIXME( "VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO not implemented.\n" );
             *next = (*next)->pNext; next = &prev;
             break;
         case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
-        {
-            VkExportFenceWin32HandleInfoKHR *fence_win32 = (VkExportFenceWin32HandleInfoKHR *)*next;
-            export_win32.pAttributes = fence_win32->pAttributes;
-            export_win32.dwAccess = fence_win32->dwAccess;
-            export_win32.name = fence_win32->name;
+            FIXME( "VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR not implemented.\n" );
             *next = (*next)->pNext; next = &prev;
             break;
-        }
         default: FIXME( "Unhandled sType %u.\n", (*next)->sType ); break;
         }
     }
@@ -1640,25 +1612,11 @@ static VkResult win32u_vkCreateFence( VkDevice client_device, const VkFenceCreat
         return res;
     }
 
-    if (export_info)
-    {
-        FIXME( "Exporting fence handle not yet implemented!\n" );
-
-        if (!(fence->local = d3dkmt_create_sync( nt_shared ? NULL : &fence->global ))) goto failed;
-        if (nt_shared && !(fence->shared = create_shared_semaphore_handle( fence->local, &export_win32 ))) goto failed;
-    }
-
     vulkan_object_init( &fence->obj.obj, host_fence );
     instance->p_insert_object( instance, &fence->obj.obj );
 
     *ret = fence->obj.client.fence;
     return res;
-
-failed:
-    device->p_vkDestroyFence( device->host.device, host_fence, NULL );
-    if (fence->local) d3dkmt_destroy_sync( fence->local );
-    free( fence );
-    return VK_ERROR_OUT_OF_HOST_MEMORY;
 }
 
 static void win32u_vkDestroyFence( VkDevice client_device, VkFence client_fence, const VkAllocationCallbacks *allocator )
@@ -1674,104 +1632,36 @@ static void win32u_vkDestroyFence( VkDevice client_device, VkFence client_fence,
     device->p_vkDestroyFence( device->host.device, fence->obj.host.fence, NULL /* allocator */ );
     instance->p_remove_object( instance, &fence->obj.obj );
 
-    if (fence->shared) NtClose( fence->shared );
-    if (fence->local) d3dkmt_destroy_sync( fence->local );
     free( fence );
 }
 
 static VkResult win32u_vkGetFenceWin32HandleKHR( VkDevice client_device, const VkFenceGetWin32HandleInfoKHR *handle_info, HANDLE *handle )
 {
     struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    struct fence *fence = fence_from_handle( handle_info->fence );
-
-    TRACE( "device %p, handle_info %p, handle %p\n", device, handle_info, handle );
-
-    switch (handle_info->handleType)
-    {
-    case VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
-        TRACE( "Returning global D3DKMT handle %#x\n", fence->global );
-        *handle = UlongToPtr( fence->global );
-        return VK_SUCCESS;
 
-    case VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT:
-        NtDuplicateObject( NtCurrentProcess(), fence->shared, NtCurrentProcess(), handle, 0, 0, DUPLICATE_SAME_ATTRIBUTES | DUPLICATE_SAME_ACCESS );
-        TRACE( "Returning NT shared handle %p -> %p\n", fence->shared, *handle );
-        return VK_SUCCESS;
+    FIXME( "device %p, handle_info %p, handle %p stub!\n", device, handle_info, handle );
 
-    default:
-        FIXME( "Unsupported handle type %#x\n", handle_info->handleType );
-        return VK_ERROR_INCOMPATIBLE_DRIVER;
-    }
+    return VK_ERROR_INCOMPATIBLE_DRIVER;
 }
 
 static VkResult win32u_vkImportFenceWin32HandleKHR( VkDevice client_device, const VkImportFenceWin32HandleInfoKHR *handle_info )
 {
     struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    struct fence *fence = fence_from_handle( handle_info->fence );
-    D3DKMT_HANDLE local, global = 0;
-    HANDLE shared = NULL;
-
-    TRACE( "device %p, handle_info %p\n", device, handle_info );
 
-    switch (handle_info->handleType)
-    {
-    case VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
-        global = PtrToUlong( handle_info->handle );
-        if (!(local = d3dkmt_open_sync( global, NULL ))) return VK_ERROR_INVALID_EXTERNAL_HANDLE;
-        break;
-    case VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT:
-        if (handle_info->name && !(shared = open_shared_semaphore_from_name( handle_info->name )))
-            return VK_ERROR_INVALID_EXTERNAL_HANDLE;
-        else if (!(shared = handle_info->handle) || NtDuplicateObject( NtCurrentProcess(), shared, NtCurrentProcess(), &shared,
-                                                                       0, 0, DUPLICATE_SAME_ATTRIBUTES | DUPLICATE_SAME_ACCESS ))
-            return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+    FIXME( "device %p, handle_info %p stub!\n", device, handle_info );
 
-        if (!(local = d3dkmt_open_sync( 0, shared )))
-        {
-            NtClose( shared );
-            return VK_ERROR_INVALID_EXTERNAL_HANDLE;
-        }
-        break;
-    default:
-        FIXME( "Unsupported handle type %#x\n", handle_info->handleType );
-        return VK_ERROR_INVALID_EXTERNAL_HANDLE;
-    }
-
-    FIXME( "Importing memory handle not yet implemented!\n" );
-
-    if (handle_info->flags & VK_FENCE_IMPORT_TEMPORARY_BIT)
-    {
-        /* FIXME: Should we still keep the temporary handles for vkGetFenceWin32HandleKHR? */
-        if (shared) NtClose( shared );
-        d3dkmt_destroy_sync( local );
-    }
-    else
-    {
-        if (fence->shared) NtClose( fence->shared );
-        if (fence->local) d3dkmt_destroy_sync( fence->local );
-        fence->shared = shared;
-        fence->global = global;
-        fence->local = local;
-    }
-    return VK_SUCCESS;
+    return VK_ERROR_INCOMPATIBLE_DRIVER;
 }
 
-static void win32u_vkGetPhysicalDeviceExternalFenceProperties( VkPhysicalDevice client_physical_device, const VkPhysicalDeviceExternalFenceInfo *client_fence_info,
+static void win32u_vkGetPhysicalDeviceExternalFenceProperties( VkPhysicalDevice client_physical_device, const VkPhysicalDeviceExternalFenceInfo *fence_info,
                                                                VkExternalFenceProperties *fence_properties )
 {
-    VkPhysicalDeviceExternalFenceInfo *fence_info = (VkPhysicalDeviceExternalFenceInfo *)client_fence_info; /* cast away const, it has been copied in the thunks */
     struct vulkan_physical_device *physical_device = vulkan_physical_device_from_handle( client_physical_device );
     struct vulkan_instance *instance = physical_device->instance;
-    VkExternalFenceHandleTypeFlagBits handle_type;
 
     TRACE( "physical_device %p, fence_info %p, fence_properties %p\n", physical_device, fence_info, fence_properties );
 
-    handle_type = fence_info->handleType;
-    if (fence_info->handleType & EXTERNAL_FENCE_WIN32_BITS) fence_info->handleType = get_host_external_fence_type();
-
     instance->p_vkGetPhysicalDeviceExternalFenceProperties( physical_device->host.physical_device, fence_info, fence_properties );
-    fence_properties->compatibleHandleTypes = handle_type;
-    fence_properties->exportFromImportedHandleTypes = handle_type;
 }
 
 static const char *win32u_get_host_extension( const char *name )
@@ -1855,7 +1745,6 @@ static const char *nulldrv_get_host_extension( const char *name )
     if (!strcmp( name, "VK_KHR_win32_surface" )) return "VK_EXT_headless_surface";
     if (!strcmp( name, "VK_KHR_external_memory_win32" )) return "VK_KHR_external_memory_fd";
     if (!strcmp( name, "VK_KHR_external_semaphore_win32" )) return "VK_KHR_external_semaphore_fd";
-    if (!strcmp( name, "VK_KHR_external_fence_win32" )) return "VK_KHR_external_fence_fd";
     return name;
 }
 
diff --git b/dlls/winevulkan/vulkan.c a/dlls/winevulkan/vulkan.c
index 04b2085ac9b..71785d97ca5 100644
--- b/dlls/winevulkan/vulkan.c
+++ a/dlls/winevulkan/vulkan.c
@@ -368,7 +368,6 @@ static VkResult vulkan_physical_device_init(struct vulkan_physical_device *physi
     {
         if (!strcmp(host_properties[i].extensionName, vk_funcs->p_get_host_extension("VK_KHR_external_memory_win32"))
                 || !strcmp(host_properties[i].extensionName, vk_funcs->p_get_host_extension("VK_KHR_external_semaphore_win32"))
-                || !strcmp(host_properties[i].extensionName, vk_funcs->p_get_host_extension("VK_KHR_external_fence_win32"))
                 || wine_vk_device_extension_supported(host_properties[i].extensionName))
         {
             TRACE("Enabling extension '%s' for physical device %p\n", host_properties[i].extensionName, physical_device);
@@ -410,11 +409,6 @@ static VkResult vulkan_physical_device_init(struct vulkan_physical_device *physi
             strcpy(physical_device->extensions[j].extensionName, "VK_KHR_external_semaphore_win32");
             physical_device->extensions[j++].specVersion = VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION;
         }
-        else if (!strcmp(host_properties[i].extensionName, vk_funcs->p_get_host_extension("VK_KHR_external_fence_win32")))
-        {
-            strcpy(physical_device->extensions[j].extensionName, "VK_KHR_external_fence_win32");
-            physical_device->extensions[j++].specVersion = VK_KHR_EXTERNAL_FENCE_WIN32_SPEC_VERSION;
-        }
         else if (wine_vk_device_extension_supported(host_properties[i].extensionName))
         {
             physical_device->extensions[j] = host_properties[i];
@@ -599,11 +593,6 @@ static VkResult wine_vk_device_convert_create_info(struct vulkan_physical_device
             device->has_external_semaphore_win32 = true;
             *extension = vk_funcs->p_get_host_extension("VK_KHR_external_semaphore_win32");
         }
-        if (!strcmp(*extension, "VK_KHR_external_fence_win32"))
-        {
-            device->has_external_fence_win32 = true;
-            *extension = vk_funcs->p_get_host_extension("VK_KHR_external_fence_win32");
-        }
     }
 
     if (physical_device->map_placed_align)
@@ -1809,11 +1798,6 @@ static NTSTATUS is_available_device_function(VkDevice handle, const char *name)
     if (!strcmp(name, "vkImportSemaphoreWin32HandleKHR"))
         return device->has_external_semaphore_win32;
 
-    if (!strcmp(name, "vkGetFenceWin32HandleKHR"))
-        return device->has_external_fence_win32;
-    if (!strcmp(name, "vkImportFenceWin32HandleKHR"))
-        return device->has_external_fence_win32;
-
     return !!vk_funcs->p_vkGetDeviceProcAddr(device->obj.host.device, name);
 }
 
diff --git b/dlls/winevulkan/vulkan_private.h a/dlls/winevulkan/vulkan_private.h
index 2324e6f8639..37aae0ca004 100644
--- b/dlls/winevulkan/vulkan_private.h
+++ a/dlls/winevulkan/vulkan_private.h
@@ -43,7 +43,6 @@ struct wine_device
     struct vulkan_device obj;
     bool has_external_memory_win32;
     bool has_external_semaphore_win32;
-    bool has_external_fence_win32;
     uint64_t queue_count;
     struct wine_queue queues[];
 };
diff --git b/dlls/winewayland.drv/vulkan.c a/dlls/winewayland.drv/vulkan.c
index 9a70c90447d..b70d2636df3 100644
--- b/dlls/winewayland.drv/vulkan.c
+++ a/dlls/winewayland.drv/vulkan.c
@@ -86,7 +86,6 @@ static const char *wayland_get_host_extension(const char *name)
     if (!strcmp( name, "VK_KHR_win32_surface" )) return "VK_KHR_wayland_surface";
     if (!strcmp( name, "VK_KHR_external_memory_win32" )) return "VK_KHR_external_memory_fd";
     if (!strcmp( name, "VK_KHR_external_semaphore_win32" )) return "VK_KHR_external_semaphore_fd";
-    if (!strcmp( name, "VK_KHR_external_fence_win32" )) return "VK_KHR_external_fence_fd";
     return name;
 }
 
diff --git b/dlls/winex11.drv/vulkan.c a/dlls/winex11.drv/vulkan.c
index bb4f5c45eec..a3277bb999b 100644
--- b/dlls/winex11.drv/vulkan.c
+++ a/dlls/winex11.drv/vulkan.c
@@ -83,7 +83,6 @@ static const char *X11DRV_get_host_extension( const char *name )
     if (!strcmp( name, "VK_KHR_win32_surface" )) return "VK_KHR_xlib_surface";
     if (!strcmp( name, "VK_KHR_external_memory_win32" )) return "VK_KHR_external_memory_fd";
     if (!strcmp( name, "VK_KHR_external_semaphore_win32" )) return "VK_KHR_external_semaphore_fd";
-    if (!strcmp( name, "VK_KHR_external_fence_win32" )) return "VK_KHR_external_fence_fd";
     return name;
 }
 

diff --git b/dlls/win32u/d3dkmt.c a/dlls/win32u/d3dkmt.c
index 7eb3928ba72..a048aca740a 100644
--- b/dlls/win32u/d3dkmt.c
+++ a/dlls/win32u/d3dkmt.c
@@ -1698,54 +1698,3 @@ NTSTATUS d3dkmt_destroy_resource( D3DKMT_HANDLE local )
 
     return STATUS_SUCCESS;
 }
-
-/* create a D3DKMT global or shared sync */
-D3DKMT_HANDLE d3dkmt_create_sync( D3DKMT_HANDLE *global )
-{
-    struct d3dkmt_object *sync = NULL;
-    NTSTATUS status;
-
-    TRACE( "global %p\n", global );
-
-    if ((status = d3dkmt_object_alloc( sizeof(*sync), D3DKMT_SYNC, (void **)&sync ))) goto failed;
-    if ((status = d3dkmt_object_create( sync, !global, NULL, 0 ))) goto failed;
-    if (global) *global = sync->global;
-    return sync->local;
-
-failed:
-    WARN( "Failed to create sync, status %#x\n", status );
-    if (sync) d3dkmt_object_free( sync );
-    return 0;
-}
-
-/* open a D3DKMT global or shared sync */
-D3DKMT_HANDLE d3dkmt_open_sync( D3DKMT_HANDLE global, HANDLE shared )
-{
-    struct d3dkmt_object *sync = NULL;
-    NTSTATUS status;
-    UINT dummy = 0;
-
-    TRACE( "global %#x, shared %p\n", global, shared );
-
-    if ((status = d3dkmt_object_alloc( sizeof(*sync), D3DKMT_SYNC, (void **)&sync ))) goto failed;
-    if ((status = d3dkmt_object_open( sync, global, shared, NULL, &dummy ))) goto failed;
-    return sync->local;
-
-failed:
-    WARN( "Failed to open sync, status %#x\n", status );
-    if (sync) d3dkmt_object_free( sync );
-    return 0;
-}
-
-/* destroy a locally opened D3DKMT sync */
-NTSTATUS d3dkmt_destroy_sync( D3DKMT_HANDLE local )
-{
-    struct d3dkmt_object *sync;
-
-    TRACE( "local %#x\n", local );
-
-    if (!(sync = get_d3dkmt_object( local, D3DKMT_SYNC ))) return STATUS_INVALID_PARAMETER;
-    d3dkmt_object_free( sync );
-
-    return STATUS_SUCCESS;
-}
diff --git b/dlls/win32u/vulkan.c a/dlls/win32u/vulkan.c
index 877091cd590..3e0300184c0 100644
--- b/dlls/win32u/vulkan.c
+++ a/dlls/win32u/vulkan.c
@@ -52,9 +52,6 @@ static const UINT EXTERNAL_MEMORY_WIN32_BITS = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OP
                                                VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT |
                                                VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT |
                                                VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT;
-static const UINT EXTERNAL_SEMAPHORE_WIN32_BITS = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT |
-                                                  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT |
-                                                  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT;
 
 struct device_memory
 {
@@ -102,9 +99,6 @@ static struct swapchain *swapchain_from_handle( VkSwapchainKHR handle )
 struct semaphore
 {
     struct vulkan_semaphore obj;
-    D3DKMT_HANDLE local;
-    D3DKMT_HANDLE global;
-    HANDLE shared;
 };
 
 static struct semaphore *semaphore_from_handle( VkSemaphore handle )
@@ -195,14 +189,6 @@ static VkExternalMemoryHandleTypeFlagBits get_host_external_memory_type(void)
     return 0;
 }
 
-static VkExternalSemaphoreHandleTypeFlagBits get_host_external_semaphore_type(void)
-{
-    const char *host_extension = driver_funcs->p_get_host_extension( "VK_KHR_external_semaphore_win32" );
-    if (!strcmp( host_extension, "VK_KHR_external_semaphore_fd" )) return VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
-    if (!strcmp( host_extension, "VK_KHR_external_semaphore_capabilities" )) return VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT;
-    return 0;
-}
-
 static void init_shared_resource_path( const WCHAR *name, UNICODE_STRING *str )
 {
     UINT len = wcslen( name );
@@ -218,7 +204,7 @@ static void init_shared_resource_path( const WCHAR *name, UNICODE_STRING *str )
     str->Length += len;
 }
 
-static HANDLE create_shared_resource_handle( D3DKMT_HANDLE local, const VkExportMemoryWin32HandleInfoKHR *info )
+static HANDLE create_shared_handle( D3DKMT_HANDLE local, const VkExportMemoryWin32HandleInfoKHR *info )
 {
     SECURITY_DESCRIPTOR *security = info->pAttributes ? info->pAttributes->lpSecurityDescriptor : NULL;
     WCHAR bufferW[MAX_PATH * 2];
@@ -235,7 +221,7 @@ static HANDLE create_shared_resource_handle( D3DKMT_HANDLE local, const VkExport
     return NULL;
 }
 
-static HANDLE open_shared_resource_from_name( const WCHAR *name )
+static HANDLE open_shared_handle_from_name( const WCHAR *name )
 {
     D3DKMT_OPENNTHANDLEFROMNAME open_name = {0};
     WCHAR bufferW[MAX_PATH * 2];
@@ -331,7 +317,7 @@ static VkResult win32u_vkAllocateMemory( VkDevice client_device, const VkMemoryA
         case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT:
         {
             HANDLE shared = import_win32->handle;
-            if (import_win32->name && !(shared = open_shared_resource_from_name( import_win32->name ))) break;
+            if (import_win32->name && !(shared = open_shared_handle_from_name( import_win32->name ))) break;
             memory->local = d3dkmt_open_resource( 0, shared );
             if (shared && shared != import_win32->handle) NtClose( shared );
             break;
@@ -362,7 +348,7 @@ static VkResult win32u_vkAllocateMemory( VkDevice client_device, const VkMemoryA
         FIXME( "Exporting memory handle not yet implemented!\n" );
 
         if (!memory->local && !(memory->local = d3dkmt_create_resource( nt_shared ? NULL : &memory->global ))) goto failed;
-        if (nt_shared && !(memory->shared = create_shared_resource_handle( memory->local, &export_win32 ))) goto failed;
+        if (nt_shared && !(memory->shared = create_shared_handle( memory->local, &export_win32 ))) goto failed;
     }
 
     vulkan_object_init( &memory->obj.obj, host_device_memory );
@@ -1356,53 +1342,15 @@ static VkResult win32u_vkQueueSubmit2( VkQueue client_queue, uint32_t count, con
     return device->p_vkQueueSubmit2( queue->host.queue, count, submits, fence ? fence->host.fence : 0 );
 }
 
-static HANDLE create_shared_semaphore_handle( D3DKMT_HANDLE local, const VkExportSemaphoreWin32HandleInfoKHR *info )
-{
-    SECURITY_DESCRIPTOR *security = info->pAttributes ? info->pAttributes->lpSecurityDescriptor : NULL;
-    WCHAR bufferW[MAX_PATH * 2];
-    UNICODE_STRING name = {.Buffer = bufferW};
-    OBJECT_ATTRIBUTES attr;
-    NTSTATUS status;
-    HANDLE shared;
-
-    if (info->name) init_shared_resource_path( info->name, &name );
-    InitializeObjectAttributes( &attr, info->name ? &name : NULL, OBJ_CASE_INSENSITIVE, NULL, security );
-
-    if (!(status = NtGdiDdDDIShareObjects( 1, &local, &attr, info->dwAccess, &shared ))) return shared;
-    WARN( "Failed to share resource %#x, status %#x\n", local, status );
-    return NULL;
-}
-
-static HANDLE open_shared_semaphore_from_name( const WCHAR *name )
-{
-    D3DKMT_OPENSYNCOBJECTNTHANDLEFROMNAME open_name = {0};
-    WCHAR bufferW[MAX_PATH * 2];
-    UNICODE_STRING name_str = {.Buffer = bufferW};
-    OBJECT_ATTRIBUTES attr;
-    NTSTATUS status;
-
-    init_shared_resource_path( name, &name_str );
-    InitializeObjectAttributes( &attr, &name_str, OBJ_OPENIF, NULL, NULL );
-
-    open_name.dwDesiredAccess = GENERIC_ALL;
-    open_name.pObjAttrib = &attr;
-    status = NtGdiDdDDIOpenSyncObjectNtHandleFromName( &open_name );
-    if (status) WARN( "Failed to open %s, status %#x\n", debugstr_w( name ), status );
-    return open_name.hNtHandle;
-}
-
 static VkResult win32u_vkCreateSemaphore( VkDevice client_device, const VkSemaphoreCreateInfo *client_create_info,
                                           const VkAllocationCallbacks *allocator, VkSemaphore *ret )
 {
     VkSemaphoreCreateInfo *create_info = (VkSemaphoreCreateInfo *)client_create_info; /* cast away const, chain has been copied in the thunks */
-    VkExportSemaphoreWin32HandleInfoKHR export_win32 = {.dwAccess = GENERIC_ALL};
     struct vulkan_device *device = vulkan_device_from_handle( client_device );
     VkBaseOutStructure **next, *prev = (VkBaseOutStructure *)create_info;
     struct vulkan_instance *instance = device->physical_device->instance;
-    VkExportSemaphoreCreateInfoKHR *export_info = NULL;
     struct semaphore *semaphore;
     VkSemaphore host_semaphore;
-    BOOL nt_shared = FALSE;
     VkResult res;
 
     TRACE( "device %p, create_info %p, allocator %p, ret %p\n", device, create_info, allocator, ret );
@@ -1412,18 +1360,11 @@ static VkResult win32u_vkCreateSemaphore( VkDevice client_device, const VkSemaph
         switch ((*next)->sType)
         {
         case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
-            export_info = (VkExportSemaphoreCreateInfoKHR *)*next;
-            if (!(export_info->handleTypes & EXTERNAL_SEMAPHORE_WIN32_BITS))
-                FIXME( "Unsupported handle types %#x\n", export_info->handleTypes );
-            else
-            {
-                nt_shared = !(export_info->handleTypes & VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT);
-                export_info->handleTypes = get_host_external_semaphore_type();
-            }
+            FIXME( "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO not implemented!\n" );
             *next = (*next)->pNext; next = &prev;
             break;
         case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
-            export_win32 = *(VkExportSemaphoreWin32HandleInfoKHR *)*next;
+            FIXME( "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR not implemented!\n" );
             *next = (*next)->pNext; next = &prev;
             break;
         case VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV: break;
@@ -1440,25 +1381,11 @@ static VkResult win32u_vkCreateSemaphore( VkDevice client_device, const VkSemaph
         return res;
     }
 
-    if (export_info)
-    {
-        FIXME( "Exporting semaphore handle not yet implemented!\n" );
-
-        if (!(semaphore->local = d3dkmt_create_sync( nt_shared ? NULL : &semaphore->global ))) goto failed;
-        if (nt_shared && !(semaphore->shared = create_shared_semaphore_handle( semaphore->local, &export_win32 ))) goto failed;
-    }
-
     vulkan_object_init( &semaphore->obj.obj, host_semaphore );
     instance->p_insert_object( instance, &semaphore->obj.obj );
 
     *ret = semaphore->obj.client.semaphore;
     return res;
-
-failed:
-    device->p_vkDestroySemaphore( device->host.device, host_semaphore, NULL );
-    if (semaphore->local) d3dkmt_destroy_sync( semaphore->local );
-    free( semaphore );
-    return VK_ERROR_OUT_OF_HOST_MEMORY;
 }
 
 static void win32u_vkDestroySemaphore( VkDevice client_device, VkSemaphore client_semaphore, const VkAllocationCallbacks *allocator )
@@ -1474,106 +1401,36 @@ static void win32u_vkDestroySemaphore( VkDevice client_device, VkSemaphore clien
     device->p_vkDestroySemaphore( device->host.device, semaphore->obj.host.semaphore, NULL /* allocator */ );
     instance->p_remove_object( instance, &semaphore->obj.obj );
 
-    if (semaphore->shared) NtClose( semaphore->shared );
-    if (semaphore->local) d3dkmt_destroy_sync( semaphore->local );
     free( semaphore );
 }
 
 static VkResult win32u_vkGetSemaphoreWin32HandleKHR( VkDevice client_device, const VkSemaphoreGetWin32HandleInfoKHR *handle_info, HANDLE *handle )
 {
     struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    struct semaphore *semaphore = semaphore_from_handle( handle_info->semaphore );
-
-    TRACE( "device %p, handle_info %p, handle %p\n", device, handle_info, handle );
-
-    switch (handle_info->handleType)
-    {
-    case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
-        TRACE( "Returning global D3DKMT handle %#x\n", semaphore->global );
-        *handle = UlongToPtr( semaphore->global );
-        return VK_SUCCESS;
 
-    case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT:
-    case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT:
-        NtDuplicateObject( NtCurrentProcess(), semaphore->shared, NtCurrentProcess(), handle, 0, 0, DUPLICATE_SAME_ATTRIBUTES | DUPLICATE_SAME_ACCESS );
-        TRACE( "Returning NT shared handle %p -> %p\n", semaphore->shared, *handle );
-        return VK_SUCCESS;
+    FIXME( "device %p, handle_info %p, handle %p stub!\n", device, handle_info, handle );
 
-    default:
-        FIXME( "Unsupported handle type %#x\n", handle_info->handleType );
-        return VK_ERROR_INCOMPATIBLE_DRIVER;
-    }
+    return VK_ERROR_INCOMPATIBLE_DRIVER;
 }
 
 static VkResult win32u_vkImportSemaphoreWin32HandleKHR( VkDevice client_device, const VkImportSemaphoreWin32HandleInfoKHR *handle_info )
 {
     struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    struct semaphore *semaphore = semaphore_from_handle( handle_info->semaphore );
-    D3DKMT_HANDLE local, global = 0;
-    HANDLE shared = NULL;
-
-    TRACE( "device %p, handle_info %p\n", device, handle_info );
 
-    switch (handle_info->handleType)
-    {
-    case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
-        global = PtrToUlong( handle_info->handle );
-        if (!(local = d3dkmt_open_sync( global, NULL ))) return VK_ERROR_INVALID_EXTERNAL_HANDLE;
-        break;
-    case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT:
-    case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT:
-        if (handle_info->name && !(shared = open_shared_semaphore_from_name( handle_info->name )))
-            return VK_ERROR_INVALID_EXTERNAL_HANDLE;
-        else if (!(shared = handle_info->handle) || NtDuplicateObject( NtCurrentProcess(), shared, NtCurrentProcess(), &shared,
-                                                                       0, 0, DUPLICATE_SAME_ATTRIBUTES | DUPLICATE_SAME_ACCESS ))
-            return VK_ERROR_INVALID_EXTERNAL_HANDLE;
-
-        if (!(local = d3dkmt_open_sync( 0, shared )))
-        {
-            NtClose( shared );
-            return VK_ERROR_INVALID_EXTERNAL_HANDLE;
-        }
-        break;
-    default:
-        FIXME( "Unsupported handle type %#x\n", handle_info->handleType );
-        return VK_ERROR_INVALID_EXTERNAL_HANDLE;
-    }
-
-    FIXME( "Importing memory handle not yet implemented!\n" );
+    FIXME( "device %p, handle_info %p stub!\n", device, handle_info );
 
-    if (handle_info->flags & VK_SEMAPHORE_IMPORT_TEMPORARY_BIT)
-    {
-        /* FIXME: Should we still keep the temporary handles for vkGetSemaphoreWin32HandleKHR? */
-        if (shared) NtClose( shared );
-        d3dkmt_destroy_sync( local );
-    }
-    else
-    {
-        if (semaphore->shared) NtClose( semaphore->shared );
-        if (semaphore->local) d3dkmt_destroy_sync( semaphore->local );
-        semaphore->shared = shared;
-        semaphore->global = global;
-        semaphore->local = local;
-    }
-    return VK_SUCCESS;
+    return VK_ERROR_INCOMPATIBLE_DRIVER;
 }
 
-static void win32u_vkGetPhysicalDeviceExternalSemaphoreProperties( VkPhysicalDevice client_physical_device, const VkPhysicalDeviceExternalSemaphoreInfo *client_semaphore_info,
+static void win32u_vkGetPhysicalDeviceExternalSemaphoreProperties( VkPhysicalDevice client_physical_device, const VkPhysicalDeviceExternalSemaphoreInfo *semaphore_info,
                                                                    VkExternalSemaphoreProperties *semaphore_properties )
 {
-    VkPhysicalDeviceExternalSemaphoreInfo *semaphore_info = (VkPhysicalDeviceExternalSemaphoreInfo *)client_semaphore_info; /* cast away const, it has been copied in the thunks */
     struct vulkan_physical_device *physical_device = vulkan_physical_device_from_handle( client_physical_device );
     struct vulkan_instance *instance = physical_device->instance;
-    VkExternalSemaphoreHandleTypeFlagBits handle_type;
 
     TRACE( "physical_device %p, semaphore_info %p, semaphore_properties %p\n", physical_device, semaphore_info, semaphore_properties );
 
-    handle_type = semaphore_info->handleType;
-    if (semaphore_info->handleType & EXTERNAL_SEMAPHORE_WIN32_BITS) semaphore_info->handleType = get_host_external_semaphore_type();
-
     instance->p_vkGetPhysicalDeviceExternalSemaphoreProperties( physical_device->host.physical_device, semaphore_info, semaphore_properties );
-    semaphore_properties->compatibleHandleTypes = handle_type;
-    semaphore_properties->exportFromImportedHandleTypes = handle_type;
 }
 
 static VkResult win32u_vkCreateFence( VkDevice client_device, const VkFenceCreateInfo *client_create_info, const VkAllocationCallbacks *allocator, VkFence *ret )
@@ -1744,7 +1601,6 @@ static const char *nulldrv_get_host_extension( const char *name )
 {
     if (!strcmp( name, "VK_KHR_win32_surface" )) return "VK_EXT_headless_surface";
     if (!strcmp( name, "VK_KHR_external_memory_win32" )) return "VK_KHR_external_memory_fd";
-    if (!strcmp( name, "VK_KHR_external_semaphore_win32" )) return "VK_KHR_external_semaphore_fd";
     return name;
 }
 
diff --git b/dlls/win32u/win32u_private.h a/dlls/win32u/win32u_private.h
index 6eaa7270b01..3c8745afab8 100644
--- b/dlls/win32u/win32u_private.h
+++ a/dlls/win32u/win32u_private.h
@@ -209,10 +209,6 @@ extern D3DKMT_HANDLE d3dkmt_create_resource( D3DKMT_HANDLE *global );
 extern D3DKMT_HANDLE d3dkmt_open_resource( D3DKMT_HANDLE global, HANDLE shared );
 extern NTSTATUS d3dkmt_destroy_resource( D3DKMT_HANDLE local );
 
-extern D3DKMT_HANDLE d3dkmt_create_sync( D3DKMT_HANDLE *global );
-extern D3DKMT_HANDLE d3dkmt_open_sync( D3DKMT_HANDLE global, HANDLE shared );
-extern NTSTATUS d3dkmt_destroy_sync( D3DKMT_HANDLE local );
-
 /* winstation.c */
 
 struct object_lock
diff --git b/dlls/winevulkan/vulkan.c a/dlls/winevulkan/vulkan.c
index 71785d97ca5..af14a493ec0 100644
--- b/dlls/winevulkan/vulkan.c
+++ a/dlls/winevulkan/vulkan.c
@@ -367,7 +367,6 @@ static VkResult vulkan_physical_device_init(struct vulkan_physical_device *physi
     for (i = 0; i < num_host_properties; i++)
     {
         if (!strcmp(host_properties[i].extensionName, vk_funcs->p_get_host_extension("VK_KHR_external_memory_win32"))
-                || !strcmp(host_properties[i].extensionName, vk_funcs->p_get_host_extension("VK_KHR_external_semaphore_win32"))
                 || wine_vk_device_extension_supported(host_properties[i].extensionName))
         {
             TRACE("Enabling extension '%s' for physical device %p\n", host_properties[i].extensionName, physical_device);
@@ -404,11 +403,6 @@ static VkResult vulkan_physical_device_init(struct vulkan_physical_device *physi
             strcpy(physical_device->extensions[j].extensionName, "VK_KHR_external_memory_win32");
             physical_device->extensions[j++].specVersion = VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION;
         }
-        else if (!strcmp(host_properties[i].extensionName, vk_funcs->p_get_host_extension("VK_KHR_external_semaphore_win32")))
-        {
-            strcpy(physical_device->extensions[j].extensionName, "VK_KHR_external_semaphore_win32");
-            physical_device->extensions[j++].specVersion = VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION;
-        }
         else if (wine_vk_device_extension_supported(host_properties[i].extensionName))
         {
             physical_device->extensions[j] = host_properties[i];
@@ -588,11 +582,6 @@ static VkResult wine_vk_device_convert_create_info(struct vulkan_physical_device
             *extension = vk_funcs->p_get_host_extension("VK_KHR_external_memory_win32");
             if (!strcmp(*extension, "VK_EXT_external_memory_dma_buf")) extensions[count++] = "VK_KHR_external_memory_fd";
         }
-        if (!strcmp(*extension, "VK_KHR_external_semaphore_win32"))
-        {
-            device->has_external_semaphore_win32 = true;
-            *extension = vk_funcs->p_get_host_extension("VK_KHR_external_semaphore_win32");
-        }
     }
 
     if (physical_device->map_placed_align)
@@ -1793,11 +1782,6 @@ static NTSTATUS is_available_device_function(VkDevice handle, const char *name)
     if (!strcmp(name, "vkGetMemoryWin32HandlePropertiesKHR"))
         return device->has_external_memory_win32;
 
-    if (!strcmp(name, "vkGetSemaphoreWin32HandleKHR"))
-        return device->has_external_semaphore_win32;
-    if (!strcmp(name, "vkImportSemaphoreWin32HandleKHR"))
-        return device->has_external_semaphore_win32;
-
     return !!vk_funcs->p_vkGetDeviceProcAddr(device->obj.host.device, name);
 }
 
diff --git b/dlls/winevulkan/vulkan_private.h a/dlls/winevulkan/vulkan_private.h
index 37aae0ca004..d3ef04ada20 100644
--- b/dlls/winevulkan/vulkan_private.h
+++ a/dlls/winevulkan/vulkan_private.h
@@ -42,7 +42,6 @@ struct wine_device
 {
     struct vulkan_device obj;
     bool has_external_memory_win32;
-    bool has_external_semaphore_win32;
     uint64_t queue_count;
     struct wine_queue queues[];
 };
diff --git b/dlls/winewayland.drv/vulkan.c a/dlls/winewayland.drv/vulkan.c
index b70d2636df3..cd5c5295cb1 100644
--- b/dlls/winewayland.drv/vulkan.c
+++ a/dlls/winewayland.drv/vulkan.c
@@ -85,7 +85,6 @@ static const char *wayland_get_host_extension(const char *name)
 {
     if (!strcmp( name, "VK_KHR_win32_surface" )) return "VK_KHR_wayland_surface";
     if (!strcmp( name, "VK_KHR_external_memory_win32" )) return "VK_KHR_external_memory_fd";
-    if (!strcmp( name, "VK_KHR_external_semaphore_win32" )) return "VK_KHR_external_semaphore_fd";
     return name;
 }
 
diff --git b/dlls/winex11.drv/vulkan.c a/dlls/winex11.drv/vulkan.c
index a3277bb999b..f49f382b3a6 100644
--- b/dlls/winex11.drv/vulkan.c
+++ a/dlls/winex11.drv/vulkan.c
@@ -82,7 +82,6 @@ static const char *X11DRV_get_host_extension( const char *name )
 {
     if (!strcmp( name, "VK_KHR_win32_surface" )) return "VK_KHR_xlib_surface";
     if (!strcmp( name, "VK_KHR_external_memory_win32" )) return "VK_KHR_external_memory_fd";
-    if (!strcmp( name, "VK_KHR_external_semaphore_win32" )) return "VK_KHR_external_semaphore_fd";
     return name;
 }
 
diff --git b/MAINTAINERS a/MAINTAINERS
index cdbfcd8a600..8eb5f84975d 100644
--- b/MAINTAINERS
+++ a/MAINTAINERS
@@ -64,12 +64,6 @@ P:	Esme Povirk <esme@codeweavers.com> @madewokherd
 F:	dlls/comdlg32/itemdlg.c
 F:	dlls/comdlg32/tests/itemdlg.c
 
-D3DKMT
-M:	Rmi Bernon <rbernon@codeweavers.com> @rbernon
-F:	dlls/win32u/d3dkmt.c
-F:	dlls/win32u/tests/d3dkmt.c
-F:	server/d3dkmt.c
-
 Direct2D
 M:	Nikolay Sivov <nsivov@codeweavers.com> @nsivov
 P:	Henri Verbeet <hverbeet@codeweavers.com> @hverbeet
@@ -277,16 +271,6 @@ OLE Typelibs
 P:	Huw Davies <huw@codeweavers.com> @huw
 F:	dlls/oleaut32/typelib.c
 
-OpenGL
-M:	Rmi Bernon <rbernon@codeweavers.com> @rbernon
-P:	Jacek Caban <jacek@codeweavers.com> @jacek
-F:	dlls/gdi32/opengl.c
-F:	dlls/opengl32/
-F:	dlls/win32u/opengl.c
-F:	dlls/wine*/opengl.c
-F:	include/wine/opengl_driver.h
-F:	include/wine/wgl.h
-
 Plug and Play
 P:	Elizabeth Figura <zfigura@codeweavers.com> @zfigura
 F:	dlls/newdev/
@@ -340,16 +324,6 @@ VBScript
 M:	Jacek Caban <jacek@codeweavers.com> @jacek
 F:	dlls/vbscript/
 
-Vulkan
-M:	Rmi Bernon <rbernon@codeweavers.com> @rbernon
-P:	Jacek Caban <jacek@codeweavers.com> @jacek
-F:	dlls/vulkan-1/
-F:	dlls/win32u/vulkan.c
-F:	dlls/wine*/vulkan.c
-F:	dlls/winevulkan/
-F:	include/wine/vulkan.h
-F:	include/wine/vulkan_driver.h
-
 Web Services
 M:	Hans Leidekker <hans@codeweavers.com> @hans
 F:	dlls/webservices/
diff --git b/dlls/win32u/d3dkmt.c a/dlls/win32u/d3dkmt.c
index a048aca740a..3afdcabfcf8 100644
--- b/dlls/win32u/d3dkmt.c
+++ a/dlls/win32u/d3dkmt.c
@@ -679,7 +679,7 @@ NTSTATUS WINAPI NtGdiDdDDIQueryVideoMemoryInfo( D3DKMT_QUERYVIDEOMEMORYINFO *des
                  !(properties2.memoryProperties.memoryHeaps[i].flags & VK_MEMORY_HEAP_DEVICE_LOCAL_BIT)))
             {
                 desc->Budget += budget.heapBudget[i];
-                desc->CurrentUsage += min( budget.heapBudget[i], budget.heapUsage[i] );
+                desc->CurrentUsage += budget.heapUsage[i];
             }
         }
         desc->AvailableForReservation = desc->Budget / 2;
@@ -1631,70 +1631,3 @@ NTSTATUS WINAPI NtGdiDdDDIDestroySynchronizationObject( const D3DKMT_DESTROYSYNC
 
     return STATUS_SUCCESS;
 }
-
-/* create a D3DKMT global or shared resource */
-D3DKMT_HANDLE d3dkmt_create_resource( D3DKMT_HANDLE *global )
-{
-    struct d3dkmt_resource *resource = NULL;
-    struct d3dkmt_object *allocation = NULL;
-    NTSTATUS status;
-
-    TRACE( "global %p\n", global );
-
-    if ((status = d3dkmt_object_alloc( sizeof(*resource), D3DKMT_RESOURCE, (void **)&resource ))) goto failed;
-    if ((status = d3dkmt_object_alloc( sizeof(*allocation), D3DKMT_ALLOCATION, (void **)&allocation ))) goto failed;
-    if ((status = d3dkmt_object_create( &resource->obj, !global, NULL, 0 ))) goto failed;
-
-    if ((status = alloc_object_handle( allocation ))) goto failed;
-    resource->allocation = allocation->local;
-
-    if (global) *global = resource->obj.global;
-    return resource->obj.local;
-
-failed:
-    WARN( "Failed to create resource, status %#x\n", status );
-    if (allocation) d3dkmt_object_free( allocation );
-    if (resource) d3dkmt_object_free( &resource->obj );
-    return 0;
-}
-
-/* open a D3DKMT global or shared resource */
-D3DKMT_HANDLE d3dkmt_open_resource( D3DKMT_HANDLE global, HANDLE shared )
-{
-    struct d3dkmt_object *allocation = NULL;
-    struct d3dkmt_resource *resource = NULL;
-    NTSTATUS status;
-    UINT dummy = 0;
-
-    TRACE( "global %#x, shared %p\n", global, shared );
-
-    if ((status = d3dkmt_object_alloc( sizeof(*resource), D3DKMT_RESOURCE, (void **)&resource ))) goto failed;
-    if ((status = d3dkmt_object_alloc( sizeof(*allocation), D3DKMT_ALLOCATION, (void **)&allocation ))) goto failed;
-    if ((status = d3dkmt_object_open( &resource->obj, global, shared, NULL, &dummy ))) goto failed;
-
-    if ((status = alloc_object_handle( allocation ))) goto failed;
-    resource->allocation = allocation->local;
-
-    return resource->obj.local;
-
-failed:
-    WARN( "Failed to open resource, status %#x\n", status );
-    if (allocation) d3dkmt_object_free( allocation );
-    if (resource) d3dkmt_object_free( &resource->obj );
-    return 0;
-}
-
-/* destroy a locally opened D3DKMT resource */
-NTSTATUS d3dkmt_destroy_resource( D3DKMT_HANDLE local )
-{
-    struct d3dkmt_resource *resource;
-    struct d3dkmt_object *allocation;
-
-    TRACE( "local %#x\n", local );
-
-    if (!(resource = get_d3dkmt_object( local, D3DKMT_RESOURCE ))) return STATUS_INVALID_PARAMETER;
-    if ((allocation = get_d3dkmt_object( resource->allocation, D3DKMT_RESOURCE ))) d3dkmt_object_free( allocation );
-    d3dkmt_object_free( &resource->obj );
-
-    return STATUS_SUCCESS;
-}
diff --git b/dlls/win32u/tests/d3dkmt.c a/dlls/win32u/tests/d3dkmt.c
index ba25286642e..a65ca1a4c02 100644
--- b/dlls/win32u/tests/d3dkmt.c
+++ a/dlls/win32u/tests/d3dkmt.c
@@ -455,7 +455,8 @@ static void get_d3dkmt_resource_desc( LUID luid, HANDLE handle, BOOL expect_glob
     D3DKMT_HANDLE resource;
     NTSTATUS status;
 
-    ok_ptr( handle, !=, NULL );
+    todo_wine ok_ptr( handle, !=, NULL );
+    if (!handle) return;
 
     open_adapter.AdapterLuid = luid;
     status = D3DKMTOpenAdapterFromLuid(&open_adapter);
@@ -479,7 +480,7 @@ static void get_d3dkmt_resource_desc( LUID luid, HANDLE handle, BOOL expect_glob
         status = D3DKMTQueryResourceInfo( &query );
         ok_nt( STATUS_SUCCESS, status );
         if (size) ok_u4( query.PrivateRuntimeDataSize, ==, size );
-        else ok( query.PrivateRuntimeDataSize == 0 || query.PrivateRuntimeDataSize == 0x68 /* NVIDIA */, "got %#x\n", query.PrivateRuntimeDataSize );
+        else todo_wine ok( query.PrivateRuntimeDataSize == 0 || query.PrivateRuntimeDataSize == 0x68 /* NVIDIA */, "got %#x\n", query.PrivateRuntimeDataSize );
         ok_u4( query.TotalPrivateDriverDataSize, <, sizeof(driver_data) );
         ok_u4( query.ResourcePrivateDriverDataSize, <, sizeof(driver_data) );
         ok_u4( query.NumAllocations, ==, 1 );
@@ -500,7 +501,7 @@ static void get_d3dkmt_resource_desc( LUID luid, HANDLE handle, BOOL expect_glob
         ok_nt( STATUS_SUCCESS, status );
         check_d3dkmt_local( open.hResource, NULL );
         if (size) ok_u4( open.PrivateRuntimeDataSize, ==, size );
-        else ok( open.PrivateRuntimeDataSize == 0 || open.PrivateRuntimeDataSize == 0x68 /* NVIDIA */, "got %#x\n", open.PrivateRuntimeDataSize );
+        else todo_wine ok( open.PrivateRuntimeDataSize == 0 || open.PrivateRuntimeDataSize == 0x68 /* NVIDIA */, "got %#x\n", open.PrivateRuntimeDataSize );
         ok_u4( open.TotalPrivateDriverDataBufferSize, <, sizeof(driver_data) );
         ok_u4( open.ResourcePrivateDriverDataSize, <, sizeof(driver_data) );
         ok_u4( open.NumAllocations, ==, 1 );
@@ -518,7 +519,7 @@ static void get_d3dkmt_resource_desc( LUID luid, HANDLE handle, BOOL expect_glob
         status = D3DKMTQueryResourceInfoFromNtHandle( &query_nt );
         ok_nt( STATUS_SUCCESS, status );
         if (size) ok_u4( query_nt.PrivateRuntimeDataSize, ==, size );
-        else ok( query_nt.PrivateRuntimeDataSize == 0 || query_nt.PrivateRuntimeDataSize == 0x68 /* NVIDIA */, "got %#x\n", query_nt.PrivateRuntimeDataSize );
+        else todo_wine ok( query_nt.PrivateRuntimeDataSize == 0 || query_nt.PrivateRuntimeDataSize == 0x68 /* NVIDIA */, "got %#x\n", query_nt.PrivateRuntimeDataSize );
         ok_u4( query_nt.TotalPrivateDriverDataSize, <, sizeof(driver_data) );
         ok_u4( query_nt.ResourcePrivateDriverDataSize, <, sizeof(driver_data) );
         ok_u4( query_nt.NumAllocations, ==, 1 );
@@ -539,7 +540,7 @@ static void get_d3dkmt_resource_desc( LUID luid, HANDLE handle, BOOL expect_glob
         ok_nt( STATUS_SUCCESS, status );
         check_d3dkmt_local( open_nt.hResource, NULL );
         if (size) ok_u4( open_nt.PrivateRuntimeDataSize, ==, size );
-        else ok( open_nt.PrivateRuntimeDataSize == 0 || open_nt.PrivateRuntimeDataSize == 0x68 /* NVIDIA */, "got %#x\n", open_nt.PrivateRuntimeDataSize );
+        else todo_wine ok( open_nt.PrivateRuntimeDataSize == 0 || open_nt.PrivateRuntimeDataSize == 0x68 /* NVIDIA */, "got %#x\n", open_nt.PrivateRuntimeDataSize );
         ok_u4( open_nt.TotalPrivateDriverDataBufferSize, <, sizeof(driver_data) );
         ok_u4( open_nt.ResourcePrivateDriverDataSize, <, sizeof(driver_data) );
         ok_u4( open_nt.NumAllocations, ==, 1 );
@@ -1422,6 +1423,7 @@ static void test_D3DKMTQueryVideoMemoryInfo(void)
         query_memory_info.PhysicalAdapterIndex = 0;
         query_memory_info.MemorySegmentGroup = groups[i];
         status = D3DKMTQueryVideoMemoryInfo( &query_memory_info );
+        todo_wine_if( status == STATUS_INVALID_PARAMETER ) /* fails on Wine without a Vulkan adapter */
         ok( status == STATUS_SUCCESS, "Got unexpected return code %#lx.\n", status );
         ok( query_memory_info.Budget >= query_memory_info.AvailableForReservation,
             "Unexpected budget %I64u and reservation %I64u.\n", query_memory_info.Budget,
@@ -3361,12 +3363,12 @@ static struct vulkan_device *create_vulkan_device( LUID *luid )
 
         winetest_push_context( "export" );
         types = get_vulkan_external_image_types( dev->instance, physical_devices[i], VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR );
-        ok( !(~types & expect_export_types), "got types %#x\n", types );
+        todo_wine ok( !(~types & expect_export_types), "got types %#x\n", types );
         winetest_pop_context();
 
         winetest_push_context( "import" );
         types = get_vulkan_external_image_types( dev->instance, physical_devices[i], VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR );
-        ok( !(~types & expect_import_types), "got types %#x\n", types );
+        todo_wine ok( !(~types & expect_import_types), "got types %#x\n", types );
         winetest_pop_context();
     }
 
@@ -3395,8 +3397,15 @@ static struct vulkan_device *create_vulkan_device( LUID *luid )
 
     p_vkCreateDevice = (void *)p_vkGetInstanceProcAddr( dev->instance, "vkCreateDevice" );
     vr = p_vkCreateDevice( dev->physical_device, &create_info, NULL, &dev->device );
-    ok_vk( VK_SUCCESS, vr );
-    ok_ptr( dev->device, !=, VK_NULL_HANDLE );
+    todo_wine ok_vk( VK_SUCCESS, vr );
+    todo_wine ok_ptr( dev->device, !=, VK_NULL_HANDLE );
+    if (dev->device == VK_NULL_HANDLE)
+    {
+        PFN_vkDestroyInstance p_vkDestroyInstance = (void *)p_vkGetInstanceProcAddr( dev->instance, "vkDestroyInstance" );
+        p_vkDestroyInstance( dev->instance, NULL );
+        free( dev );
+        return NULL;
+    }
 
     return dev;
 }
@@ -4637,36 +4646,42 @@ static void test_shared_resources(void)
 
         case MAKETEST(4, 0, 0):
         {
+            if (!vulkan_exp) break;
             buf = export_vulkan_buffer( vulkan_exp, resource_size, NULL, VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT, &handle );
             get_d3dkmt_resource_desc( luid, handle, FALSE, 0, runtime_desc );
             break;
         }
         case MAKETEST(4, 0, 1):
         {
+            if (!vulkan_exp) break;
             buf = export_vulkan_buffer( vulkan_exp, resource_size, NULL, VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT, &handle );
             get_d3dkmt_resource_desc( luid, handle, TRUE, 0, runtime_desc );
             break;
         }
         case MAKETEST(4, 1, 0):
         {
+            if (!vulkan_exp) break;
             img = export_vulkan_image( vulkan_exp, width_1d, 1, array_1d, NULL, VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT, &handle );
             get_d3dkmt_resource_desc( luid, handle, FALSE, 0, runtime_desc );
             break;
         }
         case MAKETEST(4, 2, 0):
         {
+            if (!vulkan_exp) break;
             img = export_vulkan_image( vulkan_exp, width_2d, height_2d, 1, NULL, VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT, &handle );
             get_d3dkmt_resource_desc( luid, handle, FALSE, 0, runtime_desc );
             break;
         }
         case MAKETEST(4, 2, 1):
         {
+            if (!vulkan_exp) break;
             img = export_vulkan_image( vulkan_exp, width_2d, height_2d, 1, NULL, VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT, &handle );
             get_d3dkmt_resource_desc( luid, handle, TRUE, 0, runtime_desc );
             break;
         }
         case MAKETEST(4, 3, 0):
         {
+            if (!vulkan_exp) break;
             img = export_vulkan_image( vulkan_exp, width_3d, height_3d, depth_3d, NULL, VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT, &handle );
             get_d3dkmt_resource_desc( luid, handle, FALSE, 0, runtime_desc );
             break;
diff --git b/dlls/win32u/vulkan.c a/dlls/win32u/vulkan.c
index 3e0300184c0..f54a3a4bddc 100644
--- b/dlls/win32u/vulkan.c
+++ a/dlls/win32u/vulkan.c
@@ -58,10 +58,6 @@ struct device_memory
     struct vulkan_device_memory obj;
     VkDeviceSize size;
     void *vm_map;
-
-    D3DKMT_HANDLE local;
-    D3DKMT_HANDLE global;
-    HANDLE shared;
 };
 
 static inline struct device_memory *device_memory_from_handle( VkDeviceMemory handle )
@@ -181,64 +177,6 @@ static VkResult allocate_external_host_memory( struct vulkan_device *device, VkM
     return VK_SUCCESS;
 }
 
-static VkExternalMemoryHandleTypeFlagBits get_host_external_memory_type(void)
-{
-    const char *host_extension = driver_funcs->p_get_host_extension( "VK_KHR_external_memory_win32" );
-    if (!strcmp( host_extension, "VK_KHR_external_memory_fd" )) return VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
-    if (!strcmp( host_extension, "VK_EXT_external_memory_dma_buf" )) return VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT;
-    return 0;
-}
-
-static void init_shared_resource_path( const WCHAR *name, UNICODE_STRING *str )
-{
-    UINT len = wcslen( name );
-    char buffer[MAX_PATH];
-
-    snprintf( buffer, ARRAY_SIZE(buffer), "\\Sessions\\%u\\BaseNamedObjects\\",
-              NtCurrentTeb()->Peb->SessionId );
-    str->MaximumLength = asciiz_to_unicode( str->Buffer, buffer );
-    str->Length = str->MaximumLength - sizeof(WCHAR);
-
-    memcpy( str->Buffer + str->Length / sizeof(WCHAR), name, (len + 1) * sizeof(WCHAR) );
-    str->MaximumLength += len;
-    str->Length += len;
-}
-
-static HANDLE create_shared_handle( D3DKMT_HANDLE local, const VkExportMemoryWin32HandleInfoKHR *info )
-{
-    SECURITY_DESCRIPTOR *security = info->pAttributes ? info->pAttributes->lpSecurityDescriptor : NULL;
-    WCHAR bufferW[MAX_PATH * 2];
-    UNICODE_STRING name = {.Buffer = bufferW};
-    OBJECT_ATTRIBUTES attr;
-    NTSTATUS status;
-    HANDLE shared;
-
-    if (info->name) init_shared_resource_path( info->name, &name );
-    InitializeObjectAttributes( &attr, info->name ? &name : NULL, OBJ_CASE_INSENSITIVE, NULL, security );
-
-    if (!(status = NtGdiDdDDIShareObjects( 1, &local, &attr, info->dwAccess, &shared ))) return shared;
-    WARN( "Failed to share resource %#x, status %#x\n", local, status );
-    return NULL;
-}
-
-static HANDLE open_shared_handle_from_name( const WCHAR *name )
-{
-    D3DKMT_OPENNTHANDLEFROMNAME open_name = {0};
-    WCHAR bufferW[MAX_PATH * 2];
-    UNICODE_STRING name_str = {.Buffer = bufferW};
-    OBJECT_ATTRIBUTES attr;
-    NTSTATUS status;
-
-    init_shared_resource_path( name, &name_str );
-    InitializeObjectAttributes( &attr, &name_str, OBJ_OPENIF, NULL, NULL );
-
-    open_name.dwDesiredAccess = GENERIC_ALL;
-    open_name.pObjAttrib = &attr;
-    status = NtGdiDdDDIOpenNtHandleFromName( &open_name );
-    if (status) WARN( "Failed to open %s, status %#x\n", debugstr_w( name ), status );
-    return open_name.hNtHandle;
-}
-
 static VkResult win32u_vkAllocateMemory( VkDevice client_device, const VkMemoryAllocateInfo *client_alloc_info,
                                          const VkAllocationCallbacks *allocator, VkDeviceMemory *ret )
 {
@@ -248,12 +186,9 @@ static VkResult win32u_vkAllocateMemory( VkDevice client_device, const VkMemoryA
     struct vulkan_physical_device *physical_device = device->physical_device;
     struct vulkan_instance *instance = device->physical_device->instance;
     VkImportMemoryHostPointerInfoEXT host_pointer_info, *pointer_info = NULL;
-    VkExportMemoryWin32HandleInfoKHR export_win32 = {.dwAccess = GENERIC_ALL};
-    VkImportMemoryWin32HandleInfoKHR *import_win32 = NULL;
     VkExportMemoryAllocateInfo *export_info = NULL;
     VkDeviceMemory host_device_memory;
     struct device_memory *memory;
-    BOOL nt_shared = FALSE;
     uint32_t mem_flags;
     void *mapping = NULL;
     VkResult res;
@@ -267,22 +202,18 @@ static VkResult win32u_vkAllocateMemory( VkDevice client_device, const VkMemoryA
             export_info = (VkExportMemoryAllocateInfo *)*next;
             if (!(export_info->handleTypes & EXTERNAL_MEMORY_WIN32_BITS))
                 FIXME( "Unsupported handle types %#x\n", export_info->handleTypes );
-            else
-            {
-                nt_shared = !(export_info->handleTypes & (VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT |
-                                                          VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT));
-                export_info->handleTypes = get_host_external_memory_type();
-            }
+            FIXME( "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO not implemented!\n" );
+            *next = (*next)->pNext; next = &prev;
             break;
         case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
-            export_win32 = *(VkExportMemoryWin32HandleInfoKHR *)*next;
+            FIXME( "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR not implemented!\n" );
             *next = (*next)->pNext; next = &prev;
             break;
         case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
             pointer_info = (VkImportMemoryHostPointerInfoEXT *)*next;
             break;
         case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
-            import_win32 = (VkImportMemoryWin32HandleInfoKHR *)*next;
+            FIXME( "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR not implemented!\n" );
             *next = (*next)->pNext; next = &prev;
             break;
         case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO: break;
@@ -300,57 +231,13 @@ static VkResult win32u_vkAllocateMemory( VkDevice client_device, const VkMemoryA
         (res = allocate_external_host_memory( device, alloc_info, mem_flags, &host_pointer_info )))
         return res;
 
-    if (!(memory = calloc( 1, sizeof(*memory) ))) return VK_ERROR_OUT_OF_HOST_MEMORY;
-
-    if (import_win32)
-    {
-        switch (import_win32->handleType)
-        {
-        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
-        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT:
-            memory->global = PtrToUlong( import_win32->handle );
-            memory->local = d3dkmt_open_resource( memory->global, NULL );
-            break;
-        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT:
-        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT:
-        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT:
-        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT:
-        {
-            HANDLE shared = import_win32->handle;
-            if (import_win32->name && !(shared = open_shared_handle_from_name( import_win32->name ))) break;
-            memory->local = d3dkmt_open_resource( 0, shared );
-            if (shared && shared != import_win32->handle) NtClose( shared );
-            break;
-        }
-        default:
-            FIXME( "Unsupported handle type %#x\n", import_win32->handleType );
-            break;
-        }
-
-        if (!memory->local)
-        {
-            free( memory );
-            return VK_ERROR_INVALID_EXTERNAL_HANDLE;
-        }
-
-        FIXME( "Importing memory handle not yet implemented!\n" );
-    }
-
+    if (!(memory = malloc( sizeof(*memory) ))) return VK_ERROR_OUT_OF_HOST_MEMORY;
     if ((res = device->p_vkAllocateMemory( device->host.device, alloc_info, NULL, &host_device_memory )))
     {
-        if (memory->local) d3dkmt_destroy_resource( memory->local );
         free( memory );
         return res;
     }
 
-    if (export_info)
-    {
-        FIXME( "Exporting memory handle not yet implemented!\n" );
-
-        if (!memory->local && !(memory->local = d3dkmt_create_resource( nt_shared ? NULL : &memory->global ))) goto failed;
-        if (nt_shared && !(memory->shared = create_shared_handle( memory->local, &export_win32 ))) goto failed;
-    }
-
     vulkan_object_init( &memory->obj.obj, host_device_memory );
     memory->size = alloc_info->allocationSize;
     memory->vm_map = mapping;
@@ -358,12 +245,6 @@ static VkResult win32u_vkAllocateMemory( VkDevice client_device, const VkMemoryA
 
     *ret = memory->obj.client.device_memory;
     return VK_SUCCESS;
-
-failed:
-    device->p_vkFreeMemory( device->host.device, host_device_memory, NULL );
-    if (memory->local) d3dkmt_destroy_resource( memory->local );
-    free( memory );
-    return VK_ERROR_OUT_OF_HOST_MEMORY;
 }
 
 static void win32u_vkFreeMemory( VkDevice client_device, VkDeviceMemory client_memory, const VkAllocationCallbacks *allocator )
@@ -396,57 +277,26 @@ static void win32u_vkFreeMemory( VkDevice client_device, VkDeviceMemory client_m
         NtFreeVirtualMemory( GetCurrentProcess(), &memory->vm_map, &alloc_size, MEM_RELEASE );
     }
 
-    if (memory->shared) NtClose( memory->shared );
-    if (memory->local) d3dkmt_destroy_resource( memory->local );
     free( memory );
 }
 
 static VkResult win32u_vkGetMemoryWin32HandleKHR( VkDevice client_device, const VkMemoryGetWin32HandleInfoKHR *handle_info, HANDLE *handle )
 {
     struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    struct device_memory *memory = device_memory_from_handle( handle_info->memory );
-
-    TRACE( "device %p, handle_info %p, handle %p\n", device, handle_info, handle );
-
-    switch (handle_info->handleType)
-    {
-    case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
-    case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT:
-        TRACE( "Returning global D3DKMT handle %#x\n", memory->global );
-        *handle = UlongToPtr( memory->global );
-        return VK_SUCCESS;
-
-    case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT:
-    case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT:
-    case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT:
-    case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT:
-        NtDuplicateObject( NtCurrentProcess(), memory->shared, NtCurrentProcess(), handle, 0, 0, DUPLICATE_SAME_ATTRIBUTES | DUPLICATE_SAME_ACCESS );
-        TRACE( "Returning NT shared handle %p -> %p\n", memory->shared, *handle );
-        return VK_SUCCESS;
 
-    default:
-        FIXME( "Unsupported handle type %#x\n", handle_info->handleType );
-        return VK_ERROR_INCOMPATIBLE_DRIVER;
-    }
-}
+    FIXME( "device %p, handle_info %p, handle %p stub!\n", device, handle_info, handle );
 
-static BOOL is_d3dkmt_global( D3DKMT_HANDLE handle )
-{
-    return (handle & 0xc0000000) && (handle & 0x3f) == 2;
+    return VK_ERROR_INCOMPATIBLE_DRIVER;
 }
 
 static VkResult win32u_vkGetMemoryWin32HandlePropertiesKHR( VkDevice client_device, VkExternalMemoryHandleTypeFlagBits handle_type, HANDLE handle,
                                                             VkMemoryWin32HandlePropertiesKHR *handle_properties )
 {
-    static const UINT d3dkmt_type_bits = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT | VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT;
     struct vulkan_device *device = vulkan_device_from_handle( client_device );
 
-    TRACE( "device %p, handle_type %#x, handle %p, handle_properties %p\n", device, handle_type, handle, handle_properties );
+    FIXME( "device %p, handle_type %#x, handle %p, handle_properties %p stub!\n", device, handle_type, handle, handle_properties );
 
-    if (is_d3dkmt_global( HandleToULong( handle ) )) handle_properties->memoryTypeBits = d3dkmt_type_bits;
-    else handle_properties->memoryTypeBits = EXTERNAL_MEMORY_WIN32_BITS & ~d3dkmt_type_bits;
-
-    return VK_SUCCESS;
+    return VK_ERROR_INCOMPATIBLE_DRIVER;
 }
 
 static VkResult win32u_vkMapMemory2KHR( VkDevice client_device, const VkMemoryMapInfoKHR *map_info, void **data )
@@ -600,8 +450,8 @@ static VkResult win32u_vkCreateBuffer( VkDevice client_device, const VkBufferCre
             external_info = (VkExternalMemoryBufferCreateInfo *)*next;
             if (!(external_info->handleTypes & EXTERNAL_MEMORY_WIN32_BITS))
                 FIXME( "Unsupported handle types %#x\n", external_info->handleTypes );
-            else
-                external_info->handleTypes = get_host_external_memory_type();
+            FIXME( "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO not implemented!\n" );
+            *next = (*next)->pNext; next = &prev;
             break;
         case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT: break;
         case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR: break;
@@ -641,8 +491,8 @@ static void win32u_vkGetDeviceBufferMemoryRequirements( VkDevice client_device,
             external_info = (VkExternalMemoryBufferCreateInfo *)*next;
             if (!(external_info->handleTypes & EXTERNAL_MEMORY_WIN32_BITS))
                 FIXME( "Unsupported handle types %#x\n", external_info->handleTypes );
-            else
-                external_info->handleTypes = get_host_external_memory_type();
+            FIXME( "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO not implemented!\n" );
+            *next = (*next)->pNext; next = &prev;
             break;
         case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT: break;
         case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR: break;
@@ -659,16 +509,18 @@ static void win32u_vkGetPhysicalDeviceExternalBufferProperties( VkPhysicalDevice
     VkPhysicalDeviceExternalBufferInfo *buffer_info = (VkPhysicalDeviceExternalBufferInfo *)client_buffer_info; /* cast away const, it has been copied in the thunks */
     struct vulkan_physical_device *physical_device = vulkan_physical_device_from_handle( client_physical_device );
     struct vulkan_instance *instance = physical_device->instance;
-    VkExternalMemoryHandleTypeFlagBits handle_type = 0;
 
     TRACE( "physical_device %p, buffer_info %p, buffer_properties %p\n", physical_device, buffer_info, buffer_properties );
 
-    handle_type = buffer_info->handleType;
-    if (handle_type & EXTERNAL_MEMORY_WIN32_BITS) buffer_info->handleType = get_host_external_memory_type();
+    if (!(buffer_info->handleType & EXTERNAL_MEMORY_WIN32_BITS))
+        FIXME( "Unsupported handle type %#x\n", buffer_info->handleType );
+    FIXME( "VkPhysicalDeviceExternalBufferInfo Win32 handleType not implemented!\n" );
+    buffer_info->handleType = 0;
 
     instance->p_vkGetPhysicalDeviceExternalBufferProperties( physical_device->host.physical_device, buffer_info, buffer_properties );
-    buffer_properties->externalMemoryProperties.compatibleHandleTypes = handle_type;
-    buffer_properties->externalMemoryProperties.exportFromImportedHandleTypes = handle_type;
+    buffer_properties->externalMemoryProperties.externalMemoryFeatures = 0;
+    buffer_properties->externalMemoryProperties.exportFromImportedHandleTypes = 0;
+    buffer_properties->externalMemoryProperties.compatibleHandleTypes = 0;
 }
 
 static VkResult win32u_vkCreateImage( VkDevice client_device, const VkImageCreateInfo *create_info,
@@ -688,8 +540,8 @@ static VkResult win32u_vkCreateImage( VkDevice client_device, const VkImageCreat
             external_info = (VkExternalMemoryImageCreateInfo *)*next;
             if (!(external_info->handleTypes & EXTERNAL_MEMORY_WIN32_BITS))
                 FIXME( "Unsupported handle types %#x\n", external_info->handleTypes );
-            else
-                external_info->handleTypes = get_host_external_memory_type();
+            FIXME( "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO not implemented!\n" );
+            *next = (*next)->pNext; next = &prev;
             break;
         case VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA: break;
         case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT: break;
@@ -732,8 +584,8 @@ static void win32u_vkGetDeviceImageMemoryRequirements( VkDevice client_device, c
             external_info = (VkExternalMemoryImageCreateInfo *)*next;
             if (!(external_info->handleTypes & EXTERNAL_MEMORY_WIN32_BITS))
                 FIXME( "Unsupported handle types %#x\n", external_info->handleTypes );
-            else
-                external_info->handleTypes = get_host_external_memory_type();
+            FIXME( "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO not implemented!\n" );
+            *next = (*next)->pNext; next = &prev;
             break;
         case VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA: break;
         case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT: break;
@@ -756,7 +608,7 @@ static VkResult win32u_vkGetPhysicalDeviceImageFormatProperties2( VkPhysicalDevi
     VkBaseOutStructure **next, *prev = (VkBaseOutStructure *)format_info; /* cast away const, chain has been copied in the thunks */
     struct vulkan_physical_device *physical_device = vulkan_physical_device_from_handle( client_physical_device );
     struct vulkan_instance *instance = physical_device->instance;
-    VkExternalMemoryHandleTypeFlagBits handle_type = 0;
+    VkPhysicalDeviceExternalImageFormatInfo *external_info;
     VkResult res;
 
     TRACE( "physical_device %p, format_info %p, format_properties %p\n", physical_device, format_info, format_properties );
@@ -770,12 +622,12 @@ static VkResult win32u_vkGetPhysicalDeviceImageFormatProperties2( VkPhysicalDevi
         case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO: break;
         case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV: break;
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
-        {
-            VkPhysicalDeviceExternalImageFormatInfo *external_info = (VkPhysicalDeviceExternalImageFormatInfo *)*next;
-            handle_type = external_info->handleType;
-            if (handle_type & EXTERNAL_MEMORY_WIN32_BITS) external_info->handleType = get_host_external_memory_type();
+            external_info = (VkPhysicalDeviceExternalImageFormatInfo *)*next;
+            if (!(external_info->handleType & EXTERNAL_MEMORY_WIN32_BITS))
+                FIXME( "Unsupported handle type %#x\n", external_info->handleType );
+            FIXME( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO not implemented!\n" );
+            *next = (*next)->pNext; next = &prev;
             break;
-        }
         case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT: break;
         case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR: break;
         default: FIXME( "Unhandled sType %u.\n", (*next)->sType ); break;
@@ -783,15 +635,16 @@ static VkResult win32u_vkGetPhysicalDeviceImageFormatProperties2( VkPhysicalDevi
     }
 
     res = instance->p_vkGetPhysicalDeviceImageFormatProperties2( physical_device->host.physical_device, format_info, format_properties );
-    for (prev = (VkBaseOutStructure *)format_properties, next = &prev->pNext; *next; prev = *next, next = &(*next)->pNext)
+    if (!res) for (prev = (VkBaseOutStructure *)format_properties, next = &prev->pNext; *next; prev = *next, next = &(*next)->pNext)
     {
         switch ((*next)->sType)
         {
         case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
         {
             VkExternalImageFormatProperties *props = (VkExternalImageFormatProperties *)*next;
-            props->externalMemoryProperties.compatibleHandleTypes = handle_type;
-            props->externalMemoryProperties.exportFromImportedHandleTypes = handle_type;
+            props->externalMemoryProperties.externalMemoryFeatures = 0;
+            props->externalMemoryProperties.exportFromImportedHandleTypes = 0;
+            props->externalMemoryProperties.compatibleHandleTypes = 0;
             break;
         }
         case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT: break;
@@ -1521,9 +1374,9 @@ static void win32u_vkGetPhysicalDeviceExternalFenceProperties( VkPhysicalDevice
     instance->p_vkGetPhysicalDeviceExternalFenceProperties( physical_device->host.physical_device, fence_info, fence_properties );
 }
 
-static const char *win32u_get_host_extension( const char *name )
+static const char *win32u_get_host_surface_extension(void)
 {
-    return driver_funcs->p_get_host_extension( name );
+    return driver_funcs->p_get_host_surface_extension();
 }
 
 static struct vulkan_funcs vulkan_funcs =
@@ -1573,7 +1426,7 @@ static struct vulkan_funcs vulkan_funcs =
     .p_vkQueueSubmit2KHR = win32u_vkQueueSubmit2,
     .p_vkUnmapMemory = win32u_vkUnmapMemory,
     .p_vkUnmapMemory2KHR = win32u_vkUnmapMemory2KHR,
-    .p_get_host_extension = win32u_get_host_extension,
+    .p_get_host_surface_extension = win32u_get_host_surface_extension,
 };
 
 static VkResult nulldrv_vulkan_surface_create( HWND hwnd, const struct vulkan_instance *instance, VkSurfaceKHR *surface,
@@ -1597,18 +1450,16 @@ static VkBool32 nulldrv_get_physical_device_presentation_support( struct vulkan_
     return VK_TRUE;
 }
 
-static const char *nulldrv_get_host_extension( const char *name )
+static const char *nulldrv_get_host_surface_extension(void)
 {
-    if (!strcmp( name, "VK_KHR_win32_surface" )) return "VK_EXT_headless_surface";
-    if (!strcmp( name, "VK_KHR_external_memory_win32" )) return "VK_KHR_external_memory_fd";
-    return name;
+    return "VK_EXT_headless_surface";
 }
 
 static const struct vulkan_driver_funcs nulldrv_funcs =
 {
     .p_vulkan_surface_create = nulldrv_vulkan_surface_create,
     .p_get_physical_device_presentation_support = nulldrv_get_physical_device_presentation_support,
-    .p_get_host_extension = nulldrv_get_host_extension,
+    .p_get_host_surface_extension = nulldrv_get_host_surface_extension,
 };
 
 static void vulkan_driver_init(void)
@@ -1623,7 +1474,7 @@ static void vulkan_driver_init(void)
     }
 
     if (status == STATUS_NOT_IMPLEMENTED) driver_funcs = &nulldrv_funcs;
-    else vulkan_funcs.p_get_host_extension = driver_funcs->p_get_host_extension;
+    else vulkan_funcs.p_get_host_surface_extension = driver_funcs->p_get_host_surface_extension;
 }
 
 static void vulkan_driver_load(void)
@@ -1645,17 +1496,17 @@ static VkBool32 lazydrv_get_physical_device_presentation_support( struct vulkan_
     return driver_funcs->p_get_physical_device_presentation_support( physical_device, queue );
 }
 
-static const char *lazydrv_get_host_extension( const char *name )
+static const char *lazydrv_get_host_surface_extension(void)
 {
     vulkan_driver_load();
-    return driver_funcs->p_get_host_extension( name );
+    return driver_funcs->p_get_host_surface_extension();
 }
 
 static const struct vulkan_driver_funcs lazydrv_funcs =
 {
     .p_vulkan_surface_create = lazydrv_vulkan_surface_create,
     .p_get_physical_device_presentation_support = lazydrv_get_physical_device_presentation_support,
-    .p_get_host_extension = lazydrv_get_host_extension,
+    .p_get_host_surface_extension = lazydrv_get_host_surface_extension,
 };
 
 static void vulkan_init_once(void)
diff --git b/dlls/win32u/win32u_private.h a/dlls/win32u/win32u_private.h
index 3c8745afab8..a9b39de6471 100644
--- b/dlls/win32u/win32u_private.h
+++ a/dlls/win32u/win32u_private.h
@@ -205,10 +205,6 @@ extern BOOL get_vulkan_gpus( struct list *gpus );
 extern void free_vulkan_gpu( struct vulkan_gpu *gpu );
 extern BOOL get_vulkan_uuid_from_luid( const LUID *luid, GUID *uuid );
 
-extern D3DKMT_HANDLE d3dkmt_create_resource( D3DKMT_HANDLE *global );
-extern D3DKMT_HANDLE d3dkmt_open_resource( D3DKMT_HANDLE global, HANDLE shared );
-extern NTSTATUS d3dkmt_destroy_resource( D3DKMT_HANDLE local );
-
 /* winstation.c */
 
 struct object_lock
diff --git b/dlls/winemac.drv/vulkan.c a/dlls/winemac.drv/vulkan.c
index 51d951139b9..9f9e47bbb49 100644
--- b/dlls/winemac.drv/vulkan.c
+++ a/dlls/winemac.drv/vulkan.c
@@ -99,17 +99,16 @@ static VkBool32 macdrv_get_physical_device_presentation_support(struct vulkan_ph
 }
 
 static const char *host_surface_extension = "VK_MVK_macos_surface";
-static const char *macdrv_get_host_extension(const char *name)
+static const char *macdrv_get_host_surface_extension(void)
 {
-    if (!strcmp( name, "VK_KHR_win32_surface" )) return host_surface_extension;
-    return name;
+    return host_surface_extension;
 }
 
 static const struct vulkan_driver_funcs macdrv_vulkan_driver_funcs =
 {
     .p_vulkan_surface_create = macdrv_vulkan_surface_create,
     .p_get_physical_device_presentation_support = macdrv_get_physical_device_presentation_support,
-    .p_get_host_extension = macdrv_get_host_extension,
+    .p_get_host_surface_extension = macdrv_get_host_surface_extension,
 };
 
 UINT macdrv_VulkanInit(UINT version, void *vulkan_handle, const struct vulkan_driver_funcs **driver_funcs)
diff --git b/dlls/winevulkan/make_vulkan a/dlls/winevulkan/make_vulkan
index 2ccbc3a4b17..d94ba9eadf4 100755
--- b/dlls/winevulkan/make_vulkan
+++ a/dlls/winevulkan/make_vulkan
@@ -1225,7 +1225,7 @@ class VkVariable(object):
         return self.pointer and self.pointer.count('*') > 1
 
     def is_pointer_size(self):
-        if self.type in ["size_t", "HWND", "HINSTANCE", "HANDLE", "LPCWSTR"] or self.type.startswith("PFN"):
+        if self.type in ["size_t", "HWND", "HINSTANCE"] or self.type.startswith("PFN"):
             return True
         if self.is_handle() and self.handle.is_dispatchable():
             return True
diff --git b/dlls/winevulkan/vulkan.c a/dlls/winevulkan/vulkan.c
index af14a493ec0..19d2ba7ef42 100644
--- b/dlls/winevulkan/vulkan.c
+++ a/dlls/winevulkan/vulkan.c
@@ -366,8 +366,7 @@ static VkResult vulkan_physical_device_init(struct vulkan_physical_device *physi
      */
     for (i = 0; i < num_host_properties; i++)
     {
-        if (!strcmp(host_properties[i].extensionName, vk_funcs->p_get_host_extension("VK_KHR_external_memory_win32"))
-                || wine_vk_device_extension_supported(host_properties[i].extensionName))
+        if (wine_vk_device_extension_supported(host_properties[i].extensionName))
         {
             TRACE("Enabling extension '%s' for physical device %p\n", host_properties[i].extensionName, physical_device);
             num_properties++;
@@ -398,12 +397,7 @@ static VkResult vulkan_physical_device_init(struct vulkan_physical_device *physi
 
     for (i = 0, j = 0; i < num_host_properties; i++)
     {
-        if (!strcmp(host_properties[i].extensionName, vk_funcs->p_get_host_extension("VK_KHR_external_memory_win32")))
-        {
-            strcpy(physical_device->extensions[j].extensionName, "VK_KHR_external_memory_win32");
-            physical_device->extensions[j++].specVersion = VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION;
-        }
-        else if (wine_vk_device_extension_supported(host_properties[i].extensionName))
+        if (wine_vk_device_extension_supported(host_properties[i].extensionName))
         {
             physical_device->extensions[j] = host_properties[i];
             j++;
@@ -538,8 +532,8 @@ static void wine_vk_device_init_queues(struct wine_device *object, const VkDevic
     object->queue_count += info->queueCount;
 }
 
-static VkResult wine_vk_device_convert_create_info(struct vulkan_physical_device *physical_device, struct conversion_context *ctx,
-        const VkDeviceCreateInfo *src, VkDeviceCreateInfo *dst, struct wine_device *device)
+static VkResult wine_vk_device_convert_create_info(struct vulkan_physical_device *physical_device,
+        struct conversion_context *ctx, const VkDeviceCreateInfo *src, VkDeviceCreateInfo *dst)
 {
     bool has_swapchain_maintenance1 = false;
     bool has_external_memory_host = false;
@@ -576,12 +570,6 @@ static VkResult wine_vk_device_convert_create_info(struct vulkan_physical_device
         if (!strcmp(*extension, "VK_EXT_swapchain_maintenance1")) has_swapchain_maintenance1 = true;
         if (!strcmp(*extension, "VK_EXT_surface_maintenance1")) has_surface_maintenance1 = true;
         if (!strcmp(*extension, "VK_KHR_swapchain")) has_swapchain = true;
-        if (!strcmp(*extension, "VK_KHR_external_memory_win32"))
-        {
-            device->has_external_memory_win32 = true;
-            *extension = vk_funcs->p_get_host_extension("VK_KHR_external_memory_win32");
-            if (!strcmp(*extension, "VK_EXT_external_memory_dma_buf")) extensions[count++] = "VK_KHR_external_memory_fd";
-        }
     }
 
     if (physical_device->map_placed_align)
@@ -727,7 +715,7 @@ static VkResult wine_vk_instance_convert_create_info(struct conversion_context *
         }
         if (!strcmp(*extension, "VK_KHR_win32_surface"))
         {
-            *extension = vk_funcs->p_get_host_extension("VK_KHR_win32_surface");
+            *extension = vk_funcs->p_get_host_surface_extension();
             instance->enable_win32_surface = VK_TRUE;
         }
     }
@@ -906,7 +894,7 @@ VkResult wine_vkCreateDevice(VkPhysicalDevice client_physical_device, const VkDe
         return VK_ERROR_OUT_OF_HOST_MEMORY;
 
     init_conversion_context(&ctx);
-    res = wine_vk_device_convert_create_info(physical_device, &ctx, create_info, &create_info_host, device);
+    res = wine_vk_device_convert_create_info(physical_device, &ctx, create_info, &create_info_host);
     if (res == VK_SUCCESS)
         res = instance->p_vkCreateDevice(physical_device->host.physical_device, &create_info_host,
                                                NULL /* allocator */, &host_device);
@@ -1761,42 +1749,26 @@ void wine_vkDestroyDeferredOperationKHR(VkDevice device_handle,
     free(object);
 }
 
-static NTSTATUS is_available_instance_function(VkInstance handle, const char *name)
-{
-    struct wine_instance *instance = wine_instance_from_handle(handle);
-
-    if (!strcmp(name, "vkCreateWin32SurfaceKHR"))
-        return instance->enable_win32_surface;
-    if (!strcmp(name, "vkGetPhysicalDeviceWin32PresentationSupportKHR"))
-        return instance->enable_win32_surface;
-
-    return !!vk_funcs->p_vkGetInstanceProcAddr(instance->obj.host.instance, name);
-}
-
-static NTSTATUS is_available_device_function(VkDevice handle, const char *name)
-{
-    struct wine_device *device = wine_device_from_handle(handle);
-
-    if (!strcmp(name, "vkGetMemoryWin32HandleKHR"))
-        return device->has_external_memory_win32;
-    if (!strcmp(name, "vkGetMemoryWin32HandlePropertiesKHR"))
-        return device->has_external_memory_win32;
-
-    return !!vk_funcs->p_vkGetDeviceProcAddr(device->obj.host.device, name);
-}
-
 #ifdef _WIN64
 
 NTSTATUS vk_is_available_instance_function(void *arg)
 {
     struct is_available_instance_function_params *params = arg;
-    return is_available_instance_function(params->instance, params->name);
+    struct wine_instance *instance = wine_instance_from_handle(params->instance);
+
+    if (!strcmp(params->name, "vkCreateWin32SurfaceKHR"))
+        return instance->enable_win32_surface;
+    if (!strcmp(params->name, "vkGetPhysicalDeviceWin32PresentationSupportKHR"))
+        return instance->enable_win32_surface;
+
+    return !!vk_funcs->p_vkGetInstanceProcAddr(instance->obj.host.instance, params->name);
 }
 
 NTSTATUS vk_is_available_device_function(void *arg)
 {
     struct is_available_device_function_params *params = arg;
-    return is_available_device_function(params->device, params->name);
+    struct vulkan_device *device = vulkan_device_from_handle(params->device);
+    return !!vk_funcs->p_vkGetDeviceProcAddr(device->host.device, params->name);
 }
 
 #endif /* _WIN64 */
@@ -1808,7 +1780,14 @@ NTSTATUS vk_is_available_instance_function32(void *arg)
         UINT32 instance;
         UINT32 name;
     } *params = arg;
-    return is_available_instance_function(UlongToPtr(params->instance), UlongToPtr(params->name));
+    struct wine_instance *instance = wine_instance_from_handle(UlongToPtr(params->instance));
+
+    if (!strcmp(UlongToPtr(params->name), "vkCreateWin32SurfaceKHR"))
+        return instance->enable_win32_surface;
+    if (!strcmp(UlongToPtr(params->name), "vkGetPhysicalDeviceWin32PresentationSupportKHR"))
+        return instance->enable_win32_surface;
+
+    return !!vk_funcs->p_vkGetInstanceProcAddr(instance->obj.host.instance, UlongToPtr(params->name));
 }
 
 NTSTATUS vk_is_available_device_function32(void *arg)
@@ -1818,5 +1797,6 @@ NTSTATUS vk_is_available_device_function32(void *arg)
         UINT32 device;
         UINT32 name;
     } *params = arg;
-    return is_available_device_function(UlongToPtr(params->device), UlongToPtr(params->name));
+    struct vulkan_device *device = vulkan_device_from_handle(UlongToPtr(params->device));
+    return !!vk_funcs->p_vkGetDeviceProcAddr(device->host.device, UlongToPtr(params->name));
 }
diff --git b/dlls/winevulkan/vulkan_private.h a/dlls/winevulkan/vulkan_private.h
index d3ef04ada20..51fd39c4813 100644
--- b/dlls/winevulkan/vulkan_private.h
+++ a/dlls/winevulkan/vulkan_private.h
@@ -41,7 +41,6 @@ struct wine_queue
 struct wine_device
 {
     struct vulkan_device obj;
-    bool has_external_memory_win32;
     uint64_t queue_count;
     struct wine_queue queues[];
 };
diff --git b/dlls/winevulkan/vulkan_thunks.c a/dlls/winevulkan/vulkan_thunks.c
index de26841399d..7fa3491fedb 100644
--- b/dlls/winevulkan/vulkan_thunks.c
+++ a/dlls/winevulkan/vulkan_thunks.c
@@ -3110,7 +3110,7 @@ typedef struct VkExportFenceWin32HandleInfoKHR32
     PTR32 pNext;
     PTR32 pAttributes;
     DWORD dwAccess;
-    PTR32 name;
+    LPCWSTR name;
 } VkExportFenceWin32HandleInfoKHR32;
 
 typedef struct VkExportMemoryAllocateInfo32
@@ -3127,7 +3127,7 @@ typedef struct VkExportMemoryWin32HandleInfoKHR32
     PTR32 pNext;
     PTR32 pAttributes;
     DWORD dwAccess;
-    PTR32 name;
+    LPCWSTR name;
 } VkExportMemoryWin32HandleInfoKHR32;
 
 typedef struct VkExportSemaphoreCreateInfo32
@@ -3144,7 +3144,7 @@ typedef struct VkExportSemaphoreWin32HandleInfoKHR32
     PTR32 pNext;
     PTR32 pAttributes;
     DWORD dwAccess;
-    PTR32 name;
+    LPCWSTR name;
 } VkExportSemaphoreWin32HandleInfoKHR32;
 
 typedef struct VkExternalBufferProperties32
@@ -3667,8 +3667,8 @@ typedef struct VkImportFenceWin32HandleInfoKHR32
     VkFence DECLSPEC_ALIGN(8) fence;
     VkFenceImportFlags flags;
     VkExternalFenceHandleTypeFlagBits handleType;
-    PTR32 handle;
-    PTR32 name;
+    HANDLE handle;
+    LPCWSTR name;
 } VkImportFenceWin32HandleInfoKHR32;
 
 typedef struct VkImportMemoryHostPointerInfoEXT32
@@ -3684,8 +3684,8 @@ typedef struct VkImportMemoryWin32HandleInfoKHR32
     VkStructureType sType;
     PTR32 pNext;
     VkExternalMemoryHandleTypeFlagBits handleType;
-    PTR32 handle;
-    PTR32 name;
+    HANDLE handle;
+    LPCWSTR name;
 } VkImportMemoryWin32HandleInfoKHR32;
 
 typedef struct VkImportSemaphoreWin32HandleInfoKHR32
@@ -3695,8 +3695,8 @@ typedef struct VkImportSemaphoreWin32HandleInfoKHR32
     VkSemaphore DECLSPEC_ALIGN(8) semaphore;
     VkSemaphoreImportFlags flags;
     VkExternalSemaphoreHandleTypeFlagBits handleType;
-    PTR32 handle;
-    PTR32 name;
+    HANDLE handle;
+    LPCWSTR name;
 } VkImportSemaphoreWin32HandleInfoKHR32;
 
 typedef struct VkIndirectCommandsLayoutCreateInfoEXT32
@@ -9924,7 +9924,7 @@ static void convert_VkMemoryAllocateInfo_win32_to_host(struct conversion_context
             out_ext->pNext = NULL;
             out_ext->pAttributes = UlongToPtr(in_ext->pAttributes);
             out_ext->dwAccess = in_ext->dwAccess;
-            out_ext->name = (LPCWSTR)UlongToPtr(in_ext->name);
+            out_ext->name = in_ext->name;
             out_header->pNext = (void *)out_ext;
             out_header = (void *)out_ext;
             break;
@@ -9948,8 +9948,8 @@ static void convert_VkMemoryAllocateInfo_win32_to_host(struct conversion_context
             out_ext->sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
             out_ext->pNext = NULL;
             out_ext->handleType = in_ext->handleType;
-            out_ext->handle = (HANDLE)UlongToPtr(in_ext->handle);
-            out_ext->name = (LPCWSTR)UlongToPtr(in_ext->name);
+            out_ext->handle = in_ext->handle;
+            out_ext->name = in_ext->name;
             out_header->pNext = (void *)out_ext;
             out_header = (void *)out_ext;
             break;
@@ -22285,7 +22285,7 @@ static void convert_VkFenceCreateInfo_win32_to_host(struct conversion_context *c
             out_ext->pNext = NULL;
             out_ext->pAttributes = UlongToPtr(in_ext->pAttributes);
             out_ext->dwAccess = in_ext->dwAccess;
-            out_ext->name = (LPCWSTR)UlongToPtr(in_ext->name);
+            out_ext->name = in_ext->name;
             out_header->pNext = (void *)out_ext;
             out_header = (void *)out_ext;
             break;
@@ -26176,7 +26176,7 @@ static void convert_VkSemaphoreCreateInfo_win32_to_host(struct conversion_contex
             out_ext->pNext = NULL;
             out_ext->pAttributes = UlongToPtr(in_ext->pAttributes);
             out_ext->dwAccess = in_ext->dwAccess;
-            out_ext->name = (LPCWSTR)UlongToPtr(in_ext->name);
+            out_ext->name = in_ext->name;
             out_header->pNext = (void *)out_ext;
             out_header = (void *)out_ext;
             break;
@@ -39074,8 +39074,8 @@ static void convert_VkImportFenceWin32HandleInfoKHR_win32_to_unwrapped_host(cons
     out->fence = in->fence;
     out->flags = in->flags;
     out->handleType = in->handleType;
-    out->handle = (HANDLE)UlongToPtr(in->handle);
-    out->name = (LPCWSTR)UlongToPtr(in->name);
+    out->handle = in->handle;
+    out->name = in->name;
     if (in->pNext)
         FIXME("Unexpected pNext\n");
 }
@@ -39089,8 +39089,8 @@ static void convert_VkImportSemaphoreWin32HandleInfoKHR_win32_to_unwrapped_host(
     out->semaphore = in->semaphore;
     out->flags = in->flags;
     out->handleType = in->handleType;
-    out->handle = (HANDLE)UlongToPtr(in->handle);
-    out->name = (LPCWSTR)UlongToPtr(in->name);
+    out->handle = in->handle;
+    out->name = in->name;
     if (in->pNext)
         FIXME("Unexpected pNext\n");
 }
@@ -54753,14 +54753,11 @@ static NTSTATUS thunk32_vkGetFenceWin32HandleKHR(void *args)
         VkResult result;
     } *params = args;
     VkFenceGetWin32HandleInfoKHR pGetWin32HandleInfo_host;
-    HANDLE pHandle_host;
 
     TRACE("%#x, %#x, %#x\n", params->device, params->pGetWin32HandleInfo, params->pHandle);
 
     convert_VkFenceGetWin32HandleInfoKHR_win32_to_unwrapped_host((const VkFenceGetWin32HandleInfoKHR32 *)UlongToPtr(params->pGetWin32HandleInfo), &pGetWin32HandleInfo_host);
-    pHandle_host = UlongToPtr(*(PTR32 *)UlongToPtr(params->pHandle));
-    params->result = vk_funcs->p_vkGetFenceWin32HandleKHR((VkDevice)UlongToPtr(params->device), &pGetWin32HandleInfo_host, &pHandle_host);
-    *(PTR32 *)UlongToPtr(params->pHandle) = PtrToUlong(pHandle_host);
+    params->result = vk_funcs->p_vkGetFenceWin32HandleKHR((VkDevice)UlongToPtr(params->device), &pGetWin32HandleInfo_host, (HANDLE *)UlongToPtr(params->pHandle));
     return STATUS_SUCCESS;
 }
 
@@ -55461,14 +55458,11 @@ static NTSTATUS thunk32_vkGetMemoryWin32HandleKHR(void *args)
         VkResult result;
     } *params = args;
     VkMemoryGetWin32HandleInfoKHR pGetWin32HandleInfo_host;
-    HANDLE pHandle_host;
 
     TRACE("%#x, %#x, %#x\n", params->device, params->pGetWin32HandleInfo, params->pHandle);
 
     convert_VkMemoryGetWin32HandleInfoKHR_win32_to_unwrapped_host((const VkMemoryGetWin32HandleInfoKHR32 *)UlongToPtr(params->pGetWin32HandleInfo), &pGetWin32HandleInfo_host);
-    pHandle_host = UlongToPtr(*(PTR32 *)UlongToPtr(params->pHandle));
-    params->result = vk_funcs->p_vkGetMemoryWin32HandleKHR((VkDevice)UlongToPtr(params->device), &pGetWin32HandleInfo_host, &pHandle_host);
-    *(PTR32 *)UlongToPtr(params->pHandle) = PtrToUlong(pHandle_host);
+    params->result = vk_funcs->p_vkGetMemoryWin32HandleKHR((VkDevice)UlongToPtr(params->device), &pGetWin32HandleInfo_host, (HANDLE *)UlongToPtr(params->pHandle));
     return STATUS_SUCCESS;
 }
 
@@ -55490,16 +55484,16 @@ static NTSTATUS thunk32_vkGetMemoryWin32HandlePropertiesKHR(void *args)
     {
         PTR32 device;
         VkExternalMemoryHandleTypeFlagBits handleType;
-        PTR32 handle;
+        HANDLE handle;
         PTR32 pMemoryWin32HandleProperties;
         VkResult result;
     } *params = args;
     VkMemoryWin32HandlePropertiesKHR pMemoryWin32HandleProperties_host;
 
-    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->handleType, params->handle, params->pMemoryWin32HandleProperties);
+    TRACE("%#x, %#x, %p, %#x\n", params->device, params->handleType, params->handle, params->pMemoryWin32HandleProperties);
 
     convert_VkMemoryWin32HandlePropertiesKHR_win32_to_host((VkMemoryWin32HandlePropertiesKHR32 *)UlongToPtr(params->pMemoryWin32HandleProperties), &pMemoryWin32HandleProperties_host);
-    params->result = vk_funcs->p_vkGetMemoryWin32HandlePropertiesKHR((VkDevice)UlongToPtr(params->device), params->handleType, (HANDLE)UlongToPtr(params->handle), &pMemoryWin32HandleProperties_host);
+    params->result = vk_funcs->p_vkGetMemoryWin32HandlePropertiesKHR((VkDevice)UlongToPtr(params->device), params->handleType, params->handle, &pMemoryWin32HandleProperties_host);
     convert_VkMemoryWin32HandlePropertiesKHR_host_to_win32(&pMemoryWin32HandleProperties_host, (VkMemoryWin32HandlePropertiesKHR32 *)UlongToPtr(params->pMemoryWin32HandleProperties));
     return STATUS_SUCCESS;
 }
@@ -58220,14 +58214,11 @@ static NTSTATUS thunk32_vkGetSemaphoreWin32HandleKHR(void *args)
         VkResult result;
     } *params = args;
     VkSemaphoreGetWin32HandleInfoKHR pGetWin32HandleInfo_host;
-    HANDLE pHandle_host;
 
     TRACE("%#x, %#x, %#x\n", params->device, params->pGetWin32HandleInfo, params->pHandle);
 
     convert_VkSemaphoreGetWin32HandleInfoKHR_win32_to_unwrapped_host((const VkSemaphoreGetWin32HandleInfoKHR32 *)UlongToPtr(params->pGetWin32HandleInfo), &pGetWin32HandleInfo_host);
-    pHandle_host = UlongToPtr(*(PTR32 *)UlongToPtr(params->pHandle));
-    params->result = vk_funcs->p_vkGetSemaphoreWin32HandleKHR((VkDevice)UlongToPtr(params->device), &pGetWin32HandleInfo_host, &pHandle_host);
-    *(PTR32 *)UlongToPtr(params->pHandle) = PtrToUlong(pHandle_host);
+    params->result = vk_funcs->p_vkGetSemaphoreWin32HandleKHR((VkDevice)UlongToPtr(params->device), &pGetWin32HandleInfo_host, (HANDLE *)UlongToPtr(params->pHandle));
     return STATUS_SUCCESS;
 }
 
diff --git b/dlls/winewayland.drv/vulkan.c a/dlls/winewayland.drv/vulkan.c
index cd5c5295cb1..1715f479076 100644
--- b/dlls/winewayland.drv/vulkan.c
+++ a/dlls/winewayland.drv/vulkan.c
@@ -81,18 +81,16 @@ static VkBool32 wayland_get_physical_device_presentation_support(struct vulkan_p
                                                                         process_wayland.wl_display);
 }
 
-static const char *wayland_get_host_extension(const char *name)
+static const char *wayland_get_host_surface_extension(void)
 {
-    if (!strcmp( name, "VK_KHR_win32_surface" )) return "VK_KHR_wayland_surface";
-    if (!strcmp( name, "VK_KHR_external_memory_win32" )) return "VK_KHR_external_memory_fd";
-    return name;
+    return "VK_KHR_wayland_surface";
 }
 
 static const struct vulkan_driver_funcs wayland_vulkan_driver_funcs =
 {
     .p_vulkan_surface_create = wayland_vulkan_surface_create,
     .p_get_physical_device_presentation_support = wayland_get_physical_device_presentation_support,
-    .p_get_host_extension = wayland_get_host_extension,
+    .p_get_host_surface_extension = wayland_get_host_surface_extension,
 };
 
 /**********************************************************************
diff --git b/dlls/winex11.drv/vulkan.c a/dlls/winex11.drv/vulkan.c
index f49f382b3a6..61e4327e379 100644
--- b/dlls/winex11.drv/vulkan.c
+++ a/dlls/winex11.drv/vulkan.c
@@ -78,18 +78,16 @@ static VkBool32 X11DRV_get_physical_device_presentation_support( struct vulkan_p
                                                                       default_visual.visual->visualid );
 }
 
-static const char *X11DRV_get_host_extension( const char *name )
+static const char *X11DRV_get_host_surface_extension(void)
 {
-    if (!strcmp( name, "VK_KHR_win32_surface" )) return "VK_KHR_xlib_surface";
-    if (!strcmp( name, "VK_KHR_external_memory_win32" )) return "VK_KHR_external_memory_fd";
-    return name;
+    return "VK_KHR_xlib_surface";
 }
 
 static const struct vulkan_driver_funcs x11drv_vulkan_driver_funcs =
 {
     .p_vulkan_surface_create = X11DRV_vulkan_surface_create,
     .p_get_physical_device_presentation_support = X11DRV_get_physical_device_presentation_support,
-    .p_get_host_extension = X11DRV_get_host_extension,
+    .p_get_host_surface_extension = X11DRV_get_host_surface_extension,
 };
 
 UINT X11DRV_VulkanInit( UINT version, void *vulkan_handle, const struct vulkan_driver_funcs **driver_funcs )
diff --git b/include/wine/vulkan_driver.h a/include/wine/vulkan_driver.h
index be2f5296082..6a31bc75b5b 100644
--- b/include/wine/vulkan_driver.h
+++ a/include/wine/vulkan_driver.h
@@ -47,7 +47,7 @@ struct vulkan_client_object
 #include "wine/rbtree.h"
 
 /* Wine internal vulkan driver version, needs to be bumped upon vulkan_funcs changes. */
-#define WINE_VULKAN_DRIVER_VERSION 47
+#define WINE_VULKAN_DRIVER_VERSION 46
 
 struct vulkan_object
 {
@@ -257,7 +257,7 @@ struct vulkan_funcs
     PFN_vkUnmapMemory2KHR p_vkUnmapMemory2KHR;
 
     /* winevulkan specific functions */
-    const char *(*p_get_host_extension)( const char *name );
+    const char *(*p_get_host_surface_extension)(void);
 };
 
 /* interface between win32u and the user drivers */
@@ -266,7 +266,7 @@ struct vulkan_driver_funcs
 {
     VkResult (*p_vulkan_surface_create)(HWND, const struct vulkan_instance *, VkSurfaceKHR *, struct client_surface **);
     VkBool32 (*p_get_physical_device_presentation_support)(struct vulkan_physical_device *, uint32_t);
-    const char *(*p_get_host_extension)( const char *name );
+    const char *(*p_get_host_surface_extension)(void);
 };
 
 #endif /* WINE_UNIX_LIB */

diff --git b/dlls/win32u/vulkan.c a/dlls/win32u/vulkan.c
index f54a3a4bddc..a3546bf2291 100644
--- b/dlls/win32u/vulkan.c
+++ a/dlls/win32u/vulkan.c
@@ -92,28 +92,6 @@ static struct swapchain *swapchain_from_handle( VkSwapchainKHR handle )
     return CONTAINING_RECORD( obj, struct swapchain, obj );
 }
 
-struct semaphore
-{
-    struct vulkan_semaphore obj;
-};
-
-static struct semaphore *semaphore_from_handle( VkSemaphore handle )
-{
-    struct vulkan_semaphore *obj = vulkan_semaphore_from_handle( handle );
-    return CONTAINING_RECORD( obj, struct semaphore, obj );
-}
-
-struct fence
-{
-    struct vulkan_fence obj;
-};
-
-static struct fence *fence_from_handle( VkFence handle )
-{
-    struct vulkan_fence *obj = vulkan_fence_from_handle( handle );
-    return CONTAINING_RECORD( obj, struct fence, obj );
-}
-
 static VkResult allocate_external_host_memory( struct vulkan_device *device, VkMemoryAllocateInfo *alloc_info, uint32_t mem_flags,
                                                VkImportMemoryHostPointerInfoEXT *import_info )
 {
@@ -898,7 +876,7 @@ static VkResult win32u_vkCreateSwapchainKHR( VkDevice client_device, const VkSwa
      */
     if (NtUserGetClientRect( surface->hwnd, &client_rect, NtUserGetWinMonitorDpi( surface->hwnd, MDT_RAW_DPI ) ) &&
         !extents_equals( &create_info_host.imageExtent, &client_rect ) &&
-        physical_device->has_surface_maintenance1 && physical_device->has_swapchain_maintenance1)
+        physical_device->has_swapchain_maintenance1)
     {
         scaling.scalingBehavior = VK_PRESENT_SCALING_STRETCH_BIT_EXT;
         create_info_host.pNext = &scaling;
@@ -940,8 +918,6 @@ void win32u_vkDestroySwapchainKHR( VkDevice client_device, VkSwapchainKHR client
 static VkResult win32u_vkAcquireNextImage2KHR( VkDevice client_device, const VkAcquireNextImageInfoKHR *acquire_info,
                                                uint32_t *image_index )
 {
-    struct vulkan_semaphore *semaphore = acquire_info->semaphore ? vulkan_semaphore_from_handle( acquire_info->semaphore ) : NULL;
-    struct vulkan_fence *fence = acquire_info->fence ? vulkan_fence_from_handle( acquire_info->fence ) : NULL;
     struct swapchain *swapchain = swapchain_from_handle( acquire_info->swapchain );
     struct vulkan_device *device = vulkan_device_from_handle( client_device );
     VkAcquireNextImageInfoKHR acquire_info_host = *acquire_info;
@@ -950,8 +926,7 @@ static VkResult win32u_vkAcquireNextImage2KHR( VkDevice client_device, const VkA
     VkResult res;
 
     acquire_info_host.swapchain = swapchain->obj.host.swapchain;
-    acquire_info_host.semaphore = semaphore ? semaphore->host.semaphore : 0;
-    acquire_info_host.fence = fence ? fence->host.fence : 0;
+
     res = device->p_vkAcquireNextImage2KHR( device->host.device, &acquire_info_host, image_index );
 
     if (!res && NtUserGetClientRect( surface->hwnd, &client_rect, NtUserGetDpiForWindow( surface->hwnd ) ) &&
@@ -966,10 +941,8 @@ static VkResult win32u_vkAcquireNextImage2KHR( VkDevice client_device, const VkA
 }
 
 static VkResult win32u_vkAcquireNextImageKHR( VkDevice client_device, VkSwapchainKHR client_swapchain, uint64_t timeout,
-                                              VkSemaphore client_semaphore, VkFence client_fence, uint32_t *image_index )
+                                              VkSemaphore semaphore, VkFence fence, uint32_t *image_index )
 {
-    struct vulkan_semaphore *semaphore = client_semaphore ? vulkan_semaphore_from_handle( client_semaphore ) : NULL;
-    struct vulkan_fence *fence = client_fence ? vulkan_fence_from_handle( client_fence ) : NULL;
     struct swapchain *swapchain = swapchain_from_handle( client_swapchain );
     struct vulkan_device *device = vulkan_device_from_handle( client_device );
     struct surface *surface = swapchain->surface;
@@ -977,8 +950,7 @@ static VkResult win32u_vkAcquireNextImageKHR( VkDevice client_device, VkSwapchai
     VkResult res;
 
     res = device->p_vkAcquireNextImageKHR( device->host.device, swapchain->obj.host.swapchain, timeout,
-                                              semaphore ? semaphore->host.semaphore : 0, fence ? fence->host.fence : 0,
-                                              image_index );
+                                              semaphore, fence, image_index );
 
     if (!res && NtUserGetClientRect( surface->hwnd, &client_rect, NtUserGetDpiForWindow( surface->hwnd ) ) &&
         !extents_equals( &swapchain->extents, &client_rect ))
@@ -991,14 +963,14 @@ static VkResult win32u_vkAcquireNextImageKHR( VkDevice client_device, VkSwapchai
     return res;
 }
 
-static VkResult win32u_vkQueuePresentKHR( VkQueue client_queue, const VkPresentInfoKHR *client_present_info )
+static VkResult win32u_vkQueuePresentKHR( VkQueue client_queue, const VkPresentInfoKHR *present_info )
 {
-    VkPresentInfoKHR *present_info = (VkPresentInfoKHR *)client_present_info; /* cast away const, it has been copied in the thunks */
     struct vulkan_queue *queue = vulkan_queue_from_handle( client_queue );
     VkSwapchainKHR swapchains_buffer[16], *swapchains = swapchains_buffer;
+    VkPresentInfoKHR present_info_host = *present_info;
     struct vulkan_device *device = queue->device;
-    const VkSwapchainKHR *client_swapchains;
     VkResult res;
+    UINT i;
 
     TRACE( "queue %p, present_info %p\n", queue, present_info );
 
@@ -1006,27 +978,19 @@ static VkResult win32u_vkQueuePresentKHR( VkQueue client_queue, const VkPresentI
         !(swapchains = malloc( present_info->swapchainCount * sizeof(*swapchains) )))
         return VK_ERROR_OUT_OF_HOST_MEMORY;
 
-    for (uint32_t i = 0; i < present_info->waitSemaphoreCount; i++)
-    {
-        VkSemaphore *semaphores = (VkSemaphore *)present_info->pWaitSemaphores; /* cast away const, it has been copied in the thunks */
-        struct vulkan_semaphore *semaphore = vulkan_semaphore_from_handle( semaphores[i] );
-        semaphores[i] = semaphore->host.semaphore;
-    }
-
-    for (uint32_t i = 0; i < present_info->swapchainCount; i++)
+    for (i = 0; i < present_info->swapchainCount; i++)
     {
         struct swapchain *swapchain = swapchain_from_handle( present_info->pSwapchains[i] );
         swapchains[i] = swapchain->obj.host.swapchain;
     }
 
-    client_swapchains = present_info->pSwapchains;
-    present_info->pSwapchains = swapchains;
+    present_info_host.pSwapchains = swapchains;
 
-    res = device->p_vkQueuePresentKHR( queue->host.queue, present_info );
+    res = device->p_vkQueuePresentKHR( queue->host.queue, &present_info_host );
 
-    for (uint32_t i = 0; i < present_info->swapchainCount; i++)
+    for (i = 0; i < present_info->swapchainCount; i++)
     {
-        struct swapchain *swapchain = swapchain_from_handle( client_swapchains[i] );
+        struct swapchain *swapchain = swapchain_from_handle( present_info->pSwapchains[i] );
         VkResult swapchain_res = present_info->pResults ? present_info->pResults[i] : res;
         struct surface *surface = swapchain->surface;
         RECT client_rect;
@@ -1077,13 +1041,12 @@ static VkResult win32u_vkQueuePresentKHR( VkQueue client_queue, const VkPresentI
     return res;
 }
 
-static VkResult win32u_vkQueueSubmit( VkQueue client_queue, uint32_t count, const VkSubmitInfo *submits, VkFence client_fence )
+static VkResult win32u_vkQueueSubmit( VkQueue client_queue, uint32_t count, const VkSubmitInfo *submits, VkFence fence )
 {
-    struct vulkan_fence *fence = client_fence ? vulkan_fence_from_handle( client_fence ) : NULL;
     struct vulkan_queue *queue = vulkan_queue_from_handle( client_queue );
     struct vulkan_device *device = queue->device;
 
-    TRACE( "queue %p, count %u, submits %p, fence %p\n", queue, count, submits, fence );
+    TRACE( "queue %p, count %u, submits %p, fence 0x%s\n", queue, count, submits, wine_dbgstr_longlong( fence ) );
 
     for (uint32_t i = 0; i < count; i++)
     {
@@ -1097,20 +1060,6 @@ static VkResult win32u_vkQueueSubmit( VkQueue client_queue, uint32_t count, cons
             command_buffers[j] = command_buffer->host.command_buffer;
         }
 
-        for (uint32_t j = 0; j < submit->waitSemaphoreCount; j++)
-        {
-            VkSemaphore *semaphores = (VkSemaphore *)submit->pWaitSemaphores; /* cast away const, it has been copied in the thunks */
-            struct vulkan_semaphore *semaphore = vulkan_semaphore_from_handle( semaphores[j] );
-            semaphores[j] = semaphore->host.semaphore;
-        }
-
-        for (uint32_t j = 0; j < submit->signalSemaphoreCount; j++)
-        {
-            VkSemaphore *semaphores = (VkSemaphore *)submit->pSignalSemaphores; /* cast away const, it has been copied in the thunks */
-            struct vulkan_semaphore *semaphore = vulkan_semaphore_from_handle( semaphores[j] );
-            semaphores[j] = semaphore->host.semaphore;
-        }
-
         for (next = &prev->pNext; *next; prev = *next, next = &(*next)->pNext)
         {
             switch ((*next)->sType)
@@ -1135,16 +1084,15 @@ static VkResult win32u_vkQueueSubmit( VkQueue client_queue, uint32_t count, cons
         }
     }
 
-    return device->p_vkQueueSubmit( queue->host.queue, count, submits, fence ? fence->host.fence : 0 );
+    return device->p_vkQueueSubmit( queue->host.queue, count, submits, fence );
 }
 
-static VkResult win32u_vkQueueSubmit2( VkQueue client_queue, uint32_t count, const VkSubmitInfo2 *submits, VkFence client_fence )
+static VkResult win32u_vkQueueSubmit2( VkQueue client_queue, uint32_t count, const VkSubmitInfo2 *submits, VkFence fence )
 {
-    struct vulkan_fence *fence = client_fence ? vulkan_fence_from_handle( client_fence ) : NULL;
     struct vulkan_queue *queue = vulkan_queue_from_handle( client_queue );
     struct vulkan_device *device = queue->device;
 
-    TRACE( "queue %p, count %u, submits %p, fence %p\n", queue, count, submits, fence );
+    TRACE( "queue %p, count %u, submits %p, fence 0x%s\n", queue, count, submits, wine_dbgstr_longlong( fence ) );
 
     for (uint32_t i = 0; i < count; i++)
     {
@@ -1159,22 +1107,6 @@ static VkResult win32u_vkQueueSubmit2( VkQueue client_queue, uint32_t count, con
             if (command_buffer_infos->pNext) FIXME( "Unhandled struct chain\n" );
         }
 
-        for (uint32_t j = 0; j < submit->waitSemaphoreInfoCount; j++)
-        {
-            VkSemaphoreSubmitInfo *semaphore_infos = (VkSemaphoreSubmitInfo *)submit->pWaitSemaphoreInfos; /* cast away const, it has been copied in the thunks */
-            struct vulkan_semaphore *semaphore = vulkan_semaphore_from_handle( semaphore_infos[j].semaphore );
-            semaphore_infos[j].semaphore = semaphore->host.semaphore;
-            if (semaphore_infos->pNext) FIXME( "Unhandled struct chain\n" );
-        }
-
-        for (uint32_t j = 0; j < submit->signalSemaphoreInfoCount; j++)
-        {
-            VkSemaphoreSubmitInfo *semaphore_infos = (VkSemaphoreSubmitInfo *)submit->pSignalSemaphoreInfos; /* cast away const, it has been copied in the thunks */
-            struct vulkan_semaphore *semaphore = vulkan_semaphore_from_handle( semaphore_infos[j].semaphore );
-            semaphore_infos[j].semaphore = semaphore->host.semaphore;
-            if (semaphore_infos->pNext) FIXME( "Unhandled struct chain\n" );
-        }
-
         for (next = &prev->pNext; *next; prev = *next, next = &(*next)->pNext)
         {
             switch ((*next)->sType)
@@ -1192,7 +1124,7 @@ static VkResult win32u_vkQueueSubmit2( VkQueue client_queue, uint32_t count, con
         }
     }
 
-    return device->p_vkQueueSubmit2( queue->host.queue, count, submits, fence ? fence->host.fence : 0 );
+    return device->p_vkQueueSubmit2( queue->host.queue, count, submits, fence );
 }
 
 static VkResult win32u_vkCreateSemaphore( VkDevice client_device, const VkSemaphoreCreateInfo *client_create_info,
@@ -1201,10 +1133,6 @@ static VkResult win32u_vkCreateSemaphore( VkDevice client_device, const VkSemaph
     VkSemaphoreCreateInfo *create_info = (VkSemaphoreCreateInfo *)client_create_info; /* cast away const, chain has been copied in the thunks */
     struct vulkan_device *device = vulkan_device_from_handle( client_device );
     VkBaseOutStructure **next, *prev = (VkBaseOutStructure *)create_info;
-    struct vulkan_instance *instance = device->physical_device->instance;
-    struct semaphore *semaphore;
-    VkSemaphore host_semaphore;
-    VkResult res;
 
     TRACE( "device %p, create_info %p, allocator %p, ret %p\n", device, create_info, allocator, ret );
 
@@ -1226,35 +1154,16 @@ static VkResult win32u_vkCreateSemaphore( VkDevice client_device, const VkSemaph
         }
     }
 
-    if (!(semaphore = calloc( 1, sizeof(*semaphore) ))) return VK_ERROR_OUT_OF_HOST_MEMORY;
-
-    if ((res = device->p_vkCreateSemaphore( device->host.device, create_info, NULL /* allocator */, &host_semaphore )))
-    {
-        free( semaphore );
-        return res;
-    }
-
-    vulkan_object_init( &semaphore->obj.obj, host_semaphore );
-    instance->p_insert_object( instance, &semaphore->obj.obj );
-
-    *ret = semaphore->obj.client.semaphore;
-    return res;
+    return device->p_vkCreateSemaphore( device->host.device, create_info, NULL /* allocator */, ret );
 }
 
 static void win32u_vkDestroySemaphore( VkDevice client_device, VkSemaphore client_semaphore, const VkAllocationCallbacks *allocator )
 {
     struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    struct semaphore *semaphore = semaphore_from_handle( client_semaphore );
-    struct vulkan_instance *instance = device->physical_device->instance;
-
-    TRACE( "device %p, semaphore %p, allocator %p\n", device, semaphore, allocator );
 
-    if (!client_semaphore) return;
+    TRACE( "device %p, client_semaphore 0x%s, allocator %p\n", device, wine_dbgstr_longlong( client_semaphore ), allocator );
 
-    device->p_vkDestroySemaphore( device->host.device, semaphore->obj.host.semaphore, NULL /* allocator */ );
-    instance->p_remove_object( instance, &semaphore->obj.obj );
-
-    free( semaphore );
+    device->p_vkDestroySemaphore( device->host.device, client_semaphore, NULL /* allocator */ );
 }
 
 static VkResult win32u_vkGetSemaphoreWin32HandleKHR( VkDevice client_device, const VkSemaphoreGetWin32HandleInfoKHR *handle_info, HANDLE *handle )
@@ -1291,10 +1200,6 @@ static VkResult win32u_vkCreateFence( VkDevice client_device, const VkFenceCreat
     VkFenceCreateInfo *create_info = (VkFenceCreateInfo *)client_create_info; /* cast away const, chain has been copied in the thunks */
     struct vulkan_device *device = vulkan_device_from_handle( client_device );
     VkBaseOutStructure **next, *prev = (VkBaseOutStructure *)create_info;
-    struct vulkan_instance *instance = device->physical_device->instance;
-    struct fence *fence;
-    VkFence host_fence;
-    VkResult res;
 
     TRACE( "device %p, create_info %p, allocator %p, ret %p\n", device, create_info, allocator, ret );
 
@@ -1314,35 +1219,16 @@ static VkResult win32u_vkCreateFence( VkDevice client_device, const VkFenceCreat
         }
     }
 
-    if (!(fence = calloc( 1, sizeof(*fence) ))) return VK_ERROR_OUT_OF_HOST_MEMORY;
-
-    if ((res = device->p_vkCreateFence( device->host.device, create_info, NULL /* allocator */, &host_fence )))
-    {
-        free( fence );
-        return res;
-    }
-
-    vulkan_object_init( &fence->obj.obj, host_fence );
-    instance->p_insert_object( instance, &fence->obj.obj );
-
-    *ret = fence->obj.client.fence;
-    return res;
+    return device->p_vkCreateFence( device->host.device, create_info, NULL /* allocator */, ret );
 }
 
 static void win32u_vkDestroyFence( VkDevice client_device, VkFence client_fence, const VkAllocationCallbacks *allocator )
 {
     struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    struct fence *fence = fence_from_handle( client_fence );
-    struct vulkan_instance *instance = device->physical_device->instance;
-
-    TRACE( "device %p, fence %p, allocator %p\n", device, fence, allocator );
-
-    if (!client_fence) return;
 
-    device->p_vkDestroyFence( device->host.device, fence->obj.host.fence, NULL /* allocator */ );
-    instance->p_remove_object( instance, &fence->obj.obj );
+    TRACE( "device %p, client_fence %s, allocator %p\n", device, wine_dbgstr_longlong( client_fence ), allocator );
 
-    free( fence );
+    return device->p_vkDestroyFence( device->host.device, client_fence, allocator );
 }
 
 static VkResult win32u_vkGetFenceWin32HandleKHR( VkDevice client_device, const VkFenceGetWin32HandleInfoKHR *handle_info, HANDLE *handle )
diff --git b/dlls/winevulkan/make_vulkan a/dlls/winevulkan/make_vulkan
index d94ba9eadf4..998f68fd8eb 100755
--- b/dlls/winevulkan/make_vulkan
+++ a/dlls/winevulkan/make_vulkan
@@ -312,7 +312,6 @@ STRUCT_CHAIN_CONVERSIONS = {
     "VkPhysicalDeviceImageFormatInfo2": {},
     "VkCommandBufferSubmitInfo": {},
     "VkSemaphoreCreateInfo": {},
-    "VkSemaphoreSubmitInfo": {},
     "VkFenceCreateInfo": {},
     "VkSubmitInfo": {},
     "VkSubmitInfo2": {},
@@ -1124,11 +1123,6 @@ class VkHandle(object):
             return "vulkan_surface_from_handle({0})->host.surface".format(name)
         if self.name == "VkSwapchainKHR":
             return "vulkan_swapchain_from_handle({0})->host.swapchain".format(name)
-        if self.name == "VkSemaphore":
-            return "vulkan_semaphore_from_handle({0})->host.semaphore".format(name)
-        if self.name == "VkFence":
-            return "vulkan_fence_from_handle({0})->host.fence".format(name)
-
         if self.is_dispatchable():
             LOGGER.error("Unhandled host handle for: {0}".format(self.name))
         return None
@@ -2271,8 +2265,6 @@ class StructConversionFunction(object):
 
         if self.direction == Direction.OUTPUT and not any([any([self.member_needs_copy(ext, m) for m in ext]) for ext in self.operand.struct_extensions]):
             needs_extensions = False
-        if len(self.operand.struct_extensions) == 0:
-            needs_extensions = False
 
         body += "{\n"
         if needs_extensions:
diff --git b/dlls/winevulkan/vulkan.c a/dlls/winevulkan/vulkan.c
index 19d2ba7ef42..32f48f6bc9c 100644
--- b/dlls/winevulkan/vulkan.c
+++ a/dlls/winevulkan/vulkan.c
@@ -379,8 +379,6 @@ static VkResult vulkan_physical_device_init(struct vulkan_physical_device *physi
             have_external_memory_host = TRUE;
         else if (!strcmp(host_properties[i].extensionName, "VK_EXT_map_memory_placed"))
             have_memory_placed = TRUE;
-        else if (!strcmp(host_properties[i].extensionName, "VK_EXT_surface_maintenance1"))
-            physical_device->has_surface_maintenance1 = true;
         else if (!strcmp(host_properties[i].extensionName, "VK_EXT_swapchain_maintenance1"))
             physical_device->has_swapchain_maintenance1 = true;
         else if (!strcmp(host_properties[i].extensionName, "VK_KHR_map_memory2"))
@@ -532,18 +530,22 @@ static void wine_vk_device_init_queues(struct wine_device *object, const VkDevic
     object->queue_count += info->queueCount;
 }
 
-static VkResult wine_vk_device_convert_create_info(struct vulkan_physical_device *physical_device,
+static const char *find_extension(const char *const *extensions, uint32_t count, const char *ext)
+{
+    while (count--)
+    {
+        if (!strcmp(extensions[count], ext))
+            return extensions[count];
+    }
+    return NULL;
+}
+
+static VkResult wine_vk_device_convert_create_info(VkPhysicalDevice client_physical_device,
         struct conversion_context *ctx, const VkDeviceCreateInfo *src, VkDeviceCreateInfo *dst)
 {
-    bool has_swapchain_maintenance1 = false;
-    bool has_external_memory_host = false;
-    bool has_surface_maintenance1 = false;
-    bool has_map_memory_placed = false;
-    bool has_external_memory = false;
-    bool has_map_memory2 = false;
-    bool has_swapchain = false;
-    const char **extensions;
-    uint32_t count;
+    struct vulkan_physical_device *physical_device = vulkan_physical_device_from_handle(client_physical_device);
+    const char *extra_extensions[3], * const*extensions = src->ppEnabledExtensionNames;
+    unsigned int i, extra_count = 0, extensions_count = src->enabledExtensionCount;
 
     *dst = *src;
 
@@ -551,25 +553,16 @@ static VkResult wine_vk_device_convert_create_info(struct vulkan_physical_device
     dst->enabledLayerCount = 0;
     dst->ppEnabledLayerNames = NULL;
 
-    count = src->enabledExtensionCount;
-    extensions = conversion_context_alloc(ctx, (count + 16) * sizeof(*extensions));
-    memcpy(extensions, dst->ppEnabledExtensionNames, count * sizeof(*extensions));
-    dst->ppEnabledExtensionNames = extensions;
-
-    for (const char **extension = extensions, **end = extension + count; extension < end; extension++)
+    TRACE("Enabled %u extensions.\n", extensions_count);
+    for (i = 0; i < extensions_count; i++)
     {
-        if (!wine_vk_device_extension_supported(*extension))
+        const char *extension_name = extensions[i];
+        TRACE("Extension %u: %s.\n", i, debugstr_a(extension_name));
+        if (!wine_vk_device_extension_supported(extension_name))
         {
-            WARN("Extension %s is not supported.\n", debugstr_a(*extension));
+            WARN("Extension %s is not supported.\n", debugstr_a(extension_name));
             return VK_ERROR_EXTENSION_NOT_PRESENT;
         }
-        if (!strcmp(*extension, "VK_EXT_map_memory_placed")) has_map_memory_placed = true;
-        if (!strcmp(*extension, "VK_KHR_map_memory2")) has_map_memory2 = true;
-        if (!strcmp(*extension, "VK_KHR_external_memory")) has_external_memory = true;
-        if (!strcmp(*extension, "VK_EXT_external_memory_host")) has_external_memory_host = true;
-        if (!strcmp(*extension, "VK_EXT_swapchain_maintenance1")) has_swapchain_maintenance1 = true;
-        if (!strcmp(*extension, "VK_EXT_surface_maintenance1")) has_surface_maintenance1 = true;
-        if (!strcmp(*extension, "VK_KHR_swapchain")) has_swapchain = true;
     }
 
     if (physical_device->map_placed_align)
@@ -583,28 +576,37 @@ static VkResult wine_vk_device_convert_create_info(struct vulkan_physical_device
         map_placed_features->memoryUnmapReserve = VK_TRUE;
         dst->pNext = map_placed_features;
 
-        if (!has_map_memory_placed) extensions[count++] = "VK_EXT_map_memory_placed";
-        if (!has_map_memory2) extensions[count++] = "VK_KHR_map_memory2";
+        if (!find_extension(extensions, extensions_count, "VK_EXT_map_memory_placed"))
+            extra_extensions[extra_count++] = "VK_EXT_map_memory_placed";
+        if (!find_extension(extensions, extensions_count, "VK_KHR_map_memory2"))
+            extra_extensions[extra_count++] = "VK_KHR_map_memory2";
     }
     else if (physical_device->external_memory_align)
     {
-        if (!has_external_memory) extensions[count++] = "VK_KHR_external_memory";
-        if (!has_external_memory_host) extensions[count++] = "VK_EXT_external_memory_host";
+        if (!find_extension(extensions, extensions_count, "VK_KHR_external_memory"))
+            extra_extensions[extra_count++] = "VK_KHR_external_memory";
+        if (!find_extension(extensions, extensions_count, "VK_EXT_external_memory_host"))
+            extra_extensions[extra_count++] = "VK_EXT_external_memory_host";
     }
 
     /* win32u uses VkSwapchainPresentScalingCreateInfoEXT if available. */
-    if (physical_device->has_surface_maintenance1 && physical_device->has_swapchain_maintenance1 &&
-        has_swapchain && !has_swapchain_maintenance1)
+    if (physical_device->has_swapchain_maintenance1)
     {
-        if (!has_surface_maintenance1) extensions[count++] = "VK_EXT_surface_maintenance1";
-        extensions[count++] = "VK_EXT_swapchain_maintenance1";
+        if (!find_extension(extensions, extensions_count, "VK_EXT_swapchain_maintenance1"))
+            extra_extensions[extra_count++] = "VK_EXT_swapchain_maintenance1";
     }
 
-    TRACE("Enabling %u device extensions\n", count);
-    for (const char **extension = extensions, **end = extension + count; extension < end; extension++)
-        TRACE("  - %s\n", debugstr_a(*extension));
+    if (extra_count)
+    {
+        const char **new_extensions;
+
+        dst->enabledExtensionCount += extra_count;
+        new_extensions = conversion_context_alloc(ctx, dst->enabledExtensionCount * sizeof(*new_extensions));
+        memcpy(new_extensions, extensions, extensions_count * sizeof(*new_extensions));
+        memcpy(new_extensions + extensions_count, extra_extensions, extra_count * sizeof(*new_extensions));
+        dst->ppEnabledExtensionNames = new_extensions;
+    }
 
-    dst->enabledExtensionCount = count;
     return VK_SUCCESS;
 }
 
@@ -644,10 +646,9 @@ static VkResult wine_vk_instance_convert_create_info(struct conversion_context *
 {
     VkDebugUtilsMessengerCreateInfoEXT *debug_utils_messenger;
     VkDebugReportCallbackCreateInfoEXT *debug_report_callback;
+    const char **new_extensions;
     VkBaseInStructure *header;
-    const char **extensions;
     unsigned int i;
-    uint32_t count;
 
     *dst = *src;
 
@@ -700,37 +701,36 @@ static VkResult wine_vk_instance_convert_create_info(struct conversion_context *
         }
     }
 
-    count = src->enabledExtensionCount;
-    extensions = conversion_context_alloc(ctx, (count + 2) * sizeof(*extensions));
-    memcpy(extensions, src->ppEnabledExtensionNames, count * sizeof(*dst->ppEnabledExtensionNames));
-    dst->ppEnabledExtensionNames = extensions;
+    new_extensions = conversion_context_alloc(ctx, (src->enabledExtensionCount + 2) *
+                                              sizeof(*src->ppEnabledExtensionNames));
+    memcpy(new_extensions, src->ppEnabledExtensionNames,
+           dst->enabledExtensionCount * sizeof(*dst->ppEnabledExtensionNames));
+    dst->ppEnabledExtensionNames = new_extensions;
     dst->enabledExtensionCount = src->enabledExtensionCount;
 
-    for (const char **extension = extensions, **end = extension + count; extension < end; extension++)
+    for (i = 0; i < dst->enabledExtensionCount; i++)
     {
-        if (!strcmp(*extension, "VK_EXT_debug_utils") || !strcmp(*extension, "VK_EXT_debug_report"))
+        const char *extension_name = dst->ppEnabledExtensionNames[i];
+        if (!strcmp(extension_name, "VK_EXT_debug_utils") || !strcmp(extension_name, "VK_EXT_debug_report"))
         {
             rb_init(&instance->objects, vulkan_object_compare);
             pthread_rwlock_init(&instance->objects_lock, NULL);
         }
-        if (!strcmp(*extension, "VK_KHR_win32_surface"))
+        if (!strcmp(extension_name, "VK_KHR_win32_surface"))
         {
-            *extension = vk_funcs->p_get_host_surface_extension();
+            new_extensions[i] = vk_funcs->p_get_host_surface_extension();
             instance->enable_win32_surface = VK_TRUE;
         }
     }
 
     if (use_external_memory())
     {
-        extensions[count++] = "VK_KHR_get_physical_device_properties2";
-        extensions[count++] = "VK_KHR_external_memory_capabilities";
+        new_extensions[dst->enabledExtensionCount++] = "VK_KHR_get_physical_device_properties2";
+        new_extensions[dst->enabledExtensionCount++] = "VK_KHR_external_memory_capabilities";
     }
 
-    TRACE("Enabling %u instance extensions\n", count);
-    for (const char **extension = extensions, **end = extension + count; extension < end; extension++)
-        TRACE("  - %s\n", debugstr_a(*extension));
+    TRACE("Enabled %u instance extensions.\n", dst->enabledExtensionCount);
 
-    dst->enabledExtensionCount = count;
     return VK_SUCCESS;
 }
 
@@ -894,7 +894,7 @@ VkResult wine_vkCreateDevice(VkPhysicalDevice client_physical_device, const VkDe
         return VK_ERROR_OUT_OF_HOST_MEMORY;
 
     init_conversion_context(&ctx);
-    res = wine_vk_device_convert_create_info(physical_device, &ctx, create_info, &create_info_host);
+    res = wine_vk_device_convert_create_info(client_physical_device, &ctx, create_info, &create_info_host);
     if (res == VK_SUCCESS)
         res = instance->p_vkCreateDevice(physical_device->host.physical_device, &create_info_host,
                                                NULL /* allocator */, &host_device);
diff --git b/dlls/winevulkan/vulkan_thunks.c a/dlls/winevulkan/vulkan_thunks.c
index 7fa3491fedb..b6d5c15e989 100644
--- b/dlls/winevulkan/vulkan_thunks.c
+++ a/dlls/winevulkan/vulkan_thunks.c
@@ -9612,16 +9612,12 @@ static uint64_t wine_vk_unwrap_handle(uint32_t type, uint64_t handle)
         return (uint64_t) (uintptr_t) vulkan_device_from_handle(((VkDevice) (uintptr_t) handle))->host.device;
     case VK_OBJECT_TYPE_DEVICE_MEMORY:
         return (uint64_t) vulkan_device_memory_from_handle(handle)->host.device_memory;
-    case VK_OBJECT_TYPE_FENCE:
-        return (uint64_t) vulkan_fence_from_handle(handle)->host.fence;
     case VK_OBJECT_TYPE_INSTANCE:
         return (uint64_t) (uintptr_t) vulkan_instance_from_handle(((VkInstance) (uintptr_t) handle))->host.instance;
     case VK_OBJECT_TYPE_PHYSICAL_DEVICE:
         return (uint64_t) (uintptr_t) vulkan_physical_device_from_handle(((VkPhysicalDevice) (uintptr_t) handle))->host.physical_device;
     case VK_OBJECT_TYPE_QUEUE:
         return (uint64_t) (uintptr_t) vulkan_queue_from_handle(((VkQueue) (uintptr_t) handle))->host.queue;
-    case VK_OBJECT_TYPE_SEMAPHORE:
-        return (uint64_t) vulkan_semaphore_from_handle(handle)->host.semaphore;
     case VK_OBJECT_TYPE_SURFACE_KHR:
         return (uint64_t) vulkan_surface_from_handle(handle)->host.surface;
     case VK_OBJECT_TYPE_SWAPCHAIN_KHR:
@@ -28443,7 +28439,7 @@ static void convert_VkVideoEncodeSessionParametersFeedbackInfoKHR_host_to_win32(
     }
 }
 
-static void convert_VkFenceGetWin32HandleInfoKHR_win32_to_unwrapped_host(const VkFenceGetWin32HandleInfoKHR32 *in, VkFenceGetWin32HandleInfoKHR *out)
+static void convert_VkFenceGetWin32HandleInfoKHR_win32_to_host(const VkFenceGetWin32HandleInfoKHR32 *in, VkFenceGetWin32HandleInfoKHR *out)
 {
     if (!in) return;
 
@@ -38956,7 +38952,7 @@ static void convert_VkSamplerCaptureDescriptorDataInfoEXT_win32_to_host(const Vk
         FIXME("Unexpected pNext\n");
 }
 
-static void convert_VkSemaphoreGetWin32HandleInfoKHR_win32_to_unwrapped_host(const VkSemaphoreGetWin32HandleInfoKHR32 *in, VkSemaphoreGetWin32HandleInfoKHR *out)
+static void convert_VkSemaphoreGetWin32HandleInfoKHR_win32_to_host(const VkSemaphoreGetWin32HandleInfoKHR32 *in, VkSemaphoreGetWin32HandleInfoKHR *out)
 {
     if (!in) return;
 
@@ -39065,7 +39061,7 @@ static void convert_VkVideoSessionMemoryRequirementsKHR_array_host_to_win32(cons
     }
 }
 
-static void convert_VkImportFenceWin32HandleInfoKHR_win32_to_unwrapped_host(const VkImportFenceWin32HandleInfoKHR32 *in, VkImportFenceWin32HandleInfoKHR *out)
+static void convert_VkImportFenceWin32HandleInfoKHR_win32_to_host(const VkImportFenceWin32HandleInfoKHR32 *in, VkImportFenceWin32HandleInfoKHR *out)
 {
     if (!in) return;
 
@@ -39080,7 +39076,7 @@ static void convert_VkImportFenceWin32HandleInfoKHR_win32_to_unwrapped_host(cons
         FIXME("Unexpected pNext\n");
 }
 
-static void convert_VkImportSemaphoreWin32HandleInfoKHR_win32_to_unwrapped_host(const VkImportSemaphoreWin32HandleInfoKHR32 *in, VkImportSemaphoreWin32HandleInfoKHR *out)
+static void convert_VkImportSemaphoreWin32HandleInfoKHR_win32_to_host(const VkImportSemaphoreWin32HandleInfoKHR32 *in, VkImportSemaphoreWin32HandleInfoKHR *out)
 {
     if (!in) return;
 
@@ -39106,25 +39102,13 @@ static void convert_VkInitializePerformanceApiInfoINTEL_win32_to_host(const VkIn
         FIXME("Unexpected pNext\n");
 }
 
-#ifdef _WIN64
-static void convert_VkLatencySleepInfoNV_win64_to_host(const VkLatencySleepInfoNV *in, VkLatencySleepInfoNV *out)
-{
-    if (!in) return;
-
-    out->sType = in->sType;
-    out->pNext = in->pNext;
-    out->signalSemaphore = vulkan_semaphore_from_handle(in->signalSemaphore)->host.semaphore;
-    out->value = in->value;
-}
-#endif /* _WIN64 */
-
 static void convert_VkLatencySleepInfoNV_win32_to_host(const VkLatencySleepInfoNV32 *in, VkLatencySleepInfoNV *out)
 {
     if (!in) return;
 
     out->sType = in->sType;
     out->pNext = NULL;
-    out->signalSemaphore = vulkan_semaphore_from_handle(in->signalSemaphore)->host.semaphore;
+    out->signalSemaphore = in->signalSemaphore;
     out->value = in->value;
     if (in->pNext)
         FIXME("Unexpected pNext\n");
@@ -39172,24 +39156,6 @@ static void convert_VkMemoryMapInfo_win32_to_unwrapped_host(const VkMemoryMapInf
         FIXME("Unexpected pNext\n");
 }
 
-#ifdef _WIN64
-static const VkSemaphore *convert_VkSemaphore_array_win64_to_host(struct conversion_context *ctx, const VkSemaphore *in, uint32_t count)
-{
-    VkSemaphore *out;
-    unsigned int i;
-
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
-    {
-        out[i] = vulkan_semaphore_from_handle(in[i])->host.semaphore;
-    }
-
-    return out;
-}
-#endif /* _WIN64 */
-
 #ifdef _WIN64
 static void convert_VkSparseMemoryBind_win64_to_host(const VkSparseMemoryBind *in, VkSparseMemoryBind *out)
 {
@@ -39348,7 +39314,7 @@ static void convert_VkBindSparseInfo_win64_to_host(struct conversion_context *ct
     out->sType = in->sType;
     out->pNext = in->pNext;
     out->waitSemaphoreCount = in->waitSemaphoreCount;
-    out->pWaitSemaphores = convert_VkSemaphore_array_win64_to_host(ctx, in->pWaitSemaphores, in->waitSemaphoreCount);
+    out->pWaitSemaphores = in->pWaitSemaphores;
     out->bufferBindCount = in->bufferBindCount;
     out->pBufferBinds = convert_VkSparseBufferMemoryBindInfo_array_win64_to_host(ctx, in->pBufferBinds, in->bufferBindCount);
     out->imageOpaqueBindCount = in->imageOpaqueBindCount;
@@ -39356,7 +39322,7 @@ static void convert_VkBindSparseInfo_win64_to_host(struct conversion_context *ct
     out->imageBindCount = in->imageBindCount;
     out->pImageBinds = convert_VkSparseImageMemoryBindInfo_array_win64_to_host(ctx, in->pImageBinds, in->imageBindCount);
     out->signalSemaphoreCount = in->signalSemaphoreCount;
-    out->pSignalSemaphores = convert_VkSemaphore_array_win64_to_host(ctx, in->pSignalSemaphores, in->signalSemaphoreCount);
+    out->pSignalSemaphores = in->pSignalSemaphores;
 }
 #endif /* _WIN64 */
 
@@ -39378,22 +39344,6 @@ static const VkBindSparseInfo *convert_VkBindSparseInfo_array_win64_to_host(stru
 }
 #endif /* _WIN64 */
 
-static const VkSemaphore *convert_VkSemaphore_array_win32_to_host(struct conversion_context *ctx, const VkSemaphore *in, uint32_t count)
-{
-    VkSemaphore *out;
-    unsigned int i;
-
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
-    {
-        out[i] = vulkan_semaphore_from_handle(in[i])->host.semaphore;
-    }
-
-    return out;
-}
-
 static void convert_VkSparseMemoryBind_win32_to_host(const VkSparseMemoryBind32 *in, VkSparseMemoryBind *out)
 {
     if (!in) return;
@@ -39534,7 +39484,7 @@ static void convert_VkBindSparseInfo_win32_to_host(struct conversion_context *ct
     out->sType = in->sType;
     out->pNext = NULL;
     out->waitSemaphoreCount = in->waitSemaphoreCount;
-    out->pWaitSemaphores = convert_VkSemaphore_array_win32_to_host(ctx, (const VkSemaphore *)UlongToPtr(in->pWaitSemaphores), in->waitSemaphoreCount);
+    out->pWaitSemaphores = UlongToPtr(in->pWaitSemaphores);
     out->bufferBindCount = in->bufferBindCount;
     out->pBufferBinds = convert_VkSparseBufferMemoryBindInfo_array_win32_to_host(ctx, (const VkSparseBufferMemoryBindInfo32 *)UlongToPtr(in->pBufferBinds), in->bufferBindCount);
     out->imageOpaqueBindCount = in->imageOpaqueBindCount;
@@ -39542,7 +39492,7 @@ static void convert_VkBindSparseInfo_win32_to_host(struct conversion_context *ct
     out->imageBindCount = in->imageBindCount;
     out->pImageBinds = convert_VkSparseImageMemoryBindInfo_array_win32_to_host(ctx, (const VkSparseImageMemoryBindInfo32 *)UlongToPtr(in->pImageBinds), in->imageBindCount);
     out->signalSemaphoreCount = in->signalSemaphoreCount;
-    out->pSignalSemaphores = convert_VkSemaphore_array_win32_to_host(ctx, (const VkSemaphore *)UlongToPtr(in->pSignalSemaphores), in->signalSemaphoreCount);
+    out->pSignalSemaphores = UlongToPtr(in->pSignalSemaphores);
 
     for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
     {
@@ -39639,24 +39589,6 @@ static void convert_VkOutOfBandQueueTypeInfoNV_win32_to_host(const VkOutOfBandQu
         FIXME("Unexpected pNext\n");
 }
 
-#ifdef _WIN64
-static const VkSemaphore *convert_VkSemaphore_array_win64_to_unwrapped_host(struct conversion_context *ctx, const VkSemaphore *in, uint32_t count)
-{
-    VkSemaphore *out;
-    unsigned int i;
-
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
-    {
-        out[i] = in[i];
-    }
-
-    return out;
-}
-#endif /* _WIN64 */
-
 #ifdef _WIN64
 static const VkSwapchainKHR *convert_VkSwapchainKHR_array_win64_to_unwrapped_host(struct conversion_context *ctx, const VkSwapchainKHR *in, uint32_t count)
 {
@@ -39675,173 +39607,22 @@ static const VkSwapchainKHR *convert_VkSwapchainKHR_array_win64_to_unwrapped_hos
 }
 #endif /* _WIN64 */
 
-#ifdef _WIN64
-static const VkFence *convert_VkFence_array_win64_to_host(struct conversion_context *ctx, const VkFence *in, uint32_t count)
-{
-    VkFence *out;
-    unsigned int i;
-
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
-    {
-        out[i] = vulkan_fence_from_handle(in[i])->host.fence;
-    }
-
-    return out;
-}
-#endif /* _WIN64 */
-
 #ifdef _WIN64
 static void convert_VkPresentInfoKHR_win64_to_unwrapped_host(struct conversion_context *ctx, const VkPresentInfoKHR *in, VkPresentInfoKHR *out)
 {
-    const VkBaseInStructure *in_header;
-    VkBaseOutStructure *out_header = (void *)out;
-
     if (!in) return;
 
     out->sType = in->sType;
-    out->pNext = NULL;
+    out->pNext = in->pNext;
     out->waitSemaphoreCount = in->waitSemaphoreCount;
-    out->pWaitSemaphores = convert_VkSemaphore_array_win64_to_unwrapped_host(ctx, in->pWaitSemaphores, in->waitSemaphoreCount);
+    out->pWaitSemaphores = in->pWaitSemaphores;
     out->swapchainCount = in->swapchainCount;
     out->pSwapchains = convert_VkSwapchainKHR_array_win64_to_unwrapped_host(ctx, in->pSwapchains, in->swapchainCount);
     out->pImageIndices = in->pImageIndices;
     out->pResults = in->pResults;
-
-    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
-    {
-        switch (in_header->sType)
-        {
-        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
-        {
-            VkDeviceGroupPresentInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkDeviceGroupPresentInfoKHR *in_ext = (const VkDeviceGroupPresentInfoKHR *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR;
-            out_ext->pNext = NULL;
-            out_ext->swapchainCount = in_ext->swapchainCount;
-            out_ext->pDeviceMasks = in_ext->pDeviceMasks;
-            out_ext->mode = in_ext->mode;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT:
-        {
-            VkFrameBoundaryEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkFrameBoundaryEXT *in_ext = (const VkFrameBoundaryEXT *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT;
-            out_ext->pNext = NULL;
-            out_ext->flags = in_ext->flags;
-            out_ext->frameID = in_ext->frameID;
-            out_ext->imageCount = in_ext->imageCount;
-            out_ext->pImages = in_ext->pImages;
-            out_ext->bufferCount = in_ext->bufferCount;
-            out_ext->pBuffers = in_ext->pBuffers;
-            out_ext->tagName = in_ext->tagName;
-            out_ext->tagSize = in_ext->tagSize;
-            out_ext->pTag = in_ext->pTag;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM:
-        {
-            VkFrameBoundaryTensorsARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkFrameBoundaryTensorsARM *in_ext = (const VkFrameBoundaryTensorsARM *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM;
-            out_ext->pNext = NULL;
-            out_ext->tensorCount = in_ext->tensorCount;
-            out_ext->pTensors = in_ext->pTensors;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR:
-        {
-            VkPresentId2KHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkPresentId2KHR *in_ext = (const VkPresentId2KHR *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR;
-            out_ext->pNext = NULL;
-            out_ext->swapchainCount = in_ext->swapchainCount;
-            out_ext->pPresentIds = in_ext->pPresentIds;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_PRESENT_ID_KHR:
-        {
-            VkPresentIdKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkPresentIdKHR *in_ext = (const VkPresentIdKHR *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_PRESENT_ID_KHR;
-            out_ext->pNext = NULL;
-            out_ext->swapchainCount = in_ext->swapchainCount;
-            out_ext->pPresentIds = in_ext->pPresentIds;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
-        {
-            VkPresentRegionsKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkPresentRegionsKHR *in_ext = (const VkPresentRegionsKHR *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR;
-            out_ext->pNext = NULL;
-            out_ext->swapchainCount = in_ext->swapchainCount;
-            out_ext->pRegions = in_ext->pRegions;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR:
-        {
-            VkSwapchainPresentFenceInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkSwapchainPresentFenceInfoKHR *in_ext = (const VkSwapchainPresentFenceInfoKHR *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR;
-            out_ext->pNext = NULL;
-            out_ext->swapchainCount = in_ext->swapchainCount;
-            out_ext->pFences = convert_VkFence_array_win64_to_host(ctx, in_ext->pFences, in_ext->swapchainCount);
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR:
-        {
-            VkSwapchainPresentModeInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkSwapchainPresentModeInfoKHR *in_ext = (const VkSwapchainPresentModeInfoKHR *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR;
-            out_ext->pNext = NULL;
-            out_ext->swapchainCount = in_ext->swapchainCount;
-            out_ext->pPresentModes = in_ext->pPresentModes;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
-            break;
-        }
-    }
 }
 #endif /* _WIN64 */
 
-static const VkSemaphore *convert_VkSemaphore_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSemaphore *in, uint32_t count)
-{
-    VkSemaphore *out;
-    unsigned int i;
-
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
-    {
-        out[i] = in[i];
-    }
-
-    return out;
-}
-
 static const VkSwapchainKHR *convert_VkSwapchainKHR_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSwapchainKHR *in, uint32_t count)
 {
     VkSwapchainKHR *out;
@@ -39882,22 +39663,6 @@ static const VkPresentRegionKHR *convert_VkPresentRegionKHR_array_win32_to_host(
     return out;
 }
 
-static const VkFence *convert_VkFence_array_win32_to_host(struct conversion_context *ctx, const VkFence *in, uint32_t count)
-{
-    VkFence *out;
-    unsigned int i;
-
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
-    {
-        out[i] = vulkan_fence_from_handle(in[i])->host.fence;
-    }
-
-    return out;
-}
-
 static void convert_VkPresentInfoKHR_win32_to_unwrapped_host(struct conversion_context *ctx, const VkPresentInfoKHR32 *in, VkPresentInfoKHR *out)
 {
     const VkBaseInStructure32 *in_header;
@@ -39908,7 +39673,7 @@ static void convert_VkPresentInfoKHR_win32_to_unwrapped_host(struct conversion_c
     out->sType = in->sType;
     out->pNext = NULL;
     out->waitSemaphoreCount = in->waitSemaphoreCount;
-    out->pWaitSemaphores = convert_VkSemaphore_array_win32_to_unwrapped_host(ctx, (const VkSemaphore *)UlongToPtr(in->pWaitSemaphores), in->waitSemaphoreCount);
+    out->pWaitSemaphores = UlongToPtr(in->pWaitSemaphores);
     out->swapchainCount = in->swapchainCount;
     out->pSwapchains = convert_VkSwapchainKHR_array_win32_to_unwrapped_host(ctx, (const VkSwapchainKHR *)UlongToPtr(in->pSwapchains), in->swapchainCount);
     out->pImageIndices = UlongToPtr(in->pImageIndices);
@@ -40005,7 +39770,7 @@ static void convert_VkPresentInfoKHR_win32_to_unwrapped_host(struct conversion_c
             out_ext->sType = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR;
             out_ext->pNext = NULL;
             out_ext->swapchainCount = in_ext->swapchainCount;
-            out_ext->pFences = convert_VkFence_array_win32_to_host(ctx, (const VkFence *)UlongToPtr(in_ext->pFences), in_ext->swapchainCount);
+            out_ext->pFences = UlongToPtr(in_ext->pFences);
             out_header->pNext = (void *)out_ext;
             out_header = (void *)out_ext;
             break;
@@ -40076,12 +39841,12 @@ static void convert_VkSubmitInfo_win64_to_unwrapped_host(struct conversion_conte
     out->sType = in->sType;
     out->pNext = NULL;
     out->waitSemaphoreCount = in->waitSemaphoreCount;
-    out->pWaitSemaphores = convert_VkSemaphore_array_win64_to_unwrapped_host(ctx, in->pWaitSemaphores, in->waitSemaphoreCount);
+    out->pWaitSemaphores = in->pWaitSemaphores;
     out->pWaitDstStageMask = in->pWaitDstStageMask;
     out->commandBufferCount = in->commandBufferCount;
     out->pCommandBuffers = convert_VkCommandBuffer_array_win64_to_unwrapped_host(ctx, in->pCommandBuffers, in->commandBufferCount);
     out->signalSemaphoreCount = in->signalSemaphoreCount;
-    out->pSignalSemaphores = convert_VkSemaphore_array_win64_to_unwrapped_host(ctx, in->pSignalSemaphores, in->signalSemaphoreCount);
+    out->pSignalSemaphores = in->pSignalSemaphores;
 
     for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
     {
@@ -40264,12 +40029,12 @@ static void convert_VkSubmitInfo_win32_to_unwrapped_host(struct conversion_conte
     out->sType = in->sType;
     out->pNext = NULL;
     out->waitSemaphoreCount = in->waitSemaphoreCount;
-    out->pWaitSemaphores = convert_VkSemaphore_array_win32_to_unwrapped_host(ctx, (const VkSemaphore *)UlongToPtr(in->pWaitSemaphores), in->waitSemaphoreCount);
+    out->pWaitSemaphores = UlongToPtr(in->pWaitSemaphores);
     out->pWaitDstStageMask = UlongToPtr(in->pWaitDstStageMask);
     out->commandBufferCount = in->commandBufferCount;
     out->pCommandBuffers = convert_VkCommandBuffer_array_win32_to_unwrapped_host(ctx, (const PTR32 *)UlongToPtr(in->pCommandBuffers), in->commandBufferCount);
     out->signalSemaphoreCount = in->signalSemaphoreCount;
-    out->pSignalSemaphores = convert_VkSemaphore_array_win32_to_unwrapped_host(ctx, (const VkSemaphore *)UlongToPtr(in->pSignalSemaphores), in->signalSemaphoreCount);
+    out->pSignalSemaphores = UlongToPtr(in->pSignalSemaphores);
 
     for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
     {
@@ -40423,70 +40188,6 @@ static const VkSubmitInfo *convert_VkSubmitInfo_array_win32_to_unwrapped_host(st
     return out;
 }
 
-#ifdef _WIN64
-static void convert_VkSemaphoreSubmitInfo_win64_to_unwrapped_host(struct conversion_context *ctx, const VkSemaphoreSubmitInfo *in, VkSemaphoreSubmitInfo *out)
-{
-    if (!in) return;
-
-    out->sType = in->sType;
-    out->pNext = in->pNext;
-    out->semaphore = in->semaphore;
-    out->value = in->value;
-    out->stageMask = in->stageMask;
-    out->deviceIndex = in->deviceIndex;
-}
-#endif /* _WIN64 */
-
-#ifdef _WIN64
-static const VkSemaphoreSubmitInfo *convert_VkSemaphoreSubmitInfo_array_win64_to_unwrapped_host(struct conversion_context *ctx, const VkSemaphoreSubmitInfo *in, uint32_t count)
-{
-    VkSemaphoreSubmitInfo *out;
-    unsigned int i;
-
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
-    {
-        convert_VkSemaphoreSubmitInfo_win64_to_unwrapped_host(ctx, &in[i], &out[i]);
-    }
-
-    return out;
-}
-#endif /* _WIN64 */
-
-#ifdef _WIN64
-static void convert_VkSemaphoreSubmitInfo_win64_to_host(struct conversion_context *ctx, const VkSemaphoreSubmitInfo *in, VkSemaphoreSubmitInfo *out)
-{
-    if (!in) return;
-
-    out->sType = in->sType;
-    out->pNext = in->pNext;
-    out->semaphore = vulkan_semaphore_from_handle(in->semaphore)->host.semaphore;
-    out->value = in->value;
-    out->stageMask = in->stageMask;
-    out->deviceIndex = in->deviceIndex;
-}
-#endif /* _WIN64 */
-
-#ifdef _WIN64
-static const VkSemaphoreSubmitInfo *convert_VkSemaphoreSubmitInfo_array_win64_to_host(struct conversion_context *ctx, const VkSemaphoreSubmitInfo *in, uint32_t count)
-{
-    VkSemaphoreSubmitInfo *out;
-    unsigned int i;
-
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
-    {
-        convert_VkSemaphoreSubmitInfo_win64_to_host(ctx, &in[i], &out[i]);
-    }
-
-    return out;
-}
-#endif /* _WIN64 */
-
 #ifdef _WIN64
 static void convert_VkCommandBufferSubmitInfo_win64_to_unwrapped_host(struct conversion_context *ctx, const VkCommandBufferSubmitInfo *in, VkCommandBufferSubmitInfo *out)
 {
@@ -40511,7 +40212,7 @@ static void convert_VkCommandBufferSubmitInfo_win64_to_unwrapped_host(struct con
             out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM;
             out_ext->pNext = NULL;
             out_ext->stripeSemaphoreInfoCount = in_ext->stripeSemaphoreInfoCount;
-            out_ext->pStripeSemaphoreInfos = convert_VkSemaphoreSubmitInfo_array_win64_to_host(ctx, in_ext->pStripeSemaphoreInfos, in_ext->stripeSemaphoreInfoCount);
+            out_ext->pStripeSemaphoreInfos = in_ext->pStripeSemaphoreInfos;
             out_header->pNext = (void *)out_ext;
             out_header = (void *)out_ext;
             break;
@@ -40554,11 +40255,11 @@ static void convert_VkSubmitInfo2_win64_to_unwrapped_host(struct conversion_cont
     out->pNext = NULL;
     out->flags = in->flags;
     out->waitSemaphoreInfoCount = in->waitSemaphoreInfoCount;
-    out->pWaitSemaphoreInfos = convert_VkSemaphoreSubmitInfo_array_win64_to_unwrapped_host(ctx, in->pWaitSemaphoreInfos, in->waitSemaphoreInfoCount);
+    out->pWaitSemaphoreInfos = in->pWaitSemaphoreInfos;
     out->commandBufferInfoCount = in->commandBufferInfoCount;
     out->pCommandBufferInfos = convert_VkCommandBufferSubmitInfo_array_win64_to_unwrapped_host(ctx, in->pCommandBufferInfos, in->commandBufferInfoCount);
     out->signalSemaphoreInfoCount = in->signalSemaphoreInfoCount;
-    out->pSignalSemaphoreInfos = convert_VkSemaphoreSubmitInfo_array_win64_to_unwrapped_host(ctx, in->pSignalSemaphoreInfos, in->signalSemaphoreInfoCount);
+    out->pSignalSemaphoreInfos = in->pSignalSemaphoreInfos;
 
     for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
     {
@@ -40660,7 +40361,7 @@ static const VkSubmitInfo2 *convert_VkSubmitInfo2_array_win64_to_unwrapped_host(
 }
 #endif /* _WIN64 */
 
-static void convert_VkSemaphoreSubmitInfo_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSemaphoreSubmitInfo32 *in, VkSemaphoreSubmitInfo *out)
+static void convert_VkSemaphoreSubmitInfo_win32_to_host(const VkSemaphoreSubmitInfo32 *in, VkSemaphoreSubmitInfo *out)
 {
     if (!in) return;
 
@@ -40674,36 +40375,6 @@ static void convert_VkSemaphoreSubmitInfo_win32_to_unwrapped_host(struct convers
         FIXME("Unexpected pNext\n");
 }
 
-static const VkSemaphoreSubmitInfo *convert_VkSemaphoreSubmitInfo_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSemaphoreSubmitInfo32 *in, uint32_t count)
-{
-    VkSemaphoreSubmitInfo *out;
-    unsigned int i;
-
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
-    {
-        convert_VkSemaphoreSubmitInfo_win32_to_unwrapped_host(ctx, &in[i], &out[i]);
-    }
-
-    return out;
-}
-
-static void convert_VkSemaphoreSubmitInfo_win32_to_host(struct conversion_context *ctx, const VkSemaphoreSubmitInfo32 *in, VkSemaphoreSubmitInfo *out)
-{
-    if (!in) return;
-
-    out->sType = in->sType;
-    out->pNext = NULL;
-    out->semaphore = vulkan_semaphore_from_handle(in->semaphore)->host.semaphore;
-    out->value = in->value;
-    out->stageMask = in->stageMask;
-    out->deviceIndex = in->deviceIndex;
-    if (in->pNext)
-        FIXME("Unexpected pNext\n");
-}
-
 static const VkSemaphoreSubmitInfo *convert_VkSemaphoreSubmitInfo_array_win32_to_host(struct conversion_context *ctx, const VkSemaphoreSubmitInfo32 *in, uint32_t count)
 {
     VkSemaphoreSubmitInfo *out;
@@ -40714,7 +40385,7 @@ static const VkSemaphoreSubmitInfo *convert_VkSemaphoreSubmitInfo_array_win32_to
     out = conversion_context_alloc(ctx, count * sizeof(*out));
     for (i = 0; i < count; i++)
     {
-        convert_VkSemaphoreSubmitInfo_win32_to_host(ctx, &in[i], &out[i]);
+        convert_VkSemaphoreSubmitInfo_win32_to_host(&in[i], &out[i]);
     }
 
     return out;
@@ -40782,11 +40453,11 @@ static void convert_VkSubmitInfo2_win32_to_unwrapped_host(struct conversion_cont
     out->pNext = NULL;
     out->flags = in->flags;
     out->waitSemaphoreInfoCount = in->waitSemaphoreInfoCount;
-    out->pWaitSemaphoreInfos = convert_VkSemaphoreSubmitInfo_array_win32_to_unwrapped_host(ctx, (const VkSemaphoreSubmitInfo32 *)UlongToPtr(in->pWaitSemaphoreInfos), in->waitSemaphoreInfoCount);
+    out->pWaitSemaphoreInfos = convert_VkSemaphoreSubmitInfo_array_win32_to_host(ctx, (const VkSemaphoreSubmitInfo32 *)UlongToPtr(in->pWaitSemaphoreInfos), in->waitSemaphoreInfoCount);
     out->commandBufferInfoCount = in->commandBufferInfoCount;
     out->pCommandBufferInfos = convert_VkCommandBufferSubmitInfo_array_win32_to_unwrapped_host(ctx, (const VkCommandBufferSubmitInfo32 *)UlongToPtr(in->pCommandBufferInfos), in->commandBufferInfoCount);
     out->signalSemaphoreInfoCount = in->signalSemaphoreInfoCount;
-    out->pSignalSemaphoreInfos = convert_VkSemaphoreSubmitInfo_array_win32_to_unwrapped_host(ctx, (const VkSemaphoreSubmitInfo32 *)UlongToPtr(in->pSignalSemaphoreInfos), in->signalSemaphoreInfoCount);
+    out->pSignalSemaphoreInfos = convert_VkSemaphoreSubmitInfo_array_win32_to_host(ctx, (const VkSemaphoreSubmitInfo32 *)UlongToPtr(in->pSignalSemaphoreInfos), in->signalSemaphoreInfoCount);
 
     for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
     {
@@ -41094,25 +40765,13 @@ static void convert_VkLatencySleepModeInfoNV_win32_to_host(const VkLatencySleepM
         FIXME("Unexpected pNext\n");
 }
 
-#ifdef _WIN64
-static void convert_VkSemaphoreSignalInfo_win64_to_host(const VkSemaphoreSignalInfo *in, VkSemaphoreSignalInfo *out)
-{
-    if (!in) return;
-
-    out->sType = in->sType;
-    out->pNext = in->pNext;
-    out->semaphore = vulkan_semaphore_from_handle(in->semaphore)->host.semaphore;
-    out->value = in->value;
-}
-#endif /* _WIN64 */
-
 static void convert_VkSemaphoreSignalInfo_win32_to_host(const VkSemaphoreSignalInfo32 *in, VkSemaphoreSignalInfo *out)
 {
     if (!in) return;
 
     out->sType = in->sType;
     out->pNext = NULL;
-    out->semaphore = vulkan_semaphore_from_handle(in->semaphore)->host.semaphore;
+    out->semaphore = in->semaphore;
     out->value = in->value;
     if (in->pNext)
         FIXME("Unexpected pNext\n");
@@ -41450,21 +41109,7 @@ static void convert_VkPresentWait2InfoKHR_win32_to_host(const VkPresentWait2Info
         FIXME("Unexpected pNext\n");
 }
 
-#ifdef _WIN64
-static void convert_VkSemaphoreWaitInfo_win64_to_host(struct conversion_context *ctx, const VkSemaphoreWaitInfo *in, VkSemaphoreWaitInfo *out)
-{
-    if (!in) return;
-
-    out->sType = in->sType;
-    out->pNext = in->pNext;
-    out->flags = in->flags;
-    out->semaphoreCount = in->semaphoreCount;
-    out->pSemaphores = convert_VkSemaphore_array_win64_to_host(ctx, in->pSemaphores, in->semaphoreCount);
-    out->pValues = in->pValues;
-}
-#endif /* _WIN64 */
-
-static void convert_VkSemaphoreWaitInfo_win32_to_host(struct conversion_context *ctx, const VkSemaphoreWaitInfo32 *in, VkSemaphoreWaitInfo *out)
+static void convert_VkSemaphoreWaitInfo_win32_to_host(const VkSemaphoreWaitInfo32 *in, VkSemaphoreWaitInfo *out)
 {
     if (!in) return;
 
@@ -41472,7 +41117,7 @@ static void convert_VkSemaphoreWaitInfo_win32_to_host(struct conversion_context
     out->pNext = NULL;
     out->flags = in->flags;
     out->semaphoreCount = in->semaphoreCount;
-    out->pSemaphores = convert_VkSemaphore_array_win32_to_host(ctx, (const VkSemaphore *)UlongToPtr(in->pSemaphores), in->semaphoreCount);
+    out->pSemaphores = UlongToPtr(in->pSemaphores);
     out->pValues = UlongToPtr(in->pValues);
     if (in->pNext)
         FIXME("Unexpected pNext\n");
@@ -54711,7 +54356,7 @@ static NTSTATUS thunk64_vkGetFenceStatus(void *args)
 
     TRACE("%p, 0x%s\n", params->device, wine_dbgstr_longlong(params->fence));
 
-    params->result = vulkan_device_from_handle(params->device)->p_vkGetFenceStatus(vulkan_device_from_handle(params->device)->host.device, vulkan_fence_from_handle(params->fence)->host.fence);
+    params->result = vulkan_device_from_handle(params->device)->p_vkGetFenceStatus(vulkan_device_from_handle(params->device)->host.device, params->fence);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -54727,7 +54372,7 @@ static NTSTATUS thunk32_vkGetFenceStatus(void *args)
 
     TRACE("%#x, 0x%s\n", params->device, wine_dbgstr_longlong(params->fence));
 
-    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetFenceStatus(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, vulkan_fence_from_handle(params->fence)->host.fence);
+    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetFenceStatus(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->fence);
     return STATUS_SUCCESS;
 }
 
@@ -54756,7 +54401,7 @@ static NTSTATUS thunk32_vkGetFenceWin32HandleKHR(void *args)
 
     TRACE("%#x, %#x, %#x\n", params->device, params->pGetWin32HandleInfo, params->pHandle);
 
-    convert_VkFenceGetWin32HandleInfoKHR_win32_to_unwrapped_host((const VkFenceGetWin32HandleInfoKHR32 *)UlongToPtr(params->pGetWin32HandleInfo), &pGetWin32HandleInfo_host);
+    convert_VkFenceGetWin32HandleInfoKHR_win32_to_host((const VkFenceGetWin32HandleInfoKHR32 *)UlongToPtr(params->pGetWin32HandleInfo), &pGetWin32HandleInfo_host);
     params->result = vk_funcs->p_vkGetFenceWin32HandleKHR((VkDevice)UlongToPtr(params->device), &pGetWin32HandleInfo_host, (HANDLE *)UlongToPtr(params->pHandle));
     return STATUS_SUCCESS;
 }
@@ -58143,7 +57788,7 @@ static NTSTATUS thunk64_vkGetSemaphoreCounterValue(void *args)
 
     TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->semaphore), params->pValue);
 
-    params->result = vulkan_device_from_handle(params->device)->p_vkGetSemaphoreCounterValue(vulkan_device_from_handle(params->device)->host.device, vulkan_semaphore_from_handle(params->semaphore)->host.semaphore, params->pValue);
+    params->result = vulkan_device_from_handle(params->device)->p_vkGetSemaphoreCounterValue(vulkan_device_from_handle(params->device)->host.device, params->semaphore, params->pValue);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -58160,7 +57805,7 @@ static NTSTATUS thunk32_vkGetSemaphoreCounterValue(void *args)
 
     TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->semaphore), params->pValue);
 
-    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetSemaphoreCounterValue(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, vulkan_semaphore_from_handle(params->semaphore)->host.semaphore, (uint64_t *)UlongToPtr(params->pValue));
+    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetSemaphoreCounterValue(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->semaphore, (uint64_t *)UlongToPtr(params->pValue));
     return STATUS_SUCCESS;
 }
 
@@ -58171,7 +57816,7 @@ static NTSTATUS thunk64_vkGetSemaphoreCounterValueKHR(void *args)
 
     TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->semaphore), params->pValue);
 
-    params->result = vulkan_device_from_handle(params->device)->p_vkGetSemaphoreCounterValueKHR(vulkan_device_from_handle(params->device)->host.device, vulkan_semaphore_from_handle(params->semaphore)->host.semaphore, params->pValue);
+    params->result = vulkan_device_from_handle(params->device)->p_vkGetSemaphoreCounterValueKHR(vulkan_device_from_handle(params->device)->host.device, params->semaphore, params->pValue);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -58188,7 +57833,7 @@ static NTSTATUS thunk32_vkGetSemaphoreCounterValueKHR(void *args)
 
     TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->semaphore), params->pValue);
 
-    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetSemaphoreCounterValueKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, vulkan_semaphore_from_handle(params->semaphore)->host.semaphore, (uint64_t *)UlongToPtr(params->pValue));
+    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetSemaphoreCounterValueKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->semaphore, (uint64_t *)UlongToPtr(params->pValue));
     return STATUS_SUCCESS;
 }
 
@@ -58217,7 +57862,7 @@ static NTSTATUS thunk32_vkGetSemaphoreWin32HandleKHR(void *args)
 
     TRACE("%#x, %#x, %#x\n", params->device, params->pGetWin32HandleInfo, params->pHandle);
 
-    convert_VkSemaphoreGetWin32HandleInfoKHR_win32_to_unwrapped_host((const VkSemaphoreGetWin32HandleInfoKHR32 *)UlongToPtr(params->pGetWin32HandleInfo), &pGetWin32HandleInfo_host);
+    convert_VkSemaphoreGetWin32HandleInfoKHR_win32_to_host((const VkSemaphoreGetWin32HandleInfoKHR32 *)UlongToPtr(params->pGetWin32HandleInfo), &pGetWin32HandleInfo_host);
     params->result = vk_funcs->p_vkGetSemaphoreWin32HandleKHR((VkDevice)UlongToPtr(params->device), &pGetWin32HandleInfo_host, (HANDLE *)UlongToPtr(params->pHandle));
     return STATUS_SUCCESS;
 }
@@ -58571,7 +58216,7 @@ static NTSTATUS thunk32_vkImportFenceWin32HandleKHR(void *args)
 
     TRACE("%#x, %#x\n", params->device, params->pImportFenceWin32HandleInfo);
 
-    convert_VkImportFenceWin32HandleInfoKHR_win32_to_unwrapped_host((const VkImportFenceWin32HandleInfoKHR32 *)UlongToPtr(params->pImportFenceWin32HandleInfo), &pImportFenceWin32HandleInfo_host);
+    convert_VkImportFenceWin32HandleInfoKHR_win32_to_host((const VkImportFenceWin32HandleInfoKHR32 *)UlongToPtr(params->pImportFenceWin32HandleInfo), &pImportFenceWin32HandleInfo_host);
     params->result = vk_funcs->p_vkImportFenceWin32HandleKHR((VkDevice)UlongToPtr(params->device), &pImportFenceWin32HandleInfo_host);
     return STATUS_SUCCESS;
 }
@@ -58600,7 +58245,7 @@ static NTSTATUS thunk32_vkImportSemaphoreWin32HandleKHR(void *args)
 
     TRACE("%#x, %#x\n", params->device, params->pImportSemaphoreWin32HandleInfo);
 
-    convert_VkImportSemaphoreWin32HandleInfoKHR_win32_to_unwrapped_host((const VkImportSemaphoreWin32HandleInfoKHR32 *)UlongToPtr(params->pImportSemaphoreWin32HandleInfo), &pImportSemaphoreWin32HandleInfo_host);
+    convert_VkImportSemaphoreWin32HandleInfoKHR_win32_to_host((const VkImportSemaphoreWin32HandleInfoKHR32 *)UlongToPtr(params->pImportSemaphoreWin32HandleInfo), &pImportSemaphoreWin32HandleInfo_host);
     params->result = vk_funcs->p_vkImportSemaphoreWin32HandleKHR((VkDevice)UlongToPtr(params->device), &pImportSemaphoreWin32HandleInfo_host);
     return STATUS_SUCCESS;
 }
@@ -58678,12 +58323,10 @@ static NTSTATUS thunk32_vkInvalidateMappedMemoryRanges(void *args)
 static NTSTATUS thunk64_vkLatencySleepNV(void *args)
 {
     struct vkLatencySleepNV_params *params = args;
-    VkLatencySleepInfoNV pSleepInfo_host;
 
     TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->swapchain), params->pSleepInfo);
 
-    convert_VkLatencySleepInfoNV_win64_to_host(params->pSleepInfo, &pSleepInfo_host);
-    params->result = vulkan_device_from_handle(params->device)->p_vkLatencySleepNV(vulkan_device_from_handle(params->device)->host.device, vulkan_swapchain_from_handle(params->swapchain)->host.swapchain, &pSleepInfo_host);
+    params->result = vulkan_device_from_handle(params->device)->p_vkLatencySleepNV(vulkan_device_from_handle(params->device)->host.device, vulkan_swapchain_from_handle(params->swapchain)->host.swapchain, params->pSleepInfo);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -58906,7 +58549,7 @@ static NTSTATUS thunk64_vkQueueBindSparse(void *args)
 
     init_conversion_context(ctx);
     pBindInfo_host = convert_VkBindSparseInfo_array_win64_to_host(ctx, params->pBindInfo, params->bindInfoCount);
-    params->result = vulkan_queue_from_handle(params->queue)->device->p_vkQueueBindSparse(vulkan_queue_from_handle(params->queue)->host.queue, params->bindInfoCount, pBindInfo_host, params->fence ? vulkan_fence_from_handle(params->fence)->host.fence : 0);
+    params->result = vulkan_queue_from_handle(params->queue)->device->p_vkQueueBindSparse(vulkan_queue_from_handle(params->queue)->host.queue, params->bindInfoCount, pBindInfo_host, params->fence);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -58930,7 +58573,7 @@ static NTSTATUS thunk32_vkQueueBindSparse(void *args)
 
     init_conversion_context(ctx);
     pBindInfo_host = convert_VkBindSparseInfo_array_win32_to_host(ctx, (const VkBindSparseInfo32 *)UlongToPtr(params->pBindInfo), params->bindInfoCount);
-    params->result = vulkan_queue_from_handle((VkQueue)UlongToPtr(params->queue))->device->p_vkQueueBindSparse(vulkan_queue_from_handle((VkQueue)UlongToPtr(params->queue))->host.queue, params->bindInfoCount, pBindInfo_host, params->fence ? vulkan_fence_from_handle(params->fence)->host.fence : 0);
+    params->result = vulkan_queue_from_handle((VkQueue)UlongToPtr(params->queue))->device->p_vkQueueBindSparse(vulkan_queue_from_handle((VkQueue)UlongToPtr(params->queue))->host.queue, params->bindInfoCount, pBindInfo_host, params->fence);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -59489,16 +59132,10 @@ static NTSTATUS thunk32_vkResetEvent(void *args)
 static NTSTATUS thunk64_vkResetFences(void *args)
 {
     struct vkResetFences_params *params = args;
-    const VkFence *pFences_host;
-    struct conversion_context local_ctx;
-    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%p, %u, %p\n", params->device, params->fenceCount, params->pFences);
 
-    init_conversion_context(ctx);
-    pFences_host = convert_VkFence_array_win64_to_host(ctx, params->pFences, params->fenceCount);
-    params->result = vulkan_device_from_handle(params->device)->p_vkResetFences(vulkan_device_from_handle(params->device)->host.device, params->fenceCount, pFences_host);
-    free_conversion_context(ctx);
+    params->result = vulkan_device_from_handle(params->device)->p_vkResetFences(vulkan_device_from_handle(params->device)->host.device, params->fenceCount, params->pFences);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -59512,16 +59149,10 @@ static NTSTATUS thunk32_vkResetFences(void *args)
         PTR32 pFences;
         VkResult result;
     } *params = args;
-    const VkFence *pFences_host;
-    struct conversion_context local_ctx;
-    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%#x, %u, %#x\n", params->device, params->fenceCount, params->pFences);
 
-    init_conversion_context(ctx);
-    pFences_host = convert_VkFence_array_win32_to_host(ctx, (const VkFence *)UlongToPtr(params->pFences), params->fenceCount);
-    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkResetFences(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->fenceCount, pFences_host);
-    free_conversion_context(ctx);
+    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkResetFences(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->fenceCount, (const VkFence *)UlongToPtr(params->pFences));
     return STATUS_SUCCESS;
 }
 
@@ -59862,12 +59493,10 @@ static NTSTATUS thunk32_vkSetPrivateDataEXT(void *args)
 static NTSTATUS thunk64_vkSignalSemaphore(void *args)
 {
     struct vkSignalSemaphore_params *params = args;
-    VkSemaphoreSignalInfo pSignalInfo_host;
 
     TRACE("%p, %p\n", params->device, params->pSignalInfo);
 
-    convert_VkSemaphoreSignalInfo_win64_to_host(params->pSignalInfo, &pSignalInfo_host);
-    params->result = vulkan_device_from_handle(params->device)->p_vkSignalSemaphore(vulkan_device_from_handle(params->device)->host.device, &pSignalInfo_host);
+    params->result = vulkan_device_from_handle(params->device)->p_vkSignalSemaphore(vulkan_device_from_handle(params->device)->host.device, params->pSignalInfo);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -59893,12 +59522,10 @@ static NTSTATUS thunk32_vkSignalSemaphore(void *args)
 static NTSTATUS thunk64_vkSignalSemaphoreKHR(void *args)
 {
     struct vkSignalSemaphoreKHR_params *params = args;
-    VkSemaphoreSignalInfo pSignalInfo_host;
 
     TRACE("%p, %p\n", params->device, params->pSignalInfo);
 
-    convert_VkSemaphoreSignalInfo_win64_to_host(params->pSignalInfo, &pSignalInfo_host);
-    params->result = vulkan_device_from_handle(params->device)->p_vkSignalSemaphoreKHR(vulkan_device_from_handle(params->device)->host.device, &pSignalInfo_host);
+    params->result = vulkan_device_from_handle(params->device)->p_vkSignalSemaphoreKHR(vulkan_device_from_handle(params->device)->host.device, params->pSignalInfo);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -60380,16 +60007,10 @@ static NTSTATUS thunk32_vkUpdateVideoSessionParametersKHR(void *args)
 static NTSTATUS thunk64_vkWaitForFences(void *args)
 {
     struct vkWaitForFences_params *params = args;
-    const VkFence *pFences_host;
-    struct conversion_context local_ctx;
-    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%p, %u, %p, %u, 0x%s\n", params->device, params->fenceCount, params->pFences, params->waitAll, wine_dbgstr_longlong(params->timeout));
 
-    init_conversion_context(ctx);
-    pFences_host = convert_VkFence_array_win64_to_host(ctx, params->pFences, params->fenceCount);
-    params->result = vulkan_device_from_handle(params->device)->p_vkWaitForFences(vulkan_device_from_handle(params->device)->host.device, params->fenceCount, pFences_host, params->waitAll, params->timeout);
-    free_conversion_context(ctx);
+    params->result = vulkan_device_from_handle(params->device)->p_vkWaitForFences(vulkan_device_from_handle(params->device)->host.device, params->fenceCount, params->pFences, params->waitAll, params->timeout);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -60405,16 +60026,10 @@ static NTSTATUS thunk32_vkWaitForFences(void *args)
         uint64_t DECLSPEC_ALIGN(8) timeout;
         VkResult result;
     } *params = args;
-    const VkFence *pFences_host;
-    struct conversion_context local_ctx;
-    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%#x, %u, %#x, %u, 0x%s\n", params->device, params->fenceCount, params->pFences, params->waitAll, wine_dbgstr_longlong(params->timeout));
 
-    init_conversion_context(ctx);
-    pFences_host = convert_VkFence_array_win32_to_host(ctx, (const VkFence *)UlongToPtr(params->pFences), params->fenceCount);
-    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkWaitForFences(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->fenceCount, pFences_host, params->waitAll, params->timeout);
-    free_conversion_context(ctx);
+    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkWaitForFences(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->fenceCount, (const VkFence *)UlongToPtr(params->pFences), params->waitAll, params->timeout);
     return STATUS_SUCCESS;
 }
 
@@ -60481,16 +60096,10 @@ static NTSTATUS thunk32_vkWaitForPresentKHR(void *args)
 static NTSTATUS thunk64_vkWaitSemaphores(void *args)
 {
     struct vkWaitSemaphores_params *params = args;
-    VkSemaphoreWaitInfo pWaitInfo_host;
-    struct conversion_context local_ctx;
-    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%p, %p, 0x%s\n", params->device, params->pWaitInfo, wine_dbgstr_longlong(params->timeout));
 
-    init_conversion_context(ctx);
-    convert_VkSemaphoreWaitInfo_win64_to_host(ctx, params->pWaitInfo, &pWaitInfo_host);
-    params->result = vulkan_device_from_handle(params->device)->p_vkWaitSemaphores(vulkan_device_from_handle(params->device)->host.device, &pWaitInfo_host, params->timeout);
-    free_conversion_context(ctx);
+    params->result = vulkan_device_from_handle(params->device)->p_vkWaitSemaphores(vulkan_device_from_handle(params->device)->host.device, params->pWaitInfo, params->timeout);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -60505,15 +60114,11 @@ static NTSTATUS thunk32_vkWaitSemaphores(void *args)
         VkResult result;
     } *params = args;
     VkSemaphoreWaitInfo pWaitInfo_host;
-    struct conversion_context local_ctx;
-    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%#x, %#x, 0x%s\n", params->device, params->pWaitInfo, wine_dbgstr_longlong(params->timeout));
 
-    init_conversion_context(ctx);
-    convert_VkSemaphoreWaitInfo_win32_to_host(ctx, (const VkSemaphoreWaitInfo32 *)UlongToPtr(params->pWaitInfo), &pWaitInfo_host);
+    convert_VkSemaphoreWaitInfo_win32_to_host((const VkSemaphoreWaitInfo32 *)UlongToPtr(params->pWaitInfo), &pWaitInfo_host);
     params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkWaitSemaphores(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pWaitInfo_host, params->timeout);
-    free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
 
@@ -60521,16 +60126,10 @@ static NTSTATUS thunk32_vkWaitSemaphores(void *args)
 static NTSTATUS thunk64_vkWaitSemaphoresKHR(void *args)
 {
     struct vkWaitSemaphoresKHR_params *params = args;
-    VkSemaphoreWaitInfo pWaitInfo_host;
-    struct conversion_context local_ctx;
-    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%p, %p, 0x%s\n", params->device, params->pWaitInfo, wine_dbgstr_longlong(params->timeout));
 
-    init_conversion_context(ctx);
-    convert_VkSemaphoreWaitInfo_win64_to_host(ctx, params->pWaitInfo, &pWaitInfo_host);
-    params->result = vulkan_device_from_handle(params->device)->p_vkWaitSemaphoresKHR(vulkan_device_from_handle(params->device)->host.device, &pWaitInfo_host, params->timeout);
-    free_conversion_context(ctx);
+    params->result = vulkan_device_from_handle(params->device)->p_vkWaitSemaphoresKHR(vulkan_device_from_handle(params->device)->host.device, params->pWaitInfo, params->timeout);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -60545,15 +60144,11 @@ static NTSTATUS thunk32_vkWaitSemaphoresKHR(void *args)
         VkResult result;
     } *params = args;
     VkSemaphoreWaitInfo pWaitInfo_host;
-    struct conversion_context local_ctx;
-    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%#x, %#x, 0x%s\n", params->device, params->pWaitInfo, wine_dbgstr_longlong(params->timeout));
 
-    init_conversion_context(ctx);
-    convert_VkSemaphoreWaitInfo_win32_to_host(ctx, (const VkSemaphoreWaitInfo32 *)UlongToPtr(params->pWaitInfo), &pWaitInfo_host);
+    convert_VkSemaphoreWaitInfo_win32_to_host((const VkSemaphoreWaitInfo32 *)UlongToPtr(params->pWaitInfo), &pWaitInfo_host);
     params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkWaitSemaphoresKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pWaitInfo_host, params->timeout);
-    free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
 
@@ -61047,11 +60642,9 @@ BOOL wine_vk_is_type_wrapped(VkObjectType type)
         type == VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR ||
         type == VK_OBJECT_TYPE_DEVICE ||
         type == VK_OBJECT_TYPE_DEVICE_MEMORY ||
-        type == VK_OBJECT_TYPE_FENCE ||
         type == VK_OBJECT_TYPE_INSTANCE ||
         type == VK_OBJECT_TYPE_PHYSICAL_DEVICE ||
         type == VK_OBJECT_TYPE_QUEUE ||
-        type == VK_OBJECT_TYPE_SEMAPHORE ||
         type == VK_OBJECT_TYPE_SURFACE_KHR ||
         type == VK_OBJECT_TYPE_SWAPCHAIN_KHR;
 }
diff --git b/include/wine/vulkan_driver.h a/include/wine/vulkan_driver.h
index 6a31bc75b5b..9b42e895f01 100644
--- b/include/wine/vulkan_driver.h
+++ a/include/wine/vulkan_driver.h
@@ -47,7 +47,7 @@ struct vulkan_client_object
 #include "wine/rbtree.h"
 
 /* Wine internal vulkan driver version, needs to be bumped upon vulkan_funcs changes. */
-#define WINE_VULKAN_DRIVER_VERSION 46
+#define WINE_VULKAN_DRIVER_VERSION 44
 
 struct vulkan_object
 {
@@ -94,7 +94,6 @@ struct vulkan_physical_device
 {
     VULKAN_OBJECT_HEADER( VkPhysicalDevice, physical_device );
     struct vulkan_instance *instance;
-    bool has_surface_maintenance1;
     bool has_swapchain_maintenance1;
 
     VkExtensionProperties *extensions;
@@ -182,26 +181,6 @@ static inline struct vulkan_swapchain *vulkan_swapchain_from_handle( VkSwapchain
     return (struct vulkan_swapchain *)(UINT_PTR)handle;
 }
 
-struct vulkan_semaphore
-{
-    VULKAN_OBJECT_HEADER( VkSemaphore, semaphore );
-};
-
-static inline struct vulkan_semaphore *vulkan_semaphore_from_handle( VkSemaphore handle )
-{
-    return (struct vulkan_semaphore *)(UINT_PTR)handle;
-}
-
-struct vulkan_fence
-{
-    VULKAN_OBJECT_HEADER( VkFence, fence );
-};
-
-static inline struct vulkan_fence *vulkan_fence_from_handle( VkFence handle )
-{
-    return (struct vulkan_fence *)(UINT_PTR)handle;
-}
-
 struct vulkan_funcs
 {
     /* Vulkan global functions. These are the only calls at this point a graphics driver

diff --git b/dlls/win32u/vulkan.c a/dlls/win32u/vulkan.c
index a3546bf2291..da86d34732e 100644
--- b/dlls/win32u/vulkan.c
+++ a/dlls/win32u/vulkan.c
@@ -1041,225 +1041,6 @@ static VkResult win32u_vkQueuePresentKHR( VkQueue client_queue, const VkPresentI
     return res;
 }
 
-static VkResult win32u_vkQueueSubmit( VkQueue client_queue, uint32_t count, const VkSubmitInfo *submits, VkFence fence )
-{
-    struct vulkan_queue *queue = vulkan_queue_from_handle( client_queue );
-    struct vulkan_device *device = queue->device;
-
-    TRACE( "queue %p, count %u, submits %p, fence 0x%s\n", queue, count, submits, wine_dbgstr_longlong( fence ) );
-
-    for (uint32_t i = 0; i < count; i++)
-    {
-        VkSubmitInfo *submit = (VkSubmitInfo *)submits + i; /* cast away const, chain has been copied in the thunks */
-        VkBaseOutStructure **next, *prev = (VkBaseOutStructure *)submit;
-
-        for (uint32_t j = 0; j < submit->commandBufferCount; j++)
-        {
-            VkCommandBuffer *command_buffers = (VkCommandBuffer *)submit->pCommandBuffers; /* cast away const, chain has been copied in the thunks */
-            struct vulkan_command_buffer *command_buffer = vulkan_command_buffer_from_handle( command_buffers[j] );
-            command_buffers[j] = command_buffer->host.command_buffer;
-        }
-
-        for (next = &prev->pNext; *next; prev = *next, next = &(*next)->pNext)
-        {
-            switch ((*next)->sType)
-            {
-            case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
-                FIXME( "VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR not implemented!\n" );
-                *next = (*next)->pNext; next = &prev;
-                break;
-            case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO: break;
-            case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT: break;
-            case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM: break;
-            case VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV: break;
-            case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR: break;
-            case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO: break;
-            case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO: break;
-            case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
-                FIXME( "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR not implemented!\n" );
-                *next = (*next)->pNext; next = &prev;
-                break;
-            default: FIXME( "Unhandled sType %u.\n", (*next)->sType ); break;
-            }
-        }
-    }
-
-    return device->p_vkQueueSubmit( queue->host.queue, count, submits, fence );
-}
-
-static VkResult win32u_vkQueueSubmit2( VkQueue client_queue, uint32_t count, const VkSubmitInfo2 *submits, VkFence fence )
-{
-    struct vulkan_queue *queue = vulkan_queue_from_handle( client_queue );
-    struct vulkan_device *device = queue->device;
-
-    TRACE( "queue %p, count %u, submits %p, fence 0x%s\n", queue, count, submits, wine_dbgstr_longlong( fence ) );
-
-    for (uint32_t i = 0; i < count; i++)
-    {
-        VkSubmitInfo2 *submit = (VkSubmitInfo2 *)submits + i; /* cast away const, chain has been copied in the thunks */
-        VkBaseOutStructure **next, *prev = (VkBaseOutStructure *)submit;
-
-        for (uint32_t j = 0; j < submit->commandBufferInfoCount; j++)
-        {
-            VkCommandBufferSubmitInfoKHR *command_buffer_infos = (VkCommandBufferSubmitInfoKHR *)submit->pCommandBufferInfos; /* cast away const, chain has been copied in the thunks */
-            struct vulkan_command_buffer *command_buffer = vulkan_command_buffer_from_handle( command_buffer_infos[j].commandBuffer );
-            command_buffer_infos[j].commandBuffer = command_buffer->host.command_buffer;
-            if (command_buffer_infos->pNext) FIXME( "Unhandled struct chain\n" );
-        }
-
-        for (next = &prev->pNext; *next; prev = *next, next = &(*next)->pNext)
-        {
-            switch ((*next)->sType)
-            {
-            case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT: break;
-            case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM: break;
-            case VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV: break;
-            case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR: break;
-            case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
-                FIXME( "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR not implemented!\n" );
-                *next = (*next)->pNext; next = &prev;
-                break;
-            default: FIXME( "Unhandled sType %u.\n", (*next)->sType ); break;
-            }
-        }
-    }
-
-    return device->p_vkQueueSubmit2( queue->host.queue, count, submits, fence );
-}
-
-static VkResult win32u_vkCreateSemaphore( VkDevice client_device, const VkSemaphoreCreateInfo *client_create_info,
-                                          const VkAllocationCallbacks *allocator, VkSemaphore *ret )
-{
-    VkSemaphoreCreateInfo *create_info = (VkSemaphoreCreateInfo *)client_create_info; /* cast away const, chain has been copied in the thunks */
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    VkBaseOutStructure **next, *prev = (VkBaseOutStructure *)create_info;
-
-    TRACE( "device %p, create_info %p, allocator %p, ret %p\n", device, create_info, allocator, ret );
-
-    for (next = &prev->pNext; *next; prev = *next, next = &(*next)->pNext)
-    {
-        switch ((*next)->sType)
-        {
-        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
-            FIXME( "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO not implemented!\n" );
-            *next = (*next)->pNext; next = &prev;
-            break;
-        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
-            FIXME( "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR not implemented!\n" );
-            *next = (*next)->pNext; next = &prev;
-            break;
-        case VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV: break;
-        case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO: break;
-        default: FIXME( "Unhandled sType %u.\n", (*next)->sType ); break;
-        }
-    }
-
-    return device->p_vkCreateSemaphore( device->host.device, create_info, NULL /* allocator */, ret );
-}
-
-static void win32u_vkDestroySemaphore( VkDevice client_device, VkSemaphore client_semaphore, const VkAllocationCallbacks *allocator )
-{
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-
-    TRACE( "device %p, client_semaphore 0x%s, allocator %p\n", device, wine_dbgstr_longlong( client_semaphore ), allocator );
-
-    device->p_vkDestroySemaphore( device->host.device, client_semaphore, NULL /* allocator */ );
-}
-
-static VkResult win32u_vkGetSemaphoreWin32HandleKHR( VkDevice client_device, const VkSemaphoreGetWin32HandleInfoKHR *handle_info, HANDLE *handle )
-{
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-
-    FIXME( "device %p, handle_info %p, handle %p stub!\n", device, handle_info, handle );
-
-    return VK_ERROR_INCOMPATIBLE_DRIVER;
-}
-
-static VkResult win32u_vkImportSemaphoreWin32HandleKHR( VkDevice client_device, const VkImportSemaphoreWin32HandleInfoKHR *handle_info )
-{
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-
-    FIXME( "device %p, handle_info %p stub!\n", device, handle_info );
-
-    return VK_ERROR_INCOMPATIBLE_DRIVER;
-}
-
-static void win32u_vkGetPhysicalDeviceExternalSemaphoreProperties( VkPhysicalDevice client_physical_device, const VkPhysicalDeviceExternalSemaphoreInfo *semaphore_info,
-                                                                   VkExternalSemaphoreProperties *semaphore_properties )
-{
-    struct vulkan_physical_device *physical_device = vulkan_physical_device_from_handle( client_physical_device );
-    struct vulkan_instance *instance = physical_device->instance;
-
-    TRACE( "physical_device %p, semaphore_info %p, semaphore_properties %p\n", physical_device, semaphore_info, semaphore_properties );
-
-    instance->p_vkGetPhysicalDeviceExternalSemaphoreProperties( physical_device->host.physical_device, semaphore_info, semaphore_properties );
-}
-
-static VkResult win32u_vkCreateFence( VkDevice client_device, const VkFenceCreateInfo *client_create_info, const VkAllocationCallbacks *allocator, VkFence *ret )
-{
-    VkFenceCreateInfo *create_info = (VkFenceCreateInfo *)client_create_info; /* cast away const, chain has been copied in the thunks */
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    VkBaseOutStructure **next, *prev = (VkBaseOutStructure *)create_info;
-
-    TRACE( "device %p, create_info %p, allocator %p, ret %p\n", device, create_info, allocator, ret );
-
-    for (next = &prev->pNext; *next; prev = *next, next = &(*next)->pNext)
-    {
-        switch ((*next)->sType)
-        {
-        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
-            FIXME( "VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO not implemented.\n" );
-            *next = (*next)->pNext; next = &prev;
-            break;
-        case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
-            FIXME( "VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR not implemented.\n" );
-            *next = (*next)->pNext; next = &prev;
-            break;
-        default: FIXME( "Unhandled sType %u.\n", (*next)->sType ); break;
-        }
-    }
-
-    return device->p_vkCreateFence( device->host.device, create_info, NULL /* allocator */, ret );
-}
-
-static void win32u_vkDestroyFence( VkDevice client_device, VkFence client_fence, const VkAllocationCallbacks *allocator )
-{
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-
-    TRACE( "device %p, client_fence %s, allocator %p\n", device, wine_dbgstr_longlong( client_fence ), allocator );
-
-    return device->p_vkDestroyFence( device->host.device, client_fence, allocator );
-}
-
-static VkResult win32u_vkGetFenceWin32HandleKHR( VkDevice client_device, const VkFenceGetWin32HandleInfoKHR *handle_info, HANDLE *handle )
-{
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-
-    FIXME( "device %p, handle_info %p, handle %p stub!\n", device, handle_info, handle );
-
-    return VK_ERROR_INCOMPATIBLE_DRIVER;
-}
-
-static VkResult win32u_vkImportFenceWin32HandleKHR( VkDevice client_device, const VkImportFenceWin32HandleInfoKHR *handle_info )
-{
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-
-    FIXME( "device %p, handle_info %p stub!\n", device, handle_info );
-
-    return VK_ERROR_INCOMPATIBLE_DRIVER;
-}
-
-static void win32u_vkGetPhysicalDeviceExternalFenceProperties( VkPhysicalDevice client_physical_device, const VkPhysicalDeviceExternalFenceInfo *fence_info,
-                                                               VkExternalFenceProperties *fence_properties )
-{
-    struct vulkan_physical_device *physical_device = vulkan_physical_device_from_handle( client_physical_device );
-    struct vulkan_instance *instance = physical_device->instance;
-
-    TRACE( "physical_device %p, fence_info %p, fence_properties %p\n", physical_device, fence_info, fence_properties );
-
-    instance->p_vkGetPhysicalDeviceExternalFenceProperties( physical_device->host.physical_device, fence_info, fence_properties );
-}
-
 static const char *win32u_get_host_surface_extension(void)
 {
     return driver_funcs->p_get_host_surface_extension();
@@ -1271,28 +1052,19 @@ static struct vulkan_funcs vulkan_funcs =
     .p_vkAcquireNextImageKHR = win32u_vkAcquireNextImageKHR,
     .p_vkAllocateMemory = win32u_vkAllocateMemory,
     .p_vkCreateBuffer = win32u_vkCreateBuffer,
-    .p_vkCreateFence = win32u_vkCreateFence,
     .p_vkCreateImage = win32u_vkCreateImage,
-    .p_vkCreateSemaphore = win32u_vkCreateSemaphore,
     .p_vkCreateSwapchainKHR = win32u_vkCreateSwapchainKHR,
     .p_vkCreateWin32SurfaceKHR = win32u_vkCreateWin32SurfaceKHR,
-    .p_vkDestroyFence = win32u_vkDestroyFence,
-    .p_vkDestroySemaphore = win32u_vkDestroySemaphore,
     .p_vkDestroySurfaceKHR = win32u_vkDestroySurfaceKHR,
     .p_vkDestroySwapchainKHR = win32u_vkDestroySwapchainKHR,
     .p_vkFreeMemory = win32u_vkFreeMemory,
     .p_vkGetDeviceBufferMemoryRequirements = win32u_vkGetDeviceBufferMemoryRequirements,
     .p_vkGetDeviceBufferMemoryRequirementsKHR = win32u_vkGetDeviceBufferMemoryRequirements,
     .p_vkGetDeviceImageMemoryRequirements = win32u_vkGetDeviceImageMemoryRequirements,
-    .p_vkGetFenceWin32HandleKHR = win32u_vkGetFenceWin32HandleKHR,
     .p_vkGetMemoryWin32HandleKHR = win32u_vkGetMemoryWin32HandleKHR,
     .p_vkGetMemoryWin32HandlePropertiesKHR = win32u_vkGetMemoryWin32HandlePropertiesKHR,
     .p_vkGetPhysicalDeviceExternalBufferProperties = win32u_vkGetPhysicalDeviceExternalBufferProperties,
     .p_vkGetPhysicalDeviceExternalBufferPropertiesKHR = win32u_vkGetPhysicalDeviceExternalBufferProperties,
-    .p_vkGetPhysicalDeviceExternalFenceProperties = win32u_vkGetPhysicalDeviceExternalFenceProperties,
-    .p_vkGetPhysicalDeviceExternalFencePropertiesKHR = win32u_vkGetPhysicalDeviceExternalFenceProperties,
-    .p_vkGetPhysicalDeviceExternalSemaphoreProperties = win32u_vkGetPhysicalDeviceExternalSemaphoreProperties,
-    .p_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = win32u_vkGetPhysicalDeviceExternalSemaphoreProperties,
     .p_vkGetPhysicalDeviceImageFormatProperties2 = win32u_vkGetPhysicalDeviceImageFormatProperties2,
     .p_vkGetPhysicalDeviceImageFormatProperties2KHR = win32u_vkGetPhysicalDeviceImageFormatProperties2,
     .p_vkGetPhysicalDevicePresentRectanglesKHR = win32u_vkGetPhysicalDevicePresentRectanglesKHR,
@@ -1301,15 +1073,9 @@ static struct vulkan_funcs vulkan_funcs =
     .p_vkGetPhysicalDeviceSurfaceFormats2KHR = win32u_vkGetPhysicalDeviceSurfaceFormats2KHR,
     .p_vkGetPhysicalDeviceSurfaceFormatsKHR = win32u_vkGetPhysicalDeviceSurfaceFormatsKHR,
     .p_vkGetPhysicalDeviceWin32PresentationSupportKHR = win32u_vkGetPhysicalDeviceWin32PresentationSupportKHR,
-    .p_vkGetSemaphoreWin32HandleKHR = win32u_vkGetSemaphoreWin32HandleKHR,
-    .p_vkImportFenceWin32HandleKHR = win32u_vkImportFenceWin32HandleKHR,
-    .p_vkImportSemaphoreWin32HandleKHR = win32u_vkImportSemaphoreWin32HandleKHR,
     .p_vkMapMemory = win32u_vkMapMemory,
     .p_vkMapMemory2KHR = win32u_vkMapMemory2KHR,
     .p_vkQueuePresentKHR = win32u_vkQueuePresentKHR,
-    .p_vkQueueSubmit = win32u_vkQueueSubmit,
-    .p_vkQueueSubmit2 = win32u_vkQueueSubmit2,
-    .p_vkQueueSubmit2KHR = win32u_vkQueueSubmit2,
     .p_vkUnmapMemory = win32u_vkUnmapMemory,
     .p_vkUnmapMemory2KHR = win32u_vkUnmapMemory2KHR,
     .p_get_host_surface_extension = win32u_get_host_surface_extension,
diff --git b/dlls/winevulkan/loader_thunks.c a/dlls/winevulkan/loader_thunks.c
index 17783925979..3da89090ee8 100644
--- b/dlls/winevulkan/loader_thunks.c
+++ a/dlls/winevulkan/loader_thunks.c
@@ -4999,18 +4999,6 @@ VkResult WINAPI vkGetFenceStatus(VkDevice device, VkFence fence)
     return params.result;
 }
 
-VkResult WINAPI vkGetFenceWin32HandleKHR(VkDevice device, const VkFenceGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle)
-{
-    struct vkGetFenceWin32HandleKHR_params params;
-    NTSTATUS status;
-    params.device = device;
-    params.pGetWin32HandleInfo = pGetWin32HandleInfo;
-    params.pHandle = pHandle;
-    status = UNIX_CALL(vkGetFenceWin32HandleKHR, &params);
-    assert(!status && "vkGetFenceWin32HandleKHR");
-    return params.result;
-}
-
 VkResult WINAPI vkGetFramebufferTilePropertiesQCOM(VkDevice device, VkFramebuffer framebuffer, uint32_t *pPropertiesCount, VkTilePropertiesQCOM *pProperties)
 {
     struct vkGetFramebufferTilePropertiesQCOM_params params;
@@ -6218,18 +6206,6 @@ VkResult WINAPI vkGetSemaphoreCounterValueKHR(VkDevice device, VkSemaphore semap
     return params.result;
 }
 
-VkResult WINAPI vkGetSemaphoreWin32HandleKHR(VkDevice device, const VkSemaphoreGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle)
-{
-    struct vkGetSemaphoreWin32HandleKHR_params params;
-    NTSTATUS status;
-    params.device = device;
-    params.pGetWin32HandleInfo = pGetWin32HandleInfo;
-    params.pHandle = pHandle;
-    status = UNIX_CALL(vkGetSemaphoreWin32HandleKHR, &params);
-    assert(!status && "vkGetSemaphoreWin32HandleKHR");
-    return params.result;
-}
-
 VkResult WINAPI vkGetShaderBinaryDataEXT(VkDevice device, VkShaderEXT shader, size_t *pDataSize, void *pData)
 {
     struct vkGetShaderBinaryDataEXT_params params;
@@ -6354,28 +6330,6 @@ VkResult WINAPI vkGetVideoSessionMemoryRequirementsKHR(VkDevice device, VkVideoS
     return params.result;
 }
 
-VkResult WINAPI vkImportFenceWin32HandleKHR(VkDevice device, const VkImportFenceWin32HandleInfoKHR *pImportFenceWin32HandleInfo)
-{
-    struct vkImportFenceWin32HandleKHR_params params;
-    NTSTATUS status;
-    params.device = device;
-    params.pImportFenceWin32HandleInfo = pImportFenceWin32HandleInfo;
-    status = UNIX_CALL(vkImportFenceWin32HandleKHR, &params);
-    assert(!status && "vkImportFenceWin32HandleKHR");
-    return params.result;
-}
-
-VkResult WINAPI vkImportSemaphoreWin32HandleKHR(VkDevice device, const VkImportSemaphoreWin32HandleInfoKHR *pImportSemaphoreWin32HandleInfo)
-{
-    struct vkImportSemaphoreWin32HandleKHR_params params;
-    NTSTATUS status;
-    params.device = device;
-    params.pImportSemaphoreWin32HandleInfo = pImportSemaphoreWin32HandleInfo;
-    status = UNIX_CALL(vkImportSemaphoreWin32HandleKHR, &params);
-    assert(!status && "vkImportSemaphoreWin32HandleKHR");
-    return params.result;
-}
-
 VkResult WINAPI vkInitializePerformanceApiINTEL(VkDevice device, const VkInitializePerformanceApiInfoINTEL *pInitializeInfo)
 {
     struct vkInitializePerformanceApiINTEL_params params;
@@ -7595,7 +7549,6 @@ static const struct vulkan_func vk_device_dispatch_table[] =
     {"vkGetEncodedVideoSessionParametersKHR", vkGetEncodedVideoSessionParametersKHR},
     {"vkGetEventStatus", vkGetEventStatus},
     {"vkGetFenceStatus", vkGetFenceStatus},
-    {"vkGetFenceWin32HandleKHR", vkGetFenceWin32HandleKHR},
     {"vkGetFramebufferTilePropertiesQCOM", vkGetFramebufferTilePropertiesQCOM},
     {"vkGetGeneratedCommandsMemoryRequirementsEXT", vkGetGeneratedCommandsMemoryRequirementsEXT},
     {"vkGetGeneratedCommandsMemoryRequirementsNV", vkGetGeneratedCommandsMemoryRequirementsNV},
@@ -7645,7 +7598,6 @@ static const struct vulkan_func vk_device_dispatch_table[] =
     {"vkGetSamplerOpaqueCaptureDescriptorDataEXT", vkGetSamplerOpaqueCaptureDescriptorDataEXT},
     {"vkGetSemaphoreCounterValue", vkGetSemaphoreCounterValue},
     {"vkGetSemaphoreCounterValueKHR", vkGetSemaphoreCounterValueKHR},
-    {"vkGetSemaphoreWin32HandleKHR", vkGetSemaphoreWin32HandleKHR},
     {"vkGetShaderBinaryDataEXT", vkGetShaderBinaryDataEXT},
     {"vkGetShaderInfoAMD", vkGetShaderInfoAMD},
     {"vkGetShaderModuleCreateInfoIdentifierEXT", vkGetShaderModuleCreateInfoIdentifierEXT},
@@ -7656,8 +7608,6 @@ static const struct vulkan_func vk_device_dispatch_table[] =
     {"vkGetTensorViewOpaqueCaptureDescriptorDataARM", vkGetTensorViewOpaqueCaptureDescriptorDataARM},
     {"vkGetValidationCacheDataEXT", vkGetValidationCacheDataEXT},
     {"vkGetVideoSessionMemoryRequirementsKHR", vkGetVideoSessionMemoryRequirementsKHR},
-    {"vkImportFenceWin32HandleKHR", vkImportFenceWin32HandleKHR},
-    {"vkImportSemaphoreWin32HandleKHR", vkImportSemaphoreWin32HandleKHR},
     {"vkInitializePerformanceApiINTEL", vkInitializePerformanceApiINTEL},
     {"vkInvalidateMappedMemoryRanges", vkInvalidateMappedMemoryRanges},
     {"vkLatencySleepNV", vkLatencySleepNV},
diff --git b/dlls/winevulkan/loader_thunks.h a/dlls/winevulkan/loader_thunks.h
index db5b588afba..ebfc3dce3a8 100644
--- b/dlls/winevulkan/loader_thunks.h
+++ a/dlls/winevulkan/loader_thunks.h
@@ -506,7 +506,6 @@ enum unix_call
     unix_vkGetEncodedVideoSessionParametersKHR,
     unix_vkGetEventStatus,
     unix_vkGetFenceStatus,
-    unix_vkGetFenceWin32HandleKHR,
     unix_vkGetFramebufferTilePropertiesQCOM,
     unix_vkGetGeneratedCommandsMemoryRequirementsEXT,
     unix_vkGetGeneratedCommandsMemoryRequirementsNV,
@@ -610,7 +609,6 @@ enum unix_call
     unix_vkGetSamplerOpaqueCaptureDescriptorDataEXT,
     unix_vkGetSemaphoreCounterValue,
     unix_vkGetSemaphoreCounterValueKHR,
-    unix_vkGetSemaphoreWin32HandleKHR,
     unix_vkGetShaderBinaryDataEXT,
     unix_vkGetShaderInfoAMD,
     unix_vkGetShaderModuleCreateInfoIdentifierEXT,
@@ -621,8 +619,6 @@ enum unix_call
     unix_vkGetTensorViewOpaqueCaptureDescriptorDataARM,
     unix_vkGetValidationCacheDataEXT,
     unix_vkGetVideoSessionMemoryRequirementsKHR,
-    unix_vkImportFenceWin32HandleKHR,
-    unix_vkImportSemaphoreWin32HandleKHR,
     unix_vkInitializePerformanceApiINTEL,
     unix_vkInvalidateMappedMemoryRanges,
     unix_vkLatencySleepNV,
@@ -4394,14 +4390,6 @@ struct vkGetFenceStatus_params
     VkResult result;
 };
 
-struct vkGetFenceWin32HandleKHR_params
-{
-    VkDevice device;
-    const VkFenceGetWin32HandleInfoKHR *pGetWin32HandleInfo;
-    HANDLE *pHandle;
-    VkResult result;
-};
-
 struct vkGetFramebufferTilePropertiesQCOM_params
 {
     VkDevice device;
@@ -5217,14 +5205,6 @@ struct vkGetSemaphoreCounterValueKHR_params
     VkResult result;
 };
 
-struct vkGetSemaphoreWin32HandleKHR_params
-{
-    VkDevice device;
-    const VkSemaphoreGetWin32HandleInfoKHR *pGetWin32HandleInfo;
-    HANDLE *pHandle;
-    VkResult result;
-};
-
 struct vkGetShaderBinaryDataEXT_params
 {
     VkDevice device;
@@ -5309,20 +5289,6 @@ struct vkGetVideoSessionMemoryRequirementsKHR_params
     VkResult result;
 };
 
-struct vkImportFenceWin32HandleKHR_params
-{
-    VkDevice device;
-    const VkImportFenceWin32HandleInfoKHR *pImportFenceWin32HandleInfo;
-    VkResult result;
-};
-
-struct vkImportSemaphoreWin32HandleKHR_params
-{
-    VkDevice device;
-    const VkImportSemaphoreWin32HandleInfoKHR *pImportSemaphoreWin32HandleInfo;
-    VkResult result;
-};
-
 struct vkInitializePerformanceApiINTEL_params
 {
     VkDevice device;
diff --git b/dlls/winevulkan/make_vulkan a/dlls/winevulkan/make_vulkan
index 998f68fd8eb..83ec38fd520 100755
--- b/dlls/winevulkan/make_vulkan
+++ a/dlls/winevulkan/make_vulkan
@@ -96,12 +96,15 @@ UNSUPPORTED_EXTENSIONS = [
     "VK_AMD_display_native_hdr",
     "VK_EXT_full_screen_exclusive",
     "VK_GOOGLE_display_timing",
+    "VK_KHR_external_fence_win32",
+    "VK_KHR_external_semaphore_win32",
     # Relates to external_semaphore and needs type conversions in bitflags.
     "VK_KHR_maintenance7", # Causes infinity recursion in struct convert code
     "VK_KHR_shared_presentable_image", # Needs WSI work.
     "VK_KHR_video_encode_h265", # StdVideoH265HrdParameters cannot be handled
     "VK_KHR_video_decode_h265", # by struct conversions.
     "VK_KHR_video_maintenance2", # Also affected by StdVideoH265HrdParameters.
+    "VK_KHR_win32_keyed_mutex",
     "VK_NV_external_memory_rdma", # Needs shared resources work.
     "VK_NV_external_compute_queue", # Has a new dispatchable handle
 
@@ -187,10 +190,18 @@ FUNCTION_OVERRIDES = {
 
     # Instance functions
     "vkCreateDevice" : {"extra_param" : "client_ptr"},
+    "vkGetPhysicalDeviceExternalFenceProperties" : {"dispatch" : False},
+    "vkGetPhysicalDeviceExternalSemaphoreProperties" : {"dispatch" : False},
 
     # Device functions
     "vkCreateCommandPool" : {"extra_param" : "client_ptr"},
     "vkGetDeviceProcAddr" : {"dispatch" : False},
+
+    # VK_KHR_external_fence_capabilities
+    "vkGetPhysicalDeviceExternalFencePropertiesKHR" : {"dispatch" : False},
+
+    # VK_KHR_external_semaphore_capabilities
+    "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR" : {"dispatch" : False},
 }
 
 # functions for which a user driver entry must be generated
@@ -199,13 +210,9 @@ USER_DRIVER_FUNCS = {
     "vkAcquireNextImageKHR",
     "vkAllocateMemory",
     "vkCreateBuffer",
-    "vkCreateFence",
     "vkCreateImage",
-    "vkCreateSemaphore",
     "vkCreateSwapchainKHR",
     "vkCreateWin32SurfaceKHR",
-    "vkDestroyFence",
-    "vkDestroySemaphore",
     "vkDestroySurfaceKHR",
     "vkDestroySwapchainKHR",
     "vkFreeMemory",
@@ -213,16 +220,11 @@ USER_DRIVER_FUNCS = {
     "vkGetDeviceBufferMemoryRequirementsKHR",
     "vkGetDeviceImageMemoryRequirements",
     "vkGetDeviceProcAddr",
-    "vkGetFenceWin32HandleKHR",
     "vkGetInstanceProcAddr",
     "vkGetMemoryWin32HandleKHR",
     "vkGetMemoryWin32HandlePropertiesKHR",
     "vkGetPhysicalDeviceExternalBufferProperties",
     "vkGetPhysicalDeviceExternalBufferPropertiesKHR",
-    "vkGetPhysicalDeviceExternalFenceProperties",
-    "vkGetPhysicalDeviceExternalFencePropertiesKHR",
-    "vkGetPhysicalDeviceExternalSemaphoreProperties",
-    "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR",
     "vkGetPhysicalDeviceImageFormatProperties2",
     "vkGetPhysicalDeviceImageFormatProperties2KHR",
     "vkGetPhysicalDevicePresentRectanglesKHR",
@@ -231,15 +233,9 @@ USER_DRIVER_FUNCS = {
     "vkGetPhysicalDeviceSurfaceFormats2KHR",
     "vkGetPhysicalDeviceSurfaceFormatsKHR",
     "vkGetPhysicalDeviceWin32PresentationSupportKHR",
-    "vkGetSemaphoreWin32HandleKHR",
-    "vkImportFenceWin32HandleKHR",
-    "vkImportSemaphoreWin32HandleKHR",
     "vkMapMemory",
     "vkMapMemory2KHR",
     "vkQueuePresentKHR",
-    "vkQueueSubmit",
-    "vkQueueSubmit2",
-    "vkQueueSubmit2KHR",
     "vkUnmapMemory",
     "vkUnmapMemory2KHR",
 }
@@ -278,6 +274,8 @@ MANUAL_UNIX_THUNKS = {
     "vkGetPhysicalDeviceCalibrateableTimeDomainsKHR",
     "vkGetPhysicalDeviceExternalFenceProperties",
     "vkGetPhysicalDeviceExternalFencePropertiesKHR",
+    "vkGetPhysicalDeviceExternalSemaphoreProperties",
+    "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR",
 }
 
 # loader functions which are entirely manually implemented
@@ -310,11 +308,6 @@ STRUCT_CHAIN_CONVERSIONS = {
     "VkImageCreateInfo": {},
     "VkPhysicalDeviceExternalBufferInfo": {},
     "VkPhysicalDeviceImageFormatInfo2": {},
-    "VkCommandBufferSubmitInfo": {},
-    "VkSemaphoreCreateInfo": {},
-    "VkFenceCreateInfo": {},
-    "VkSubmitInfo": {},
-    "VkSubmitInfo2": {},
 
     # Ignore to not confuse host loader.
     "VkDeviceCreateInfo": {"strip": ["VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO"]},
@@ -1061,7 +1054,7 @@ class VkHandle(object):
             # Should only happen for VkInstance
             return "vulkan_instance_from_handle({0})".format(param)
         elif self.name == "VkCommandBuffer":
-            return "vulkan_command_buffer_from_handle({0})->device".format(param)
+            return "wine_cmd_buffer_from_handle({0})->device".format(param)
         elif self.name == "VkDevice":
             return "vulkan_device_from_handle({0})".format(param)
         elif self.name == "VkPhysicalDevice":
@@ -1100,7 +1093,7 @@ class VkHandle(object):
         """ Provide access to the host handle of a wrapped object. """
 
         if self.name == "VkCommandBuffer":
-            return "vulkan_command_buffer_from_handle({0})->host.command_buffer".format(name)
+            return "wine_cmd_buffer_from_handle({0})->host.command_buffer".format(name)
         if self.name == "VkCommandPool":
             return "wine_cmd_pool_from_handle({0})->host.command_pool".format(name)
         if self.name == "VkDebugUtilsMessengerEXT":
@@ -1564,13 +1557,13 @@ class VkMember(VkVariable):
                 return True
 
         if self.is_handle():
-            if self.handle.is_wrapped() and self.is_dynamic_array():
+            if unwrap != Unwrap.NONE and self.handle.is_wrapped():
                 return True
-            if conv and self.handle.is_dispatchable() and self.is_static_array():
+            if conv and self.handle.is_dispatchable():
                 return True
-            return unwrap != Unwrap.NONE and self.handle.is_wrapped()
         elif self.is_generic_handle():
-            return unwrap != Unwrap.NONE
+            if unwrap != Unwrap.NONE:
+                return True
         elif self.is_struct() or self.is_union():
             if self.struct.needs_conversion(conv, unwrap, direction, is_const):
                 return True
diff --git b/dlls/winevulkan/vulkan.c a/dlls/winevulkan/vulkan.c
index 32f48f6bc9c..6325fd2bb43 100644
--- b/dlls/winevulkan/vulkan.c
+++ a/dlls/winevulkan/vulkan.c
@@ -465,14 +465,14 @@ static void wine_vk_free_command_buffers(struct vulkan_device *device,
         struct wine_cmd_pool *pool, uint32_t count, const VkCommandBuffer *buffers)
 {
     struct vulkan_instance *instance = device->physical_device->instance;
-    struct vulkan_command_buffer *buffer;
+    struct wine_cmd_buffer *buffer;
     unsigned int i;
 
     for (i = 0; i < count; i++)
     {
         if (!buffers[i])
             continue;
-        buffer = vulkan_command_buffer_from_handle(buffers[i]);
+        buffer = wine_cmd_buffer_from_handle(buffers[i]);
         if (!buffer)
             continue;
 
@@ -812,7 +812,7 @@ VkResult wine_vkAllocateCommandBuffers(VkDevice client_device, const VkCommandBu
 {
     struct vulkan_device *device = vulkan_device_from_handle(client_device);
     struct vulkan_instance *instance = device->physical_device->instance;
-    struct vulkan_command_buffer *buffer;
+    struct wine_cmd_buffer *buffer;
     struct wine_cmd_pool *pool;
     VkResult res = VK_SUCCESS;
     unsigned int i;
diff --git b/dlls/winevulkan/vulkan_private.h a/dlls/winevulkan/vulkan_private.h
index 51fd39c4813..da520433467 100644
--- b/dlls/winevulkan/vulkan_private.h
+++ a/dlls/winevulkan/vulkan_private.h
@@ -29,6 +29,18 @@
 
 extern const struct vulkan_funcs *vk_funcs;
 
+struct wine_cmd_buffer
+{
+    VULKAN_OBJECT_HEADER( VkCommandBuffer, command_buffer );
+    struct vulkan_device *device;
+};
+
+static inline struct wine_cmd_buffer *wine_cmd_buffer_from_handle(VkCommandBuffer handle)
+{
+    struct vulkan_client_object *client = (struct vulkan_client_object *)handle;
+    return (struct wine_cmd_buffer *)(UINT_PTR)client->unix_handle;
+}
+
 struct wine_queue
 {
     struct vulkan_queue obj;
diff --git b/dlls/winevulkan/vulkan_thunks.c a/dlls/winevulkan/vulkan_thunks.c
index b6d5c15e989..816da31f22c 100644
--- b/dlls/winevulkan/vulkan_thunks.c
+++ a/dlls/winevulkan/vulkan_thunks.c
@@ -2484,16 +2484,6 @@ typedef struct VkCuModuleTexturingModeCreateInfoNVX32
     VkBool32 use64bitTexturing;
 } VkCuModuleTexturingModeCreateInfoNVX32;
 
-typedef struct VkD3D12FenceSubmitInfoKHR32
-{
-    VkStructureType sType;
-    PTR32 pNext;
-    uint32_t waitSemaphoreValuesCount;
-    PTR32 pWaitSemaphoreValues;
-    uint32_t signalSemaphoreValuesCount;
-    PTR32 pSignalSemaphoreValues;
-} VkD3D12FenceSubmitInfoKHR32;
-
 typedef struct VkDataGraphPipelineCompilerControlCreateInfoARM32
 {
     VkStructureType sType;
@@ -3104,15 +3094,6 @@ typedef struct VkExportFenceCreateInfo32
 } VkExportFenceCreateInfo32;
 typedef VkExportFenceCreateInfo32 VkExportFenceCreateInfoKHR32;
 
-typedef struct VkExportFenceWin32HandleInfoKHR32
-{
-    VkStructureType sType;
-    PTR32 pNext;
-    PTR32 pAttributes;
-    DWORD dwAccess;
-    LPCWSTR name;
-} VkExportFenceWin32HandleInfoKHR32;
-
 typedef struct VkExportMemoryAllocateInfo32
 {
     VkStructureType sType;
@@ -3138,15 +3119,6 @@ typedef struct VkExportSemaphoreCreateInfo32
 } VkExportSemaphoreCreateInfo32;
 typedef VkExportSemaphoreCreateInfo32 VkExportSemaphoreCreateInfoKHR32;
 
-typedef struct VkExportSemaphoreWin32HandleInfoKHR32
-{
-    VkStructureType sType;
-    PTR32 pNext;
-    PTR32 pAttributes;
-    DWORD dwAccess;
-    LPCWSTR name;
-} VkExportSemaphoreWin32HandleInfoKHR32;
-
 typedef struct VkExternalBufferProperties32
 {
     VkStructureType sType;
@@ -3227,14 +3199,6 @@ typedef struct VkFenceCreateInfo32
     VkFenceCreateFlags flags;
 } VkFenceCreateInfo32;
 
-typedef struct VkFenceGetWin32HandleInfoKHR32
-{
-    VkStructureType sType;
-    PTR32 pNext;
-    VkFence DECLSPEC_ALIGN(8) fence;
-    VkExternalFenceHandleTypeFlagBits handleType;
-} VkFenceGetWin32HandleInfoKHR32;
-
 typedef struct VkFilterCubicImageViewImageFormatPropertiesEXT32
 {
     VkStructureType sType;
@@ -3660,17 +3624,6 @@ typedef struct VkImageViewUsageCreateInfo32
 } VkImageViewUsageCreateInfo32;
 typedef VkImageViewUsageCreateInfo32 VkImageViewUsageCreateInfoKHR32;
 
-typedef struct VkImportFenceWin32HandleInfoKHR32
-{
-    VkStructureType sType;
-    PTR32 pNext;
-    VkFence DECLSPEC_ALIGN(8) fence;
-    VkFenceImportFlags flags;
-    VkExternalFenceHandleTypeFlagBits handleType;
-    HANDLE handle;
-    LPCWSTR name;
-} VkImportFenceWin32HandleInfoKHR32;
-
 typedef struct VkImportMemoryHostPointerInfoEXT32
 {
     VkStructureType sType;
@@ -3688,17 +3641,6 @@ typedef struct VkImportMemoryWin32HandleInfoKHR32
     LPCWSTR name;
 } VkImportMemoryWin32HandleInfoKHR32;
 
-typedef struct VkImportSemaphoreWin32HandleInfoKHR32
-{
-    VkStructureType sType;
-    PTR32 pNext;
-    VkSemaphore DECLSPEC_ALIGN(8) semaphore;
-    VkSemaphoreImportFlags flags;
-    VkExternalSemaphoreHandleTypeFlagBits handleType;
-    HANDLE handle;
-    LPCWSTR name;
-} VkImportSemaphoreWin32HandleInfoKHR32;
-
 typedef struct VkIndirectCommandsLayoutCreateInfoEXT32
 {
     VkStructureType sType;
@@ -8361,14 +8303,6 @@ typedef struct VkSemaphoreCreateInfo32
     VkSemaphoreCreateFlags flags;
 } VkSemaphoreCreateInfo32;
 
-typedef struct VkSemaphoreGetWin32HandleInfoKHR32
-{
-    VkStructureType sType;
-    PTR32 pNext;
-    VkSemaphore DECLSPEC_ALIGN(8) semaphore;
-    VkExternalSemaphoreHandleTypeFlagBits handleType;
-} VkSemaphoreGetWin32HandleInfoKHR32;
-
 typedef struct VkSemaphoreSignalInfo32
 {
     VkStructureType sType;
@@ -9515,19 +9449,6 @@ typedef struct VkVideoSessionParametersUpdateInfoKHR32
     uint32_t updateSequenceCount;
 } VkVideoSessionParametersUpdateInfoKHR32;
 
-typedef struct VkWin32KeyedMutexAcquireReleaseInfoKHR32
-{
-    VkStructureType sType;
-    PTR32 pNext;
-    uint32_t acquireCount;
-    PTR32 pAcquireSyncs;
-    PTR32 pAcquireKeys;
-    PTR32 pAcquireTimeouts;
-    uint32_t releaseCount;
-    PTR32 pReleaseSyncs;
-    PTR32 pReleaseKeys;
-} VkWin32KeyedMutexAcquireReleaseInfoKHR32;
-
 typedef struct VkWin32SurfaceCreateInfoKHR32
 {
     VkStructureType sType;
@@ -9599,7 +9520,7 @@ static uint64_t wine_vk_unwrap_handle(uint32_t type, uint64_t handle)
     switch(type)
     {
     case VK_OBJECT_TYPE_COMMAND_BUFFER:
-        return (uint64_t) (uintptr_t) vulkan_command_buffer_from_handle(((VkCommandBuffer) (uintptr_t) handle))->host.command_buffer;
+        return (uint64_t) (uintptr_t) wine_cmd_buffer_from_handle(((VkCommandBuffer) (uintptr_t) handle))->host.command_buffer;
     case VK_OBJECT_TYPE_COMMAND_POOL:
         return (uint64_t) wine_cmd_pool_from_handle(handle)->host.command_pool;
     case VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT:
@@ -13678,7 +13599,7 @@ static const VkCommandBuffer *convert_VkCommandBuffer_array_win64_to_host(struct
     out = conversion_context_alloc(ctx, count * sizeof(*out));
     for (i = 0; i < count; i++)
     {
-        out[i] = vulkan_command_buffer_from_handle(in[i])->host.command_buffer;
+        out[i] = wine_cmd_buffer_from_handle(in[i])->host.command_buffer;
     }
 
     return out;
@@ -13695,7 +13616,7 @@ static const VkCommandBuffer *convert_VkCommandBuffer_array_win32_to_host(struct
     out = conversion_context_alloc(ctx, count * sizeof(*out));
     for (i = 0; i < count; i++)
     {
-        out[i] = vulkan_command_buffer_from_handle(UlongToPtr(in[i]))->host.command_buffer;
+        out[i] = wine_cmd_buffer_from_handle(UlongToPtr(in[i]))->host.command_buffer;
     }
 
     return out;
@@ -22199,54 +22120,6 @@ static void convert_VkEventCreateInfo_win32_to_host(const VkEventCreateInfo32 *i
         FIXME("Unexpected pNext\n");
 }
 
-#ifdef _WIN64
-static void convert_VkFenceCreateInfo_win64_to_host(struct conversion_context *ctx, const VkFenceCreateInfo *in, VkFenceCreateInfo *out)
-{
-    const VkBaseInStructure *in_header;
-    VkBaseOutStructure *out_header = (void *)out;
-
-    if (!in) return;
-
-    out->sType = in->sType;
-    out->pNext = NULL;
-    out->flags = in->flags;
-
-    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
-    {
-        switch (in_header->sType)
-        {
-        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
-        {
-            VkExportFenceCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkExportFenceCreateInfo *in_ext = (const VkExportFenceCreateInfo *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO;
-            out_ext->pNext = NULL;
-            out_ext->handleTypes = in_ext->handleTypes;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
-        {
-            VkExportFenceWin32HandleInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkExportFenceWin32HandleInfoKHR *in_ext = (const VkExportFenceWin32HandleInfoKHR *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR;
-            out_ext->pNext = NULL;
-            out_ext->pAttributes = in_ext->pAttributes;
-            out_ext->dwAccess = in_ext->dwAccess;
-            out_ext->name = in_ext->name;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
-            break;
-        }
-    }
-}
-#endif /* _WIN64 */
-
 static void convert_VkFenceCreateInfo_win32_to_host(struct conversion_context *ctx, const VkFenceCreateInfo32 *in, VkFenceCreateInfo *out)
 {
     const VkBaseInStructure32 *in_header;
@@ -22273,19 +22146,6 @@ static void convert_VkFenceCreateInfo_win32_to_host(struct conversion_context *c
             out_header = (void *)out_ext;
             break;
         }
-        case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
-        {
-            VkExportFenceWin32HandleInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkExportFenceWin32HandleInfoKHR32 *in_ext = (const VkExportFenceWin32HandleInfoKHR32 *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR;
-            out_ext->pNext = NULL;
-            out_ext->pAttributes = UlongToPtr(in_ext->pAttributes);
-            out_ext->dwAccess = in_ext->dwAccess;
-            out_ext->name = in_ext->name;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
         default:
             FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
@@ -26067,77 +25927,6 @@ static void convert_VkSamplerYcbcrConversionCreateInfo_win32_to_host(struct conv
     }
 }
 
-#ifdef _WIN64
-static void convert_VkSemaphoreCreateInfo_win64_to_host(struct conversion_context *ctx, const VkSemaphoreCreateInfo *in, VkSemaphoreCreateInfo *out)
-{
-    const VkBaseInStructure *in_header;
-    VkBaseOutStructure *out_header = (void *)out;
-
-    if (!in) return;
-
-    out->sType = in->sType;
-    out->pNext = NULL;
-    out->flags = in->flags;
-
-    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
-    {
-        switch (in_header->sType)
-        {
-        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
-        {
-            VkExportSemaphoreCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkExportSemaphoreCreateInfo *in_ext = (const VkExportSemaphoreCreateInfo *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO;
-            out_ext->pNext = NULL;
-            out_ext->handleTypes = in_ext->handleTypes;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
-        {
-            VkExportSemaphoreWin32HandleInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkExportSemaphoreWin32HandleInfoKHR *in_ext = (const VkExportSemaphoreWin32HandleInfoKHR *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;
-            out_ext->pNext = NULL;
-            out_ext->pAttributes = in_ext->pAttributes;
-            out_ext->dwAccess = in_ext->dwAccess;
-            out_ext->name = in_ext->name;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV:
-        {
-            VkQueryLowLatencySupportNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkQueryLowLatencySupportNV *in_ext = (const VkQueryLowLatencySupportNV *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV;
-            out_ext->pNext = NULL;
-            out_ext->pQueriedLowLatencyData = in_ext->pQueriedLowLatencyData;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO:
-        {
-            VkSemaphoreTypeCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkSemaphoreTypeCreateInfo *in_ext = (const VkSemaphoreTypeCreateInfo *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
-            out_ext->pNext = NULL;
-            out_ext->semaphoreType = in_ext->semaphoreType;
-            out_ext->initialValue = in_ext->initialValue;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
-            break;
-        }
-    }
-}
-#endif /* _WIN64 */
-
 static void convert_VkSemaphoreCreateInfo_win32_to_host(struct conversion_context *ctx, const VkSemaphoreCreateInfo32 *in, VkSemaphoreCreateInfo *out)
 {
     const VkBaseInStructure32 *in_header;
@@ -26164,19 +25953,6 @@ static void convert_VkSemaphoreCreateInfo_win32_to_host(struct conversion_contex
             out_header = (void *)out_ext;
             break;
         }
-        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
-        {
-            VkExportSemaphoreWin32HandleInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkExportSemaphoreWin32HandleInfoKHR32 *in_ext = (const VkExportSemaphoreWin32HandleInfoKHR32 *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;
-            out_ext->pNext = NULL;
-            out_ext->pAttributes = UlongToPtr(in_ext->pAttributes);
-            out_ext->dwAccess = in_ext->dwAccess;
-            out_ext->name = in_ext->name;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
         case VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV:
         {
             VkQueryLowLatencySupportNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -28439,18 +28215,6 @@ static void convert_VkVideoEncodeSessionParametersFeedbackInfoKHR_host_to_win32(
     }
 }
 
-static void convert_VkFenceGetWin32HandleInfoKHR_win32_to_host(const VkFenceGetWin32HandleInfoKHR32 *in, VkFenceGetWin32HandleInfoKHR *out)
-{
-    if (!in) return;
-
-    out->sType = in->sType;
-    out->pNext = NULL;
-    out->fence = in->fence;
-    out->handleType = in->handleType;
-    if (in->pNext)
-        FIXME("Unexpected pNext\n");
-}
-
 static VkTilePropertiesQCOM *convert_VkTilePropertiesQCOM_array_win32_to_host(struct conversion_context *ctx, const VkTilePropertiesQCOM32 *in, uint32_t count)
 {
     VkTilePropertiesQCOM *out;
@@ -38952,18 +38716,6 @@ static void convert_VkSamplerCaptureDescriptorDataInfoEXT_win32_to_host(const Vk
         FIXME("Unexpected pNext\n");
 }
 
-static void convert_VkSemaphoreGetWin32HandleInfoKHR_win32_to_host(const VkSemaphoreGetWin32HandleInfoKHR32 *in, VkSemaphoreGetWin32HandleInfoKHR *out)
-{
-    if (!in) return;
-
-    out->sType = in->sType;
-    out->pNext = NULL;
-    out->semaphore = in->semaphore;
-    out->handleType = in->handleType;
-    if (in->pNext)
-        FIXME("Unexpected pNext\n");
-}
-
 static void convert_VkShaderModuleIdentifierEXT_win32_to_host(const VkShaderModuleIdentifierEXT32 *in, VkShaderModuleIdentifierEXT *out)
 {
     if (!in) return;
@@ -39061,36 +38813,6 @@ static void convert_VkVideoSessionMemoryRequirementsKHR_array_host_to_win32(cons
     }
 }
 
-static void convert_VkImportFenceWin32HandleInfoKHR_win32_to_host(const VkImportFenceWin32HandleInfoKHR32 *in, VkImportFenceWin32HandleInfoKHR *out)
-{
-    if (!in) return;
-
-    out->sType = in->sType;
-    out->pNext = NULL;
-    out->fence = in->fence;
-    out->flags = in->flags;
-    out->handleType = in->handleType;
-    out->handle = in->handle;
-    out->name = in->name;
-    if (in->pNext)
-        FIXME("Unexpected pNext\n");
-}
-
-static void convert_VkImportSemaphoreWin32HandleInfoKHR_win32_to_host(const VkImportSemaphoreWin32HandleInfoKHR32 *in, VkImportSemaphoreWin32HandleInfoKHR *out)
-{
-    if (!in) return;
-
-    out->sType = in->sType;
-    out->pNext = NULL;
-    out->semaphore = in->semaphore;
-    out->flags = in->flags;
-    out->handleType = in->handleType;
-    out->handle = in->handle;
-    out->name = in->name;
-    if (in->pNext)
-        FIXME("Unexpected pNext\n");
-}
-
 static void convert_VkInitializePerformanceApiInfoINTEL_win32_to_host(const VkInitializePerformanceApiInfoINTEL32 *in, VkInitializePerformanceApiInfoINTEL *out)
 {
     if (!in) return;
@@ -39589,56 +39311,6 @@ static void convert_VkOutOfBandQueueTypeInfoNV_win32_to_host(const VkOutOfBandQu
         FIXME("Unexpected pNext\n");
 }
 
-#ifdef _WIN64
-static const VkSwapchainKHR *convert_VkSwapchainKHR_array_win64_to_unwrapped_host(struct conversion_context *ctx, const VkSwapchainKHR *in, uint32_t count)
-{
-    VkSwapchainKHR *out;
-    unsigned int i;
-
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
-    {
-        out[i] = in[i];
-    }
-
-    return out;
-}
-#endif /* _WIN64 */
-
-#ifdef _WIN64
-static void convert_VkPresentInfoKHR_win64_to_unwrapped_host(struct conversion_context *ctx, const VkPresentInfoKHR *in, VkPresentInfoKHR *out)
-{
-    if (!in) return;
-
-    out->sType = in->sType;
-    out->pNext = in->pNext;
-    out->waitSemaphoreCount = in->waitSemaphoreCount;
-    out->pWaitSemaphores = in->pWaitSemaphores;
-    out->swapchainCount = in->swapchainCount;
-    out->pSwapchains = convert_VkSwapchainKHR_array_win64_to_unwrapped_host(ctx, in->pSwapchains, in->swapchainCount);
-    out->pImageIndices = in->pImageIndices;
-    out->pResults = in->pResults;
-}
-#endif /* _WIN64 */
-
-static const VkSwapchainKHR *convert_VkSwapchainKHR_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSwapchainKHR *in, uint32_t count)
-{
-    VkSwapchainKHR *out;
-    unsigned int i;
-
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
-    {
-        out[i] = in[i];
-    }
-
-    return out;
-}
-
 static void convert_VkPresentRegionKHR_win32_to_host(const VkPresentRegionKHR32 *in, VkPresentRegionKHR *out)
 {
     if (!in) return;
@@ -39675,7 +39347,7 @@ static void convert_VkPresentInfoKHR_win32_to_unwrapped_host(struct conversion_c
     out->waitSemaphoreCount = in->waitSemaphoreCount;
     out->pWaitSemaphores = UlongToPtr(in->pWaitSemaphores);
     out->swapchainCount = in->swapchainCount;
-    out->pSwapchains = convert_VkSwapchainKHR_array_win32_to_unwrapped_host(ctx, (const VkSwapchainKHR *)UlongToPtr(in->pSwapchains), in->swapchainCount);
+    out->pSwapchains = UlongToPtr(in->pSwapchains);
     out->pImageIndices = UlongToPtr(in->pImageIndices);
     out->pResults = UlongToPtr(in->pResults);
 
@@ -39795,198 +39467,24 @@ static void convert_VkPresentInfoKHR_win32_to_unwrapped_host(struct conversion_c
 }
 
 #ifdef _WIN64
-static const VkCommandBuffer *convert_VkCommandBuffer_array_win64_to_unwrapped_host(struct conversion_context *ctx, const VkCommandBuffer *in, uint32_t count)
+static void convert_VkSubmitInfo_win64_to_host(struct conversion_context *ctx, const VkSubmitInfo *in, VkSubmitInfo *out)
 {
-    VkCommandBuffer *out;
-    unsigned int i;
-
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
-    {
-        out[i] = in[i];
-    }
-
-    return out;
-}
-#endif /* _WIN64 */
-
-#ifdef _WIN64
-static const VkDeviceMemory *convert_VkDeviceMemory_array_win64_to_host(struct conversion_context *ctx, const VkDeviceMemory *in, uint32_t count)
-{
-    VkDeviceMemory *out;
-    unsigned int i;
-
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
-    {
-        out[i] = vulkan_device_memory_from_handle(in[i])->host.device_memory;
-    }
-
-    return out;
-}
-#endif /* _WIN64 */
-
-#ifdef _WIN64
-static void convert_VkSubmitInfo_win64_to_unwrapped_host(struct conversion_context *ctx, const VkSubmitInfo *in, VkSubmitInfo *out)
-{
-    const VkBaseInStructure *in_header;
-    VkBaseOutStructure *out_header = (void *)out;
-
     if (!in) return;
 
     out->sType = in->sType;
-    out->pNext = NULL;
+    out->pNext = in->pNext;
     out->waitSemaphoreCount = in->waitSemaphoreCount;
     out->pWaitSemaphores = in->pWaitSemaphores;
     out->pWaitDstStageMask = in->pWaitDstStageMask;
     out->commandBufferCount = in->commandBufferCount;
-    out->pCommandBuffers = convert_VkCommandBuffer_array_win64_to_unwrapped_host(ctx, in->pCommandBuffers, in->commandBufferCount);
+    out->pCommandBuffers = convert_VkCommandBuffer_array_win64_to_host(ctx, in->pCommandBuffers, in->commandBufferCount);
     out->signalSemaphoreCount = in->signalSemaphoreCount;
     out->pSignalSemaphores = in->pSignalSemaphores;
-
-    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
-    {
-        switch (in_header->sType)
-        {
-        case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
-        {
-            VkD3D12FenceSubmitInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkD3D12FenceSubmitInfoKHR *in_ext = (const VkD3D12FenceSubmitInfoKHR *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR;
-            out_ext->pNext = NULL;
-            out_ext->waitSemaphoreValuesCount = in_ext->waitSemaphoreValuesCount;
-            out_ext->pWaitSemaphoreValues = in_ext->pWaitSemaphoreValues;
-            out_ext->signalSemaphoreValuesCount = in_ext->signalSemaphoreValuesCount;
-            out_ext->pSignalSemaphoreValues = in_ext->pSignalSemaphoreValues;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
-        {
-            VkDeviceGroupSubmitInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkDeviceGroupSubmitInfo *in_ext = (const VkDeviceGroupSubmitInfo *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO;
-            out_ext->pNext = NULL;
-            out_ext->waitSemaphoreCount = in_ext->waitSemaphoreCount;
-            out_ext->pWaitSemaphoreDeviceIndices = in_ext->pWaitSemaphoreDeviceIndices;
-            out_ext->commandBufferCount = in_ext->commandBufferCount;
-            out_ext->pCommandBufferDeviceMasks = in_ext->pCommandBufferDeviceMasks;
-            out_ext->signalSemaphoreCount = in_ext->signalSemaphoreCount;
-            out_ext->pSignalSemaphoreDeviceIndices = in_ext->pSignalSemaphoreDeviceIndices;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT:
-        {
-            VkFrameBoundaryEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkFrameBoundaryEXT *in_ext = (const VkFrameBoundaryEXT *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT;
-            out_ext->pNext = NULL;
-            out_ext->flags = in_ext->flags;
-            out_ext->frameID = in_ext->frameID;
-            out_ext->imageCount = in_ext->imageCount;
-            out_ext->pImages = in_ext->pImages;
-            out_ext->bufferCount = in_ext->bufferCount;
-            out_ext->pBuffers = in_ext->pBuffers;
-            out_ext->tagName = in_ext->tagName;
-            out_ext->tagSize = in_ext->tagSize;
-            out_ext->pTag = in_ext->pTag;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM:
-        {
-            VkFrameBoundaryTensorsARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkFrameBoundaryTensorsARM *in_ext = (const VkFrameBoundaryTensorsARM *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM;
-            out_ext->pNext = NULL;
-            out_ext->tensorCount = in_ext->tensorCount;
-            out_ext->pTensors = in_ext->pTensors;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV:
-        {
-            VkLatencySubmissionPresentIdNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkLatencySubmissionPresentIdNV *in_ext = (const VkLatencySubmissionPresentIdNV *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV;
-            out_ext->pNext = NULL;
-            out_ext->presentID = in_ext->presentID;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR:
-        {
-            VkPerformanceQuerySubmitInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkPerformanceQuerySubmitInfoKHR *in_ext = (const VkPerformanceQuerySubmitInfoKHR *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR;
-            out_ext->pNext = NULL;
-            out_ext->counterPassIndex = in_ext->counterPassIndex;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
-        {
-            VkProtectedSubmitInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkProtectedSubmitInfo *in_ext = (const VkProtectedSubmitInfo *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO;
-            out_ext->pNext = NULL;
-            out_ext->protectedSubmit = in_ext->protectedSubmit;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO:
-        {
-            VkTimelineSemaphoreSubmitInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkTimelineSemaphoreSubmitInfo *in_ext = (const VkTimelineSemaphoreSubmitInfo *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO;
-            out_ext->pNext = NULL;
-            out_ext->waitSemaphoreValueCount = in_ext->waitSemaphoreValueCount;
-            out_ext->pWaitSemaphoreValues = in_ext->pWaitSemaphoreValues;
-            out_ext->signalSemaphoreValueCount = in_ext->signalSemaphoreValueCount;
-            out_ext->pSignalSemaphoreValues = in_ext->pSignalSemaphoreValues;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
-        {
-            VkWin32KeyedMutexAcquireReleaseInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkWin32KeyedMutexAcquireReleaseInfoKHR *in_ext = (const VkWin32KeyedMutexAcquireReleaseInfoKHR *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR;
-            out_ext->pNext = NULL;
-            out_ext->acquireCount = in_ext->acquireCount;
-            out_ext->pAcquireSyncs = convert_VkDeviceMemory_array_win64_to_host(ctx, in_ext->pAcquireSyncs, in_ext->acquireCount);
-            out_ext->pAcquireKeys = in_ext->pAcquireKeys;
-            out_ext->pAcquireTimeouts = in_ext->pAcquireTimeouts;
-            out_ext->releaseCount = in_ext->releaseCount;
-            out_ext->pReleaseSyncs = convert_VkDeviceMemory_array_win64_to_host(ctx, in_ext->pReleaseSyncs, in_ext->releaseCount);
-            out_ext->pReleaseKeys = in_ext->pReleaseKeys;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
-            break;
-        }
-    }
 }
 #endif /* _WIN64 */
 
 #ifdef _WIN64
-static const VkSubmitInfo *convert_VkSubmitInfo_array_win64_to_unwrapped_host(struct conversion_context *ctx, const VkSubmitInfo *in, uint32_t count)
+static const VkSubmitInfo *convert_VkSubmitInfo_array_win64_to_host(struct conversion_context *ctx, const VkSubmitInfo *in, uint32_t count)
 {
     VkSubmitInfo *out;
     unsigned int i;
@@ -39996,30 +39494,14 @@ static const VkSubmitInfo *convert_VkSubmitInfo_array_win64_to_unwrapped_host(st
     out = conversion_context_alloc(ctx, count * sizeof(*out));
     for (i = 0; i < count; i++)
     {
-        convert_VkSubmitInfo_win64_to_unwrapped_host(ctx, &in[i], &out[i]);
+        convert_VkSubmitInfo_win64_to_host(ctx, &in[i], &out[i]);
     }
 
     return out;
 }
 #endif /* _WIN64 */
 
-static const VkDeviceMemory *convert_VkDeviceMemory_array_win32_to_host(struct conversion_context *ctx, const VkDeviceMemory *in, uint32_t count)
-{
-    VkDeviceMemory *out;
-    unsigned int i;
-
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
-    {
-        out[i] = vulkan_device_memory_from_handle(in[i])->host.device_memory;
-    }
-
-    return out;
-}
-
-static void convert_VkSubmitInfo_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSubmitInfo32 *in, VkSubmitInfo *out)
+static void convert_VkSubmitInfo_win32_to_host(struct conversion_context *ctx, const VkSubmitInfo32 *in, VkSubmitInfo *out)
 {
     const VkBaseInStructure32 *in_header;
     VkBaseOutStructure *out_header = (void *)out;
@@ -40032,7 +39514,7 @@ static void convert_VkSubmitInfo_win32_to_unwrapped_host(struct conversion_conte
     out->pWaitSemaphores = UlongToPtr(in->pWaitSemaphores);
     out->pWaitDstStageMask = UlongToPtr(in->pWaitDstStageMask);
     out->commandBufferCount = in->commandBufferCount;
-    out->pCommandBuffers = convert_VkCommandBuffer_array_win32_to_unwrapped_host(ctx, (const PTR32 *)UlongToPtr(in->pCommandBuffers), in->commandBufferCount);
+    out->pCommandBuffers = convert_VkCommandBuffer_array_win32_to_host(ctx, (const PTR32 *)UlongToPtr(in->pCommandBuffers), in->commandBufferCount);
     out->signalSemaphoreCount = in->signalSemaphoreCount;
     out->pSignalSemaphores = UlongToPtr(in->pSignalSemaphores);
 
@@ -40040,20 +39522,6 @@ static void convert_VkSubmitInfo_win32_to_unwrapped_host(struct conversion_conte
     {
         switch (in_header->sType)
         {
-        case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
-        {
-            VkD3D12FenceSubmitInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkD3D12FenceSubmitInfoKHR32 *in_ext = (const VkD3D12FenceSubmitInfoKHR32 *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR;
-            out_ext->pNext = NULL;
-            out_ext->waitSemaphoreValuesCount = in_ext->waitSemaphoreValuesCount;
-            out_ext->pWaitSemaphoreValues = UlongToPtr(in_ext->pWaitSemaphoreValues);
-            out_ext->signalSemaphoreValuesCount = in_ext->signalSemaphoreValuesCount;
-            out_ext->pSignalSemaphoreValues = UlongToPtr(in_ext->pSignalSemaphoreValues);
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
         case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
         {
             VkDeviceGroupSubmitInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -40148,23 +39616,6 @@ static void convert_VkSubmitInfo_win32_to_unwrapped_host(struct conversion_conte
             out_header = (void *)out_ext;
             break;
         }
-        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
-        {
-            VkWin32KeyedMutexAcquireReleaseInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkWin32KeyedMutexAcquireReleaseInfoKHR32 *in_ext = (const VkWin32KeyedMutexAcquireReleaseInfoKHR32 *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR;
-            out_ext->pNext = NULL;
-            out_ext->acquireCount = in_ext->acquireCount;
-            out_ext->pAcquireSyncs = convert_VkDeviceMemory_array_win32_to_host(ctx, (const VkDeviceMemory *)UlongToPtr(in_ext->pAcquireSyncs), in_ext->acquireCount);
-            out_ext->pAcquireKeys = UlongToPtr(in_ext->pAcquireKeys);
-            out_ext->pAcquireTimeouts = UlongToPtr(in_ext->pAcquireTimeouts);
-            out_ext->releaseCount = in_ext->releaseCount;
-            out_ext->pReleaseSyncs = convert_VkDeviceMemory_array_win32_to_host(ctx, (const VkDeviceMemory *)UlongToPtr(in_ext->pReleaseSyncs), in_ext->releaseCount);
-            out_ext->pReleaseKeys = UlongToPtr(in_ext->pReleaseKeys);
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
         default:
             FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
@@ -40172,7 +39623,7 @@ static void convert_VkSubmitInfo_win32_to_unwrapped_host(struct conversion_conte
     }
 }
 
-static const VkSubmitInfo *convert_VkSubmitInfo_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSubmitInfo32 *in, uint32_t count)
+static const VkSubmitInfo *convert_VkSubmitInfo_array_win32_to_host(struct conversion_context *ctx, const VkSubmitInfo32 *in, uint32_t count)
 {
     VkSubmitInfo *out;
     unsigned int i;
@@ -40182,51 +39633,26 @@ static const VkSubmitInfo *convert_VkSubmitInfo_array_win32_to_unwrapped_host(st
     out = conversion_context_alloc(ctx, count * sizeof(*out));
     for (i = 0; i < count; i++)
     {
-        convert_VkSubmitInfo_win32_to_unwrapped_host(ctx, &in[i], &out[i]);
+        convert_VkSubmitInfo_win32_to_host(ctx, &in[i], &out[i]);
     }
 
     return out;
 }
 
 #ifdef _WIN64
-static void convert_VkCommandBufferSubmitInfo_win64_to_unwrapped_host(struct conversion_context *ctx, const VkCommandBufferSubmitInfo *in, VkCommandBufferSubmitInfo *out)
+static void convert_VkCommandBufferSubmitInfo_win64_to_host(const VkCommandBufferSubmitInfo *in, VkCommandBufferSubmitInfo *out)
 {
-    const VkBaseInStructure *in_header;
-    VkBaseOutStructure *out_header = (void *)out;
-
     if (!in) return;
 
     out->sType = in->sType;
-    out->pNext = NULL;
-    out->commandBuffer = in->commandBuffer;
+    out->pNext = in->pNext;
+    out->commandBuffer = wine_cmd_buffer_from_handle(in->commandBuffer)->host.command_buffer;
     out->deviceMask = in->deviceMask;
-
-    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
-    {
-        switch (in_header->sType)
-        {
-        case VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM:
-        {
-            VkRenderPassStripeSubmitInfoARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkRenderPassStripeSubmitInfoARM *in_ext = (const VkRenderPassStripeSubmitInfoARM *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM;
-            out_ext->pNext = NULL;
-            out_ext->stripeSemaphoreInfoCount = in_ext->stripeSemaphoreInfoCount;
-            out_ext->pStripeSemaphoreInfos = in_ext->pStripeSemaphoreInfos;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
-            break;
-        }
-    }
 }
 #endif /* _WIN64 */
 
 #ifdef _WIN64
-static const VkCommandBufferSubmitInfo *convert_VkCommandBufferSubmitInfo_array_win64_to_unwrapped_host(struct conversion_context *ctx, const VkCommandBufferSubmitInfo *in, uint32_t count)
+static const VkCommandBufferSubmitInfo *convert_VkCommandBufferSubmitInfo_array_win64_to_host(struct conversion_context *ctx, const VkCommandBufferSubmitInfo *in, uint32_t count)
 {
     VkCommandBufferSubmitInfo *out;
     unsigned int i;
@@ -40236,7 +39662,7 @@ static const VkCommandBufferSubmitInfo *convert_VkCommandBufferSubmitInfo_array_
     out = conversion_context_alloc(ctx, count * sizeof(*out));
     for (i = 0; i < count; i++)
     {
-        convert_VkCommandBufferSubmitInfo_win64_to_unwrapped_host(ctx, &in[i], &out[i]);
+        convert_VkCommandBufferSubmitInfo_win64_to_host(&in[i], &out[i]);
     }
 
     return out;
@@ -40244,107 +39670,24 @@ static const VkCommandBufferSubmitInfo *convert_VkCommandBufferSubmitInfo_array_
 #endif /* _WIN64 */
 
 #ifdef _WIN64
-static void convert_VkSubmitInfo2_win64_to_unwrapped_host(struct conversion_context *ctx, const VkSubmitInfo2 *in, VkSubmitInfo2 *out)
+static void convert_VkSubmitInfo2_win64_to_host(struct conversion_context *ctx, const VkSubmitInfo2 *in, VkSubmitInfo2 *out)
 {
-    const VkBaseInStructure *in_header;
-    VkBaseOutStructure *out_header = (void *)out;
-
     if (!in) return;
 
     out->sType = in->sType;
-    out->pNext = NULL;
+    out->pNext = in->pNext;
     out->flags = in->flags;
     out->waitSemaphoreInfoCount = in->waitSemaphoreInfoCount;
     out->pWaitSemaphoreInfos = in->pWaitSemaphoreInfos;
     out->commandBufferInfoCount = in->commandBufferInfoCount;
-    out->pCommandBufferInfos = convert_VkCommandBufferSubmitInfo_array_win64_to_unwrapped_host(ctx, in->pCommandBufferInfos, in->commandBufferInfoCount);
+    out->pCommandBufferInfos = convert_VkCommandBufferSubmitInfo_array_win64_to_host(ctx, in->pCommandBufferInfos, in->commandBufferInfoCount);
     out->signalSemaphoreInfoCount = in->signalSemaphoreInfoCount;
     out->pSignalSemaphoreInfos = in->pSignalSemaphoreInfos;
-
-    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
-    {
-        switch (in_header->sType)
-        {
-        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT:
-        {
-            VkFrameBoundaryEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkFrameBoundaryEXT *in_ext = (const VkFrameBoundaryEXT *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT;
-            out_ext->pNext = NULL;
-            out_ext->flags = in_ext->flags;
-            out_ext->frameID = in_ext->frameID;
-            out_ext->imageCount = in_ext->imageCount;
-            out_ext->pImages = in_ext->pImages;
-            out_ext->bufferCount = in_ext->bufferCount;
-            out_ext->pBuffers = in_ext->pBuffers;
-            out_ext->tagName = in_ext->tagName;
-            out_ext->tagSize = in_ext->tagSize;
-            out_ext->pTag = in_ext->pTag;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM:
-        {
-            VkFrameBoundaryTensorsARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkFrameBoundaryTensorsARM *in_ext = (const VkFrameBoundaryTensorsARM *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM;
-            out_ext->pNext = NULL;
-            out_ext->tensorCount = in_ext->tensorCount;
-            out_ext->pTensors = in_ext->pTensors;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV:
-        {
-            VkLatencySubmissionPresentIdNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkLatencySubmissionPresentIdNV *in_ext = (const VkLatencySubmissionPresentIdNV *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV;
-            out_ext->pNext = NULL;
-            out_ext->presentID = in_ext->presentID;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR:
-        {
-            VkPerformanceQuerySubmitInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkPerformanceQuerySubmitInfoKHR *in_ext = (const VkPerformanceQuerySubmitInfoKHR *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR;
-            out_ext->pNext = NULL;
-            out_ext->counterPassIndex = in_ext->counterPassIndex;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
-        {
-            VkWin32KeyedMutexAcquireReleaseInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkWin32KeyedMutexAcquireReleaseInfoKHR *in_ext = (const VkWin32KeyedMutexAcquireReleaseInfoKHR *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR;
-            out_ext->pNext = NULL;
-            out_ext->acquireCount = in_ext->acquireCount;
-            out_ext->pAcquireSyncs = convert_VkDeviceMemory_array_win64_to_host(ctx, in_ext->pAcquireSyncs, in_ext->acquireCount);
-            out_ext->pAcquireKeys = in_ext->pAcquireKeys;
-            out_ext->pAcquireTimeouts = in_ext->pAcquireTimeouts;
-            out_ext->releaseCount = in_ext->releaseCount;
-            out_ext->pReleaseSyncs = convert_VkDeviceMemory_array_win64_to_host(ctx, in_ext->pReleaseSyncs, in_ext->releaseCount);
-            out_ext->pReleaseKeys = in_ext->pReleaseKeys;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
-            break;
-        }
-    }
 }
 #endif /* _WIN64 */
 
 #ifdef _WIN64
-static const VkSubmitInfo2 *convert_VkSubmitInfo2_array_win64_to_unwrapped_host(struct conversion_context *ctx, const VkSubmitInfo2 *in, uint32_t count)
+static const VkSubmitInfo2 *convert_VkSubmitInfo2_array_win64_to_host(struct conversion_context *ctx, const VkSubmitInfo2 *in, uint32_t count)
 {
     VkSubmitInfo2 *out;
     unsigned int i;
@@ -40354,7 +39697,7 @@ static const VkSubmitInfo2 *convert_VkSubmitInfo2_array_win64_to_unwrapped_host(
     out = conversion_context_alloc(ctx, count * sizeof(*out));
     for (i = 0; i < count; i++)
     {
-        convert_VkSubmitInfo2_win64_to_unwrapped_host(ctx, &in[i], &out[i]);
+        convert_VkSubmitInfo2_win64_to_host(ctx, &in[i], &out[i]);
     }
 
     return out;
@@ -40391,7 +39734,7 @@ static const VkSemaphoreSubmitInfo *convert_VkSemaphoreSubmitInfo_array_win32_to
     return out;
 }
 
-static void convert_VkCommandBufferSubmitInfo_win32_to_unwrapped_host(struct conversion_context *ctx, const VkCommandBufferSubmitInfo32 *in, VkCommandBufferSubmitInfo *out)
+static void convert_VkCommandBufferSubmitInfo_win32_to_host(struct conversion_context *ctx, const VkCommandBufferSubmitInfo32 *in, VkCommandBufferSubmitInfo *out)
 {
     const VkBaseInStructure32 *in_header;
     VkBaseOutStructure *out_header = (void *)out;
@@ -40400,7 +39743,7 @@ static void convert_VkCommandBufferSubmitInfo_win32_to_unwrapped_host(struct con
 
     out->sType = in->sType;
     out->pNext = NULL;
-    out->commandBuffer = (VkCommandBuffer)UlongToPtr(in->commandBuffer);
+    out->commandBuffer = wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(in->commandBuffer))->host.command_buffer;
     out->deviceMask = in->deviceMask;
 
     for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
@@ -40426,7 +39769,7 @@ static void convert_VkCommandBufferSubmitInfo_win32_to_unwrapped_host(struct con
     }
 }
 
-static const VkCommandBufferSubmitInfo *convert_VkCommandBufferSubmitInfo_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkCommandBufferSubmitInfo32 *in, uint32_t count)
+static const VkCommandBufferSubmitInfo *convert_VkCommandBufferSubmitInfo_array_win32_to_host(struct conversion_context *ctx, const VkCommandBufferSubmitInfo32 *in, uint32_t count)
 {
     VkCommandBufferSubmitInfo *out;
     unsigned int i;
@@ -40436,13 +39779,13 @@ static const VkCommandBufferSubmitInfo *convert_VkCommandBufferSubmitInfo_array_
     out = conversion_context_alloc(ctx, count * sizeof(*out));
     for (i = 0; i < count; i++)
     {
-        convert_VkCommandBufferSubmitInfo_win32_to_unwrapped_host(ctx, &in[i], &out[i]);
+        convert_VkCommandBufferSubmitInfo_win32_to_host(ctx, &in[i], &out[i]);
     }
 
     return out;
 }
 
-static void convert_VkSubmitInfo2_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSubmitInfo232 *in, VkSubmitInfo2 *out)
+static void convert_VkSubmitInfo2_win32_to_host(struct conversion_context *ctx, const VkSubmitInfo232 *in, VkSubmitInfo2 *out)
 {
     const VkBaseInStructure32 *in_header;
     VkBaseOutStructure *out_header = (void *)out;
@@ -40455,7 +39798,7 @@ static void convert_VkSubmitInfo2_win32_to_unwrapped_host(struct conversion_cont
     out->waitSemaphoreInfoCount = in->waitSemaphoreInfoCount;
     out->pWaitSemaphoreInfos = convert_VkSemaphoreSubmitInfo_array_win32_to_host(ctx, (const VkSemaphoreSubmitInfo32 *)UlongToPtr(in->pWaitSemaphoreInfos), in->waitSemaphoreInfoCount);
     out->commandBufferInfoCount = in->commandBufferInfoCount;
-    out->pCommandBufferInfos = convert_VkCommandBufferSubmitInfo_array_win32_to_unwrapped_host(ctx, (const VkCommandBufferSubmitInfo32 *)UlongToPtr(in->pCommandBufferInfos), in->commandBufferInfoCount);
+    out->pCommandBufferInfos = convert_VkCommandBufferSubmitInfo_array_win32_to_host(ctx, (const VkCommandBufferSubmitInfo32 *)UlongToPtr(in->pCommandBufferInfos), in->commandBufferInfoCount);
     out->signalSemaphoreInfoCount = in->signalSemaphoreInfoCount;
     out->pSignalSemaphoreInfos = convert_VkSemaphoreSubmitInfo_array_win32_to_host(ctx, (const VkSemaphoreSubmitInfo32 *)UlongToPtr(in->pSignalSemaphoreInfos), in->signalSemaphoreInfoCount);
 
@@ -40516,23 +39859,6 @@ static void convert_VkSubmitInfo2_win32_to_unwrapped_host(struct conversion_cont
             out_header = (void *)out_ext;
             break;
         }
-        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
-        {
-            VkWin32KeyedMutexAcquireReleaseInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkWin32KeyedMutexAcquireReleaseInfoKHR32 *in_ext = (const VkWin32KeyedMutexAcquireReleaseInfoKHR32 *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR;
-            out_ext->pNext = NULL;
-            out_ext->acquireCount = in_ext->acquireCount;
-            out_ext->pAcquireSyncs = convert_VkDeviceMemory_array_win32_to_host(ctx, (const VkDeviceMemory *)UlongToPtr(in_ext->pAcquireSyncs), in_ext->acquireCount);
-            out_ext->pAcquireKeys = UlongToPtr(in_ext->pAcquireKeys);
-            out_ext->pAcquireTimeouts = UlongToPtr(in_ext->pAcquireTimeouts);
-            out_ext->releaseCount = in_ext->releaseCount;
-            out_ext->pReleaseSyncs = convert_VkDeviceMemory_array_win32_to_host(ctx, (const VkDeviceMemory *)UlongToPtr(in_ext->pReleaseSyncs), in_ext->releaseCount);
-            out_ext->pReleaseKeys = UlongToPtr(in_ext->pReleaseKeys);
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
         default:
             FIXME("Unhandled sType %u.\n", in_header->sType);
             break;
@@ -40540,7 +39866,7 @@ static void convert_VkSubmitInfo2_win32_to_unwrapped_host(struct conversion_cont
     }
 }
 
-static const VkSubmitInfo2 *convert_VkSubmitInfo2_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSubmitInfo232 *in, uint32_t count)
+static const VkSubmitInfo2 *convert_VkSubmitInfo2_array_win32_to_host(struct conversion_context *ctx, const VkSubmitInfo232 *in, uint32_t count)
 {
     VkSubmitInfo2 *out;
     unsigned int i;
@@ -40550,7 +39876,7 @@ static const VkSubmitInfo2 *convert_VkSubmitInfo2_array_win32_to_unwrapped_host(
     out = conversion_context_alloc(ctx, count * sizeof(*out));
     for (i = 0; i < count; i++)
     {
-        convert_VkSubmitInfo2_win32_to_unwrapped_host(ctx, &in[i], &out[i]);
+        convert_VkSubmitInfo2_win32_to_host(ctx, &in[i], &out[i]);
     }
 
     return out;
@@ -41398,7 +40724,7 @@ static NTSTATUS thunk64_vkBeginCommandBuffer(void *args)
 
     init_conversion_context(ctx);
     convert_VkCommandBufferBeginInfo_win64_to_host(ctx, params->pBeginInfo, &pBeginInfo_host);
-    params->result = vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkBeginCommandBuffer(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, &pBeginInfo_host);
+    params->result = wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkBeginCommandBuffer(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, &pBeginInfo_host);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -41420,7 +40746,7 @@ static NTSTATUS thunk32_vkBeginCommandBuffer(void *args)
 
     init_conversion_context(ctx);
     convert_VkCommandBufferBeginInfo_win32_to_host(ctx, (const VkCommandBufferBeginInfo32 *)UlongToPtr(params->pBeginInfo), &pBeginInfo_host);
-    params->result = vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkBeginCommandBuffer(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBeginInfo_host);
+    params->result = wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkBeginCommandBuffer(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBeginInfo_host);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -41920,7 +41246,7 @@ static void thunk64_vkCmdBeginConditionalRenderingEXT(void *args)
 {
     struct vkCmdBeginConditionalRenderingEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginConditionalRenderingEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pConditionalRenderingBegin);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginConditionalRenderingEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pConditionalRenderingBegin);
 }
 #endif /* _WIN64 */
 
@@ -41934,7 +41260,7 @@ static void thunk32_vkCmdBeginConditionalRenderingEXT(void *args)
     VkConditionalRenderingBeginInfoEXT pConditionalRenderingBegin_host;
 
     convert_VkConditionalRenderingBeginInfoEXT_win32_to_host((const VkConditionalRenderingBeginInfoEXT32 *)UlongToPtr(params->pConditionalRenderingBegin), &pConditionalRenderingBegin_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginConditionalRenderingEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pConditionalRenderingBegin_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginConditionalRenderingEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pConditionalRenderingBegin_host);
 }
 
 #ifdef _WIN64
@@ -41942,7 +41268,7 @@ static void thunk64_vkCmdBeginDebugUtilsLabelEXT(void *args)
 {
     struct vkCmdBeginDebugUtilsLabelEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginDebugUtilsLabelEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pLabelInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginDebugUtilsLabelEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pLabelInfo);
 }
 #endif /* _WIN64 */
 
@@ -41956,7 +41282,7 @@ static void thunk32_vkCmdBeginDebugUtilsLabelEXT(void *args)
     VkDebugUtilsLabelEXT pLabelInfo_host;
 
     convert_VkDebugUtilsLabelEXT_win32_to_host((const VkDebugUtilsLabelEXT32 *)UlongToPtr(params->pLabelInfo), &pLabelInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginDebugUtilsLabelEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pLabelInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginDebugUtilsLabelEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pLabelInfo_host);
 }
 
 #ifdef _WIN64
@@ -41964,7 +41290,7 @@ static void thunk64_vkCmdBeginPerTileExecutionQCOM(void *args)
 {
     struct vkCmdBeginPerTileExecutionQCOM_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginPerTileExecutionQCOM(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPerTileBeginInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginPerTileExecutionQCOM(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPerTileBeginInfo);
 }
 #endif /* _WIN64 */
 
@@ -41978,7 +41304,7 @@ static void thunk32_vkCmdBeginPerTileExecutionQCOM(void *args)
     VkPerTileBeginInfoQCOM pPerTileBeginInfo_host;
 
     convert_VkPerTileBeginInfoQCOM_win32_to_host((const VkPerTileBeginInfoQCOM32 *)UlongToPtr(params->pPerTileBeginInfo), &pPerTileBeginInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginPerTileExecutionQCOM(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPerTileBeginInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginPerTileExecutionQCOM(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPerTileBeginInfo_host);
 }
 
 #ifdef _WIN64
@@ -41986,7 +41312,7 @@ static void thunk64_vkCmdBeginQuery(void *args)
 {
     struct vkCmdBeginQuery_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginQuery(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->queryPool, params->query, params->flags);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginQuery(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->queryPool, params->query, params->flags);
 }
 #endif /* _WIN64 */
 
@@ -42000,7 +41326,7 @@ static void thunk32_vkCmdBeginQuery(void *args)
         VkQueryControlFlags flags;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginQuery(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->queryPool, params->query, params->flags);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginQuery(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->queryPool, params->query, params->flags);
 }
 
 #ifdef _WIN64
@@ -42008,7 +41334,7 @@ static void thunk64_vkCmdBeginQueryIndexedEXT(void *args)
 {
     struct vkCmdBeginQueryIndexedEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginQueryIndexedEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->queryPool, params->query, params->flags, params->index);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginQueryIndexedEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->queryPool, params->query, params->flags, params->index);
 }
 #endif /* _WIN64 */
 
@@ -42023,7 +41349,7 @@ static void thunk32_vkCmdBeginQueryIndexedEXT(void *args)
         uint32_t index;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginQueryIndexedEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->queryPool, params->query, params->flags, params->index);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginQueryIndexedEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->queryPool, params->query, params->flags, params->index);
 }
 
 #ifdef _WIN64
@@ -42031,7 +41357,7 @@ static void thunk64_vkCmdBeginRenderPass(void *args)
 {
     struct vkCmdBeginRenderPass_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginRenderPass(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRenderPassBegin, params->contents);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginRenderPass(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRenderPassBegin, params->contents);
 }
 #endif /* _WIN64 */
 
@@ -42049,7 +41375,7 @@ static void thunk32_vkCmdBeginRenderPass(void *args)
 
     init_conversion_context(ctx);
     convert_VkRenderPassBeginInfo_win32_to_host(ctx, (const VkRenderPassBeginInfo32 *)UlongToPtr(params->pRenderPassBegin), &pRenderPassBegin_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginRenderPass(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRenderPassBegin_host, params->contents);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginRenderPass(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRenderPassBegin_host, params->contents);
     free_conversion_context(ctx);
 }
 
@@ -42058,7 +41384,7 @@ static void thunk64_vkCmdBeginRenderPass2(void *args)
 {
     struct vkCmdBeginRenderPass2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginRenderPass2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRenderPassBegin, params->pSubpassBeginInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginRenderPass2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRenderPassBegin, params->pSubpassBeginInfo);
 }
 #endif /* _WIN64 */
 
@@ -42078,7 +41404,7 @@ static void thunk32_vkCmdBeginRenderPass2(void *args)
     init_conversion_context(ctx);
     convert_VkRenderPassBeginInfo_win32_to_host(ctx, (const VkRenderPassBeginInfo32 *)UlongToPtr(params->pRenderPassBegin), &pRenderPassBegin_host);
     convert_VkSubpassBeginInfo_win32_to_host((const VkSubpassBeginInfo32 *)UlongToPtr(params->pSubpassBeginInfo), &pSubpassBeginInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginRenderPass2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRenderPassBegin_host, &pSubpassBeginInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginRenderPass2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRenderPassBegin_host, &pSubpassBeginInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -42087,7 +41413,7 @@ static void thunk64_vkCmdBeginRenderPass2KHR(void *args)
 {
     struct vkCmdBeginRenderPass2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginRenderPass2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRenderPassBegin, params->pSubpassBeginInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginRenderPass2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRenderPassBegin, params->pSubpassBeginInfo);
 }
 #endif /* _WIN64 */
 
@@ -42107,7 +41433,7 @@ static void thunk32_vkCmdBeginRenderPass2KHR(void *args)
     init_conversion_context(ctx);
     convert_VkRenderPassBeginInfo_win32_to_host(ctx, (const VkRenderPassBeginInfo32 *)UlongToPtr(params->pRenderPassBegin), &pRenderPassBegin_host);
     convert_VkSubpassBeginInfo_win32_to_host((const VkSubpassBeginInfo32 *)UlongToPtr(params->pSubpassBeginInfo), &pSubpassBeginInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginRenderPass2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRenderPassBegin_host, &pSubpassBeginInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginRenderPass2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRenderPassBegin_host, &pSubpassBeginInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -42116,7 +41442,7 @@ static void thunk64_vkCmdBeginRendering(void *args)
 {
     struct vkCmdBeginRendering_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginRendering(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRenderingInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginRendering(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRenderingInfo);
 }
 #endif /* _WIN64 */
 
@@ -42133,7 +41459,7 @@ static void thunk32_vkCmdBeginRendering(void *args)
 
     init_conversion_context(ctx);
     convert_VkRenderingInfo_win32_to_host(ctx, (const VkRenderingInfo32 *)UlongToPtr(params->pRenderingInfo), &pRenderingInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginRendering(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRenderingInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginRendering(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRenderingInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -42142,7 +41468,7 @@ static void thunk64_vkCmdBeginRenderingKHR(void *args)
 {
     struct vkCmdBeginRenderingKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginRenderingKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRenderingInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginRenderingKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRenderingInfo);
 }
 #endif /* _WIN64 */
 
@@ -42159,7 +41485,7 @@ static void thunk32_vkCmdBeginRenderingKHR(void *args)
 
     init_conversion_context(ctx);
     convert_VkRenderingInfo_win32_to_host(ctx, (const VkRenderingInfo32 *)UlongToPtr(params->pRenderingInfo), &pRenderingInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginRenderingKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRenderingInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginRenderingKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRenderingInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -42168,7 +41494,7 @@ static void thunk64_vkCmdBeginTransformFeedbackEXT(void *args)
 {
     struct vkCmdBeginTransformFeedbackEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginTransformFeedbackEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstCounterBuffer, params->counterBufferCount, params->pCounterBuffers, params->pCounterBufferOffsets);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginTransformFeedbackEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstCounterBuffer, params->counterBufferCount, params->pCounterBuffers, params->pCounterBufferOffsets);
 }
 #endif /* _WIN64 */
 
@@ -42183,7 +41509,7 @@ static void thunk32_vkCmdBeginTransformFeedbackEXT(void *args)
         PTR32 pCounterBufferOffsets;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginTransformFeedbackEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstCounterBuffer, params->counterBufferCount, (const VkBuffer *)UlongToPtr(params->pCounterBuffers), (const VkDeviceSize *)UlongToPtr(params->pCounterBufferOffsets));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginTransformFeedbackEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstCounterBuffer, params->counterBufferCount, (const VkBuffer *)UlongToPtr(params->pCounterBuffers), (const VkDeviceSize *)UlongToPtr(params->pCounterBufferOffsets));
 }
 
 #ifdef _WIN64
@@ -42191,7 +41517,7 @@ static void thunk64_vkCmdBeginVideoCodingKHR(void *args)
 {
     struct vkCmdBeginVideoCodingKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginVideoCodingKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBeginInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginVideoCodingKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBeginInfo);
 }
 #endif /* _WIN64 */
 
@@ -42208,7 +41534,7 @@ static void thunk32_vkCmdBeginVideoCodingKHR(void *args)
 
     init_conversion_context(ctx);
     convert_VkVideoBeginCodingInfoKHR_win32_to_host(ctx, (const VkVideoBeginCodingInfoKHR32 *)UlongToPtr(params->pBeginInfo), &pBeginInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginVideoCodingKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBeginInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginVideoCodingKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBeginInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -42217,7 +41543,7 @@ static void thunk64_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT(void *args)
 {
     struct vkCmdBindDescriptorBufferEmbeddedSamplers2EXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBindDescriptorBufferEmbeddedSamplersInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBindDescriptorBufferEmbeddedSamplersInfo);
 }
 #endif /* _WIN64 */
 
@@ -42234,7 +41560,7 @@ static void thunk32_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT(void *args)
 
     init_conversion_context(ctx);
     convert_VkBindDescriptorBufferEmbeddedSamplersInfoEXT_win32_to_host(ctx, (const VkBindDescriptorBufferEmbeddedSamplersInfoEXT32 *)UlongToPtr(params->pBindDescriptorBufferEmbeddedSamplersInfo), &pBindDescriptorBufferEmbeddedSamplersInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBindDescriptorBufferEmbeddedSamplersInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBindDescriptorBufferEmbeddedSamplersInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -42243,7 +41569,7 @@ static void thunk64_vkCmdBindDescriptorBufferEmbeddedSamplersEXT(void *args)
 {
     struct vkCmdBindDescriptorBufferEmbeddedSamplersEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindDescriptorBufferEmbeddedSamplersEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->layout, params->set);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindDescriptorBufferEmbeddedSamplersEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->layout, params->set);
 }
 #endif /* _WIN64 */
 
@@ -42257,7 +41583,7 @@ static void thunk32_vkCmdBindDescriptorBufferEmbeddedSamplersEXT(void *args)
         uint32_t set;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindDescriptorBufferEmbeddedSamplersEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->layout, params->set);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindDescriptorBufferEmbeddedSamplersEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->layout, params->set);
 }
 
 #ifdef _WIN64
@@ -42265,7 +41591,7 @@ static void thunk64_vkCmdBindDescriptorBuffersEXT(void *args)
 {
     struct vkCmdBindDescriptorBuffersEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindDescriptorBuffersEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->bufferCount, params->pBindingInfos);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindDescriptorBuffersEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->bufferCount, params->pBindingInfos);
 }
 #endif /* _WIN64 */
 
@@ -42283,7 +41609,7 @@ static void thunk32_vkCmdBindDescriptorBuffersEXT(void *args)
 
     init_conversion_context(ctx);
     pBindingInfos_host = convert_VkDescriptorBufferBindingInfoEXT_array_win32_to_host(ctx, (const VkDescriptorBufferBindingInfoEXT32 *)UlongToPtr(params->pBindingInfos), params->bufferCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindDescriptorBuffersEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->bufferCount, pBindingInfos_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindDescriptorBuffersEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->bufferCount, pBindingInfos_host);
     free_conversion_context(ctx);
 }
 
@@ -42292,7 +41618,7 @@ static void thunk64_vkCmdBindDescriptorSets(void *args)
 {
     struct vkCmdBindDescriptorSets_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindDescriptorSets(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->layout, params->firstSet, params->descriptorSetCount, params->pDescriptorSets, params->dynamicOffsetCount, params->pDynamicOffsets);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindDescriptorSets(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->layout, params->firstSet, params->descriptorSetCount, params->pDescriptorSets, params->dynamicOffsetCount, params->pDynamicOffsets);
 }
 #endif /* _WIN64 */
 
@@ -42310,7 +41636,7 @@ static void thunk32_vkCmdBindDescriptorSets(void *args)
         PTR32 pDynamicOffsets;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindDescriptorSets(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->layout, params->firstSet, params->descriptorSetCount, (const VkDescriptorSet *)UlongToPtr(params->pDescriptorSets), params->dynamicOffsetCount, (const uint32_t *)UlongToPtr(params->pDynamicOffsets));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindDescriptorSets(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->layout, params->firstSet, params->descriptorSetCount, (const VkDescriptorSet *)UlongToPtr(params->pDescriptorSets), params->dynamicOffsetCount, (const uint32_t *)UlongToPtr(params->pDynamicOffsets));
 }
 
 #ifdef _WIN64
@@ -42318,7 +41644,7 @@ static void thunk64_vkCmdBindDescriptorSets2(void *args)
 {
     struct vkCmdBindDescriptorSets2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindDescriptorSets2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBindDescriptorSetsInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindDescriptorSets2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBindDescriptorSetsInfo);
 }
 #endif /* _WIN64 */
 
@@ -42335,7 +41661,7 @@ static void thunk32_vkCmdBindDescriptorSets2(void *args)
 
     init_conversion_context(ctx);
     convert_VkBindDescriptorSetsInfo_win32_to_host(ctx, (const VkBindDescriptorSetsInfo32 *)UlongToPtr(params->pBindDescriptorSetsInfo), &pBindDescriptorSetsInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindDescriptorSets2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBindDescriptorSetsInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindDescriptorSets2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBindDescriptorSetsInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -42344,7 +41670,7 @@ static void thunk64_vkCmdBindDescriptorSets2KHR(void *args)
 {
     struct vkCmdBindDescriptorSets2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindDescriptorSets2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBindDescriptorSetsInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindDescriptorSets2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBindDescriptorSetsInfo);
 }
 #endif /* _WIN64 */
 
@@ -42361,7 +41687,7 @@ static void thunk32_vkCmdBindDescriptorSets2KHR(void *args)
 
     init_conversion_context(ctx);
     convert_VkBindDescriptorSetsInfo_win32_to_host(ctx, (const VkBindDescriptorSetsInfo32 *)UlongToPtr(params->pBindDescriptorSetsInfo), &pBindDescriptorSetsInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindDescriptorSets2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBindDescriptorSetsInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindDescriptorSets2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBindDescriptorSetsInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -42370,7 +41696,7 @@ static void thunk64_vkCmdBindIndexBuffer(void *args)
 {
     struct vkCmdBindIndexBuffer_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindIndexBuffer(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->indexType);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindIndexBuffer(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->indexType);
 }
 #endif /* _WIN64 */
 
@@ -42384,7 +41710,7 @@ static void thunk32_vkCmdBindIndexBuffer(void *args)
         VkIndexType indexType;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindIndexBuffer(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->indexType);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindIndexBuffer(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->indexType);
 }
 
 #ifdef _WIN64
@@ -42392,7 +41718,7 @@ static void thunk64_vkCmdBindIndexBuffer2(void *args)
 {
     struct vkCmdBindIndexBuffer2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindIndexBuffer2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->size, params->indexType);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindIndexBuffer2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->size, params->indexType);
 }
 #endif /* _WIN64 */
 
@@ -42407,7 +41733,7 @@ static void thunk32_vkCmdBindIndexBuffer2(void *args)
         VkIndexType indexType;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindIndexBuffer2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->size, params->indexType);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindIndexBuffer2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->size, params->indexType);
 }
 
 #ifdef _WIN64
@@ -42415,7 +41741,7 @@ static void thunk64_vkCmdBindIndexBuffer2KHR(void *args)
 {
     struct vkCmdBindIndexBuffer2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindIndexBuffer2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->size, params->indexType);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindIndexBuffer2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->size, params->indexType);
 }
 #endif /* _WIN64 */
 
@@ -42430,7 +41756,7 @@ static void thunk32_vkCmdBindIndexBuffer2KHR(void *args)
         VkIndexType indexType;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindIndexBuffer2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->size, params->indexType);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindIndexBuffer2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->size, params->indexType);
 }
 
 #ifdef _WIN64
@@ -42438,7 +41764,7 @@ static void thunk64_vkCmdBindInvocationMaskHUAWEI(void *args)
 {
     struct vkCmdBindInvocationMaskHUAWEI_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindInvocationMaskHUAWEI(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->imageView, params->imageLayout);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindInvocationMaskHUAWEI(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->imageView, params->imageLayout);
 }
 #endif /* _WIN64 */
 
@@ -42451,7 +41777,7 @@ static void thunk32_vkCmdBindInvocationMaskHUAWEI(void *args)
         VkImageLayout imageLayout;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindInvocationMaskHUAWEI(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->imageView, params->imageLayout);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindInvocationMaskHUAWEI(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->imageView, params->imageLayout);
 }
 
 #ifdef _WIN64
@@ -42459,7 +41785,7 @@ static void thunk64_vkCmdBindPipeline(void *args)
 {
     struct vkCmdBindPipeline_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindPipeline(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->pipeline);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindPipeline(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->pipeline);
 }
 #endif /* _WIN64 */
 
@@ -42472,7 +41798,7 @@ static void thunk32_vkCmdBindPipeline(void *args)
         VkPipeline DECLSPEC_ALIGN(8) pipeline;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindPipeline(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->pipeline);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindPipeline(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->pipeline);
 }
 
 #ifdef _WIN64
@@ -42480,7 +41806,7 @@ static void thunk64_vkCmdBindPipelineShaderGroupNV(void *args)
 {
     struct vkCmdBindPipelineShaderGroupNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindPipelineShaderGroupNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->pipeline, params->groupIndex);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindPipelineShaderGroupNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->pipeline, params->groupIndex);
 }
 #endif /* _WIN64 */
 
@@ -42494,7 +41820,7 @@ static void thunk32_vkCmdBindPipelineShaderGroupNV(void *args)
         uint32_t groupIndex;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindPipelineShaderGroupNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->pipeline, params->groupIndex);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindPipelineShaderGroupNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->pipeline, params->groupIndex);
 }
 
 #ifdef _WIN64
@@ -42502,7 +41828,7 @@ static void thunk64_vkCmdBindShadersEXT(void *args)
 {
     struct vkCmdBindShadersEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindShadersEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stageCount, params->pStages, params->pShaders);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindShadersEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stageCount, params->pStages, params->pShaders);
 }
 #endif /* _WIN64 */
 
@@ -42516,7 +41842,7 @@ static void thunk32_vkCmdBindShadersEXT(void *args)
         PTR32 pShaders;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindShadersEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stageCount, (const VkShaderStageFlagBits *)UlongToPtr(params->pStages), (const VkShaderEXT *)UlongToPtr(params->pShaders));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindShadersEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stageCount, (const VkShaderStageFlagBits *)UlongToPtr(params->pStages), (const VkShaderEXT *)UlongToPtr(params->pShaders));
 }
 
 #ifdef _WIN64
@@ -42524,7 +41850,7 @@ static void thunk64_vkCmdBindShadingRateImageNV(void *args)
 {
     struct vkCmdBindShadingRateImageNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindShadingRateImageNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->imageView, params->imageLayout);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindShadingRateImageNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->imageView, params->imageLayout);
 }
 #endif /* _WIN64 */
 
@@ -42537,7 +41863,7 @@ static void thunk32_vkCmdBindShadingRateImageNV(void *args)
         VkImageLayout imageLayout;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindShadingRateImageNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->imageView, params->imageLayout);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindShadingRateImageNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->imageView, params->imageLayout);
 }
 
 #ifdef _WIN64
@@ -42554,7 +41880,7 @@ static void thunk64_vkCmdBindTileMemoryQCOM(void *args)
         pTileMemoryBindInfo_host = conversion_context_alloc(ctx, sizeof(*pTileMemoryBindInfo_host));
         convert_VkTileMemoryBindInfoQCOM_win64_to_host(params->pTileMemoryBindInfo, pTileMemoryBindInfo_host);
     }
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindTileMemoryQCOM(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, pTileMemoryBindInfo_host);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindTileMemoryQCOM(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, pTileMemoryBindInfo_host);
     free_conversion_context(ctx);
 }
 #endif /* _WIN64 */
@@ -42576,7 +41902,7 @@ static void thunk32_vkCmdBindTileMemoryQCOM(void *args)
         pTileMemoryBindInfo_host = conversion_context_alloc(ctx, sizeof(*pTileMemoryBindInfo_host));
         convert_VkTileMemoryBindInfoQCOM_win32_to_host((const VkTileMemoryBindInfoQCOM32 *)UlongToPtr(params->pTileMemoryBindInfo), pTileMemoryBindInfo_host);
     }
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindTileMemoryQCOM(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, pTileMemoryBindInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindTileMemoryQCOM(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, pTileMemoryBindInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -42585,7 +41911,7 @@ static void thunk64_vkCmdBindTransformFeedbackBuffersEXT(void *args)
 {
     struct vkCmdBindTransformFeedbackBuffersEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindTransformFeedbackBuffersEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstBinding, params->bindingCount, params->pBuffers, params->pOffsets, params->pSizes);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindTransformFeedbackBuffersEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstBinding, params->bindingCount, params->pBuffers, params->pOffsets, params->pSizes);
 }
 #endif /* _WIN64 */
 
@@ -42601,7 +41927,7 @@ static void thunk32_vkCmdBindTransformFeedbackBuffersEXT(void *args)
         PTR32 pSizes;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindTransformFeedbackBuffersEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstBinding, params->bindingCount, (const VkBuffer *)UlongToPtr(params->pBuffers), (const VkDeviceSize *)UlongToPtr(params->pOffsets), (const VkDeviceSize *)UlongToPtr(params->pSizes));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindTransformFeedbackBuffersEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstBinding, params->bindingCount, (const VkBuffer *)UlongToPtr(params->pBuffers), (const VkDeviceSize *)UlongToPtr(params->pOffsets), (const VkDeviceSize *)UlongToPtr(params->pSizes));
 }
 
 #ifdef _WIN64
@@ -42609,7 +41935,7 @@ static void thunk64_vkCmdBindVertexBuffers(void *args)
 {
     struct vkCmdBindVertexBuffers_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindVertexBuffers(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstBinding, params->bindingCount, params->pBuffers, params->pOffsets);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindVertexBuffers(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstBinding, params->bindingCount, params->pBuffers, params->pOffsets);
 }
 #endif /* _WIN64 */
 
@@ -42624,7 +41950,7 @@ static void thunk32_vkCmdBindVertexBuffers(void *args)
         PTR32 pOffsets;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindVertexBuffers(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstBinding, params->bindingCount, (const VkBuffer *)UlongToPtr(params->pBuffers), (const VkDeviceSize *)UlongToPtr(params->pOffsets));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindVertexBuffers(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstBinding, params->bindingCount, (const VkBuffer *)UlongToPtr(params->pBuffers), (const VkDeviceSize *)UlongToPtr(params->pOffsets));
 }
 
 #ifdef _WIN64
@@ -42632,7 +41958,7 @@ static void thunk64_vkCmdBindVertexBuffers2(void *args)
 {
     struct vkCmdBindVertexBuffers2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindVertexBuffers2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstBinding, params->bindingCount, params->pBuffers, params->pOffsets, params->pSizes, params->pStrides);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindVertexBuffers2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstBinding, params->bindingCount, params->pBuffers, params->pOffsets, params->pSizes, params->pStrides);
 }
 #endif /* _WIN64 */
 
@@ -42649,7 +41975,7 @@ static void thunk32_vkCmdBindVertexBuffers2(void *args)
         PTR32 pStrides;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindVertexBuffers2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstBinding, params->bindingCount, (const VkBuffer *)UlongToPtr(params->pBuffers), (const VkDeviceSize *)UlongToPtr(params->pOffsets), (const VkDeviceSize *)UlongToPtr(params->pSizes), (const VkDeviceSize *)UlongToPtr(params->pStrides));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindVertexBuffers2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstBinding, params->bindingCount, (const VkBuffer *)UlongToPtr(params->pBuffers), (const VkDeviceSize *)UlongToPtr(params->pOffsets), (const VkDeviceSize *)UlongToPtr(params->pSizes), (const VkDeviceSize *)UlongToPtr(params->pStrides));
 }
 
 #ifdef _WIN64
@@ -42657,7 +41983,7 @@ static void thunk64_vkCmdBindVertexBuffers2EXT(void *args)
 {
     struct vkCmdBindVertexBuffers2EXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindVertexBuffers2EXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstBinding, params->bindingCount, params->pBuffers, params->pOffsets, params->pSizes, params->pStrides);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindVertexBuffers2EXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstBinding, params->bindingCount, params->pBuffers, params->pOffsets, params->pSizes, params->pStrides);
 }
 #endif /* _WIN64 */
 
@@ -42674,7 +42000,7 @@ static void thunk32_vkCmdBindVertexBuffers2EXT(void *args)
         PTR32 pStrides;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindVertexBuffers2EXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstBinding, params->bindingCount, (const VkBuffer *)UlongToPtr(params->pBuffers), (const VkDeviceSize *)UlongToPtr(params->pOffsets), (const VkDeviceSize *)UlongToPtr(params->pSizes), (const VkDeviceSize *)UlongToPtr(params->pStrides));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindVertexBuffers2EXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstBinding, params->bindingCount, (const VkBuffer *)UlongToPtr(params->pBuffers), (const VkDeviceSize *)UlongToPtr(params->pOffsets), (const VkDeviceSize *)UlongToPtr(params->pSizes), (const VkDeviceSize *)UlongToPtr(params->pStrides));
 }
 
 #ifdef _WIN64
@@ -42682,7 +42008,7 @@ static void thunk64_vkCmdBlitImage(void *args)
 {
     struct vkCmdBlitImage_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBlitImage(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, params->pRegions, params->filter);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBlitImage(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, params->pRegions, params->filter);
 }
 #endif /* _WIN64 */
 
@@ -42700,7 +42026,7 @@ static void thunk32_vkCmdBlitImage(void *args)
         VkFilter filter;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBlitImage(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, (const VkImageBlit *)UlongToPtr(params->pRegions), params->filter);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBlitImage(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, (const VkImageBlit *)UlongToPtr(params->pRegions), params->filter);
 }
 
 #ifdef _WIN64
@@ -42708,7 +42034,7 @@ static void thunk64_vkCmdBlitImage2(void *args)
 {
     struct vkCmdBlitImage2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBlitImage2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBlitImageInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBlitImage2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBlitImageInfo);
 }
 #endif /* _WIN64 */
 
@@ -42725,7 +42051,7 @@ static void thunk32_vkCmdBlitImage2(void *args)
 
     init_conversion_context(ctx);
     convert_VkBlitImageInfo2_win32_to_host(ctx, (const VkBlitImageInfo232 *)UlongToPtr(params->pBlitImageInfo), &pBlitImageInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBlitImage2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBlitImageInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBlitImage2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBlitImageInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -42734,7 +42060,7 @@ static void thunk64_vkCmdBlitImage2KHR(void *args)
 {
     struct vkCmdBlitImage2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBlitImage2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBlitImageInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBlitImage2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBlitImageInfo);
 }
 #endif /* _WIN64 */
 
@@ -42751,7 +42077,7 @@ static void thunk32_vkCmdBlitImage2KHR(void *args)
 
     init_conversion_context(ctx);
     convert_VkBlitImageInfo2_win32_to_host(ctx, (const VkBlitImageInfo232 *)UlongToPtr(params->pBlitImageInfo), &pBlitImageInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBlitImage2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBlitImageInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBlitImage2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBlitImageInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -42760,7 +42086,7 @@ static void thunk64_vkCmdBuildAccelerationStructureNV(void *args)
 {
     struct vkCmdBuildAccelerationStructureNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBuildAccelerationStructureNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo, params->instanceData, params->instanceOffset, params->update, params->dst, params->src, params->scratch, params->scratchOffset);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBuildAccelerationStructureNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo, params->instanceData, params->instanceOffset, params->update, params->dst, params->src, params->scratch, params->scratchOffset);
 }
 #endif /* _WIN64 */
 
@@ -42784,7 +42110,7 @@ static void thunk32_vkCmdBuildAccelerationStructureNV(void *args)
 
     init_conversion_context(ctx);
     convert_VkAccelerationStructureInfoNV_win32_to_host(ctx, (const VkAccelerationStructureInfoNV32 *)UlongToPtr(params->pInfo), &pInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBuildAccelerationStructureNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host, params->instanceData, params->instanceOffset, params->update, params->dst, params->src, params->scratch, params->scratchOffset);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBuildAccelerationStructureNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host, params->instanceData, params->instanceOffset, params->update, params->dst, params->src, params->scratch, params->scratchOffset);
     free_conversion_context(ctx);
 }
 
@@ -42793,7 +42119,7 @@ static void thunk64_vkCmdBuildAccelerationStructuresIndirectKHR(void *args)
 {
     struct vkCmdBuildAccelerationStructuresIndirectKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBuildAccelerationStructuresIndirectKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->infoCount, params->pInfos, params->pIndirectDeviceAddresses, params->pIndirectStrides, params->ppMaxPrimitiveCounts);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBuildAccelerationStructuresIndirectKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->infoCount, params->pInfos, params->pIndirectDeviceAddresses, params->pIndirectStrides, params->ppMaxPrimitiveCounts);
 }
 #endif /* _WIN64 */
 
@@ -42816,7 +42142,7 @@ static void thunk32_vkCmdBuildAccelerationStructuresIndirectKHR(void *args)
     init_conversion_context(ctx);
     pInfos_host = convert_VkAccelerationStructureBuildGeometryInfoKHR_array_win32_to_host(ctx, (const VkAccelerationStructureBuildGeometryInfoKHR32 *)UlongToPtr(params->pInfos), params->infoCount);
     ppMaxPrimitiveCounts_host = convert_uint32_t_array_win32_to_host(ctx, (const PTR32 *)UlongToPtr(params->ppMaxPrimitiveCounts), params->infoCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBuildAccelerationStructuresIndirectKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->infoCount, pInfos_host, (const VkDeviceAddress *)UlongToPtr(params->pIndirectDeviceAddresses), (const uint32_t *)UlongToPtr(params->pIndirectStrides), ppMaxPrimitiveCounts_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBuildAccelerationStructuresIndirectKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->infoCount, pInfos_host, (const VkDeviceAddress *)UlongToPtr(params->pIndirectDeviceAddresses), (const uint32_t *)UlongToPtr(params->pIndirectStrides), ppMaxPrimitiveCounts_host);
     convert_uint32_t_array_host_to_win32(ppMaxPrimitiveCounts_host, (PTR32 *)UlongToPtr(params->ppMaxPrimitiveCounts), params->infoCount);
     free_conversion_context(ctx);
 }
@@ -42826,7 +42152,7 @@ static void thunk64_vkCmdBuildAccelerationStructuresKHR(void *args)
 {
     struct vkCmdBuildAccelerationStructuresKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBuildAccelerationStructuresKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->infoCount, params->pInfos, params->ppBuildRangeInfos);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBuildAccelerationStructuresKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->infoCount, params->pInfos, params->ppBuildRangeInfos);
 }
 #endif /* _WIN64 */
 
@@ -42847,7 +42173,7 @@ static void thunk32_vkCmdBuildAccelerationStructuresKHR(void *args)
     init_conversion_context(ctx);
     pInfos_host = convert_VkAccelerationStructureBuildGeometryInfoKHR_array_win32_to_host(ctx, (const VkAccelerationStructureBuildGeometryInfoKHR32 *)UlongToPtr(params->pInfos), params->infoCount);
     ppBuildRangeInfos_host = convert_VkAccelerationStructureBuildRangeInfoKHR_array_win32_to_host(ctx, (const PTR32 *)UlongToPtr(params->ppBuildRangeInfos), params->infoCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBuildAccelerationStructuresKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->infoCount, pInfos_host, ppBuildRangeInfos_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBuildAccelerationStructuresKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->infoCount, pInfos_host, ppBuildRangeInfos_host);
     free_conversion_context(ctx);
 }
 
@@ -42856,7 +42182,7 @@ static void thunk64_vkCmdBuildClusterAccelerationStructureIndirectNV(void *args)
 {
     struct vkCmdBuildClusterAccelerationStructureIndirectNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBuildClusterAccelerationStructureIndirectNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCommandInfos);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBuildClusterAccelerationStructureIndirectNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCommandInfos);
 }
 #endif /* _WIN64 */
 
@@ -42873,7 +42199,7 @@ static void thunk32_vkCmdBuildClusterAccelerationStructureIndirectNV(void *args)
 
     init_conversion_context(ctx);
     convert_VkClusterAccelerationStructureCommandsInfoNV_win32_to_host(ctx, (const VkClusterAccelerationStructureCommandsInfoNV32 *)UlongToPtr(params->pCommandInfos), &pCommandInfos_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBuildClusterAccelerationStructureIndirectNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCommandInfos_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBuildClusterAccelerationStructureIndirectNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCommandInfos_host);
     free_conversion_context(ctx);
 }
 
@@ -42882,7 +42208,7 @@ static void thunk64_vkCmdBuildMicromapsEXT(void *args)
 {
     struct vkCmdBuildMicromapsEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBuildMicromapsEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->infoCount, params->pInfos);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBuildMicromapsEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->infoCount, params->pInfos);
 }
 #endif /* _WIN64 */
 
@@ -42900,7 +42226,7 @@ static void thunk32_vkCmdBuildMicromapsEXT(void *args)
 
     init_conversion_context(ctx);
     pInfos_host = convert_VkMicromapBuildInfoEXT_array_win32_to_host(ctx, (const VkMicromapBuildInfoEXT32 *)UlongToPtr(params->pInfos), params->infoCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBuildMicromapsEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->infoCount, pInfos_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBuildMicromapsEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->infoCount, pInfos_host);
     free_conversion_context(ctx);
 }
 
@@ -42909,7 +42235,7 @@ static void thunk64_vkCmdBuildPartitionedAccelerationStructuresNV(void *args)
 {
     struct vkCmdBuildPartitionedAccelerationStructuresNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBuildPartitionedAccelerationStructuresNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBuildInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBuildPartitionedAccelerationStructuresNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBuildInfo);
 }
 #endif /* _WIN64 */
 
@@ -42926,7 +42252,7 @@ static void thunk32_vkCmdBuildPartitionedAccelerationStructuresNV(void *args)
 
     init_conversion_context(ctx);
     convert_VkBuildPartitionedAccelerationStructureInfoNV_win32_to_host(ctx, (const VkBuildPartitionedAccelerationStructureInfoNV32 *)UlongToPtr(params->pBuildInfo), &pBuildInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBuildPartitionedAccelerationStructuresNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBuildInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBuildPartitionedAccelerationStructuresNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBuildInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -42935,7 +42261,7 @@ static void thunk64_vkCmdClearAttachments(void *args)
 {
     struct vkCmdClearAttachments_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdClearAttachments(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->attachmentCount, params->pAttachments, params->rectCount, params->pRects);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdClearAttachments(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->attachmentCount, params->pAttachments, params->rectCount, params->pRects);
 }
 #endif /* _WIN64 */
 
@@ -42950,7 +42276,7 @@ static void thunk32_vkCmdClearAttachments(void *args)
         PTR32 pRects;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdClearAttachments(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->attachmentCount, (const VkClearAttachment *)UlongToPtr(params->pAttachments), params->rectCount, (const VkClearRect *)UlongToPtr(params->pRects));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdClearAttachments(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->attachmentCount, (const VkClearAttachment *)UlongToPtr(params->pAttachments), params->rectCount, (const VkClearRect *)UlongToPtr(params->pRects));
 }
 
 #ifdef _WIN64
@@ -42958,7 +42284,7 @@ static void thunk64_vkCmdClearColorImage(void *args)
 {
     struct vkCmdClearColorImage_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdClearColorImage(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->image, params->imageLayout, params->pColor, params->rangeCount, params->pRanges);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdClearColorImage(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->image, params->imageLayout, params->pColor, params->rangeCount, params->pRanges);
 }
 #endif /* _WIN64 */
 
@@ -42974,7 +42300,7 @@ static void thunk32_vkCmdClearColorImage(void *args)
         PTR32 pRanges;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdClearColorImage(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->image, params->imageLayout, (const VkClearColorValue *)UlongToPtr(params->pColor), params->rangeCount, (const VkImageSubresourceRange *)UlongToPtr(params->pRanges));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdClearColorImage(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->image, params->imageLayout, (const VkClearColorValue *)UlongToPtr(params->pColor), params->rangeCount, (const VkImageSubresourceRange *)UlongToPtr(params->pRanges));
 }
 
 #ifdef _WIN64
@@ -42982,7 +42308,7 @@ static void thunk64_vkCmdClearDepthStencilImage(void *args)
 {
     struct vkCmdClearDepthStencilImage_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdClearDepthStencilImage(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->image, params->imageLayout, params->pDepthStencil, params->rangeCount, params->pRanges);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdClearDepthStencilImage(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->image, params->imageLayout, params->pDepthStencil, params->rangeCount, params->pRanges);
 }
 #endif /* _WIN64 */
 
@@ -42998,7 +42324,7 @@ static void thunk32_vkCmdClearDepthStencilImage(void *args)
         PTR32 pRanges;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdClearDepthStencilImage(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->image, params->imageLayout, (const VkClearDepthStencilValue *)UlongToPtr(params->pDepthStencil), params->rangeCount, (const VkImageSubresourceRange *)UlongToPtr(params->pRanges));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdClearDepthStencilImage(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->image, params->imageLayout, (const VkClearDepthStencilValue *)UlongToPtr(params->pDepthStencil), params->rangeCount, (const VkImageSubresourceRange *)UlongToPtr(params->pRanges));
 }
 
 #ifdef _WIN64
@@ -43006,7 +42332,7 @@ static void thunk64_vkCmdControlVideoCodingKHR(void *args)
 {
     struct vkCmdControlVideoCodingKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdControlVideoCodingKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCodingControlInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdControlVideoCodingKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCodingControlInfo);
 }
 #endif /* _WIN64 */
 
@@ -43023,7 +42349,7 @@ static void thunk32_vkCmdControlVideoCodingKHR(void *args)
 
     init_conversion_context(ctx);
     convert_VkVideoCodingControlInfoKHR_win32_to_host(ctx, (const VkVideoCodingControlInfoKHR32 *)UlongToPtr(params->pCodingControlInfo), &pCodingControlInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdControlVideoCodingKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCodingControlInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdControlVideoCodingKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCodingControlInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -43032,7 +42358,7 @@ static void thunk64_vkCmdConvertCooperativeVectorMatrixNV(void *args)
 {
     struct vkCmdConvertCooperativeVectorMatrixNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdConvertCooperativeVectorMatrixNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->infoCount, params->pInfos);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdConvertCooperativeVectorMatrixNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->infoCount, params->pInfos);
 }
 #endif /* _WIN64 */
 
@@ -43050,7 +42376,7 @@ static void thunk32_vkCmdConvertCooperativeVectorMatrixNV(void *args)
 
     init_conversion_context(ctx);
     pInfos_host = convert_VkConvertCooperativeVectorMatrixInfoNV_array_win32_to_host(ctx, (const VkConvertCooperativeVectorMatrixInfoNV32 *)UlongToPtr(params->pInfos), params->infoCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdConvertCooperativeVectorMatrixNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->infoCount, pInfos_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdConvertCooperativeVectorMatrixNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->infoCount, pInfos_host);
     free_conversion_context(ctx);
 }
 
@@ -43059,7 +42385,7 @@ static void thunk64_vkCmdCopyAccelerationStructureKHR(void *args)
 {
     struct vkCmdCopyAccelerationStructureKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyAccelerationStructureKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyAccelerationStructureKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo);
 }
 #endif /* _WIN64 */
 
@@ -43073,7 +42399,7 @@ static void thunk32_vkCmdCopyAccelerationStructureKHR(void *args)
     VkCopyAccelerationStructureInfoKHR pInfo_host;
 
     convert_VkCopyAccelerationStructureInfoKHR_win32_to_host((const VkCopyAccelerationStructureInfoKHR32 *)UlongToPtr(params->pInfo), &pInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyAccelerationStructureKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyAccelerationStructureKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host);
 }
 
 #ifdef _WIN64
@@ -43081,7 +42407,7 @@ static void thunk64_vkCmdCopyAccelerationStructureNV(void *args)
 {
     struct vkCmdCopyAccelerationStructureNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyAccelerationStructureNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->dst, params->src, params->mode);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyAccelerationStructureNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->dst, params->src, params->mode);
 }
 #endif /* _WIN64 */
 
@@ -43095,7 +42421,7 @@ static void thunk32_vkCmdCopyAccelerationStructureNV(void *args)
         VkCopyAccelerationStructureModeKHR mode;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyAccelerationStructureNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->dst, params->src, params->mode);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyAccelerationStructureNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->dst, params->src, params->mode);
 }
 
 #ifdef _WIN64
@@ -43103,7 +42429,7 @@ static void thunk64_vkCmdCopyAccelerationStructureToMemoryKHR(void *args)
 {
     struct vkCmdCopyAccelerationStructureToMemoryKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyAccelerationStructureToMemoryKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyAccelerationStructureToMemoryKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo);
 }
 #endif /* _WIN64 */
 
@@ -43117,7 +42443,7 @@ static void thunk32_vkCmdCopyAccelerationStructureToMemoryKHR(void *args)
     VkCopyAccelerationStructureToMemoryInfoKHR pInfo_host;
 
     convert_VkCopyAccelerationStructureToMemoryInfoKHR_win32_to_host((const VkCopyAccelerationStructureToMemoryInfoKHR32 *)UlongToPtr(params->pInfo), &pInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyAccelerationStructureToMemoryKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyAccelerationStructureToMemoryKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host);
 }
 
 #ifdef _WIN64
@@ -43125,7 +42451,7 @@ static void thunk64_vkCmdCopyBuffer(void *args)
 {
     struct vkCmdCopyBuffer_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyBuffer(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcBuffer, params->dstBuffer, params->regionCount, params->pRegions);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyBuffer(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcBuffer, params->dstBuffer, params->regionCount, params->pRegions);
 }
 #endif /* _WIN64 */
 
@@ -43145,7 +42471,7 @@ static void thunk32_vkCmdCopyBuffer(void *args)
 
     init_conversion_context(ctx);
     pRegions_host = convert_VkBufferCopy_array_win32_to_host(ctx, (const VkBufferCopy32 *)UlongToPtr(params->pRegions), params->regionCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyBuffer(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcBuffer, params->dstBuffer, params->regionCount, pRegions_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyBuffer(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcBuffer, params->dstBuffer, params->regionCount, pRegions_host);
     free_conversion_context(ctx);
 }
 
@@ -43154,7 +42480,7 @@ static void thunk64_vkCmdCopyBuffer2(void *args)
 {
     struct vkCmdCopyBuffer2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyBuffer2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyBufferInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyBuffer2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyBufferInfo);
 }
 #endif /* _WIN64 */
 
@@ -43171,7 +42497,7 @@ static void thunk32_vkCmdCopyBuffer2(void *args)
 
     init_conversion_context(ctx);
     convert_VkCopyBufferInfo2_win32_to_host(ctx, (const VkCopyBufferInfo232 *)UlongToPtr(params->pCopyBufferInfo), &pCopyBufferInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyBuffer2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyBufferInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyBuffer2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyBufferInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -43180,7 +42506,7 @@ static void thunk64_vkCmdCopyBuffer2KHR(void *args)
 {
     struct vkCmdCopyBuffer2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyBuffer2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyBufferInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyBuffer2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyBufferInfo);
 }
 #endif /* _WIN64 */
 
@@ -43197,7 +42523,7 @@ static void thunk32_vkCmdCopyBuffer2KHR(void *args)
 
     init_conversion_context(ctx);
     convert_VkCopyBufferInfo2_win32_to_host(ctx, (const VkCopyBufferInfo232 *)UlongToPtr(params->pCopyBufferInfo), &pCopyBufferInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyBuffer2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyBufferInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyBuffer2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyBufferInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -43206,7 +42532,7 @@ static void thunk64_vkCmdCopyBufferToImage(void *args)
 {
     struct vkCmdCopyBufferToImage_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyBufferToImage(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcBuffer, params->dstImage, params->dstImageLayout, params->regionCount, params->pRegions);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyBufferToImage(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcBuffer, params->dstImage, params->dstImageLayout, params->regionCount, params->pRegions);
 }
 #endif /* _WIN64 */
 
@@ -43227,7 +42553,7 @@ static void thunk32_vkCmdCopyBufferToImage(void *args)
 
     init_conversion_context(ctx);
     pRegions_host = convert_VkBufferImageCopy_array_win32_to_host(ctx, (const VkBufferImageCopy32 *)UlongToPtr(params->pRegions), params->regionCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyBufferToImage(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcBuffer, params->dstImage, params->dstImageLayout, params->regionCount, pRegions_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyBufferToImage(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcBuffer, params->dstImage, params->dstImageLayout, params->regionCount, pRegions_host);
     free_conversion_context(ctx);
 }
 
@@ -43236,7 +42562,7 @@ static void thunk64_vkCmdCopyBufferToImage2(void *args)
 {
     struct vkCmdCopyBufferToImage2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyBufferToImage2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyBufferToImageInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyBufferToImage2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyBufferToImageInfo);
 }
 #endif /* _WIN64 */
 
@@ -43253,7 +42579,7 @@ static void thunk32_vkCmdCopyBufferToImage2(void *args)
 
     init_conversion_context(ctx);
     convert_VkCopyBufferToImageInfo2_win32_to_host(ctx, (const VkCopyBufferToImageInfo232 *)UlongToPtr(params->pCopyBufferToImageInfo), &pCopyBufferToImageInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyBufferToImage2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyBufferToImageInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyBufferToImage2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyBufferToImageInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -43262,7 +42588,7 @@ static void thunk64_vkCmdCopyBufferToImage2KHR(void *args)
 {
     struct vkCmdCopyBufferToImage2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyBufferToImage2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyBufferToImageInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyBufferToImage2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyBufferToImageInfo);
 }
 #endif /* _WIN64 */
 
@@ -43279,7 +42605,7 @@ static void thunk32_vkCmdCopyBufferToImage2KHR(void *args)
 
     init_conversion_context(ctx);
     convert_VkCopyBufferToImageInfo2_win32_to_host(ctx, (const VkCopyBufferToImageInfo232 *)UlongToPtr(params->pCopyBufferToImageInfo), &pCopyBufferToImageInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyBufferToImage2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyBufferToImageInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyBufferToImage2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyBufferToImageInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -43288,7 +42614,7 @@ static void thunk64_vkCmdCopyImage(void *args)
 {
     struct vkCmdCopyImage_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyImage(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, params->pRegions);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyImage(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, params->pRegions);
 }
 #endif /* _WIN64 */
 
@@ -43305,7 +42631,7 @@ static void thunk32_vkCmdCopyImage(void *args)
         PTR32 pRegions;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyImage(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, (const VkImageCopy *)UlongToPtr(params->pRegions));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyImage(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, (const VkImageCopy *)UlongToPtr(params->pRegions));
 }
 
 #ifdef _WIN64
@@ -43313,7 +42639,7 @@ static void thunk64_vkCmdCopyImage2(void *args)
 {
     struct vkCmdCopyImage2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyImage2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyImageInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyImage2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyImageInfo);
 }
 #endif /* _WIN64 */
 
@@ -43330,7 +42656,7 @@ static void thunk32_vkCmdCopyImage2(void *args)
 
     init_conversion_context(ctx);
     convert_VkCopyImageInfo2_win32_to_host(ctx, (const VkCopyImageInfo232 *)UlongToPtr(params->pCopyImageInfo), &pCopyImageInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyImage2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyImageInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyImage2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyImageInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -43339,7 +42665,7 @@ static void thunk64_vkCmdCopyImage2KHR(void *args)
 {
     struct vkCmdCopyImage2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyImage2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyImageInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyImage2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyImageInfo);
 }
 #endif /* _WIN64 */
 
@@ -43356,7 +42682,7 @@ static void thunk32_vkCmdCopyImage2KHR(void *args)
 
     init_conversion_context(ctx);
     convert_VkCopyImageInfo2_win32_to_host(ctx, (const VkCopyImageInfo232 *)UlongToPtr(params->pCopyImageInfo), &pCopyImageInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyImage2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyImageInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyImage2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyImageInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -43365,7 +42691,7 @@ static void thunk64_vkCmdCopyImageToBuffer(void *args)
 {
     struct vkCmdCopyImageToBuffer_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyImageToBuffer(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstBuffer, params->regionCount, params->pRegions);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyImageToBuffer(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstBuffer, params->regionCount, params->pRegions);
 }
 #endif /* _WIN64 */
 
@@ -43386,7 +42712,7 @@ static void thunk32_vkCmdCopyImageToBuffer(void *args)
 
     init_conversion_context(ctx);
     pRegions_host = convert_VkBufferImageCopy_array_win32_to_host(ctx, (const VkBufferImageCopy32 *)UlongToPtr(params->pRegions), params->regionCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyImageToBuffer(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstBuffer, params->regionCount, pRegions_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyImageToBuffer(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstBuffer, params->regionCount, pRegions_host);
     free_conversion_context(ctx);
 }
 
@@ -43395,7 +42721,7 @@ static void thunk64_vkCmdCopyImageToBuffer2(void *args)
 {
     struct vkCmdCopyImageToBuffer2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyImageToBuffer2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyImageToBufferInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyImageToBuffer2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyImageToBufferInfo);
 }
 #endif /* _WIN64 */
 
@@ -43412,7 +42738,7 @@ static void thunk32_vkCmdCopyImageToBuffer2(void *args)
 
     init_conversion_context(ctx);
     convert_VkCopyImageToBufferInfo2_win32_to_host(ctx, (const VkCopyImageToBufferInfo232 *)UlongToPtr(params->pCopyImageToBufferInfo), &pCopyImageToBufferInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyImageToBuffer2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyImageToBufferInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyImageToBuffer2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyImageToBufferInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -43421,7 +42747,7 @@ static void thunk64_vkCmdCopyImageToBuffer2KHR(void *args)
 {
     struct vkCmdCopyImageToBuffer2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyImageToBuffer2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyImageToBufferInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyImageToBuffer2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyImageToBufferInfo);
 }
 #endif /* _WIN64 */
 
@@ -43438,7 +42764,7 @@ static void thunk32_vkCmdCopyImageToBuffer2KHR(void *args)
 
     init_conversion_context(ctx);
     convert_VkCopyImageToBufferInfo2_win32_to_host(ctx, (const VkCopyImageToBufferInfo232 *)UlongToPtr(params->pCopyImageToBufferInfo), &pCopyImageToBufferInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyImageToBuffer2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyImageToBufferInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyImageToBuffer2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyImageToBufferInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -43447,7 +42773,7 @@ static void thunk64_vkCmdCopyMemoryIndirectNV(void *args)
 {
     struct vkCmdCopyMemoryIndirectNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMemoryIndirectNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->copyBufferAddress, params->copyCount, params->stride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMemoryIndirectNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->copyBufferAddress, params->copyCount, params->stride);
 }
 #endif /* _WIN64 */
 
@@ -43461,7 +42787,7 @@ static void thunk32_vkCmdCopyMemoryIndirectNV(void *args)
         uint32_t stride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMemoryIndirectNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->copyBufferAddress, params->copyCount, params->stride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMemoryIndirectNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->copyBufferAddress, params->copyCount, params->stride);
 }
 
 #ifdef _WIN64
@@ -43469,7 +42795,7 @@ static void thunk64_vkCmdCopyMemoryToAccelerationStructureKHR(void *args)
 {
     struct vkCmdCopyMemoryToAccelerationStructureKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMemoryToAccelerationStructureKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMemoryToAccelerationStructureKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo);
 }
 #endif /* _WIN64 */
 
@@ -43483,7 +42809,7 @@ static void thunk32_vkCmdCopyMemoryToAccelerationStructureKHR(void *args)
     VkCopyMemoryToAccelerationStructureInfoKHR pInfo_host;
 
     convert_VkCopyMemoryToAccelerationStructureInfoKHR_win32_to_host((const VkCopyMemoryToAccelerationStructureInfoKHR32 *)UlongToPtr(params->pInfo), &pInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMemoryToAccelerationStructureKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMemoryToAccelerationStructureKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host);
 }
 
 #ifdef _WIN64
@@ -43491,7 +42817,7 @@ static void thunk64_vkCmdCopyMemoryToImageIndirectNV(void *args)
 {
     struct vkCmdCopyMemoryToImageIndirectNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMemoryToImageIndirectNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->copyBufferAddress, params->copyCount, params->stride, params->dstImage, params->dstImageLayout, params->pImageSubresources);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMemoryToImageIndirectNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->copyBufferAddress, params->copyCount, params->stride, params->dstImage, params->dstImageLayout, params->pImageSubresources);
 }
 #endif /* _WIN64 */
 
@@ -43508,7 +42834,7 @@ static void thunk32_vkCmdCopyMemoryToImageIndirectNV(void *args)
         PTR32 pImageSubresources;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMemoryToImageIndirectNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->copyBufferAddress, params->copyCount, params->stride, params->dstImage, params->dstImageLayout, (const VkImageSubresourceLayers *)UlongToPtr(params->pImageSubresources));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMemoryToImageIndirectNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->copyBufferAddress, params->copyCount, params->stride, params->dstImage, params->dstImageLayout, (const VkImageSubresourceLayers *)UlongToPtr(params->pImageSubresources));
 }
 
 #ifdef _WIN64
@@ -43516,7 +42842,7 @@ static void thunk64_vkCmdCopyMemoryToMicromapEXT(void *args)
 {
     struct vkCmdCopyMemoryToMicromapEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMemoryToMicromapEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMemoryToMicromapEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo);
 }
 #endif /* _WIN64 */
 
@@ -43530,7 +42856,7 @@ static void thunk32_vkCmdCopyMemoryToMicromapEXT(void *args)
     VkCopyMemoryToMicromapInfoEXT pInfo_host;
 
     convert_VkCopyMemoryToMicromapInfoEXT_win32_to_host((const VkCopyMemoryToMicromapInfoEXT32 *)UlongToPtr(params->pInfo), &pInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMemoryToMicromapEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMemoryToMicromapEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host);
 }
 
 #ifdef _WIN64
@@ -43538,7 +42864,7 @@ static void thunk64_vkCmdCopyMicromapEXT(void *args)
 {
     struct vkCmdCopyMicromapEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMicromapEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMicromapEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo);
 }
 #endif /* _WIN64 */
 
@@ -43552,7 +42878,7 @@ static void thunk32_vkCmdCopyMicromapEXT(void *args)
     VkCopyMicromapInfoEXT pInfo_host;
 
     convert_VkCopyMicromapInfoEXT_win32_to_host((const VkCopyMicromapInfoEXT32 *)UlongToPtr(params->pInfo), &pInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMicromapEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMicromapEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host);
 }
 
 #ifdef _WIN64
@@ -43560,7 +42886,7 @@ static void thunk64_vkCmdCopyMicromapToMemoryEXT(void *args)
 {
     struct vkCmdCopyMicromapToMemoryEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMicromapToMemoryEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMicromapToMemoryEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo);
 }
 #endif /* _WIN64 */
 
@@ -43574,7 +42900,7 @@ static void thunk32_vkCmdCopyMicromapToMemoryEXT(void *args)
     VkCopyMicromapToMemoryInfoEXT pInfo_host;
 
     convert_VkCopyMicromapToMemoryInfoEXT_win32_to_host((const VkCopyMicromapToMemoryInfoEXT32 *)UlongToPtr(params->pInfo), &pInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMicromapToMemoryEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMicromapToMemoryEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host);
 }
 
 #ifdef _WIN64
@@ -43582,7 +42908,7 @@ static void thunk64_vkCmdCopyQueryPoolResults(void *args)
 {
     struct vkCmdCopyQueryPoolResults_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyQueryPoolResults(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->queryPool, params->firstQuery, params->queryCount, params->dstBuffer, params->dstOffset, params->stride, params->flags);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyQueryPoolResults(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->queryPool, params->firstQuery, params->queryCount, params->dstBuffer, params->dstOffset, params->stride, params->flags);
 }
 #endif /* _WIN64 */
 
@@ -43600,7 +42926,7 @@ static void thunk32_vkCmdCopyQueryPoolResults(void *args)
         VkQueryResultFlags flags;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyQueryPoolResults(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->queryPool, params->firstQuery, params->queryCount, params->dstBuffer, params->dstOffset, params->stride, params->flags);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyQueryPoolResults(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->queryPool, params->firstQuery, params->queryCount, params->dstBuffer, params->dstOffset, params->stride, params->flags);
 }
 
 #ifdef _WIN64
@@ -43608,7 +42934,7 @@ static void thunk64_vkCmdCopyTensorARM(void *args)
 {
     struct vkCmdCopyTensorARM_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyTensorARM(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyTensorInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyTensorARM(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyTensorInfo);
 }
 #endif /* _WIN64 */
 
@@ -43625,7 +42951,7 @@ static void thunk32_vkCmdCopyTensorARM(void *args)
 
     init_conversion_context(ctx);
     convert_VkCopyTensorInfoARM_win32_to_host(ctx, (const VkCopyTensorInfoARM32 *)UlongToPtr(params->pCopyTensorInfo), &pCopyTensorInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyTensorARM(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyTensorInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyTensorARM(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyTensorInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -43634,7 +42960,7 @@ static void thunk64_vkCmdCuLaunchKernelNVX(void *args)
 {
     struct vkCmdCuLaunchKernelNVX_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCuLaunchKernelNVX(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pLaunchInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCuLaunchKernelNVX(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pLaunchInfo);
 }
 #endif /* _WIN64 */
 
@@ -43648,7 +42974,7 @@ static void thunk32_vkCmdCuLaunchKernelNVX(void *args)
     VkCuLaunchInfoNVX pLaunchInfo_host;
 
     convert_VkCuLaunchInfoNVX_win32_to_host((const VkCuLaunchInfoNVX32 *)UlongToPtr(params->pLaunchInfo), &pLaunchInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCuLaunchKernelNVX(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pLaunchInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCuLaunchKernelNVX(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pLaunchInfo_host);
 }
 
 #ifdef _WIN64
@@ -43656,7 +42982,7 @@ static void thunk64_vkCmdDebugMarkerBeginEXT(void *args)
 {
     struct vkCmdDebugMarkerBeginEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDebugMarkerBeginEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pMarkerInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDebugMarkerBeginEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pMarkerInfo);
 }
 #endif /* _WIN64 */
 
@@ -43670,7 +42996,7 @@ static void thunk32_vkCmdDebugMarkerBeginEXT(void *args)
     VkDebugMarkerMarkerInfoEXT pMarkerInfo_host;
 
     convert_VkDebugMarkerMarkerInfoEXT_win32_to_host((const VkDebugMarkerMarkerInfoEXT32 *)UlongToPtr(params->pMarkerInfo), &pMarkerInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDebugMarkerBeginEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pMarkerInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDebugMarkerBeginEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pMarkerInfo_host);
 }
 
 #ifdef _WIN64
@@ -43678,7 +43004,7 @@ static void thunk64_vkCmdDebugMarkerEndEXT(void *args)
 {
     struct vkCmdDebugMarkerEndEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDebugMarkerEndEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDebugMarkerEndEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer);
 }
 #endif /* _WIN64 */
 
@@ -43689,7 +43015,7 @@ static void thunk32_vkCmdDebugMarkerEndEXT(void *args)
         PTR32 commandBuffer;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDebugMarkerEndEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDebugMarkerEndEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
 }
 
 #ifdef _WIN64
@@ -43697,7 +43023,7 @@ static void thunk64_vkCmdDebugMarkerInsertEXT(void *args)
 {
     struct vkCmdDebugMarkerInsertEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDebugMarkerInsertEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pMarkerInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDebugMarkerInsertEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pMarkerInfo);
 }
 #endif /* _WIN64 */
 
@@ -43711,7 +43037,7 @@ static void thunk32_vkCmdDebugMarkerInsertEXT(void *args)
     VkDebugMarkerMarkerInfoEXT pMarkerInfo_host;
 
     convert_VkDebugMarkerMarkerInfoEXT_win32_to_host((const VkDebugMarkerMarkerInfoEXT32 *)UlongToPtr(params->pMarkerInfo), &pMarkerInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDebugMarkerInsertEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pMarkerInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDebugMarkerInsertEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pMarkerInfo_host);
 }
 
 #ifdef _WIN64
@@ -43719,7 +43045,7 @@ static void thunk64_vkCmdDecodeVideoKHR(void *args)
 {
     struct vkCmdDecodeVideoKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDecodeVideoKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pDecodeInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDecodeVideoKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pDecodeInfo);
 }
 #endif /* _WIN64 */
 
@@ -43736,7 +43062,7 @@ static void thunk32_vkCmdDecodeVideoKHR(void *args)
 
     init_conversion_context(ctx);
     convert_VkVideoDecodeInfoKHR_win32_to_host(ctx, (const VkVideoDecodeInfoKHR32 *)UlongToPtr(params->pDecodeInfo), &pDecodeInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDecodeVideoKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pDecodeInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDecodeVideoKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pDecodeInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -43745,7 +43071,7 @@ static void thunk64_vkCmdDecompressMemoryIndirectCountNV(void *args)
 {
     struct vkCmdDecompressMemoryIndirectCountNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDecompressMemoryIndirectCountNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->indirectCommandsAddress, params->indirectCommandsCountAddress, params->stride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDecompressMemoryIndirectCountNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->indirectCommandsAddress, params->indirectCommandsCountAddress, params->stride);
 }
 #endif /* _WIN64 */
 
@@ -43759,7 +43085,7 @@ static void thunk32_vkCmdDecompressMemoryIndirectCountNV(void *args)
         uint32_t stride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDecompressMemoryIndirectCountNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->indirectCommandsAddress, params->indirectCommandsCountAddress, params->stride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDecompressMemoryIndirectCountNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->indirectCommandsAddress, params->indirectCommandsCountAddress, params->stride);
 }
 
 #ifdef _WIN64
@@ -43767,7 +43093,7 @@ static void thunk64_vkCmdDecompressMemoryNV(void *args)
 {
     struct vkCmdDecompressMemoryNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDecompressMemoryNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->decompressRegionCount, params->pDecompressMemoryRegions);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDecompressMemoryNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->decompressRegionCount, params->pDecompressMemoryRegions);
 }
 #endif /* _WIN64 */
 
@@ -43785,7 +43111,7 @@ static void thunk32_vkCmdDecompressMemoryNV(void *args)
 
     init_conversion_context(ctx);
     pDecompressMemoryRegions_host = convert_VkDecompressMemoryRegionNV_array_win32_to_host(ctx, (const VkDecompressMemoryRegionNV32 *)UlongToPtr(params->pDecompressMemoryRegions), params->decompressRegionCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDecompressMemoryNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->decompressRegionCount, pDecompressMemoryRegions_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDecompressMemoryNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->decompressRegionCount, pDecompressMemoryRegions_host);
     free_conversion_context(ctx);
 }
 
@@ -43794,7 +43120,7 @@ static void thunk64_vkCmdDispatch(void *args)
 {
     struct vkCmdDispatch_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDispatch(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDispatch(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
 }
 #endif /* _WIN64 */
 
@@ -43808,7 +43134,7 @@ static void thunk32_vkCmdDispatch(void *args)
         uint32_t groupCountZ;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDispatch(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDispatch(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
 }
 
 #ifdef _WIN64
@@ -43816,7 +43142,7 @@ static void thunk64_vkCmdDispatchBase(void *args)
 {
     struct vkCmdDispatchBase_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDispatchBase(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->baseGroupX, params->baseGroupY, params->baseGroupZ, params->groupCountX, params->groupCountY, params->groupCountZ);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDispatchBase(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->baseGroupX, params->baseGroupY, params->baseGroupZ, params->groupCountX, params->groupCountY, params->groupCountZ);
 }
 #endif /* _WIN64 */
 
@@ -43833,7 +43159,7 @@ static void thunk32_vkCmdDispatchBase(void *args)
         uint32_t groupCountZ;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDispatchBase(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->baseGroupX, params->baseGroupY, params->baseGroupZ, params->groupCountX, params->groupCountY, params->groupCountZ);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDispatchBase(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->baseGroupX, params->baseGroupY, params->baseGroupZ, params->groupCountX, params->groupCountY, params->groupCountZ);
 }
 
 #ifdef _WIN64
@@ -43841,7 +43167,7 @@ static void thunk64_vkCmdDispatchBaseKHR(void *args)
 {
     struct vkCmdDispatchBaseKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDispatchBaseKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->baseGroupX, params->baseGroupY, params->baseGroupZ, params->groupCountX, params->groupCountY, params->groupCountZ);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDispatchBaseKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->baseGroupX, params->baseGroupY, params->baseGroupZ, params->groupCountX, params->groupCountY, params->groupCountZ);
 }
 #endif /* _WIN64 */
 
@@ -43858,7 +43184,7 @@ static void thunk32_vkCmdDispatchBaseKHR(void *args)
         uint32_t groupCountZ;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDispatchBaseKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->baseGroupX, params->baseGroupY, params->baseGroupZ, params->groupCountX, params->groupCountY, params->groupCountZ);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDispatchBaseKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->baseGroupX, params->baseGroupY, params->baseGroupZ, params->groupCountX, params->groupCountY, params->groupCountZ);
 }
 
 #ifdef _WIN64
@@ -43866,7 +43192,7 @@ static void thunk64_vkCmdDispatchDataGraphARM(void *args)
 {
     struct vkCmdDispatchDataGraphARM_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDispatchDataGraphARM(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->session, params->pInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDispatchDataGraphARM(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->session, params->pInfo);
 }
 #endif /* _WIN64 */
 
@@ -43888,7 +43214,7 @@ static void thunk32_vkCmdDispatchDataGraphARM(void *args)
         pInfo_host = conversion_context_alloc(ctx, sizeof(*pInfo_host));
         convert_VkDataGraphPipelineDispatchInfoARM_win32_to_host((const VkDataGraphPipelineDispatchInfoARM32 *)UlongToPtr(params->pInfo), pInfo_host);
     }
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDispatchDataGraphARM(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->session, pInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDispatchDataGraphARM(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->session, pInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -43897,7 +43223,7 @@ static void thunk64_vkCmdDispatchIndirect(void *args)
 {
     struct vkCmdDispatchIndirect_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDispatchIndirect(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDispatchIndirect(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset);
 }
 #endif /* _WIN64 */
 
@@ -43910,7 +43236,7 @@ static void thunk32_vkCmdDispatchIndirect(void *args)
         VkDeviceSize DECLSPEC_ALIGN(8) offset;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDispatchIndirect(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDispatchIndirect(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset);
 }
 
 #ifdef _WIN64
@@ -43918,7 +43244,7 @@ static void thunk64_vkCmdDispatchTileQCOM(void *args)
 {
     struct vkCmdDispatchTileQCOM_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDispatchTileQCOM(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pDispatchTileInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDispatchTileQCOM(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pDispatchTileInfo);
 }
 #endif /* _WIN64 */
 
@@ -43932,7 +43258,7 @@ static void thunk32_vkCmdDispatchTileQCOM(void *args)
     VkDispatchTileInfoQCOM pDispatchTileInfo_host;
 
     convert_VkDispatchTileInfoQCOM_win32_to_host((const VkDispatchTileInfoQCOM32 *)UlongToPtr(params->pDispatchTileInfo), &pDispatchTileInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDispatchTileQCOM(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pDispatchTileInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDispatchTileQCOM(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pDispatchTileInfo_host);
 }
 
 #ifdef _WIN64
@@ -43940,7 +43266,7 @@ static void thunk64_vkCmdDraw(void *args)
 {
     struct vkCmdDraw_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDraw(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->vertexCount, params->instanceCount, params->firstVertex, params->firstInstance);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDraw(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->vertexCount, params->instanceCount, params->firstVertex, params->firstInstance);
 }
 #endif /* _WIN64 */
 
@@ -43955,7 +43281,7 @@ static void thunk32_vkCmdDraw(void *args)
         uint32_t firstInstance;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDraw(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->vertexCount, params->instanceCount, params->firstVertex, params->firstInstance);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDraw(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->vertexCount, params->instanceCount, params->firstVertex, params->firstInstance);
 }
 
 #ifdef _WIN64
@@ -43963,7 +43289,7 @@ static void thunk64_vkCmdDrawClusterHUAWEI(void *args)
 {
     struct vkCmdDrawClusterHUAWEI_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawClusterHUAWEI(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawClusterHUAWEI(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
 }
 #endif /* _WIN64 */
 
@@ -43977,7 +43303,7 @@ static void thunk32_vkCmdDrawClusterHUAWEI(void *args)
         uint32_t groupCountZ;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawClusterHUAWEI(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawClusterHUAWEI(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
 }
 
 #ifdef _WIN64
@@ -43985,7 +43311,7 @@ static void thunk64_vkCmdDrawClusterIndirectHUAWEI(void *args)
 {
     struct vkCmdDrawClusterIndirectHUAWEI_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawClusterIndirectHUAWEI(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawClusterIndirectHUAWEI(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset);
 }
 #endif /* _WIN64 */
 
@@ -43998,7 +43324,7 @@ static void thunk32_vkCmdDrawClusterIndirectHUAWEI(void *args)
         VkDeviceSize DECLSPEC_ALIGN(8) offset;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawClusterIndirectHUAWEI(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawClusterIndirectHUAWEI(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset);
 }
 
 #ifdef _WIN64
@@ -44006,7 +43332,7 @@ static void thunk64_vkCmdDrawIndexed(void *args)
 {
     struct vkCmdDrawIndexed_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndexed(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->indexCount, params->instanceCount, params->firstIndex, params->vertexOffset, params->firstInstance);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndexed(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->indexCount, params->instanceCount, params->firstIndex, params->vertexOffset, params->firstInstance);
 }
 #endif /* _WIN64 */
 
@@ -44022,7 +43348,7 @@ static void thunk32_vkCmdDrawIndexed(void *args)
         uint32_t firstInstance;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndexed(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->indexCount, params->instanceCount, params->firstIndex, params->vertexOffset, params->firstInstance);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndexed(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->indexCount, params->instanceCount, params->firstIndex, params->vertexOffset, params->firstInstance);
 }
 
 #ifdef _WIN64
@@ -44030,7 +43356,7 @@ static void thunk64_vkCmdDrawIndexedIndirect(void *args)
 {
     struct vkCmdDrawIndexedIndirect_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndexedIndirect(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndexedIndirect(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
 }
 #endif /* _WIN64 */
 
@@ -44045,7 +43371,7 @@ static void thunk32_vkCmdDrawIndexedIndirect(void *args)
         uint32_t stride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndexedIndirect(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndexedIndirect(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
 }
 
 #ifdef _WIN64
@@ -44053,7 +43379,7 @@ static void thunk64_vkCmdDrawIndexedIndirectCount(void *args)
 {
     struct vkCmdDrawIndexedIndirectCount_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndexedIndirectCount(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndexedIndirectCount(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 #endif /* _WIN64 */
 
@@ -44070,7 +43396,7 @@ static void thunk32_vkCmdDrawIndexedIndirectCount(void *args)
         uint32_t stride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndexedIndirectCount(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndexedIndirectCount(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 
 #ifdef _WIN64
@@ -44078,7 +43404,7 @@ static void thunk64_vkCmdDrawIndexedIndirectCountAMD(void *args)
 {
     struct vkCmdDrawIndexedIndirectCountAMD_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndexedIndirectCountAMD(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndexedIndirectCountAMD(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 #endif /* _WIN64 */
 
@@ -44095,7 +43421,7 @@ static void thunk32_vkCmdDrawIndexedIndirectCountAMD(void *args)
         uint32_t stride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndexedIndirectCountAMD(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndexedIndirectCountAMD(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 
 #ifdef _WIN64
@@ -44103,7 +43429,7 @@ static void thunk64_vkCmdDrawIndexedIndirectCountKHR(void *args)
 {
     struct vkCmdDrawIndexedIndirectCountKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndexedIndirectCountKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndexedIndirectCountKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 #endif /* _WIN64 */
 
@@ -44120,7 +43446,7 @@ static void thunk32_vkCmdDrawIndexedIndirectCountKHR(void *args)
         uint32_t stride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndexedIndirectCountKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndexedIndirectCountKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 
 #ifdef _WIN64
@@ -44128,7 +43454,7 @@ static void thunk64_vkCmdDrawIndirect(void *args)
 {
     struct vkCmdDrawIndirect_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndirect(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndirect(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
 }
 #endif /* _WIN64 */
 
@@ -44143,7 +43469,7 @@ static void thunk32_vkCmdDrawIndirect(void *args)
         uint32_t stride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndirect(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndirect(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
 }
 
 #ifdef _WIN64
@@ -44151,7 +43477,7 @@ static void thunk64_vkCmdDrawIndirectByteCountEXT(void *args)
 {
     struct vkCmdDrawIndirectByteCountEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndirectByteCountEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->instanceCount, params->firstInstance, params->counterBuffer, params->counterBufferOffset, params->counterOffset, params->vertexStride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndirectByteCountEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->instanceCount, params->firstInstance, params->counterBuffer, params->counterBufferOffset, params->counterOffset, params->vertexStride);
 }
 #endif /* _WIN64 */
 
@@ -44168,7 +43494,7 @@ static void thunk32_vkCmdDrawIndirectByteCountEXT(void *args)
         uint32_t vertexStride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndirectByteCountEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->instanceCount, params->firstInstance, params->counterBuffer, params->counterBufferOffset, params->counterOffset, params->vertexStride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndirectByteCountEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->instanceCount, params->firstInstance, params->counterBuffer, params->counterBufferOffset, params->counterOffset, params->vertexStride);
 }
 
 #ifdef _WIN64
@@ -44176,7 +43502,7 @@ static void thunk64_vkCmdDrawIndirectCount(void *args)
 {
     struct vkCmdDrawIndirectCount_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndirectCount(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndirectCount(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 #endif /* _WIN64 */
 
@@ -44193,7 +43519,7 @@ static void thunk32_vkCmdDrawIndirectCount(void *args)
         uint32_t stride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndirectCount(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndirectCount(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 
 #ifdef _WIN64
@@ -44201,7 +43527,7 @@ static void thunk64_vkCmdDrawIndirectCountAMD(void *args)
 {
     struct vkCmdDrawIndirectCountAMD_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndirectCountAMD(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndirectCountAMD(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 #endif /* _WIN64 */
 
@@ -44218,7 +43544,7 @@ static void thunk32_vkCmdDrawIndirectCountAMD(void *args)
         uint32_t stride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndirectCountAMD(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndirectCountAMD(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 
 #ifdef _WIN64
@@ -44226,7 +43552,7 @@ static void thunk64_vkCmdDrawIndirectCountKHR(void *args)
 {
     struct vkCmdDrawIndirectCountKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndirectCountKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndirectCountKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 #endif /* _WIN64 */
 
@@ -44243,7 +43569,7 @@ static void thunk32_vkCmdDrawIndirectCountKHR(void *args)
         uint32_t stride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndirectCountKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndirectCountKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 
 #ifdef _WIN64
@@ -44251,7 +43577,7 @@ static void thunk64_vkCmdDrawMeshTasksEXT(void *args)
 {
     struct vkCmdDrawMeshTasksEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMeshTasksEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMeshTasksEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
 }
 #endif /* _WIN64 */
 
@@ -44265,7 +43591,7 @@ static void thunk32_vkCmdDrawMeshTasksEXT(void *args)
         uint32_t groupCountZ;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMeshTasksEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMeshTasksEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
 }
 
 #ifdef _WIN64
@@ -44273,7 +43599,7 @@ static void thunk64_vkCmdDrawMeshTasksIndirectCountEXT(void *args)
 {
     struct vkCmdDrawMeshTasksIndirectCountEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMeshTasksIndirectCountEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMeshTasksIndirectCountEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 #endif /* _WIN64 */
 
@@ -44290,7 +43616,7 @@ static void thunk32_vkCmdDrawMeshTasksIndirectCountEXT(void *args)
         uint32_t stride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMeshTasksIndirectCountEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMeshTasksIndirectCountEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 
 #ifdef _WIN64
@@ -44298,7 +43624,7 @@ static void thunk64_vkCmdDrawMeshTasksIndirectCountNV(void *args)
 {
     struct vkCmdDrawMeshTasksIndirectCountNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMeshTasksIndirectCountNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMeshTasksIndirectCountNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 #endif /* _WIN64 */
 
@@ -44315,7 +43641,7 @@ static void thunk32_vkCmdDrawMeshTasksIndirectCountNV(void *args)
         uint32_t stride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMeshTasksIndirectCountNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMeshTasksIndirectCountNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 
 #ifdef _WIN64
@@ -44323,7 +43649,7 @@ static void thunk64_vkCmdDrawMeshTasksIndirectEXT(void *args)
 {
     struct vkCmdDrawMeshTasksIndirectEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMeshTasksIndirectEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMeshTasksIndirectEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
 }
 #endif /* _WIN64 */
 
@@ -44338,7 +43664,7 @@ static void thunk32_vkCmdDrawMeshTasksIndirectEXT(void *args)
         uint32_t stride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMeshTasksIndirectEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMeshTasksIndirectEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
 }
 
 #ifdef _WIN64
@@ -44346,7 +43672,7 @@ static void thunk64_vkCmdDrawMeshTasksIndirectNV(void *args)
 {
     struct vkCmdDrawMeshTasksIndirectNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMeshTasksIndirectNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMeshTasksIndirectNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
 }
 #endif /* _WIN64 */
 
@@ -44361,7 +43687,7 @@ static void thunk32_vkCmdDrawMeshTasksIndirectNV(void *args)
         uint32_t stride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMeshTasksIndirectNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMeshTasksIndirectNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
 }
 
 #ifdef _WIN64
@@ -44369,7 +43695,7 @@ static void thunk64_vkCmdDrawMeshTasksNV(void *args)
 {
     struct vkCmdDrawMeshTasksNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMeshTasksNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->taskCount, params->firstTask);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMeshTasksNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->taskCount, params->firstTask);
 }
 #endif /* _WIN64 */
 
@@ -44382,7 +43708,7 @@ static void thunk32_vkCmdDrawMeshTasksNV(void *args)
         uint32_t firstTask;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMeshTasksNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->taskCount, params->firstTask);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMeshTasksNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->taskCount, params->firstTask);
 }
 
 #ifdef _WIN64
@@ -44390,7 +43716,7 @@ static void thunk64_vkCmdDrawMultiEXT(void *args)
 {
     struct vkCmdDrawMultiEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMultiEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->drawCount, params->pVertexInfo, params->instanceCount, params->firstInstance, params->stride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMultiEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->drawCount, params->pVertexInfo, params->instanceCount, params->firstInstance, params->stride);
 }
 #endif /* _WIN64 */
 
@@ -44406,7 +43732,7 @@ static void thunk32_vkCmdDrawMultiEXT(void *args)
         uint32_t stride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMultiEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->drawCount, (const VkMultiDrawInfoEXT *)UlongToPtr(params->pVertexInfo), params->instanceCount, params->firstInstance, params->stride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMultiEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->drawCount, (const VkMultiDrawInfoEXT *)UlongToPtr(params->pVertexInfo), params->instanceCount, params->firstInstance, params->stride);
 }
 
 #ifdef _WIN64
@@ -44414,7 +43740,7 @@ static void thunk64_vkCmdDrawMultiIndexedEXT(void *args)
 {
     struct vkCmdDrawMultiIndexedEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMultiIndexedEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->drawCount, params->pIndexInfo, params->instanceCount, params->firstInstance, params->stride, params->pVertexOffset);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMultiIndexedEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->drawCount, params->pIndexInfo, params->instanceCount, params->firstInstance, params->stride, params->pVertexOffset);
 }
 #endif /* _WIN64 */
 
@@ -44431,7 +43757,7 @@ static void thunk32_vkCmdDrawMultiIndexedEXT(void *args)
         PTR32 pVertexOffset;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMultiIndexedEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->drawCount, (const VkMultiDrawIndexedInfoEXT *)UlongToPtr(params->pIndexInfo), params->instanceCount, params->firstInstance, params->stride, (const int32_t *)UlongToPtr(params->pVertexOffset));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMultiIndexedEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->drawCount, (const VkMultiDrawIndexedInfoEXT *)UlongToPtr(params->pIndexInfo), params->instanceCount, params->firstInstance, params->stride, (const int32_t *)UlongToPtr(params->pVertexOffset));
 }
 
 #ifdef _WIN64
@@ -44439,7 +43765,7 @@ static void thunk64_vkCmdEncodeVideoKHR(void *args)
 {
     struct vkCmdEncodeVideoKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEncodeVideoKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pEncodeInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEncodeVideoKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pEncodeInfo);
 }
 #endif /* _WIN64 */
 
@@ -44456,7 +43782,7 @@ static void thunk32_vkCmdEncodeVideoKHR(void *args)
 
     init_conversion_context(ctx);
     convert_VkVideoEncodeInfoKHR_win32_to_host(ctx, (const VkVideoEncodeInfoKHR32 *)UlongToPtr(params->pEncodeInfo), &pEncodeInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEncodeVideoKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pEncodeInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEncodeVideoKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pEncodeInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -44465,7 +43791,7 @@ static void thunk64_vkCmdEndConditionalRenderingEXT(void *args)
 {
     struct vkCmdEndConditionalRenderingEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndConditionalRenderingEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndConditionalRenderingEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer);
 }
 #endif /* _WIN64 */
 
@@ -44476,7 +43802,7 @@ static void thunk32_vkCmdEndConditionalRenderingEXT(void *args)
         PTR32 commandBuffer;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndConditionalRenderingEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndConditionalRenderingEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
 }
 
 #ifdef _WIN64
@@ -44484,7 +43810,7 @@ static void thunk64_vkCmdEndDebugUtilsLabelEXT(void *args)
 {
     struct vkCmdEndDebugUtilsLabelEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndDebugUtilsLabelEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndDebugUtilsLabelEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer);
 }
 #endif /* _WIN64 */
 
@@ -44495,7 +43821,7 @@ static void thunk32_vkCmdEndDebugUtilsLabelEXT(void *args)
         PTR32 commandBuffer;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndDebugUtilsLabelEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndDebugUtilsLabelEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
 }
 
 #ifdef _WIN64
@@ -44503,7 +43829,7 @@ static void thunk64_vkCmdEndPerTileExecutionQCOM(void *args)
 {
     struct vkCmdEndPerTileExecutionQCOM_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndPerTileExecutionQCOM(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPerTileEndInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndPerTileExecutionQCOM(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPerTileEndInfo);
 }
 #endif /* _WIN64 */
 
@@ -44517,7 +43843,7 @@ static void thunk32_vkCmdEndPerTileExecutionQCOM(void *args)
     VkPerTileEndInfoQCOM pPerTileEndInfo_host;
 
     convert_VkPerTileEndInfoQCOM_win32_to_host((const VkPerTileEndInfoQCOM32 *)UlongToPtr(params->pPerTileEndInfo), &pPerTileEndInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndPerTileExecutionQCOM(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPerTileEndInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndPerTileExecutionQCOM(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPerTileEndInfo_host);
 }
 
 #ifdef _WIN64
@@ -44525,7 +43851,7 @@ static void thunk64_vkCmdEndQuery(void *args)
 {
     struct vkCmdEndQuery_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndQuery(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->queryPool, params->query);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndQuery(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->queryPool, params->query);
 }
 #endif /* _WIN64 */
 
@@ -44538,7 +43864,7 @@ static void thunk32_vkCmdEndQuery(void *args)
         uint32_t query;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndQuery(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->queryPool, params->query);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndQuery(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->queryPool, params->query);
 }
 
 #ifdef _WIN64
@@ -44546,7 +43872,7 @@ static void thunk64_vkCmdEndQueryIndexedEXT(void *args)
 {
     struct vkCmdEndQueryIndexedEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndQueryIndexedEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->queryPool, params->query, params->index);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndQueryIndexedEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->queryPool, params->query, params->index);
 }
 #endif /* _WIN64 */
 
@@ -44560,7 +43886,7 @@ static void thunk32_vkCmdEndQueryIndexedEXT(void *args)
         uint32_t index;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndQueryIndexedEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->queryPool, params->query, params->index);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndQueryIndexedEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->queryPool, params->query, params->index);
 }
 
 #ifdef _WIN64
@@ -44568,7 +43894,7 @@ static void thunk64_vkCmdEndRenderPass(void *args)
 {
     struct vkCmdEndRenderPass_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndRenderPass(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndRenderPass(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer);
 }
 #endif /* _WIN64 */
 
@@ -44579,7 +43905,7 @@ static void thunk32_vkCmdEndRenderPass(void *args)
         PTR32 commandBuffer;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndRenderPass(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndRenderPass(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
 }
 
 #ifdef _WIN64
@@ -44587,7 +43913,7 @@ static void thunk64_vkCmdEndRenderPass2(void *args)
 {
     struct vkCmdEndRenderPass2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndRenderPass2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pSubpassEndInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndRenderPass2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pSubpassEndInfo);
 }
 #endif /* _WIN64 */
 
@@ -44604,7 +43930,7 @@ static void thunk32_vkCmdEndRenderPass2(void *args)
 
     init_conversion_context(ctx);
     convert_VkSubpassEndInfo_win32_to_host(ctx, (const VkSubpassEndInfo32 *)UlongToPtr(params->pSubpassEndInfo), &pSubpassEndInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndRenderPass2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pSubpassEndInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndRenderPass2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pSubpassEndInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -44613,7 +43939,7 @@ static void thunk64_vkCmdEndRenderPass2KHR(void *args)
 {
     struct vkCmdEndRenderPass2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndRenderPass2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pSubpassEndInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndRenderPass2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pSubpassEndInfo);
 }
 #endif /* _WIN64 */
 
@@ -44630,7 +43956,7 @@ static void thunk32_vkCmdEndRenderPass2KHR(void *args)
 
     init_conversion_context(ctx);
     convert_VkSubpassEndInfo_win32_to_host(ctx, (const VkSubpassEndInfo32 *)UlongToPtr(params->pSubpassEndInfo), &pSubpassEndInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndRenderPass2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pSubpassEndInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndRenderPass2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pSubpassEndInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -44639,7 +43965,7 @@ static void thunk64_vkCmdEndRendering(void *args)
 {
     struct vkCmdEndRendering_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndRendering(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndRendering(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer);
 }
 #endif /* _WIN64 */
 
@@ -44650,7 +43976,7 @@ static void thunk32_vkCmdEndRendering(void *args)
         PTR32 commandBuffer;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndRendering(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndRendering(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
 }
 
 #ifdef _WIN64
@@ -44658,7 +43984,7 @@ static void thunk64_vkCmdEndRendering2EXT(void *args)
 {
     struct vkCmdEndRendering2EXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndRendering2EXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRenderingEndInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndRendering2EXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRenderingEndInfo);
 }
 #endif /* _WIN64 */
 
@@ -44679,7 +44005,7 @@ static void thunk32_vkCmdEndRendering2EXT(void *args)
         pRenderingEndInfo_host = conversion_context_alloc(ctx, sizeof(*pRenderingEndInfo_host));
         convert_VkRenderingEndInfoEXT_win32_to_host(ctx, (const VkRenderingEndInfoEXT32 *)UlongToPtr(params->pRenderingEndInfo), pRenderingEndInfo_host);
     }
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndRendering2EXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, pRenderingEndInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndRendering2EXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, pRenderingEndInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -44688,7 +44014,7 @@ static void thunk64_vkCmdEndRenderingKHR(void *args)
 {
     struct vkCmdEndRenderingKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndRenderingKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndRenderingKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer);
 }
 #endif /* _WIN64 */
 
@@ -44699,7 +44025,7 @@ static void thunk32_vkCmdEndRenderingKHR(void *args)
         PTR32 commandBuffer;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndRenderingKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndRenderingKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
 }
 
 #ifdef _WIN64
@@ -44707,7 +44033,7 @@ static void thunk64_vkCmdEndTransformFeedbackEXT(void *args)
 {
     struct vkCmdEndTransformFeedbackEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndTransformFeedbackEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstCounterBuffer, params->counterBufferCount, params->pCounterBuffers, params->pCounterBufferOffsets);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndTransformFeedbackEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstCounterBuffer, params->counterBufferCount, params->pCounterBuffers, params->pCounterBufferOffsets);
 }
 #endif /* _WIN64 */
 
@@ -44722,7 +44048,7 @@ static void thunk32_vkCmdEndTransformFeedbackEXT(void *args)
         PTR32 pCounterBufferOffsets;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndTransformFeedbackEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstCounterBuffer, params->counterBufferCount, (const VkBuffer *)UlongToPtr(params->pCounterBuffers), (const VkDeviceSize *)UlongToPtr(params->pCounterBufferOffsets));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndTransformFeedbackEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstCounterBuffer, params->counterBufferCount, (const VkBuffer *)UlongToPtr(params->pCounterBuffers), (const VkDeviceSize *)UlongToPtr(params->pCounterBufferOffsets));
 }
 
 #ifdef _WIN64
@@ -44730,7 +44056,7 @@ static void thunk64_vkCmdEndVideoCodingKHR(void *args)
 {
     struct vkCmdEndVideoCodingKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndVideoCodingKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pEndCodingInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndVideoCodingKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pEndCodingInfo);
 }
 #endif /* _WIN64 */
 
@@ -44744,7 +44070,7 @@ static void thunk32_vkCmdEndVideoCodingKHR(void *args)
     VkVideoEndCodingInfoKHR pEndCodingInfo_host;
 
     convert_VkVideoEndCodingInfoKHR_win32_to_host((const VkVideoEndCodingInfoKHR32 *)UlongToPtr(params->pEndCodingInfo), &pEndCodingInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndVideoCodingKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pEndCodingInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndVideoCodingKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pEndCodingInfo_host);
 }
 
 #ifdef _WIN64
@@ -44757,7 +44083,7 @@ static void thunk64_vkCmdExecuteCommands(void *args)
 
     init_conversion_context(ctx);
     pCommandBuffers_host = convert_VkCommandBuffer_array_win64_to_host(ctx, params->pCommandBuffers, params->commandBufferCount);
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdExecuteCommands(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->commandBufferCount, pCommandBuffers_host);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdExecuteCommands(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->commandBufferCount, pCommandBuffers_host);
     free_conversion_context(ctx);
 }
 #endif /* _WIN64 */
@@ -44776,7 +44102,7 @@ static void thunk32_vkCmdExecuteCommands(void *args)
 
     init_conversion_context(ctx);
     pCommandBuffers_host = convert_VkCommandBuffer_array_win32_to_host(ctx, (const PTR32 *)UlongToPtr(params->pCommandBuffers), params->commandBufferCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdExecuteCommands(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->commandBufferCount, pCommandBuffers_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdExecuteCommands(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->commandBufferCount, pCommandBuffers_host);
     free_conversion_context(ctx);
 }
 
@@ -44785,7 +44111,7 @@ static void thunk64_vkCmdExecuteGeneratedCommandsEXT(void *args)
 {
     struct vkCmdExecuteGeneratedCommandsEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdExecuteGeneratedCommandsEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->isPreprocessed, params->pGeneratedCommandsInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdExecuteGeneratedCommandsEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->isPreprocessed, params->pGeneratedCommandsInfo);
 }
 #endif /* _WIN64 */
 
@@ -44803,7 +44129,7 @@ static void thunk32_vkCmdExecuteGeneratedCommandsEXT(void *args)
 
     init_conversion_context(ctx);
     convert_VkGeneratedCommandsInfoEXT_win32_to_host(ctx, (const VkGeneratedCommandsInfoEXT32 *)UlongToPtr(params->pGeneratedCommandsInfo), &pGeneratedCommandsInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdExecuteGeneratedCommandsEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->isPreprocessed, &pGeneratedCommandsInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdExecuteGeneratedCommandsEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->isPreprocessed, &pGeneratedCommandsInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -44812,7 +44138,7 @@ static void thunk64_vkCmdExecuteGeneratedCommandsNV(void *args)
 {
     struct vkCmdExecuteGeneratedCommandsNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdExecuteGeneratedCommandsNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->isPreprocessed, params->pGeneratedCommandsInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdExecuteGeneratedCommandsNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->isPreprocessed, params->pGeneratedCommandsInfo);
 }
 #endif /* _WIN64 */
 
@@ -44830,7 +44156,7 @@ static void thunk32_vkCmdExecuteGeneratedCommandsNV(void *args)
 
     init_conversion_context(ctx);
     convert_VkGeneratedCommandsInfoNV_win32_to_host(ctx, (const VkGeneratedCommandsInfoNV32 *)UlongToPtr(params->pGeneratedCommandsInfo), &pGeneratedCommandsInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdExecuteGeneratedCommandsNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->isPreprocessed, &pGeneratedCommandsInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdExecuteGeneratedCommandsNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->isPreprocessed, &pGeneratedCommandsInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -44839,7 +44165,7 @@ static void thunk64_vkCmdFillBuffer(void *args)
 {
     struct vkCmdFillBuffer_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdFillBuffer(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->dstBuffer, params->dstOffset, params->size, params->data);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdFillBuffer(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->dstBuffer, params->dstOffset, params->size, params->data);
 }
 #endif /* _WIN64 */
 
@@ -44854,7 +44180,7 @@ static void thunk32_vkCmdFillBuffer(void *args)
         uint32_t data;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdFillBuffer(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->dstBuffer, params->dstOffset, params->size, params->data);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdFillBuffer(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->dstBuffer, params->dstOffset, params->size, params->data);
 }
 
 #ifdef _WIN64
@@ -44862,7 +44188,7 @@ static void thunk64_vkCmdInsertDebugUtilsLabelEXT(void *args)
 {
     struct vkCmdInsertDebugUtilsLabelEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdInsertDebugUtilsLabelEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pLabelInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdInsertDebugUtilsLabelEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pLabelInfo);
 }
 #endif /* _WIN64 */
 
@@ -44876,7 +44202,7 @@ static void thunk32_vkCmdInsertDebugUtilsLabelEXT(void *args)
     VkDebugUtilsLabelEXT pLabelInfo_host;
 
     convert_VkDebugUtilsLabelEXT_win32_to_host((const VkDebugUtilsLabelEXT32 *)UlongToPtr(params->pLabelInfo), &pLabelInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdInsertDebugUtilsLabelEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pLabelInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdInsertDebugUtilsLabelEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pLabelInfo_host);
 }
 
 #ifdef _WIN64
@@ -44884,7 +44210,7 @@ static void thunk64_vkCmdNextSubpass(void *args)
 {
     struct vkCmdNextSubpass_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdNextSubpass(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->contents);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdNextSubpass(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->contents);
 }
 #endif /* _WIN64 */
 
@@ -44896,7 +44222,7 @@ static void thunk32_vkCmdNextSubpass(void *args)
         VkSubpassContents contents;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdNextSubpass(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->contents);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdNextSubpass(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->contents);
 }
 
 #ifdef _WIN64
@@ -44904,7 +44230,7 @@ static void thunk64_vkCmdNextSubpass2(void *args)
 {
     struct vkCmdNextSubpass2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdNextSubpass2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pSubpassBeginInfo, params->pSubpassEndInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdNextSubpass2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pSubpassBeginInfo, params->pSubpassEndInfo);
 }
 #endif /* _WIN64 */
 
@@ -44924,7 +44250,7 @@ static void thunk32_vkCmdNextSubpass2(void *args)
     init_conversion_context(ctx);
     convert_VkSubpassBeginInfo_win32_to_host((const VkSubpassBeginInfo32 *)UlongToPtr(params->pSubpassBeginInfo), &pSubpassBeginInfo_host);
     convert_VkSubpassEndInfo_win32_to_host(ctx, (const VkSubpassEndInfo32 *)UlongToPtr(params->pSubpassEndInfo), &pSubpassEndInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdNextSubpass2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pSubpassBeginInfo_host, &pSubpassEndInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdNextSubpass2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pSubpassBeginInfo_host, &pSubpassEndInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -44933,7 +44259,7 @@ static void thunk64_vkCmdNextSubpass2KHR(void *args)
 {
     struct vkCmdNextSubpass2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdNextSubpass2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pSubpassBeginInfo, params->pSubpassEndInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdNextSubpass2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pSubpassBeginInfo, params->pSubpassEndInfo);
 }
 #endif /* _WIN64 */
 
@@ -44953,7 +44279,7 @@ static void thunk32_vkCmdNextSubpass2KHR(void *args)
     init_conversion_context(ctx);
     convert_VkSubpassBeginInfo_win32_to_host((const VkSubpassBeginInfo32 *)UlongToPtr(params->pSubpassBeginInfo), &pSubpassBeginInfo_host);
     convert_VkSubpassEndInfo_win32_to_host(ctx, (const VkSubpassEndInfo32 *)UlongToPtr(params->pSubpassEndInfo), &pSubpassEndInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdNextSubpass2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pSubpassBeginInfo_host, &pSubpassEndInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdNextSubpass2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pSubpassBeginInfo_host, &pSubpassEndInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -44962,7 +44288,7 @@ static void thunk64_vkCmdOpticalFlowExecuteNV(void *args)
 {
     struct vkCmdOpticalFlowExecuteNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdOpticalFlowExecuteNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->session, params->pExecuteInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdOpticalFlowExecuteNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->session, params->pExecuteInfo);
 }
 #endif /* _WIN64 */
 
@@ -44977,7 +44303,7 @@ static void thunk32_vkCmdOpticalFlowExecuteNV(void *args)
     VkOpticalFlowExecuteInfoNV pExecuteInfo_host;
 
     convert_VkOpticalFlowExecuteInfoNV_win32_to_host((const VkOpticalFlowExecuteInfoNV32 *)UlongToPtr(params->pExecuteInfo), &pExecuteInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdOpticalFlowExecuteNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->session, &pExecuteInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdOpticalFlowExecuteNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->session, &pExecuteInfo_host);
 }
 
 #ifdef _WIN64
@@ -44985,7 +44311,7 @@ static void thunk64_vkCmdPipelineBarrier(void *args)
 {
     struct vkCmdPipelineBarrier_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPipelineBarrier(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcStageMask, params->dstStageMask, params->dependencyFlags, params->memoryBarrierCount, params->pMemoryBarriers, params->bufferMemoryBarrierCount, params->pBufferMemoryBarriers, params->imageMemoryBarrierCount, params->pImageMemoryBarriers);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPipelineBarrier(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcStageMask, params->dstStageMask, params->dependencyFlags, params->memoryBarrierCount, params->pMemoryBarriers, params->bufferMemoryBarrierCount, params->pBufferMemoryBarriers, params->imageMemoryBarrierCount, params->pImageMemoryBarriers);
 }
 #endif /* _WIN64 */
 
@@ -45014,7 +44340,7 @@ static void thunk32_vkCmdPipelineBarrier(void *args)
     pMemoryBarriers_host = convert_VkMemoryBarrier_array_win32_to_host(ctx, (const VkMemoryBarrier32 *)UlongToPtr(params->pMemoryBarriers), params->memoryBarrierCount);
     pBufferMemoryBarriers_host = convert_VkBufferMemoryBarrier_array_win32_to_host(ctx, (const VkBufferMemoryBarrier32 *)UlongToPtr(params->pBufferMemoryBarriers), params->bufferMemoryBarrierCount);
     pImageMemoryBarriers_host = convert_VkImageMemoryBarrier_array_win32_to_host(ctx, (const VkImageMemoryBarrier32 *)UlongToPtr(params->pImageMemoryBarriers), params->imageMemoryBarrierCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPipelineBarrier(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcStageMask, params->dstStageMask, params->dependencyFlags, params->memoryBarrierCount, pMemoryBarriers_host, params->bufferMemoryBarrierCount, pBufferMemoryBarriers_host, params->imageMemoryBarrierCount, pImageMemoryBarriers_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPipelineBarrier(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcStageMask, params->dstStageMask, params->dependencyFlags, params->memoryBarrierCount, pMemoryBarriers_host, params->bufferMemoryBarrierCount, pBufferMemoryBarriers_host, params->imageMemoryBarrierCount, pImageMemoryBarriers_host);
     free_conversion_context(ctx);
 }
 
@@ -45023,7 +44349,7 @@ static void thunk64_vkCmdPipelineBarrier2(void *args)
 {
     struct vkCmdPipelineBarrier2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPipelineBarrier2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pDependencyInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPipelineBarrier2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pDependencyInfo);
 }
 #endif /* _WIN64 */
 
@@ -45040,7 +44366,7 @@ static void thunk32_vkCmdPipelineBarrier2(void *args)
 
     init_conversion_context(ctx);
     convert_VkDependencyInfo_win32_to_host(ctx, (const VkDependencyInfo32 *)UlongToPtr(params->pDependencyInfo), &pDependencyInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPipelineBarrier2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pDependencyInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPipelineBarrier2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pDependencyInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -45049,7 +44375,7 @@ static void thunk64_vkCmdPipelineBarrier2KHR(void *args)
 {
     struct vkCmdPipelineBarrier2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPipelineBarrier2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pDependencyInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPipelineBarrier2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pDependencyInfo);
 }
 #endif /* _WIN64 */
 
@@ -45066,7 +44392,7 @@ static void thunk32_vkCmdPipelineBarrier2KHR(void *args)
 
     init_conversion_context(ctx);
     convert_VkDependencyInfo_win32_to_host(ctx, (const VkDependencyInfo32 *)UlongToPtr(params->pDependencyInfo), &pDependencyInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPipelineBarrier2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pDependencyInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPipelineBarrier2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pDependencyInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -45075,7 +44401,7 @@ static void thunk64_vkCmdPreprocessGeneratedCommandsEXT(void *args)
 {
     struct vkCmdPreprocessGeneratedCommandsEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPreprocessGeneratedCommandsEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pGeneratedCommandsInfo, vulkan_command_buffer_from_handle(params->stateCommandBuffer)->host.command_buffer);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPreprocessGeneratedCommandsEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pGeneratedCommandsInfo, wine_cmd_buffer_from_handle(params->stateCommandBuffer)->host.command_buffer);
 }
 #endif /* _WIN64 */
 
@@ -45093,7 +44419,7 @@ static void thunk32_vkCmdPreprocessGeneratedCommandsEXT(void *args)
 
     init_conversion_context(ctx);
     convert_VkGeneratedCommandsInfoEXT_win32_to_host(ctx, (const VkGeneratedCommandsInfoEXT32 *)UlongToPtr(params->pGeneratedCommandsInfo), &pGeneratedCommandsInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPreprocessGeneratedCommandsEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pGeneratedCommandsInfo_host, vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->stateCommandBuffer))->host.command_buffer);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPreprocessGeneratedCommandsEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pGeneratedCommandsInfo_host, wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->stateCommandBuffer))->host.command_buffer);
     free_conversion_context(ctx);
 }
 
@@ -45102,7 +44428,7 @@ static void thunk64_vkCmdPreprocessGeneratedCommandsNV(void *args)
 {
     struct vkCmdPreprocessGeneratedCommandsNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPreprocessGeneratedCommandsNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pGeneratedCommandsInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPreprocessGeneratedCommandsNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pGeneratedCommandsInfo);
 }
 #endif /* _WIN64 */
 
@@ -45119,7 +44445,7 @@ static void thunk32_vkCmdPreprocessGeneratedCommandsNV(void *args)
 
     init_conversion_context(ctx);
     convert_VkGeneratedCommandsInfoNV_win32_to_host(ctx, (const VkGeneratedCommandsInfoNV32 *)UlongToPtr(params->pGeneratedCommandsInfo), &pGeneratedCommandsInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPreprocessGeneratedCommandsNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pGeneratedCommandsInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPreprocessGeneratedCommandsNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pGeneratedCommandsInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -45128,7 +44454,7 @@ static void thunk64_vkCmdPushConstants(void *args)
 {
     struct vkCmdPushConstants_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushConstants(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->layout, params->stageFlags, params->offset, params->size, params->pValues);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushConstants(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->layout, params->stageFlags, params->offset, params->size, params->pValues);
 }
 #endif /* _WIN64 */
 
@@ -45144,7 +44470,7 @@ static void thunk32_vkCmdPushConstants(void *args)
         PTR32 pValues;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushConstants(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->layout, params->stageFlags, params->offset, params->size, (const void *)UlongToPtr(params->pValues));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushConstants(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->layout, params->stageFlags, params->offset, params->size, (const void *)UlongToPtr(params->pValues));
 }
 
 #ifdef _WIN64
@@ -45152,7 +44478,7 @@ static void thunk64_vkCmdPushConstants2(void *args)
 {
     struct vkCmdPushConstants2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushConstants2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPushConstantsInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushConstants2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPushConstantsInfo);
 }
 #endif /* _WIN64 */
 
@@ -45169,7 +44495,7 @@ static void thunk32_vkCmdPushConstants2(void *args)
 
     init_conversion_context(ctx);
     convert_VkPushConstantsInfo_win32_to_host(ctx, (const VkPushConstantsInfo32 *)UlongToPtr(params->pPushConstantsInfo), &pPushConstantsInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushConstants2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPushConstantsInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushConstants2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPushConstantsInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -45178,7 +44504,7 @@ static void thunk64_vkCmdPushConstants2KHR(void *args)
 {
     struct vkCmdPushConstants2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushConstants2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPushConstantsInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushConstants2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPushConstantsInfo);
 }
 #endif /* _WIN64 */
 
@@ -45195,7 +44521,7 @@ static void thunk32_vkCmdPushConstants2KHR(void *args)
 
     init_conversion_context(ctx);
     convert_VkPushConstantsInfo_win32_to_host(ctx, (const VkPushConstantsInfo32 *)UlongToPtr(params->pPushConstantsInfo), &pPushConstantsInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushConstants2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPushConstantsInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushConstants2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPushConstantsInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -45204,7 +44530,7 @@ static void thunk64_vkCmdPushDescriptorSet(void *args)
 {
     struct vkCmdPushDescriptorSet_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSet(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->layout, params->set, params->descriptorWriteCount, params->pDescriptorWrites);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSet(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->layout, params->set, params->descriptorWriteCount, params->pDescriptorWrites);
 }
 #endif /* _WIN64 */
 
@@ -45225,7 +44551,7 @@ static void thunk32_vkCmdPushDescriptorSet(void *args)
 
     init_conversion_context(ctx);
     pDescriptorWrites_host = convert_VkWriteDescriptorSet_array_win32_to_host(ctx, (const VkWriteDescriptorSet32 *)UlongToPtr(params->pDescriptorWrites), params->descriptorWriteCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSet(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->layout, params->set, params->descriptorWriteCount, pDescriptorWrites_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSet(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->layout, params->set, params->descriptorWriteCount, pDescriptorWrites_host);
     free_conversion_context(ctx);
 }
 
@@ -45234,7 +44560,7 @@ static void thunk64_vkCmdPushDescriptorSet2(void *args)
 {
     struct vkCmdPushDescriptorSet2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSet2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPushDescriptorSetInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSet2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPushDescriptorSetInfo);
 }
 #endif /* _WIN64 */
 
@@ -45251,7 +44577,7 @@ static void thunk32_vkCmdPushDescriptorSet2(void *args)
 
     init_conversion_context(ctx);
     convert_VkPushDescriptorSetInfo_win32_to_host(ctx, (const VkPushDescriptorSetInfo32 *)UlongToPtr(params->pPushDescriptorSetInfo), &pPushDescriptorSetInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSet2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPushDescriptorSetInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSet2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPushDescriptorSetInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -45260,7 +44586,7 @@ static void thunk64_vkCmdPushDescriptorSet2KHR(void *args)
 {
     struct vkCmdPushDescriptorSet2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSet2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPushDescriptorSetInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSet2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPushDescriptorSetInfo);
 }
 #endif /* _WIN64 */
 
@@ -45277,7 +44603,7 @@ static void thunk32_vkCmdPushDescriptorSet2KHR(void *args)
 
     init_conversion_context(ctx);
     convert_VkPushDescriptorSetInfo_win32_to_host(ctx, (const VkPushDescriptorSetInfo32 *)UlongToPtr(params->pPushDescriptorSetInfo), &pPushDescriptorSetInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSet2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPushDescriptorSetInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSet2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPushDescriptorSetInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -45286,7 +44612,7 @@ static void thunk64_vkCmdPushDescriptorSetKHR(void *args)
 {
     struct vkCmdPushDescriptorSetKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSetKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->layout, params->set, params->descriptorWriteCount, params->pDescriptorWrites);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSetKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->layout, params->set, params->descriptorWriteCount, params->pDescriptorWrites);
 }
 #endif /* _WIN64 */
 
@@ -45307,7 +44633,7 @@ static void thunk32_vkCmdPushDescriptorSetKHR(void *args)
 
     init_conversion_context(ctx);
     pDescriptorWrites_host = convert_VkWriteDescriptorSet_array_win32_to_host(ctx, (const VkWriteDescriptorSet32 *)UlongToPtr(params->pDescriptorWrites), params->descriptorWriteCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSetKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->layout, params->set, params->descriptorWriteCount, pDescriptorWrites_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSetKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->layout, params->set, params->descriptorWriteCount, pDescriptorWrites_host);
     free_conversion_context(ctx);
 }
 
@@ -45316,7 +44642,7 @@ static void thunk64_vkCmdPushDescriptorSetWithTemplate(void *args)
 {
     struct vkCmdPushDescriptorSetWithTemplate_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSetWithTemplate(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->descriptorUpdateTemplate, params->layout, params->set, params->pData);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSetWithTemplate(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->descriptorUpdateTemplate, params->layout, params->set, params->pData);
 }
 #endif /* _WIN64 */
 
@@ -45331,7 +44657,7 @@ static void thunk32_vkCmdPushDescriptorSetWithTemplate(void *args)
         PTR32 pData;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSetWithTemplate(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->descriptorUpdateTemplate, params->layout, params->set, (const void *)UlongToPtr(params->pData));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSetWithTemplate(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->descriptorUpdateTemplate, params->layout, params->set, (const void *)UlongToPtr(params->pData));
 }
 
 #ifdef _WIN64
@@ -45339,7 +44665,7 @@ static void thunk64_vkCmdPushDescriptorSetWithTemplate2(void *args)
 {
     struct vkCmdPushDescriptorSetWithTemplate2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSetWithTemplate2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPushDescriptorSetWithTemplateInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSetWithTemplate2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPushDescriptorSetWithTemplateInfo);
 }
 #endif /* _WIN64 */
 
@@ -45356,7 +44682,7 @@ static void thunk32_vkCmdPushDescriptorSetWithTemplate2(void *args)
 
     init_conversion_context(ctx);
     convert_VkPushDescriptorSetWithTemplateInfo_win32_to_host(ctx, (const VkPushDescriptorSetWithTemplateInfo32 *)UlongToPtr(params->pPushDescriptorSetWithTemplateInfo), &pPushDescriptorSetWithTemplateInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSetWithTemplate2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPushDescriptorSetWithTemplateInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSetWithTemplate2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPushDescriptorSetWithTemplateInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -45365,7 +44691,7 @@ static void thunk64_vkCmdPushDescriptorSetWithTemplate2KHR(void *args)
 {
     struct vkCmdPushDescriptorSetWithTemplate2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSetWithTemplate2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPushDescriptorSetWithTemplateInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSetWithTemplate2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPushDescriptorSetWithTemplateInfo);
 }
 #endif /* _WIN64 */
 
@@ -45382,7 +44708,7 @@ static void thunk32_vkCmdPushDescriptorSetWithTemplate2KHR(void *args)
 
     init_conversion_context(ctx);
     convert_VkPushDescriptorSetWithTemplateInfo_win32_to_host(ctx, (const VkPushDescriptorSetWithTemplateInfo32 *)UlongToPtr(params->pPushDescriptorSetWithTemplateInfo), &pPushDescriptorSetWithTemplateInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSetWithTemplate2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPushDescriptorSetWithTemplateInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSetWithTemplate2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPushDescriptorSetWithTemplateInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -45391,7 +44717,7 @@ static void thunk64_vkCmdPushDescriptorSetWithTemplateKHR(void *args)
 {
     struct vkCmdPushDescriptorSetWithTemplateKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSetWithTemplateKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->descriptorUpdateTemplate, params->layout, params->set, params->pData);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSetWithTemplateKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->descriptorUpdateTemplate, params->layout, params->set, params->pData);
 }
 #endif /* _WIN64 */
 
@@ -45406,7 +44732,7 @@ static void thunk32_vkCmdPushDescriptorSetWithTemplateKHR(void *args)
         PTR32 pData;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSetWithTemplateKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->descriptorUpdateTemplate, params->layout, params->set, (const void *)UlongToPtr(params->pData));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSetWithTemplateKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->descriptorUpdateTemplate, params->layout, params->set, (const void *)UlongToPtr(params->pData));
 }
 
 #ifdef _WIN64
@@ -45414,7 +44740,7 @@ static void thunk64_vkCmdResetEvent(void *args)
 {
     struct vkCmdResetEvent_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResetEvent(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->event, params->stageMask);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResetEvent(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->event, params->stageMask);
 }
 #endif /* _WIN64 */
 
@@ -45427,7 +44753,7 @@ static void thunk32_vkCmdResetEvent(void *args)
         VkPipelineStageFlags stageMask;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResetEvent(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->event, params->stageMask);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResetEvent(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->event, params->stageMask);
 }
 
 #ifdef _WIN64
@@ -45435,7 +44761,7 @@ static void thunk64_vkCmdResetEvent2(void *args)
 {
     struct vkCmdResetEvent2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResetEvent2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->event, params->stageMask);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResetEvent2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->event, params->stageMask);
 }
 #endif /* _WIN64 */
 
@@ -45448,7 +44774,7 @@ static void thunk32_vkCmdResetEvent2(void *args)
         VkPipelineStageFlags2 DECLSPEC_ALIGN(8) stageMask;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResetEvent2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->event, params->stageMask);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResetEvent2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->event, params->stageMask);
 }
 
 #ifdef _WIN64
@@ -45456,7 +44782,7 @@ static void thunk64_vkCmdResetEvent2KHR(void *args)
 {
     struct vkCmdResetEvent2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResetEvent2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->event, params->stageMask);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResetEvent2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->event, params->stageMask);
 }
 #endif /* _WIN64 */
 
@@ -45469,7 +44795,7 @@ static void thunk32_vkCmdResetEvent2KHR(void *args)
         VkPipelineStageFlags2 DECLSPEC_ALIGN(8) stageMask;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResetEvent2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->event, params->stageMask);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResetEvent2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->event, params->stageMask);
 }
 
 #ifdef _WIN64
@@ -45477,7 +44803,7 @@ static void thunk64_vkCmdResetQueryPool(void *args)
 {
     struct vkCmdResetQueryPool_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResetQueryPool(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->queryPool, params->firstQuery, params->queryCount);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResetQueryPool(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->queryPool, params->firstQuery, params->queryCount);
 }
 #endif /* _WIN64 */
 
@@ -45491,7 +44817,7 @@ static void thunk32_vkCmdResetQueryPool(void *args)
         uint32_t queryCount;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResetQueryPool(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->queryPool, params->firstQuery, params->queryCount);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResetQueryPool(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->queryPool, params->firstQuery, params->queryCount);
 }
 
 #ifdef _WIN64
@@ -45499,7 +44825,7 @@ static void thunk64_vkCmdResolveImage(void *args)
 {
     struct vkCmdResolveImage_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResolveImage(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, params->pRegions);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResolveImage(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, params->pRegions);
 }
 #endif /* _WIN64 */
 
@@ -45516,7 +44842,7 @@ static void thunk32_vkCmdResolveImage(void *args)
         PTR32 pRegions;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResolveImage(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, (const VkImageResolve *)UlongToPtr(params->pRegions));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResolveImage(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, (const VkImageResolve *)UlongToPtr(params->pRegions));
 }
 
 #ifdef _WIN64
@@ -45524,7 +44850,7 @@ static void thunk64_vkCmdResolveImage2(void *args)
 {
     struct vkCmdResolveImage2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResolveImage2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pResolveImageInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResolveImage2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pResolveImageInfo);
 }
 #endif /* _WIN64 */
 
@@ -45541,7 +44867,7 @@ static void thunk32_vkCmdResolveImage2(void *args)
 
     init_conversion_context(ctx);
     convert_VkResolveImageInfo2_win32_to_host(ctx, (const VkResolveImageInfo232 *)UlongToPtr(params->pResolveImageInfo), &pResolveImageInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResolveImage2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pResolveImageInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResolveImage2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pResolveImageInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -45550,7 +44876,7 @@ static void thunk64_vkCmdResolveImage2KHR(void *args)
 {
     struct vkCmdResolveImage2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResolveImage2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pResolveImageInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResolveImage2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pResolveImageInfo);
 }
 #endif /* _WIN64 */
 
@@ -45567,7 +44893,7 @@ static void thunk32_vkCmdResolveImage2KHR(void *args)
 
     init_conversion_context(ctx);
     convert_VkResolveImageInfo2_win32_to_host(ctx, (const VkResolveImageInfo232 *)UlongToPtr(params->pResolveImageInfo), &pResolveImageInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResolveImage2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pResolveImageInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResolveImage2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pResolveImageInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -45576,7 +44902,7 @@ static void thunk64_vkCmdSetAlphaToCoverageEnableEXT(void *args)
 {
     struct vkCmdSetAlphaToCoverageEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetAlphaToCoverageEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->alphaToCoverageEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetAlphaToCoverageEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->alphaToCoverageEnable);
 }
 #endif /* _WIN64 */
 
@@ -45588,7 +44914,7 @@ static void thunk32_vkCmdSetAlphaToCoverageEnableEXT(void *args)
         VkBool32 alphaToCoverageEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetAlphaToCoverageEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->alphaToCoverageEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetAlphaToCoverageEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->alphaToCoverageEnable);
 }
 
 #ifdef _WIN64
@@ -45596,7 +44922,7 @@ static void thunk64_vkCmdSetAlphaToOneEnableEXT(void *args)
 {
     struct vkCmdSetAlphaToOneEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetAlphaToOneEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->alphaToOneEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetAlphaToOneEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->alphaToOneEnable);
 }
 #endif /* _WIN64 */
 
@@ -45608,7 +44934,7 @@ static void thunk32_vkCmdSetAlphaToOneEnableEXT(void *args)
         VkBool32 alphaToOneEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetAlphaToOneEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->alphaToOneEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetAlphaToOneEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->alphaToOneEnable);
 }
 
 #ifdef _WIN64
@@ -45616,7 +44942,7 @@ static void thunk64_vkCmdSetAttachmentFeedbackLoopEnableEXT(void *args)
 {
     struct vkCmdSetAttachmentFeedbackLoopEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetAttachmentFeedbackLoopEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->aspectMask);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetAttachmentFeedbackLoopEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->aspectMask);
 }
 #endif /* _WIN64 */
 
@@ -45628,7 +44954,7 @@ static void thunk32_vkCmdSetAttachmentFeedbackLoopEnableEXT(void *args)
         VkImageAspectFlags aspectMask;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetAttachmentFeedbackLoopEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->aspectMask);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetAttachmentFeedbackLoopEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->aspectMask);
 }
 
 #ifdef _WIN64
@@ -45636,7 +44962,7 @@ static void thunk64_vkCmdSetBlendConstants(void *args)
 {
     struct vkCmdSetBlendConstants_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetBlendConstants(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->blendConstants);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetBlendConstants(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->blendConstants);
 }
 #endif /* _WIN64 */
 
@@ -45648,7 +44974,7 @@ static void thunk32_vkCmdSetBlendConstants(void *args)
         PTR32 blendConstants;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetBlendConstants(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, (const float *)UlongToPtr(params->blendConstants));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetBlendConstants(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, (const float *)UlongToPtr(params->blendConstants));
 }
 
 #ifdef _WIN64
@@ -45656,7 +44982,7 @@ static void thunk64_vkCmdSetCheckpointNV(void *args)
 {
     struct vkCmdSetCheckpointNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCheckpointNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCheckpointMarker);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCheckpointNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCheckpointMarker);
 }
 #endif /* _WIN64 */
 
@@ -45668,7 +44994,7 @@ static void thunk32_vkCmdSetCheckpointNV(void *args)
         PTR32 pCheckpointMarker;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCheckpointNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, (const void *)UlongToPtr(params->pCheckpointMarker));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCheckpointNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, (const void *)UlongToPtr(params->pCheckpointMarker));
 }
 
 #ifdef _WIN64
@@ -45676,7 +45002,7 @@ static void thunk64_vkCmdSetCoarseSampleOrderNV(void *args)
 {
     struct vkCmdSetCoarseSampleOrderNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoarseSampleOrderNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->sampleOrderType, params->customSampleOrderCount, params->pCustomSampleOrders);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoarseSampleOrderNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->sampleOrderType, params->customSampleOrderCount, params->pCustomSampleOrders);
 }
 #endif /* _WIN64 */
 
@@ -45695,7 +45021,7 @@ static void thunk32_vkCmdSetCoarseSampleOrderNV(void *args)
 
     init_conversion_context(ctx);
     pCustomSampleOrders_host = convert_VkCoarseSampleOrderCustomNV_array_win32_to_host(ctx, (const VkCoarseSampleOrderCustomNV32 *)UlongToPtr(params->pCustomSampleOrders), params->customSampleOrderCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoarseSampleOrderNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->sampleOrderType, params->customSampleOrderCount, pCustomSampleOrders_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoarseSampleOrderNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->sampleOrderType, params->customSampleOrderCount, pCustomSampleOrders_host);
     free_conversion_context(ctx);
 }
 
@@ -45704,7 +45030,7 @@ static void thunk64_vkCmdSetColorBlendAdvancedEXT(void *args)
 {
     struct vkCmdSetColorBlendAdvancedEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetColorBlendAdvancedEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstAttachment, params->attachmentCount, params->pColorBlendAdvanced);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetColorBlendAdvancedEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstAttachment, params->attachmentCount, params->pColorBlendAdvanced);
 }
 #endif /* _WIN64 */
 
@@ -45718,7 +45044,7 @@ static void thunk32_vkCmdSetColorBlendAdvancedEXT(void *args)
         PTR32 pColorBlendAdvanced;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetColorBlendAdvancedEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstAttachment, params->attachmentCount, (const VkColorBlendAdvancedEXT *)UlongToPtr(params->pColorBlendAdvanced));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetColorBlendAdvancedEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstAttachment, params->attachmentCount, (const VkColorBlendAdvancedEXT *)UlongToPtr(params->pColorBlendAdvanced));
 }
 
 #ifdef _WIN64
@@ -45726,7 +45052,7 @@ static void thunk64_vkCmdSetColorBlendEnableEXT(void *args)
 {
     struct vkCmdSetColorBlendEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetColorBlendEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstAttachment, params->attachmentCount, params->pColorBlendEnables);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetColorBlendEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstAttachment, params->attachmentCount, params->pColorBlendEnables);
 }
 #endif /* _WIN64 */
 
@@ -45740,7 +45066,7 @@ static void thunk32_vkCmdSetColorBlendEnableEXT(void *args)
         PTR32 pColorBlendEnables;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetColorBlendEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstAttachment, params->attachmentCount, (const VkBool32 *)UlongToPtr(params->pColorBlendEnables));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetColorBlendEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstAttachment, params->attachmentCount, (const VkBool32 *)UlongToPtr(params->pColorBlendEnables));
 }
 
 #ifdef _WIN64
@@ -45748,7 +45074,7 @@ static void thunk64_vkCmdSetColorBlendEquationEXT(void *args)
 {
     struct vkCmdSetColorBlendEquationEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetColorBlendEquationEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstAttachment, params->attachmentCount, params->pColorBlendEquations);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetColorBlendEquationEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstAttachment, params->attachmentCount, params->pColorBlendEquations);
 }
 #endif /* _WIN64 */
 
@@ -45762,7 +45088,7 @@ static void thunk32_vkCmdSetColorBlendEquationEXT(void *args)
         PTR32 pColorBlendEquations;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetColorBlendEquationEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstAttachment, params->attachmentCount, (const VkColorBlendEquationEXT *)UlongToPtr(params->pColorBlendEquations));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetColorBlendEquationEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstAttachment, params->attachmentCount, (const VkColorBlendEquationEXT *)UlongToPtr(params->pColorBlendEquations));
 }
 
 #ifdef _WIN64
@@ -45770,7 +45096,7 @@ static void thunk64_vkCmdSetColorWriteEnableEXT(void *args)
 {
     struct vkCmdSetColorWriteEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetColorWriteEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->attachmentCount, params->pColorWriteEnables);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetColorWriteEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->attachmentCount, params->pColorWriteEnables);
 }
 #endif /* _WIN64 */
 
@@ -45783,7 +45109,7 @@ static void thunk32_vkCmdSetColorWriteEnableEXT(void *args)
         PTR32 pColorWriteEnables;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetColorWriteEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->attachmentCount, (const VkBool32 *)UlongToPtr(params->pColorWriteEnables));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetColorWriteEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->attachmentCount, (const VkBool32 *)UlongToPtr(params->pColorWriteEnables));
 }
 
 #ifdef _WIN64
@@ -45791,7 +45117,7 @@ static void thunk64_vkCmdSetColorWriteMaskEXT(void *args)
 {
     struct vkCmdSetColorWriteMaskEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetColorWriteMaskEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstAttachment, params->attachmentCount, params->pColorWriteMasks);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetColorWriteMaskEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstAttachment, params->attachmentCount, params->pColorWriteMasks);
 }
 #endif /* _WIN64 */
 
@@ -45805,7 +45131,7 @@ static void thunk32_vkCmdSetColorWriteMaskEXT(void *args)
         PTR32 pColorWriteMasks;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetColorWriteMaskEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstAttachment, params->attachmentCount, (const VkColorComponentFlags *)UlongToPtr(params->pColorWriteMasks));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetColorWriteMaskEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstAttachment, params->attachmentCount, (const VkColorComponentFlags *)UlongToPtr(params->pColorWriteMasks));
 }
 
 #ifdef _WIN64
@@ -45813,7 +45139,7 @@ static void thunk64_vkCmdSetConservativeRasterizationModeEXT(void *args)
 {
     struct vkCmdSetConservativeRasterizationModeEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetConservativeRasterizationModeEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->conservativeRasterizationMode);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetConservativeRasterizationModeEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->conservativeRasterizationMode);
 }
 #endif /* _WIN64 */
 
@@ -45825,7 +45151,7 @@ static void thunk32_vkCmdSetConservativeRasterizationModeEXT(void *args)
         VkConservativeRasterizationModeEXT conservativeRasterizationMode;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetConservativeRasterizationModeEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->conservativeRasterizationMode);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetConservativeRasterizationModeEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->conservativeRasterizationMode);
 }
 
 #ifdef _WIN64
@@ -45833,7 +45159,7 @@ static void thunk64_vkCmdSetCoverageModulationModeNV(void *args)
 {
     struct vkCmdSetCoverageModulationModeNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoverageModulationModeNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->coverageModulationMode);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoverageModulationModeNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->coverageModulationMode);
 }
 #endif /* _WIN64 */
 
@@ -45845,7 +45171,7 @@ static void thunk32_vkCmdSetCoverageModulationModeNV(void *args)
         VkCoverageModulationModeNV coverageModulationMode;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoverageModulationModeNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->coverageModulationMode);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoverageModulationModeNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->coverageModulationMode);
 }
 
 #ifdef _WIN64
@@ -45853,7 +45179,7 @@ static void thunk64_vkCmdSetCoverageModulationTableEnableNV(void *args)
 {
     struct vkCmdSetCoverageModulationTableEnableNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoverageModulationTableEnableNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->coverageModulationTableEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoverageModulationTableEnableNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->coverageModulationTableEnable);
 }
 #endif /* _WIN64 */
 
@@ -45865,7 +45191,7 @@ static void thunk32_vkCmdSetCoverageModulationTableEnableNV(void *args)
         VkBool32 coverageModulationTableEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoverageModulationTableEnableNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->coverageModulationTableEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoverageModulationTableEnableNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->coverageModulationTableEnable);
 }
 
 #ifdef _WIN64
@@ -45873,7 +45199,7 @@ static void thunk64_vkCmdSetCoverageModulationTableNV(void *args)
 {
     struct vkCmdSetCoverageModulationTableNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoverageModulationTableNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->coverageModulationTableCount, params->pCoverageModulationTable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoverageModulationTableNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->coverageModulationTableCount, params->pCoverageModulationTable);
 }
 #endif /* _WIN64 */
 
@@ -45886,7 +45212,7 @@ static void thunk32_vkCmdSetCoverageModulationTableNV(void *args)
         PTR32 pCoverageModulationTable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoverageModulationTableNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->coverageModulationTableCount, (const float *)UlongToPtr(params->pCoverageModulationTable));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoverageModulationTableNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->coverageModulationTableCount, (const float *)UlongToPtr(params->pCoverageModulationTable));
 }
 
 #ifdef _WIN64
@@ -45894,7 +45220,7 @@ static void thunk64_vkCmdSetCoverageReductionModeNV(void *args)
 {
     struct vkCmdSetCoverageReductionModeNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoverageReductionModeNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->coverageReductionMode);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoverageReductionModeNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->coverageReductionMode);
 }
 #endif /* _WIN64 */
 
@@ -45906,7 +45232,7 @@ static void thunk32_vkCmdSetCoverageReductionModeNV(void *args)
         VkCoverageReductionModeNV coverageReductionMode;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoverageReductionModeNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->coverageReductionMode);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoverageReductionModeNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->coverageReductionMode);
 }
 
 #ifdef _WIN64
@@ -45914,7 +45240,7 @@ static void thunk64_vkCmdSetCoverageToColorEnableNV(void *args)
 {
     struct vkCmdSetCoverageToColorEnableNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoverageToColorEnableNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->coverageToColorEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoverageToColorEnableNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->coverageToColorEnable);
 }
 #endif /* _WIN64 */
 
@@ -45926,7 +45252,7 @@ static void thunk32_vkCmdSetCoverageToColorEnableNV(void *args)
         VkBool32 coverageToColorEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoverageToColorEnableNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->coverageToColorEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoverageToColorEnableNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->coverageToColorEnable);
 }
 
 #ifdef _WIN64
@@ -45934,7 +45260,7 @@ static void thunk64_vkCmdSetCoverageToColorLocationNV(void *args)
 {
     struct vkCmdSetCoverageToColorLocationNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoverageToColorLocationNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->coverageToColorLocation);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoverageToColorLocationNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->coverageToColorLocation);
 }
 #endif /* _WIN64 */
 
@@ -45946,7 +45272,7 @@ static void thunk32_vkCmdSetCoverageToColorLocationNV(void *args)
         uint32_t coverageToColorLocation;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoverageToColorLocationNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->coverageToColorLocation);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoverageToColorLocationNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->coverageToColorLocation);
 }
 
 #ifdef _WIN64
@@ -45954,7 +45280,7 @@ static void thunk64_vkCmdSetCullMode(void *args)
 {
     struct vkCmdSetCullMode_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCullMode(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->cullMode);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCullMode(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->cullMode);
 }
 #endif /* _WIN64 */
 
@@ -45966,7 +45292,7 @@ static void thunk32_vkCmdSetCullMode(void *args)
         VkCullModeFlags cullMode;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCullMode(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->cullMode);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCullMode(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->cullMode);
 }
 
 #ifdef _WIN64
@@ -45974,7 +45300,7 @@ static void thunk64_vkCmdSetCullModeEXT(void *args)
 {
     struct vkCmdSetCullModeEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCullModeEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->cullMode);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCullModeEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->cullMode);
 }
 #endif /* _WIN64 */
 
@@ -45986,7 +45312,7 @@ static void thunk32_vkCmdSetCullModeEXT(void *args)
         VkCullModeFlags cullMode;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCullModeEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->cullMode);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCullModeEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->cullMode);
 }
 
 #ifdef _WIN64
@@ -45994,7 +45320,7 @@ static void thunk64_vkCmdSetDepthBias(void *args)
 {
     struct vkCmdSetDepthBias_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBias(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthBiasConstantFactor, params->depthBiasClamp, params->depthBiasSlopeFactor);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBias(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthBiasConstantFactor, params->depthBiasClamp, params->depthBiasSlopeFactor);
 }
 #endif /* _WIN64 */
 
@@ -46008,7 +45334,7 @@ static void thunk32_vkCmdSetDepthBias(void *args)
         float depthBiasSlopeFactor;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBias(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthBiasConstantFactor, params->depthBiasClamp, params->depthBiasSlopeFactor);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBias(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthBiasConstantFactor, params->depthBiasClamp, params->depthBiasSlopeFactor);
 }
 
 #ifdef _WIN64
@@ -46016,7 +45342,7 @@ static void thunk64_vkCmdSetDepthBias2EXT(void *args)
 {
     struct vkCmdSetDepthBias2EXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBias2EXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pDepthBiasInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBias2EXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pDepthBiasInfo);
 }
 #endif /* _WIN64 */
 
@@ -46033,7 +45359,7 @@ static void thunk32_vkCmdSetDepthBias2EXT(void *args)
 
     init_conversion_context(ctx);
     convert_VkDepthBiasInfoEXT_win32_to_host(ctx, (const VkDepthBiasInfoEXT32 *)UlongToPtr(params->pDepthBiasInfo), &pDepthBiasInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBias2EXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pDepthBiasInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBias2EXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pDepthBiasInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -46042,7 +45368,7 @@ static void thunk64_vkCmdSetDepthBiasEnable(void *args)
 {
     struct vkCmdSetDepthBiasEnable_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBiasEnable(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthBiasEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBiasEnable(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthBiasEnable);
 }
 #endif /* _WIN64 */
 
@@ -46054,7 +45380,7 @@ static void thunk32_vkCmdSetDepthBiasEnable(void *args)
         VkBool32 depthBiasEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBiasEnable(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthBiasEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBiasEnable(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthBiasEnable);
 }
 
 #ifdef _WIN64
@@ -46062,7 +45388,7 @@ static void thunk64_vkCmdSetDepthBiasEnableEXT(void *args)
 {
     struct vkCmdSetDepthBiasEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBiasEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthBiasEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBiasEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthBiasEnable);
 }
 #endif /* _WIN64 */
 
@@ -46074,7 +45400,7 @@ static void thunk32_vkCmdSetDepthBiasEnableEXT(void *args)
         VkBool32 depthBiasEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBiasEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthBiasEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBiasEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthBiasEnable);
 }
 
 #ifdef _WIN64
@@ -46082,7 +45408,7 @@ static void thunk64_vkCmdSetDepthBounds(void *args)
 {
     struct vkCmdSetDepthBounds_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBounds(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->minDepthBounds, params->maxDepthBounds);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBounds(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->minDepthBounds, params->maxDepthBounds);
 }
 #endif /* _WIN64 */
 
@@ -46095,7 +45421,7 @@ static void thunk32_vkCmdSetDepthBounds(void *args)
         float maxDepthBounds;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBounds(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->minDepthBounds, params->maxDepthBounds);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBounds(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->minDepthBounds, params->maxDepthBounds);
 }
 
 #ifdef _WIN64
@@ -46103,7 +45429,7 @@ static void thunk64_vkCmdSetDepthBoundsTestEnable(void *args)
 {
     struct vkCmdSetDepthBoundsTestEnable_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBoundsTestEnable(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthBoundsTestEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBoundsTestEnable(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthBoundsTestEnable);
 }
 #endif /* _WIN64 */
 
@@ -46115,7 +45441,7 @@ static void thunk32_vkCmdSetDepthBoundsTestEnable(void *args)
         VkBool32 depthBoundsTestEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBoundsTestEnable(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthBoundsTestEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBoundsTestEnable(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthBoundsTestEnable);
 }
 
 #ifdef _WIN64
@@ -46123,7 +45449,7 @@ static void thunk64_vkCmdSetDepthBoundsTestEnableEXT(void *args)
 {
     struct vkCmdSetDepthBoundsTestEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBoundsTestEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthBoundsTestEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBoundsTestEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthBoundsTestEnable);
 }
 #endif /* _WIN64 */
 
@@ -46135,7 +45461,7 @@ static void thunk32_vkCmdSetDepthBoundsTestEnableEXT(void *args)
         VkBool32 depthBoundsTestEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBoundsTestEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthBoundsTestEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBoundsTestEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthBoundsTestEnable);
 }
 
 #ifdef _WIN64
@@ -46143,7 +45469,7 @@ static void thunk64_vkCmdSetDepthClampEnableEXT(void *args)
 {
     struct vkCmdSetDepthClampEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthClampEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthClampEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthClampEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthClampEnable);
 }
 #endif /* _WIN64 */
 
@@ -46155,7 +45481,7 @@ static void thunk32_vkCmdSetDepthClampEnableEXT(void *args)
         VkBool32 depthClampEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthClampEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthClampEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthClampEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthClampEnable);
 }
 
 #ifdef _WIN64
@@ -46163,7 +45489,7 @@ static void thunk64_vkCmdSetDepthClampRangeEXT(void *args)
 {
     struct vkCmdSetDepthClampRangeEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthClampRangeEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthClampMode, params->pDepthClampRange);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthClampRangeEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthClampMode, params->pDepthClampRange);
 }
 #endif /* _WIN64 */
 
@@ -46176,7 +45502,7 @@ static void thunk32_vkCmdSetDepthClampRangeEXT(void *args)
         PTR32 pDepthClampRange;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthClampRangeEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthClampMode, (const VkDepthClampRangeEXT *)UlongToPtr(params->pDepthClampRange));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthClampRangeEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthClampMode, (const VkDepthClampRangeEXT *)UlongToPtr(params->pDepthClampRange));
 }
 
 #ifdef _WIN64
@@ -46184,7 +45510,7 @@ static void thunk64_vkCmdSetDepthClipEnableEXT(void *args)
 {
     struct vkCmdSetDepthClipEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthClipEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthClipEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthClipEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthClipEnable);
 }
 #endif /* _WIN64 */
 
@@ -46196,7 +45522,7 @@ static void thunk32_vkCmdSetDepthClipEnableEXT(void *args)
         VkBool32 depthClipEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthClipEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthClipEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthClipEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthClipEnable);
 }
 
 #ifdef _WIN64
@@ -46204,7 +45530,7 @@ static void thunk64_vkCmdSetDepthClipNegativeOneToOneEXT(void *args)
 {
     struct vkCmdSetDepthClipNegativeOneToOneEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthClipNegativeOneToOneEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->negativeOneToOne);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthClipNegativeOneToOneEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->negativeOneToOne);
 }
 #endif /* _WIN64 */
 
@@ -46216,7 +45542,7 @@ static void thunk32_vkCmdSetDepthClipNegativeOneToOneEXT(void *args)
         VkBool32 negativeOneToOne;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthClipNegativeOneToOneEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->negativeOneToOne);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthClipNegativeOneToOneEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->negativeOneToOne);
 }
 
 #ifdef _WIN64
@@ -46224,7 +45550,7 @@ static void thunk64_vkCmdSetDepthCompareOp(void *args)
 {
     struct vkCmdSetDepthCompareOp_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthCompareOp(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthCompareOp);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthCompareOp(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthCompareOp);
 }
 #endif /* _WIN64 */
 
@@ -46236,7 +45562,7 @@ static void thunk32_vkCmdSetDepthCompareOp(void *args)
         VkCompareOp depthCompareOp;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthCompareOp(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthCompareOp);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthCompareOp(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthCompareOp);
 }
 
 #ifdef _WIN64
@@ -46244,7 +45570,7 @@ static void thunk64_vkCmdSetDepthCompareOpEXT(void *args)
 {
     struct vkCmdSetDepthCompareOpEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthCompareOpEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthCompareOp);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthCompareOpEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthCompareOp);
 }
 #endif /* _WIN64 */
 
@@ -46256,7 +45582,7 @@ static void thunk32_vkCmdSetDepthCompareOpEXT(void *args)
         VkCompareOp depthCompareOp;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthCompareOpEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthCompareOp);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthCompareOpEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthCompareOp);
 }
 
 #ifdef _WIN64
@@ -46264,7 +45590,7 @@ static void thunk64_vkCmdSetDepthTestEnable(void *args)
 {
     struct vkCmdSetDepthTestEnable_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthTestEnable(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthTestEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthTestEnable(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthTestEnable);
 }
 #endif /* _WIN64 */
 
@@ -46276,7 +45602,7 @@ static void thunk32_vkCmdSetDepthTestEnable(void *args)
         VkBool32 depthTestEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthTestEnable(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthTestEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthTestEnable(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthTestEnable);
 }
 
 #ifdef _WIN64
@@ -46284,7 +45610,7 @@ static void thunk64_vkCmdSetDepthTestEnableEXT(void *args)
 {
     struct vkCmdSetDepthTestEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthTestEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthTestEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthTestEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthTestEnable);
 }
 #endif /* _WIN64 */
 
@@ -46296,7 +45622,7 @@ static void thunk32_vkCmdSetDepthTestEnableEXT(void *args)
         VkBool32 depthTestEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthTestEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthTestEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthTestEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthTestEnable);
 }
 
 #ifdef _WIN64
@@ -46304,7 +45630,7 @@ static void thunk64_vkCmdSetDepthWriteEnable(void *args)
 {
     struct vkCmdSetDepthWriteEnable_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthWriteEnable(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthWriteEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthWriteEnable(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthWriteEnable);
 }
 #endif /* _WIN64 */
 
@@ -46316,7 +45642,7 @@ static void thunk32_vkCmdSetDepthWriteEnable(void *args)
         VkBool32 depthWriteEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthWriteEnable(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthWriteEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthWriteEnable(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthWriteEnable);
 }
 
 #ifdef _WIN64
@@ -46324,7 +45650,7 @@ static void thunk64_vkCmdSetDepthWriteEnableEXT(void *args)
 {
     struct vkCmdSetDepthWriteEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthWriteEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthWriteEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthWriteEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthWriteEnable);
 }
 #endif /* _WIN64 */
 
@@ -46336,7 +45662,7 @@ static void thunk32_vkCmdSetDepthWriteEnableEXT(void *args)
         VkBool32 depthWriteEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthWriteEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthWriteEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthWriteEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthWriteEnable);
 }
 
 #ifdef _WIN64
@@ -46344,7 +45670,7 @@ static void thunk64_vkCmdSetDescriptorBufferOffsets2EXT(void *args)
 {
     struct vkCmdSetDescriptorBufferOffsets2EXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDescriptorBufferOffsets2EXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pSetDescriptorBufferOffsetsInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDescriptorBufferOffsets2EXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pSetDescriptorBufferOffsetsInfo);
 }
 #endif /* _WIN64 */
 
@@ -46361,7 +45687,7 @@ static void thunk32_vkCmdSetDescriptorBufferOffsets2EXT(void *args)
 
     init_conversion_context(ctx);
     convert_VkSetDescriptorBufferOffsetsInfoEXT_win32_to_host(ctx, (const VkSetDescriptorBufferOffsetsInfoEXT32 *)UlongToPtr(params->pSetDescriptorBufferOffsetsInfo), &pSetDescriptorBufferOffsetsInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDescriptorBufferOffsets2EXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pSetDescriptorBufferOffsetsInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDescriptorBufferOffsets2EXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pSetDescriptorBufferOffsetsInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -46370,7 +45696,7 @@ static void thunk64_vkCmdSetDescriptorBufferOffsetsEXT(void *args)
 {
     struct vkCmdSetDescriptorBufferOffsetsEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDescriptorBufferOffsetsEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->layout, params->firstSet, params->setCount, params->pBufferIndices, params->pOffsets);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDescriptorBufferOffsetsEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->layout, params->firstSet, params->setCount, params->pBufferIndices, params->pOffsets);
 }
 #endif /* _WIN64 */
 
@@ -46387,7 +45713,7 @@ static void thunk32_vkCmdSetDescriptorBufferOffsetsEXT(void *args)
         PTR32 pOffsets;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDescriptorBufferOffsetsEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->layout, params->firstSet, params->setCount, (const uint32_t *)UlongToPtr(params->pBufferIndices), (const VkDeviceSize *)UlongToPtr(params->pOffsets));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDescriptorBufferOffsetsEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->layout, params->firstSet, params->setCount, (const uint32_t *)UlongToPtr(params->pBufferIndices), (const VkDeviceSize *)UlongToPtr(params->pOffsets));
 }
 
 #ifdef _WIN64
@@ -46395,7 +45721,7 @@ static void thunk64_vkCmdSetDeviceMask(void *args)
 {
     struct vkCmdSetDeviceMask_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDeviceMask(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->deviceMask);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDeviceMask(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->deviceMask);
 }
 #endif /* _WIN64 */
 
@@ -46407,7 +45733,7 @@ static void thunk32_vkCmdSetDeviceMask(void *args)
         uint32_t deviceMask;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDeviceMask(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->deviceMask);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDeviceMask(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->deviceMask);
 }
 
 #ifdef _WIN64
@@ -46415,7 +45741,7 @@ static void thunk64_vkCmdSetDeviceMaskKHR(void *args)
 {
     struct vkCmdSetDeviceMaskKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDeviceMaskKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->deviceMask);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDeviceMaskKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->deviceMask);
 }
 #endif /* _WIN64 */
 
@@ -46427,7 +45753,7 @@ static void thunk32_vkCmdSetDeviceMaskKHR(void *args)
         uint32_t deviceMask;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDeviceMaskKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->deviceMask);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDeviceMaskKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->deviceMask);
 }
 
 #ifdef _WIN64
@@ -46435,7 +45761,7 @@ static void thunk64_vkCmdSetDiscardRectangleEXT(void *args)
 {
     struct vkCmdSetDiscardRectangleEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDiscardRectangleEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstDiscardRectangle, params->discardRectangleCount, params->pDiscardRectangles);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDiscardRectangleEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstDiscardRectangle, params->discardRectangleCount, params->pDiscardRectangles);
 }
 #endif /* _WIN64 */
 
@@ -46449,7 +45775,7 @@ static void thunk32_vkCmdSetDiscardRectangleEXT(void *args)
         PTR32 pDiscardRectangles;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDiscardRectangleEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstDiscardRectangle, params->discardRectangleCount, (const VkRect2D *)UlongToPtr(params->pDiscardRectangles));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDiscardRectangleEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstDiscardRectangle, params->discardRectangleCount, (const VkRect2D *)UlongToPtr(params->pDiscardRectangles));
 }
 
 #ifdef _WIN64
@@ -46457,7 +45783,7 @@ static void thunk64_vkCmdSetDiscardRectangleEnableEXT(void *args)
 {
     struct vkCmdSetDiscardRectangleEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDiscardRectangleEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->discardRectangleEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDiscardRectangleEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->discardRectangleEnable);
 }
 #endif /* _WIN64 */
 
@@ -46469,7 +45795,7 @@ static void thunk32_vkCmdSetDiscardRectangleEnableEXT(void *args)
         VkBool32 discardRectangleEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDiscardRectangleEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->discardRectangleEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDiscardRectangleEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->discardRectangleEnable);
 }
 
 #ifdef _WIN64
@@ -46477,7 +45803,7 @@ static void thunk64_vkCmdSetDiscardRectangleModeEXT(void *args)
 {
     struct vkCmdSetDiscardRectangleModeEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDiscardRectangleModeEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->discardRectangleMode);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDiscardRectangleModeEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->discardRectangleMode);
 }
 #endif /* _WIN64 */
 
@@ -46489,7 +45815,7 @@ static void thunk32_vkCmdSetDiscardRectangleModeEXT(void *args)
         VkDiscardRectangleModeEXT discardRectangleMode;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDiscardRectangleModeEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->discardRectangleMode);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDiscardRectangleModeEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->discardRectangleMode);
 }
 
 #ifdef _WIN64
@@ -46497,7 +45823,7 @@ static void thunk64_vkCmdSetEvent(void *args)
 {
     struct vkCmdSetEvent_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetEvent(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->event, params->stageMask);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetEvent(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->event, params->stageMask);
 }
 #endif /* _WIN64 */
 
@@ -46510,7 +45836,7 @@ static void thunk32_vkCmdSetEvent(void *args)
         VkPipelineStageFlags stageMask;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetEvent(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->event, params->stageMask);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetEvent(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->event, params->stageMask);
 }
 
 #ifdef _WIN64
@@ -46518,7 +45844,7 @@ static void thunk64_vkCmdSetEvent2(void *args)
 {
     struct vkCmdSetEvent2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetEvent2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->event, params->pDependencyInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetEvent2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->event, params->pDependencyInfo);
 }
 #endif /* _WIN64 */
 
@@ -46536,7 +45862,7 @@ static void thunk32_vkCmdSetEvent2(void *args)
 
     init_conversion_context(ctx);
     convert_VkDependencyInfo_win32_to_host(ctx, (const VkDependencyInfo32 *)UlongToPtr(params->pDependencyInfo), &pDependencyInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetEvent2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->event, &pDependencyInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetEvent2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->event, &pDependencyInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -46545,7 +45871,7 @@ static void thunk64_vkCmdSetEvent2KHR(void *args)
 {
     struct vkCmdSetEvent2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetEvent2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->event, params->pDependencyInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetEvent2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->event, params->pDependencyInfo);
 }
 #endif /* _WIN64 */
 
@@ -46563,7 +45889,7 @@ static void thunk32_vkCmdSetEvent2KHR(void *args)
 
     init_conversion_context(ctx);
     convert_VkDependencyInfo_win32_to_host(ctx, (const VkDependencyInfo32 *)UlongToPtr(params->pDependencyInfo), &pDependencyInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetEvent2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->event, &pDependencyInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetEvent2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->event, &pDependencyInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -46572,7 +45898,7 @@ static void thunk64_vkCmdSetExclusiveScissorEnableNV(void *args)
 {
     struct vkCmdSetExclusiveScissorEnableNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetExclusiveScissorEnableNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstExclusiveScissor, params->exclusiveScissorCount, params->pExclusiveScissorEnables);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetExclusiveScissorEnableNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstExclusiveScissor, params->exclusiveScissorCount, params->pExclusiveScissorEnables);
 }
 #endif /* _WIN64 */
 
@@ -46586,7 +45912,7 @@ static void thunk32_vkCmdSetExclusiveScissorEnableNV(void *args)
         PTR32 pExclusiveScissorEnables;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetExclusiveScissorEnableNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstExclusiveScissor, params->exclusiveScissorCount, (const VkBool32 *)UlongToPtr(params->pExclusiveScissorEnables));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetExclusiveScissorEnableNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstExclusiveScissor, params->exclusiveScissorCount, (const VkBool32 *)UlongToPtr(params->pExclusiveScissorEnables));
 }
 
 #ifdef _WIN64
@@ -46594,7 +45920,7 @@ static void thunk64_vkCmdSetExclusiveScissorNV(void *args)
 {
     struct vkCmdSetExclusiveScissorNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetExclusiveScissorNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstExclusiveScissor, params->exclusiveScissorCount, params->pExclusiveScissors);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetExclusiveScissorNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstExclusiveScissor, params->exclusiveScissorCount, params->pExclusiveScissors);
 }
 #endif /* _WIN64 */
 
@@ -46608,7 +45934,7 @@ static void thunk32_vkCmdSetExclusiveScissorNV(void *args)
         PTR32 pExclusiveScissors;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetExclusiveScissorNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstExclusiveScissor, params->exclusiveScissorCount, (const VkRect2D *)UlongToPtr(params->pExclusiveScissors));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetExclusiveScissorNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstExclusiveScissor, params->exclusiveScissorCount, (const VkRect2D *)UlongToPtr(params->pExclusiveScissors));
 }
 
 #ifdef _WIN64
@@ -46616,7 +45942,7 @@ static void thunk64_vkCmdSetExtraPrimitiveOverestimationSizeEXT(void *args)
 {
     struct vkCmdSetExtraPrimitiveOverestimationSizeEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetExtraPrimitiveOverestimationSizeEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->extraPrimitiveOverestimationSize);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetExtraPrimitiveOverestimationSizeEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->extraPrimitiveOverestimationSize);
 }
 #endif /* _WIN64 */
 
@@ -46628,7 +45954,7 @@ static void thunk32_vkCmdSetExtraPrimitiveOverestimationSizeEXT(void *args)
         float extraPrimitiveOverestimationSize;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetExtraPrimitiveOverestimationSizeEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->extraPrimitiveOverestimationSize);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetExtraPrimitiveOverestimationSizeEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->extraPrimitiveOverestimationSize);
 }
 
 #ifdef _WIN64
@@ -46636,7 +45962,7 @@ static void thunk64_vkCmdSetFragmentShadingRateEnumNV(void *args)
 {
     struct vkCmdSetFragmentShadingRateEnumNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetFragmentShadingRateEnumNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->shadingRate, params->combinerOps);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetFragmentShadingRateEnumNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->shadingRate, params->combinerOps);
 }
 #endif /* _WIN64 */
 
@@ -46649,7 +45975,7 @@ static void thunk32_vkCmdSetFragmentShadingRateEnumNV(void *args)
         PTR32 combinerOps;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetFragmentShadingRateEnumNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->shadingRate, (const VkFragmentShadingRateCombinerOpKHR *)UlongToPtr(params->combinerOps));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetFragmentShadingRateEnumNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->shadingRate, (const VkFragmentShadingRateCombinerOpKHR *)UlongToPtr(params->combinerOps));
 }
 
 #ifdef _WIN64
@@ -46657,7 +45983,7 @@ static void thunk64_vkCmdSetFragmentShadingRateKHR(void *args)
 {
     struct vkCmdSetFragmentShadingRateKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetFragmentShadingRateKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pFragmentSize, params->combinerOps);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetFragmentShadingRateKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pFragmentSize, params->combinerOps);
 }
 #endif /* _WIN64 */
 
@@ -46670,7 +45996,7 @@ static void thunk32_vkCmdSetFragmentShadingRateKHR(void *args)
         PTR32 combinerOps;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetFragmentShadingRateKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, (const VkExtent2D *)UlongToPtr(params->pFragmentSize), (const VkFragmentShadingRateCombinerOpKHR *)UlongToPtr(params->combinerOps));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetFragmentShadingRateKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, (const VkExtent2D *)UlongToPtr(params->pFragmentSize), (const VkFragmentShadingRateCombinerOpKHR *)UlongToPtr(params->combinerOps));
 }
 
 #ifdef _WIN64
@@ -46678,7 +46004,7 @@ static void thunk64_vkCmdSetFrontFace(void *args)
 {
     struct vkCmdSetFrontFace_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetFrontFace(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->frontFace);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetFrontFace(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->frontFace);
 }
 #endif /* _WIN64 */
 
@@ -46690,7 +46016,7 @@ static void thunk32_vkCmdSetFrontFace(void *args)
         VkFrontFace frontFace;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetFrontFace(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->frontFace);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetFrontFace(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->frontFace);
 }
 
 #ifdef _WIN64
@@ -46698,7 +46024,7 @@ static void thunk64_vkCmdSetFrontFaceEXT(void *args)
 {
     struct vkCmdSetFrontFaceEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetFrontFaceEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->frontFace);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetFrontFaceEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->frontFace);
 }
 #endif /* _WIN64 */
 
@@ -46710,7 +46036,7 @@ static void thunk32_vkCmdSetFrontFaceEXT(void *args)
         VkFrontFace frontFace;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetFrontFaceEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->frontFace);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetFrontFaceEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->frontFace);
 }
 
 #ifdef _WIN64
@@ -46718,7 +46044,7 @@ static void thunk64_vkCmdSetLineRasterizationModeEXT(void *args)
 {
     struct vkCmdSetLineRasterizationModeEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLineRasterizationModeEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->lineRasterizationMode);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLineRasterizationModeEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->lineRasterizationMode);
 }
 #endif /* _WIN64 */
 
@@ -46730,7 +46056,7 @@ static void thunk32_vkCmdSetLineRasterizationModeEXT(void *args)
         VkLineRasterizationModeEXT lineRasterizationMode;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLineRasterizationModeEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->lineRasterizationMode);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLineRasterizationModeEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->lineRasterizationMode);
 }
 
 #ifdef _WIN64
@@ -46738,7 +46064,7 @@ static void thunk64_vkCmdSetLineStipple(void *args)
 {
     struct vkCmdSetLineStipple_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLineStipple(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->lineStippleFactor, params->lineStipplePattern);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLineStipple(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->lineStippleFactor, params->lineStipplePattern);
 }
 #endif /* _WIN64 */
 
@@ -46751,7 +46077,7 @@ static void thunk32_vkCmdSetLineStipple(void *args)
         uint16_t lineStipplePattern;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLineStipple(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->lineStippleFactor, params->lineStipplePattern);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLineStipple(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->lineStippleFactor, params->lineStipplePattern);
 }
 
 #ifdef _WIN64
@@ -46759,7 +46085,7 @@ static void thunk64_vkCmdSetLineStippleEXT(void *args)
 {
     struct vkCmdSetLineStippleEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLineStippleEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->lineStippleFactor, params->lineStipplePattern);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLineStippleEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->lineStippleFactor, params->lineStipplePattern);
 }
 #endif /* _WIN64 */
 
@@ -46772,7 +46098,7 @@ static void thunk32_vkCmdSetLineStippleEXT(void *args)
         uint16_t lineStipplePattern;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLineStippleEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->lineStippleFactor, params->lineStipplePattern);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLineStippleEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->lineStippleFactor, params->lineStipplePattern);
 }
 
 #ifdef _WIN64
@@ -46780,7 +46106,7 @@ static void thunk64_vkCmdSetLineStippleEnableEXT(void *args)
 {
     struct vkCmdSetLineStippleEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLineStippleEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stippledLineEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLineStippleEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stippledLineEnable);
 }
 #endif /* _WIN64 */
 
@@ -46792,7 +46118,7 @@ static void thunk32_vkCmdSetLineStippleEnableEXT(void *args)
         VkBool32 stippledLineEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLineStippleEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stippledLineEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLineStippleEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stippledLineEnable);
 }
 
 #ifdef _WIN64
@@ -46800,7 +46126,7 @@ static void thunk64_vkCmdSetLineStippleKHR(void *args)
 {
     struct vkCmdSetLineStippleKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLineStippleKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->lineStippleFactor, params->lineStipplePattern);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLineStippleKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->lineStippleFactor, params->lineStipplePattern);
 }
 #endif /* _WIN64 */
 
@@ -46813,7 +46139,7 @@ static void thunk32_vkCmdSetLineStippleKHR(void *args)
         uint16_t lineStipplePattern;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLineStippleKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->lineStippleFactor, params->lineStipplePattern);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLineStippleKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->lineStippleFactor, params->lineStipplePattern);
 }
 
 #ifdef _WIN64
@@ -46821,7 +46147,7 @@ static void thunk64_vkCmdSetLineWidth(void *args)
 {
     struct vkCmdSetLineWidth_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLineWidth(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->lineWidth);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLineWidth(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->lineWidth);
 }
 #endif /* _WIN64 */
 
@@ -46833,7 +46159,7 @@ static void thunk32_vkCmdSetLineWidth(void *args)
         float lineWidth;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLineWidth(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->lineWidth);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLineWidth(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->lineWidth);
 }
 
 #ifdef _WIN64
@@ -46841,7 +46167,7 @@ static void thunk64_vkCmdSetLogicOpEXT(void *args)
 {
     struct vkCmdSetLogicOpEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLogicOpEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->logicOp);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLogicOpEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->logicOp);
 }
 #endif /* _WIN64 */
 
@@ -46853,7 +46179,7 @@ static void thunk32_vkCmdSetLogicOpEXT(void *args)
         VkLogicOp logicOp;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLogicOpEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->logicOp);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLogicOpEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->logicOp);
 }
 
 #ifdef _WIN64
@@ -46861,7 +46187,7 @@ static void thunk64_vkCmdSetLogicOpEnableEXT(void *args)
 {
     struct vkCmdSetLogicOpEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLogicOpEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->logicOpEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLogicOpEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->logicOpEnable);
 }
 #endif /* _WIN64 */
 
@@ -46873,7 +46199,7 @@ static void thunk32_vkCmdSetLogicOpEnableEXT(void *args)
         VkBool32 logicOpEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLogicOpEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->logicOpEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLogicOpEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->logicOpEnable);
 }
 
 #ifdef _WIN64
@@ -46881,7 +46207,7 @@ static void thunk64_vkCmdSetPatchControlPointsEXT(void *args)
 {
     struct vkCmdSetPatchControlPointsEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPatchControlPointsEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->patchControlPoints);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPatchControlPointsEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->patchControlPoints);
 }
 #endif /* _WIN64 */
 
@@ -46893,7 +46219,7 @@ static void thunk32_vkCmdSetPatchControlPointsEXT(void *args)
         uint32_t patchControlPoints;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPatchControlPointsEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->patchControlPoints);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPatchControlPointsEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->patchControlPoints);
 }
 
 #ifdef _WIN64
@@ -46903,7 +46229,7 @@ static NTSTATUS thunk64_vkCmdSetPerformanceMarkerINTEL(void *args)
 
     TRACE("%p, %p\n", params->commandBuffer, params->pMarkerInfo);
 
-    params->result = vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPerformanceMarkerINTEL(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pMarkerInfo);
+    params->result = wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPerformanceMarkerINTEL(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pMarkerInfo);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -46921,7 +46247,7 @@ static NTSTATUS thunk32_vkCmdSetPerformanceMarkerINTEL(void *args)
     TRACE("%#x, %#x\n", params->commandBuffer, params->pMarkerInfo);
 
     convert_VkPerformanceMarkerInfoINTEL_win32_to_host((const VkPerformanceMarkerInfoINTEL32 *)UlongToPtr(params->pMarkerInfo), &pMarkerInfo_host);
-    params->result = vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPerformanceMarkerINTEL(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pMarkerInfo_host);
+    params->result = wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPerformanceMarkerINTEL(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pMarkerInfo_host);
     return STATUS_SUCCESS;
 }
 
@@ -46932,7 +46258,7 @@ static NTSTATUS thunk64_vkCmdSetPerformanceOverrideINTEL(void *args)
 
     TRACE("%p, %p\n", params->commandBuffer, params->pOverrideInfo);
 
-    params->result = vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPerformanceOverrideINTEL(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pOverrideInfo);
+    params->result = wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPerformanceOverrideINTEL(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pOverrideInfo);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -46950,7 +46276,7 @@ static NTSTATUS thunk32_vkCmdSetPerformanceOverrideINTEL(void *args)
     TRACE("%#x, %#x\n", params->commandBuffer, params->pOverrideInfo);
 
     convert_VkPerformanceOverrideInfoINTEL_win32_to_host((const VkPerformanceOverrideInfoINTEL32 *)UlongToPtr(params->pOverrideInfo), &pOverrideInfo_host);
-    params->result = vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPerformanceOverrideINTEL(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pOverrideInfo_host);
+    params->result = wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPerformanceOverrideINTEL(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pOverrideInfo_host);
     return STATUS_SUCCESS;
 }
 
@@ -46961,7 +46287,7 @@ static NTSTATUS thunk64_vkCmdSetPerformanceStreamMarkerINTEL(void *args)
 
     TRACE("%p, %p\n", params->commandBuffer, params->pMarkerInfo);
 
-    params->result = vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPerformanceStreamMarkerINTEL(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pMarkerInfo);
+    params->result = wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPerformanceStreamMarkerINTEL(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pMarkerInfo);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -46979,7 +46305,7 @@ static NTSTATUS thunk32_vkCmdSetPerformanceStreamMarkerINTEL(void *args)
     TRACE("%#x, %#x\n", params->commandBuffer, params->pMarkerInfo);
 
     convert_VkPerformanceStreamMarkerInfoINTEL_win32_to_host((const VkPerformanceStreamMarkerInfoINTEL32 *)UlongToPtr(params->pMarkerInfo), &pMarkerInfo_host);
-    params->result = vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPerformanceStreamMarkerINTEL(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pMarkerInfo_host);
+    params->result = wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPerformanceStreamMarkerINTEL(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pMarkerInfo_host);
     return STATUS_SUCCESS;
 }
 
@@ -46988,7 +46314,7 @@ static void thunk64_vkCmdSetPolygonModeEXT(void *args)
 {
     struct vkCmdSetPolygonModeEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPolygonModeEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->polygonMode);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPolygonModeEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->polygonMode);
 }
 #endif /* _WIN64 */
 
@@ -47000,7 +46326,7 @@ static void thunk32_vkCmdSetPolygonModeEXT(void *args)
         VkPolygonMode polygonMode;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPolygonModeEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->polygonMode);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPolygonModeEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->polygonMode);
 }
 
 #ifdef _WIN64
@@ -47008,7 +46334,7 @@ static void thunk64_vkCmdSetPrimitiveRestartEnable(void *args)
 {
     struct vkCmdSetPrimitiveRestartEnable_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPrimitiveRestartEnable(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->primitiveRestartEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPrimitiveRestartEnable(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->primitiveRestartEnable);
 }
 #endif /* _WIN64 */
 
@@ -47020,7 +46346,7 @@ static void thunk32_vkCmdSetPrimitiveRestartEnable(void *args)
         VkBool32 primitiveRestartEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPrimitiveRestartEnable(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->primitiveRestartEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPrimitiveRestartEnable(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->primitiveRestartEnable);
 }
 
 #ifdef _WIN64
@@ -47028,7 +46354,7 @@ static void thunk64_vkCmdSetPrimitiveRestartEnableEXT(void *args)
 {
     struct vkCmdSetPrimitiveRestartEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPrimitiveRestartEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->primitiveRestartEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPrimitiveRestartEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->primitiveRestartEnable);
 }
 #endif /* _WIN64 */
 
@@ -47040,7 +46366,7 @@ static void thunk32_vkCmdSetPrimitiveRestartEnableEXT(void *args)
         VkBool32 primitiveRestartEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPrimitiveRestartEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->primitiveRestartEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPrimitiveRestartEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->primitiveRestartEnable);
 }
 
 #ifdef _WIN64
@@ -47048,7 +46374,7 @@ static void thunk64_vkCmdSetPrimitiveTopology(void *args)
 {
     struct vkCmdSetPrimitiveTopology_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPrimitiveTopology(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->primitiveTopology);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPrimitiveTopology(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->primitiveTopology);
 }
 #endif /* _WIN64 */
 
@@ -47060,7 +46386,7 @@ static void thunk32_vkCmdSetPrimitiveTopology(void *args)
         VkPrimitiveTopology primitiveTopology;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPrimitiveTopology(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->primitiveTopology);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPrimitiveTopology(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->primitiveTopology);
 }
 
 #ifdef _WIN64
@@ -47068,7 +46394,7 @@ static void thunk64_vkCmdSetPrimitiveTopologyEXT(void *args)
 {
     struct vkCmdSetPrimitiveTopologyEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPrimitiveTopologyEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->primitiveTopology);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPrimitiveTopologyEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->primitiveTopology);
 }
 #endif /* _WIN64 */
 
@@ -47080,7 +46406,7 @@ static void thunk32_vkCmdSetPrimitiveTopologyEXT(void *args)
         VkPrimitiveTopology primitiveTopology;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPrimitiveTopologyEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->primitiveTopology);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPrimitiveTopologyEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->primitiveTopology);
 }
 
 #ifdef _WIN64
@@ -47088,7 +46414,7 @@ static void thunk64_vkCmdSetProvokingVertexModeEXT(void *args)
 {
     struct vkCmdSetProvokingVertexModeEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetProvokingVertexModeEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->provokingVertexMode);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetProvokingVertexModeEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->provokingVertexMode);
 }
 #endif /* _WIN64 */
 
@@ -47100,7 +46426,7 @@ static void thunk32_vkCmdSetProvokingVertexModeEXT(void *args)
         VkProvokingVertexModeEXT provokingVertexMode;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetProvokingVertexModeEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->provokingVertexMode);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetProvokingVertexModeEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->provokingVertexMode);
 }
 
 #ifdef _WIN64
@@ -47108,7 +46434,7 @@ static void thunk64_vkCmdSetRasterizationSamplesEXT(void *args)
 {
     struct vkCmdSetRasterizationSamplesEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRasterizationSamplesEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->rasterizationSamples);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRasterizationSamplesEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->rasterizationSamples);
 }
 #endif /* _WIN64 */
 
@@ -47120,7 +46446,7 @@ static void thunk32_vkCmdSetRasterizationSamplesEXT(void *args)
         VkSampleCountFlagBits rasterizationSamples;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRasterizationSamplesEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->rasterizationSamples);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRasterizationSamplesEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->rasterizationSamples);
 }
 
 #ifdef _WIN64
@@ -47128,7 +46454,7 @@ static void thunk64_vkCmdSetRasterizationStreamEXT(void *args)
 {
     struct vkCmdSetRasterizationStreamEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRasterizationStreamEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->rasterizationStream);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRasterizationStreamEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->rasterizationStream);
 }
 #endif /* _WIN64 */
 
@@ -47140,7 +46466,7 @@ static void thunk32_vkCmdSetRasterizationStreamEXT(void *args)
         uint32_t rasterizationStream;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRasterizationStreamEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->rasterizationStream);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRasterizationStreamEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->rasterizationStream);
 }
 
 #ifdef _WIN64
@@ -47148,7 +46474,7 @@ static void thunk64_vkCmdSetRasterizerDiscardEnable(void *args)
 {
     struct vkCmdSetRasterizerDiscardEnable_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRasterizerDiscardEnable(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->rasterizerDiscardEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRasterizerDiscardEnable(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->rasterizerDiscardEnable);
 }
 #endif /* _WIN64 */
 
@@ -47160,7 +46486,7 @@ static void thunk32_vkCmdSetRasterizerDiscardEnable(void *args)
         VkBool32 rasterizerDiscardEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRasterizerDiscardEnable(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->rasterizerDiscardEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRasterizerDiscardEnable(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->rasterizerDiscardEnable);
 }
 
 #ifdef _WIN64
@@ -47168,7 +46494,7 @@ static void thunk64_vkCmdSetRasterizerDiscardEnableEXT(void *args)
 {
     struct vkCmdSetRasterizerDiscardEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRasterizerDiscardEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->rasterizerDiscardEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRasterizerDiscardEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->rasterizerDiscardEnable);
 }
 #endif /* _WIN64 */
 
@@ -47180,7 +46506,7 @@ static void thunk32_vkCmdSetRasterizerDiscardEnableEXT(void *args)
         VkBool32 rasterizerDiscardEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRasterizerDiscardEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->rasterizerDiscardEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRasterizerDiscardEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->rasterizerDiscardEnable);
 }
 
 #ifdef _WIN64
@@ -47188,7 +46514,7 @@ static void thunk64_vkCmdSetRayTracingPipelineStackSizeKHR(void *args)
 {
     struct vkCmdSetRayTracingPipelineStackSizeKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRayTracingPipelineStackSizeKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineStackSize);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRayTracingPipelineStackSizeKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineStackSize);
 }
 #endif /* _WIN64 */
 
@@ -47200,7 +46526,7 @@ static void thunk32_vkCmdSetRayTracingPipelineStackSizeKHR(void *args)
         uint32_t pipelineStackSize;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRayTracingPipelineStackSizeKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineStackSize);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRayTracingPipelineStackSizeKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineStackSize);
 }
 
 #ifdef _WIN64
@@ -47208,7 +46534,7 @@ static void thunk64_vkCmdSetRenderingAttachmentLocations(void *args)
 {
     struct vkCmdSetRenderingAttachmentLocations_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRenderingAttachmentLocations(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pLocationInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRenderingAttachmentLocations(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pLocationInfo);
 }
 #endif /* _WIN64 */
 
@@ -47222,7 +46548,7 @@ static void thunk32_vkCmdSetRenderingAttachmentLocations(void *args)
     VkRenderingAttachmentLocationInfo pLocationInfo_host;
 
     convert_VkRenderingAttachmentLocationInfo_win32_to_host((const VkRenderingAttachmentLocationInfo32 *)UlongToPtr(params->pLocationInfo), &pLocationInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRenderingAttachmentLocations(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pLocationInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRenderingAttachmentLocations(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pLocationInfo_host);
 }
 
 #ifdef _WIN64
@@ -47230,7 +46556,7 @@ static void thunk64_vkCmdSetRenderingAttachmentLocationsKHR(void *args)
 {
     struct vkCmdSetRenderingAttachmentLocationsKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRenderingAttachmentLocationsKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pLocationInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRenderingAttachmentLocationsKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pLocationInfo);
 }
 #endif /* _WIN64 */
 
@@ -47244,7 +46570,7 @@ static void thunk32_vkCmdSetRenderingAttachmentLocationsKHR(void *args)
     VkRenderingAttachmentLocationInfo pLocationInfo_host;
 
     convert_VkRenderingAttachmentLocationInfo_win32_to_host((const VkRenderingAttachmentLocationInfo32 *)UlongToPtr(params->pLocationInfo), &pLocationInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRenderingAttachmentLocationsKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pLocationInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRenderingAttachmentLocationsKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pLocationInfo_host);
 }
 
 #ifdef _WIN64
@@ -47252,7 +46578,7 @@ static void thunk64_vkCmdSetRenderingInputAttachmentIndices(void *args)
 {
     struct vkCmdSetRenderingInputAttachmentIndices_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRenderingInputAttachmentIndices(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInputAttachmentIndexInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRenderingInputAttachmentIndices(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInputAttachmentIndexInfo);
 }
 #endif /* _WIN64 */
 
@@ -47266,7 +46592,7 @@ static void thunk32_vkCmdSetRenderingInputAttachmentIndices(void *args)
     VkRenderingInputAttachmentIndexInfo pInputAttachmentIndexInfo_host;
 
     convert_VkRenderingInputAttachmentIndexInfo_win32_to_host((const VkRenderingInputAttachmentIndexInfo32 *)UlongToPtr(params->pInputAttachmentIndexInfo), &pInputAttachmentIndexInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRenderingInputAttachmentIndices(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInputAttachmentIndexInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRenderingInputAttachmentIndices(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInputAttachmentIndexInfo_host);
 }
 
 #ifdef _WIN64
@@ -47274,7 +46600,7 @@ static void thunk64_vkCmdSetRenderingInputAttachmentIndicesKHR(void *args)
 {
     struct vkCmdSetRenderingInputAttachmentIndicesKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRenderingInputAttachmentIndicesKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInputAttachmentIndexInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRenderingInputAttachmentIndicesKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInputAttachmentIndexInfo);
 }
 #endif /* _WIN64 */
 
@@ -47288,7 +46614,7 @@ static void thunk32_vkCmdSetRenderingInputAttachmentIndicesKHR(void *args)
     VkRenderingInputAttachmentIndexInfo pInputAttachmentIndexInfo_host;
 
     convert_VkRenderingInputAttachmentIndexInfo_win32_to_host((const VkRenderingInputAttachmentIndexInfo32 *)UlongToPtr(params->pInputAttachmentIndexInfo), &pInputAttachmentIndexInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRenderingInputAttachmentIndicesKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInputAttachmentIndexInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRenderingInputAttachmentIndicesKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInputAttachmentIndexInfo_host);
 }
 
 #ifdef _WIN64
@@ -47296,7 +46622,7 @@ static void thunk64_vkCmdSetRepresentativeFragmentTestEnableNV(void *args)
 {
     struct vkCmdSetRepresentativeFragmentTestEnableNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRepresentativeFragmentTestEnableNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->representativeFragmentTestEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRepresentativeFragmentTestEnableNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->representativeFragmentTestEnable);
 }
 #endif /* _WIN64 */
 
@@ -47308,7 +46634,7 @@ static void thunk32_vkCmdSetRepresentativeFragmentTestEnableNV(void *args)
         VkBool32 representativeFragmentTestEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRepresentativeFragmentTestEnableNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->representativeFragmentTestEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRepresentativeFragmentTestEnableNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->representativeFragmentTestEnable);
 }
 
 #ifdef _WIN64
@@ -47316,7 +46642,7 @@ static void thunk64_vkCmdSetSampleLocationsEXT(void *args)
 {
     struct vkCmdSetSampleLocationsEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetSampleLocationsEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pSampleLocationsInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetSampleLocationsEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pSampleLocationsInfo);
 }
 #endif /* _WIN64 */
 
@@ -47330,7 +46656,7 @@ static void thunk32_vkCmdSetSampleLocationsEXT(void *args)
     VkSampleLocationsInfoEXT pSampleLocationsInfo_host;
 
     convert_VkSampleLocationsInfoEXT_win32_to_host((const VkSampleLocationsInfoEXT32 *)UlongToPtr(params->pSampleLocationsInfo), &pSampleLocationsInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetSampleLocationsEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pSampleLocationsInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetSampleLocationsEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pSampleLocationsInfo_host);
 }
 
 #ifdef _WIN64
@@ -47338,7 +46664,7 @@ static void thunk64_vkCmdSetSampleLocationsEnableEXT(void *args)
 {
     struct vkCmdSetSampleLocationsEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetSampleLocationsEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->sampleLocationsEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetSampleLocationsEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->sampleLocationsEnable);
 }
 #endif /* _WIN64 */
 
@@ -47350,7 +46676,7 @@ static void thunk32_vkCmdSetSampleLocationsEnableEXT(void *args)
         VkBool32 sampleLocationsEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetSampleLocationsEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->sampleLocationsEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetSampleLocationsEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->sampleLocationsEnable);
 }
 
 #ifdef _WIN64
@@ -47358,7 +46684,7 @@ static void thunk64_vkCmdSetSampleMaskEXT(void *args)
 {
     struct vkCmdSetSampleMaskEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetSampleMaskEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->samples, params->pSampleMask);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetSampleMaskEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->samples, params->pSampleMask);
 }
 #endif /* _WIN64 */
 
@@ -47371,7 +46697,7 @@ static void thunk32_vkCmdSetSampleMaskEXT(void *args)
         PTR32 pSampleMask;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetSampleMaskEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->samples, (const VkSampleMask *)UlongToPtr(params->pSampleMask));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetSampleMaskEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->samples, (const VkSampleMask *)UlongToPtr(params->pSampleMask));
 }
 
 #ifdef _WIN64
@@ -47379,7 +46705,7 @@ static void thunk64_vkCmdSetScissor(void *args)
 {
     struct vkCmdSetScissor_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetScissor(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstScissor, params->scissorCount, params->pScissors);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetScissor(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstScissor, params->scissorCount, params->pScissors);
 }
 #endif /* _WIN64 */
 
@@ -47393,7 +46719,7 @@ static void thunk32_vkCmdSetScissor(void *args)
         PTR32 pScissors;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetScissor(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstScissor, params->scissorCount, (const VkRect2D *)UlongToPtr(params->pScissors));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetScissor(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstScissor, params->scissorCount, (const VkRect2D *)UlongToPtr(params->pScissors));
 }
 
 #ifdef _WIN64
@@ -47401,7 +46727,7 @@ static void thunk64_vkCmdSetScissorWithCount(void *args)
 {
     struct vkCmdSetScissorWithCount_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetScissorWithCount(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->scissorCount, params->pScissors);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetScissorWithCount(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->scissorCount, params->pScissors);
 }
 #endif /* _WIN64 */
 
@@ -47414,7 +46740,7 @@ static void thunk32_vkCmdSetScissorWithCount(void *args)
         PTR32 pScissors;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetScissorWithCount(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->scissorCount, (const VkRect2D *)UlongToPtr(params->pScissors));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetScissorWithCount(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->scissorCount, (const VkRect2D *)UlongToPtr(params->pScissors));
 }
 
 #ifdef _WIN64
@@ -47422,7 +46748,7 @@ static void thunk64_vkCmdSetScissorWithCountEXT(void *args)
 {
     struct vkCmdSetScissorWithCountEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetScissorWithCountEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->scissorCount, params->pScissors);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetScissorWithCountEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->scissorCount, params->pScissors);
 }
 #endif /* _WIN64 */
 
@@ -47435,7 +46761,7 @@ static void thunk32_vkCmdSetScissorWithCountEXT(void *args)
         PTR32 pScissors;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetScissorWithCountEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->scissorCount, (const VkRect2D *)UlongToPtr(params->pScissors));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetScissorWithCountEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->scissorCount, (const VkRect2D *)UlongToPtr(params->pScissors));
 }
 
 #ifdef _WIN64
@@ -47443,7 +46769,7 @@ static void thunk64_vkCmdSetShadingRateImageEnableNV(void *args)
 {
     struct vkCmdSetShadingRateImageEnableNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetShadingRateImageEnableNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->shadingRateImageEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetShadingRateImageEnableNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->shadingRateImageEnable);
 }
 #endif /* _WIN64 */
 
@@ -47455,7 +46781,7 @@ static void thunk32_vkCmdSetShadingRateImageEnableNV(void *args)
         VkBool32 shadingRateImageEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetShadingRateImageEnableNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->shadingRateImageEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetShadingRateImageEnableNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->shadingRateImageEnable);
 }
 
 #ifdef _WIN64
@@ -47463,7 +46789,7 @@ static void thunk64_vkCmdSetStencilCompareMask(void *args)
 {
     struct vkCmdSetStencilCompareMask_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilCompareMask(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->faceMask, params->compareMask);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilCompareMask(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->faceMask, params->compareMask);
 }
 #endif /* _WIN64 */
 
@@ -47476,7 +46802,7 @@ static void thunk32_vkCmdSetStencilCompareMask(void *args)
         uint32_t compareMask;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilCompareMask(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->faceMask, params->compareMask);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilCompareMask(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->faceMask, params->compareMask);
 }
 
 #ifdef _WIN64
@@ -47484,7 +46810,7 @@ static void thunk64_vkCmdSetStencilOp(void *args)
 {
     struct vkCmdSetStencilOp_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilOp(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->faceMask, params->failOp, params->passOp, params->depthFailOp, params->compareOp);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilOp(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->faceMask, params->failOp, params->passOp, params->depthFailOp, params->compareOp);
 }
 #endif /* _WIN64 */
 
@@ -47500,7 +46826,7 @@ static void thunk32_vkCmdSetStencilOp(void *args)
         VkCompareOp compareOp;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilOp(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->faceMask, params->failOp, params->passOp, params->depthFailOp, params->compareOp);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilOp(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->faceMask, params->failOp, params->passOp, params->depthFailOp, params->compareOp);
 }
 
 #ifdef _WIN64
@@ -47508,7 +46834,7 @@ static void thunk64_vkCmdSetStencilOpEXT(void *args)
 {
     struct vkCmdSetStencilOpEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilOpEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->faceMask, params->failOp, params->passOp, params->depthFailOp, params->compareOp);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilOpEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->faceMask, params->failOp, params->passOp, params->depthFailOp, params->compareOp);
 }
 #endif /* _WIN64 */
 
@@ -47524,7 +46850,7 @@ static void thunk32_vkCmdSetStencilOpEXT(void *args)
         VkCompareOp compareOp;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilOpEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->faceMask, params->failOp, params->passOp, params->depthFailOp, params->compareOp);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilOpEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->faceMask, params->failOp, params->passOp, params->depthFailOp, params->compareOp);
 }
 
 #ifdef _WIN64
@@ -47532,7 +46858,7 @@ static void thunk64_vkCmdSetStencilReference(void *args)
 {
     struct vkCmdSetStencilReference_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilReference(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->faceMask, params->reference);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilReference(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->faceMask, params->reference);
 }
 #endif /* _WIN64 */
 
@@ -47545,7 +46871,7 @@ static void thunk32_vkCmdSetStencilReference(void *args)
         uint32_t reference;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilReference(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->faceMask, params->reference);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilReference(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->faceMask, params->reference);
 }
 
 #ifdef _WIN64
@@ -47553,7 +46879,7 @@ static void thunk64_vkCmdSetStencilTestEnable(void *args)
 {
     struct vkCmdSetStencilTestEnable_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilTestEnable(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stencilTestEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilTestEnable(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stencilTestEnable);
 }
 #endif /* _WIN64 */
 
@@ -47565,7 +46891,7 @@ static void thunk32_vkCmdSetStencilTestEnable(void *args)
         VkBool32 stencilTestEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilTestEnable(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stencilTestEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilTestEnable(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stencilTestEnable);
 }
 
 #ifdef _WIN64
@@ -47573,7 +46899,7 @@ static void thunk64_vkCmdSetStencilTestEnableEXT(void *args)
 {
     struct vkCmdSetStencilTestEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilTestEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stencilTestEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilTestEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stencilTestEnable);
 }
 #endif /* _WIN64 */
 
@@ -47585,7 +46911,7 @@ static void thunk32_vkCmdSetStencilTestEnableEXT(void *args)
         VkBool32 stencilTestEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilTestEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stencilTestEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilTestEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stencilTestEnable);
 }
 
 #ifdef _WIN64
@@ -47593,7 +46919,7 @@ static void thunk64_vkCmdSetStencilWriteMask(void *args)
 {
     struct vkCmdSetStencilWriteMask_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilWriteMask(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->faceMask, params->writeMask);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilWriteMask(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->faceMask, params->writeMask);
 }
 #endif /* _WIN64 */
 
@@ -47606,7 +46932,7 @@ static void thunk32_vkCmdSetStencilWriteMask(void *args)
         uint32_t writeMask;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilWriteMask(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->faceMask, params->writeMask);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilWriteMask(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->faceMask, params->writeMask);
 }
 
 #ifdef _WIN64
@@ -47614,7 +46940,7 @@ static void thunk64_vkCmdSetTessellationDomainOriginEXT(void *args)
 {
     struct vkCmdSetTessellationDomainOriginEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetTessellationDomainOriginEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->domainOrigin);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetTessellationDomainOriginEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->domainOrigin);
 }
 #endif /* _WIN64 */
 
@@ -47626,7 +46952,7 @@ static void thunk32_vkCmdSetTessellationDomainOriginEXT(void *args)
         VkTessellationDomainOrigin domainOrigin;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetTessellationDomainOriginEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->domainOrigin);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetTessellationDomainOriginEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->domainOrigin);
 }
 
 #ifdef _WIN64
@@ -47634,7 +46960,7 @@ static void thunk64_vkCmdSetVertexInputEXT(void *args)
 {
     struct vkCmdSetVertexInputEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetVertexInputEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->vertexBindingDescriptionCount, params->pVertexBindingDescriptions, params->vertexAttributeDescriptionCount, params->pVertexAttributeDescriptions);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetVertexInputEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->vertexBindingDescriptionCount, params->pVertexBindingDescriptions, params->vertexAttributeDescriptionCount, params->pVertexAttributeDescriptions);
 }
 #endif /* _WIN64 */
 
@@ -47656,7 +46982,7 @@ static void thunk32_vkCmdSetVertexInputEXT(void *args)
     init_conversion_context(ctx);
     pVertexBindingDescriptions_host = convert_VkVertexInputBindingDescription2EXT_array_win32_to_host(ctx, (const VkVertexInputBindingDescription2EXT32 *)UlongToPtr(params->pVertexBindingDescriptions), params->vertexBindingDescriptionCount);
     pVertexAttributeDescriptions_host = convert_VkVertexInputAttributeDescription2EXT_array_win32_to_host(ctx, (const VkVertexInputAttributeDescription2EXT32 *)UlongToPtr(params->pVertexAttributeDescriptions), params->vertexAttributeDescriptionCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetVertexInputEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->vertexBindingDescriptionCount, pVertexBindingDescriptions_host, params->vertexAttributeDescriptionCount, pVertexAttributeDescriptions_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetVertexInputEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->vertexBindingDescriptionCount, pVertexBindingDescriptions_host, params->vertexAttributeDescriptionCount, pVertexAttributeDescriptions_host);
     free_conversion_context(ctx);
 }
 
@@ -47665,7 +46991,7 @@ static void thunk64_vkCmdSetViewport(void *args)
 {
     struct vkCmdSetViewport_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewport(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstViewport, params->viewportCount, params->pViewports);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewport(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstViewport, params->viewportCount, params->pViewports);
 }
 #endif /* _WIN64 */
 
@@ -47679,7 +47005,7 @@ static void thunk32_vkCmdSetViewport(void *args)
         PTR32 pViewports;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewport(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstViewport, params->viewportCount, (const VkViewport *)UlongToPtr(params->pViewports));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewport(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstViewport, params->viewportCount, (const VkViewport *)UlongToPtr(params->pViewports));
 }
 
 #ifdef _WIN64
@@ -47687,7 +47013,7 @@ static void thunk64_vkCmdSetViewportShadingRatePaletteNV(void *args)
 {
     struct vkCmdSetViewportShadingRatePaletteNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewportShadingRatePaletteNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstViewport, params->viewportCount, params->pShadingRatePalettes);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewportShadingRatePaletteNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstViewport, params->viewportCount, params->pShadingRatePalettes);
 }
 #endif /* _WIN64 */
 
@@ -47706,7 +47032,7 @@ static void thunk32_vkCmdSetViewportShadingRatePaletteNV(void *args)
 
     init_conversion_context(ctx);
     pShadingRatePalettes_host = convert_VkShadingRatePaletteNV_array_win32_to_host(ctx, (const VkShadingRatePaletteNV32 *)UlongToPtr(params->pShadingRatePalettes), params->viewportCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewportShadingRatePaletteNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstViewport, params->viewportCount, pShadingRatePalettes_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewportShadingRatePaletteNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstViewport, params->viewportCount, pShadingRatePalettes_host);
     free_conversion_context(ctx);
 }
 
@@ -47715,7 +47041,7 @@ static void thunk64_vkCmdSetViewportSwizzleNV(void *args)
 {
     struct vkCmdSetViewportSwizzleNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewportSwizzleNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstViewport, params->viewportCount, params->pViewportSwizzles);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewportSwizzleNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstViewport, params->viewportCount, params->pViewportSwizzles);
 }
 #endif /* _WIN64 */
 
@@ -47729,7 +47055,7 @@ static void thunk32_vkCmdSetViewportSwizzleNV(void *args)
         PTR32 pViewportSwizzles;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewportSwizzleNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstViewport, params->viewportCount, (const VkViewportSwizzleNV *)UlongToPtr(params->pViewportSwizzles));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewportSwizzleNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstViewport, params->viewportCount, (const VkViewportSwizzleNV *)UlongToPtr(params->pViewportSwizzles));
 }
 
 #ifdef _WIN64
@@ -47737,7 +47063,7 @@ static void thunk64_vkCmdSetViewportWScalingEnableNV(void *args)
 {
     struct vkCmdSetViewportWScalingEnableNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewportWScalingEnableNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->viewportWScalingEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewportWScalingEnableNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->viewportWScalingEnable);
 }
 #endif /* _WIN64 */
 
@@ -47749,7 +47075,7 @@ static void thunk32_vkCmdSetViewportWScalingEnableNV(void *args)
         VkBool32 viewportWScalingEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewportWScalingEnableNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->viewportWScalingEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewportWScalingEnableNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->viewportWScalingEnable);
 }
 
 #ifdef _WIN64
@@ -47757,7 +47083,7 @@ static void thunk64_vkCmdSetViewportWScalingNV(void *args)
 {
     struct vkCmdSetViewportWScalingNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewportWScalingNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstViewport, params->viewportCount, params->pViewportWScalings);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewportWScalingNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstViewport, params->viewportCount, params->pViewportWScalings);
 }
 #endif /* _WIN64 */
 
@@ -47771,7 +47097,7 @@ static void thunk32_vkCmdSetViewportWScalingNV(void *args)
         PTR32 pViewportWScalings;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewportWScalingNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstViewport, params->viewportCount, (const VkViewportWScalingNV *)UlongToPtr(params->pViewportWScalings));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewportWScalingNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstViewport, params->viewportCount, (const VkViewportWScalingNV *)UlongToPtr(params->pViewportWScalings));
 }
 
 #ifdef _WIN64
@@ -47779,7 +47105,7 @@ static void thunk64_vkCmdSetViewportWithCount(void *args)
 {
     struct vkCmdSetViewportWithCount_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewportWithCount(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->viewportCount, params->pViewports);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewportWithCount(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->viewportCount, params->pViewports);
 }
 #endif /* _WIN64 */
 
@@ -47792,7 +47118,7 @@ static void thunk32_vkCmdSetViewportWithCount(void *args)
         PTR32 pViewports;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewportWithCount(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->viewportCount, (const VkViewport *)UlongToPtr(params->pViewports));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewportWithCount(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->viewportCount, (const VkViewport *)UlongToPtr(params->pViewports));
 }
 
 #ifdef _WIN64
@@ -47800,7 +47126,7 @@ static void thunk64_vkCmdSetViewportWithCountEXT(void *args)
 {
     struct vkCmdSetViewportWithCountEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewportWithCountEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->viewportCount, params->pViewports);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewportWithCountEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->viewportCount, params->pViewports);
 }
 #endif /* _WIN64 */
 
@@ -47813,7 +47139,7 @@ static void thunk32_vkCmdSetViewportWithCountEXT(void *args)
         PTR32 pViewports;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewportWithCountEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->viewportCount, (const VkViewport *)UlongToPtr(params->pViewports));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewportWithCountEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->viewportCount, (const VkViewport *)UlongToPtr(params->pViewports));
 }
 
 #ifdef _WIN64
@@ -47821,7 +47147,7 @@ static void thunk64_vkCmdSubpassShadingHUAWEI(void *args)
 {
     struct vkCmdSubpassShadingHUAWEI_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSubpassShadingHUAWEI(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSubpassShadingHUAWEI(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer);
 }
 #endif /* _WIN64 */
 
@@ -47832,7 +47158,7 @@ static void thunk32_vkCmdSubpassShadingHUAWEI(void *args)
         PTR32 commandBuffer;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSubpassShadingHUAWEI(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSubpassShadingHUAWEI(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
 }
 
 #ifdef _WIN64
@@ -47840,7 +47166,7 @@ static void thunk64_vkCmdTraceRaysIndirect2KHR(void *args)
 {
     struct vkCmdTraceRaysIndirect2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdTraceRaysIndirect2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->indirectDeviceAddress);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdTraceRaysIndirect2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->indirectDeviceAddress);
 }
 #endif /* _WIN64 */
 
@@ -47852,7 +47178,7 @@ static void thunk32_vkCmdTraceRaysIndirect2KHR(void *args)
         VkDeviceAddress DECLSPEC_ALIGN(8) indirectDeviceAddress;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdTraceRaysIndirect2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->indirectDeviceAddress);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdTraceRaysIndirect2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->indirectDeviceAddress);
 }
 
 #ifdef _WIN64
@@ -47860,7 +47186,7 @@ static void thunk64_vkCmdTraceRaysIndirectKHR(void *args)
 {
     struct vkCmdTraceRaysIndirectKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdTraceRaysIndirectKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRaygenShaderBindingTable, params->pMissShaderBindingTable, params->pHitShaderBindingTable, params->pCallableShaderBindingTable, params->indirectDeviceAddress);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdTraceRaysIndirectKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRaygenShaderBindingTable, params->pMissShaderBindingTable, params->pHitShaderBindingTable, params->pCallableShaderBindingTable, params->indirectDeviceAddress);
 }
 #endif /* _WIN64 */
 
@@ -47884,7 +47210,7 @@ static void thunk32_vkCmdTraceRaysIndirectKHR(void *args)
     convert_VkStridedDeviceAddressRegionKHR_win32_to_host((const VkStridedDeviceAddressRegionKHR32 *)UlongToPtr(params->pMissShaderBindingTable), &pMissShaderBindingTable_host);
     convert_VkStridedDeviceAddressRegionKHR_win32_to_host((const VkStridedDeviceAddressRegionKHR32 *)UlongToPtr(params->pHitShaderBindingTable), &pHitShaderBindingTable_host);
     convert_VkStridedDeviceAddressRegionKHR_win32_to_host((const VkStridedDeviceAddressRegionKHR32 *)UlongToPtr(params->pCallableShaderBindingTable), &pCallableShaderBindingTable_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdTraceRaysIndirectKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRaygenShaderBindingTable_host, &pMissShaderBindingTable_host, &pHitShaderBindingTable_host, &pCallableShaderBindingTable_host, params->indirectDeviceAddress);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdTraceRaysIndirectKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRaygenShaderBindingTable_host, &pMissShaderBindingTable_host, &pHitShaderBindingTable_host, &pCallableShaderBindingTable_host, params->indirectDeviceAddress);
 }
 
 #ifdef _WIN64
@@ -47892,7 +47218,7 @@ static void thunk64_vkCmdTraceRaysKHR(void *args)
 {
     struct vkCmdTraceRaysKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdTraceRaysKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRaygenShaderBindingTable, params->pMissShaderBindingTable, params->pHitShaderBindingTable, params->pCallableShaderBindingTable, params->width, params->height, params->depth);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdTraceRaysKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRaygenShaderBindingTable, params->pMissShaderBindingTable, params->pHitShaderBindingTable, params->pCallableShaderBindingTable, params->width, params->height, params->depth);
 }
 #endif /* _WIN64 */
 
@@ -47918,7 +47244,7 @@ static void thunk32_vkCmdTraceRaysKHR(void *args)
     convert_VkStridedDeviceAddressRegionKHR_win32_to_host((const VkStridedDeviceAddressRegionKHR32 *)UlongToPtr(params->pMissShaderBindingTable), &pMissShaderBindingTable_host);
     convert_VkStridedDeviceAddressRegionKHR_win32_to_host((const VkStridedDeviceAddressRegionKHR32 *)UlongToPtr(params->pHitShaderBindingTable), &pHitShaderBindingTable_host);
     convert_VkStridedDeviceAddressRegionKHR_win32_to_host((const VkStridedDeviceAddressRegionKHR32 *)UlongToPtr(params->pCallableShaderBindingTable), &pCallableShaderBindingTable_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdTraceRaysKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRaygenShaderBindingTable_host, &pMissShaderBindingTable_host, &pHitShaderBindingTable_host, &pCallableShaderBindingTable_host, params->width, params->height, params->depth);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdTraceRaysKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRaygenShaderBindingTable_host, &pMissShaderBindingTable_host, &pHitShaderBindingTable_host, &pCallableShaderBindingTable_host, params->width, params->height, params->depth);
 }
 
 #ifdef _WIN64
@@ -47926,7 +47252,7 @@ static void thunk64_vkCmdTraceRaysNV(void *args)
 {
     struct vkCmdTraceRaysNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdTraceRaysNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->raygenShaderBindingTableBuffer, params->raygenShaderBindingOffset, params->missShaderBindingTableBuffer, params->missShaderBindingOffset, params->missShaderBindingStride, params->hitShaderBindingTableBuffer, params->hitShaderBindingOffset, params->hitShaderBindingStride, params->callableShaderBindingTableBuffer, params->callableShaderBindingOffset, params->callableShaderBindingStride, params->width, params->height, params->depth);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdTraceRaysNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->raygenShaderBindingTableBuffer, params->raygenShaderBindingOffset, params->missShaderBindingTableBuffer, params->missShaderBindingOffset, params->missShaderBindingStride, params->hitShaderBindingTableBuffer, params->hitShaderBindingOffset, params->hitShaderBindingStride, params->callableShaderBindingTableBuffer, params->callableShaderBindingOffset, params->callableShaderBindingStride, params->width, params->height, params->depth);
 }
 #endif /* _WIN64 */
 
@@ -47951,7 +47277,7 @@ static void thunk32_vkCmdTraceRaysNV(void *args)
         uint32_t depth;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdTraceRaysNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->raygenShaderBindingTableBuffer, params->raygenShaderBindingOffset, params->missShaderBindingTableBuffer, params->missShaderBindingOffset, params->missShaderBindingStride, params->hitShaderBindingTableBuffer, params->hitShaderBindingOffset, params->hitShaderBindingStride, params->callableShaderBindingTableBuffer, params->callableShaderBindingOffset, params->callableShaderBindingStride, params->width, params->height, params->depth);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdTraceRaysNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->raygenShaderBindingTableBuffer, params->raygenShaderBindingOffset, params->missShaderBindingTableBuffer, params->missShaderBindingOffset, params->missShaderBindingStride, params->hitShaderBindingTableBuffer, params->hitShaderBindingOffset, params->hitShaderBindingStride, params->callableShaderBindingTableBuffer, params->callableShaderBindingOffset, params->callableShaderBindingStride, params->width, params->height, params->depth);
 }
 
 #ifdef _WIN64
@@ -47959,7 +47285,7 @@ static void thunk64_vkCmdUpdateBuffer(void *args)
 {
     struct vkCmdUpdateBuffer_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdUpdateBuffer(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->dstBuffer, params->dstOffset, params->dataSize, params->pData);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdUpdateBuffer(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->dstBuffer, params->dstOffset, params->dataSize, params->pData);
 }
 #endif /* _WIN64 */
 
@@ -47974,7 +47300,7 @@ static void thunk32_vkCmdUpdateBuffer(void *args)
         PTR32 pData;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdUpdateBuffer(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->dstBuffer, params->dstOffset, params->dataSize, (const void *)UlongToPtr(params->pData));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdUpdateBuffer(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->dstBuffer, params->dstOffset, params->dataSize, (const void *)UlongToPtr(params->pData));
 }
 
 #ifdef _WIN64
@@ -47982,7 +47308,7 @@ static void thunk64_vkCmdUpdatePipelineIndirectBufferNV(void *args)
 {
     struct vkCmdUpdatePipelineIndirectBufferNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdUpdatePipelineIndirectBufferNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->pipeline);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdUpdatePipelineIndirectBufferNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->pipeline);
 }
 #endif /* _WIN64 */
 
@@ -47995,7 +47321,7 @@ static void thunk32_vkCmdUpdatePipelineIndirectBufferNV(void *args)
         VkPipeline DECLSPEC_ALIGN(8) pipeline;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdUpdatePipelineIndirectBufferNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->pipeline);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdUpdatePipelineIndirectBufferNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->pipeline);
 }
 
 #ifdef _WIN64
@@ -48003,7 +47329,7 @@ static void thunk64_vkCmdWaitEvents(void *args)
 {
     struct vkCmdWaitEvents_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWaitEvents(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->eventCount, params->pEvents, params->srcStageMask, params->dstStageMask, params->memoryBarrierCount, params->pMemoryBarriers, params->bufferMemoryBarrierCount, params->pBufferMemoryBarriers, params->imageMemoryBarrierCount, params->pImageMemoryBarriers);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWaitEvents(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->eventCount, params->pEvents, params->srcStageMask, params->dstStageMask, params->memoryBarrierCount, params->pMemoryBarriers, params->bufferMemoryBarrierCount, params->pBufferMemoryBarriers, params->imageMemoryBarrierCount, params->pImageMemoryBarriers);
 }
 #endif /* _WIN64 */
 
@@ -48033,7 +47359,7 @@ static void thunk32_vkCmdWaitEvents(void *args)
     pMemoryBarriers_host = convert_VkMemoryBarrier_array_win32_to_host(ctx, (const VkMemoryBarrier32 *)UlongToPtr(params->pMemoryBarriers), params->memoryBarrierCount);
     pBufferMemoryBarriers_host = convert_VkBufferMemoryBarrier_array_win32_to_host(ctx, (const VkBufferMemoryBarrier32 *)UlongToPtr(params->pBufferMemoryBarriers), params->bufferMemoryBarrierCount);
     pImageMemoryBarriers_host = convert_VkImageMemoryBarrier_array_win32_to_host(ctx, (const VkImageMemoryBarrier32 *)UlongToPtr(params->pImageMemoryBarriers), params->imageMemoryBarrierCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWaitEvents(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->eventCount, (const VkEvent *)UlongToPtr(params->pEvents), params->srcStageMask, params->dstStageMask, params->memoryBarrierCount, pMemoryBarriers_host, params->bufferMemoryBarrierCount, pBufferMemoryBarriers_host, params->imageMemoryBarrierCount, pImageMemoryBarriers_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWaitEvents(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->eventCount, (const VkEvent *)UlongToPtr(params->pEvents), params->srcStageMask, params->dstStageMask, params->memoryBarrierCount, pMemoryBarriers_host, params->bufferMemoryBarrierCount, pBufferMemoryBarriers_host, params->imageMemoryBarrierCount, pImageMemoryBarriers_host);
     free_conversion_context(ctx);
 }
 
@@ -48042,7 +47368,7 @@ static void thunk64_vkCmdWaitEvents2(void *args)
 {
     struct vkCmdWaitEvents2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWaitEvents2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->eventCount, params->pEvents, params->pDependencyInfos);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWaitEvents2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->eventCount, params->pEvents, params->pDependencyInfos);
 }
 #endif /* _WIN64 */
 
@@ -48061,7 +47387,7 @@ static void thunk32_vkCmdWaitEvents2(void *args)
 
     init_conversion_context(ctx);
     pDependencyInfos_host = convert_VkDependencyInfo_array_win32_to_host(ctx, (const VkDependencyInfo32 *)UlongToPtr(params->pDependencyInfos), params->eventCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWaitEvents2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->eventCount, (const VkEvent *)UlongToPtr(params->pEvents), pDependencyInfos_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWaitEvents2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->eventCount, (const VkEvent *)UlongToPtr(params->pEvents), pDependencyInfos_host);
     free_conversion_context(ctx);
 }
 
@@ -48070,7 +47396,7 @@ static void thunk64_vkCmdWaitEvents2KHR(void *args)
 {
     struct vkCmdWaitEvents2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWaitEvents2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->eventCount, params->pEvents, params->pDependencyInfos);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWaitEvents2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->eventCount, params->pEvents, params->pDependencyInfos);
 }
 #endif /* _WIN64 */
 
@@ -48089,7 +47415,7 @@ static void thunk32_vkCmdWaitEvents2KHR(void *args)
 
     init_conversion_context(ctx);
     pDependencyInfos_host = convert_VkDependencyInfo_array_win32_to_host(ctx, (const VkDependencyInfo32 *)UlongToPtr(params->pDependencyInfos), params->eventCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWaitEvents2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->eventCount, (const VkEvent *)UlongToPtr(params->pEvents), pDependencyInfos_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWaitEvents2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->eventCount, (const VkEvent *)UlongToPtr(params->pEvents), pDependencyInfos_host);
     free_conversion_context(ctx);
 }
 
@@ -48098,7 +47424,7 @@ static void thunk64_vkCmdWriteAccelerationStructuresPropertiesKHR(void *args)
 {
     struct vkCmdWriteAccelerationStructuresPropertiesKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteAccelerationStructuresPropertiesKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->accelerationStructureCount, params->pAccelerationStructures, params->queryType, params->queryPool, params->firstQuery);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteAccelerationStructuresPropertiesKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->accelerationStructureCount, params->pAccelerationStructures, params->queryType, params->queryPool, params->firstQuery);
 }
 #endif /* _WIN64 */
 
@@ -48114,7 +47440,7 @@ static void thunk32_vkCmdWriteAccelerationStructuresPropertiesKHR(void *args)
         uint32_t firstQuery;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteAccelerationStructuresPropertiesKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->accelerationStructureCount, (const VkAccelerationStructureKHR *)UlongToPtr(params->pAccelerationStructures), params->queryType, params->queryPool, params->firstQuery);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteAccelerationStructuresPropertiesKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->accelerationStructureCount, (const VkAccelerationStructureKHR *)UlongToPtr(params->pAccelerationStructures), params->queryType, params->queryPool, params->firstQuery);
 }
 
 #ifdef _WIN64
@@ -48122,7 +47448,7 @@ static void thunk64_vkCmdWriteAccelerationStructuresPropertiesNV(void *args)
 {
     struct vkCmdWriteAccelerationStructuresPropertiesNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteAccelerationStructuresPropertiesNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->accelerationStructureCount, params->pAccelerationStructures, params->queryType, params->queryPool, params->firstQuery);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteAccelerationStructuresPropertiesNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->accelerationStructureCount, params->pAccelerationStructures, params->queryType, params->queryPool, params->firstQuery);
 }
 #endif /* _WIN64 */
 
@@ -48138,7 +47464,7 @@ static void thunk32_vkCmdWriteAccelerationStructuresPropertiesNV(void *args)
         uint32_t firstQuery;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteAccelerationStructuresPropertiesNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->accelerationStructureCount, (const VkAccelerationStructureNV *)UlongToPtr(params->pAccelerationStructures), params->queryType, params->queryPool, params->firstQuery);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteAccelerationStructuresPropertiesNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->accelerationStructureCount, (const VkAccelerationStructureNV *)UlongToPtr(params->pAccelerationStructures), params->queryType, params->queryPool, params->firstQuery);
 }
 
 #ifdef _WIN64
@@ -48146,7 +47472,7 @@ static void thunk64_vkCmdWriteBufferMarker2AMD(void *args)
 {
     struct vkCmdWriteBufferMarker2AMD_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteBufferMarker2AMD(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stage, params->dstBuffer, params->dstOffset, params->marker);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteBufferMarker2AMD(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stage, params->dstBuffer, params->dstOffset, params->marker);
 }
 #endif /* _WIN64 */
 
@@ -48161,7 +47487,7 @@ static void thunk32_vkCmdWriteBufferMarker2AMD(void *args)
         uint32_t marker;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteBufferMarker2AMD(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stage, params->dstBuffer, params->dstOffset, params->marker);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteBufferMarker2AMD(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stage, params->dstBuffer, params->dstOffset, params->marker);
 }
 
 #ifdef _WIN64
@@ -48169,7 +47495,7 @@ static void thunk64_vkCmdWriteBufferMarkerAMD(void *args)
 {
     struct vkCmdWriteBufferMarkerAMD_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteBufferMarkerAMD(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineStage, params->dstBuffer, params->dstOffset, params->marker);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteBufferMarkerAMD(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineStage, params->dstBuffer, params->dstOffset, params->marker);
 }
 #endif /* _WIN64 */
 
@@ -48184,7 +47510,7 @@ static void thunk32_vkCmdWriteBufferMarkerAMD(void *args)
         uint32_t marker;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteBufferMarkerAMD(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineStage, params->dstBuffer, params->dstOffset, params->marker);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteBufferMarkerAMD(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineStage, params->dstBuffer, params->dstOffset, params->marker);
 }
 
 #ifdef _WIN64
@@ -48192,7 +47518,7 @@ static void thunk64_vkCmdWriteMicromapsPropertiesEXT(void *args)
 {
     struct vkCmdWriteMicromapsPropertiesEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteMicromapsPropertiesEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->micromapCount, params->pMicromaps, params->queryType, params->queryPool, params->firstQuery);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteMicromapsPropertiesEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->micromapCount, params->pMicromaps, params->queryType, params->queryPool, params->firstQuery);
 }
 #endif /* _WIN64 */
 
@@ -48208,7 +47534,7 @@ static void thunk32_vkCmdWriteMicromapsPropertiesEXT(void *args)
         uint32_t firstQuery;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteMicromapsPropertiesEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->micromapCount, (const VkMicromapEXT *)UlongToPtr(params->pMicromaps), params->queryType, params->queryPool, params->firstQuery);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteMicromapsPropertiesEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->micromapCount, (const VkMicromapEXT *)UlongToPtr(params->pMicromaps), params->queryType, params->queryPool, params->firstQuery);
 }
 
 #ifdef _WIN64
@@ -48216,7 +47542,7 @@ static void thunk64_vkCmdWriteTimestamp(void *args)
 {
     struct vkCmdWriteTimestamp_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteTimestamp(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineStage, params->queryPool, params->query);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteTimestamp(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineStage, params->queryPool, params->query);
 }
 #endif /* _WIN64 */
 
@@ -48230,7 +47556,7 @@ static void thunk32_vkCmdWriteTimestamp(void *args)
         uint32_t query;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteTimestamp(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineStage, params->queryPool, params->query);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteTimestamp(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineStage, params->queryPool, params->query);
 }
 
 #ifdef _WIN64
@@ -48238,7 +47564,7 @@ static void thunk64_vkCmdWriteTimestamp2(void *args)
 {
     struct vkCmdWriteTimestamp2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteTimestamp2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stage, params->queryPool, params->query);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteTimestamp2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stage, params->queryPool, params->query);
 }
 #endif /* _WIN64 */
 
@@ -48252,7 +47578,7 @@ static void thunk32_vkCmdWriteTimestamp2(void *args)
         uint32_t query;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteTimestamp2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stage, params->queryPool, params->query);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteTimestamp2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stage, params->queryPool, params->query);
 }
 
 #ifdef _WIN64
@@ -48260,7 +47586,7 @@ static void thunk64_vkCmdWriteTimestamp2KHR(void *args)
 {
     struct vkCmdWriteTimestamp2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteTimestamp2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stage, params->queryPool, params->query);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteTimestamp2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stage, params->queryPool, params->query);
 }
 #endif /* _WIN64 */
 
@@ -48274,7 +47600,7 @@ static void thunk32_vkCmdWriteTimestamp2KHR(void *args)
         uint32_t query;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteTimestamp2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stage, params->queryPool, params->query);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteTimestamp2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stage, params->queryPool, params->query);
 }
 
 #ifdef _WIN64
@@ -49388,16 +48714,10 @@ static NTSTATUS thunk32_vkCreateEvent(void *args)
 static NTSTATUS thunk64_vkCreateFence(void *args)
 {
     struct vkCreateFence_params *params = args;
-    VkFenceCreateInfo pCreateInfo_host;
-    struct conversion_context local_ctx;
-    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pFence);
 
-    init_conversion_context(ctx);
-    convert_VkFenceCreateInfo_win64_to_host(ctx, params->pCreateInfo, &pCreateInfo_host);
-    params->result = vk_funcs->p_vkCreateFence(params->device, &pCreateInfo_host, params->pAllocator, params->pFence);
-    free_conversion_context(ctx);
+    params->result = vulkan_device_from_handle(params->device)->p_vkCreateFence(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pFence);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -49420,7 +48740,7 @@ static NTSTATUS thunk32_vkCreateFence(void *args)
 
     init_conversion_context(ctx);
     convert_VkFenceCreateInfo_win32_to_host(ctx, (const VkFenceCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
-    params->result = vk_funcs->p_vkCreateFence((VkDevice)UlongToPtr(params->device), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkFence *)UlongToPtr(params->pFence));
+    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateFence(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkFence *)UlongToPtr(params->pFence));
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -50303,16 +49623,10 @@ static NTSTATUS thunk32_vkCreateSamplerYcbcrConversionKHR(void *args)
 static NTSTATUS thunk64_vkCreateSemaphore(void *args)
 {
     struct vkCreateSemaphore_params *params = args;
-    VkSemaphoreCreateInfo pCreateInfo_host;
-    struct conversion_context local_ctx;
-    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pSemaphore);
 
-    init_conversion_context(ctx);
-    convert_VkSemaphoreCreateInfo_win64_to_host(ctx, params->pCreateInfo, &pCreateInfo_host);
-    params->result = vk_funcs->p_vkCreateSemaphore(params->device, &pCreateInfo_host, params->pAllocator, params->pSemaphore);
-    free_conversion_context(ctx);
+    params->result = vulkan_device_from_handle(params->device)->p_vkCreateSemaphore(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pSemaphore);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -50335,7 +49649,7 @@ static NTSTATUS thunk32_vkCreateSemaphore(void *args)
 
     init_conversion_context(ctx);
     convert_VkSemaphoreCreateInfo_win32_to_host(ctx, (const VkSemaphoreCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
-    params->result = vk_funcs->p_vkCreateSemaphore((VkDevice)UlongToPtr(params->device), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkSemaphore *)UlongToPtr(params->pSemaphore));
+    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateSemaphore(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkSemaphore *)UlongToPtr(params->pSemaphore));
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -51240,7 +50554,7 @@ static NTSTATUS thunk64_vkDestroyFence(void *args)
 
     TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->fence), params->pAllocator);
 
-    vk_funcs->p_vkDestroyFence(params->device, params->fence, params->pAllocator);
+    vulkan_device_from_handle(params->device)->p_vkDestroyFence(vulkan_device_from_handle(params->device)->host.device, params->fence, NULL);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -51256,7 +50570,7 @@ static NTSTATUS thunk32_vkDestroyFence(void *args)
 
     TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->fence), params->pAllocator);
 
-    vk_funcs->p_vkDestroyFence((VkDevice)UlongToPtr(params->device), params->fence, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator));
+    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyFence(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->fence, NULL);
     return STATUS_SUCCESS;
 }
 
@@ -51812,7 +51126,7 @@ static NTSTATUS thunk64_vkDestroySemaphore(void *args)
 
     TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->semaphore), params->pAllocator);
 
-    vk_funcs->p_vkDestroySemaphore(params->device, params->semaphore, params->pAllocator);
+    vulkan_device_from_handle(params->device)->p_vkDestroySemaphore(vulkan_device_from_handle(params->device)->host.device, params->semaphore, NULL);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -51828,7 +51142,7 @@ static NTSTATUS thunk32_vkDestroySemaphore(void *args)
 
     TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->semaphore), params->pAllocator);
 
-    vk_funcs->p_vkDestroySemaphore((VkDevice)UlongToPtr(params->device), params->semaphore, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator));
+    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroySemaphore(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->semaphore, NULL);
     return STATUS_SUCCESS;
 }
 
@@ -52108,7 +51422,7 @@ static NTSTATUS thunk64_vkEndCommandBuffer(void *args)
 
     TRACE("%p\n", params->commandBuffer);
 
-    params->result = vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkEndCommandBuffer(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer);
+    params->result = wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkEndCommandBuffer(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -52123,7 +51437,7 @@ static NTSTATUS thunk32_vkEndCommandBuffer(void *args)
 
     TRACE("%#x\n", params->commandBuffer);
 
-    params->result = vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkEndCommandBuffer(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
+    params->result = wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkEndCommandBuffer(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
     return STATUS_SUCCESS;
 }
 
@@ -54376,36 +53690,6 @@ static NTSTATUS thunk32_vkGetFenceStatus(void *args)
     return STATUS_SUCCESS;
 }
 
-#ifdef _WIN64
-static NTSTATUS thunk64_vkGetFenceWin32HandleKHR(void *args)
-{
-    struct vkGetFenceWin32HandleKHR_params *params = args;
-
-    TRACE("%p, %p, %p\n", params->device, params->pGetWin32HandleInfo, params->pHandle);
-
-    params->result = vk_funcs->p_vkGetFenceWin32HandleKHR(params->device, params->pGetWin32HandleInfo, params->pHandle);
-    return STATUS_SUCCESS;
-}
-#endif /* _WIN64 */
-
-static NTSTATUS thunk32_vkGetFenceWin32HandleKHR(void *args)
-{
-    struct
-    {
-        PTR32 device;
-        PTR32 pGetWin32HandleInfo;
-        PTR32 pHandle;
-        VkResult result;
-    } *params = args;
-    VkFenceGetWin32HandleInfoKHR pGetWin32HandleInfo_host;
-
-    TRACE("%#x, %#x, %#x\n", params->device, params->pGetWin32HandleInfo, params->pHandle);
-
-    convert_VkFenceGetWin32HandleInfoKHR_win32_to_host((const VkFenceGetWin32HandleInfoKHR32 *)UlongToPtr(params->pGetWin32HandleInfo), &pGetWin32HandleInfo_host);
-    params->result = vk_funcs->p_vkGetFenceWin32HandleKHR((VkDevice)UlongToPtr(params->device), &pGetWin32HandleInfo_host, (HANDLE *)UlongToPtr(params->pHandle));
-    return STATUS_SUCCESS;
-}
-
 #ifdef _WIN64
 static NTSTATUS thunk64_vkGetFramebufferTilePropertiesQCOM(void *args)
 {
@@ -55598,7 +54882,7 @@ static NTSTATUS thunk64_vkGetPhysicalDeviceExternalSemaphoreProperties(void *arg
 
     TRACE("%p, %p, %p\n", params->physicalDevice, params->pExternalSemaphoreInfo, params->pExternalSemaphoreProperties);
 
-    vk_funcs->p_vkGetPhysicalDeviceExternalSemaphoreProperties(params->physicalDevice, params->pExternalSemaphoreInfo, params->pExternalSemaphoreProperties);
+    wine_vkGetPhysicalDeviceExternalSemaphoreProperties(params->physicalDevice, params->pExternalSemaphoreInfo, params->pExternalSemaphoreProperties);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -55621,7 +54905,7 @@ static NTSTATUS thunk32_vkGetPhysicalDeviceExternalSemaphoreProperties(void *arg
     init_conversion_context(ctx);
     convert_VkPhysicalDeviceExternalSemaphoreInfo_win32_to_host(ctx, (const VkPhysicalDeviceExternalSemaphoreInfo32 *)UlongToPtr(params->pExternalSemaphoreInfo), &pExternalSemaphoreInfo_host);
     convert_VkExternalSemaphoreProperties_win32_to_host((VkExternalSemaphoreProperties32 *)UlongToPtr(params->pExternalSemaphoreProperties), &pExternalSemaphoreProperties_host);
-    vk_funcs->p_vkGetPhysicalDeviceExternalSemaphoreProperties((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pExternalSemaphoreInfo_host, &pExternalSemaphoreProperties_host);
+    wine_vkGetPhysicalDeviceExternalSemaphoreProperties((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pExternalSemaphoreInfo_host, &pExternalSemaphoreProperties_host);
     convert_VkExternalSemaphoreProperties_host_to_win32(&pExternalSemaphoreProperties_host, (VkExternalSemaphoreProperties32 *)UlongToPtr(params->pExternalSemaphoreProperties));
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
@@ -55634,7 +54918,7 @@ static NTSTATUS thunk64_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(void *
 
     TRACE("%p, %p, %p\n", params->physicalDevice, params->pExternalSemaphoreInfo, params->pExternalSemaphoreProperties);
 
-    vk_funcs->p_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(params->physicalDevice, params->pExternalSemaphoreInfo, params->pExternalSemaphoreProperties);
+    wine_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(params->physicalDevice, params->pExternalSemaphoreInfo, params->pExternalSemaphoreProperties);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -55657,7 +54941,7 @@ static NTSTATUS thunk32_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(void *
     init_conversion_context(ctx);
     convert_VkPhysicalDeviceExternalSemaphoreInfo_win32_to_host(ctx, (const VkPhysicalDeviceExternalSemaphoreInfo32 *)UlongToPtr(params->pExternalSemaphoreInfo), &pExternalSemaphoreInfo_host);
     convert_VkExternalSemaphoreProperties_win32_to_host((VkExternalSemaphoreProperties32 *)UlongToPtr(params->pExternalSemaphoreProperties), &pExternalSemaphoreProperties_host);
-    vk_funcs->p_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pExternalSemaphoreInfo_host, &pExternalSemaphoreProperties_host);
+    wine_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pExternalSemaphoreInfo_host, &pExternalSemaphoreProperties_host);
     convert_VkExternalSemaphoreProperties_host_to_win32(&pExternalSemaphoreProperties_host, (VkExternalSemaphoreProperties32 *)UlongToPtr(params->pExternalSemaphoreProperties));
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
@@ -57837,36 +57121,6 @@ static NTSTATUS thunk32_vkGetSemaphoreCounterValueKHR(void *args)
     return STATUS_SUCCESS;
 }
 
-#ifdef _WIN64
-static NTSTATUS thunk64_vkGetSemaphoreWin32HandleKHR(void *args)
-{
-    struct vkGetSemaphoreWin32HandleKHR_params *params = args;
-
-    TRACE("%p, %p, %p\n", params->device, params->pGetWin32HandleInfo, params->pHandle);
-
-    params->result = vk_funcs->p_vkGetSemaphoreWin32HandleKHR(params->device, params->pGetWin32HandleInfo, params->pHandle);
-    return STATUS_SUCCESS;
-}
-#endif /* _WIN64 */
-
-static NTSTATUS thunk32_vkGetSemaphoreWin32HandleKHR(void *args)
-{
-    struct
-    {
-        PTR32 device;
-        PTR32 pGetWin32HandleInfo;
-        PTR32 pHandle;
-        VkResult result;
-    } *params = args;
-    VkSemaphoreGetWin32HandleInfoKHR pGetWin32HandleInfo_host;
-
-    TRACE("%#x, %#x, %#x\n", params->device, params->pGetWin32HandleInfo, params->pHandle);
-
-    convert_VkSemaphoreGetWin32HandleInfoKHR_win32_to_host((const VkSemaphoreGetWin32HandleInfoKHR32 *)UlongToPtr(params->pGetWin32HandleInfo), &pGetWin32HandleInfo_host);
-    params->result = vk_funcs->p_vkGetSemaphoreWin32HandleKHR((VkDevice)UlongToPtr(params->device), &pGetWin32HandleInfo_host, (HANDLE *)UlongToPtr(params->pHandle));
-    return STATUS_SUCCESS;
-}
-
 #ifdef _WIN64
 static NTSTATUS thunk64_vkGetShaderBinaryDataEXT(void *args)
 {
@@ -58192,64 +57446,6 @@ static NTSTATUS thunk32_vkGetVideoSessionMemoryRequirementsKHR(void *args)
     return STATUS_SUCCESS;
 }
 
-#ifdef _WIN64
-static NTSTATUS thunk64_vkImportFenceWin32HandleKHR(void *args)
-{
-    struct vkImportFenceWin32HandleKHR_params *params = args;
-
-    TRACE("%p, %p\n", params->device, params->pImportFenceWin32HandleInfo);
-
-    params->result = vk_funcs->p_vkImportFenceWin32HandleKHR(params->device, params->pImportFenceWin32HandleInfo);
-    return STATUS_SUCCESS;
-}
-#endif /* _WIN64 */
-
-static NTSTATUS thunk32_vkImportFenceWin32HandleKHR(void *args)
-{
-    struct
-    {
-        PTR32 device;
-        PTR32 pImportFenceWin32HandleInfo;
-        VkResult result;
-    } *params = args;
-    VkImportFenceWin32HandleInfoKHR pImportFenceWin32HandleInfo_host;
-
-    TRACE("%#x, %#x\n", params->device, params->pImportFenceWin32HandleInfo);
-
-    convert_VkImportFenceWin32HandleInfoKHR_win32_to_host((const VkImportFenceWin32HandleInfoKHR32 *)UlongToPtr(params->pImportFenceWin32HandleInfo), &pImportFenceWin32HandleInfo_host);
-    params->result = vk_funcs->p_vkImportFenceWin32HandleKHR((VkDevice)UlongToPtr(params->device), &pImportFenceWin32HandleInfo_host);
-    return STATUS_SUCCESS;
-}
-
-#ifdef _WIN64
-static NTSTATUS thunk64_vkImportSemaphoreWin32HandleKHR(void *args)
-{
-    struct vkImportSemaphoreWin32HandleKHR_params *params = args;
-
-    TRACE("%p, %p\n", params->device, params->pImportSemaphoreWin32HandleInfo);
-
-    params->result = vk_funcs->p_vkImportSemaphoreWin32HandleKHR(params->device, params->pImportSemaphoreWin32HandleInfo);
-    return STATUS_SUCCESS;
-}
-#endif /* _WIN64 */
-
-static NTSTATUS thunk32_vkImportSemaphoreWin32HandleKHR(void *args)
-{
-    struct
-    {
-        PTR32 device;
-        PTR32 pImportSemaphoreWin32HandleInfo;
-        VkResult result;
-    } *params = args;
-    VkImportSemaphoreWin32HandleInfoKHR pImportSemaphoreWin32HandleInfo_host;
-
-    TRACE("%#x, %#x\n", params->device, params->pImportSemaphoreWin32HandleInfo);
-
-    convert_VkImportSemaphoreWin32HandleInfoKHR_win32_to_host((const VkImportSemaphoreWin32HandleInfoKHR32 *)UlongToPtr(params->pImportSemaphoreWin32HandleInfo), &pImportSemaphoreWin32HandleInfo_host);
-    params->result = vk_funcs->p_vkImportSemaphoreWin32HandleKHR((VkDevice)UlongToPtr(params->device), &pImportSemaphoreWin32HandleInfo_host);
-    return STATUS_SUCCESS;
-}
-
 #ifdef _WIN64
 static NTSTATUS thunk64_vkInitializePerformanceApiINTEL(void *args)
 {
@@ -58663,16 +57859,10 @@ static NTSTATUS thunk32_vkQueueNotifyOutOfBandNV(void *args)
 static NTSTATUS thunk64_vkQueuePresentKHR(void *args)
 {
     struct vkQueuePresentKHR_params *params = args;
-    VkPresentInfoKHR pPresentInfo_host;
-    struct conversion_context local_ctx;
-    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%p, %p\n", params->queue, params->pPresentInfo);
 
-    init_conversion_context(ctx);
-    convert_VkPresentInfoKHR_win64_to_unwrapped_host(ctx, params->pPresentInfo, &pPresentInfo_host);
-    params->result = vk_funcs->p_vkQueuePresentKHR(params->queue, &pPresentInfo_host);
-    free_conversion_context(ctx);
+    params->result = vk_funcs->p_vkQueuePresentKHR(params->queue, params->pPresentInfo);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -58736,8 +57926,8 @@ static NTSTATUS thunk64_vkQueueSubmit(void *args)
     TRACE("%p, %u, %p, 0x%s\n", params->queue, params->submitCount, params->pSubmits, wine_dbgstr_longlong(params->fence));
 
     init_conversion_context(ctx);
-    pSubmits_host = convert_VkSubmitInfo_array_win64_to_unwrapped_host(ctx, params->pSubmits, params->submitCount);
-    params->result = vk_funcs->p_vkQueueSubmit(params->queue, params->submitCount, pSubmits_host, params->fence);
+    pSubmits_host = convert_VkSubmitInfo_array_win64_to_host(ctx, params->pSubmits, params->submitCount);
+    params->result = vulkan_queue_from_handle(params->queue)->device->p_vkQueueSubmit(vulkan_queue_from_handle(params->queue)->host.queue, params->submitCount, pSubmits_host, params->fence);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -58760,8 +57950,8 @@ static NTSTATUS thunk32_vkQueueSubmit(void *args)
     TRACE("%#x, %u, %#x, 0x%s\n", params->queue, params->submitCount, params->pSubmits, wine_dbgstr_longlong(params->fence));
 
     init_conversion_context(ctx);
-    pSubmits_host = convert_VkSubmitInfo_array_win32_to_unwrapped_host(ctx, (const VkSubmitInfo32 *)UlongToPtr(params->pSubmits), params->submitCount);
-    params->result = vk_funcs->p_vkQueueSubmit((VkQueue)UlongToPtr(params->queue), params->submitCount, pSubmits_host, params->fence);
+    pSubmits_host = convert_VkSubmitInfo_array_win32_to_host(ctx, (const VkSubmitInfo32 *)UlongToPtr(params->pSubmits), params->submitCount);
+    params->result = vulkan_queue_from_handle((VkQueue)UlongToPtr(params->queue))->device->p_vkQueueSubmit(vulkan_queue_from_handle((VkQueue)UlongToPtr(params->queue))->host.queue, params->submitCount, pSubmits_host, params->fence);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -58777,8 +57967,8 @@ static NTSTATUS thunk64_vkQueueSubmit2(void *args)
     TRACE("%p, %u, %p, 0x%s\n", params->queue, params->submitCount, params->pSubmits, wine_dbgstr_longlong(params->fence));
 
     init_conversion_context(ctx);
-    pSubmits_host = convert_VkSubmitInfo2_array_win64_to_unwrapped_host(ctx, params->pSubmits, params->submitCount);
-    params->result = vk_funcs->p_vkQueueSubmit2(params->queue, params->submitCount, pSubmits_host, params->fence);
+    pSubmits_host = convert_VkSubmitInfo2_array_win64_to_host(ctx, params->pSubmits, params->submitCount);
+    params->result = vulkan_queue_from_handle(params->queue)->device->p_vkQueueSubmit2(vulkan_queue_from_handle(params->queue)->host.queue, params->submitCount, pSubmits_host, params->fence);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -58801,8 +57991,8 @@ static NTSTATUS thunk32_vkQueueSubmit2(void *args)
     TRACE("%#x, %u, %#x, 0x%s\n", params->queue, params->submitCount, params->pSubmits, wine_dbgstr_longlong(params->fence));
 
     init_conversion_context(ctx);
-    pSubmits_host = convert_VkSubmitInfo2_array_win32_to_unwrapped_host(ctx, (const VkSubmitInfo232 *)UlongToPtr(params->pSubmits), params->submitCount);
-    params->result = vk_funcs->p_vkQueueSubmit2((VkQueue)UlongToPtr(params->queue), params->submitCount, pSubmits_host, params->fence);
+    pSubmits_host = convert_VkSubmitInfo2_array_win32_to_host(ctx, (const VkSubmitInfo232 *)UlongToPtr(params->pSubmits), params->submitCount);
+    params->result = vulkan_queue_from_handle((VkQueue)UlongToPtr(params->queue))->device->p_vkQueueSubmit2(vulkan_queue_from_handle((VkQueue)UlongToPtr(params->queue))->host.queue, params->submitCount, pSubmits_host, params->fence);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -58818,8 +58008,8 @@ static NTSTATUS thunk64_vkQueueSubmit2KHR(void *args)
     TRACE("%p, %u, %p, 0x%s\n", params->queue, params->submitCount, params->pSubmits, wine_dbgstr_longlong(params->fence));
 
     init_conversion_context(ctx);
-    pSubmits_host = convert_VkSubmitInfo2_array_win64_to_unwrapped_host(ctx, params->pSubmits, params->submitCount);
-    params->result = vk_funcs->p_vkQueueSubmit2KHR(params->queue, params->submitCount, pSubmits_host, params->fence);
+    pSubmits_host = convert_VkSubmitInfo2_array_win64_to_host(ctx, params->pSubmits, params->submitCount);
+    params->result = vulkan_queue_from_handle(params->queue)->device->p_vkQueueSubmit2KHR(vulkan_queue_from_handle(params->queue)->host.queue, params->submitCount, pSubmits_host, params->fence);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -58842,8 +58032,8 @@ static NTSTATUS thunk32_vkQueueSubmit2KHR(void *args)
     TRACE("%#x, %u, %#x, 0x%s\n", params->queue, params->submitCount, params->pSubmits, wine_dbgstr_longlong(params->fence));
 
     init_conversion_context(ctx);
-    pSubmits_host = convert_VkSubmitInfo2_array_win32_to_unwrapped_host(ctx, (const VkSubmitInfo232 *)UlongToPtr(params->pSubmits), params->submitCount);
-    params->result = vk_funcs->p_vkQueueSubmit2KHR((VkQueue)UlongToPtr(params->queue), params->submitCount, pSubmits_host, params->fence);
+    pSubmits_host = convert_VkSubmitInfo2_array_win32_to_host(ctx, (const VkSubmitInfo232 *)UlongToPtr(params->pSubmits), params->submitCount);
+    params->result = vulkan_queue_from_handle((VkQueue)UlongToPtr(params->queue))->device->p_vkQueueSubmit2KHR(vulkan_queue_from_handle((VkQueue)UlongToPtr(params->queue))->host.queue, params->submitCount, pSubmits_host, params->fence);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -59025,7 +58215,7 @@ static NTSTATUS thunk64_vkResetCommandBuffer(void *args)
 
     TRACE("%p, %#x\n", params->commandBuffer, params->flags);
 
-    params->result = vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkResetCommandBuffer(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->flags);
+    params->result = wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkResetCommandBuffer(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->flags);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -59041,7 +58231,7 @@ static NTSTATUS thunk32_vkResetCommandBuffer(void *args)
 
     TRACE("%#x, %#x\n", params->commandBuffer, params->flags);
 
-    params->result = vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkResetCommandBuffer(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->flags);
+    params->result = wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkResetCommandBuffer(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->flags);
     return STATUS_SUCCESS;
 }
 
@@ -60395,11 +59585,9 @@ static const char * const vk_device_extensions[] =
     "VK_KHR_dynamic_rendering",
     "VK_KHR_dynamic_rendering_local_read",
     "VK_KHR_external_fence",
-    "VK_KHR_external_fence_win32",
     "VK_KHR_external_memory",
     "VK_KHR_external_memory_win32",
     "VK_KHR_external_semaphore",
-    "VK_KHR_external_semaphore_win32",
     "VK_KHR_format_feature_flags2",
     "VK_KHR_fragment_shader_barycentric",
     "VK_KHR_fragment_shading_rate",
@@ -60481,7 +59669,6 @@ static const char * const vk_device_extensions[] =
     "VK_KHR_video_maintenance1",
     "VK_KHR_video_queue",
     "VK_KHR_vulkan_memory_model",
-    "VK_KHR_win32_keyed_mutex",
     "VK_KHR_workgroup_memory_explicit_layout",
     "VK_KHR_zero_initialize_workgroup_memory",
     "VK_MESA_image_alignment_control",
@@ -61139,7 +60326,6 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     thunk64_vkGetEncodedVideoSessionParametersKHR,
     thunk64_vkGetEventStatus,
     thunk64_vkGetFenceStatus,
-    thunk64_vkGetFenceWin32HandleKHR,
     thunk64_vkGetFramebufferTilePropertiesQCOM,
     thunk64_vkGetGeneratedCommandsMemoryRequirementsEXT,
     thunk64_vkGetGeneratedCommandsMemoryRequirementsNV,
@@ -61243,7 +60429,6 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     thunk64_vkGetSamplerOpaqueCaptureDescriptorDataEXT,
     thunk64_vkGetSemaphoreCounterValue,
     thunk64_vkGetSemaphoreCounterValueKHR,
-    thunk64_vkGetSemaphoreWin32HandleKHR,
     thunk64_vkGetShaderBinaryDataEXT,
     thunk64_vkGetShaderInfoAMD,
     thunk64_vkGetShaderModuleCreateInfoIdentifierEXT,
@@ -61254,8 +60439,6 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     thunk64_vkGetTensorViewOpaqueCaptureDescriptorDataARM,
     thunk64_vkGetValidationCacheDataEXT,
     thunk64_vkGetVideoSessionMemoryRequirementsKHR,
-    thunk64_vkImportFenceWin32HandleKHR,
-    thunk64_vkImportSemaphoreWin32HandleKHR,
     thunk64_vkInitializePerformanceApiINTEL,
     thunk64_vkInvalidateMappedMemoryRanges,
     thunk64_vkLatencySleepNV,
@@ -61817,7 +61000,6 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     thunk32_vkGetEncodedVideoSessionParametersKHR,
     thunk32_vkGetEventStatus,
     thunk32_vkGetFenceStatus,
-    thunk32_vkGetFenceWin32HandleKHR,
     thunk32_vkGetFramebufferTilePropertiesQCOM,
     thunk32_vkGetGeneratedCommandsMemoryRequirementsEXT,
     thunk32_vkGetGeneratedCommandsMemoryRequirementsNV,
@@ -61921,7 +61103,6 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     thunk32_vkGetSamplerOpaqueCaptureDescriptorDataEXT,
     thunk32_vkGetSemaphoreCounterValue,
     thunk32_vkGetSemaphoreCounterValueKHR,
-    thunk32_vkGetSemaphoreWin32HandleKHR,
     thunk32_vkGetShaderBinaryDataEXT,
     thunk32_vkGetShaderInfoAMD,
     thunk32_vkGetShaderModuleCreateInfoIdentifierEXT,
@@ -61932,8 +61113,6 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     thunk32_vkGetTensorViewOpaqueCaptureDescriptorDataARM,
     thunk32_vkGetValidationCacheDataEXT,
     thunk32_vkGetVideoSessionMemoryRequirementsKHR,
-    thunk32_vkImportFenceWin32HandleKHR,
-    thunk32_vkImportSemaphoreWin32HandleKHR,
     thunk32_vkInitializePerformanceApiINTEL,
     thunk32_vkInvalidateMappedMemoryRanges,
     thunk32_vkLatencySleepNV,
diff --git b/dlls/winevulkan/vulkan_thunks.h a/dlls/winevulkan/vulkan_thunks.h
index 6c0c704355d..a7736bb7923 100644
--- b/dlls/winevulkan/vulkan_thunks.h
+++ a/dlls/winevulkan/vulkan_thunks.h
@@ -50,5 +50,7 @@ VkResult wine_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(VkPhysicalDevice ph
 VkResult wine_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR(VkPhysicalDevice physicalDevice, uint32_t *pTimeDomainCount, VkTimeDomainKHR *pTimeDomains);
 void wine_vkGetPhysicalDeviceExternalFenceProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties);
 void wine_vkGetPhysicalDeviceExternalFencePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties);
+void wine_vkGetPhysicalDeviceExternalSemaphoreProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, VkExternalSemaphoreProperties *pExternalSemaphoreProperties);
+void wine_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, VkExternalSemaphoreProperties *pExternalSemaphoreProperties);
 
 #endif /* __WINE_VULKAN_THUNKS_H */
diff --git b/include/wine/vulkan.h a/include/wine/vulkan.h
index e4a71a38bb8..4336a154ecc 100644
--- b/include/wine/vulkan.h
+++ a/include/wine/vulkan.h
@@ -180,14 +180,10 @@ typedef struct _XDisplay Display;
 #define VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME "VK_KHR_external_memory_win32"
 #define VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION 1
 #define VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME "VK_KHR_external_memory_fd"
-#define VK_KHR_WIN32_KEYED_MUTEX_SPEC_VERSION 1
-#define VK_KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME "VK_KHR_win32_keyed_mutex"
 #define VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION 1
 #define VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME "VK_KHR_external_semaphore_capabilities"
 #define VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION 1
 #define VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME "VK_KHR_external_semaphore"
-#define VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION 1
-#define VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME "VK_KHR_external_semaphore_win32"
 #define VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION 1
 #define VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME "VK_KHR_external_semaphore_fd"
 #define VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION 2
@@ -234,8 +230,6 @@ typedef struct _XDisplay Display;
 #define VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME "VK_KHR_external_fence_capabilities"
 #define VK_KHR_EXTERNAL_FENCE_SPEC_VERSION 1
 #define VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME "VK_KHR_external_fence"
-#define VK_KHR_EXTERNAL_FENCE_WIN32_SPEC_VERSION 1
-#define VK_KHR_EXTERNAL_FENCE_WIN32_EXTENSION_NAME "VK_KHR_external_fence_win32"
 #define VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION 1
 #define VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME "VK_KHR_external_fence_fd"
 #define VK_KHR_PERFORMANCE_QUERY_SPEC_VERSION 1
@@ -5456,14 +5450,9 @@ typedef enum VkStructureType
     VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR = 1000074000,
     VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR = 1000074001,
     VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR = 1000074002,
-    VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = 1000075000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 1000076000,
     VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES = 1000076001,
     VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO = 1000077000,
-    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078000,
-    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078001,
-    VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR = 1000078002,
-    VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = 1000078003,
     VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000,
     VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR = 1000079001,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES = 1000080000,
@@ -5499,9 +5488,6 @@ typedef enum VkStructureType
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 1000112000,
     VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES = 1000112001,
     VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO = 1000113000,
-    VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114000,
-    VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114001,
-    VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR = 1000114002,
     VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR = 1000115000,
     VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR = 1000115001,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR = 1000116000,
@@ -11300,16 +11286,6 @@ typedef struct VkCuModuleTexturingModeCreateInfoNVX
     VkBool32 use64bitTexturing;
 } VkCuModuleTexturingModeCreateInfoNVX;
 
-typedef struct VkD3D12FenceSubmitInfoKHR
-{
-    VkStructureType sType;
-    const void *pNext;
-    uint32_t waitSemaphoreValuesCount;
-    const uint64_t *pWaitSemaphoreValues;
-    uint32_t signalSemaphoreValuesCount;
-    const uint64_t *pSignalSemaphoreValues;
-} VkD3D12FenceSubmitInfoKHR;
-
 typedef struct VkDataGraphPipelineCompilerControlCreateInfoARM
 {
     VkStructureType sType;
@@ -11995,15 +11971,6 @@ typedef struct VkExportFenceCreateInfo
 } VkExportFenceCreateInfo;
 typedef VkExportFenceCreateInfo VkExportFenceCreateInfoKHR;
 
-typedef struct VkExportFenceWin32HandleInfoKHR
-{
-    VkStructureType sType;
-    const void *pNext;
-    const SECURITY_ATTRIBUTES *pAttributes;
-    DWORD dwAccess;
-    LPCWSTR name;
-} VkExportFenceWin32HandleInfoKHR;
-
 typedef struct VkExportMemoryAllocateInfo
 {
     VkStructureType sType;
@@ -12029,15 +11996,6 @@ typedef struct VkExportSemaphoreCreateInfo
 } VkExportSemaphoreCreateInfo;
 typedef VkExportSemaphoreCreateInfo VkExportSemaphoreCreateInfoKHR;
 
-typedef struct VkExportSemaphoreWin32HandleInfoKHR
-{
-    VkStructureType sType;
-    const void *pNext;
-    const SECURITY_ATTRIBUTES *pAttributes;
-    DWORD dwAccess;
-    LPCWSTR name;
-} VkExportSemaphoreWin32HandleInfoKHR;
-
 typedef struct VkExternalBufferProperties
 {
     VkStructureType sType;
@@ -12126,14 +12084,6 @@ typedef struct VkFenceGetFdInfoKHR
     VkExternalFenceHandleTypeFlagBits handleType;
 } VkFenceGetFdInfoKHR;
 
-typedef struct VkFenceGetWin32HandleInfoKHR
-{
-    VkStructureType sType;
-    const void *pNext;
-    VkFence WINE_VK_ALIGN(8) fence;
-    VkExternalFenceHandleTypeFlagBits handleType;
-} VkFenceGetWin32HandleInfoKHR;
-
 typedef struct VkFilterCubicImageViewImageFormatPropertiesEXT
 {
     VkStructureType sType;
@@ -12626,17 +12576,6 @@ typedef struct VkImportFenceFdInfoKHR
     int fd;
 } VkImportFenceFdInfoKHR;
 
-typedef struct VkImportFenceWin32HandleInfoKHR
-{
-    VkStructureType sType;
-    const void *pNext;
-    VkFence WINE_VK_ALIGN(8) fence;
-    VkFenceImportFlags flags;
-    VkExternalFenceHandleTypeFlagBits handleType;
-    HANDLE handle;
-    LPCWSTR name;
-} VkImportFenceWin32HandleInfoKHR;
-
 typedef struct VkImportMemoryFdInfoKHR
 {
     VkStructureType sType;
@@ -12680,17 +12619,6 @@ typedef struct VkImportSemaphoreFdInfoKHR
     int fd;
 } VkImportSemaphoreFdInfoKHR;
 
-typedef struct VkImportSemaphoreWin32HandleInfoKHR
-{
-    VkStructureType sType;
-    const void *pNext;
-    VkSemaphore WINE_VK_ALIGN(8) semaphore;
-    VkSemaphoreImportFlags flags;
-    VkExternalSemaphoreHandleTypeFlagBits handleType;
-    HANDLE handle;
-    LPCWSTR name;
-} VkImportSemaphoreWin32HandleInfoKHR;
-
 typedef struct VkIndirectCommandsLayoutCreateInfoEXT
 {
     VkStructureType sType;
@@ -17520,14 +17448,6 @@ typedef struct VkSemaphoreGetFdInfoKHR
     VkExternalSemaphoreHandleTypeFlagBits handleType;
 } VkSemaphoreGetFdInfoKHR;
 
-typedef struct VkSemaphoreGetWin32HandleInfoKHR
-{
-    VkStructureType sType;
-    const void *pNext;
-    VkSemaphore WINE_VK_ALIGN(8) semaphore;
-    VkExternalSemaphoreHandleTypeFlagBits handleType;
-} VkSemaphoreGetWin32HandleInfoKHR;
-
 typedef struct VkSemaphoreSignalInfo
 {
     VkStructureType sType;
@@ -18724,19 +18644,6 @@ typedef struct VkWaylandSurfaceCreateInfoKHR
     struct wl_surface *surface;
 } VkWaylandSurfaceCreateInfoKHR;
 
-typedef struct VkWin32KeyedMutexAcquireReleaseInfoKHR
-{
-    VkStructureType sType;
-    const void *pNext;
-    uint32_t acquireCount;
-    const VkDeviceMemory *pAcquireSyncs;
-    const uint64_t *pAcquireKeys;
-    const uint32_t *pAcquireTimeouts;
-    uint32_t releaseCount;
-    const VkDeviceMemory *pReleaseSyncs;
-    const uint64_t *pReleaseKeys;
-} VkWin32KeyedMutexAcquireReleaseInfoKHR;
-
 typedef struct VkWin32SurfaceCreateInfoKHR
 {
     VkStructureType sType;
@@ -19303,7 +19210,6 @@ typedef VkResult (VKAPI_PTR *PFN_vkGetEncodedVideoSessionParametersKHR)(VkDevice
 typedef VkResult (VKAPI_PTR *PFN_vkGetEventStatus)(VkDevice, VkEvent);
 typedef VkResult (VKAPI_PTR *PFN_vkGetFenceFdKHR)(VkDevice, const VkFenceGetFdInfoKHR *, int *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetFenceStatus)(VkDevice, VkFence);
-typedef VkResult (VKAPI_PTR *PFN_vkGetFenceWin32HandleKHR)(VkDevice, const VkFenceGetWin32HandleInfoKHR *, HANDLE *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetFramebufferTilePropertiesQCOM)(VkDevice, VkFramebuffer, uint32_t *, VkTilePropertiesQCOM *);
 typedef void (VKAPI_PTR *PFN_vkGetGeneratedCommandsMemoryRequirementsEXT)(VkDevice, const VkGeneratedCommandsMemoryRequirementsInfoEXT *, VkMemoryRequirements2 *);
 typedef void (VKAPI_PTR *PFN_vkGetGeneratedCommandsMemoryRequirementsNV)(VkDevice, const VkGeneratedCommandsMemoryRequirementsInfoNV *, VkMemoryRequirements2 *);
@@ -19416,7 +19322,6 @@ typedef VkResult (VKAPI_PTR *PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT)(VkD
 typedef VkResult (VKAPI_PTR *PFN_vkGetSemaphoreCounterValue)(VkDevice, VkSemaphore, uint64_t *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetSemaphoreCounterValueKHR)(VkDevice, VkSemaphore, uint64_t *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetSemaphoreFdKHR)(VkDevice, const VkSemaphoreGetFdInfoKHR *, int *);
-typedef VkResult (VKAPI_PTR *PFN_vkGetSemaphoreWin32HandleKHR)(VkDevice, const VkSemaphoreGetWin32HandleInfoKHR *, HANDLE *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetShaderBinaryDataEXT)(VkDevice, VkShaderEXT, size_t *, void *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetShaderInfoAMD)(VkDevice, VkPipeline, VkShaderStageFlagBits, VkShaderInfoTypeAMD, size_t *, void *);
 typedef void (VKAPI_PTR *PFN_vkGetShaderModuleCreateInfoIdentifierEXT)(VkDevice, const VkShaderModuleCreateInfo *, VkShaderModuleIdentifierEXT *);
@@ -19428,9 +19333,7 @@ typedef VkResult (VKAPI_PTR *PFN_vkGetTensorViewOpaqueCaptureDescriptorDataARM)(
 typedef VkResult (VKAPI_PTR *PFN_vkGetValidationCacheDataEXT)(VkDevice, VkValidationCacheEXT, size_t *, void *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetVideoSessionMemoryRequirementsKHR)(VkDevice, VkVideoSessionKHR, uint32_t *, VkVideoSessionMemoryRequirementsKHR *);
 typedef VkResult (VKAPI_PTR *PFN_vkImportFenceFdKHR)(VkDevice, const VkImportFenceFdInfoKHR *);
-typedef VkResult (VKAPI_PTR *PFN_vkImportFenceWin32HandleKHR)(VkDevice, const VkImportFenceWin32HandleInfoKHR *);
 typedef VkResult (VKAPI_PTR *PFN_vkImportSemaphoreFdKHR)(VkDevice, const VkImportSemaphoreFdInfoKHR *);
-typedef VkResult (VKAPI_PTR *PFN_vkImportSemaphoreWin32HandleKHR)(VkDevice, const VkImportSemaphoreWin32HandleInfoKHR *);
 typedef VkResult (VKAPI_PTR *PFN_vkInitializePerformanceApiINTEL)(VkDevice, const VkInitializePerformanceApiInfoINTEL *);
 typedef VkResult (VKAPI_PTR *PFN_vkInvalidateMappedMemoryRanges)(VkDevice, uint32_t, const VkMappedMemoryRange *);
 typedef VkResult (VKAPI_PTR *PFN_vkLatencySleepNV)(VkDevice, VkSwapchainKHR, const VkLatencySleepInfoNV *);
@@ -19988,7 +19891,6 @@ VkResult VKAPI_CALL vkGetEncodedVideoSessionParametersKHR(VkDevice device, const
 VkResult VKAPI_CALL vkGetEventStatus(VkDevice device, VkEvent event);
 VkResult VKAPI_CALL vkGetFenceFdKHR(VkDevice device, const VkFenceGetFdInfoKHR *pGetFdInfo, int *pFd);
 VkResult VKAPI_CALL vkGetFenceStatus(VkDevice device, VkFence fence);
-VkResult VKAPI_CALL vkGetFenceWin32HandleKHR(VkDevice device, const VkFenceGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle);
 VkResult VKAPI_CALL vkGetFramebufferTilePropertiesQCOM(VkDevice device, VkFramebuffer framebuffer, uint32_t *pPropertiesCount, VkTilePropertiesQCOM *pProperties);
 void VKAPI_CALL vkGetGeneratedCommandsMemoryRequirementsEXT(VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoEXT *pInfo, VkMemoryRequirements2 *pMemoryRequirements);
 void VKAPI_CALL vkGetGeneratedCommandsMemoryRequirementsNV(VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoNV *pInfo, VkMemoryRequirements2 *pMemoryRequirements);
@@ -20101,7 +20003,6 @@ VkResult VKAPI_CALL vkGetSamplerOpaqueCaptureDescriptorDataEXT(VkDevice device,
 VkResult VKAPI_CALL vkGetSemaphoreCounterValue(VkDevice device, VkSemaphore semaphore, uint64_t *pValue);
 VkResult VKAPI_CALL vkGetSemaphoreCounterValueKHR(VkDevice device, VkSemaphore semaphore, uint64_t *pValue);
 VkResult VKAPI_CALL vkGetSemaphoreFdKHR(VkDevice device, const VkSemaphoreGetFdInfoKHR *pGetFdInfo, int *pFd);
-VkResult VKAPI_CALL vkGetSemaphoreWin32HandleKHR(VkDevice device, const VkSemaphoreGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle);
 VkResult VKAPI_CALL vkGetShaderBinaryDataEXT(VkDevice device, VkShaderEXT shader, size_t *pDataSize, void *pData);
 VkResult VKAPI_CALL vkGetShaderInfoAMD(VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage, VkShaderInfoTypeAMD infoType, size_t *pInfoSize, void *pInfo);
 void VKAPI_CALL vkGetShaderModuleCreateInfoIdentifierEXT(VkDevice device, const VkShaderModuleCreateInfo *pCreateInfo, VkShaderModuleIdentifierEXT *pIdentifier);
@@ -20113,9 +20014,7 @@ VkResult VKAPI_CALL vkGetTensorViewOpaqueCaptureDescriptorDataARM(VkDevice devic
 VkResult VKAPI_CALL vkGetValidationCacheDataEXT(VkDevice device, VkValidationCacheEXT validationCache, size_t *pDataSize, void *pData);
 VkResult VKAPI_CALL vkGetVideoSessionMemoryRequirementsKHR(VkDevice device, VkVideoSessionKHR videoSession, uint32_t *pMemoryRequirementsCount, VkVideoSessionMemoryRequirementsKHR *pMemoryRequirements);
 VkResult VKAPI_CALL vkImportFenceFdKHR(VkDevice device, const VkImportFenceFdInfoKHR *pImportFenceFdInfo);
-VkResult VKAPI_CALL vkImportFenceWin32HandleKHR(VkDevice device, const VkImportFenceWin32HandleInfoKHR *pImportFenceWin32HandleInfo);
 VkResult VKAPI_CALL vkImportSemaphoreFdKHR(VkDevice device, const VkImportSemaphoreFdInfoKHR *pImportSemaphoreFdInfo);
-VkResult VKAPI_CALL vkImportSemaphoreWin32HandleKHR(VkDevice device, const VkImportSemaphoreWin32HandleInfoKHR *pImportSemaphoreWin32HandleInfo);
 VkResult VKAPI_CALL vkInitializePerformanceApiINTEL(VkDevice device, const VkInitializePerformanceApiInfoINTEL *pInitializeInfo);
 VkResult VKAPI_CALL vkInvalidateMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange *pMemoryRanges);
 VkResult VKAPI_CALL vkLatencySleepNV(VkDevice device, VkSwapchainKHR swapchain, const VkLatencySleepInfoNV *pSleepInfo);
@@ -20649,7 +20548,6 @@ VkResult VKAPI_CALL vkWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micr
     USE_VK_FUNC(vkGetEventStatus) \
     USE_VK_FUNC(vkGetFenceFdKHR) \
     USE_VK_FUNC(vkGetFenceStatus) \
-    USE_VK_FUNC(vkGetFenceWin32HandleKHR) \
     USE_VK_FUNC(vkGetFramebufferTilePropertiesQCOM) \
     USE_VK_FUNC(vkGetGeneratedCommandsMemoryRequirementsEXT) \
     USE_VK_FUNC(vkGetGeneratedCommandsMemoryRequirementsNV) \
@@ -20705,7 +20603,6 @@ VkResult VKAPI_CALL vkWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micr
     USE_VK_FUNC(vkGetSemaphoreCounterValue) \
     USE_VK_FUNC(vkGetSemaphoreCounterValueKHR) \
     USE_VK_FUNC(vkGetSemaphoreFdKHR) \
-    USE_VK_FUNC(vkGetSemaphoreWin32HandleKHR) \
     USE_VK_FUNC(vkGetShaderBinaryDataEXT) \
     USE_VK_FUNC(vkGetShaderInfoAMD) \
     USE_VK_FUNC(vkGetShaderModuleCreateInfoIdentifierEXT) \
@@ -20717,9 +20614,7 @@ VkResult VKAPI_CALL vkWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micr
     USE_VK_FUNC(vkGetValidationCacheDataEXT) \
     USE_VK_FUNC(vkGetVideoSessionMemoryRequirementsKHR) \
     USE_VK_FUNC(vkImportFenceFdKHR) \
-    USE_VK_FUNC(vkImportFenceWin32HandleKHR) \
     USE_VK_FUNC(vkImportSemaphoreFdKHR) \
-    USE_VK_FUNC(vkImportSemaphoreWin32HandleKHR) \
     USE_VK_FUNC(vkInitializePerformanceApiINTEL) \
     USE_VK_FUNC(vkInvalidateMappedMemoryRanges) \
     USE_VK_FUNC(vkLatencySleepNV) \
@@ -20814,10 +20709,6 @@ VkResult VKAPI_CALL vkWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micr
     USE_VK_FUNC(vkGetPhysicalDeviceCooperativeVectorPropertiesNV) \
     USE_VK_FUNC(vkGetPhysicalDeviceExternalBufferProperties) \
     USE_VK_FUNC(vkGetPhysicalDeviceExternalBufferPropertiesKHR) \
-    USE_VK_FUNC(vkGetPhysicalDeviceExternalFenceProperties) \
-    USE_VK_FUNC(vkGetPhysicalDeviceExternalFencePropertiesKHR) \
-    USE_VK_FUNC(vkGetPhysicalDeviceExternalSemaphoreProperties) \
-    USE_VK_FUNC(vkGetPhysicalDeviceExternalSemaphorePropertiesKHR) \
     USE_VK_FUNC(vkGetPhysicalDeviceExternalTensorPropertiesARM) \
     USE_VK_FUNC(vkGetPhysicalDeviceFeatures) \
     USE_VK_FUNC(vkGetPhysicalDeviceFeatures2) \
diff --git b/include/wine/vulkan_driver.h a/include/wine/vulkan_driver.h
index 9b42e895f01..c9c76d87171 100644
--- b/include/wine/vulkan_driver.h
+++ a/include/wine/vulkan_driver.h
@@ -47,7 +47,7 @@ struct vulkan_client_object
 #include "wine/rbtree.h"
 
 /* Wine internal vulkan driver version, needs to be bumped upon vulkan_funcs changes. */
-#define WINE_VULKAN_DRIVER_VERSION 44
+#define WINE_VULKAN_DRIVER_VERSION 40
 
 struct vulkan_object
 {
@@ -138,18 +138,6 @@ static inline struct vulkan_queue *vulkan_queue_from_handle( VkQueue handle )
     return (struct vulkan_queue *)(UINT_PTR)client->unix_handle;
 }
 
-struct vulkan_command_buffer
-{
-    VULKAN_OBJECT_HEADER( VkCommandBuffer, command_buffer );
-    struct vulkan_device *device;
-};
-
-static inline struct vulkan_command_buffer *vulkan_command_buffer_from_handle( VkCommandBuffer handle )
-{
-    struct vulkan_client_object *client = (struct vulkan_client_object *)handle;
-    return (struct vulkan_command_buffer *)(UINT_PTR)client->unix_handle;
-}
-
 struct vulkan_device_memory
 {
     VULKAN_OBJECT_HEADER( VkDeviceMemory, device_memory );
@@ -191,13 +179,9 @@ struct vulkan_funcs
     PFN_vkAcquireNextImageKHR p_vkAcquireNextImageKHR;
     PFN_vkAllocateMemory p_vkAllocateMemory;
     PFN_vkCreateBuffer p_vkCreateBuffer;
-    PFN_vkCreateFence p_vkCreateFence;
     PFN_vkCreateImage p_vkCreateImage;
-    PFN_vkCreateSemaphore p_vkCreateSemaphore;
     PFN_vkCreateSwapchainKHR p_vkCreateSwapchainKHR;
     PFN_vkCreateWin32SurfaceKHR p_vkCreateWin32SurfaceKHR;
-    PFN_vkDestroyFence p_vkDestroyFence;
-    PFN_vkDestroySemaphore p_vkDestroySemaphore;
     PFN_vkDestroySurfaceKHR p_vkDestroySurfaceKHR;
     PFN_vkDestroySwapchainKHR p_vkDestroySwapchainKHR;
     PFN_vkFreeMemory p_vkFreeMemory;
@@ -205,16 +189,11 @@ struct vulkan_funcs
     PFN_vkGetDeviceBufferMemoryRequirementsKHR p_vkGetDeviceBufferMemoryRequirementsKHR;
     PFN_vkGetDeviceImageMemoryRequirements p_vkGetDeviceImageMemoryRequirements;
     PFN_vkGetDeviceProcAddr p_vkGetDeviceProcAddr;
-    PFN_vkGetFenceWin32HandleKHR p_vkGetFenceWin32HandleKHR;
     PFN_vkGetInstanceProcAddr p_vkGetInstanceProcAddr;
     PFN_vkGetMemoryWin32HandleKHR p_vkGetMemoryWin32HandleKHR;
     PFN_vkGetMemoryWin32HandlePropertiesKHR p_vkGetMemoryWin32HandlePropertiesKHR;
     PFN_vkGetPhysicalDeviceExternalBufferProperties p_vkGetPhysicalDeviceExternalBufferProperties;
     PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR p_vkGetPhysicalDeviceExternalBufferPropertiesKHR;
-    PFN_vkGetPhysicalDeviceExternalFenceProperties p_vkGetPhysicalDeviceExternalFenceProperties;
-    PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR p_vkGetPhysicalDeviceExternalFencePropertiesKHR;
-    PFN_vkGetPhysicalDeviceExternalSemaphoreProperties p_vkGetPhysicalDeviceExternalSemaphoreProperties;
-    PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR p_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR;
     PFN_vkGetPhysicalDeviceImageFormatProperties2 p_vkGetPhysicalDeviceImageFormatProperties2;
     PFN_vkGetPhysicalDeviceImageFormatProperties2KHR p_vkGetPhysicalDeviceImageFormatProperties2KHR;
     PFN_vkGetPhysicalDevicePresentRectanglesKHR p_vkGetPhysicalDevicePresentRectanglesKHR;
@@ -223,15 +202,9 @@ struct vulkan_funcs
     PFN_vkGetPhysicalDeviceSurfaceFormats2KHR p_vkGetPhysicalDeviceSurfaceFormats2KHR;
     PFN_vkGetPhysicalDeviceSurfaceFormatsKHR p_vkGetPhysicalDeviceSurfaceFormatsKHR;
     PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR p_vkGetPhysicalDeviceWin32PresentationSupportKHR;
-    PFN_vkGetSemaphoreWin32HandleKHR p_vkGetSemaphoreWin32HandleKHR;
-    PFN_vkImportFenceWin32HandleKHR p_vkImportFenceWin32HandleKHR;
-    PFN_vkImportSemaphoreWin32HandleKHR p_vkImportSemaphoreWin32HandleKHR;
     PFN_vkMapMemory p_vkMapMemory;
     PFN_vkMapMemory2KHR p_vkMapMemory2KHR;
     PFN_vkQueuePresentKHR p_vkQueuePresentKHR;
-    PFN_vkQueueSubmit p_vkQueueSubmit;
-    PFN_vkQueueSubmit2 p_vkQueueSubmit2;
-    PFN_vkQueueSubmit2KHR p_vkQueueSubmit2KHR;
     PFN_vkUnmapMemory p_vkUnmapMemory;
     PFN_vkUnmapMemory2KHR p_vkUnmapMemory2KHR;
 

diff --git b/dlls/win32u/vulkan.c a/dlls/win32u/vulkan.c
index da86d34732e..3bc08d17ae8 100644
--- b/dlls/win32u/vulkan.c
+++ a/dlls/win32u/vulkan.c
@@ -92,7 +92,7 @@ static struct swapchain *swapchain_from_handle( VkSwapchainKHR handle )
     return CONTAINING_RECORD( obj, struct swapchain, obj );
 }
 
-static VkResult allocate_external_host_memory( struct vulkan_device *device, VkMemoryAllocateInfo *alloc_info, uint32_t mem_flags,
+static VkResult allocate_external_host_memory( struct vulkan_device *device, VkMemoryAllocateInfo *alloc_info,
                                                VkImportMemoryHostPointerInfoEXT *import_info )
 {
     struct vulkan_physical_device *physical_device = device->physical_device;
@@ -100,14 +100,16 @@ static VkResult allocate_external_host_memory( struct vulkan_device *device, VkM
     {
         .sType = VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT,
     };
-    uint32_t i, align = physical_device->external_memory_align - 1;
+    uint32_t i, mem_flags, align = physical_device->external_memory_align - 1;
     SIZE_T alloc_size = alloc_info->allocationSize;
     static int once;
-    void *mapping = NULL;
+    void *mapping;
     VkResult res;
 
     if (!once++) FIXME( "Using VK_EXT_external_memory_host\n" );
 
+    mem_flags = physical_device->memory_properties.memoryTypes[alloc_info->memoryTypeIndex].propertyFlags;
+
     if (NtAllocateVirtualMemory( GetCurrentProcess(), &mapping, zero_bits, &alloc_size, MEM_COMMIT, PAGE_READWRITE ))
     {
         ERR( "NtAllocateVirtualMemory failed\n" );
@@ -155,11 +157,10 @@ static VkResult allocate_external_host_memory( struct vulkan_device *device, VkM
     return VK_SUCCESS;
 }
 
-static VkResult win32u_vkAllocateMemory( VkDevice client_device, const VkMemoryAllocateInfo *client_alloc_info,
+static VkResult win32u_vkAllocateMemory( VkDevice client_device, const VkMemoryAllocateInfo *alloc_info,
                                          const VkAllocationCallbacks *allocator, VkDeviceMemory *ret )
 {
-    VkMemoryAllocateInfo *alloc_info = (VkMemoryAllocateInfo *)client_alloc_info; /* cast away const, chain has been copied in the thunks */
-    VkBaseOutStructure **next, *prev = (VkBaseOutStructure *)alloc_info;
+    VkBaseOutStructure **next, *prev = (VkBaseOutStructure *)alloc_info; /* cast away const, chain has been copied in the thunks */
     struct vulkan_device *device = vulkan_device_from_handle( client_device );
     struct vulkan_physical_device *physical_device = device->physical_device;
     struct vulkan_instance *instance = device->physical_device->instance;
@@ -206,7 +207,7 @@ static VkResult win32u_vkAllocateMemory( VkDevice client_device, const VkMemoryA
     /* For host visible memory, we try to use VK_EXT_external_memory_host on wow64 to ensure that mapped pointer is 32-bit. */
     mem_flags = physical_device->memory_properties.memoryTypes[alloc_info->memoryTypeIndex].propertyFlags;
     if (physical_device->external_memory_align && (mem_flags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) && !pointer_info &&
-        (res = allocate_external_host_memory( device, alloc_info, mem_flags, &host_pointer_info )))
+        (res = allocate_external_host_memory( device, (VkMemoryAllocateInfo *)alloc_info, &host_pointer_info )))
         return res;
 
     if (!(memory = malloc( sizeof(*memory) ))) return VK_ERROR_OUT_OF_HOST_MEMORY;
@@ -481,24 +482,20 @@ static void win32u_vkGetDeviceBufferMemoryRequirements( VkDevice client_device,
     device->p_vkGetDeviceBufferMemoryRequirements( device->host.device, buffer_requirements, memory_requirements );
 }
 
-static void win32u_vkGetPhysicalDeviceExternalBufferProperties( VkPhysicalDevice client_physical_device, const VkPhysicalDeviceExternalBufferInfo *client_buffer_info,
-                                                                VkExternalBufferProperties *buffer_properties )
+static void win32u_vkGetPhysicalDeviceExternalBufferProperties( VkPhysicalDevice client_physical_device, const VkPhysicalDeviceExternalBufferInfo *buffer_info,
+                                                                VkExternalBufferProperties *buffer_properies )
 {
-    VkPhysicalDeviceExternalBufferInfo *buffer_info = (VkPhysicalDeviceExternalBufferInfo *)client_buffer_info; /* cast away const, it has been copied in the thunks */
     struct vulkan_physical_device *physical_device = vulkan_physical_device_from_handle( client_physical_device );
     struct vulkan_instance *instance = physical_device->instance;
 
-    TRACE( "physical_device %p, buffer_info %p, buffer_properties %p\n", physical_device, buffer_info, buffer_properties );
+    TRACE( "physical_device %p, buffer_info %p, buffer_properies %p\n", physical_device, buffer_info, buffer_properies );
 
     if (!(buffer_info->handleType & EXTERNAL_MEMORY_WIN32_BITS))
         FIXME( "Unsupported handle type %#x\n", buffer_info->handleType );
     FIXME( "VkPhysicalDeviceExternalBufferInfo Win32 handleType not implemented!\n" );
-    buffer_info->handleType = 0;
+    ((VkPhysicalDeviceExternalBufferInfo *)buffer_info)->handleType = 0; /* cast away const, it has been copied in the thunks */
 
-    instance->p_vkGetPhysicalDeviceExternalBufferProperties( physical_device->host.physical_device, buffer_info, buffer_properties );
-    buffer_properties->externalMemoryProperties.externalMemoryFeatures = 0;
-    buffer_properties->externalMemoryProperties.exportFromImportedHandleTypes = 0;
-    buffer_properties->externalMemoryProperties.compatibleHandleTypes = 0;
+    return instance->p_vkGetPhysicalDeviceExternalBufferProperties( physical_device->host.physical_device, buffer_info, buffer_properies );
 }
 
 static VkResult win32u_vkCreateImage( VkDevice client_device, const VkImageCreateInfo *create_info,
@@ -581,15 +578,14 @@ static void win32u_vkGetDeviceImageMemoryRequirements( VkDevice client_device, c
 }
 
 static VkResult win32u_vkGetPhysicalDeviceImageFormatProperties2( VkPhysicalDevice client_physical_device, const VkPhysicalDeviceImageFormatInfo2 *format_info,
-                                                                  VkImageFormatProperties2 *format_properties )
+                                                                  VkImageFormatProperties2 *format_properies )
 {
     VkBaseOutStructure **next, *prev = (VkBaseOutStructure *)format_info; /* cast away const, chain has been copied in the thunks */
     struct vulkan_physical_device *physical_device = vulkan_physical_device_from_handle( client_physical_device );
     struct vulkan_instance *instance = physical_device->instance;
     VkPhysicalDeviceExternalImageFormatInfo *external_info;
-    VkResult res;
 
-    TRACE( "physical_device %p, format_info %p, format_properties %p\n", physical_device, format_info, format_properties );
+    TRACE( "physical_device %p, format_info %p, format_properies %p\n", physical_device, format_info, format_properies );
 
     for (next = &prev->pNext; *next; prev = *next, next = &(*next)->pNext)
     {
@@ -612,29 +608,7 @@ static VkResult win32u_vkGetPhysicalDeviceImageFormatProperties2( VkPhysicalDevi
         }
     }
 
-    res = instance->p_vkGetPhysicalDeviceImageFormatProperties2( physical_device->host.physical_device, format_info, format_properties );
-    if (!res) for (prev = (VkBaseOutStructure *)format_properties, next = &prev->pNext; *next; prev = *next, next = &(*next)->pNext)
-    {
-        switch ((*next)->sType)
-        {
-        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
-        {
-            VkExternalImageFormatProperties *props = (VkExternalImageFormatProperties *)*next;
-            props->externalMemoryProperties.externalMemoryFeatures = 0;
-            props->externalMemoryProperties.exportFromImportedHandleTypes = 0;
-            props->externalMemoryProperties.compatibleHandleTypes = 0;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT: break;
-        case VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY: break;
-        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT: break;
-        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES: break;
-        case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD: break;
-        default: FIXME( "Unhandled sType %u.\n", (*next)->sType ); break;
-        }
-    }
-
-    return res;
+    return instance->p_vkGetPhysicalDeviceImageFormatProperties2( physical_device->host.physical_device, format_info, format_properies );
 }
 
 static VkResult win32u_vkCreateWin32SurfaceKHR( VkInstance client_instance, const VkWin32SurfaceCreateInfoKHR *create_info,
diff --git b/dlls/winevulkan/vulkan.c a/dlls/winevulkan/vulkan.c
index 6325fd2bb43..417406d66df 100644
--- b/dlls/winevulkan/vulkan.c
+++ a/dlls/winevulkan/vulkan.c
@@ -1364,6 +1364,66 @@ void wine_vkGetPhysicalDeviceExternalFencePropertiesKHR(VkPhysicalDevice client_
     properties->externalFenceFeatures = 0;
 }
 
+void wine_vkGetPhysicalDeviceExternalBufferProperties(VkPhysicalDevice client_physical_device,
+                                                      const VkPhysicalDeviceExternalBufferInfo *buffer_info,
+                                                      VkExternalBufferProperties *properties)
+{
+    memset(&properties->externalMemoryProperties, 0, sizeof(properties->externalMemoryProperties));
+}
+
+void wine_vkGetPhysicalDeviceExternalBufferPropertiesKHR(VkPhysicalDevice client_physical_device,
+                                                         const VkPhysicalDeviceExternalBufferInfo *buffer_info,
+                                                         VkExternalBufferProperties *properties)
+{
+    memset(&properties->externalMemoryProperties, 0, sizeof(properties->externalMemoryProperties));
+}
+
+VkResult wine_vkGetPhysicalDeviceImageFormatProperties2(VkPhysicalDevice client_physical_device,
+                                                        const VkPhysicalDeviceImageFormatInfo2 *format_info,
+                                                        VkImageFormatProperties2 *properties)
+{
+    struct vulkan_physical_device *physical_device = vulkan_physical_device_from_handle(client_physical_device);
+    struct vulkan_instance *instance = physical_device->instance;
+    VkExternalImageFormatProperties *external_image_properties;
+    VkResult res;
+
+    res = instance->p_vkGetPhysicalDeviceImageFormatProperties2(physical_device->host.physical_device, format_info, properties);
+
+    if ((external_image_properties = find_next_struct(properties,
+                                                      VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES)))
+    {
+        VkExternalMemoryProperties *p = &external_image_properties->externalMemoryProperties;
+        p->externalMemoryFeatures = 0;
+        p->exportFromImportedHandleTypes = 0;
+        p->compatibleHandleTypes = 0;
+    }
+
+    return res;
+}
+
+VkResult wine_vkGetPhysicalDeviceImageFormatProperties2KHR(VkPhysicalDevice client_physical_device,
+                                                           const VkPhysicalDeviceImageFormatInfo2 *format_info,
+                                                           VkImageFormatProperties2 *properties)
+{
+    struct vulkan_physical_device *physical_device = vulkan_physical_device_from_handle(client_physical_device);
+    struct vulkan_instance *instance = physical_device->instance;
+    VkExternalImageFormatProperties *external_image_properties;
+    VkResult res;
+
+    res = instance->p_vkGetPhysicalDeviceImageFormatProperties2KHR(physical_device->host.physical_device, format_info, properties);
+
+    if ((external_image_properties = find_next_struct(properties,
+                                                      VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES)))
+    {
+        VkExternalMemoryProperties *p = &external_image_properties->externalMemoryProperties;
+        p->externalMemoryFeatures = 0;
+        p->exportFromImportedHandleTypes = 0;
+        p->compatibleHandleTypes = 0;
+    }
+
+    return res;
+}
+
 /* From ntdll/unix/sync.c */
 #define NANOSECONDS_IN_A_SECOND 1000000000
 #define TICKSPERSEC             10000000

diff --git b/dlls/win32u/vulkan.c a/dlls/win32u/vulkan.c
index 3bc08d17ae8..6503b217d1c 100644
--- b/dlls/win32u/vulkan.c
+++ a/dlls/win32u/vulkan.c
@@ -46,13 +46,6 @@ WINE_DECLARE_DEBUG_CHANNEL(fps);
 
 static const struct vulkan_driver_funcs *driver_funcs;
 
-static const UINT EXTERNAL_MEMORY_WIN32_BITS = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT |
-                                               VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT |
-                                               VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT |
-                                               VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT |
-                                               VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT |
-                                               VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT;
-
 struct device_memory
 {
     struct vulkan_device_memory obj;
@@ -92,6 +85,13 @@ static struct swapchain *swapchain_from_handle( VkSwapchainKHR handle )
     return CONTAINING_RECORD( obj, struct swapchain, obj );
 }
 
+static inline const void *find_next_struct( const void *head, VkStructureType type )
+{
+    const VkBaseInStructure *header;
+    for (header = head; header; header = header->pNext) if (header->sType == type) return header;
+    return NULL;
+}
+
 static VkResult allocate_external_host_memory( struct vulkan_device *device, VkMemoryAllocateInfo *alloc_info,
                                                VkImportMemoryHostPointerInfoEXT *import_info )
 {
@@ -160,65 +160,33 @@ static VkResult allocate_external_host_memory( struct vulkan_device *device, VkM
 static VkResult win32u_vkAllocateMemory( VkDevice client_device, const VkMemoryAllocateInfo *alloc_info,
                                          const VkAllocationCallbacks *allocator, VkDeviceMemory *ret )
 {
-    VkBaseOutStructure **next, *prev = (VkBaseOutStructure *)alloc_info; /* cast away const, chain has been copied in the thunks */
     struct vulkan_device *device = vulkan_device_from_handle( client_device );
     struct vulkan_physical_device *physical_device = device->physical_device;
     struct vulkan_instance *instance = device->physical_device->instance;
-    VkImportMemoryHostPointerInfoEXT host_pointer_info, *pointer_info = NULL;
-    VkExportMemoryAllocateInfo *export_info = NULL;
+    VkImportMemoryHostPointerInfoEXT host_pointer_info;
+    VkMemoryAllocateInfo info = *alloc_info;
     VkDeviceMemory host_device_memory;
     struct device_memory *memory;
     uint32_t mem_flags;
     void *mapping = NULL;
     VkResult res;
 
-    for (next = &prev->pNext; *next; prev = *next, next = &(*next)->pNext)
-    {
-        switch ((*next)->sType)
-        {
-        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV: break;
-        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
-            export_info = (VkExportMemoryAllocateInfo *)*next;
-            if (!(export_info->handleTypes & EXTERNAL_MEMORY_WIN32_BITS))
-                FIXME( "Unsupported handle types %#x\n", export_info->handleTypes );
-            FIXME( "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO not implemented!\n" );
-            *next = (*next)->pNext; next = &prev;
-            break;
-        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
-            FIXME( "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR not implemented!\n" );
-            *next = (*next)->pNext; next = &prev;
-            break;
-        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
-            pointer_info = (VkImportMemoryHostPointerInfoEXT *)*next;
-            break;
-        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
-            FIXME( "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR not implemented!\n" );
-            *next = (*next)->pNext; next = &prev;
-            break;
-        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO: break;
-        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO: break;
-        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM: break;
-        case VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO: break;
-        case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT: break;
-        default: FIXME( "Unhandled sType %u.\n", (*next)->sType ); break;
-        }
-    }
-
     /* For host visible memory, we try to use VK_EXT_external_memory_host on wow64 to ensure that mapped pointer is 32-bit. */
     mem_flags = physical_device->memory_properties.memoryTypes[alloc_info->memoryTypeIndex].propertyFlags;
-    if (physical_device->external_memory_align && (mem_flags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) && !pointer_info &&
-        (res = allocate_external_host_memory( device, (VkMemoryAllocateInfo *)alloc_info, &host_pointer_info )))
+    if (physical_device->external_memory_align && (mem_flags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) &&
+        !find_next_struct( alloc_info->pNext, VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT ) &&
+        (res = allocate_external_host_memory( device, &info, &host_pointer_info )))
         return res;
 
     if (!(memory = malloc( sizeof(*memory) ))) return VK_ERROR_OUT_OF_HOST_MEMORY;
-    if ((res = device->p_vkAllocateMemory( device->host.device, alloc_info, NULL, &host_device_memory )))
+    if ((res = device->p_vkAllocateMemory( device->host.device, &info, NULL, &host_device_memory )))
     {
         free( memory );
         return res;
     }
 
     vulkan_object_init( &memory->obj.obj, host_device_memory );
-    memory->size = alloc_info->allocationSize;
+    memory->size = info.allocationSize;
     memory->vm_map = mapping;
     instance->p_insert_object( instance, &memory->obj.obj );
 
@@ -259,25 +227,6 @@ static void win32u_vkFreeMemory( VkDevice client_device, VkDeviceMemory client_m
     free( memory );
 }
 
-static VkResult win32u_vkGetMemoryWin32HandleKHR( VkDevice client_device, const VkMemoryGetWin32HandleInfoKHR *handle_info, HANDLE *handle )
-{
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-
-    FIXME( "device %p, handle_info %p, handle %p stub!\n", device, handle_info, handle );
-
-    return VK_ERROR_INCOMPATIBLE_DRIVER;
-}
-
-static VkResult win32u_vkGetMemoryWin32HandlePropertiesKHR( VkDevice client_device, VkExternalMemoryHandleTypeFlagBits handle_type, HANDLE handle,
-                                                            VkMemoryWin32HandlePropertiesKHR *handle_properties )
-{
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-
-    FIXME( "device %p, handle_type %#x, handle %p, handle_properties %p stub!\n", device, handle_type, handle, handle_properties );
-
-    return VK_ERROR_INCOMPATIBLE_DRIVER;
-}
-
 static VkResult win32u_vkMapMemory2KHR( VkDevice client_device, const VkMemoryMapInfoKHR *map_info, void **data )
 {
     struct vulkan_device *device = vulkan_device_from_handle( client_device );
@@ -412,203 +361,41 @@ static void win32u_vkUnmapMemory( VkDevice client_device, VkDeviceMemory client_
 static VkResult win32u_vkCreateBuffer( VkDevice client_device, const VkBufferCreateInfo *create_info,
                                        const VkAllocationCallbacks *allocator, VkBuffer *buffer )
 {
-    VkBaseOutStructure **next, *prev = (VkBaseOutStructure *)create_info; /* cast away const, chain has been copied in the thunks */
     struct vulkan_device *device = vulkan_device_from_handle( client_device );
     struct vulkan_physical_device *physical_device = device->physical_device;
-    VkExternalMemoryBufferCreateInfo host_external_info, *external_info = NULL;
-
-    for (next = &prev->pNext; *next; prev = *next, next = &(*next)->pNext)
-    {
-        switch ((*next)->sType)
-        {
-        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT: break;
-        case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO: break;
-        case VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO: break;
-        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV: break;
-        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
-            external_info = (VkExternalMemoryBufferCreateInfo *)*next;
-            if (!(external_info->handleTypes & EXTERNAL_MEMORY_WIN32_BITS))
-                FIXME( "Unsupported handle types %#x\n", external_info->handleTypes );
-            FIXME( "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO not implemented!\n" );
-            *next = (*next)->pNext; next = &prev;
-            break;
-        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT: break;
-        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR: break;
-        default: FIXME( "Unhandled sType %u.\n", (*next)->sType ); break;
-        }
-    }
+    VkExternalMemoryBufferCreateInfo external_memory_info;
+    VkBufferCreateInfo info = *create_info;
 
-    if (physical_device->external_memory_align && !external_info)
+    if (physical_device->external_memory_align &&
+        !find_next_struct( info.pNext, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO ))
     {
-        host_external_info.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
-        host_external_info.pNext = create_info->pNext;
-        host_external_info.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT;
-        ((VkBufferCreateInfo *)create_info)->pNext = &host_external_info; /* cast away const, it has been copied in the thunks */
-    }
-
-    return device->p_vkCreateBuffer( device->host.device, create_info, NULL, buffer );
-}
-
-static void win32u_vkGetDeviceBufferMemoryRequirements( VkDevice client_device, const VkDeviceBufferMemoryRequirements *buffer_requirements,
-                                                        VkMemoryRequirements2 *memory_requirements )
-{
-    VkBaseOutStructure **next, *prev = (VkBaseOutStructure *)buffer_requirements->pCreateInfo; /* cast away const, chain has been copied in the thunks */
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    VkExternalMemoryBufferCreateInfo *external_info;
-
-    TRACE( "device %p, buffer_requirements %p, memory_requirements %p\n", device, buffer_requirements, memory_requirements );
-
-    for (next = &prev->pNext; *next; prev = *next, next = &(*next)->pNext)
-    {
-        switch ((*next)->sType)
-        {
-        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT: break;
-        case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO: break;
-        case VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO: break;
-        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV: break;
-        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
-            external_info = (VkExternalMemoryBufferCreateInfo *)*next;
-            if (!(external_info->handleTypes & EXTERNAL_MEMORY_WIN32_BITS))
-                FIXME( "Unsupported handle types %#x\n", external_info->handleTypes );
-            FIXME( "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO not implemented!\n" );
-            *next = (*next)->pNext; next = &prev;
-            break;
-        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT: break;
-        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR: break;
-        default: FIXME( "Unhandled sType %u.\n", (*next)->sType ); break;
-        }
+        external_memory_info.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
+        external_memory_info.pNext = info.pNext;
+        external_memory_info.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT;
+        info.pNext = &external_memory_info;
     }
 
-    device->p_vkGetDeviceBufferMemoryRequirements( device->host.device, buffer_requirements, memory_requirements );
-}
-
-static void win32u_vkGetPhysicalDeviceExternalBufferProperties( VkPhysicalDevice client_physical_device, const VkPhysicalDeviceExternalBufferInfo *buffer_info,
-                                                                VkExternalBufferProperties *buffer_properies )
-{
-    struct vulkan_physical_device *physical_device = vulkan_physical_device_from_handle( client_physical_device );
-    struct vulkan_instance *instance = physical_device->instance;
-
-    TRACE( "physical_device %p, buffer_info %p, buffer_properies %p\n", physical_device, buffer_info, buffer_properies );
-
-    if (!(buffer_info->handleType & EXTERNAL_MEMORY_WIN32_BITS))
-        FIXME( "Unsupported handle type %#x\n", buffer_info->handleType );
-    FIXME( "VkPhysicalDeviceExternalBufferInfo Win32 handleType not implemented!\n" );
-    ((VkPhysicalDeviceExternalBufferInfo *)buffer_info)->handleType = 0; /* cast away const, it has been copied in the thunks */
-
-    return instance->p_vkGetPhysicalDeviceExternalBufferProperties( physical_device->host.physical_device, buffer_info, buffer_properies );
+    return device->p_vkCreateBuffer( device->host.device, &info, NULL, buffer );
 }
 
 static VkResult win32u_vkCreateImage( VkDevice client_device, const VkImageCreateInfo *create_info,
                                       const VkAllocationCallbacks *allocator, VkImage *image )
 {
-    VkBaseOutStructure **next, *prev = (VkBaseOutStructure *)create_info; /* cast away const, chain has been copied in the thunks */
     struct vulkan_device *device = vulkan_device_from_handle( client_device );
     struct vulkan_physical_device *physical_device = device->physical_device;
-    VkExternalMemoryImageCreateInfo host_external_info, *external_info = NULL;
+    VkExternalMemoryImageCreateInfo external_memory_info;
+    VkImageCreateInfo info = *create_info;
 
-    for (next = &prev->pNext; *next; prev = *next, next = &(*next)->pNext)
+    if (physical_device->external_memory_align &&
+        !find_next_struct( info.pNext, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO ))
     {
-        switch ((*next)->sType)
-        {
-        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV: break;
-        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
-            external_info = (VkExternalMemoryImageCreateInfo *)*next;
-            if (!(external_info->handleTypes & EXTERNAL_MEMORY_WIN32_BITS))
-                FIXME( "Unsupported handle types %#x\n", external_info->handleTypes );
-            FIXME( "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO not implemented!\n" );
-            *next = (*next)->pNext; next = &prev;
-            break;
-        case VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA: break;
-        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT: break;
-        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO: break;
-        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO: break;
-        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR: break;
-        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT: break;
-        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV: break;
-        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR: break;
-        default: FIXME( "Unhandled sType %u.\n", (*next)->sType ); break;
-        }
-    }
-
-    if (physical_device->external_memory_align && !external_info)
-    {
-        host_external_info.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
-        host_external_info.pNext = create_info->pNext;
-        host_external_info.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT;
-        ((VkImageCreateInfo *)create_info)->pNext = &host_external_info; /* cast away const, it has been copied in the thunks */
-    }
-
-    return device->p_vkCreateImage( device->host.device, create_info, NULL, image );
-}
-
-static void win32u_vkGetDeviceImageMemoryRequirements( VkDevice client_device, const VkDeviceImageMemoryRequirements *image_requirements,
-                                                       VkMemoryRequirements2 *memory_requirements )
-{
-    VkBaseOutStructure **next, *prev = (VkBaseOutStructure *)image_requirements->pCreateInfo; /* cast away const, chain has been copied in the thunks */
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    VkExternalMemoryImageCreateInfo *external_info;
-
-    TRACE( "device %p, image_requirements %p, memory_requirements %p\n", device, image_requirements, memory_requirements );
-
-    for (next = &prev->pNext; *next; prev = *next, next = &(*next)->pNext)
-    {
-        switch ((*next)->sType)
-        {
-        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV: break;
-        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
-            external_info = (VkExternalMemoryImageCreateInfo *)*next;
-            if (!(external_info->handleTypes & EXTERNAL_MEMORY_WIN32_BITS))
-                FIXME( "Unsupported handle types %#x\n", external_info->handleTypes );
-            FIXME( "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO not implemented!\n" );
-            *next = (*next)->pNext; next = &prev;
-            break;
-        case VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA: break;
-        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT: break;
-        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO: break;
-        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO: break;
-        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR: break;
-        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT: break;
-        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV: break;
-        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR: break;
-        default: FIXME( "Unhandled sType %u.\n", (*next)->sType ); break;
-        }
-    }
-
-    device->p_vkGetDeviceImageMemoryRequirements( device->host.device, image_requirements, memory_requirements );
-}
-
-static VkResult win32u_vkGetPhysicalDeviceImageFormatProperties2( VkPhysicalDevice client_physical_device, const VkPhysicalDeviceImageFormatInfo2 *format_info,
-                                                                  VkImageFormatProperties2 *format_properies )
-{
-    VkBaseOutStructure **next, *prev = (VkBaseOutStructure *)format_info; /* cast away const, chain has been copied in the thunks */
-    struct vulkan_physical_device *physical_device = vulkan_physical_device_from_handle( client_physical_device );
-    struct vulkan_instance *instance = physical_device->instance;
-    VkPhysicalDeviceExternalImageFormatInfo *external_info;
-
-    TRACE( "physical_device %p, format_info %p, format_properies %p\n", physical_device, format_info, format_properies );
-
-    for (next = &prev->pNext; *next; prev = *next, next = &(*next)->pNext)
-    {
-        switch ((*next)->sType)
-        {
-        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT: break;
-        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO: break;
-        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO: break;
-        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV: break;
-        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
-            external_info = (VkPhysicalDeviceExternalImageFormatInfo *)*next;
-            if (!(external_info->handleType & EXTERNAL_MEMORY_WIN32_BITS))
-                FIXME( "Unsupported handle type %#x\n", external_info->handleType );
-            FIXME( "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO not implemented!\n" );
-            *next = (*next)->pNext; next = &prev;
-            break;
-        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT: break;
-        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR: break;
-        default: FIXME( "Unhandled sType %u.\n", (*next)->sType ); break;
-        }
+        external_memory_info.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
+        external_memory_info.pNext = info.pNext;
+        external_memory_info.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT;
+        info.pNext = &external_memory_info;
     }
 
-    return instance->p_vkGetPhysicalDeviceImageFormatProperties2( physical_device->host.physical_device, format_info, format_properies );
+    return device->p_vkCreateImage( device->host.device, &info, NULL, image );
 }
 
 static VkResult win32u_vkCreateWin32SurfaceKHR( VkInstance client_instance, const VkWin32SurfaceCreateInfoKHR *create_info,
@@ -1032,15 +819,6 @@ static struct vulkan_funcs vulkan_funcs =
     .p_vkDestroySurfaceKHR = win32u_vkDestroySurfaceKHR,
     .p_vkDestroySwapchainKHR = win32u_vkDestroySwapchainKHR,
     .p_vkFreeMemory = win32u_vkFreeMemory,
-    .p_vkGetDeviceBufferMemoryRequirements = win32u_vkGetDeviceBufferMemoryRequirements,
-    .p_vkGetDeviceBufferMemoryRequirementsKHR = win32u_vkGetDeviceBufferMemoryRequirements,
-    .p_vkGetDeviceImageMemoryRequirements = win32u_vkGetDeviceImageMemoryRequirements,
-    .p_vkGetMemoryWin32HandleKHR = win32u_vkGetMemoryWin32HandleKHR,
-    .p_vkGetMemoryWin32HandlePropertiesKHR = win32u_vkGetMemoryWin32HandlePropertiesKHR,
-    .p_vkGetPhysicalDeviceExternalBufferProperties = win32u_vkGetPhysicalDeviceExternalBufferProperties,
-    .p_vkGetPhysicalDeviceExternalBufferPropertiesKHR = win32u_vkGetPhysicalDeviceExternalBufferProperties,
-    .p_vkGetPhysicalDeviceImageFormatProperties2 = win32u_vkGetPhysicalDeviceImageFormatProperties2,
-    .p_vkGetPhysicalDeviceImageFormatProperties2KHR = win32u_vkGetPhysicalDeviceImageFormatProperties2,
     .p_vkGetPhysicalDevicePresentRectanglesKHR = win32u_vkGetPhysicalDevicePresentRectanglesKHR,
     .p_vkGetPhysicalDeviceProperties2 = win32u_vkGetPhysicalDeviceProperties2,
     .p_vkGetPhysicalDeviceProperties2KHR = win32u_vkGetPhysicalDeviceProperties2KHR,
diff --git b/dlls/winevulkan/loader_thunks.c a/dlls/winevulkan/loader_thunks.c
index 3da89090ee8..e932ec46476 100644
--- b/dlls/winevulkan/loader_thunks.c
+++ a/dlls/winevulkan/loader_thunks.c
@@ -5233,31 +5233,6 @@ VkResult WINAPI vkGetMemoryHostPointerPropertiesEXT(VkDevice device, VkExternalM
     return params.result;
 }
 
-VkResult WINAPI vkGetMemoryWin32HandleKHR(VkDevice device, const VkMemoryGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle)
-{
-    struct vkGetMemoryWin32HandleKHR_params params;
-    NTSTATUS status;
-    params.device = device;
-    params.pGetWin32HandleInfo = pGetWin32HandleInfo;
-    params.pHandle = pHandle;
-    status = UNIX_CALL(vkGetMemoryWin32HandleKHR, &params);
-    assert(!status && "vkGetMemoryWin32HandleKHR");
-    return params.result;
-}
-
-VkResult WINAPI vkGetMemoryWin32HandlePropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, HANDLE handle, VkMemoryWin32HandlePropertiesKHR *pMemoryWin32HandleProperties)
-{
-    struct vkGetMemoryWin32HandlePropertiesKHR_params params;
-    NTSTATUS status;
-    params.device = device;
-    params.handleType = handleType;
-    params.handle = handle;
-    params.pMemoryWin32HandleProperties = pMemoryWin32HandleProperties;
-    status = UNIX_CALL(vkGetMemoryWin32HandlePropertiesKHR, &params);
-    assert(!status && "vkGetMemoryWin32HandlePropertiesKHR");
-    return params.result;
-}
-
 void WINAPI vkGetMicromapBuildSizesEXT(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkMicromapBuildInfoEXT *pBuildInfo, VkMicromapBuildSizesInfoEXT *pSizeInfo)
 {
     struct vkGetMicromapBuildSizesEXT_params params;
@@ -7569,8 +7544,6 @@ static const struct vulkan_func vk_device_dispatch_table[] =
     {"vkGetImageViewOpaqueCaptureDescriptorDataEXT", vkGetImageViewOpaqueCaptureDescriptorDataEXT},
     {"vkGetLatencyTimingsNV", vkGetLatencyTimingsNV},
     {"vkGetMemoryHostPointerPropertiesEXT", vkGetMemoryHostPointerPropertiesEXT},
-    {"vkGetMemoryWin32HandleKHR", vkGetMemoryWin32HandleKHR},
-    {"vkGetMemoryWin32HandlePropertiesKHR", vkGetMemoryWin32HandlePropertiesKHR},
     {"vkGetMicromapBuildSizesEXT", vkGetMicromapBuildSizesEXT},
     {"vkGetPartitionedAccelerationStructuresBuildSizesNV", vkGetPartitionedAccelerationStructuresBuildSizesNV},
     {"vkGetPerformanceParameterINTEL", vkGetPerformanceParameterINTEL},
diff --git b/dlls/winevulkan/loader_thunks.h a/dlls/winevulkan/loader_thunks.h
index ebfc3dce3a8..7bf58a83988 100644
--- b/dlls/winevulkan/loader_thunks.h
+++ a/dlls/winevulkan/loader_thunks.h
@@ -526,8 +526,6 @@ enum unix_call
     unix_vkGetImageViewOpaqueCaptureDescriptorDataEXT,
     unix_vkGetLatencyTimingsNV,
     unix_vkGetMemoryHostPointerPropertiesEXT,
-    unix_vkGetMemoryWin32HandleKHR,
-    unix_vkGetMemoryWin32HandlePropertiesKHR,
     unix_vkGetMicromapBuildSizesEXT,
     unix_vkGetPartitionedAccelerationStructuresBuildSizesNV,
     unix_vkGetPerformanceParameterINTEL,
@@ -4544,23 +4542,6 @@ struct vkGetMemoryHostPointerPropertiesEXT_params
     VkResult result;
 };
 
-struct vkGetMemoryWin32HandleKHR_params
-{
-    VkDevice device;
-    const VkMemoryGetWin32HandleInfoKHR *pGetWin32HandleInfo;
-    HANDLE *pHandle;
-    VkResult result;
-};
-
-struct vkGetMemoryWin32HandlePropertiesKHR_params
-{
-    VkDevice device;
-    VkExternalMemoryHandleTypeFlagBits handleType;
-    HANDLE handle;
-    VkMemoryWin32HandlePropertiesKHR *pMemoryWin32HandleProperties;
-    VkResult result;
-};
-
 struct vkGetMicromapBuildSizesEXT_params
 {
     VkDevice device;
diff --git b/dlls/winevulkan/make_vulkan a/dlls/winevulkan/make_vulkan
index 83ec38fd520..6eb466b8937 100755
--- b/dlls/winevulkan/make_vulkan
+++ a/dlls/winevulkan/make_vulkan
@@ -109,9 +109,15 @@ UNSUPPORTED_EXTENSIONS = [
     "VK_NV_external_compute_queue", # Has a new dispatchable handle
 
     # Extensions for other platforms
+    "VK_EXT_external_memory_dma_buf",
+    "VK_EXT_image_drm_format_modifier",
     "VK_EXT_metal_objects",
     "VK_EXT_physical_device_drm",
     "VK_GOOGLE_surfaceless_query",
+    "VK_KHR_external_fence_fd",
+    "VK_KHR_external_memory_fd",
+    "VK_EXT_external_memory_metal",
+    "VK_KHR_external_semaphore_fd",
     "VK_SEC_amigo_profiling", # Angle specific.
 
     # Extensions which require callback handling
@@ -127,15 +133,10 @@ UNSUPPORTED_EXTENSIONS = [
 # but not expose to applications (useful for test commits)
 UNEXPOSED_EXTENSIONS = {
     "VK_EXT_map_memory_placed",
+    "VK_KHR_external_memory_win32",
     "VK_EXT_headless_surface",
     # Extensions for other platforms
-    "VK_EXT_external_memory_dma_buf",
-    "VK_EXT_image_drm_format_modifier",
     "VK_EXT_metal_surface",
-    "VK_KHR_external_fence_fd",
-    "VK_KHR_external_memory_fd",
-    "VK_EXT_external_memory_metal",
-    "VK_KHR_external_semaphore_fd",
     "VK_KHR_wayland_surface",
     "VK_KHR_xlib_surface",
     "VK_MVK_macos_surface",
@@ -190,6 +191,7 @@ FUNCTION_OVERRIDES = {
 
     # Instance functions
     "vkCreateDevice" : {"extra_param" : "client_ptr"},
+    "vkGetPhysicalDeviceExternalBufferProperties" : {"dispatch" : False},
     "vkGetPhysicalDeviceExternalFenceProperties" : {"dispatch" : False},
     "vkGetPhysicalDeviceExternalSemaphoreProperties" : {"dispatch" : False},
 
@@ -200,6 +202,9 @@ FUNCTION_OVERRIDES = {
     # VK_KHR_external_fence_capabilities
     "vkGetPhysicalDeviceExternalFencePropertiesKHR" : {"dispatch" : False},
 
+    # VK_KHR_external_memory_capabilities
+    "vkGetPhysicalDeviceExternalBufferPropertiesKHR" : {"dispatch" : False},
+
     # VK_KHR_external_semaphore_capabilities
     "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR" : {"dispatch" : False},
 }
@@ -216,17 +221,8 @@ USER_DRIVER_FUNCS = {
     "vkDestroySurfaceKHR",
     "vkDestroySwapchainKHR",
     "vkFreeMemory",
-    "vkGetDeviceBufferMemoryRequirements",
-    "vkGetDeviceBufferMemoryRequirementsKHR",
-    "vkGetDeviceImageMemoryRequirements",
     "vkGetDeviceProcAddr",
     "vkGetInstanceProcAddr",
-    "vkGetMemoryWin32HandleKHR",
-    "vkGetMemoryWin32HandlePropertiesKHR",
-    "vkGetPhysicalDeviceExternalBufferProperties",
-    "vkGetPhysicalDeviceExternalBufferPropertiesKHR",
-    "vkGetPhysicalDeviceImageFormatProperties2",
-    "vkGetPhysicalDeviceImageFormatProperties2KHR",
     "vkGetPhysicalDevicePresentRectanglesKHR",
     "vkGetPhysicalDeviceSurfaceCapabilities2KHR",
     "vkGetPhysicalDeviceSurfaceCapabilitiesKHR",
@@ -272,10 +268,14 @@ MANUAL_UNIX_THUNKS = {
     "vkGetInstanceProcAddr",
     "vkGetPhysicalDeviceCalibrateableTimeDomainsEXT",
     "vkGetPhysicalDeviceCalibrateableTimeDomainsKHR",
+    "vkGetPhysicalDeviceExternalBufferProperties",
+    "vkGetPhysicalDeviceExternalBufferPropertiesKHR",
     "vkGetPhysicalDeviceExternalFenceProperties",
     "vkGetPhysicalDeviceExternalFencePropertiesKHR",
     "vkGetPhysicalDeviceExternalSemaphoreProperties",
     "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR",
+    "vkGetPhysicalDeviceImageFormatProperties2",
+    "vkGetPhysicalDeviceImageFormatProperties2KHR",
 }
 
 # loader functions which are entirely manually implemented
@@ -302,16 +302,9 @@ MANUAL_LOADER_THUNKS = {
 }
 
 STRUCT_CHAIN_CONVERSIONS = {
-    # Force making copies of some struct chains
-    "VkMemoryAllocateInfo": {},
-    "VkBufferCreateInfo": {},
-    "VkImageCreateInfo": {},
-    "VkPhysicalDeviceExternalBufferInfo": {},
-    "VkPhysicalDeviceImageFormatInfo2": {},
-
     # Ignore to not confuse host loader.
-    "VkDeviceCreateInfo": {"strip": ["VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO"]},
-    "VkInstanceCreateInfo": {"strip": ["VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO"]},
+    "VkDeviceCreateInfo": ["VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO"],
+    "VkInstanceCreateInfo": ["VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO"],
 }
 
 # Some struct members are conditionally ignored and callers are free to leave them uninitialized.
@@ -2301,9 +2294,8 @@ class StructConversionFunction(object):
 
             ident = "            "
 
-            if self.direction == Direction.INPUT and self.type in STRUCT_CHAIN_CONVERSIONS \
-                    and "strip" in STRUCT_CHAIN_CONVERSIONS[self.type]:
-                for i in STRUCT_CHAIN_CONVERSIONS[self.type]["strip"]:
+            if self.direction == Direction.INPUT and self.type in STRUCT_CHAIN_CONVERSIONS:
+                for i in STRUCT_CHAIN_CONVERSIONS[self.type]:
                     body += "        case {0}:\n".format(i)
                 body += ident + "break;\n"
 
diff --git b/dlls/winevulkan/vulkan_thunks.c a/dlls/winevulkan/vulkan_thunks.c
index 816da31f22c..ac5604c80e5 100644
--- b/dlls/winevulkan/vulkan_thunks.c
+++ a/dlls/winevulkan/vulkan_thunks.c
@@ -3102,15 +3102,6 @@ typedef struct VkExportMemoryAllocateInfo32
 } VkExportMemoryAllocateInfo32;
 typedef VkExportMemoryAllocateInfo32 VkExportMemoryAllocateInfoKHR32;
 
-typedef struct VkExportMemoryWin32HandleInfoKHR32
-{
-    VkStructureType sType;
-    PTR32 pNext;
-    PTR32 pAttributes;
-    DWORD dwAccess;
-    LPCWSTR name;
-} VkExportMemoryWin32HandleInfoKHR32;
-
 typedef struct VkExportSemaphoreCreateInfo32
 {
     VkStructureType sType;
@@ -3632,15 +3623,6 @@ typedef struct VkImportMemoryHostPointerInfoEXT32
     PTR32 pHostPointer;
 } VkImportMemoryHostPointerInfoEXT32;
 
-typedef struct VkImportMemoryWin32HandleInfoKHR32
-{
-    VkStructureType sType;
-    PTR32 pNext;
-    VkExternalMemoryHandleTypeFlagBits handleType;
-    HANDLE handle;
-    LPCWSTR name;
-} VkImportMemoryWin32HandleInfoKHR32;
-
 typedef struct VkIndirectCommandsLayoutCreateInfoEXT32
 {
     VkStructureType sType;
@@ -3799,14 +3781,6 @@ typedef struct VkMemoryDedicatedRequirements32
 } VkMemoryDedicatedRequirements32;
 typedef VkMemoryDedicatedRequirements32 VkMemoryDedicatedRequirementsKHR32;
 
-typedef struct VkMemoryGetWin32HandleInfoKHR32
-{
-    VkStructureType sType;
-    PTR32 pNext;
-    VkDeviceMemory DECLSPEC_ALIGN(8) memory;
-    VkExternalMemoryHandleTypeFlagBits handleType;
-} VkMemoryGetWin32HandleInfoKHR32;
-
 typedef struct VkMemoryHostPointerPropertiesEXT32
 {
     VkStructureType sType;
@@ -3858,13 +3832,6 @@ typedef struct VkMemoryUnmapInfo32
 } VkMemoryUnmapInfo32;
 typedef VkMemoryUnmapInfo32 VkMemoryUnmapInfoKHR32;
 
-typedef struct VkMemoryWin32HandlePropertiesKHR32
-{
-    VkStructureType sType;
-    PTR32 pNext;
-    uint32_t memoryTypeBits;
-} VkMemoryWin32HandlePropertiesKHR32;
-
 typedef struct VkMicromapBuildInfoEXT32
 {
     VkStructureType sType;
@@ -9651,149 +9618,6 @@ static void convert_VkDescriptorSetAllocateInfo_win32_to_host(struct conversion_
     }
 }
 
-#ifdef _WIN64
-static void convert_VkMemoryAllocateInfo_win64_to_host(struct conversion_context *ctx, const VkMemoryAllocateInfo *in, VkMemoryAllocateInfo *out)
-{
-    const VkBaseInStructure *in_header;
-    VkBaseOutStructure *out_header = (void *)out;
-
-    if (!in) return;
-
-    out->sType = in->sType;
-    out->pNext = NULL;
-    out->allocationSize = in->allocationSize;
-    out->memoryTypeIndex = in->memoryTypeIndex;
-
-    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
-    {
-        switch (in_header->sType)
-        {
-        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
-        {
-            VkDedicatedAllocationMemoryAllocateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkDedicatedAllocationMemoryAllocateInfoNV *in_ext = (const VkDedicatedAllocationMemoryAllocateInfoNV *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV;
-            out_ext->pNext = NULL;
-            out_ext->image = in_ext->image;
-            out_ext->buffer = in_ext->buffer;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
-        {
-            VkExportMemoryAllocateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkExportMemoryAllocateInfo *in_ext = (const VkExportMemoryAllocateInfo *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO;
-            out_ext->pNext = NULL;
-            out_ext->handleTypes = in_ext->handleTypes;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
-        {
-            VkExportMemoryWin32HandleInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkExportMemoryWin32HandleInfoKHR *in_ext = (const VkExportMemoryWin32HandleInfoKHR *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
-            out_ext->pNext = NULL;
-            out_ext->pAttributes = in_ext->pAttributes;
-            out_ext->dwAccess = in_ext->dwAccess;
-            out_ext->name = in_ext->name;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
-        {
-            VkImportMemoryHostPointerInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkImportMemoryHostPointerInfoEXT *in_ext = (const VkImportMemoryHostPointerInfoEXT *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT;
-            out_ext->pNext = NULL;
-            out_ext->handleType = in_ext->handleType;
-            out_ext->pHostPointer = in_ext->pHostPointer;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
-        {
-            VkImportMemoryWin32HandleInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkImportMemoryWin32HandleInfoKHR *in_ext = (const VkImportMemoryWin32HandleInfoKHR *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
-            out_ext->pNext = NULL;
-            out_ext->handleType = in_ext->handleType;
-            out_ext->handle = in_ext->handle;
-            out_ext->name = in_ext->name;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
-        {
-            VkMemoryAllocateFlagsInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkMemoryAllocateFlagsInfo *in_ext = (const VkMemoryAllocateFlagsInfo *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO;
-            out_ext->pNext = NULL;
-            out_ext->flags = in_ext->flags;
-            out_ext->deviceMask = in_ext->deviceMask;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
-        {
-            VkMemoryDedicatedAllocateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkMemoryDedicatedAllocateInfo *in_ext = (const VkMemoryDedicatedAllocateInfo *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO;
-            out_ext->pNext = NULL;
-            out_ext->image = in_ext->image;
-            out_ext->buffer = in_ext->buffer;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM:
-        {
-            VkMemoryDedicatedAllocateInfoTensorARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkMemoryDedicatedAllocateInfoTensorARM *in_ext = (const VkMemoryDedicatedAllocateInfoTensorARM *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM;
-            out_ext->pNext = NULL;
-            out_ext->tensor = in_ext->tensor;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO:
-        {
-            VkMemoryOpaqueCaptureAddressAllocateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkMemoryOpaqueCaptureAddressAllocateInfo *in_ext = (const VkMemoryOpaqueCaptureAddressAllocateInfo *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO;
-            out_ext->pNext = NULL;
-            out_ext->opaqueCaptureAddress = in_ext->opaqueCaptureAddress;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT:
-        {
-            VkMemoryPriorityAllocateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkMemoryPriorityAllocateInfoEXT *in_ext = (const VkMemoryPriorityAllocateInfoEXT *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT;
-            out_ext->pNext = NULL;
-            out_ext->priority = in_ext->priority;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
-            break;
-        }
-    }
-}
-#endif /* _WIN64 */
-
 static void convert_VkMemoryAllocateInfo_win32_to_host(struct conversion_context *ctx, const VkMemoryAllocateInfo32 *in, VkMemoryAllocateInfo *out)
 {
     const VkBaseInStructure32 *in_header;
@@ -9833,19 +9657,6 @@ static void convert_VkMemoryAllocateInfo_win32_to_host(struct conversion_context
             out_header = (void *)out_ext;
             break;
         }
-        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
-        {
-            VkExportMemoryWin32HandleInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkExportMemoryWin32HandleInfoKHR32 *in_ext = (const VkExportMemoryWin32HandleInfoKHR32 *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
-            out_ext->pNext = NULL;
-            out_ext->pAttributes = UlongToPtr(in_ext->pAttributes);
-            out_ext->dwAccess = in_ext->dwAccess;
-            out_ext->name = in_ext->name;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
         case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
         {
             VkImportMemoryHostPointerInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -9858,19 +9669,6 @@ static void convert_VkMemoryAllocateInfo_win32_to_host(struct conversion_context
             out_header = (void *)out_ext;
             break;
         }
-        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
-        {
-            VkImportMemoryWin32HandleInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkImportMemoryWin32HandleInfoKHR32 *in_ext = (const VkImportMemoryWin32HandleInfoKHR32 *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
-            out_ext->pNext = NULL;
-            out_ext->handleType = in_ext->handleType;
-            out_ext->handle = in_ext->handle;
-            out_ext->name = in_ext->name;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
         case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
         {
             VkMemoryAllocateFlagsInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -14946,113 +14744,6 @@ static void convert_VkAccelerationStructureCreateInfoNV_win32_to_host(struct con
     }
 }
 
-#ifdef _WIN64
-static void convert_VkBufferCreateInfo_win64_to_host(struct conversion_context *ctx, const VkBufferCreateInfo *in, VkBufferCreateInfo *out)
-{
-    const VkBaseInStructure *in_header;
-    VkBaseOutStructure *out_header = (void *)out;
-
-    if (!in) return;
-
-    out->sType = in->sType;
-    out->pNext = NULL;
-    out->flags = in->flags;
-    out->size = in->size;
-    out->usage = in->usage;
-    out->sharingMode = in->sharingMode;
-    out->queueFamilyIndexCount = in->queueFamilyIndexCount;
-    out->pQueueFamilyIndices = in->pQueueFamilyIndices;
-
-    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
-    {
-        switch (in_header->sType)
-        {
-        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT:
-        {
-            VkBufferDeviceAddressCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkBufferDeviceAddressCreateInfoEXT *in_ext = (const VkBufferDeviceAddressCreateInfoEXT *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT;
-            out_ext->pNext = NULL;
-            out_ext->deviceAddress = in_ext->deviceAddress;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO:
-        {
-            VkBufferOpaqueCaptureAddressCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkBufferOpaqueCaptureAddressCreateInfo *in_ext = (const VkBufferOpaqueCaptureAddressCreateInfo *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO;
-            out_ext->pNext = NULL;
-            out_ext->opaqueCaptureAddress = in_ext->opaqueCaptureAddress;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO:
-        {
-            VkBufferUsageFlags2CreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkBufferUsageFlags2CreateInfo *in_ext = (const VkBufferUsageFlags2CreateInfo *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO;
-            out_ext->pNext = NULL;
-            out_ext->usage = in_ext->usage;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
-        {
-            VkDedicatedAllocationBufferCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkDedicatedAllocationBufferCreateInfoNV *in_ext = (const VkDedicatedAllocationBufferCreateInfoNV *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV;
-            out_ext->pNext = NULL;
-            out_ext->dedicatedAllocation = in_ext->dedicatedAllocation;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
-        {
-            VkExternalMemoryBufferCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkExternalMemoryBufferCreateInfo *in_ext = (const VkExternalMemoryBufferCreateInfo *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
-            out_ext->pNext = NULL;
-            out_ext->handleTypes = in_ext->handleTypes;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT:
-        {
-            VkOpaqueCaptureDescriptorDataCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkOpaqueCaptureDescriptorDataCreateInfoEXT *in_ext = (const VkOpaqueCaptureDescriptorDataCreateInfoEXT *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT;
-            out_ext->pNext = NULL;
-            out_ext->opaqueCaptureDescriptorData = in_ext->opaqueCaptureDescriptorData;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR:
-        {
-            VkVideoProfileListInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkVideoProfileListInfoKHR *in_ext = (const VkVideoProfileListInfoKHR *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR;
-            out_ext->pNext = NULL;
-            out_ext->profileCount = in_ext->profileCount;
-            out_ext->pProfiles = in_ext->pProfiles;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
-            break;
-        }
-    }
-}
-#endif /* _WIN64 */
-
 static void convert_VkVideoProfileInfoKHR_win32_to_host(struct conversion_context *ctx, const VkVideoProfileInfoKHR32 *in, VkVideoProfileInfoKHR *out)
 {
     const VkBaseInStructure32 *in_header;
@@ -27562,35 +27253,6 @@ static void convert_VkAccelerationStructureVersionInfoKHR_win32_to_host(const Vk
         FIXME("Unexpected pNext\n");
 }
 
-#ifdef _WIN64
-static const VkBufferCreateInfo *convert_VkBufferCreateInfo_array_win64_to_host(struct conversion_context *ctx, const VkBufferCreateInfo *in, uint32_t count)
-{
-    VkBufferCreateInfo *out;
-    unsigned int i;
-
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
-    {
-        convert_VkBufferCreateInfo_win64_to_host(ctx, &in[i], &out[i]);
-    }
-
-    return out;
-}
-#endif /* _WIN64 */
-
-#ifdef _WIN64
-static void convert_VkDeviceBufferMemoryRequirements_win64_to_host(struct conversion_context *ctx, const VkDeviceBufferMemoryRequirements *in, VkDeviceBufferMemoryRequirements *out)
-{
-    if (!in) return;
-
-    out->sType = in->sType;
-    out->pNext = in->pNext;
-    out->pCreateInfo = convert_VkBufferCreateInfo_array_win64_to_host(ctx, in->pCreateInfo, 1);
-}
-#endif /* _WIN64 */
-
 static const VkBufferCreateInfo *convert_VkBufferCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkBufferCreateInfo32 *in, uint32_t count)
 {
     VkBufferCreateInfo *out;
@@ -28520,35 +28182,6 @@ static void convert_VkMemoryHostPointerPropertiesEXT_host_to_win32(const VkMemor
     out->memoryTypeBits = in->memoryTypeBits;
 }
 
-static void convert_VkMemoryGetWin32HandleInfoKHR_win32_to_unwrapped_host(const VkMemoryGetWin32HandleInfoKHR32 *in, VkMemoryGetWin32HandleInfoKHR *out)
-{
-    if (!in) return;
-
-    out->sType = in->sType;
-    out->pNext = NULL;
-    out->memory = in->memory;
-    out->handleType = in->handleType;
-    if (in->pNext)
-        FIXME("Unexpected pNext\n");
-}
-
-static void convert_VkMemoryWin32HandlePropertiesKHR_win32_to_host(const VkMemoryWin32HandlePropertiesKHR32 *in, VkMemoryWin32HandlePropertiesKHR *out)
-{
-    if (!in) return;
-
-    out->sType = in->sType;
-    out->pNext = NULL;
-    if (in->pNext)
-        FIXME("Unexpected pNext\n");
-}
-
-static void convert_VkMemoryWin32HandlePropertiesKHR_host_to_win32(const VkMemoryWin32HandlePropertiesKHR *in, VkMemoryWin32HandlePropertiesKHR32 *out)
-{
-    if (!in) return;
-
-    out->memoryTypeBits = in->memoryTypeBits;
-}
-
 static void convert_VkMicromapBuildSizesInfoEXT_win32_to_host(const VkMicromapBuildSizesInfoEXT32 *in, VkMicromapBuildSizesInfoEXT *out)
 {
     if (!in) return;
@@ -28814,43 +28447,6 @@ static void convert_VkCooperativeVectorPropertiesNV_array_host_to_win32(const Vk
     }
 }
 
-#ifdef _WIN64
-static void convert_VkPhysicalDeviceExternalBufferInfo_win64_to_host(struct conversion_context *ctx, const VkPhysicalDeviceExternalBufferInfo *in, VkPhysicalDeviceExternalBufferInfo *out)
-{
-    const VkBaseInStructure *in_header;
-    VkBaseOutStructure *out_header = (void *)out;
-
-    if (!in) return;
-
-    out->sType = in->sType;
-    out->pNext = NULL;
-    out->flags = in->flags;
-    out->usage = in->usage;
-    out->handleType = in->handleType;
-
-    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
-    {
-        switch (in_header->sType)
-        {
-        case VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO:
-        {
-            VkBufferUsageFlags2CreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkBufferUsageFlags2CreateInfo *in_ext = (const VkBufferUsageFlags2CreateInfo *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO;
-            out_ext->pNext = NULL;
-            out_ext->usage = in_ext->usage;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
-            break;
-        }
-    }
-}
-#endif /* _WIN64 */
-
 static void convert_VkPhysicalDeviceExternalBufferInfo_win32_to_host(struct conversion_context *ctx, const VkPhysicalDeviceExternalBufferInfo32 *in, VkPhysicalDeviceExternalBufferInfo *out)
 {
     const VkBaseInStructure32 *in_header;
@@ -34130,115 +33726,6 @@ static void convert_VkImageFormatProperties_host_to_win32(const VkImageFormatPro
     out->maxResourceSize = in->maxResourceSize;
 }
 
-#ifdef _WIN64
-static void convert_VkPhysicalDeviceImageFormatInfo2_win64_to_host(struct conversion_context *ctx, const VkPhysicalDeviceImageFormatInfo2 *in, VkPhysicalDeviceImageFormatInfo2 *out)
-{
-    const VkBaseInStructure *in_header;
-    VkBaseOutStructure *out_header = (void *)out;
-
-    if (!in) return;
-
-    out->sType = in->sType;
-    out->pNext = NULL;
-    out->format = in->format;
-    out->type = in->type;
-    out->tiling = in->tiling;
-    out->usage = in->usage;
-    out->flags = in->flags;
-
-    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
-    {
-        switch (in_header->sType)
-        {
-        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT:
-        {
-            VkImageCompressionControlEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkImageCompressionControlEXT *in_ext = (const VkImageCompressionControlEXT *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT;
-            out_ext->pNext = NULL;
-            out_ext->flags = in_ext->flags;
-            out_ext->compressionControlPlaneCount = in_ext->compressionControlPlaneCount;
-            out_ext->pFixedRateFlags = in_ext->pFixedRateFlags;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO:
-        {
-            VkImageFormatListCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkImageFormatListCreateInfo *in_ext = (const VkImageFormatListCreateInfo *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO;
-            out_ext->pNext = NULL;
-            out_ext->viewFormatCount = in_ext->viewFormatCount;
-            out_ext->pViewFormats = in_ext->pViewFormats;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO:
-        {
-            VkImageStencilUsageCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkImageStencilUsageCreateInfo *in_ext = (const VkImageStencilUsageCreateInfo *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO;
-            out_ext->pNext = NULL;
-            out_ext->stencilUsage = in_ext->stencilUsage;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV:
-        {
-            VkOpticalFlowImageFormatInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkOpticalFlowImageFormatInfoNV *in_ext = (const VkOpticalFlowImageFormatInfoNV *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV;
-            out_ext->pNext = NULL;
-            out_ext->usage = in_ext->usage;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
-        {
-            VkPhysicalDeviceExternalImageFormatInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkPhysicalDeviceExternalImageFormatInfo *in_ext = (const VkPhysicalDeviceExternalImageFormatInfo *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO;
-            out_ext->pNext = NULL;
-            out_ext->handleType = in_ext->handleType;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT:
-        {
-            VkPhysicalDeviceImageViewImageFormatInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkPhysicalDeviceImageViewImageFormatInfoEXT *in_ext = (const VkPhysicalDeviceImageViewImageFormatInfoEXT *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT;
-            out_ext->pNext = NULL;
-            out_ext->imageViewType = in_ext->imageViewType;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR:
-        {
-            VkVideoProfileListInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkVideoProfileListInfoKHR *in_ext = (const VkVideoProfileListInfoKHR *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR;
-            out_ext->pNext = NULL;
-            out_ext->profileCount = in_ext->profileCount;
-            out_ext->pProfiles = in_ext->pProfiles;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
-            break;
-        }
-    }
-}
-#endif /* _WIN64 */
-
 static void convert_VkPhysicalDeviceImageFormatInfo2_win32_to_host(struct conversion_context *ctx, const VkPhysicalDeviceImageFormatInfo232 *in, VkPhysicalDeviceImageFormatInfo2 *out)
 {
     const VkBaseInStructure32 *in_header;
@@ -40643,16 +40130,10 @@ static NTSTATUS thunk32_vkAllocateDescriptorSets(void *args)
 static NTSTATUS thunk64_vkAllocateMemory(void *args)
 {
     struct vkAllocateMemory_params *params = args;
-    VkMemoryAllocateInfo pAllocateInfo_host;
-    struct conversion_context local_ctx;
-    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%p, %p, %p, %p\n", params->device, params->pAllocateInfo, params->pAllocator, params->pMemory);
 
-    init_conversion_context(ctx);
-    convert_VkMemoryAllocateInfo_win64_to_host(ctx, params->pAllocateInfo, &pAllocateInfo_host);
-    params->result = vk_funcs->p_vkAllocateMemory(params->device, &pAllocateInfo_host, params->pAllocator, params->pMemory);
-    free_conversion_context(ctx);
+    params->result = vk_funcs->p_vkAllocateMemory(params->device, params->pAllocateInfo, params->pAllocator, params->pMemory);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -48112,16 +47593,10 @@ static NTSTATUS thunk32_vkCreateAccelerationStructureNV(void *args)
 static NTSTATUS thunk64_vkCreateBuffer(void *args)
 {
     struct vkCreateBuffer_params *params = args;
-    VkBufferCreateInfo pCreateInfo_host;
-    struct conversion_context local_ctx;
-    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pBuffer);
 
-    init_conversion_context(ctx);
-    convert_VkBufferCreateInfo_win64_to_host(ctx, params->pCreateInfo, &pCreateInfo_host);
-    params->result = vk_funcs->p_vkCreateBuffer(params->device, &pCreateInfo_host, params->pAllocator, params->pBuffer);
-    free_conversion_context(ctx);
+    params->result = vk_funcs->p_vkCreateBuffer(params->device, params->pCreateInfo, params->pAllocator, params->pBuffer);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -52816,16 +52291,10 @@ static NTSTATUS thunk32_vkGetDeviceAccelerationStructureCompatibilityKHR(void *a
 static NTSTATUS thunk64_vkGetDeviceBufferMemoryRequirements(void *args)
 {
     struct vkGetDeviceBufferMemoryRequirements_params *params = args;
-    VkDeviceBufferMemoryRequirements pInfo_host;
-    struct conversion_context local_ctx;
-    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pMemoryRequirements);
 
-    init_conversion_context(ctx);
-    convert_VkDeviceBufferMemoryRequirements_win64_to_host(ctx, params->pInfo, &pInfo_host);
-    vk_funcs->p_vkGetDeviceBufferMemoryRequirements(params->device, &pInfo_host, params->pMemoryRequirements);
-    free_conversion_context(ctx);
+    vulkan_device_from_handle(params->device)->p_vkGetDeviceBufferMemoryRequirements(vulkan_device_from_handle(params->device)->host.device, params->pInfo, params->pMemoryRequirements);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -52848,7 +52317,7 @@ static NTSTATUS thunk32_vkGetDeviceBufferMemoryRequirements(void *args)
     init_conversion_context(ctx);
     convert_VkDeviceBufferMemoryRequirements_win32_to_host(ctx, (const VkDeviceBufferMemoryRequirements32 *)UlongToPtr(params->pInfo), &pInfo_host);
     convert_VkMemoryRequirements2_win32_to_host(ctx, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
-    vk_funcs->p_vkGetDeviceBufferMemoryRequirements((VkDevice)UlongToPtr(params->device), &pInfo_host, &pMemoryRequirements_host);
+    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDeviceBufferMemoryRequirements(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, &pMemoryRequirements_host);
     convert_VkMemoryRequirements2_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements));
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
@@ -52858,16 +52327,10 @@ static NTSTATUS thunk32_vkGetDeviceBufferMemoryRequirements(void *args)
 static NTSTATUS thunk64_vkGetDeviceBufferMemoryRequirementsKHR(void *args)
 {
     struct vkGetDeviceBufferMemoryRequirementsKHR_params *params = args;
-    VkDeviceBufferMemoryRequirements pInfo_host;
-    struct conversion_context local_ctx;
-    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pMemoryRequirements);
 
-    init_conversion_context(ctx);
-    convert_VkDeviceBufferMemoryRequirements_win64_to_host(ctx, params->pInfo, &pInfo_host);
-    vk_funcs->p_vkGetDeviceBufferMemoryRequirementsKHR(params->device, &pInfo_host, params->pMemoryRequirements);
-    free_conversion_context(ctx);
+    vulkan_device_from_handle(params->device)->p_vkGetDeviceBufferMemoryRequirementsKHR(vulkan_device_from_handle(params->device)->host.device, params->pInfo, params->pMemoryRequirements);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -52890,7 +52353,7 @@ static NTSTATUS thunk32_vkGetDeviceBufferMemoryRequirementsKHR(void *args)
     init_conversion_context(ctx);
     convert_VkDeviceBufferMemoryRequirements_win32_to_host(ctx, (const VkDeviceBufferMemoryRequirements32 *)UlongToPtr(params->pInfo), &pInfo_host);
     convert_VkMemoryRequirements2_win32_to_host(ctx, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
-    vk_funcs->p_vkGetDeviceBufferMemoryRequirementsKHR((VkDevice)UlongToPtr(params->device), &pInfo_host, &pMemoryRequirements_host);
+    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDeviceBufferMemoryRequirementsKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, &pMemoryRequirements_host);
     convert_VkMemoryRequirements2_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements));
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
@@ -53066,7 +52529,7 @@ static NTSTATUS thunk64_vkGetDeviceImageMemoryRequirements(void *args)
 
     init_conversion_context(ctx);
     convert_VkDeviceImageMemoryRequirements_win64_to_host(ctx, params->pInfo, &pInfo_host);
-    vk_funcs->p_vkGetDeviceImageMemoryRequirements(params->device, &pInfo_host, params->pMemoryRequirements);
+    vulkan_device_from_handle(params->device)->p_vkGetDeviceImageMemoryRequirements(vulkan_device_from_handle(params->device)->host.device, &pInfo_host, params->pMemoryRequirements);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -53090,7 +52553,7 @@ static NTSTATUS thunk32_vkGetDeviceImageMemoryRequirements(void *args)
     init_conversion_context(ctx);
     convert_VkDeviceImageMemoryRequirements_win32_to_host(ctx, (const VkDeviceImageMemoryRequirements32 *)UlongToPtr(params->pInfo), &pInfo_host);
     convert_VkMemoryRequirements2_win32_to_host(ctx, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
-    vk_funcs->p_vkGetDeviceImageMemoryRequirements((VkDevice)UlongToPtr(params->device), &pInfo_host, &pMemoryRequirements_host);
+    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDeviceImageMemoryRequirements(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, &pMemoryRequirements_host);
     convert_VkMemoryRequirements2_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements));
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
@@ -54365,68 +53828,6 @@ static NTSTATUS thunk32_vkGetMemoryHostPointerPropertiesEXT(void *args)
     return STATUS_SUCCESS;
 }
 
-#ifdef _WIN64
-static NTSTATUS thunk64_vkGetMemoryWin32HandleKHR(void *args)
-{
-    struct vkGetMemoryWin32HandleKHR_params *params = args;
-
-    TRACE("%p, %p, %p\n", params->device, params->pGetWin32HandleInfo, params->pHandle);
-
-    params->result = vk_funcs->p_vkGetMemoryWin32HandleKHR(params->device, params->pGetWin32HandleInfo, params->pHandle);
-    return STATUS_SUCCESS;
-}
-#endif /* _WIN64 */
-
-static NTSTATUS thunk32_vkGetMemoryWin32HandleKHR(void *args)
-{
-    struct
-    {
-        PTR32 device;
-        PTR32 pGetWin32HandleInfo;
-        PTR32 pHandle;
-        VkResult result;
-    } *params = args;
-    VkMemoryGetWin32HandleInfoKHR pGetWin32HandleInfo_host;
-
-    TRACE("%#x, %#x, %#x\n", params->device, params->pGetWin32HandleInfo, params->pHandle);
-
-    convert_VkMemoryGetWin32HandleInfoKHR_win32_to_unwrapped_host((const VkMemoryGetWin32HandleInfoKHR32 *)UlongToPtr(params->pGetWin32HandleInfo), &pGetWin32HandleInfo_host);
-    params->result = vk_funcs->p_vkGetMemoryWin32HandleKHR((VkDevice)UlongToPtr(params->device), &pGetWin32HandleInfo_host, (HANDLE *)UlongToPtr(params->pHandle));
-    return STATUS_SUCCESS;
-}
-
-#ifdef _WIN64
-static NTSTATUS thunk64_vkGetMemoryWin32HandlePropertiesKHR(void *args)
-{
-    struct vkGetMemoryWin32HandlePropertiesKHR_params *params = args;
-
-    TRACE("%p, %#x, %p, %p\n", params->device, params->handleType, params->handle, params->pMemoryWin32HandleProperties);
-
-    params->result = vk_funcs->p_vkGetMemoryWin32HandlePropertiesKHR(params->device, params->handleType, params->handle, params->pMemoryWin32HandleProperties);
-    return STATUS_SUCCESS;
-}
-#endif /* _WIN64 */
-
-static NTSTATUS thunk32_vkGetMemoryWin32HandlePropertiesKHR(void *args)
-{
-    struct
-    {
-        PTR32 device;
-        VkExternalMemoryHandleTypeFlagBits handleType;
-        HANDLE handle;
-        PTR32 pMemoryWin32HandleProperties;
-        VkResult result;
-    } *params = args;
-    VkMemoryWin32HandlePropertiesKHR pMemoryWin32HandleProperties_host;
-
-    TRACE("%#x, %#x, %p, %#x\n", params->device, params->handleType, params->handle, params->pMemoryWin32HandleProperties);
-
-    convert_VkMemoryWin32HandlePropertiesKHR_win32_to_host((VkMemoryWin32HandlePropertiesKHR32 *)UlongToPtr(params->pMemoryWin32HandleProperties), &pMemoryWin32HandleProperties_host);
-    params->result = vk_funcs->p_vkGetMemoryWin32HandlePropertiesKHR((VkDevice)UlongToPtr(params->device), params->handleType, params->handle, &pMemoryWin32HandleProperties_host);
-    convert_VkMemoryWin32HandlePropertiesKHR_host_to_win32(&pMemoryWin32HandleProperties_host, (VkMemoryWin32HandlePropertiesKHR32 *)UlongToPtr(params->pMemoryWin32HandleProperties));
-    return STATUS_SUCCESS;
-}
-
 #ifdef _WIN64
 static NTSTATUS thunk64_vkGetMicromapBuildSizesEXT(void *args)
 {
@@ -54731,16 +54132,10 @@ static NTSTATUS thunk32_vkGetPhysicalDeviceCooperativeVectorPropertiesNV(void *a
 static NTSTATUS thunk64_vkGetPhysicalDeviceExternalBufferProperties(void *args)
 {
     struct vkGetPhysicalDeviceExternalBufferProperties_params *params = args;
-    VkPhysicalDeviceExternalBufferInfo pExternalBufferInfo_host;
-    struct conversion_context local_ctx;
-    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%p, %p, %p\n", params->physicalDevice, params->pExternalBufferInfo, params->pExternalBufferProperties);
 
-    init_conversion_context(ctx);
-    convert_VkPhysicalDeviceExternalBufferInfo_win64_to_host(ctx, params->pExternalBufferInfo, &pExternalBufferInfo_host);
-    vk_funcs->p_vkGetPhysicalDeviceExternalBufferProperties(params->physicalDevice, &pExternalBufferInfo_host, params->pExternalBufferProperties);
-    free_conversion_context(ctx);
+    wine_vkGetPhysicalDeviceExternalBufferProperties(params->physicalDevice, params->pExternalBufferInfo, params->pExternalBufferProperties);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -54763,7 +54158,7 @@ static NTSTATUS thunk32_vkGetPhysicalDeviceExternalBufferProperties(void *args)
     init_conversion_context(ctx);
     convert_VkPhysicalDeviceExternalBufferInfo_win32_to_host(ctx, (const VkPhysicalDeviceExternalBufferInfo32 *)UlongToPtr(params->pExternalBufferInfo), &pExternalBufferInfo_host);
     convert_VkExternalBufferProperties_win32_to_host((VkExternalBufferProperties32 *)UlongToPtr(params->pExternalBufferProperties), &pExternalBufferProperties_host);
-    vk_funcs->p_vkGetPhysicalDeviceExternalBufferProperties((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pExternalBufferInfo_host, &pExternalBufferProperties_host);
+    wine_vkGetPhysicalDeviceExternalBufferProperties((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pExternalBufferInfo_host, &pExternalBufferProperties_host);
     convert_VkExternalBufferProperties_host_to_win32(&pExternalBufferProperties_host, (VkExternalBufferProperties32 *)UlongToPtr(params->pExternalBufferProperties));
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
@@ -54773,16 +54168,10 @@ static NTSTATUS thunk32_vkGetPhysicalDeviceExternalBufferProperties(void *args)
 static NTSTATUS thunk64_vkGetPhysicalDeviceExternalBufferPropertiesKHR(void *args)
 {
     struct vkGetPhysicalDeviceExternalBufferPropertiesKHR_params *params = args;
-    VkPhysicalDeviceExternalBufferInfo pExternalBufferInfo_host;
-    struct conversion_context local_ctx;
-    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%p, %p, %p\n", params->physicalDevice, params->pExternalBufferInfo, params->pExternalBufferProperties);
 
-    init_conversion_context(ctx);
-    convert_VkPhysicalDeviceExternalBufferInfo_win64_to_host(ctx, params->pExternalBufferInfo, &pExternalBufferInfo_host);
-    vk_funcs->p_vkGetPhysicalDeviceExternalBufferPropertiesKHR(params->physicalDevice, &pExternalBufferInfo_host, params->pExternalBufferProperties);
-    free_conversion_context(ctx);
+    wine_vkGetPhysicalDeviceExternalBufferPropertiesKHR(params->physicalDevice, params->pExternalBufferInfo, params->pExternalBufferProperties);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -54805,7 +54194,7 @@ static NTSTATUS thunk32_vkGetPhysicalDeviceExternalBufferPropertiesKHR(void *arg
     init_conversion_context(ctx);
     convert_VkPhysicalDeviceExternalBufferInfo_win32_to_host(ctx, (const VkPhysicalDeviceExternalBufferInfo32 *)UlongToPtr(params->pExternalBufferInfo), &pExternalBufferInfo_host);
     convert_VkExternalBufferProperties_win32_to_host((VkExternalBufferProperties32 *)UlongToPtr(params->pExternalBufferProperties), &pExternalBufferProperties_host);
-    vk_funcs->p_vkGetPhysicalDeviceExternalBufferPropertiesKHR((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pExternalBufferInfo_host, &pExternalBufferProperties_host);
+    wine_vkGetPhysicalDeviceExternalBufferPropertiesKHR((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pExternalBufferInfo_host, &pExternalBufferProperties_host);
     convert_VkExternalBufferProperties_host_to_win32(&pExternalBufferProperties_host, (VkExternalBufferProperties32 *)UlongToPtr(params->pExternalBufferProperties));
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
@@ -55243,16 +54632,10 @@ static NTSTATUS thunk32_vkGetPhysicalDeviceImageFormatProperties(void *args)
 static NTSTATUS thunk64_vkGetPhysicalDeviceImageFormatProperties2(void *args)
 {
     struct vkGetPhysicalDeviceImageFormatProperties2_params *params = args;
-    VkPhysicalDeviceImageFormatInfo2 pImageFormatInfo_host;
-    struct conversion_context local_ctx;
-    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%p, %p, %p\n", params->physicalDevice, params->pImageFormatInfo, params->pImageFormatProperties);
 
-    init_conversion_context(ctx);
-    convert_VkPhysicalDeviceImageFormatInfo2_win64_to_host(ctx, params->pImageFormatInfo, &pImageFormatInfo_host);
-    params->result = vk_funcs->p_vkGetPhysicalDeviceImageFormatProperties2(params->physicalDevice, &pImageFormatInfo_host, params->pImageFormatProperties);
-    free_conversion_context(ctx);
+    params->result = wine_vkGetPhysicalDeviceImageFormatProperties2(params->physicalDevice, params->pImageFormatInfo, params->pImageFormatProperties);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -55276,7 +54659,7 @@ static NTSTATUS thunk32_vkGetPhysicalDeviceImageFormatProperties2(void *args)
     init_conversion_context(ctx);
     convert_VkPhysicalDeviceImageFormatInfo2_win32_to_host(ctx, (const VkPhysicalDeviceImageFormatInfo232 *)UlongToPtr(params->pImageFormatInfo), &pImageFormatInfo_host);
     convert_VkImageFormatProperties2_win32_to_host(ctx, (VkImageFormatProperties232 *)UlongToPtr(params->pImageFormatProperties), &pImageFormatProperties_host);
-    params->result = vk_funcs->p_vkGetPhysicalDeviceImageFormatProperties2((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pImageFormatInfo_host, &pImageFormatProperties_host);
+    params->result = wine_vkGetPhysicalDeviceImageFormatProperties2((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pImageFormatInfo_host, &pImageFormatProperties_host);
     convert_VkImageFormatProperties2_host_to_win32(&pImageFormatProperties_host, (VkImageFormatProperties232 *)UlongToPtr(params->pImageFormatProperties));
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
@@ -55286,16 +54669,10 @@ static NTSTATUS thunk32_vkGetPhysicalDeviceImageFormatProperties2(void *args)
 static NTSTATUS thunk64_vkGetPhysicalDeviceImageFormatProperties2KHR(void *args)
 {
     struct vkGetPhysicalDeviceImageFormatProperties2KHR_params *params = args;
-    VkPhysicalDeviceImageFormatInfo2 pImageFormatInfo_host;
-    struct conversion_context local_ctx;
-    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%p, %p, %p\n", params->physicalDevice, params->pImageFormatInfo, params->pImageFormatProperties);
 
-    init_conversion_context(ctx);
-    convert_VkPhysicalDeviceImageFormatInfo2_win64_to_host(ctx, params->pImageFormatInfo, &pImageFormatInfo_host);
-    params->result = vk_funcs->p_vkGetPhysicalDeviceImageFormatProperties2KHR(params->physicalDevice, &pImageFormatInfo_host, params->pImageFormatProperties);
-    free_conversion_context(ctx);
+    params->result = wine_vkGetPhysicalDeviceImageFormatProperties2KHR(params->physicalDevice, params->pImageFormatInfo, params->pImageFormatProperties);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -55319,7 +54696,7 @@ static NTSTATUS thunk32_vkGetPhysicalDeviceImageFormatProperties2KHR(void *args)
     init_conversion_context(ctx);
     convert_VkPhysicalDeviceImageFormatInfo2_win32_to_host(ctx, (const VkPhysicalDeviceImageFormatInfo232 *)UlongToPtr(params->pImageFormatInfo), &pImageFormatInfo_host);
     convert_VkImageFormatProperties2_win32_to_host(ctx, (VkImageFormatProperties232 *)UlongToPtr(params->pImageFormatProperties), &pImageFormatProperties_host);
-    params->result = vk_funcs->p_vkGetPhysicalDeviceImageFormatProperties2KHR((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pImageFormatInfo_host, &pImageFormatProperties_host);
+    params->result = wine_vkGetPhysicalDeviceImageFormatProperties2KHR((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pImageFormatInfo_host, &pImageFormatProperties_host);
     convert_VkImageFormatProperties2_host_to_win32(&pImageFormatProperties_host, (VkImageFormatProperties232 *)UlongToPtr(params->pImageFormatProperties));
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
@@ -59586,7 +58963,6 @@ static const char * const vk_device_extensions[] =
     "VK_KHR_dynamic_rendering_local_read",
     "VK_KHR_external_fence",
     "VK_KHR_external_memory",
-    "VK_KHR_external_memory_win32",
     "VK_KHR_external_semaphore",
     "VK_KHR_format_feature_flags2",
     "VK_KHR_fragment_shader_barycentric",
@@ -60346,8 +59722,6 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     thunk64_vkGetImageViewOpaqueCaptureDescriptorDataEXT,
     thunk64_vkGetLatencyTimingsNV,
     thunk64_vkGetMemoryHostPointerPropertiesEXT,
-    thunk64_vkGetMemoryWin32HandleKHR,
-    thunk64_vkGetMemoryWin32HandlePropertiesKHR,
     thunk64_vkGetMicromapBuildSizesEXT,
     thunk64_vkGetPartitionedAccelerationStructuresBuildSizesNV,
     thunk64_vkGetPerformanceParameterINTEL,
@@ -61020,8 +60394,6 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     thunk32_vkGetImageViewOpaqueCaptureDescriptorDataEXT,
     thunk32_vkGetLatencyTimingsNV,
     thunk32_vkGetMemoryHostPointerPropertiesEXT,
-    thunk32_vkGetMemoryWin32HandleKHR,
-    thunk32_vkGetMemoryWin32HandlePropertiesKHR,
     thunk32_vkGetMicromapBuildSizesEXT,
     thunk32_vkGetPartitionedAccelerationStructuresBuildSizesNV,
     thunk32_vkGetPerformanceParameterINTEL,
diff --git b/dlls/winevulkan/vulkan_thunks.h a/dlls/winevulkan/vulkan_thunks.h
index a7736bb7923..4f5abf6cabc 100644
--- b/dlls/winevulkan/vulkan_thunks.h
+++ a/dlls/winevulkan/vulkan_thunks.h
@@ -48,9 +48,13 @@ void wine_vkGetDeviceQueue(VkDevice device, uint32_t queueFamilyIndex, uint32_t
 void wine_vkGetDeviceQueue2(VkDevice device, const VkDeviceQueueInfo2 *pQueueInfo, VkQueue *pQueue);
 VkResult wine_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(VkPhysicalDevice physicalDevice, uint32_t *pTimeDomainCount, VkTimeDomainKHR *pTimeDomains);
 VkResult wine_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR(VkPhysicalDevice physicalDevice, uint32_t *pTimeDomainCount, VkTimeDomainKHR *pTimeDomains);
+void wine_vkGetPhysicalDeviceExternalBufferProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties);
+void wine_vkGetPhysicalDeviceExternalBufferPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties);
 void wine_vkGetPhysicalDeviceExternalFenceProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties);
 void wine_vkGetPhysicalDeviceExternalFencePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties);
 void wine_vkGetPhysicalDeviceExternalSemaphoreProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, VkExternalSemaphoreProperties *pExternalSemaphoreProperties);
 void wine_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, VkExternalSemaphoreProperties *pExternalSemaphoreProperties);
+VkResult wine_vkGetPhysicalDeviceImageFormatProperties2(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties);
+VkResult wine_vkGetPhysicalDeviceImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties);
 
 #endif /* __WINE_VULKAN_THUNKS_H */
diff --git b/include/wine/vulkan.h a/include/wine/vulkan.h
index 4336a154ecc..76c2da1244d 100644
--- b/include/wine/vulkan.h
+++ a/include/wine/vulkan.h
@@ -178,14 +178,10 @@ typedef struct _XDisplay Display;
 #define VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME "VK_KHR_external_memory"
 #define VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION 1
 #define VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME "VK_KHR_external_memory_win32"
-#define VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION 1
-#define VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME "VK_KHR_external_memory_fd"
 #define VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION 1
 #define VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME "VK_KHR_external_semaphore_capabilities"
 #define VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION 1
 #define VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME "VK_KHR_external_semaphore"
-#define VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION 1
-#define VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME "VK_KHR_external_semaphore_fd"
 #define VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION 2
 #define VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME "VK_KHR_push_descriptor"
 #define VK_EXT_CONDITIONAL_RENDERING_SPEC_VERSION 2
@@ -230,8 +226,6 @@ typedef struct _XDisplay Display;
 #define VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME "VK_KHR_external_fence_capabilities"
 #define VK_KHR_EXTERNAL_FENCE_SPEC_VERSION 1
 #define VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME "VK_KHR_external_fence"
-#define VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION 1
-#define VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME "VK_KHR_external_fence_fd"
 #define VK_KHR_PERFORMANCE_QUERY_SPEC_VERSION 1
 #define VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME "VK_KHR_performance_query"
 #define VK_KHR_MAINTENANCE2_SPEC_VERSION VK_KHR_MAINTENANCE_2_SPEC_VERSION
@@ -244,8 +238,6 @@ typedef struct _XDisplay Display;
 #define VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME "VK_KHR_variable_pointers"
 #define VK_MVK_MACOS_SURFACE_SPEC_VERSION 3
 #define VK_MVK_MACOS_SURFACE_EXTENSION_NAME "VK_MVK_macos_surface"
-#define VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION 1
-#define VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME "VK_EXT_external_memory_dma_buf"
 #define VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION 1
 #define VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME "VK_EXT_queue_family_foreign"
 #define VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION 3
@@ -292,8 +284,6 @@ typedef struct _XDisplay Display;
 #define VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME "VK_KHR_sampler_ycbcr_conversion"
 #define VK_KHR_BIND_MEMORY_2_SPEC_VERSION 1
 #define VK_KHR_BIND_MEMORY_2_EXTENSION_NAME "VK_KHR_bind_memory2"
-#define VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION 2
-#define VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME "VK_EXT_image_drm_format_modifier"
 #define VK_EXT_VALIDATION_CACHE_SPEC_VERSION 1
 #define VK_EXT_VALIDATION_CACHE_EXTENSION_NAME "VK_EXT_validation_cache"
 #define VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION 2
@@ -799,8 +789,6 @@ typedef struct _XDisplay Display;
 #define VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME "VK_NV_cooperative_matrix2"
 #define VK_ARM_PIPELINE_OPACITY_MICROMAP_SPEC_VERSION 1
 #define VK_ARM_PIPELINE_OPACITY_MICROMAP_EXTENSION_NAME "VK_ARM_pipeline_opacity_micromap"
-#define VK_EXT_EXTERNAL_MEMORY_METAL_SPEC_VERSION 1
-#define VK_EXT_EXTERNAL_MEMORY_METAL_EXTENSION_NAME "VK_EXT_external_memory_metal"
 #define VK_KHR_DEPTH_CLAMP_ZERO_ONE_SPEC_VERSION 1
 #define VK_KHR_DEPTH_CLAMP_ZERO_ONE_EXTENSION_NAME "VK_KHR_depth_clamp_zero_one"
 #define VK_EXT_VERTEX_ATTRIBUTE_ROBUSTNESS_SPEC_VERSION 1
@@ -2985,10 +2973,6 @@ typedef enum VkExternalMemoryHandleTypeFlagBits
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT = 0x00000040,
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT = 0x00000080,
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT = 0x00000100,
-    VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT = 0x00000200,
-    VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT = 0x00010000,
-    VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_EXT = 0x00020000,
-    VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT = 0x00040000,
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT,
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
@@ -3630,10 +3614,6 @@ typedef enum VkImageAspectFlagBits
     VK_IMAGE_ASPECT_PLANE_0_BIT = 0x00000010,
     VK_IMAGE_ASPECT_PLANE_1_BIT = 0x00000020,
     VK_IMAGE_ASPECT_PLANE_2_BIT = 0x00000040,
-    VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT = 0x00000080,
-    VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT = 0x00000100,
-    VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT = 0x00000200,
-    VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT = 0x00000400,
     VK_IMAGE_ASPECT_PLANE_0_BIT_KHR = VK_IMAGE_ASPECT_PLANE_0_BIT,
     VK_IMAGE_ASPECT_PLANE_1_BIT_KHR = VK_IMAGE_ASPECT_PLANE_1_BIT,
     VK_IMAGE_ASPECT_PLANE_2_BIT_KHR = VK_IMAGE_ASPECT_PLANE_2_BIT,
@@ -3762,7 +3742,6 @@ typedef enum VkImageTiling
 {
     VK_IMAGE_TILING_OPTIMAL = 0,
     VK_IMAGE_TILING_LINEAR = 1,
-    VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT = 1000158000,
     VK_IMAGE_TILING_MAX_ENUM = 0x7fffffff,
 } VkImageTiling;
 
@@ -4951,7 +4930,6 @@ typedef enum VkResult
     VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS = -1000257000,
     VK_ERROR_NOT_PERMITTED = -1000174001,
     VK_ERROR_FRAGMENTATION = -1000161000,
-    VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = -1000158000,
     VK_ERROR_INVALID_EXTERNAL_HANDLE = -1000072003,
     VK_ERROR_OUT_OF_POOL_MEMORY = -1000069000,
     VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR = -1000023005,
@@ -5447,14 +5425,9 @@ typedef enum VkStructureType
     VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001,
     VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002,
     VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR = 1000073003,
-    VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR = 1000074000,
-    VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR = 1000074001,
-    VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR = 1000074002,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 1000076000,
     VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES = 1000076001,
     VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO = 1000077000,
-    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000,
-    VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR = 1000079001,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES = 1000080000,
     VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT = 1000081000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT = 1000081001,
@@ -5488,8 +5461,6 @@ typedef enum VkStructureType
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 1000112000,
     VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES = 1000112001,
     VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO = 1000113000,
-    VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR = 1000115000,
-    VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR = 1000115001,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR = 1000116000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR = 1000116001,
     VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR = 1000116002,
@@ -5569,12 +5540,6 @@ typedef enum VkStructureType
     VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 1000156005,
     VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO = 1000157000,
     VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO = 1000157001,
-    VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT = 1000158000,
-    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT = 1000158002,
-    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT = 1000158003,
-    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT = 1000158004,
-    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158005,
-    VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT = 1000158006,
     VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160000,
     VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160001,
     VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO = 1000161000,
@@ -6204,9 +6169,6 @@ typedef enum VkStructureType
     VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV = 1000593001,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV = 1000593002,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM = 1000596000,
-    VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT = 1000602000,
-    VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT = 1000602001,
-    VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT = 1000602002,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT = 1000608000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM = 1000609000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE = 1000611000,
@@ -9282,20 +9244,6 @@ typedef struct VkDeviceQueueCreateInfo
     const float *pQueuePriorities;
 } VkDeviceQueueCreateInfo;
 
-typedef struct VkDrmFormatModifierProperties2EXT
-{
-    uint64_t WINE_VK_ALIGN(8) drmFormatModifier;
-    uint32_t drmFormatModifierPlaneCount;
-    VkFormatFeatureFlags2 WINE_VK_ALIGN(8) drmFormatModifierTilingFeatures;
-} VkDrmFormatModifierProperties2EXT;
-
-typedef struct VkDrmFormatModifierPropertiesEXT
-{
-    uint64_t WINE_VK_ALIGN(8) drmFormatModifier;
-    uint32_t drmFormatModifierPlaneCount;
-    VkFormatFeatureFlags drmFormatModifierTilingFeatures;
-} VkDrmFormatModifierPropertiesEXT;
-
 typedef struct VkExtensionProperties
 {
     char extensionName[VK_MAX_EXTENSION_NAME_SIZE];
@@ -11940,22 +11888,6 @@ typedef struct VkDrawMeshTasksIndirectCommandNV
     uint32_t firstTask;
 } VkDrawMeshTasksIndirectCommandNV;
 
-typedef struct VkDrmFormatModifierPropertiesList2EXT
-{
-    VkStructureType sType;
-    void *pNext;
-    uint32_t drmFormatModifierCount;
-    VkDrmFormatModifierProperties2EXT *pDrmFormatModifierProperties;
-} VkDrmFormatModifierPropertiesList2EXT;
-
-typedef struct VkDrmFormatModifierPropertiesListEXT
-{
-    VkStructureType sType;
-    void *pNext;
-    uint32_t drmFormatModifierCount;
-    VkDrmFormatModifierPropertiesEXT *pDrmFormatModifierProperties;
-} VkDrmFormatModifierPropertiesListEXT;
-
 typedef struct VkEventCreateInfo
 {
     VkStructureType sType;
@@ -12076,14 +12008,6 @@ typedef struct VkFenceCreateInfo
     VkFenceCreateFlags flags;
 } VkFenceCreateInfo;
 
-typedef struct VkFenceGetFdInfoKHR
-{
-    VkStructureType sType;
-    const void *pNext;
-    VkFence WINE_VK_ALIGN(8) fence;
-    VkExternalFenceHandleTypeFlagBits handleType;
-} VkFenceGetFdInfoKHR;
-
 typedef struct VkFilterCubicImageViewImageFormatPropertiesEXT
 {
     VkStructureType sType;
@@ -12388,30 +12312,6 @@ typedef struct VkImageCopy
     VkExtent3D extent;
 } VkImageCopy;
 
-typedef struct VkImageDrmFormatModifierExplicitCreateInfoEXT
-{
-    VkStructureType sType;
-    const void *pNext;
-    uint64_t WINE_VK_ALIGN(8) drmFormatModifier;
-    uint32_t drmFormatModifierPlaneCount;
-    const VkSubresourceLayout *pPlaneLayouts;
-} VkImageDrmFormatModifierExplicitCreateInfoEXT;
-
-typedef struct VkImageDrmFormatModifierListCreateInfoEXT
-{
-    VkStructureType sType;
-    const void *pNext;
-    uint32_t drmFormatModifierCount;
-    const uint64_t *pDrmFormatModifiers;
-} VkImageDrmFormatModifierListCreateInfoEXT;
-
-typedef struct VkImageDrmFormatModifierPropertiesEXT
-{
-    VkStructureType sType;
-    void *pNext;
-    uint64_t WINE_VK_ALIGN(8) drmFormatModifier;
-} VkImageDrmFormatModifierPropertiesEXT;
-
 typedef struct VkImageFormatListCreateInfo
 {
     VkStructureType sType;
@@ -12566,24 +12466,6 @@ typedef struct VkImageViewUsageCreateInfo
 } VkImageViewUsageCreateInfo;
 typedef VkImageViewUsageCreateInfo VkImageViewUsageCreateInfoKHR;
 
-typedef struct VkImportFenceFdInfoKHR
-{
-    VkStructureType sType;
-    const void *pNext;
-    VkFence WINE_VK_ALIGN(8) fence;
-    VkFenceImportFlags flags;
-    VkExternalFenceHandleTypeFlagBits handleType;
-    int fd;
-} VkImportFenceFdInfoKHR;
-
-typedef struct VkImportMemoryFdInfoKHR
-{
-    VkStructureType sType;
-    const void *pNext;
-    VkExternalMemoryHandleTypeFlagBits handleType;
-    int fd;
-} VkImportMemoryFdInfoKHR;
-
 typedef struct VkImportMemoryHostPointerInfoEXT
 {
     VkStructureType sType;
@@ -12592,14 +12474,6 @@ typedef struct VkImportMemoryHostPointerInfoEXT
     void *pHostPointer;
 } VkImportMemoryHostPointerInfoEXT;
 
-typedef struct VkImportMemoryMetalHandleInfoEXT
-{
-    VkStructureType sType;
-    const void *pNext;
-    VkExternalMemoryHandleTypeFlagBits handleType;
-    void *handle;
-} VkImportMemoryMetalHandleInfoEXT;
-
 typedef struct VkImportMemoryWin32HandleInfoKHR
 {
     VkStructureType sType;
@@ -12609,16 +12483,6 @@ typedef struct VkImportMemoryWin32HandleInfoKHR
     LPCWSTR name;
 } VkImportMemoryWin32HandleInfoKHR;
 
-typedef struct VkImportSemaphoreFdInfoKHR
-{
-    VkStructureType sType;
-    const void *pNext;
-    VkSemaphore WINE_VK_ALIGN(8) semaphore;
-    VkSemaphoreImportFlags flags;
-    VkExternalSemaphoreHandleTypeFlagBits handleType;
-    int fd;
-} VkImportSemaphoreFdInfoKHR;
-
 typedef struct VkIndirectCommandsLayoutCreateInfoEXT
 {
     VkStructureType sType;
@@ -12793,29 +12657,6 @@ typedef struct VkMemoryDedicatedRequirements
 } VkMemoryDedicatedRequirements;
 typedef VkMemoryDedicatedRequirements VkMemoryDedicatedRequirementsKHR;
 
-typedef struct VkMemoryFdPropertiesKHR
-{
-    VkStructureType sType;
-    void *pNext;
-    uint32_t memoryTypeBits;
-} VkMemoryFdPropertiesKHR;
-
-typedef struct VkMemoryGetFdInfoKHR
-{
-    VkStructureType sType;
-    const void *pNext;
-    VkDeviceMemory WINE_VK_ALIGN(8) memory;
-    VkExternalMemoryHandleTypeFlagBits handleType;
-} VkMemoryGetFdInfoKHR;
-
-typedef struct VkMemoryGetMetalHandleInfoEXT
-{
-    VkStructureType sType;
-    const void *pNext;
-    VkDeviceMemory WINE_VK_ALIGN(8) memory;
-    VkExternalMemoryHandleTypeFlagBits handleType;
-} VkMemoryGetMetalHandleInfoEXT;
-
 typedef struct VkMemoryGetWin32HandleInfoKHR
 {
     VkStructureType sType;
@@ -12849,13 +12690,6 @@ typedef struct VkMemoryMapPlacedInfoEXT
     void *pPlacedAddress;
 } VkMemoryMapPlacedInfoEXT;
 
-typedef struct VkMemoryMetalHandlePropertiesEXT
-{
-    VkStructureType sType;
-    void *pNext;
-    uint32_t memoryTypeBits;
-} VkMemoryMetalHandlePropertiesEXT;
-
 typedef struct VkMemoryOpaqueCaptureAddressAllocateInfo
 {
     VkStructureType sType;
@@ -14322,16 +14156,6 @@ typedef struct VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT
     VkBool32 imageCompressionControlSwapchain;
 } VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT;
 
-typedef struct VkPhysicalDeviceImageDrmFormatModifierInfoEXT
-{
-    VkStructureType sType;
-    const void *pNext;
-    uint64_t WINE_VK_ALIGN(8) drmFormatModifier;
-    VkSharingMode sharingMode;
-    uint32_t queueFamilyIndexCount;
-    const uint32_t *pQueueFamilyIndices;
-} VkPhysicalDeviceImageDrmFormatModifierInfoEXT;
-
 typedef struct VkPhysicalDeviceImageFormatInfo2
 {
     VkStructureType sType;
@@ -17440,14 +17264,6 @@ typedef struct VkSemaphoreCreateInfo
     VkSemaphoreCreateFlags flags;
 } VkSemaphoreCreateInfo;
 
-typedef struct VkSemaphoreGetFdInfoKHR
-{
-    VkStructureType sType;
-    const void *pNext;
-    VkSemaphore WINE_VK_ALIGN(8) semaphore;
-    VkExternalSemaphoreHandleTypeFlagBits handleType;
-} VkSemaphoreGetFdInfoKHR;
-
 typedef struct VkSemaphoreSignalInfo
 {
     VkStructureType sType;
@@ -19208,12 +19024,10 @@ typedef void (VKAPI_PTR *PFN_vkGetDeviceTensorMemoryRequirementsARM)(VkDevice, c
 typedef VkResult (VKAPI_PTR *PFN_vkGetDynamicRenderingTilePropertiesQCOM)(VkDevice, const VkRenderingInfo *, VkTilePropertiesQCOM *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetEncodedVideoSessionParametersKHR)(VkDevice, const VkVideoEncodeSessionParametersGetInfoKHR *, VkVideoEncodeSessionParametersFeedbackInfoKHR *, size_t *, void *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetEventStatus)(VkDevice, VkEvent);
-typedef VkResult (VKAPI_PTR *PFN_vkGetFenceFdKHR)(VkDevice, const VkFenceGetFdInfoKHR *, int *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetFenceStatus)(VkDevice, VkFence);
 typedef VkResult (VKAPI_PTR *PFN_vkGetFramebufferTilePropertiesQCOM)(VkDevice, VkFramebuffer, uint32_t *, VkTilePropertiesQCOM *);
 typedef void (VKAPI_PTR *PFN_vkGetGeneratedCommandsMemoryRequirementsEXT)(VkDevice, const VkGeneratedCommandsMemoryRequirementsInfoEXT *, VkMemoryRequirements2 *);
 typedef void (VKAPI_PTR *PFN_vkGetGeneratedCommandsMemoryRequirementsNV)(VkDevice, const VkGeneratedCommandsMemoryRequirementsInfoNV *, VkMemoryRequirements2 *);
-typedef VkResult (VKAPI_PTR *PFN_vkGetImageDrmFormatModifierPropertiesEXT)(VkDevice, VkImage, VkImageDrmFormatModifierPropertiesEXT *);
 typedef void (VKAPI_PTR *PFN_vkGetImageMemoryRequirements)(VkDevice, VkImage, VkMemoryRequirements *);
 typedef void (VKAPI_PTR *PFN_vkGetImageMemoryRequirements2)(VkDevice, const VkImageMemoryRequirementsInfo2 *, VkMemoryRequirements2 *);
 typedef void (VKAPI_PTR *PFN_vkGetImageMemoryRequirements2KHR)(VkDevice, const VkImageMemoryRequirementsInfo2 *, VkMemoryRequirements2 *);
@@ -19231,11 +19045,7 @@ typedef uint32_t (VKAPI_PTR *PFN_vkGetImageViewHandleNVX)(VkDevice, const VkImag
 typedef VkResult (VKAPI_PTR *PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT)(VkDevice, const VkImageViewCaptureDescriptorDataInfoEXT *, void *);
 typedef PFN_vkVoidFunction (VKAPI_PTR *PFN_vkGetInstanceProcAddr)(VkInstance, const char *);
 typedef void (VKAPI_PTR *PFN_vkGetLatencyTimingsNV)(VkDevice, VkSwapchainKHR, VkGetLatencyMarkerInfoNV *);
-typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryFdKHR)(VkDevice, const VkMemoryGetFdInfoKHR *, int *);
-typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryFdPropertiesKHR)(VkDevice, VkExternalMemoryHandleTypeFlagBits, int, VkMemoryFdPropertiesKHR *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryHostPointerPropertiesEXT)(VkDevice, VkExternalMemoryHandleTypeFlagBits, const void *, VkMemoryHostPointerPropertiesEXT *);
-typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryMetalHandleEXT)(VkDevice, const VkMemoryGetMetalHandleInfoEXT *, void **);
-typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryMetalHandlePropertiesEXT)(VkDevice, VkExternalMemoryHandleTypeFlagBits, const void *, VkMemoryMetalHandlePropertiesEXT *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryWin32HandleKHR)(VkDevice, const VkMemoryGetWin32HandleInfoKHR *, HANDLE *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryWin32HandlePropertiesKHR)(VkDevice, VkExternalMemoryHandleTypeFlagBits, HANDLE, VkMemoryWin32HandlePropertiesKHR *);
 typedef void (VKAPI_PTR *PFN_vkGetMicromapBuildSizesEXT)(VkDevice, VkAccelerationStructureBuildTypeKHR, const VkMicromapBuildInfoEXT *, VkMicromapBuildSizesInfoEXT *);
@@ -19321,7 +19131,6 @@ typedef void (VKAPI_PTR *PFN_vkGetRenderingAreaGranularityKHR)(VkDevice, const V
 typedef VkResult (VKAPI_PTR *PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT)(VkDevice, const VkSamplerCaptureDescriptorDataInfoEXT *, void *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetSemaphoreCounterValue)(VkDevice, VkSemaphore, uint64_t *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetSemaphoreCounterValueKHR)(VkDevice, VkSemaphore, uint64_t *);
-typedef VkResult (VKAPI_PTR *PFN_vkGetSemaphoreFdKHR)(VkDevice, const VkSemaphoreGetFdInfoKHR *, int *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetShaderBinaryDataEXT)(VkDevice, VkShaderEXT, size_t *, void *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetShaderInfoAMD)(VkDevice, VkPipeline, VkShaderStageFlagBits, VkShaderInfoTypeAMD, size_t *, void *);
 typedef void (VKAPI_PTR *PFN_vkGetShaderModuleCreateInfoIdentifierEXT)(VkDevice, const VkShaderModuleCreateInfo *, VkShaderModuleIdentifierEXT *);
@@ -19332,8 +19141,6 @@ typedef VkResult (VKAPI_PTR *PFN_vkGetTensorOpaqueCaptureDescriptorDataARM)(VkDe
 typedef VkResult (VKAPI_PTR *PFN_vkGetTensorViewOpaqueCaptureDescriptorDataARM)(VkDevice, const VkTensorViewCaptureDescriptorDataInfoARM *, void *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetValidationCacheDataEXT)(VkDevice, VkValidationCacheEXT, size_t *, void *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetVideoSessionMemoryRequirementsKHR)(VkDevice, VkVideoSessionKHR, uint32_t *, VkVideoSessionMemoryRequirementsKHR *);
-typedef VkResult (VKAPI_PTR *PFN_vkImportFenceFdKHR)(VkDevice, const VkImportFenceFdInfoKHR *);
-typedef VkResult (VKAPI_PTR *PFN_vkImportSemaphoreFdKHR)(VkDevice, const VkImportSemaphoreFdInfoKHR *);
 typedef VkResult (VKAPI_PTR *PFN_vkInitializePerformanceApiINTEL)(VkDevice, const VkInitializePerformanceApiInfoINTEL *);
 typedef VkResult (VKAPI_PTR *PFN_vkInvalidateMappedMemoryRanges)(VkDevice, uint32_t, const VkMappedMemoryRange *);
 typedef VkResult (VKAPI_PTR *PFN_vkLatencySleepNV)(VkDevice, VkSwapchainKHR, const VkLatencySleepInfoNV *);
@@ -19889,12 +19696,10 @@ void VKAPI_CALL vkGetDeviceTensorMemoryRequirementsARM(VkDevice device, const Vk
 VkResult VKAPI_CALL vkGetDynamicRenderingTilePropertiesQCOM(VkDevice device, const VkRenderingInfo *pRenderingInfo, VkTilePropertiesQCOM *pProperties);
 VkResult VKAPI_CALL vkGetEncodedVideoSessionParametersKHR(VkDevice device, const VkVideoEncodeSessionParametersGetInfoKHR *pVideoSessionParametersInfo, VkVideoEncodeSessionParametersFeedbackInfoKHR *pFeedbackInfo, size_t *pDataSize, void *pData);
 VkResult VKAPI_CALL vkGetEventStatus(VkDevice device, VkEvent event);
-VkResult VKAPI_CALL vkGetFenceFdKHR(VkDevice device, const VkFenceGetFdInfoKHR *pGetFdInfo, int *pFd);
 VkResult VKAPI_CALL vkGetFenceStatus(VkDevice device, VkFence fence);
 VkResult VKAPI_CALL vkGetFramebufferTilePropertiesQCOM(VkDevice device, VkFramebuffer framebuffer, uint32_t *pPropertiesCount, VkTilePropertiesQCOM *pProperties);
 void VKAPI_CALL vkGetGeneratedCommandsMemoryRequirementsEXT(VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoEXT *pInfo, VkMemoryRequirements2 *pMemoryRequirements);
 void VKAPI_CALL vkGetGeneratedCommandsMemoryRequirementsNV(VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoNV *pInfo, VkMemoryRequirements2 *pMemoryRequirements);
-VkResult VKAPI_CALL vkGetImageDrmFormatModifierPropertiesEXT(VkDevice device, VkImage image, VkImageDrmFormatModifierPropertiesEXT *pProperties);
 void VKAPI_CALL vkGetImageMemoryRequirements(VkDevice device, VkImage image, VkMemoryRequirements *pMemoryRequirements);
 void VKAPI_CALL vkGetImageMemoryRequirements2(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements);
 void VKAPI_CALL vkGetImageMemoryRequirements2KHR(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements);
@@ -19912,11 +19717,7 @@ uint32_t VKAPI_CALL vkGetImageViewHandleNVX(VkDevice device, const VkImageViewHa
 VkResult VKAPI_CALL vkGetImageViewOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkImageViewCaptureDescriptorDataInfoEXT *pInfo, void *pData);
 PFN_vkVoidFunction VKAPI_CALL vkGetInstanceProcAddr(VkInstance instance, const char *pName);
 void VKAPI_CALL vkGetLatencyTimingsNV(VkDevice device, VkSwapchainKHR swapchain, VkGetLatencyMarkerInfoNV *pLatencyMarkerInfo);
-VkResult VKAPI_CALL vkGetMemoryFdKHR(VkDevice device, const VkMemoryGetFdInfoKHR *pGetFdInfo, int *pFd);
-VkResult VKAPI_CALL vkGetMemoryFdPropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, int fd, VkMemoryFdPropertiesKHR *pMemoryFdProperties);
 VkResult VKAPI_CALL vkGetMemoryHostPointerPropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void *pHostPointer, VkMemoryHostPointerPropertiesEXT *pMemoryHostPointerProperties);
-VkResult VKAPI_CALL vkGetMemoryMetalHandleEXT(VkDevice device, const VkMemoryGetMetalHandleInfoEXT *pGetMetalHandleInfo, void **pHandle);
-VkResult VKAPI_CALL vkGetMemoryMetalHandlePropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void *pHandle, VkMemoryMetalHandlePropertiesEXT *pMemoryMetalHandleProperties);
 VkResult VKAPI_CALL vkGetMemoryWin32HandleKHR(VkDevice device, const VkMemoryGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle);
 VkResult VKAPI_CALL vkGetMemoryWin32HandlePropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, HANDLE handle, VkMemoryWin32HandlePropertiesKHR *pMemoryWin32HandleProperties);
 void VKAPI_CALL vkGetMicromapBuildSizesEXT(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkMicromapBuildInfoEXT *pBuildInfo, VkMicromapBuildSizesInfoEXT *pSizeInfo);
@@ -20002,7 +19803,6 @@ void VKAPI_CALL vkGetRenderingAreaGranularityKHR(VkDevice device, const VkRender
 VkResult VKAPI_CALL vkGetSamplerOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkSamplerCaptureDescriptorDataInfoEXT *pInfo, void *pData);
 VkResult VKAPI_CALL vkGetSemaphoreCounterValue(VkDevice device, VkSemaphore semaphore, uint64_t *pValue);
 VkResult VKAPI_CALL vkGetSemaphoreCounterValueKHR(VkDevice device, VkSemaphore semaphore, uint64_t *pValue);
-VkResult VKAPI_CALL vkGetSemaphoreFdKHR(VkDevice device, const VkSemaphoreGetFdInfoKHR *pGetFdInfo, int *pFd);
 VkResult VKAPI_CALL vkGetShaderBinaryDataEXT(VkDevice device, VkShaderEXT shader, size_t *pDataSize, void *pData);
 VkResult VKAPI_CALL vkGetShaderInfoAMD(VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage, VkShaderInfoTypeAMD infoType, size_t *pInfoSize, void *pInfo);
 void VKAPI_CALL vkGetShaderModuleCreateInfoIdentifierEXT(VkDevice device, const VkShaderModuleCreateInfo *pCreateInfo, VkShaderModuleIdentifierEXT *pIdentifier);
@@ -20013,8 +19813,6 @@ VkResult VKAPI_CALL vkGetTensorOpaqueCaptureDescriptorDataARM(VkDevice device, c
 VkResult VKAPI_CALL vkGetTensorViewOpaqueCaptureDescriptorDataARM(VkDevice device, const VkTensorViewCaptureDescriptorDataInfoARM *pInfo, void *pData);
 VkResult VKAPI_CALL vkGetValidationCacheDataEXT(VkDevice device, VkValidationCacheEXT validationCache, size_t *pDataSize, void *pData);
 VkResult VKAPI_CALL vkGetVideoSessionMemoryRequirementsKHR(VkDevice device, VkVideoSessionKHR videoSession, uint32_t *pMemoryRequirementsCount, VkVideoSessionMemoryRequirementsKHR *pMemoryRequirements);
-VkResult VKAPI_CALL vkImportFenceFdKHR(VkDevice device, const VkImportFenceFdInfoKHR *pImportFenceFdInfo);
-VkResult VKAPI_CALL vkImportSemaphoreFdKHR(VkDevice device, const VkImportSemaphoreFdInfoKHR *pImportSemaphoreFdInfo);
 VkResult VKAPI_CALL vkInitializePerformanceApiINTEL(VkDevice device, const VkInitializePerformanceApiInfoINTEL *pInitializeInfo);
 VkResult VKAPI_CALL vkInvalidateMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange *pMemoryRanges);
 VkResult VKAPI_CALL vkLatencySleepNV(VkDevice device, VkSwapchainKHR swapchain, const VkLatencySleepInfoNV *pSleepInfo);
@@ -20546,12 +20344,10 @@ VkResult VKAPI_CALL vkWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micr
     USE_VK_FUNC(vkGetDynamicRenderingTilePropertiesQCOM) \
     USE_VK_FUNC(vkGetEncodedVideoSessionParametersKHR) \
     USE_VK_FUNC(vkGetEventStatus) \
-    USE_VK_FUNC(vkGetFenceFdKHR) \
     USE_VK_FUNC(vkGetFenceStatus) \
     USE_VK_FUNC(vkGetFramebufferTilePropertiesQCOM) \
     USE_VK_FUNC(vkGetGeneratedCommandsMemoryRequirementsEXT) \
     USE_VK_FUNC(vkGetGeneratedCommandsMemoryRequirementsNV) \
-    USE_VK_FUNC(vkGetImageDrmFormatModifierPropertiesEXT) \
     USE_VK_FUNC(vkGetImageMemoryRequirements) \
     USE_VK_FUNC(vkGetImageMemoryRequirements2) \
     USE_VK_FUNC(vkGetImageMemoryRequirements2KHR) \
@@ -20568,11 +20364,7 @@ VkResult VKAPI_CALL vkWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micr
     USE_VK_FUNC(vkGetImageViewHandleNVX) \
     USE_VK_FUNC(vkGetImageViewOpaqueCaptureDescriptorDataEXT) \
     USE_VK_FUNC(vkGetLatencyTimingsNV) \
-    USE_VK_FUNC(vkGetMemoryFdKHR) \
-    USE_VK_FUNC(vkGetMemoryFdPropertiesKHR) \
     USE_VK_FUNC(vkGetMemoryHostPointerPropertiesEXT) \
-    USE_VK_FUNC(vkGetMemoryMetalHandleEXT) \
-    USE_VK_FUNC(vkGetMemoryMetalHandlePropertiesEXT) \
     USE_VK_FUNC(vkGetMemoryWin32HandleKHR) \
     USE_VK_FUNC(vkGetMemoryWin32HandlePropertiesKHR) \
     USE_VK_FUNC(vkGetMicromapBuildSizesEXT) \
@@ -20602,7 +20394,6 @@ VkResult VKAPI_CALL vkWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micr
     USE_VK_FUNC(vkGetSamplerOpaqueCaptureDescriptorDataEXT) \
     USE_VK_FUNC(vkGetSemaphoreCounterValue) \
     USE_VK_FUNC(vkGetSemaphoreCounterValueKHR) \
-    USE_VK_FUNC(vkGetSemaphoreFdKHR) \
     USE_VK_FUNC(vkGetShaderBinaryDataEXT) \
     USE_VK_FUNC(vkGetShaderInfoAMD) \
     USE_VK_FUNC(vkGetShaderModuleCreateInfoIdentifierEXT) \
@@ -20613,8 +20404,6 @@ VkResult VKAPI_CALL vkWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micr
     USE_VK_FUNC(vkGetTensorViewOpaqueCaptureDescriptorDataARM) \
     USE_VK_FUNC(vkGetValidationCacheDataEXT) \
     USE_VK_FUNC(vkGetVideoSessionMemoryRequirementsKHR) \
-    USE_VK_FUNC(vkImportFenceFdKHR) \
-    USE_VK_FUNC(vkImportSemaphoreFdKHR) \
     USE_VK_FUNC(vkInitializePerformanceApiINTEL) \
     USE_VK_FUNC(vkInvalidateMappedMemoryRanges) \
     USE_VK_FUNC(vkLatencySleepNV) \
@@ -20707,8 +20496,6 @@ VkResult VKAPI_CALL vkWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micr
     USE_VK_FUNC(vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR) \
     USE_VK_FUNC(vkGetPhysicalDeviceCooperativeMatrixPropertiesNV) \
     USE_VK_FUNC(vkGetPhysicalDeviceCooperativeVectorPropertiesNV) \
-    USE_VK_FUNC(vkGetPhysicalDeviceExternalBufferProperties) \
-    USE_VK_FUNC(vkGetPhysicalDeviceExternalBufferPropertiesKHR) \
     USE_VK_FUNC(vkGetPhysicalDeviceExternalTensorPropertiesARM) \
     USE_VK_FUNC(vkGetPhysicalDeviceFeatures) \
     USE_VK_FUNC(vkGetPhysicalDeviceFeatures2) \
diff --git b/include/wine/vulkan_driver.h a/include/wine/vulkan_driver.h
index c9c76d87171..c373f639451 100644
--- b/include/wine/vulkan_driver.h
+++ a/include/wine/vulkan_driver.h
@@ -185,17 +185,8 @@ struct vulkan_funcs
     PFN_vkDestroySurfaceKHR p_vkDestroySurfaceKHR;
     PFN_vkDestroySwapchainKHR p_vkDestroySwapchainKHR;
     PFN_vkFreeMemory p_vkFreeMemory;
-    PFN_vkGetDeviceBufferMemoryRequirements p_vkGetDeviceBufferMemoryRequirements;
-    PFN_vkGetDeviceBufferMemoryRequirementsKHR p_vkGetDeviceBufferMemoryRequirementsKHR;
-    PFN_vkGetDeviceImageMemoryRequirements p_vkGetDeviceImageMemoryRequirements;
     PFN_vkGetDeviceProcAddr p_vkGetDeviceProcAddr;
     PFN_vkGetInstanceProcAddr p_vkGetInstanceProcAddr;
-    PFN_vkGetMemoryWin32HandleKHR p_vkGetMemoryWin32HandleKHR;
-    PFN_vkGetMemoryWin32HandlePropertiesKHR p_vkGetMemoryWin32HandlePropertiesKHR;
-    PFN_vkGetPhysicalDeviceExternalBufferProperties p_vkGetPhysicalDeviceExternalBufferProperties;
-    PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR p_vkGetPhysicalDeviceExternalBufferPropertiesKHR;
-    PFN_vkGetPhysicalDeviceImageFormatProperties2 p_vkGetPhysicalDeviceImageFormatProperties2;
-    PFN_vkGetPhysicalDeviceImageFormatProperties2KHR p_vkGetPhysicalDeviceImageFormatProperties2KHR;
     PFN_vkGetPhysicalDevicePresentRectanglesKHR p_vkGetPhysicalDevicePresentRectanglesKHR;
     PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR p_vkGetPhysicalDeviceSurfaceCapabilities2KHR;
     PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR p_vkGetPhysicalDeviceSurfaceCapabilitiesKHR;

diff --git b/dlls/win32u/vulkan.c a/dlls/win32u/vulkan.c
index 6503b217d1c..9cd5a533060 100644
--- b/dlls/win32u/vulkan.c
+++ a/dlls/win32u/vulkan.c
@@ -46,19 +46,6 @@ WINE_DECLARE_DEBUG_CHANNEL(fps);
 
 static const struct vulkan_driver_funcs *driver_funcs;
 
-struct device_memory
-{
-    struct vulkan_device_memory obj;
-    VkDeviceSize size;
-    void *vm_map;
-};
-
-static inline struct device_memory *device_memory_from_handle( VkDeviceMemory handle )
-{
-    struct vulkan_device_memory *obj = vulkan_device_memory_from_handle( handle );
-    return CONTAINING_RECORD( obj, struct device_memory, obj );
-}
-
 struct surface
 {
     struct vulkan_surface obj;
@@ -85,319 +72,6 @@ static struct swapchain *swapchain_from_handle( VkSwapchainKHR handle )
     return CONTAINING_RECORD( obj, struct swapchain, obj );
 }
 
-static inline const void *find_next_struct( const void *head, VkStructureType type )
-{
-    const VkBaseInStructure *header;
-    for (header = head; header; header = header->pNext) if (header->sType == type) return header;
-    return NULL;
-}
-
-static VkResult allocate_external_host_memory( struct vulkan_device *device, VkMemoryAllocateInfo *alloc_info,
-                                               VkImportMemoryHostPointerInfoEXT *import_info )
-{
-    struct vulkan_physical_device *physical_device = device->physical_device;
-    VkMemoryHostPointerPropertiesEXT props =
-    {
-        .sType = VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT,
-    };
-    uint32_t i, mem_flags, align = physical_device->external_memory_align - 1;
-    SIZE_T alloc_size = alloc_info->allocationSize;
-    static int once;
-    void *mapping;
-    VkResult res;
-
-    if (!once++) FIXME( "Using VK_EXT_external_memory_host\n" );
-
-    mem_flags = physical_device->memory_properties.memoryTypes[alloc_info->memoryTypeIndex].propertyFlags;
-
-    if (NtAllocateVirtualMemory( GetCurrentProcess(), &mapping, zero_bits, &alloc_size, MEM_COMMIT, PAGE_READWRITE ))
-    {
-        ERR( "NtAllocateVirtualMemory failed\n" );
-        return VK_ERROR_OUT_OF_HOST_MEMORY;
-    }
-
-    if ((res = device->p_vkGetMemoryHostPointerPropertiesEXT( device->host.device, VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT,
-                                                              mapping, &props )))
-    {
-        ERR( "vkGetMemoryHostPointerPropertiesEXT failed: %d\n", res );
-        return res;
-    }
-
-    if (!(props.memoryTypeBits & (1u << alloc_info->memoryTypeIndex)))
-    {
-        /* If requested memory type is not allowed to use external memory, try to find a supported compatible type. */
-        uint32_t mask = mem_flags & ~VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
-        for (i = 0; i < physical_device->memory_properties.memoryTypeCount; i++)
-        {
-            if (!(props.memoryTypeBits & (1u << i))) continue;
-            if ((physical_device->memory_properties.memoryTypes[i].propertyFlags & mask) != mask) continue;
-
-            TRACE( "Memory type not compatible with host memory, using %u instead\n", i );
-            alloc_info->memoryTypeIndex = i;
-            break;
-        }
-        if (i == physical_device->memory_properties.memoryTypeCount)
-        {
-            FIXME( "Not found compatible memory type\n" );
-            alloc_size = 0;
-            NtFreeVirtualMemory( GetCurrentProcess(), &mapping, &alloc_size, MEM_RELEASE );
-        }
-    }
-
-    if (props.memoryTypeBits & (1u << alloc_info->memoryTypeIndex))
-    {
-        import_info->sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT;
-        import_info->handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT;
-        import_info->pHostPointer = mapping;
-        import_info->pNext = alloc_info->pNext;
-        alloc_info->pNext = import_info;
-        alloc_info->allocationSize = (alloc_info->allocationSize + align) & ~align;
-    }
-
-    return VK_SUCCESS;
-}
-
-static VkResult win32u_vkAllocateMemory( VkDevice client_device, const VkMemoryAllocateInfo *alloc_info,
-                                         const VkAllocationCallbacks *allocator, VkDeviceMemory *ret )
-{
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    struct vulkan_physical_device *physical_device = device->physical_device;
-    struct vulkan_instance *instance = device->physical_device->instance;
-    VkImportMemoryHostPointerInfoEXT host_pointer_info;
-    VkMemoryAllocateInfo info = *alloc_info;
-    VkDeviceMemory host_device_memory;
-    struct device_memory *memory;
-    uint32_t mem_flags;
-    void *mapping = NULL;
-    VkResult res;
-
-    /* For host visible memory, we try to use VK_EXT_external_memory_host on wow64 to ensure that mapped pointer is 32-bit. */
-    mem_flags = physical_device->memory_properties.memoryTypes[alloc_info->memoryTypeIndex].propertyFlags;
-    if (physical_device->external_memory_align && (mem_flags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) &&
-        !find_next_struct( alloc_info->pNext, VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT ) &&
-        (res = allocate_external_host_memory( device, &info, &host_pointer_info )))
-        return res;
-
-    if (!(memory = malloc( sizeof(*memory) ))) return VK_ERROR_OUT_OF_HOST_MEMORY;
-    if ((res = device->p_vkAllocateMemory( device->host.device, &info, NULL, &host_device_memory )))
-    {
-        free( memory );
-        return res;
-    }
-
-    vulkan_object_init( &memory->obj.obj, host_device_memory );
-    memory->size = info.allocationSize;
-    memory->vm_map = mapping;
-    instance->p_insert_object( instance, &memory->obj.obj );
-
-    *ret = memory->obj.client.device_memory;
-    return VK_SUCCESS;
-}
-
-static void win32u_vkFreeMemory( VkDevice client_device, VkDeviceMemory client_memory, const VkAllocationCallbacks *allocator )
-{
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    struct vulkan_physical_device *physical_device = device->physical_device;
-    struct vulkan_instance *instance = device->physical_device->instance;
-    struct device_memory *memory;
-
-    if (!client_memory) return;
-    memory = device_memory_from_handle( client_memory );
-
-    if (memory->vm_map && !physical_device->external_memory_align)
-    {
-        const VkMemoryUnmapInfoKHR info =
-        {
-            .sType = VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR,
-            .memory = memory->obj.host.device_memory,
-            .flags = VK_MEMORY_UNMAP_RESERVE_BIT_EXT,
-        };
-        device->p_vkUnmapMemory2KHR( device->host.device, &info );
-    }
-
-    device->p_vkFreeMemory( device->host.device, memory->obj.host.device_memory, NULL );
-    instance->p_remove_object( instance, &memory->obj.obj );
-
-    if (memory->vm_map)
-    {
-        SIZE_T alloc_size = 0;
-        NtFreeVirtualMemory( GetCurrentProcess(), &memory->vm_map, &alloc_size, MEM_RELEASE );
-    }
-
-    free( memory );
-}
-
-static VkResult win32u_vkMapMemory2KHR( VkDevice client_device, const VkMemoryMapInfoKHR *map_info, void **data )
-{
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    struct vulkan_physical_device *physical_device = device->physical_device;
-    struct device_memory *memory = device_memory_from_handle( map_info->memory );
-    VkMemoryMapInfoKHR info = *map_info;
-    VkMemoryMapPlacedInfoEXT placed_info =
-    {
-        .sType = VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT,
-    };
-    VkResult res;
-
-    info.memory = memory->obj.host.device_memory;
-    if (memory->vm_map)
-    {
-        *data = (char *)memory->vm_map + info.offset;
-        TRACE( "returning %p\n", *data );
-        return VK_SUCCESS;
-    }
-
-    if (physical_device->map_placed_align)
-    {
-        SIZE_T alloc_size = memory->size;
-
-        placed_info.pNext = info.pNext;
-        info.pNext = &placed_info;
-        info.offset = 0;
-        info.size = VK_WHOLE_SIZE;
-        info.flags |= VK_MEMORY_MAP_PLACED_BIT_EXT;
-
-        if (NtAllocateVirtualMemory( GetCurrentProcess(), &placed_info.pPlacedAddress, zero_bits,
-                                     &alloc_size, MEM_COMMIT, PAGE_READWRITE ))
-        {
-            ERR( "NtAllocateVirtualMemory failed\n" );
-            return VK_ERROR_OUT_OF_HOST_MEMORY;
-        }
-    }
-
-    if (device->p_vkMapMemory2KHR)
-        res = device->p_vkMapMemory2KHR( device->host.device, &info, data );
-    else
-    {
-        if (info.pNext) FIXME( "struct extension chain not implemented!\n" );
-        res = device->p_vkMapMemory( device->host.device, info.memory, info.offset, info.size, info.flags, data );
-    }
-
-    if (placed_info.pPlacedAddress)
-    {
-        if (res != VK_SUCCESS)
-        {
-            SIZE_T alloc_size = 0;
-            ERR( "vkMapMemory2EXT failed: %d\n", res );
-            NtFreeVirtualMemory( GetCurrentProcess(), &placed_info.pPlacedAddress, &alloc_size, MEM_RELEASE );
-            return res;
-        }
-        memory->vm_map = placed_info.pPlacedAddress;
-        *data = (char *)memory->vm_map + map_info->offset;
-        TRACE( "Using placed mapping %p\n", memory->vm_map );
-    }
-
-#ifdef _WIN64
-    if (NtCurrentTeb()->WowTebOffset && res == VK_SUCCESS && (UINT_PTR)*data >> 32)
-    {
-        FIXME( "returned mapping %p does not fit 32-bit pointer\n", *data );
-        device->p_vkUnmapMemory( device->host.device, memory->obj.host.device_memory );
-        *data = NULL;
-        res = VK_ERROR_OUT_OF_HOST_MEMORY;
-    }
-#endif
-
-    return res;
-}
-
-static VkResult win32u_vkMapMemory( VkDevice client_device, VkDeviceMemory client_memory, VkDeviceSize offset,
-                                    VkDeviceSize size, VkMemoryMapFlags flags, void **data )
-{
-    const VkMemoryMapInfoKHR info =
-    {
-        .sType = VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR,
-        .flags = flags,
-        .memory = client_memory,
-        .offset = offset,
-        .size = size,
-    };
-
-    return win32u_vkMapMemory2KHR( client_device, &info, data );
-}
-
-static VkResult win32u_vkUnmapMemory2KHR( VkDevice client_device, const VkMemoryUnmapInfoKHR *unmap_info )
-{
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    struct vulkan_physical_device *physical_device = device->physical_device;
-    struct device_memory *memory = device_memory_from_handle( unmap_info->memory );
-    VkMemoryUnmapInfoKHR info;
-    VkResult res;
-
-    if (memory->vm_map && physical_device->external_memory_align) return VK_SUCCESS;
-
-    if (!device->p_vkUnmapMemory2KHR)
-    {
-        if (unmap_info->pNext || memory->vm_map) FIXME( "Not implemented\n" );
-        device->p_vkUnmapMemory( device->host.device, memory->obj.host.device_memory );
-        return VK_SUCCESS;
-    }
-
-    info = *unmap_info;
-    info.memory = memory->obj.host.device_memory;
-    if (memory->vm_map) info.flags |= VK_MEMORY_UNMAP_RESERVE_BIT_EXT;
-
-    res = device->p_vkUnmapMemory2KHR( device->host.device, &info );
-
-    if (res == VK_SUCCESS && memory->vm_map)
-    {
-        SIZE_T size = 0;
-        NtFreeVirtualMemory( GetCurrentProcess(), &memory->vm_map, &size, MEM_RELEASE );
-        memory->vm_map = NULL;
-    }
-    return res;
-}
-
-static void win32u_vkUnmapMemory( VkDevice client_device, VkDeviceMemory client_memory )
-{
-    const VkMemoryUnmapInfoKHR info =
-    {
-        .sType = VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR,
-        .memory = client_memory,
-    };
-
-    win32u_vkUnmapMemory2KHR( client_device, &info );
-}
-
-static VkResult win32u_vkCreateBuffer( VkDevice client_device, const VkBufferCreateInfo *create_info,
-                                       const VkAllocationCallbacks *allocator, VkBuffer *buffer )
-{
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    struct vulkan_physical_device *physical_device = device->physical_device;
-    VkExternalMemoryBufferCreateInfo external_memory_info;
-    VkBufferCreateInfo info = *create_info;
-
-    if (physical_device->external_memory_align &&
-        !find_next_struct( info.pNext, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO ))
-    {
-        external_memory_info.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
-        external_memory_info.pNext = info.pNext;
-        external_memory_info.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT;
-        info.pNext = &external_memory_info;
-    }
-
-    return device->p_vkCreateBuffer( device->host.device, &info, NULL, buffer );
-}
-
-static VkResult win32u_vkCreateImage( VkDevice client_device, const VkImageCreateInfo *create_info,
-                                      const VkAllocationCallbacks *allocator, VkImage *image )
-{
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    struct vulkan_physical_device *physical_device = device->physical_device;
-    VkExternalMemoryImageCreateInfo external_memory_info;
-    VkImageCreateInfo info = *create_info;
-
-    if (physical_device->external_memory_align &&
-        !find_next_struct( info.pNext, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO ))
-    {
-        external_memory_info.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
-        external_memory_info.pNext = info.pNext;
-        external_memory_info.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT;
-        info.pNext = &external_memory_info;
-    }
-
-    return device->p_vkCreateImage( device->host.device, &info, NULL, image );
-}
-
 static VkResult win32u_vkCreateWin32SurfaceKHR( VkInstance client_instance, const VkWin32SurfaceCreateInfoKHR *create_info,
                                                 const VkAllocationCallbacks *allocator, VkSurfaceKHR *ret )
 {
@@ -809,29 +483,21 @@ static const char *win32u_get_host_surface_extension(void)
 
 static struct vulkan_funcs vulkan_funcs =
 {
-    .p_vkAcquireNextImage2KHR = win32u_vkAcquireNextImage2KHR,
-    .p_vkAcquireNextImageKHR = win32u_vkAcquireNextImageKHR,
-    .p_vkAllocateMemory = win32u_vkAllocateMemory,
-    .p_vkCreateBuffer = win32u_vkCreateBuffer,
-    .p_vkCreateImage = win32u_vkCreateImage,
-    .p_vkCreateSwapchainKHR = win32u_vkCreateSwapchainKHR,
     .p_vkCreateWin32SurfaceKHR = win32u_vkCreateWin32SurfaceKHR,
     .p_vkDestroySurfaceKHR = win32u_vkDestroySurfaceKHR,
-    .p_vkDestroySwapchainKHR = win32u_vkDestroySwapchainKHR,
-    .p_vkFreeMemory = win32u_vkFreeMemory,
-    .p_vkGetPhysicalDevicePresentRectanglesKHR = win32u_vkGetPhysicalDevicePresentRectanglesKHR,
     .p_vkGetPhysicalDeviceProperties2 = win32u_vkGetPhysicalDeviceProperties2,
     .p_vkGetPhysicalDeviceProperties2KHR = win32u_vkGetPhysicalDeviceProperties2KHR,
-    .p_vkGetPhysicalDeviceSurfaceCapabilities2KHR = win32u_vkGetPhysicalDeviceSurfaceCapabilities2KHR,
     .p_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = win32u_vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
-    .p_vkGetPhysicalDeviceSurfaceFormats2KHR = win32u_vkGetPhysicalDeviceSurfaceFormats2KHR,
+    .p_vkGetPhysicalDeviceSurfaceCapabilities2KHR = win32u_vkGetPhysicalDeviceSurfaceCapabilities2KHR,
+    .p_vkGetPhysicalDevicePresentRectanglesKHR = win32u_vkGetPhysicalDevicePresentRectanglesKHR,
     .p_vkGetPhysicalDeviceSurfaceFormatsKHR = win32u_vkGetPhysicalDeviceSurfaceFormatsKHR,
+    .p_vkGetPhysicalDeviceSurfaceFormats2KHR = win32u_vkGetPhysicalDeviceSurfaceFormats2KHR,
     .p_vkGetPhysicalDeviceWin32PresentationSupportKHR = win32u_vkGetPhysicalDeviceWin32PresentationSupportKHR,
-    .p_vkMapMemory = win32u_vkMapMemory,
-    .p_vkMapMemory2KHR = win32u_vkMapMemory2KHR,
+    .p_vkCreateSwapchainKHR = win32u_vkCreateSwapchainKHR,
+    .p_vkDestroySwapchainKHR = win32u_vkDestroySwapchainKHR,
+    .p_vkAcquireNextImage2KHR = win32u_vkAcquireNextImage2KHR,
+    .p_vkAcquireNextImageKHR = win32u_vkAcquireNextImageKHR,
     .p_vkQueuePresentKHR = win32u_vkQueuePresentKHR,
-    .p_vkUnmapMemory = win32u_vkUnmapMemory,
-    .p_vkUnmapMemory2KHR = win32u_vkUnmapMemory2KHR,
     .p_get_host_surface_extension = win32u_get_host_surface_extension,
 };
 
diff --git b/dlls/winevulkan/make_vulkan a/dlls/winevulkan/make_vulkan
index 09d450bba71..b968b7d6e87 100755
--- b/dlls/winevulkan/make_vulkan
+++ a/dlls/winevulkan/make_vulkan
@@ -213,14 +213,10 @@ FUNCTION_OVERRIDES = {
 USER_DRIVER_FUNCS = {
     "vkAcquireNextImage2KHR",
     "vkAcquireNextImageKHR",
-    "vkAllocateMemory",
-    "vkCreateBuffer",
-    "vkCreateImage",
     "vkCreateSwapchainKHR",
     "vkCreateWin32SurfaceKHR",
     "vkDestroySurfaceKHR",
     "vkDestroySwapchainKHR",
-    "vkFreeMemory",
     "vkGetDeviceProcAddr",
     "vkGetInstanceProcAddr",
     "vkGetPhysicalDevicePresentRectanglesKHR",
@@ -229,21 +225,20 @@ USER_DRIVER_FUNCS = {
     "vkGetPhysicalDeviceSurfaceFormats2KHR",
     "vkGetPhysicalDeviceSurfaceFormatsKHR",
     "vkGetPhysicalDeviceWin32PresentationSupportKHR",
-    "vkMapMemory",
-    "vkMapMemory2KHR",
     "vkQueuePresentKHR",
-    "vkUnmapMemory",
-    "vkUnmapMemory2KHR",
 }
 
 # functions for which the unix thunk is manually implemented
 MANUAL_UNIX_THUNKS = {
     "vkAllocateCommandBuffers",
+    "vkAllocateMemory",
+    "vkCreateBuffer",
     "vkCreateCommandPool",
     "vkCreateDebugReportCallbackEXT",
     "vkCreateDebugUtilsMessengerEXT",
     "vkCreateDeferredOperationKHR",
     "vkCreateDevice",
+    "vkCreateImage",
     "vkCreateInstance",
     "vkDestroyCommandPool",
     "vkDestroyDebugReportCallbackEXT",
@@ -260,6 +255,7 @@ MANUAL_UNIX_THUNKS = {
     "vkEnumeratePhysicalDeviceGroupsKHR",
     "vkEnumeratePhysicalDevices",
     "vkFreeCommandBuffers",
+    "vkFreeMemory",
     "vkGetCalibratedTimestampsEXT",
     "vkGetCalibratedTimestampsKHR",
     "vkGetDeviceProcAddr",
@@ -276,6 +272,10 @@ MANUAL_UNIX_THUNKS = {
     "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR",
     "vkGetPhysicalDeviceImageFormatProperties2",
     "vkGetPhysicalDeviceImageFormatProperties2KHR",
+    "vkMapMemory",
+    "vkMapMemory2KHR",
+    "vkUnmapMemory",
+    "vkUnmapMemory2KHR",
 }
 
 # loader functions which are entirely manually implemented
@@ -1112,7 +1112,7 @@ class VkHandle(object):
         if self.name == "VkInstance":
             return "vulkan_instance_from_handle({0})->host.instance".format(name)
         if self.name == "VkDeviceMemory":
-            return "vulkan_device_memory_from_handle({0})->host.device_memory".format(name)
+            return "wine_device_memory_from_handle({0})->host.device_memory".format(name)
         if self.name == "VkPhysicalDevice":
             return "vulkan_physical_device_from_handle({0})->host.physical_device".format(name)
         if self.name == "VkQueue":
diff --git b/dlls/winevulkan/vulkan.c a/dlls/winevulkan/vulkan.c
index 38930fa302b..ac93931092b 100644
--- b/dlls/winevulkan/vulkan.c
+++ a/dlls/winevulkan/vulkan.c
@@ -42,6 +42,12 @@ static struct wine_instance *wine_instance_from_handle(VkInstance handle)
     return CONTAINING_RECORD(object, struct wine_instance, obj);
 }
 
+static struct wine_phys_dev *wine_phys_dev_from_handle(VkPhysicalDevice handle)
+{
+    struct vulkan_physical_device *object = vulkan_physical_device_from_handle(handle);
+    return CONTAINING_RECORD(object, struct wine_phys_dev, obj);
+}
+
 static struct wine_device *wine_device_from_handle(VkDevice handle)
 {
     struct vulkan_device *object = vulkan_device_from_handle(handle);
@@ -317,14 +323,13 @@ static VkBool32 debug_report_callback_conversion(VkDebugReportFlagsEXT flags, Vk
     return VK_FALSE;
 }
 
-static void vulkan_physical_device_cleanup(struct vulkan_physical_device *physical_device)
+static void wine_phys_dev_cleanup(struct wine_phys_dev *phys_dev)
 {
-    free(physical_device->extensions);
+    free(phys_dev->extensions);
 }
 
-static VkResult vulkan_physical_device_init(struct vulkan_physical_device *physical_device,
-        VkPhysicalDevice host_physical_device, VkPhysicalDevice client_physical_device,
-        struct vulkan_instance *instance)
+static VkResult wine_vk_physical_device_init(struct wine_phys_dev *object, VkPhysicalDevice host_physical_device,
+        VkPhysicalDevice client_physical_device, struct vulkan_instance *instance)
 {
     BOOL have_memory_placed = FALSE, have_map_memory2 = FALSE;
     uint32_t num_host_properties, num_properties = 0;
@@ -333,10 +338,10 @@ static VkResult vulkan_physical_device_init(struct vulkan_physical_device *physi
     VkResult res;
     unsigned int i, j;
 
-    vulkan_object_init_ptr(&physical_device->obj, (UINT_PTR)host_physical_device, &client_physical_device->obj);
-    physical_device->instance = instance;
+    vulkan_object_init_ptr(&object->obj.obj, (UINT_PTR)host_physical_device, &client_physical_device->obj);
+    object->obj.instance = instance;
 
-    instance->p_vkGetPhysicalDeviceMemoryProperties(host_physical_device, &physical_device->memory_properties);
+    instance->p_vkGetPhysicalDeviceMemoryProperties(host_physical_device, &object->memory_properties);
 
     res = instance->p_vkEnumerateDeviceExtensionProperties(host_physical_device,
             NULL, &num_host_properties, NULL);
@@ -368,7 +373,7 @@ static VkResult vulkan_physical_device_init(struct vulkan_physical_device *physi
     {
         if (wine_vk_device_extension_supported(host_properties[i].extensionName))
         {
-            TRACE("Enabling extension '%s' for physical device %p\n", host_properties[i].extensionName, physical_device);
+            TRACE("Enabling extension '%s' for physical device %p\n", host_properties[i].extensionName, object);
             num_properties++;
         }
         else
@@ -380,14 +385,14 @@ static VkResult vulkan_physical_device_init(struct vulkan_physical_device *physi
         else if (!strcmp(host_properties[i].extensionName, "VK_EXT_map_memory_placed"))
             have_memory_placed = TRUE;
         else if (!strcmp(host_properties[i].extensionName, "VK_EXT_swapchain_maintenance1"))
-            physical_device->has_swapchain_maintenance1 = true;
+            object->obj.has_swapchain_maintenance1 = true;
         else if (!strcmp(host_properties[i].extensionName, "VK_KHR_map_memory2"))
             have_map_memory2 = TRUE;
     }
 
     TRACE("Host supported extensions %u, Wine supported extensions %u\n", num_host_properties, num_properties);
 
-    if (!(physical_device->extensions = calloc(num_properties, sizeof(*physical_device->extensions))))
+    if (!(object->extensions = calloc(num_properties, sizeof(*object->extensions))))
     {
         ERR("Failed to allocate memory for device extensions!\n");
         goto err;
@@ -397,11 +402,11 @@ static VkResult vulkan_physical_device_init(struct vulkan_physical_device *physi
     {
         if (wine_vk_device_extension_supported(host_properties[i].extensionName))
         {
-            physical_device->extensions[j] = host_properties[i];
+            object->extensions[j] = host_properties[i];
             j++;
         }
     }
-    physical_device->extension_count = num_properties;
+    object->extension_count = num_properties;
 
     if (zero_bits && have_memory_placed && have_map_memory2)
     {
@@ -429,12 +434,12 @@ static VkResult vulkan_physical_device_init(struct vulkan_physical_device *physi
             };
 
             instance->p_vkGetPhysicalDeviceProperties2(host_physical_device, &props);
-            physical_device->map_placed_align = map_placed_props.minPlacedMemoryMapAlignment;
-            TRACE( "Using placed map with alignment %u\n", physical_device->map_placed_align );
+            object->map_placed_align = map_placed_props.minPlacedMemoryMapAlignment;
+            TRACE( "Using placed map with alignment %u\n", object->map_placed_align );
         }
     }
 
-    if (zero_bits && have_external_memory_host && !physical_device->map_placed_align)
+    if (zero_bits && have_external_memory_host && !object->map_placed_align)
     {
         VkPhysicalDeviceExternalMemoryHostPropertiesEXT host_mem_props =
         {
@@ -446,17 +451,17 @@ static VkResult vulkan_physical_device_init(struct vulkan_physical_device *physi
             .pNext = &host_mem_props,
         };
         instance->p_vkGetPhysicalDeviceProperties2KHR(host_physical_device, &props);
-        physical_device->external_memory_align = host_mem_props.minImportedHostPointerAlignment;
-        if (physical_device->external_memory_align)
+        object->external_memory_align = host_mem_props.minImportedHostPointerAlignment;
+        if (object->external_memory_align)
             TRACE("Using VK_EXT_external_memory_host for memory mapping with alignment: %u\n",
-                  physical_device->external_memory_align);
+                  object->external_memory_align);
     }
 
     free(host_properties);
     return VK_SUCCESS;
 
 err:
-    vulkan_physical_device_cleanup(physical_device);
+    wine_phys_dev_cleanup(object);
     free(host_properties);
     return res;
 }
@@ -541,7 +546,7 @@ static const char *find_extension(const char *const *extensions, uint32_t count,
 static VkResult wine_vk_device_convert_create_info(VkPhysicalDevice client_physical_device,
         struct conversion_context *ctx, const VkDeviceCreateInfo *src, VkDeviceCreateInfo *dst)
 {
-    struct vulkan_physical_device *physical_device = vulkan_physical_device_from_handle(client_physical_device);
+    struct wine_phys_dev *phys_dev = wine_phys_dev_from_handle(client_physical_device);
     const char *extra_extensions[3], * const*extensions = src->ppEnabledExtensionNames;
     unsigned int i, extra_count = 0, extensions_count = src->enabledExtensionCount;
 
@@ -563,7 +568,7 @@ static VkResult wine_vk_device_convert_create_info(VkPhysicalDevice client_physi
         }
     }
 
-    if (physical_device->map_placed_align)
+    if (phys_dev->map_placed_align)
     {
         VkPhysicalDeviceMapMemoryPlacedFeaturesEXT *map_placed_features;
         map_placed_features = conversion_context_alloc(ctx, sizeof(*map_placed_features));
@@ -579,7 +584,7 @@ static VkResult wine_vk_device_convert_create_info(VkPhysicalDevice client_physi
         if (!find_extension(extensions, extensions_count, "VK_KHR_map_memory2"))
             extra_extensions[extra_count++] = "VK_KHR_map_memory2";
     }
-    else if (physical_device->external_memory_align)
+    else if (phys_dev->external_memory_align)
     {
         if (!find_extension(extensions, extensions_count, "VK_KHR_external_memory"))
             extra_extensions[extra_count++] = "VK_KHR_external_memory";
@@ -588,7 +593,7 @@ static VkResult wine_vk_device_convert_create_info(VkPhysicalDevice client_physi
     }
 
     /* win32u uses VkSwapchainPresentScalingCreateInfoEXT if available. */
-    if (physical_device->has_swapchain_maintenance1)
+    if (phys_dev->obj.has_swapchain_maintenance1)
     {
         if (!find_extension(extensions, extensions_count, "VK_EXT_swapchain_maintenance1"))
             extra_extensions[extra_count++] = "VK_EXT_swapchain_maintenance1";
@@ -733,9 +738,10 @@ static VkResult wine_vk_instance_convert_create_info(struct conversion_context *
 }
 
 /* Helper function which stores wrapped physical devices in the instance object. */
-static VkResult wine_vk_instance_init_physical_devices(struct vulkan_instance *instance,
-        struct vulkan_physical_device *physical_devices)
+static VkResult wine_vk_instance_init_physical_devices(struct wine_instance *object)
 {
+    struct vulkan_instance *instance = &object->obj;
+    struct wine_phys_dev *physical_devices = object->phys_devs;
     VkInstance client_instance = instance->client.instance;
     VkPhysicalDevice *host_physical_devices;
     uint32_t phys_dev_count;
@@ -771,34 +777,33 @@ static VkResult wine_vk_instance_init_physical_devices(struct vulkan_instance *i
     /* Wrap each host physical device handle into a dispatchable object for the ICD loader. */
     for (i = 0; i < phys_dev_count; i++)
     {
-        struct vulkan_physical_device *physical_device = physical_devices + i;
-        res = vulkan_physical_device_init(physical_device, host_physical_devices[i], &client_instance->phys_devs[i], instance);
+        struct wine_phys_dev *phys_dev = physical_devices + i;
+        res = wine_vk_physical_device_init(phys_dev, host_physical_devices[i], &client_instance->phys_devs[i], instance);
         if (res != VK_SUCCESS)
             goto err;
     }
-    instance->physical_device_count = phys_dev_count;
-    instance->physical_devices = physical_devices;
+    object->phys_dev_count = phys_dev_count;
 
     free(host_physical_devices);
     return VK_SUCCESS;
 
 err:
-    while (i) vulkan_physical_device_cleanup(&physical_devices[--i]);
+    while (i) wine_phys_dev_cleanup(&physical_devices[--i]);
     free(host_physical_devices);
     return res;
 }
 
-static struct vulkan_physical_device *vulkan_instance_get_physical_device(struct vulkan_instance *instance,
+static struct wine_phys_dev *wine_vk_instance_wrap_physical_device(struct wine_instance *instance,
         VkPhysicalDevice host_physical_device)
 {
-    struct vulkan_physical_device *physical_devices = instance->physical_devices;
-    uint32_t physical_device_count = instance->physical_device_count;
+    struct wine_phys_dev *physical_devices = instance->phys_devs;
+    uint32_t physical_device_count = instance->phys_dev_count;
     unsigned int i;
 
     for (i = 0; i < physical_device_count; ++i)
     {
-        struct vulkan_physical_device *current = physical_devices + i;
-        if (current->host.physical_device == host_physical_device) return current;
+        struct wine_phys_dev *current = physical_devices + i;
+        if (current->obj.host.physical_device == host_physical_device) return current;
     }
 
     ERR("Unrecognized physical device %p.\n", host_physical_device);
@@ -943,19 +948,17 @@ VkResult wine_vkCreateInstance(const VkInstanceCreateInfo *create_info,
     struct conversion_context ctx;
     struct wine_instance *instance;
     VkInstance host_instance, client_instance = client_ptr;
-    struct vulkan_physical_device *physical_devices;
     unsigned int i;
     VkResult res;
 
     if (allocator)
         FIXME("Support for allocation callbacks not implemented yet\n");
 
-    if (!(instance = calloc(1, sizeof(*instance) + sizeof(*physical_devices) * client_instance->phys_dev_count)))
+    if (!(instance = calloc(1, offsetof(struct wine_instance, phys_devs[client_instance->phys_dev_count]))))
     {
         ERR("Failed to allocate memory for instance\n");
         return VK_ERROR_OUT_OF_HOST_MEMORY;
     }
-    physical_devices = (struct vulkan_physical_device *)(instance + 1);
 
     init_conversion_context(&ctx);
     res = wine_vk_instance_convert_create_info(&ctx, create_info, &create_info_host, instance);
@@ -988,7 +991,7 @@ VkResult wine_vkCreateInstance(const VkInstanceCreateInfo *create_info,
      * the host physical devices and present those to the application.
      * Cleanup happens as part of wine_vkDestroyInstance.
      */
-    res = wine_vk_instance_init_physical_devices(&instance->obj, physical_devices);
+    res = wine_vk_instance_init_physical_devices(instance);
     if (res != VK_SUCCESS)
     {
         ERR("Failed to load physical devices, res=%d\n", res);
@@ -1012,10 +1015,10 @@ VkResult wine_vkCreateInstance(const VkInstanceCreateInfo *create_info,
 
     TRACE("Created instance %p, host_instance %p.\n", instance, instance->obj.host.instance);
 
-    for (i = 0; i < instance->obj.physical_device_count; i++)
+    for (i = 0; i < instance->phys_dev_count; i++)
     {
-        struct vulkan_physical_device *physical_device = &instance->obj.physical_devices[i];
-        vulkan_instance_insert_object(&instance->obj, &physical_device->obj);
+        struct wine_phys_dev *phys_dev = &instance->phys_devs[i];
+        vulkan_instance_insert_object(&instance->obj, &phys_dev->obj.obj);
     }
     vulkan_instance_insert_object(&instance->obj, &instance->obj.obj);
 
@@ -1053,10 +1056,10 @@ void wine_vkDestroyInstance(VkInstance client_instance, const VkAllocationCallba
         return;
 
     instance->obj.p_vkDestroyInstance(instance->obj.host.instance, NULL /* allocator */);
-    for (i = 0; i < instance->obj.physical_device_count; i++)
+    for (i = 0; i < instance->phys_dev_count; i++)
     {
-        vulkan_instance_remove_object(&instance->obj, &instance->obj.physical_devices[i].obj);
-        vulkan_physical_device_cleanup(&instance->obj.physical_devices[i]);
+        vulkan_instance_remove_object(&instance->obj, &instance->phys_devs[i].obj.obj);
+        wine_phys_dev_cleanup(&instance->phys_devs[i]);
     }
     vulkan_instance_remove_object(&instance->obj, &instance->obj.obj);
 
@@ -1068,7 +1071,7 @@ void wine_vkDestroyInstance(VkInstance client_instance, const VkAllocationCallba
 VkResult wine_vkEnumerateDeviceExtensionProperties(VkPhysicalDevice client_physical_device, const char *layer_name,
                                                    uint32_t *count, VkExtensionProperties *properties)
 {
-    struct vulkan_physical_device *physical_device = vulkan_physical_device_from_handle(client_physical_device);
+    struct wine_phys_dev *phys_dev = wine_phys_dev_from_handle(client_physical_device);
 
     /* This shouldn't get called with layer_name set, the ICD loader prevents it. */
     if (layer_name)
@@ -1079,15 +1082,15 @@ VkResult wine_vkEnumerateDeviceExtensionProperties(VkPhysicalDevice client_physi
 
     if (!properties)
     {
-        *count = physical_device->extension_count;
+        *count = phys_dev->extension_count;
         return VK_SUCCESS;
     }
 
-    *count = min(*count, physical_device->extension_count);
-    memcpy(properties, physical_device->extensions, *count * sizeof(*properties));
+    *count = min(*count, phys_dev->extension_count);
+    memcpy(properties, phys_dev->extensions, *count * sizeof(*properties));
 
     TRACE("Returning %u extensions.\n", *count);
-    return *count < physical_device->extension_count ? VK_INCOMPLETE : VK_SUCCESS;
+    return *count < phys_dev->extension_count ? VK_INCOMPLETE : VK_SUCCESS;
 }
 
 VkResult wine_vkEnumerateInstanceExtensionProperties(const char *name, uint32_t *count,
@@ -1183,23 +1186,23 @@ VkResult wine_vkEnumerateInstanceVersion(uint32_t *version)
 
 VkResult wine_vkEnumeratePhysicalDevices(VkInstance client_instance, uint32_t *count, VkPhysicalDevice *client_physical_devices)
 {
-    struct vulkan_instance *instance = vulkan_instance_from_handle(client_instance);
+    struct wine_instance *instance = wine_instance_from_handle(client_instance);
     unsigned int i;
 
     if (!client_physical_devices)
     {
-        *count = instance->physical_device_count;
+        *count = instance->phys_dev_count;
         return VK_SUCCESS;
     }
 
-    *count = min(*count, instance->physical_device_count);
+    *count = min(*count, instance->phys_dev_count);
     for (i = 0; i < *count; i++)
     {
-        client_physical_devices[i] = instance->physical_devices[i].client.physical_device;
+        client_physical_devices[i] = instance->phys_devs[i].obj.client.physical_device;
     }
 
     TRACE("Returning %u devices.\n", *count);
-    return *count < instance->physical_device_count ? VK_INCOMPLETE : VK_SUCCESS;
+    return *count < instance->phys_dev_count ? VK_INCOMPLETE : VK_SUCCESS;
 }
 
 void wine_vkFreeCommandBuffers(VkDevice client_device, VkCommandPool command_pool, uint32_t count,
@@ -1300,14 +1303,14 @@ void wine_vkDestroyCommandPool(VkDevice client_device, VkCommandPool handle,
     free(pool);
 }
 
-static VkResult wine_vk_enumerate_physical_device_groups(struct vulkan_instance *instance,
+static VkResult wine_vk_enumerate_physical_device_groups(struct wine_instance *instance,
         VkResult (*p_vkEnumeratePhysicalDeviceGroups)(VkInstance, uint32_t *, VkPhysicalDeviceGroupProperties *),
         uint32_t *count, VkPhysicalDeviceGroupProperties *properties)
 {
     unsigned int i, j;
     VkResult res;
 
-    res = p_vkEnumeratePhysicalDeviceGroups(instance->host.instance, count, properties);
+    res = p_vkEnumeratePhysicalDeviceGroups(instance->obj.host.instance, count, properties);
     if (res < 0 || !properties)
         return res;
 
@@ -1317,9 +1320,10 @@ static VkResult wine_vk_enumerate_physical_device_groups(struct vulkan_instance
         for (j = 0; j < current->physicalDeviceCount; ++j)
         {
             VkPhysicalDevice host_physical_device = current->physicalDevices[j];
-            struct vulkan_physical_device *physical_device = vulkan_instance_get_physical_device(instance, host_physical_device);
-            if (!physical_device) return VK_ERROR_INITIALIZATION_FAILED;
-            current->physicalDevices[j] = physical_device->client.physical_device;
+            struct wine_phys_dev *phys_dev = wine_vk_instance_wrap_physical_device(instance, host_physical_device);
+            if (!phys_dev)
+                return VK_ERROR_INITIALIZATION_FAILED;
+            current->physicalDevices[j] = phys_dev->obj.client.physical_device;
         }
     }
 
@@ -1329,19 +1333,19 @@ static VkResult wine_vk_enumerate_physical_device_groups(struct vulkan_instance
 VkResult wine_vkEnumeratePhysicalDeviceGroups(VkInstance client_instance, uint32_t *count,
                                               VkPhysicalDeviceGroupProperties *properties)
 {
-    struct vulkan_instance *instance = vulkan_instance_from_handle(client_instance);
+    struct wine_instance *instance = wine_instance_from_handle(client_instance);
 
     return wine_vk_enumerate_physical_device_groups(instance,
-            instance->p_vkEnumeratePhysicalDeviceGroups, count, properties);
+            instance->obj.p_vkEnumeratePhysicalDeviceGroups, count, properties);
 }
 
 VkResult wine_vkEnumeratePhysicalDeviceGroupsKHR(VkInstance client_instance, uint32_t *count,
                                                  VkPhysicalDeviceGroupProperties *properties)
 {
-    struct vulkan_instance *instance = vulkan_instance_from_handle(client_instance);
+    struct wine_instance *instance = wine_instance_from_handle(client_instance);
 
     return wine_vk_enumerate_physical_device_groups(instance,
-            instance->p_vkEnumeratePhysicalDeviceGroupsKHR, count, properties);
+            instance->obj.p_vkEnumeratePhysicalDeviceGroupsKHR, count, properties);
 }
 
 void wine_vkGetPhysicalDeviceExternalFenceProperties(VkPhysicalDevice client_physical_device,
@@ -1644,6 +1648,317 @@ void wine_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(VkPhysicalDevice cli
     properties->externalSemaphoreFeatures = 0;
 }
 
+VkResult wine_vkAllocateMemory(VkDevice client_device, const VkMemoryAllocateInfo *alloc_info,
+                               const VkAllocationCallbacks *allocator, VkDeviceMemory *ret)
+{
+    struct vulkan_device *device = vulkan_device_from_handle(client_device);
+    struct wine_phys_dev *physical_device = CONTAINING_RECORD(device->physical_device, struct wine_phys_dev, obj);
+    struct vulkan_instance *instance = device->physical_device->instance;
+    struct wine_device_memory *memory;
+    VkMemoryAllocateInfo info = *alloc_info;
+    VkImportMemoryHostPointerInfoEXT host_pointer_info;
+    VkDeviceMemory host_device_memory;
+    uint32_t mem_flags;
+    void *mapping = NULL;
+    VkResult result;
+
+    /* For host visible memory, we try to use VK_EXT_external_memory_host on wow64
+     * to ensure that mapped pointer is 32-bit. */
+    mem_flags = physical_device->memory_properties.memoryTypes[alloc_info->memoryTypeIndex].propertyFlags;
+    if (physical_device->external_memory_align && (mem_flags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) &&
+        !find_next_struct(alloc_info->pNext, VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT))
+    {
+        VkMemoryHostPointerPropertiesEXT props =
+        {
+            .sType = VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT,
+        };
+        uint32_t i, align = physical_device->external_memory_align - 1;
+        SIZE_T alloc_size = info.allocationSize;
+        static int once;
+
+        if (!once++)
+            FIXME("Using VK_EXT_external_memory_host\n");
+
+        if (NtAllocateVirtualMemory(GetCurrentProcess(), &mapping, zero_bits, &alloc_size,
+                                    MEM_COMMIT, PAGE_READWRITE))
+        {
+            ERR("NtAllocateVirtualMemory failed\n");
+            return VK_ERROR_OUT_OF_HOST_MEMORY;
+        }
+
+        result = device->p_vkGetMemoryHostPointerPropertiesEXT(device->host.device,
+                VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT, mapping, &props);
+        if (result != VK_SUCCESS)
+        {
+            ERR("vkGetMemoryHostPointerPropertiesEXT failed: %d\n", result);
+            return result;
+        }
+
+        if (!(props.memoryTypeBits & (1u << info.memoryTypeIndex)))
+        {
+            /* If requested memory type is not allowed to use external memory,
+             * try to find a supported compatible type. */
+            uint32_t mask = mem_flags & ~VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
+            for (i = 0; i < physical_device->memory_properties.memoryTypeCount; i++)
+            {
+                if (!(props.memoryTypeBits & (1u << i)))
+                    continue;
+                if ((physical_device->memory_properties.memoryTypes[i].propertyFlags & mask) != mask)
+                    continue;
+
+                TRACE("Memory type not compatible with host memory, using %u instead\n", i);
+                info.memoryTypeIndex = i;
+                break;
+            }
+            if (i == physical_device->memory_properties.memoryTypeCount)
+            {
+                FIXME("Not found compatible memory type\n");
+                alloc_size = 0;
+                NtFreeVirtualMemory(GetCurrentProcess(), &mapping, &alloc_size, MEM_RELEASE);
+            }
+        }
+
+        if (props.memoryTypeBits & (1u << info.memoryTypeIndex))
+        {
+            host_pointer_info.sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT;
+            host_pointer_info.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT;
+            host_pointer_info.pHostPointer = mapping;
+            host_pointer_info.pNext = info.pNext;
+            info.pNext = &host_pointer_info;
+
+            info.allocationSize = (info.allocationSize + align) & ~align;
+        }
+    }
+
+    if (!(memory = malloc(sizeof(*memory))))
+        return VK_ERROR_OUT_OF_HOST_MEMORY;
+
+    result = device->p_vkAllocateMemory(device->host.device, &info, NULL, &host_device_memory);
+    if (result != VK_SUCCESS)
+    {
+        free(memory);
+        return result;
+    }
+
+    vulkan_object_init(&memory->obj, host_device_memory);
+    memory->size = info.allocationSize;
+    memory->vm_map = mapping;
+    vulkan_instance_insert_object(instance, &memory->obj);
+
+    *ret = memory->client.device_memory;
+    return VK_SUCCESS;
+}
+
+void wine_vkFreeMemory(VkDevice client_device, VkDeviceMemory memory_handle, const VkAllocationCallbacks *allocator)
+{
+    struct vulkan_device *device = vulkan_device_from_handle(client_device);
+    struct wine_phys_dev *physical_device = CONTAINING_RECORD(device->physical_device, struct wine_phys_dev, obj);
+    struct vulkan_instance *instance = device->physical_device->instance;
+    struct wine_device_memory *memory;
+
+    if (!memory_handle)
+        return;
+    memory = wine_device_memory_from_handle(memory_handle);
+
+    if (memory->vm_map && !physical_device->external_memory_align)
+    {
+        const VkMemoryUnmapInfoKHR info =
+        {
+            .sType = VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR,
+            .memory = memory->host.device_memory,
+            .flags = VK_MEMORY_UNMAP_RESERVE_BIT_EXT,
+        };
+        device->p_vkUnmapMemory2KHR(device->host.device, &info);
+    }
+
+    device->p_vkFreeMemory(device->host.device, memory->host.device_memory, NULL);
+    vulkan_instance_remove_object(instance, &memory->obj);
+
+    if (memory->vm_map)
+    {
+        SIZE_T alloc_size = 0;
+        NtFreeVirtualMemory(GetCurrentProcess(), &memory->vm_map, &alloc_size, MEM_RELEASE);
+    }
+
+    free(memory);
+}
+
+VkResult wine_vkMapMemory(VkDevice client_device, VkDeviceMemory memory, VkDeviceSize offset,
+                          VkDeviceSize size, VkMemoryMapFlags flags, void **data)
+{
+    const VkMemoryMapInfoKHR info =
+    {
+      .sType = VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR,
+      .flags = flags,
+      .memory = memory,
+      .offset = offset,
+      .size = size,
+   };
+
+   return wine_vkMapMemory2KHR(client_device, &info, data);
+}
+
+VkResult wine_vkMapMemory2KHR(VkDevice client_device, const VkMemoryMapInfoKHR *map_info, void **data)
+{
+    struct vulkan_device *device = vulkan_device_from_handle(client_device);
+    struct wine_phys_dev *physical_device = CONTAINING_RECORD(device->physical_device, struct wine_phys_dev, obj);
+    struct wine_device_memory *memory = wine_device_memory_from_handle(map_info->memory);
+    VkMemoryMapInfoKHR info = *map_info;
+    VkMemoryMapPlacedInfoEXT placed_info =
+    {
+        .sType = VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT,
+    };
+    VkResult result;
+
+    info.memory = memory->host.device_memory;
+    if (memory->vm_map)
+    {
+        *data = (char *)memory->vm_map + info.offset;
+        TRACE("returning %p\n", *data);
+        return VK_SUCCESS;
+    }
+
+    if (physical_device->map_placed_align)
+    {
+        SIZE_T alloc_size = memory->size;
+
+        placed_info.pNext = info.pNext;
+        info.pNext = &placed_info;
+        info.offset = 0;
+        info.size = VK_WHOLE_SIZE;
+        info.flags |=  VK_MEMORY_MAP_PLACED_BIT_EXT;
+
+        if (NtAllocateVirtualMemory(GetCurrentProcess(), &placed_info.pPlacedAddress, zero_bits, &alloc_size,
+                                    MEM_COMMIT, PAGE_READWRITE))
+        {
+            ERR("NtAllocateVirtualMemory failed\n");
+            return VK_ERROR_OUT_OF_HOST_MEMORY;
+        }
+    }
+
+    if (device->p_vkMapMemory2KHR)
+    {
+        result = device->p_vkMapMemory2KHR(device->host.device, &info, data);
+    }
+    else
+    {
+        assert(!info.pNext);
+        result = device->p_vkMapMemory(device->host.device, info.memory, info.offset,
+                                             info.size, info.flags, data);
+    }
+
+    if (placed_info.pPlacedAddress)
+    {
+        if (result != VK_SUCCESS)
+        {
+            SIZE_T alloc_size = 0;
+            ERR("vkMapMemory2EXT failed: %d\n", result);
+            NtFreeVirtualMemory(GetCurrentProcess(), &placed_info.pPlacedAddress, &alloc_size, MEM_RELEASE);
+            return result;
+        }
+        memory->vm_map = placed_info.pPlacedAddress;
+        *data = (char *)memory->vm_map + map_info->offset;
+        TRACE("Using placed mapping %p\n", memory->vm_map);
+    }
+
+#ifdef _WIN64
+    if (NtCurrentTeb()->WowTebOffset && result == VK_SUCCESS && (UINT_PTR)*data >> 32)
+    {
+        FIXME("returned mapping %p does not fit 32-bit pointer\n", *data);
+        device->p_vkUnmapMemory(device->host.device, memory->host.device_memory);
+        *data = NULL;
+        result = VK_ERROR_OUT_OF_HOST_MEMORY;
+    }
+#endif
+
+    return result;
+}
+
+void wine_vkUnmapMemory(VkDevice client_device, VkDeviceMemory memory)
+{
+    const VkMemoryUnmapInfoKHR info =
+    {
+        .sType = VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR,
+        .memory = memory,
+    };
+
+    wine_vkUnmapMemory2KHR(client_device, &info);
+}
+
+VkResult wine_vkUnmapMemory2KHR(VkDevice client_device, const VkMemoryUnmapInfoKHR *unmap_info)
+{
+    struct vulkan_device *device = vulkan_device_from_handle(client_device);
+    struct wine_phys_dev *physical_device = CONTAINING_RECORD(device->physical_device, struct wine_phys_dev, obj);
+    struct wine_device_memory *memory = wine_device_memory_from_handle(unmap_info->memory);
+    VkMemoryUnmapInfoKHR info;
+    VkResult result;
+
+    if (memory->vm_map && physical_device->external_memory_align)
+        return VK_SUCCESS;
+
+    if (!device->p_vkUnmapMemory2KHR)
+    {
+        assert(!unmap_info->pNext && !memory->vm_map);
+        device->p_vkUnmapMemory(device->host.device, memory->host.device_memory);
+        return VK_SUCCESS;
+    }
+
+    info = *unmap_info;
+    info.memory = memory->host.device_memory;
+    if (memory->vm_map)
+        info.flags |= VK_MEMORY_UNMAP_RESERVE_BIT_EXT;
+
+    result = device->p_vkUnmapMemory2KHR(device->host.device, &info);
+
+    if (result == VK_SUCCESS && memory->vm_map)
+    {
+        SIZE_T size = 0;
+        NtFreeVirtualMemory(GetCurrentProcess(), &memory->vm_map, &size, MEM_RELEASE);
+        memory->vm_map = NULL;
+    }
+    return result;
+}
+
+VkResult wine_vkCreateBuffer(VkDevice client_device, const VkBufferCreateInfo *create_info,
+                             const VkAllocationCallbacks *allocator, VkBuffer *buffer)
+{
+    struct vulkan_device *device = vulkan_device_from_handle(client_device);
+    struct wine_phys_dev *physical_device = CONTAINING_RECORD(device->physical_device, struct wine_phys_dev, obj);
+    VkExternalMemoryBufferCreateInfo external_memory_info;
+    VkBufferCreateInfo info = *create_info;
+
+    if (physical_device->external_memory_align &&
+        !find_next_struct(info.pNext, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO))
+    {
+        external_memory_info.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
+        external_memory_info.pNext = info.pNext;
+        external_memory_info.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT;
+        info.pNext = &external_memory_info;
+    }
+
+    return device->p_vkCreateBuffer(device->host.device, &info, NULL, buffer);
+}
+
+VkResult wine_vkCreateImage(VkDevice client_device, const VkImageCreateInfo *create_info,
+                            const VkAllocationCallbacks *allocator, VkImage *image)
+{
+    struct vulkan_device *device = vulkan_device_from_handle(client_device);
+    struct wine_phys_dev *physical_device = CONTAINING_RECORD(device->physical_device, struct wine_phys_dev, obj);
+    VkExternalMemoryImageCreateInfo external_memory_info;
+    VkImageCreateInfo info = *create_info;
+
+    if (physical_device->external_memory_align &&
+        !find_next_struct(info.pNext, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO))
+    {
+        external_memory_info.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
+        external_memory_info.pNext = info.pNext;
+        external_memory_info.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT;
+        info.pNext = &external_memory_info;
+    }
+
+    return device->p_vkCreateImage(device->host.device, &info, NULL, image);
+}
+
 VkResult wine_vkCreateDebugUtilsMessengerEXT(VkInstance client_instance,
                                              const VkDebugUtilsMessengerCreateInfoEXT *create_info,
                                              const VkAllocationCallbacks *allocator,
diff --git b/dlls/winevulkan/vulkan_private.h a/dlls/winevulkan/vulkan_private.h
index da520433467..59b900930b3 100644
--- b/dlls/winevulkan/vulkan_private.h
+++ a/dlls/winevulkan/vulkan_private.h
@@ -70,6 +70,18 @@ struct wine_debug_report_callback
     UINT64 user_data; /* client pointer */
 };
 
+struct wine_phys_dev
+{
+    struct vulkan_physical_device obj;
+
+    VkPhysicalDeviceMemoryProperties memory_properties;
+    VkExtensionProperties *extensions;
+    uint32_t extension_count;
+
+    uint32_t external_memory_align;
+    uint32_t map_placed_align;
+};
+
 struct wine_debug_report_callback;
 
 struct wine_instance
@@ -87,8 +99,14 @@ struct wine_instance
 
     struct rb_tree objects;
     pthread_rwlock_t objects_lock;
+
+    /* We cache devices as we need to wrap them as they are dispatchable objects. */
+    uint32_t phys_dev_count;
+    struct wine_phys_dev phys_devs[];
 };
 
+C_ASSERT(sizeof(struct wine_instance) == offsetof(struct wine_instance, phys_devs[0]));
+
 struct wine_cmd_pool
 {
     VULKAN_OBJECT_HEADER( VkCommandPool, command_pool );
@@ -100,6 +118,18 @@ static inline struct wine_cmd_pool *wine_cmd_pool_from_handle(VkCommandPool hand
     return (struct wine_cmd_pool *)(UINT_PTR)client->unix_handle;
 }
 
+struct wine_device_memory
+{
+    VULKAN_OBJECT_HEADER( VkDeviceMemory, device_memory );
+    VkDeviceSize size;
+    void *vm_map;
+};
+
+static inline struct wine_device_memory *wine_device_memory_from_handle(VkDeviceMemory handle)
+{
+    return (struct wine_device_memory *)(uintptr_t)handle;
+}
+
 struct wine_debug_utils_messenger
 {
     VULKAN_OBJECT_HEADER( VkDebugUtilsMessengerEXT, debug_messenger );
diff --git b/dlls/winevulkan/vulkan_thunks.c a/dlls/winevulkan/vulkan_thunks.c
index 3d8882c8db0..c8045fa397e 100644
--- b/dlls/winevulkan/vulkan_thunks.c
+++ a/dlls/winevulkan/vulkan_thunks.c
@@ -9499,7 +9499,7 @@
     case VK_OBJECT_TYPE_DEVICE:
         return (uint64_t) (uintptr_t) vulkan_device_from_handle(((VkDevice) (uintptr_t) handle))->host.device;
     case VK_OBJECT_TYPE_DEVICE_MEMORY:
-        return (uint64_t) vulkan_device_memory_from_handle(handle)->host.device_memory;
+        return (uint64_t) wine_device_memory_from_handle(handle)->host.device_memory;
     case VK_OBJECT_TYPE_INSTANCE:
         return (uint64_t) (uintptr_t) vulkan_instance_from_handle(((VkInstance) (uintptr_t) handle))->host.instance;
     case VK_OBJECT_TYPE_PHYSICAL_DEVICE:
@@ -9905,7 +9905,7 @@
             const VkTileMemoryBindInfoQCOM *in_ext = (const VkTileMemoryBindInfoQCOM *)in_header;
             out_ext->sType = VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM;
             out_ext->pNext = NULL;
-            out_ext->memory = vulkan_device_memory_from_handle(in_ext->memory)->host.device_memory;
+            out_ext->memory = wine_device_memory_from_handle(in_ext->memory)->host.device_memory;
             out_header->pNext = (void *)out_ext;
             out_header = (void *)out_ext;
             break;
@@ -10078,7 +10078,7 @@
             const VkTileMemoryBindInfoQCOM32 *in_ext = (const VkTileMemoryBindInfoQCOM32 *)in_header;
             out_ext->sType = VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM;
             out_ext->pNext = NULL;
-            out_ext->memory = vulkan_device_memory_from_handle(in_ext->memory)->host.device_memory;
+            out_ext->memory = wine_device_memory_from_handle(in_ext->memory)->host.device_memory;
             out_header->pNext = (void *)out_ext;
             out_header = (void *)out_ext;
             break;
@@ -10148,7 +10148,7 @@
     out->sType = in->sType;
     out->pNext = in->pNext;
     out->accelerationStructure = in->accelerationStructure;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = wine_device_memory_from_handle(in->memory)->host.device_memory;
     out->memoryOffset = in->memoryOffset;
     out->deviceIndexCount = in->deviceIndexCount;
     out->pDeviceIndices = in->pDeviceIndices;
@@ -10180,7 +10180,7 @@
     out->sType = in->sType;
     out->pNext = NULL;
     out->accelerationStructure = in->accelerationStructure;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = wine_device_memory_from_handle(in->memory)->host.device_memory;
     out->memoryOffset = in->memoryOffset;
     out->deviceIndexCount = in->deviceIndexCount;
     out->pDeviceIndices = UlongToPtr(in->pDeviceIndices);
@@ -10212,7 +10212,7 @@
     out->sType = in->sType;
     out->pNext = in->pNext;
     out->buffer = in->buffer;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = wine_device_memory_from_handle(in->memory)->host.device_memory;
     out->memoryOffset = in->memoryOffset;
 }
 #endif /* _WIN64 */
@@ -10245,7 +10245,7 @@
     out->sType = in->sType;
     out->pNext = NULL;
     out->buffer = in->buffer;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = wine_device_memory_from_handle(in->memory)->host.device_memory;
     out->memoryOffset = in->memoryOffset;
 
     for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
@@ -10308,7 +10308,7 @@
     out->session = in->session;
     out->bindPoint = in->bindPoint;
     out->objectIndex = in->objectIndex;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = wine_device_memory_from_handle(in->memory)->host.device_memory;
     out->memoryOffset = in->memoryOffset;
 }
 #endif /* _WIN64 */
@@ -10340,7 +10340,7 @@
     out->session = in->session;
     out->bindPoint = in->bindPoint;
     out->objectIndex = in->objectIndex;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = wine_device_memory_from_handle(in->memory)->host.device_memory;
     out->memoryOffset = in->memoryOffset;
     if (in->pNext)
         FIXME("Unexpected pNext\n");
@@ -10373,7 +10373,7 @@
     out->sType = in->sType;
     out->pNext = NULL;
     out->image = in->image;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = wine_device_memory_from_handle(in->memory)->host.device_memory;
     out->memoryOffset = in->memoryOffset;
 
     for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
@@ -10464,7 +10464,7 @@
     out->sType = in->sType;
     out->pNext = NULL;
     out->image = in->image;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = wine_device_memory_from_handle(in->memory)->host.device_memory;
     out->memoryOffset = in->memoryOffset;
 
     for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
@@ -10550,7 +10550,7 @@
     out->sType = in->sType;
     out->pNext = in->pNext;
     out->tensor = in->tensor;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = wine_device_memory_from_handle(in->memory)->host.device_memory;
     out->memoryOffset = in->memoryOffset;
 }
 #endif /* _WIN64 */
@@ -10580,7 +10580,7 @@
     out->sType = in->sType;
     out->pNext = NULL;
     out->tensor = in->tensor;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = wine_device_memory_from_handle(in->memory)->host.device_memory;
     out->memoryOffset = in->memoryOffset;
     if (in->pNext)
         FIXME("Unexpected pNext\n");
@@ -10610,7 +10610,7 @@
     out->sType = in->sType;
     out->pNext = in->pNext;
     out->memoryBindIndex = in->memoryBindIndex;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = wine_device_memory_from_handle(in->memory)->host.device_memory;
     out->memoryOffset = in->memoryOffset;
     out->memorySize = in->memorySize;
 }
@@ -10641,7 +10641,7 @@
     out->sType = in->sType;
     out->pNext = NULL;
     out->memoryBindIndex = in->memoryBindIndex;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = wine_device_memory_from_handle(in->memory)->host.device_memory;
     out->memoryOffset = in->memoryOffset;
     out->memorySize = in->memorySize;
     if (in->pNext)
@@ -11855,7 +11855,7 @@
 
     out->sType = in->sType;
     out->pNext = in->pNext;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = wine_device_memory_from_handle(in->memory)->host.device_memory;
 }
 #endif /* _WIN64 */
 
@@ -11865,7 +11865,7 @@
 
     out->sType = in->sType;
     out->pNext = NULL;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = wine_device_memory_from_handle(in->memory)->host.device_memory;
     if (in->pNext)
         FIXME("Unexpected pNext\n");
 }
@@ -26652,7 +26652,7 @@
 
     out->sType = in->sType;
     out->pNext = in->pNext;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = wine_device_memory_from_handle(in->memory)->host.device_memory;
     out->offset = in->offset;
     out->size = in->size;
 }
@@ -26682,7 +26682,7 @@
 
     out->sType = in->sType;
     out->pNext = NULL;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = wine_device_memory_from_handle(in->memory)->host.device_memory;
     out->offset = in->offset;
     out->size = in->size;
     if (in->pNext)
@@ -27694,7 +27694,7 @@
 
     out->sType = in->sType;
     out->pNext = in->pNext;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = wine_device_memory_from_handle(in->memory)->host.device_memory;
 }
 #endif /* _WIN64 */
 
@@ -27704,7 +27704,7 @@
 
     out->sType = in->sType;
     out->pNext = NULL;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = wine_device_memory_from_handle(in->memory)->host.device_memory;
     if (in->pNext)
         FIXME("Unexpected pNext\n");
 }
@@ -38331,7 +38331,7 @@
     out->sType = in->sType;
     out->pNext = in->pNext;
     out->flags = in->flags;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = wine_device_memory_from_handle(in->memory)->host.device_memory;
     out->offset = in->offset;
     out->size = in->size;
 }
@@ -38344,7 +38344,7 @@
     out->sType = in->sType;
     out->pNext = NULL;
     out->flags = in->flags;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = wine_device_memory_from_handle(in->memory)->host.device_memory;
     out->offset = in->offset;
     out->size = in->size;
     if (in->pNext)
@@ -38372,7 +38372,7 @@
 
     out->resourceOffset = in->resourceOffset;
     out->size = in->size;
-    out->memory = in->memory ? vulkan_device_memory_from_handle(in->memory)->host.device_memory : 0;
+    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->host.device_memory : 0;
     out->memoryOffset = in->memoryOffset;
     out->flags = in->flags;
 }
@@ -38462,7 +38462,7 @@
     out->subresource = in->subresource;
     out->offset = in->offset;
     out->extent = in->extent;
-    out->memory = in->memory ? vulkan_device_memory_from_handle(in->memory)->host.device_memory : 0;
+    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->host.device_memory : 0;
     out->memoryOffset = in->memoryOffset;
     out->flags = in->flags;
 }
@@ -38559,7 +38559,7 @@
 
     out->resourceOffset = in->resourceOffset;
     out->size = in->size;
-    out->memory = in->memory ? vulkan_device_memory_from_handle(in->memory)->host.device_memory : 0;
+    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->host.device_memory : 0;
     out->memoryOffset = in->memoryOffset;
     out->flags = in->flags;
 }
@@ -38637,7 +38637,7 @@
     out->subresource = in->subresource;
     out->offset = in->offset;
     out->extent = in->extent;
-    out->memory = in->memory ? vulkan_device_memory_from_handle(in->memory)->host.device_memory : 0;
+    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->host.device_memory : 0;
     out->memoryOffset = in->memoryOffset;
     out->flags = in->flags;
 }
@@ -39743,7 +39743,7 @@
     out->sType = in->sType;
     out->pNext = in->pNext;
     out->flags = in->flags;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = wine_device_memory_from_handle(in->memory)->host.device_memory;
 }
 #endif /* _WIN64 */
 
@@ -39754,7 +39754,7 @@
     out->sType = in->sType;
     out->pNext = NULL;
     out->flags = in->flags;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = wine_device_memory_from_handle(in->memory)->host.device_memory;
     if (in->pNext)
         FIXME("Unexpected pNext\n");
 }
@@ -40133,7 +40133,7 @@
 
     TRACE("%p, %p, %p, %p\n", params->device, params->pAllocateInfo, params->pAllocator, params->pMemory);
 
-    params->result = vk_funcs->p_vkAllocateMemory(params->device, params->pAllocateInfo, params->pAllocator, params->pMemory);
+    params->result = wine_vkAllocateMemory(params->device, params->pAllocateInfo, params->pAllocator, params->pMemory);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -40156,7 +40156,7 @@
 
     init_conversion_context(ctx);
     convert_VkMemoryAllocateInfo_win32_to_host(ctx, (const VkMemoryAllocateInfo32 *)UlongToPtr(params->pAllocateInfo), &pAllocateInfo_host);
-    params->result = vk_funcs->p_vkAllocateMemory((VkDevice)UlongToPtr(params->device), &pAllocateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkDeviceMemory *)UlongToPtr(params->pMemory));
+    params->result = wine_vkAllocateMemory((VkDevice)UlongToPtr(params->device), &pAllocateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkDeviceMemory *)UlongToPtr(params->pMemory));
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -40279,7 +40279,7 @@
 
     TRACE("%p, 0x%s, 0x%s, 0x%s\n", params->device, wine_dbgstr_longlong(params->buffer), wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->memoryOffset));
 
-    params->result = vulkan_device_from_handle(params->device)->p_vkBindBufferMemory(vulkan_device_from_handle(params->device)->host.device, params->buffer, vulkan_device_memory_from_handle(params->memory)->host.device_memory, params->memoryOffset);
+    params->result = vulkan_device_from_handle(params->device)->p_vkBindBufferMemory(vulkan_device_from_handle(params->device)->host.device, params->buffer, wine_device_memory_from_handle(params->memory)->host.device_memory, params->memoryOffset);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -40297,7 +40297,7 @@
 
     TRACE("%#x, 0x%s, 0x%s, 0x%s\n", params->device, wine_dbgstr_longlong(params->buffer), wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->memoryOffset));
 
-    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkBindBufferMemory(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->buffer, vulkan_device_memory_from_handle(params->memory)->host.device_memory, params->memoryOffset);
+    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkBindBufferMemory(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->buffer, wine_device_memory_from_handle(params->memory)->host.device_memory, params->memoryOffset);
     return STATUS_SUCCESS;
 }
 
@@ -40428,7 +40428,7 @@
 
     TRACE("%p, 0x%s, 0x%s, 0x%s\n", params->device, wine_dbgstr_longlong(params->image), wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->memoryOffset));
 
-    params->result = vulkan_device_from_handle(params->device)->p_vkBindImageMemory(vulkan_device_from_handle(params->device)->host.device, params->image, vulkan_device_memory_from_handle(params->memory)->host.device_memory, params->memoryOffset);
+    params->result = vulkan_device_from_handle(params->device)->p_vkBindImageMemory(vulkan_device_from_handle(params->device)->host.device, params->image, wine_device_memory_from_handle(params->memory)->host.device_memory, params->memoryOffset);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -40446,7 +40446,7 @@
 
     TRACE("%#x, 0x%s, 0x%s, 0x%s\n", params->device, wine_dbgstr_longlong(params->image), wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->memoryOffset));
 
-    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkBindImageMemory(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->image, vulkan_device_memory_from_handle(params->memory)->host.device_memory, params->memoryOffset);
+    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkBindImageMemory(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->image, wine_device_memory_from_handle(params->memory)->host.device_memory, params->memoryOffset);
     return STATUS_SUCCESS;
 }
 
@@ -47596,7 +47596,7 @@
 
     TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pBuffer);
 
-    params->result = vk_funcs->p_vkCreateBuffer(params->device, params->pCreateInfo, params->pAllocator, params->pBuffer);
+    params->result = wine_vkCreateBuffer(params->device, params->pCreateInfo, params->pAllocator, params->pBuffer);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -47619,7 +47619,7 @@
 
     init_conversion_context(ctx);
     convert_VkBufferCreateInfo_win32_to_host(ctx, (const VkBufferCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
-    params->result = vk_funcs->p_vkCreateBuffer((VkDevice)UlongToPtr(params->device), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkBuffer *)UlongToPtr(params->pBuffer));
+    params->result = wine_vkCreateBuffer((VkDevice)UlongToPtr(params->device), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkBuffer *)UlongToPtr(params->pBuffer));
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -48311,7 +48311,7 @@
 
     init_conversion_context(ctx);
     convert_VkImageCreateInfo_win64_to_host(ctx, params->pCreateInfo, &pCreateInfo_host);
-    params->result = vk_funcs->p_vkCreateImage(params->device, &pCreateInfo_host, params->pAllocator, params->pImage);
+    params->result = wine_vkCreateImage(params->device, &pCreateInfo_host, params->pAllocator, params->pImage);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -48335,7 +48335,7 @@
 
     init_conversion_context(ctx);
     convert_VkImageCreateInfo_win32_to_host(ctx, (const VkImageCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
-    params->result = vk_funcs->p_vkCreateImage((VkDevice)UlongToPtr(params->device), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkImage *)UlongToPtr(params->pImage));
+    params->result = wine_vkCreateImage((VkDevice)UlongToPtr(params->device), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkImage *)UlongToPtr(params->pImage));
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -51282,7 +51282,7 @@
 
     TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->memory), params->pAllocator);
 
-    vk_funcs->p_vkFreeMemory(params->device, params->memory, params->pAllocator);
+    wine_vkFreeMemory(params->device, params->memory, params->pAllocator);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -51298,7 +51298,7 @@
 
     TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->memory), params->pAllocator);
 
-    vk_funcs->p_vkFreeMemory((VkDevice)UlongToPtr(params->device), params->memory, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator));
+    wine_vkFreeMemory((VkDevice)UlongToPtr(params->device), params->memory, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator));
     return STATUS_SUCCESS;
 }
 
@@ -52778,7 +52778,7 @@
 
     TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->memory), params->pCommittedMemoryInBytes);
 
-    vulkan_device_from_handle(params->device)->p_vkGetDeviceMemoryCommitment(vulkan_device_from_handle(params->device)->host.device, vulkan_device_memory_from_handle(params->memory)->host.device_memory, params->pCommittedMemoryInBytes);
+    vulkan_device_from_handle(params->device)->p_vkGetDeviceMemoryCommitment(vulkan_device_from_handle(params->device)->host.device, wine_device_memory_from_handle(params->memory)->host.device_memory, params->pCommittedMemoryInBytes);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -52794,7 +52794,7 @@
 
     TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->memory), params->pCommittedMemoryInBytes);
 
-    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDeviceMemoryCommitment(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, vulkan_device_memory_from_handle(params->memory)->host.device_memory, (VkDeviceSize *)UlongToPtr(params->pCommittedMemoryInBytes));
+    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDeviceMemoryCommitment(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, wine_device_memory_from_handle(params->memory)->host.device_memory, (VkDeviceSize *)UlongToPtr(params->pCommittedMemoryInBytes));
     return STATUS_SUCCESS;
 }
 
@@ -56929,7 +56929,7 @@
 
     TRACE("%p, 0x%s, 0x%s, 0x%s, %#x, %p\n", params->device, wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->offset), wine_dbgstr_longlong(params->size), params->flags, params->ppData);
 
-    params->result = vk_funcs->p_vkMapMemory(params->device, params->memory, params->offset, params->size, params->flags, params->ppData);
+    params->result = wine_vkMapMemory(params->device, params->memory, params->offset, params->size, params->flags, params->ppData);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -56951,7 +56951,7 @@
     TRACE("%#x, 0x%s, 0x%s, 0x%s, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->offset), wine_dbgstr_longlong(params->size), params->flags, params->ppData);
 
     ppData_host = UlongToPtr(*(PTR32 *)UlongToPtr(params->ppData));
-    params->result = vk_funcs->p_vkMapMemory((VkDevice)UlongToPtr(params->device), params->memory, params->offset, params->size, params->flags, &ppData_host);
+    params->result = wine_vkMapMemory((VkDevice)UlongToPtr(params->device), params->memory, params->offset, params->size, params->flags, &ppData_host);
     *(PTR32 *)UlongToPtr(params->ppData) = PtrToUlong(ppData_host);
     return STATUS_SUCCESS;
 }
@@ -56998,7 +56998,7 @@
 
     TRACE("%p, %p, %p\n", params->device, params->pMemoryMapInfo, params->ppData);
 
-    params->result = vk_funcs->p_vkMapMemory2KHR(params->device, params->pMemoryMapInfo, params->ppData);
+    params->result = wine_vkMapMemory2KHR(params->device, params->pMemoryMapInfo, params->ppData);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -57019,7 +57019,7 @@
 
     convert_VkMemoryMapInfo_win32_to_unwrapped_host((const VkMemoryMapInfo32 *)UlongToPtr(params->pMemoryMapInfo), &pMemoryMapInfo_host);
     ppData_host = UlongToPtr(*(PTR32 *)UlongToPtr(params->ppData));
-    params->result = vk_funcs->p_vkMapMemory2KHR((VkDevice)UlongToPtr(params->device), &pMemoryMapInfo_host, &ppData_host);
+    params->result = wine_vkMapMemory2KHR((VkDevice)UlongToPtr(params->device), &pMemoryMapInfo_host, &ppData_host);
     *(PTR32 *)UlongToPtr(params->ppData) = PtrToUlong(ppData_host);
     return STATUS_SUCCESS;
 }
@@ -57848,7 +57848,7 @@
 
     TRACE("%p, 0x%s, %f\n", params->device, wine_dbgstr_longlong(params->memory), params->priority);
 
-    vulkan_device_from_handle(params->device)->p_vkSetDeviceMemoryPriorityEXT(vulkan_device_from_handle(params->device)->host.device, vulkan_device_memory_from_handle(params->memory)->host.device_memory, params->priority);
+    vulkan_device_from_handle(params->device)->p_vkSetDeviceMemoryPriorityEXT(vulkan_device_from_handle(params->device)->host.device, wine_device_memory_from_handle(params->memory)->host.device_memory, params->priority);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -57864,7 +57864,7 @@
 
     TRACE("%#x, 0x%s, %f\n", params->device, wine_dbgstr_longlong(params->memory), params->priority);
 
-    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkSetDeviceMemoryPriorityEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, vulkan_device_memory_from_handle(params->memory)->host.device_memory, params->priority);
+    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkSetDeviceMemoryPriorityEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, wine_device_memory_from_handle(params->memory)->host.device_memory, params->priority);
     return STATUS_SUCCESS;
 }
 
@@ -58308,7 +58308,7 @@
 
     TRACE("%p, 0x%s\n", params->device, wine_dbgstr_longlong(params->memory));
 
-    vk_funcs->p_vkUnmapMemory(params->device, params->memory);
+    wine_vkUnmapMemory(params->device, params->memory);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -58323,7 +58323,7 @@
 
     TRACE("%#x, 0x%s\n", params->device, wine_dbgstr_longlong(params->memory));
 
-    vk_funcs->p_vkUnmapMemory((VkDevice)UlongToPtr(params->device), params->memory);
+    wine_vkUnmapMemory((VkDevice)UlongToPtr(params->device), params->memory);
     return STATUS_SUCCESS;
 }
 
@@ -58365,7 +58365,7 @@
 
     TRACE("%p, %p\n", params->device, params->pMemoryUnmapInfo);
 
-    params->result = vk_funcs->p_vkUnmapMemory2KHR(params->device, params->pMemoryUnmapInfo);
+    params->result = wine_vkUnmapMemory2KHR(params->device, params->pMemoryUnmapInfo);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -58383,7 +58383,7 @@
     TRACE("%#x, %#x\n", params->device, params->pMemoryUnmapInfo);
 
     convert_VkMemoryUnmapInfo_win32_to_unwrapped_host((const VkMemoryUnmapInfo32 *)UlongToPtr(params->pMemoryUnmapInfo), &pMemoryUnmapInfo_host);
-    params->result = vk_funcs->p_vkUnmapMemory2KHR((VkDevice)UlongToPtr(params->device), &pMemoryUnmapInfo_host);
+    params->result = wine_vkUnmapMemory2KHR((VkDevice)UlongToPtr(params->device), &pMemoryUnmapInfo_host);
     return STATUS_SUCCESS;
 }
 
diff --git b/dlls/winevulkan/vulkan_thunks.h a/dlls/winevulkan/vulkan_thunks.h
index 4f5abf6cabc..23dbf19424d 100644
--- b/dlls/winevulkan/vulkan_thunks.h
+++ a/dlls/winevulkan/vulkan_thunks.h
@@ -22,11 +22,14 @@
 
 /* Functions for which we have custom implementations outside of the thunks. */
 VkResult wine_vkAllocateCommandBuffers(VkDevice device, const VkCommandBufferAllocateInfo *pAllocateInfo, VkCommandBuffer *pCommandBuffers);
+VkResult wine_vkAllocateMemory(VkDevice device, const VkMemoryAllocateInfo *pAllocateInfo, const VkAllocationCallbacks *pAllocator, VkDeviceMemory *pMemory);
+VkResult wine_vkCreateBuffer(VkDevice device, const VkBufferCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkBuffer *pBuffer);
 VkResult wine_vkCreateCommandPool(VkDevice device, const VkCommandPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkCommandPool *pCommandPool, void *client_ptr);
 VkResult wine_vkCreateDebugReportCallbackEXT(VkInstance instance, const VkDebugReportCallbackCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDebugReportCallbackEXT *pCallback);
 VkResult wine_vkCreateDebugUtilsMessengerEXT(VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDebugUtilsMessengerEXT *pMessenger);
 VkResult wine_vkCreateDeferredOperationKHR(VkDevice device, const VkAllocationCallbacks *pAllocator, VkDeferredOperationKHR *pDeferredOperation);
 VkResult wine_vkCreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDevice *pDevice, void *client_ptr);
+VkResult wine_vkCreateImage(VkDevice device, const VkImageCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkImage *pImage);
 VkResult wine_vkCreateInstance(const VkInstanceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkInstance *pInstance, void *client_ptr);
 void wine_vkDestroyCommandPool(VkDevice device, VkCommandPool commandPool, const VkAllocationCallbacks *pAllocator);
 void wine_vkDestroyDebugReportCallbackEXT(VkInstance instance, VkDebugReportCallbackEXT callback, const VkAllocationCallbacks *pAllocator);
@@ -42,6 +45,7 @@ VkResult wine_vkEnumeratePhysicalDeviceGroups(VkInstance instance, uint32_t *pPh
 VkResult wine_vkEnumeratePhysicalDeviceGroupsKHR(VkInstance instance, uint32_t *pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties);
 VkResult wine_vkEnumeratePhysicalDevices(VkInstance instance, uint32_t *pPhysicalDeviceCount, VkPhysicalDevice *pPhysicalDevices);
 void wine_vkFreeCommandBuffers(VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, const VkCommandBuffer *pCommandBuffers);
+void wine_vkFreeMemory(VkDevice device, VkDeviceMemory memory, const VkAllocationCallbacks *pAllocator);
 VkResult wine_vkGetCalibratedTimestampsEXT(VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoKHR *pTimestampInfos, uint64_t *pTimestamps, uint64_t *pMaxDeviation);
 VkResult wine_vkGetCalibratedTimestampsKHR(VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoKHR *pTimestampInfos, uint64_t *pTimestamps, uint64_t *pMaxDeviation);
 void wine_vkGetDeviceQueue(VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue *pQueue);
@@ -56,5 +60,9 @@ void wine_vkGetPhysicalDeviceExternalSemaphoreProperties(VkPhysicalDevice physic
 void wine_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, VkExternalSemaphoreProperties *pExternalSemaphoreProperties);
 VkResult wine_vkGetPhysicalDeviceImageFormatProperties2(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties);
 VkResult wine_vkGetPhysicalDeviceImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties);
+VkResult wine_vkMapMemory(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void **ppData);
+VkResult wine_vkMapMemory2KHR(VkDevice device, const VkMemoryMapInfo *pMemoryMapInfo, void **ppData);
+void wine_vkUnmapMemory(VkDevice device, VkDeviceMemory memory);
+VkResult wine_vkUnmapMemory2KHR(VkDevice device, const VkMemoryUnmapInfo *pMemoryUnmapInfo);
 
 #endif /* __WINE_VULKAN_THUNKS_H */
diff --git b/include/wine/vulkan_driver.h a/include/wine/vulkan_driver.h
index c373f639451..3788ff02dc6 100644
--- b/include/wine/vulkan_driver.h
+++ a/include/wine/vulkan_driver.h
@@ -79,9 +79,6 @@ struct vulkan_instance
 #undef USE_VK_FUNC
     void (*p_insert_object)( struct vulkan_instance *instance, struct vulkan_object *obj );
     void (*p_remove_object)( struct vulkan_instance *instance, struct vulkan_object *obj );
-
-    struct vulkan_physical_device *physical_devices;
-    uint32_t physical_device_count;
 };
 
 static inline struct vulkan_instance *vulkan_instance_from_handle( VkInstance handle )
@@ -95,14 +92,6 @@ struct vulkan_physical_device
     VULKAN_OBJECT_HEADER( VkPhysicalDevice, physical_device );
     struct vulkan_instance *instance;
     bool has_swapchain_maintenance1;
-
-    VkExtensionProperties *extensions;
-    uint32_t extension_count;
-
-    /* for WOW64 memory mapping with VK_EXT_external_memory_host */
-    VkPhysicalDeviceMemoryProperties memory_properties;
-    uint32_t external_memory_align;
-    uint32_t map_placed_align;
 };
 
 static inline struct vulkan_physical_device *vulkan_physical_device_from_handle( VkPhysicalDevice handle )
@@ -138,16 +127,6 @@ static inline struct vulkan_queue *vulkan_queue_from_handle( VkQueue handle )
     return (struct vulkan_queue *)(UINT_PTR)client->unix_handle;
 }
 
-struct vulkan_device_memory
-{
-    VULKAN_OBJECT_HEADER( VkDeviceMemory, device_memory );
-};
-
-static inline struct vulkan_device_memory *vulkan_device_memory_from_handle( VkDeviceMemory handle )
-{
-    return (struct vulkan_device_memory *)(UINT_PTR)handle;
-}
-
 struct vulkan_surface
 {
     VULKAN_OBJECT_HEADER( VkSurfaceKHR, surface );
@@ -177,14 +156,10 @@ struct vulkan_funcs
      */
     PFN_vkAcquireNextImage2KHR p_vkAcquireNextImage2KHR;
     PFN_vkAcquireNextImageKHR p_vkAcquireNextImageKHR;
-    PFN_vkAllocateMemory p_vkAllocateMemory;
-    PFN_vkCreateBuffer p_vkCreateBuffer;
-    PFN_vkCreateImage p_vkCreateImage;
     PFN_vkCreateSwapchainKHR p_vkCreateSwapchainKHR;
     PFN_vkCreateWin32SurfaceKHR p_vkCreateWin32SurfaceKHR;
     PFN_vkDestroySurfaceKHR p_vkDestroySurfaceKHR;
     PFN_vkDestroySwapchainKHR p_vkDestroySwapchainKHR;
-    PFN_vkFreeMemory p_vkFreeMemory;
     PFN_vkGetDeviceProcAddr p_vkGetDeviceProcAddr;
     PFN_vkGetInstanceProcAddr p_vkGetInstanceProcAddr;
     PFN_vkGetPhysicalDevicePresentRectanglesKHR p_vkGetPhysicalDevicePresentRectanglesKHR;
@@ -193,11 +168,7 @@ struct vulkan_funcs
     PFN_vkGetPhysicalDeviceSurfaceFormats2KHR p_vkGetPhysicalDeviceSurfaceFormats2KHR;
     PFN_vkGetPhysicalDeviceSurfaceFormatsKHR p_vkGetPhysicalDeviceSurfaceFormatsKHR;
     PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR p_vkGetPhysicalDeviceWin32PresentationSupportKHR;
-    PFN_vkMapMemory p_vkMapMemory;
-    PFN_vkMapMemory2KHR p_vkMapMemory2KHR;
     PFN_vkQueuePresentKHR p_vkQueuePresentKHR;
-    PFN_vkUnmapMemory p_vkUnmapMemory;
-    PFN_vkUnmapMemory2KHR p_vkUnmapMemory2KHR;
 
     /* winevulkan specific functions */
     const char *(*p_get_host_surface_extension)(void);

From 3e21e7bd60a84dec269fe6f5fa0cd4d3a7f8106d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 1 Dec 2023 21:24:07 +0100
Subject: [PATCH 0014/1564] vrclient: Revert "winevulkan: Check if instance
 extensions are supported."

This reverts commit e84999bd7ab859746e893ed2d49b1d42b0323c3a.

Vulkan VR games will try to load some extensions that winevulkan doesn't
support.
---
 dlls/winevulkan/vulkan.c | 5 -----
 1 file changed, 5 deletions(-)

diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index 61b3a42d63f..f8a7064f093 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -688,11 +688,6 @@ static VkResult wine_vk_instance_convert_create_info(struct conversion_context *
     {
         const char *extension_name = src->ppEnabledExtensionNames[i];
         TRACE("Extension %u: %s.\n", i, debugstr_a(extension_name));
-        if (!wine_vk_instance_extension_supported(extension_name))
-        {
-            WARN("Extension %s is not supported.\n", debugstr_a(extension_name));
-            return VK_ERROR_EXTENSION_NOT_PRESENT;
-        }
     }
 
     new_extensions = conversion_context_alloc(ctx, (src->enabledExtensionCount + 2) *
-- 
2.49.0

From 18138491a912d2a26cb2fdf68314fb7af28e0a20 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 1 Dec 2023 21:24:10 +0100
Subject: [PATCH 0015/1564] vrclient: Revert "winevulkan: Check if device
 extensions are supported."

This reverts commit 4907ffdf2a15ab3a1e3749def37f4be67b758a35.

Vulkan VR games will try to load some extensions that winevulkan doesn't
support.
---
 dlls/winevulkan/vulkan.c | 5 -----
 1 file changed, 5 deletions(-)

diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index f8a7064f093..ad7fc06cc0e 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -559,11 +559,6 @@ static VkResult wine_vk_device_convert_create_info(VkPhysicalDevice client_physi
     {
         const char *extension_name = extensions[i];
         TRACE("Extension %u: %s.\n", i, debugstr_a(extension_name));
-        if (!wine_vk_device_extension_supported(extension_name))
-        {
-            WARN("Extension %s is not supported.\n", debugstr_a(extension_name));
-            return VK_ERROR_EXTENSION_NOT_PRESENT;
-        }
     }
 
     if (phys_dev->map_placed_align)
-- 
2.49.0

From 7ecc1d7fe67fb23f0082432e052fb6eaeb84748a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 1 Dec 2023 21:24:16 +0100
Subject: [PATCH 0016/1564] vrclient: winevulkan: Retrieve XR extensions from
 the environment.

---
 dlls/winevulkan/vulkan.c | 68 +++++++++++++++++++++++++++++++++++++++-
 1 file changed, 67 insertions(+), 1 deletion(-)

diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index ad7fc06cc0e..82aae4ad0bf 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -531,6 +531,49 @@ static void wine_vk_device_init_queues(struct wine_device *object, const VkDevic
     object->queue_count += info->queueCount;
 }
 
+static char *cc_strdup(struct conversion_context *ctx, const char *s)
+{
+    int len = strlen(s) + 1;
+    char *ret;
+
+    ret = conversion_context_alloc(ctx, len);
+    memcpy(ret, s, len);
+    return ret;
+}
+
+static void parse_xr_extensions(struct conversion_context *ctx, const char **extra_extensions, unsigned int *extra_count)
+{
+    char *iter, *start;
+
+    iter = getenv("__WINE_OPENXR_VK_DEVICE_EXTENSIONS");
+    if (!iter) return;
+    iter = cc_strdup(ctx, iter);
+
+    TRACE("got var: %s\n", iter);
+    start = iter;
+    do
+    {
+        if(*iter == ' ')
+        {
+            *iter = 0;
+            extra_extensions[(*extra_count)++] = cc_strdup(ctx, start);
+            TRACE("added %s to list\n", extra_extensions[(*extra_count) - 1]);
+            iter++;
+            start = iter;
+        }
+        else if(*iter == 0)
+        {
+            extra_extensions[(*extra_count)++] = cc_strdup(ctx, start);
+            TRACE("added %s to list\n", extra_extensions[(*extra_count) - 1]);
+            break;
+        }
+        else
+        {
+            iter++;
+        }
+    } while (1);
+}
+
 static const char *find_extension(const char *const *extensions, uint32_t count, const char *ext)
 {
     while (count--)
@@ -561,6 +607,12 @@ static VkResult wine_vk_device_convert_create_info(VkPhysicalDevice client_physi
         TRACE("Extension %u: %s.\n", i, debugstr_a(extension_name));
     }
 
+    if (find_extension(extensions, extensions_count, wine_xr_extension_name))
+    {
+        parse_xr_extensions(ctx, extra_extensions, &extra_count);
+        remove_extensions[remove_count++] = wine_xr_extension_name;
+    }
+
     if (phys_dev->map_placed_align)
     {
         VkPhysicalDeviceMapMemoryPlacedFeaturesEXT *map_placed_features;
@@ -592,6 +644,20 @@ static VkResult wine_vk_device_convert_create_info(VkPhysicalDevice client_physi
         dst->enabledExtensionCount += extra_count;
         new_extensions = conversion_context_alloc(ctx, dst->enabledExtensionCount * sizeof(*new_extensions));
         memcpy(new_extensions, extensions, extensions_count * sizeof(*new_extensions));
+        for (i = 0; i < extensions_count; i++)
+        {
+            for (j = 0; j < remove_count; ++j)
+            {
+                if (!strcmp(new_extensions[i], remove_extensions[j]))
+                {
+                    --dst->enabledExtensionCount;
+                    --extensions_count;
+                    memmove(&new_extensions[i], &new_extensions[i + 1], sizeof(*new_extensions) * (extensions_count - i));
+                    --i;
+                    break;
+                }
+            }
+        }
         memcpy(new_extensions + extensions_count, extra_extensions, extra_count * sizeof(*new_extensions));
         dst->ppEnabledExtensionNames = new_extensions;
     }
-- 
2.49.0

From 2685a7b09f9337b0d5e5cc39e9f12bac7e5dc9a3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 1 Dec 2023 21:24:24 +0100
Subject: [PATCH 0017/1564] vrclient: winevulkan: Add custom Vk structures for
 creating instance and device through OpenXR.

---
 dlls/winevulkan/make_vulkan | 35 +++++++++++++++++++++++++++-
 dlls/winevulkan/vulkan.c    | 46 ++++++++++++++++++++++++++++++++++---
 2 files changed, 77 insertions(+), 4 deletions(-)

diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index 72a8d548b5d..c8e112f8134 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -2493,7 +2493,18 @@ class StructConversionFunction(object):
 
             body += "        default:\n"
             if self.direction == Direction.INPUT:
-                body += ident + "FIXME(\"Unhandled sType %u.\\n\", in_header->sType);\n"
+                body += ident + "if ((in_header->sType >> 16) == 0x7ead)\n"
+                body += ident + "{\n"
+                body += ident + "    VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);\n";
+                body += ident + "    memcpy(out_ext, in_header, 32);\n";
+                body += ident + "    out_ext->pNext = NULL;\n";
+                body += ident + "    out_header->pNext = (void *)out_ext;\n";
+                body += ident + "    out_header = (void *)out_ext;\n";
+                body += ident + "}\n"
+                body += ident + "else\n"
+                body += ident + "{\n"
+                body += ident + "    FIXME(\"Unhandled sType %u.\\n\", in_header->sType);\n"
+                body += ident + "}\n"
             body += "            break;\n"
             body += "        }\n"
             body += "    }\n"
@@ -3148,6 +3159,28 @@ class VkGenerator(object):
                 f.write(" \\\n    USE_VK_FUNC({0})".format(vk_func.name))
         f.write("\n\n")
 
+        f.write("typedef VkResult (*PFN_native_vkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *,\n")
+        f.write("                                                       void * (*)(VkInstance, const char *), void *);\n");
+        f.write("typedef VkResult (*PFN_native_vkCreateDevice)(VkPhysicalDevice, const VkDeviceCreateInfo *, const VkAllocationCallbacks *, VkDevice *,\n");
+        f.write("                                                     void * (*)(VkInstance, const char *), void *);\n\n");
+        f.write("typedef struct VkCreateInfoWineDeviceCallback {\n");
+        f.write("    VkStructureType             sType;\n");
+        f.write("    const void*                 pNext;\n");
+        f.write("    PFN_native_vkCreateDevice   native_create_callback;\n");
+        f.write("    void*                       context;\n");
+        f.write("} VkCreateInfoWineDeviceCallback;\n");
+
+        f.write("#define VK_STRUCTURE_TYPE_CREATE_INFO_WINE_DEVICE_CALLBACK 2125312001\n");
+
+        f.write("typedef struct VkCreateInfoWineInstanceCallback {\n");
+        f.write("    VkStructureType             sType;\n");
+        f.write("    const void*                 pNext;\n");
+        f.write("    PFN_native_vkCreateInstance native_create_callback;\n");
+        f.write("    void*                       context;\n");
+        f.write("} VkCreateInfoWineInstanceCallback;\n");
+
+        f.write("#define VK_STRUCTURE_TYPE_CREATE_INFO_WINE_INSTANCE_CALLBACK 2125312002\n");
+
         f.write("#endif /* __WINE_VULKAN_H */\n")
 
     def generate_vulkan_spec(self, f):
diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index 82aae4ad0bf..7c8990172f5 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -707,6 +710,9 @@ static VkResult wine_vk_instance_convert_create_info(struct conversion_context *
 
     *dst = *src;
 
+    if ((header = (VkBaseInStructure *)dst->pNext) && header->sType == VK_STRUCTURE_TYPE_CREATE_INFO_WINE_INSTANCE_CALLBACK)
+        dst->pNext = header->pNext;
+
     instance->utils_messenger_count = wine_vk_count_struct(dst, DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT);
     instance->utils_messengers =  calloc(instance->utils_messenger_count, sizeof(*instance->utils_messengers));
     header = (VkBaseInStructure *) dst;
@@ -922,6 +928,10 @@ VkResult wine_vkCreateDevice(VkPhysicalDevice client_physical_device, const VkDe
     unsigned int queue_count, i;
     VkResult res;
 
+    PFN_native_vkCreateDevice native_create_device = NULL;
+    void *native_create_device_context = NULL;
+    VkCreateInfoWineDeviceCallback *callback;
+
     if (allocator)
         FIXME("Support for allocation callbacks not implemented yet\n");
 
@@ -943,11 +953,25 @@ VkResult wine_vkCreateDevice(VkPhysicalDevice client_physical_device, const VkDe
     if (!(device = calloc(1, offsetof(struct wine_device, queues[queue_count]))))
         return VK_ERROR_OUT_OF_HOST_MEMORY;
 
+    if ((callback = (VkCreateInfoWineDeviceCallback *)create_info->pNext)
+            && callback->sType == VK_STRUCTURE_TYPE_CREATE_INFO_WINE_DEVICE_CALLBACK)
+    {
+        native_create_device = callback->native_create_callback;
+        native_create_device_context = callback->context;
+    }
+
     init_conversion_context(&ctx);
     res = wine_vk_device_convert_create_info(client_physical_device, &ctx, create_info, &create_info_host);
     if (res == VK_SUCCESS)
-        res = instance->p_vkCreateDevice(physical_device->host.physical_device, &create_info_host,
-                                               NULL /* allocator */, &host_device);
+    {
+        if (native_create_device)
+            res = native_create_device(physical_device->host.physical_device, &create_info_host,
+                                       NULL /* allocator */, &host_device,
+                                       (void *)vk_funcs->p_vkGetInstanceProcAddr, native_create_device_context);
+        else
+            res = instance->p_vkCreateDevice(physical_device->host.physical_device, &create_info_host,
+                                             NULL /* allocator */, &host_device);
+    }
     free_conversion_context(&ctx);
     if (res != VK_SUCCESS)
     {
@@ -990,6 +1014,9 @@ VkResult wine_vkCreateInstance(const VkInstanceCreateInfo *create_info,
                                const VkAllocationCallbacks *allocator, VkInstance *ret,
                                void *client_ptr)
 {
+    PFN_native_vkCreateInstance native_create_instance = NULL;
+    void *native_create_instance_context = NULL;
+    VkCreateInfoWineInstanceCallback *callback;
     VkInstanceCreateInfo create_info_host;
     const VkApplicationInfo *app_info;
     struct conversion_context ctx;
@@ -1007,10 +1034,23 @@ VkResult wine_vkCreateInstance(const VkInstanceCreateInfo *create_info,
         return VK_ERROR_OUT_OF_HOST_MEMORY;
     }
 
+    if ((callback = (VkCreateInfoWineInstanceCallback *)create_info->pNext)
+            && callback->sType == VK_STRUCTURE_TYPE_CREATE_INFO_WINE_INSTANCE_CALLBACK)
+    {
+        native_create_instance = callback->native_create_callback;
+        native_create_instance_context = callback->context;
+    }
+
     init_conversion_context(&ctx);
     res = wine_vk_instance_convert_create_info(&ctx, create_info, &create_info_host, instance);
     if (res == VK_SUCCESS)
-        res = p_vkCreateInstance(&create_info_host, NULL /* allocator */, &host_instance);
+    {
+        if (native_create_instance)
+            res = native_create_instance(&create_info_host, NULL /* allocator */, &host_instance,
+                    (void *)vk_funcs->p_vkGetInstanceProcAddr, native_create_instance_context);
+        else
+            res = p_vkCreateInstance(&create_info_host, NULL /* allocator */, &host_instance);
+    }
     free_conversion_context(&ctx);
     if (res != VK_SUCCESS)
     {
-- 
2.49.0

From 05559d938bca44759f3fde8ed892517a0f1b7173 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 6 Dec 2024 17:48:53 +0100
Subject: [PATCH 0582/1564] winevulkan: Get rid of the internal wine_queue
 struct.

---
 dlls/winevulkan/vulkan.c         | 20 ++++++++++----------
 dlls/winevulkan/vulkan_private.h | 11 +----------
 include/wine/vulkan_driver.h     |  3 +++
 3 files changed, 14 insertions(+), 20 deletions(-)

diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index 7c8990172f5..1a571a33a52 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -487,7 +487,7 @@ static void wine_vk_free_command_buffers(struct vulkan_device *device,
 
 static void wine_vk_device_init_queues(struct wine_device *object, const VkDeviceQueueCreateInfo *info)
 {
-    struct wine_queue *queues = object->queues + object->queue_count;
+    struct vulkan_queue *queues = object->queues + object->queue_count;
     struct vulkan_device *device = &object->obj;
     VkQueue client_queues = device->client.device->queues + object->queue_count;
     VkDeviceQueueInfo2 queue_info;
@@ -497,7 +497,7 @@ static void wine_vk_device_init_queues(struct wine_device *object, const VkDevic
 
     for (i = 0; i < info->queueCount; i++)
     {
-        struct wine_queue *queue = queues + i;
+        struct vulkan_queue *queue = queues + i;
         VkQueue host_queue, client_queue = client_queues + i;
 
         /* The Vulkan spec says:
@@ -519,13 +519,13 @@ static void wine_vk_device_init_queues(struct wine_device *object, const VkDevic
             device->p_vkGetDeviceQueue(device->host.device, info->queueFamilyIndex, i, &host_queue);
         }
 
-        vulkan_object_init_ptr(&queue->obj.obj, (UINT_PTR)host_queue, &client_queue->obj);
-        queue->obj.device = device;
+        vulkan_object_init_ptr(&queue->obj, (UINT_PTR)host_queue, &client_queue->obj);
+        queue->device = device;
         queue->family_index = info->queueFamilyIndex;
         queue->queue_index = i;
         queue->flags = info->flags;
 
-        TRACE("Got device %p queue %p, host_queue %p.\n", device, queue, queue->obj.host.queue);
+        TRACE("Got device %p queue %p, host_queue %p.\n", device, queue, queue->host.queue);
     }
 
     object->queue_count += info->queueCount;
@@ -1001,8 +1001,8 @@ VkResult wine_vkCreateDevice(VkPhysicalDevice client_physical_device, const VkDe
     TRACE("Created device %p, host_device %p.\n", device, device->obj.host.device);
     for (i = 0; i < device->queue_count; i++)
     {
-        struct wine_queue *queue = device->queues + i;
-        vulkan_instance_insert_object(instance, &queue->obj.obj);
+        struct vulkan_queue *queue = device->queues + i;
+        vulkan_instance_insert_object(instance, &queue->obj);
     }
     vulkan_instance_insert_object(instance, &device->obj.obj);
 
@@ -1126,7 +1126,7 @@ void wine_vkDestroyDevice(VkDevice client_device, const VkAllocationCallbacks *a
 
     device->obj.p_vkDestroyDevice(device->obj.host.device, NULL /* pAllocator */);
     for (i = 0; i < device->queue_count; i++)
-        vulkan_instance_remove_object(instance, &device->queues[i].obj.obj);
+        vulkan_instance_remove_object(instance, &device->queues[i].obj);
     vulkan_instance_remove_object(instance, &device->obj.obj);
 
     free(device);
@@ -1304,7 +1304,7 @@ void wine_vkFreeCommandBuffers(VkDevice client_device, VkCommandPool command_poo
 static VkQueue wine_vk_device_find_queue(VkDevice client_device, const VkDeviceQueueInfo2 *info)
 {
     struct wine_device *device = wine_device_from_handle(client_device);
-    struct wine_queue *queue;
+    struct vulkan_queue *queue;
     uint32_t i;
 
     for (i = 0; i < device->queue_count; i++)
@@ -1314,7 +1314,7 @@ static VkQueue wine_vk_device_find_queue(VkDevice client_device, const VkDeviceQ
                 && queue->queue_index == info->queueIndex
                 && queue->flags == info->flags)
         {
-            return queue->obj.client.queue;
+            return queue->client.queue;
         }
     }
 
diff --git a/dlls/winevulkan/vulkan_private.h b/dlls/winevulkan/vulkan_private.h
index 59b900930b3..c0c92bd88c9 100644
--- a/dlls/winevulkan/vulkan_private.h
+++ b/dlls/winevulkan/vulkan_private.h
@@ -41,20 +41,11 @@ static inline struct wine_cmd_buffer *wine_cmd_buffer_from_handle(VkCommandBuffe
     return (struct wine_cmd_buffer *)(UINT_PTR)client->unix_handle;
 }
 
-struct wine_queue
-{
-    struct vulkan_queue obj;
-
-    uint32_t family_index;
-    uint32_t queue_index;
-    VkDeviceQueueCreateFlags flags;
-};
-
 struct wine_device
 {
     struct vulkan_device obj;
     uint64_t queue_count;
-    struct wine_queue queues[];
+    struct vulkan_queue queues[];
 };
 
 C_ASSERT(sizeof(struct wine_device) == offsetof(struct wine_device, queues[0]));
diff --git a/include/wine/vulkan_driver.h b/include/wine/vulkan_driver.h
index 39263084c82..f72b2ff3b0c 100644
--- a/include/wine/vulkan_driver.h
+++ b/include/wine/vulkan_driver.h
@@ -121,6 +121,9 @@ struct vulkan_queue
 {
     VULKAN_OBJECT_HEADER( VkQueue, queue );
     struct vulkan_device *device;
+    uint32_t family_index;
+    uint32_t queue_index;
+    VkDeviceQueueCreateFlags flags;
 };
 
 static inline struct vulkan_queue *vulkan_queue_from_handle( VkQueue handle )
-- 
2.49.0

From efe7ba3f755476549f8f369feae15d32a079f9f4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 6 Dec 2024 17:50:38 +0100
Subject: [PATCH 0583/1564] winevulkan: Define struct wine_device queues as a
 pointer.

---
 dlls/winevulkan/vulkan.c         | 11 +++++++++--
 dlls/winevulkan/vulkan_private.h |  4 +---
 2 files changed, 10 insertions(+), 5 deletions(-)

diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index 1a571a33a52..91606023b8c 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -927,6 +927,8 @@ VkResult wine_vkCreateDevice(VkPhysicalDevice client_physical_device, const VkDe
     struct wine_device *device;
     unsigned int queue_count, i;
     VkResult res;
+    size_t size;
+    void *ptr;
 
     PFN_native_vkCreateDevice native_create_device = NULL;
     void *native_create_device_context = NULL;
@@ -946,12 +948,17 @@ VkResult wine_vkCreateDevice(VkPhysicalDevice client_physical_device, const VkDe
         TRACE("Driver version: %#x.\n", properties.driverVersion);
     }
 
+    size = sizeof(*device);
+
     /* We need to cache all queues within the device as each requires wrapping since queues are dispatchable objects. */
     for (queue_count = 0, i = 0; i < create_info->queueCreateInfoCount; i++)
         queue_count += create_info->pQueueCreateInfos[i].queueCount;
+    size += queue_count * sizeof(*device->queues);
 
-    if (!(device = calloc(1, offsetof(struct wine_device, queues[queue_count]))))
-        return VK_ERROR_OUT_OF_HOST_MEMORY;
+    if (!(device = ptr = calloc(1, size))) return VK_ERROR_OUT_OF_HOST_MEMORY;
+    ptr = (char *)ptr + sizeof(*device);
+    device->queues = ptr;
+    ptr = (char *)ptr + queue_count * sizeof(*device->queues);
 
     if ((callback = (VkCreateInfoWineDeviceCallback *)create_info->pNext)
             && callback->sType == VK_STRUCTURE_TYPE_CREATE_INFO_WINE_DEVICE_CALLBACK)
diff --git a/dlls/winevulkan/vulkan_private.h b/dlls/winevulkan/vulkan_private.h
index c0c92bd88c9..2452dfd7dad 100644
--- a/dlls/winevulkan/vulkan_private.h
+++ b/dlls/winevulkan/vulkan_private.h
@@ -45,11 +45,9 @@ struct wine_device
 {
     struct vulkan_device obj;
     uint64_t queue_count;
-    struct vulkan_queue queues[];
+    struct vulkan_queue *queues;
 };
 
-C_ASSERT(sizeof(struct wine_device) == offsetof(struct wine_device, queues[0]));
-
 struct wine_debug_utils_messenger;
 
 struct wine_debug_report_callback
-- 
2.49.0

From c0435d9a2ee36b5cfc884cbba3ab7a5de605f1b6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 6 Dec 2024 17:52:39 +0100
Subject: [PATCH 0584/1564] winevulkan: Get rid of internal struct wine_device.

---
 dlls/winevulkan/vulkan.c         | 39 +++++++++++++-------------------
 dlls/winevulkan/vulkan_private.h |  7 ------
 include/wine/vulkan_driver.h     |  2 ++
 3 files changed, 18 insertions(+), 30 deletions(-)

diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index 91606023b8c..56de14e3d7f 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -48,12 +48,6 @@ static struct wine_phys_dev *wine_phys_dev_from_handle(VkPhysicalDevice handle)
     return CONTAINING_RECORD(object, struct wine_phys_dev, obj);
 }
 
-static struct wine_device *wine_device_from_handle(VkDevice handle)
-{
-    struct vulkan_device *object = vulkan_device_from_handle(handle);
-    return CONTAINING_RECORD(object, struct wine_device, obj);
-}
-
 static void vulkan_object_init_ptr( struct vulkan_object *obj, UINT64 host_handle, struct vulkan_client_object *client )
 {
     obj->host_handle = host_handle;
@@ -485,11 +479,10 @@ static void wine_vk_free_command_buffers(struct vulkan_device *device,
     }
 }
 
-static void wine_vk_device_init_queues(struct wine_device *object, const VkDeviceQueueCreateInfo *info)
+static void wine_vk_device_init_queues(struct vulkan_device *device, const VkDeviceQueueCreateInfo *info)
 {
-    struct vulkan_queue *queues = object->queues + object->queue_count;
-    struct vulkan_device *device = &object->obj;
-    VkQueue client_queues = device->client.device->queues + object->queue_count;
+    struct vulkan_queue *queues = device->queues + device->queue_count;
+    VkQueue client_queues = device->client.device->queues + device->queue_count;
     VkDeviceQueueInfo2 queue_info;
     UINT i;
 
@@ -528,7 +521,7 @@ static void wine_vk_device_init_queues(struct wine_device *object, const VkDevic
         TRACE("Got device %p queue %p, host_queue %p.\n", device, queue, queue->host.queue);
     }
 
-    object->queue_count += info->queueCount;
+    device->queue_count += info->queueCount;
 }
 
 static char *cc_strdup(struct conversion_context *ctx, const char *s)
@@ -924,7 +917,7 @@ VkResult wine_vkCreateDevice(VkPhysicalDevice client_physical_device, const VkDe
     VkDevice host_device, client_device = client_ptr;
     VkDeviceCreateInfo create_info_host;
     struct conversion_context ctx;
-    struct wine_device *device;
+    struct vulkan_device *device;
     unsigned int queue_count, i;
     VkResult res;
     size_t size;
@@ -987,16 +980,16 @@ VkResult wine_vkCreateDevice(VkPhysicalDevice client_physical_device, const VkDe
         return res;
     }
 
-    vulkan_object_init_ptr(&device->obj.obj, (UINT_PTR)host_device, &client_device->obj);
-    device->obj.physical_device = physical_device;
+    vulkan_object_init_ptr(&device->obj, (UINT_PTR)host_device, &client_device->obj);
+    device->physical_device = physical_device;
 
     /* Just load all function pointers we are aware off. The loader takes care of filtering.
      * We use vkGetDeviceProcAddr as opposed to vkGetInstanceProcAddr for efficiency reasons
      * as functions pass through fewer dispatch tables within the loader.
      */
 #define USE_VK_FUNC(name)                                                                          \
-    device->obj.p_##name = (void *)vk_funcs->p_vkGetDeviceProcAddr(device->obj.host.device, #name);  \
-    if (device->obj.p_##name == NULL) TRACE("Not found '%s'.\n", #name);
+    device->p_##name = (void *)vk_funcs->p_vkGetDeviceProcAddr(device->host.device, #name);  \
+    if (device->p_##name == NULL) TRACE("Not found '%s'.\n", #name);
     ALL_VK_DEVICE_FUNCS
 #undef USE_VK_FUNC
 
@@ -1005,13 +998,13 @@ VkResult wine_vkCreateDevice(VkPhysicalDevice client_physical_device, const VkDe
 
     client_device->quirks = CONTAINING_RECORD(instance, struct wine_instance, obj)->quirks;
 
-    TRACE("Created device %p, host_device %p.\n", device, device->obj.host.device);
+    TRACE("Created device %p, host_device %p.\n", device, device->host.device);
     for (i = 0; i < device->queue_count; i++)
     {
         struct vulkan_queue *queue = device->queues + i;
         vulkan_instance_insert_object(instance, &queue->obj);
     }
-    vulkan_instance_insert_object(instance, &device->obj.obj);
+    vulkan_instance_insert_object(instance, &device->obj);
 
     *ret = client_device;
     return VK_SUCCESS;
@@ -1122,8 +1115,8 @@ VkResult wine_vkCreateInstance(const VkInstanceCreateInfo *create_info,
 
 void wine_vkDestroyDevice(VkDevice client_device, const VkAllocationCallbacks *allocator)
 {
-    struct wine_device *device = wine_device_from_handle(client_device);
-    struct vulkan_instance *instance = device->obj.physical_device->instance;
+    struct vulkan_device *device = vulkan_device_from_handle(client_device);
+    struct vulkan_instance *instance = device->physical_device->instance;
     unsigned int i;
 
     if (allocator)
@@ -1131,10 +1124,10 @@ void wine_vkDestroyDevice(VkDevice client_device, const VkAllocationCallbacks *a
     if (!device)
         return;
 
-    device->obj.p_vkDestroyDevice(device->obj.host.device, NULL /* pAllocator */);
+    device->p_vkDestroyDevice(device->host.device, NULL /* pAllocator */);
     for (i = 0; i < device->queue_count; i++)
         vulkan_instance_remove_object(instance, &device->queues[i].obj);
-    vulkan_instance_remove_object(instance, &device->obj.obj);
+    vulkan_instance_remove_object(instance, &device->obj);
 
     free(device);
 }
@@ -1310,7 +1303,7 @@ void wine_vkFreeCommandBuffers(VkDevice client_device, VkCommandPool command_poo
 
 static VkQueue wine_vk_device_find_queue(VkDevice client_device, const VkDeviceQueueInfo2 *info)
 {
-    struct wine_device *device = wine_device_from_handle(client_device);
+    struct vulkan_device *device = vulkan_device_from_handle(client_device);
     struct vulkan_queue *queue;
     uint32_t i;
 
diff --git a/dlls/winevulkan/vulkan_private.h b/dlls/winevulkan/vulkan_private.h
index 2452dfd7dad..e0ab34026f6 100644
--- a/dlls/winevulkan/vulkan_private.h
+++ b/dlls/winevulkan/vulkan_private.h
@@ -41,13 +41,6 @@ static inline struct wine_cmd_buffer *wine_cmd_buffer_from_handle(VkCommandBuffe
     return (struct wine_cmd_buffer *)(UINT_PTR)client->unix_handle;
 }
 
-struct wine_device
-{
-    struct vulkan_device obj;
-    uint64_t queue_count;
-    struct vulkan_queue *queues;
-};
-
 struct wine_debug_utils_messenger;
 
 struct wine_debug_report_callback
diff --git a/include/wine/vulkan_driver.h b/include/wine/vulkan_driver.h
index f72b2ff3b0c..ffa87ee6187 100644
--- a/include/wine/vulkan_driver.h
+++ b/include/wine/vulkan_driver.h
@@ -109,6 +109,8 @@ struct vulkan_device
 #define USE_VK_FUNC(x) PFN_ ## x p_ ## x;
     ALL_VK_DEVICE_FUNCS
 #undef USE_VK_FUNC
+    uint64_t queue_count;
+    struct vulkan_queue *queues;
 };
 
 static inline struct vulkan_device *vulkan_device_from_handle( VkDevice handle )
-- 
2.49.0

From 5550801f26e20a864b2c31860236f022192fe911 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 6 Dec 2024 17:53:22 +0100
Subject: [PATCH 0585/1564] winevulkan: Cache the VkQueueFamilyProperties with
 the vulkan_device.

---
 dlls/winevulkan/vulkan.c     | 9 ++++++++-
 include/wine/vulkan_driver.h | 1 +
 2 files changed, 9 insertions(+), 1 deletion(-)

diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index 56de14e3d7f..46e25d6f8c9 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -918,7 +918,7 @@ VkResult wine_vkCreateDevice(VkPhysicalDevice client_physical_device, const VkDe
     VkDeviceCreateInfo create_info_host;
     struct conversion_context ctx;
     struct vulkan_device *device;
-    unsigned int queue_count, i;
+    unsigned int queue_count, props_count, i;
     VkResult res;
     size_t size;
     void *ptr;
@@ -943,6 +943,9 @@ VkResult wine_vkCreateDevice(VkPhysicalDevice client_physical_device, const VkDe
 
     size = sizeof(*device);
 
+    instance->p_vkGetPhysicalDeviceQueueFamilyProperties(physical_device->host.physical_device, &props_count, NULL);
+    size += props_count * sizeof(*device->queue_props);
+
     /* We need to cache all queues within the device as each requires wrapping since queues are dispatchable objects. */
     for (queue_count = 0, i = 0; i < create_info->queueCreateInfoCount; i++)
         queue_count += create_info->pQueueCreateInfos[i].queueCount;
@@ -950,6 +953,8 @@ VkResult wine_vkCreateDevice(VkPhysicalDevice client_physical_device, const VkDe
 
     if (!(device = ptr = calloc(1, size))) return VK_ERROR_OUT_OF_HOST_MEMORY;
     ptr = (char *)ptr + sizeof(*device);
+    device->queue_props = ptr;
+    ptr = (char *)ptr + props_count * sizeof(*device->queue_props);
     device->queues = ptr;
     ptr = (char *)ptr + queue_count * sizeof(*device->queues);
 
@@ -993,6 +998,8 @@ VkResult wine_vkCreateDevice(VkPhysicalDevice client_physical_device, const VkDe
     ALL_VK_DEVICE_FUNCS
 #undef USE_VK_FUNC
 
+    instance->p_vkGetPhysicalDeviceQueueFamilyProperties(physical_device->host.physical_device, &props_count, device->queue_props);
+
     for (i = 0; i < create_info_host.queueCreateInfoCount; i++)
         wine_vk_device_init_queues(device, create_info_host.pQueueCreateInfos + i);
 
diff --git a/include/wine/vulkan_driver.h b/include/wine/vulkan_driver.h
index ffa87ee6187..d6af57154a2 100644
--- a/include/wine/vulkan_driver.h
+++ b/include/wine/vulkan_driver.h
@@ -111,6 +111,7 @@ struct vulkan_device
 #undef USE_VK_FUNC
     uint64_t queue_count;
     struct vulkan_queue *queues;
+    VkQueueFamilyProperties *queue_props;
 };
 
 static inline struct vulkan_device *vulkan_device_from_handle( VkDevice handle )
-- 
2.49.0

From b1ca399137a3f005b7cd2266c0e5eaace884a398 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 19 May 2021 13:33:36 -0400
Subject: [PATCH 0872/1564] winevulkan: Implement VK_KHR_external_memory_win32
 for buffers.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/vulkan-1/tests/vulkan.c     |   5 +-
 dlls/winevulkan/make_vulkan      |  51 +++++--
 dlls/winevulkan/vulkan.c         | 249 +++++++++++++++++++++++++++++--
 dlls/winevulkan/vulkan_private.h |   4 +
 4 files changed, 285 insertions(+), 24 deletions(-)

diff --git a/dlls/vulkan-1/tests/vulkan.c b/dlls/vulkan-1/tests/vulkan.c
index 71ad2c4cf34..10403f3bd26 100644
--- a/dlls/vulkan-1/tests/vulkan.c
+++ b/dlls/vulkan-1/tests/vulkan.c
@@ -1154,8 +1154,9 @@ static void import_memory(VkDevice vk_device, VkMemoryAllocateInfo alloc_info, V
         import_handle_info.name = L"wine_test_buffer_export_name";
 
         vr = vkAllocateMemory(vk_device, &alloc_info, NULL, &memory);
-        ok(vr == VK_SUCCESS, "vkAllocateMemory failed, VkResult %d.\n", vr);
-        vkFreeMemory(vk_device, memory, NULL);
+        todo_wine ok(vr == VK_SUCCESS, "vkAllocateMemory failed, VkResult %d.\n", vr);
+        if (vr == VK_SUCCESS)
+            vkFreeMemory(vk_device, memory, NULL);
     }
 }
 
diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index 6606dcab545..77ee1715b72 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -112,7 +112,6 @@ UNSUPPORTED_EXTENSIONS = [
     "VK_EXT_physical_device_drm",
     "VK_GOOGLE_surfaceless_query",
     "VK_KHR_external_fence_fd",
-    "VK_KHR_external_memory_fd",
     "VK_EXT_external_memory_metal",
     "VK_KHR_external_semaphore_fd",
     "VK_SEC_amigo_profiling", # Angle specific.
@@ -129,7 +128,6 @@ UNSUPPORTED_EXTENSIONS = [
 # but not expose to applications (useful for test commits)
 UNEXPOSED_EXTENSIONS = {
     "VK_EXT_map_memory_placed",
-    "VK_KHR_external_memory_win32",
     "VK_EXT_headless_surface",
 }
 
@@ -174,22 +172,27 @@ FUNCTION_OVERRIDES = {
 
     # Instance functions
     "vkCreateDevice" : {"extra_param" : "client_ptr"},
-    "vkGetPhysicalDeviceExternalBufferProperties" : {"dispatch" : False},
+    "vkGetPhysicalDeviceExternalBufferProperties" : {"dispatch" : True},
     "vkGetPhysicalDeviceExternalFenceProperties" : {"dispatch" : False},
     "vkGetPhysicalDeviceExternalSemaphoreProperties" : {"dispatch" : False},
 
     # Device functions
     "vkCreateCommandPool" : {"extra_param" : "client_ptr"},
     "vkGetDeviceProcAddr" : {"dispatch" : False},
+    "vkAllocateMemory" : {"extra_param" : "pAllocateInfo"},
 
     # VK_KHR_external_fence_capabilities
     "vkGetPhysicalDeviceExternalFencePropertiesKHR" : {"dispatch" : False},
 
     # VK_KHR_external_memory_capabilities
-    "vkGetPhysicalDeviceExternalBufferPropertiesKHR" : {"dispatch" : False},
+    "vkGetPhysicalDeviceExternalBufferPropertiesKHR" : {"dispatch" : True},
 
     # VK_KHR_external_semaphore_capabilities
     "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR" : {"dispatch" : False},
+
+    # VK_KHR_external_memory_win32
+    "vkGetMemoryWin32HandleKHR" : {"dispatch" : True},
+    "vkGetMemoryWin32HandlePropertiesKHR" : {"dispatch" : True},
 }
 
 # functions for which a user driver entry must be generated
@@ -243,6 +246,8 @@ MANUAL_UNIX_THUNKS = {
     "vkGetCalibratedTimestampsEXT",
     "vkGetCalibratedTimestampsKHR",
     "vkGetDeviceProcAddr",
+    "vkGetMemoryWin32HandleKHR",
+    "vkGetMemoryWin32HandlePropertiesKHR",
     "vkGetDeviceQueue",
     "vkGetDeviceQueue2",
     "vkGetInstanceProcAddr",
@@ -290,6 +295,10 @@ STRUCT_CHAIN_CONVERSIONS = {
     # Ignore to not confuse host loader.
     "VkDeviceCreateInfo": ["VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO"],
     "VkInstanceCreateInfo": ["VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO"],
+
+    # Structs which require pNext chain modification
+    "VkBufferCreateInfo": [],
+    "VkMemoryAllocateInfo": ["VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR", "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR"],
 }
 
 # Some struct members are conditionally ignored and callers are free to leave them uninitialized.
@@ -808,7 +817,14 @@ class VkFunction(object):
         proto += ", ".join([p.definition() for p in self.params])
 
         if is_thunk and self.extra_param:
-            proto += ", void *" + self.extra_param
+            extra_param_is_new = True
+            for p in self.params:
+                if p.name == self.extra_param:
+                    extra_param_is_new = False
+            if extra_param_is_new:
+                proto += ", void *" + self.extra_param
+            else:
+                proto += ", void *win_" + self.extra_param
 
         proto += ")"
         return proto
@@ -895,7 +911,7 @@ class VkFunction(object):
             if conv:
                 params += ", UlongToPtr({0}{1})".format(params_prefix, self.extra_param)
             else:
-                params += ", {0}{1}".format(params_prefix, self.extra_param)
+                params += ", (void *){0}{1}".format(params_prefix, self.extra_param)
 
         if self.name in MANUAL_UNIX_THUNKS:
             func_prefix = "wine_"
@@ -975,9 +991,12 @@ class VkFunction(object):
         if conv:
             thunk += "    struct\n"
             thunk += "    {\n"
+            extra_param_is_new = True
             for p in self.params:
                 thunk += "        {0};\n".format(p.definition(conv=True, is_member=True))
-            if self.extra_param:
+                if p.name == self.extra_param:
+                    extra_param_is_new = False
+            if self.extra_param and extra_param_is_new:
                 thunk += "        PTR32 {0};\n".format(self.extra_param)
             if self.type != "void":
                 thunk += "        {0} result;\n".format(self.type)
@@ -1568,8 +1587,9 @@ class VkMember(VkVariable):
                     return "{0}{1} = {2} ? {3} : 0;\n".format(output, self.name, self.value(input, conv),
                         handle.unwrap_handle(self.value(input, conv), unwrap))
                 else:
-                    return "{0}{1} = {2};\n".format(output, self.name,
-                        handle.unwrap_handle(self.value(input, conv), unwrap))
+                    input_name = "{0}{1}".format(input, self.name)
+                    return "{0}{1} = {2} ? {3} : VK_NULL_HANDLE;\n".format(output, self.name,
+                        input_name, handle.unwrap_handle(self.value(input, conv), unwrap))
             elif self.is_generic_handle():
                 if direction == Direction.OUTPUT:
                     LOGGER.error("OUTPUT parameter {0}.{1} cannot be unwrapped".format(self.type, self.name))
@@ -2440,9 +2460,12 @@ class StructConversionFunction(object):
             ident = "            "
 
             if self.direction == Direction.INPUT and self.type in STRUCT_CHAIN_CONVERSIONS:
+                has_any_chain_conversions = False
                 for i in STRUCT_CHAIN_CONVERSIONS[self.type]:
                     body += "        case {0}:\n".format(i)
-                body += ident + "break;\n"
+                    has_any_chain_conversions = True
+                if has_any_chain_conversions:
+                    body += ident + "break;\n"
 
             for ext in self.operand.struct_extensions:
                 if not ext.required:
@@ -2452,6 +2475,8 @@ class StructConversionFunction(object):
                     continue
 
                 stype = next(x for x in ext.members if x.name == "sType").values
+                if self.type in STRUCT_CHAIN_CONVERSIONS and stype in STRUCT_CHAIN_CONVERSIONS[self.type]:
+                    continue
                 win_type = ext.name + "32" if self.conv and ext.needs_win32_type() else ext.name
                 if self.direction == Direction.INPUT:
                     in_type = "const " + win_type
@@ -3024,9 +3049,13 @@ class VkGenerator(object):
 
             f.write("struct {0}_params\n".format(vk_func.name))
             f.write("{\n");
+            extra_param_is_new = True
             for p in vk_func.params:
                 f.write("    {0};\n".format(p.definition(is_member=True)))
-            if vk_func.extra_param:
+                if p.name == vk_func.extra_param:
+                    extra_param_is_new = False
+
+            if vk_func.extra_param and extra_param_is_new:
                 f.write("    void *{0};\n".format(vk_func.extra_param))
             if vk_func.type != "void":
                 f.write("    {0} result;\n".format(vk_func.type))
diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index 12a37a10b60..8f92368f0cb 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -23,6 +23,11 @@
 
 #include "config.h"
 #include <time.h>
+#include <unistd.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "wine/server.h"
 
 #include "vulkan_private.h"
 #include "wine/vulkan_driver.h"
@@ -365,6 +370,15 @@ static VkResult wine_vk_physical_device_init(struct wine_phys_dev *object, VkPhy
      */
     for (i = 0; i < num_host_properties; i++)
     {
+        if (!strcmp(host_properties[i].extensionName, "VK_KHR_external_memory_fd"))
+        {
+            TRACE("Substituting VK_KHR_external_memory_fd for VK_KHR_external_memory_win32\n");
+
+            snprintf(host_properties[i].extensionName, sizeof(host_properties[i].extensionName),
+                    VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME);
+            host_properties[i].specVersion = VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION;
+        }
+
         if (wine_vk_device_extension_supported(host_properties[i].extensionName))
         {
             TRACE("Enabling extension '%s' for physical device %p\n", host_properties[i].extensionName, object);
@@ -609,6 +623,12 @@ static VkResult wine_vk_device_convert_create_info(VkPhysicalDevice client_physi
         remove_extensions[remove_count++] = wine_xr_extension_name;
     }
 
+    if (find_extension(extensions, extensions_count, "VK_KHR_external_memory_win32"))
+    {
+        extra_extensions[extra_count++] = "VK_KHR_external_memory_fd";
+        remove_extensions[remove_count++] = "VK_KHR_external_memory_win32";
+    }
+
     if (phys_dev->map_placed_align)
     {
         VkPhysicalDeviceMapMemoryPlacedFeaturesEXT *map_placed_features;
@@ -1482,18 +1502,71 @@ void wine_vkGetPhysicalDeviceExternalFencePropertiesKHR(VkPhysicalDevice client_
     properties->externalFenceFeatures = 0;
 }
 
+static inline void wine_vk_normalize_handle_types_win(VkExternalMemoryHandleTypeFlags *types)
+{
+    *types &=
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT;
+}
+
+static inline void wine_vk_normalize_handle_types_host(VkExternalMemoryHandleTypeFlags *types)
+{
+    *types &=
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT |
+/*      predicated on VK_KHR_external_memory_dma_buf
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT | */
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT;
+}
+
+static void wine_vk_get_physical_device_external_buffer_properties(struct wine_phys_dev *phys_dev,
+        void (*p_vkGetPhysicalDeviceExternalBufferProperties)(VkPhysicalDevice, const VkPhysicalDeviceExternalBufferInfo *, VkExternalBufferProperties *),
+        const VkPhysicalDeviceExternalBufferInfo *buffer_info, VkExternalBufferProperties *properties)
+{
+    VkPhysicalDeviceExternalBufferInfo buffer_info_dup = *buffer_info;
+
+    wine_vk_normalize_handle_types_win(&buffer_info_dup.handleType);
+    if (buffer_info_dup.handleType == VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT)
+        buffer_info_dup.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
+    wine_vk_normalize_handle_types_host(&buffer_info_dup.handleType);
+
+    if (buffer_info->handleType && !buffer_info_dup.handleType)
+    {
+        memset(&properties->externalMemoryProperties, 0, sizeof(properties->externalMemoryProperties));
+        return;
+    }
+
+    p_vkGetPhysicalDeviceExternalBufferProperties(phys_dev->obj.host.physical_device, &buffer_info_dup, properties);
+
+    if (properties->externalMemoryProperties.exportFromImportedHandleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT)
+        properties->externalMemoryProperties.exportFromImportedHandleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+    wine_vk_normalize_handle_types_win(&properties->externalMemoryProperties.exportFromImportedHandleTypes);
+
+    if (properties->externalMemoryProperties.compatibleHandleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT)
+        properties->externalMemoryProperties.compatibleHandleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+    wine_vk_normalize_handle_types_win(&properties->externalMemoryProperties.compatibleHandleTypes);
+}
+
 void wine_vkGetPhysicalDeviceExternalBufferProperties(VkPhysicalDevice client_physical_device,
                                                       const VkPhysicalDeviceExternalBufferInfo *buffer_info,
                                                       VkExternalBufferProperties *properties)
 {
-    memset(&properties->externalMemoryProperties, 0, sizeof(properties->externalMemoryProperties));
+    struct wine_phys_dev *phys_dev = wine_phys_dev_from_handle(client_physical_device);
+    wine_vk_get_physical_device_external_buffer_properties(phys_dev, phys_dev->obj.instance->p_vkGetPhysicalDeviceExternalBufferProperties, buffer_info, properties);
 }
 
 void wine_vkGetPhysicalDeviceExternalBufferPropertiesKHR(VkPhysicalDevice client_physical_device,
                                                          const VkPhysicalDeviceExternalBufferInfo *buffer_info,
                                                          VkExternalBufferProperties *properties)
 {
-    memset(&properties->externalMemoryProperties, 0, sizeof(properties->externalMemoryProperties));
+    struct wine_phys_dev *phys_dev = wine_phys_dev_from_handle(client_physical_device);
+    wine_vk_get_physical_device_external_buffer_properties(phys_dev, phys_dev->obj.instance->p_vkGetPhysicalDeviceExternalBufferPropertiesKHR, buffer_info, properties);
 }
 
 VkResult wine_vkGetPhysicalDeviceImageFormatProperties2(VkPhysicalDevice client_physical_device,
@@ -1764,12 +1837,28 @@ void wine_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(VkPhysicalDevice cli
     properties->externalSemaphoreFeatures = 0;
 }
 
+static HANDLE create_gpu_resource(int fd, LPCWSTR name)
+{
+    HANDLE ret = INVALID_HANDLE_VALUE;
+
+    TRACE("Creating shared vulkan resource fd %d name %s.\n", fd, debugstr_w(name));
+
+    if (name)
+        FIXME("Naming gpu resources not supported.\n");
+
+    wine_server_fd_to_handle(fd, GENERIC_ALL, 0, &ret);
+
+    return ret;
+}
+
 VkResult wine_vkAllocateMemory(VkDevice client_device, const VkMemoryAllocateInfo *alloc_info,
-                               const VkAllocationCallbacks *allocator, VkDeviceMemory *ret)
+                               const VkAllocationCallbacks *allocator, VkDeviceMemory *ret,
+                               void *win_pAllocateInfo)
 {
     struct vulkan_device *device = vulkan_device_from_handle(client_device);
     struct wine_phys_dev *physical_device = CONTAINING_RECORD(device->physical_device, struct wine_phys_dev, obj);
     struct vulkan_instance *instance = device->physical_device->instance;
+    const VkMemoryAllocateInfo *win_alloc_info = win_pAllocateInfo;
     struct wine_device_memory *memory;
     VkMemoryAllocateInfo info = *alloc_info;
     VkImportMemoryHostPointerInfoEXT host_pointer_info;
@@ -1778,12 +1867,74 @@ VkResult wine_vkAllocateMemory(VkDevice client_device, const VkMemoryAllocateInf
     void *mapping = NULL;
     VkResult result;
 
-    /* For host visible memory, we try to use VK_EXT_external_memory_host on wow64
-     * to ensure that mapped pointer is 32-bit. */
+    const VkImportMemoryWin32HandleInfoKHR *handle_import_info;
+    const VkExportMemoryWin32HandleInfoKHR *handle_export_info;
+    VkExportMemoryAllocateInfo *export_info;
+    VkImportMemoryFdInfoKHR fd_import_info;
+    VkMemoryGetFdInfoKHR get_fd_info;
+    int fd;
+
+    if (!(memory = calloc(sizeof(*memory), 1)))
+        return VK_ERROR_OUT_OF_HOST_MEMORY;
+
+    memory->handle = INVALID_HANDLE_VALUE;
+    fd_import_info.fd = -1;
+    fd_import_info.pNext = NULL;
+
+    /* find and process handle import/export info and grab it */
+    handle_import_info = find_next_struct(win_alloc_info, VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR);
+    handle_export_info = find_next_struct(win_alloc_info, VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR);
+    if (handle_export_info && handle_export_info->pAttributes && handle_export_info->pAttributes->lpSecurityDescriptor)
+        FIXME("Support for custom security descriptor not implemented.\n");
+
+    if ((export_info = find_next_struct(alloc_info, VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO)))
+    {
+        memory->handle_types = export_info->handleTypes;
+        if (export_info->handleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT)
+            export_info->handleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
+        wine_vk_normalize_handle_types_host(&export_info->handleTypes);
+    }
+
     mem_flags = physical_device->memory_properties.memoryTypes[alloc_info->memoryTypeIndex].propertyFlags;
-    if (physical_device->external_memory_align && (mem_flags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) &&
+
+    /* Vulkan consumes imported FDs, but not imported HANDLEs */
+    if (handle_import_info)
+    {
+        fd_import_info.sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR;
+        fd_import_info.pNext = info.pNext;
+        fd_import_info.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
+        info.pNext = &fd_import_info;
+
+        switch (handle_import_info->handleType)
+        {
+            case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT:
+                if (handle_import_info->handle)
+                    NtDuplicateObject( NtCurrentProcess(), handle_import_info->handle, NtCurrentProcess(), &memory->handle, 0, 0, DUPLICATE_SAME_ACCESS );
+                else if (handle_import_info->name)
+                    FIXME("Importing device memory by resource name not supported.\n");
+                break;
+            default:
+                WARN("Invalid handle type %08x passed in.\n", handle_import_info->handleType);
+                result = VK_ERROR_INVALID_EXTERNAL_HANDLE;
+                goto done;
+        }
+
+        if (memory->handle != INVALID_HANDLE_VALUE)
+            wine_server_handle_to_fd(memory->handle, FILE_READ_DATA, &fd_import_info.fd, NULL);
+
+        if (fd_import_info.fd == -1)
+        {
+            TRACE("Couldn't access resource handle or name. type=%08x handle=%p name=%s\n", handle_import_info->handleType, handle_import_info->handle,
+                    handle_import_info->name ? debugstr_w(handle_import_info->name) : "");
+            result = VK_ERROR_INVALID_EXTERNAL_HANDLE;
+            goto done;
+        }
+    }
+    else if (physical_device->external_memory_align && (mem_flags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) &&
         !find_next_struct(alloc_info->pNext, VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT))
     {
+        /* For host visible memory, we try to use VK_EXT_external_memory_host on wow64
+         * to ensure that mapped pointer is 32-bit. */
         VkMemoryHostPointerPropertiesEXT props =
         {
             .sType = VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT,
@@ -1799,6 +1950,7 @@ VkResult wine_vkAllocateMemory(VkDevice client_device, const VkMemoryAllocateInf
                                     MEM_COMMIT, PAGE_READWRITE))
         {
             ERR("NtAllocateVirtualMemory failed\n");
+            free(memory);
             return VK_ERROR_OUT_OF_HOST_MEMORY;
         }
 
@@ -1807,6 +1959,7 @@ VkResult wine_vkAllocateMemory(VkDevice client_device, const VkMemoryAllocateInf
         if (result != VK_SUCCESS)
         {
             ERR("vkGetMemoryHostPointerPropertiesEXT failed: %d\n", result);
+            free(memory);
             return result;
         }
 
@@ -1846,12 +1999,39 @@ VkResult wine_vkAllocateMemory(VkDevice client_device, const VkMemoryAllocateInf
         }
     }
 
-    if (!(memory = malloc(sizeof(*memory))))
-        return VK_ERROR_OUT_OF_HOST_MEMORY;
-
     result = device->p_vkAllocateMemory(device->host.device, &info, NULL, &host_device_memory);
+    if (result == VK_SUCCESS && memory->handle == INVALID_HANDLE_VALUE && export_info && export_info->handleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT)
+    {
+        get_fd_info.sType = VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR;
+        get_fd_info.pNext = NULL;
+        get_fd_info.memory = host_device_memory;
+        get_fd_info.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
+
+        if (device->p_vkGetMemoryFdKHR(device->host.device, &get_fd_info, &fd) == VK_SUCCESS)
+        {
+            memory->handle = create_gpu_resource(fd, handle_export_info ? handle_export_info->name : NULL);
+            memory->access = handle_export_info ? handle_export_info->dwAccess : GENERIC_ALL;
+            if (handle_export_info && handle_export_info->pAttributes)
+                memory->inherit = handle_export_info->pAttributes->bInheritHandle;
+            else
+                memory->inherit = FALSE;
+            close(fd);
+        }
+
+        if (memory->handle == INVALID_HANDLE_VALUE)
+        {
+            device->p_vkFreeMemory(device->host.device, host_device_memory, NULL);
+            result = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto done;
+        }
+    }
+done:
     if (result != VK_SUCCESS)
     {
+        if (fd_import_info.fd != -1)
+            close(fd_import_info.fd);
+        if (memory->handle != INVALID_HANDLE_VALUE)
+            NtClose(memory->handle);
         free(memory);
         return result;
     }
@@ -1896,6 +2076,9 @@ void wine_vkFreeMemory(VkDevice client_device, VkDeviceMemory memory_handle, con
         NtFreeVirtualMemory(GetCurrentProcess(), &memory->vm_map, &alloc_size, MEM_RELEASE);
     }
 
+    if (memory->handle != INVALID_HANDLE_VALUE)
+        NtClose(memory->handle);
+
     free(memory);
 }
 
@@ -2040,10 +2223,16 @@ VkResult wine_vkCreateBuffer(VkDevice client_device, const VkBufferCreateInfo *c
 {
     struct vulkan_device *device = vulkan_device_from_handle(client_device);
     struct wine_phys_dev *physical_device = CONTAINING_RECORD(device->physical_device, struct wine_phys_dev, obj);
-    VkExternalMemoryBufferCreateInfo external_memory_info;
+    VkExternalMemoryBufferCreateInfo external_memory_info, *ext_info;
     VkBufferCreateInfo info = *create_info;
 
-    if (physical_device->external_memory_align &&
+    if ((ext_info = find_next_struct(create_info, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO)))
+    {
+        if (ext_info->handleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT)
+            ext_info->handleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
+        wine_vk_normalize_handle_types_host(&ext_info->handleTypes);
+    }
+    else if (physical_device->external_memory_align &&
         !find_next_struct(info.pNext, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO))
     {
         external_memory_info.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
@@ -2257,6 +2446,8 @@ NTSTATUS vk_is_available_device_function(void *arg)
 {
     struct is_available_device_function_params *params = arg;
     struct vulkan_device *device = vulkan_device_from_handle(params->device);
+    if (!strcmp(params->name, "vkGetMemoryWin32HandleKHR") || !strcmp(params->name, "vkGetMemoryWin32HandlePropertiesKHR"))
+        params->name = "vkGetMemoryFdKHR";
     return !!vk_funcs->p_vkGetDeviceProcAddr(device->host.device, params->name);
 }
 
@@ -2287,5 +2478,41 @@ NTSTATUS vk_is_available_device_function32(void *arg)
         UINT32 name;
     } *params = arg;
     struct vulkan_device *device = vulkan_device_from_handle(UlongToPtr(params->device));
+    char *name = UlongToPtr(params->name);
+    if (!strcmp(name, "vkGetMemoryWin32HandleKHR") || !strcmp(name, "vkGetMemoryWin32HandlePropertiesKHR"))
+        return !!vk_funcs->p_vkGetDeviceProcAddr(device->host.device, "vkGetMemoryFdKHR");
     return !!vk_funcs->p_vkGetDeviceProcAddr(device->host.device, UlongToPtr(params->name));
 }
+
+VkResult wine_vkGetMemoryWin32HandleKHR(VkDevice device, const VkMemoryGetWin32HandleInfoKHR *handle_info, HANDLE *handle)
+{
+    struct wine_device_memory *dev_mem = wine_device_memory_from_handle(handle_info->memory);
+    const VkBaseInStructure *chain;
+
+    TRACE("%p, %p %p\n", device, handle_info, handle);
+
+    if (!(dev_mem->handle_types & handle_info->handleType))
+        return VK_ERROR_UNKNOWN;
+
+    if ((chain = handle_info->pNext))
+        FIXME("Ignoring a linked structure of type %u.\n", chain->sType);
+
+    switch(handle_info->handleType)
+    {
+        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT:
+            return !NtDuplicateObject( NtCurrentProcess(), dev_mem->handle, NtCurrentProcess(), handle, dev_mem->access, dev_mem->inherit ? OBJ_INHERIT : 0, 0) ?
+                VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY;
+        default:
+            FIXME("Unable to get handle of type %x, did the application ignore the capabilities?\n", handle_info->handleType);
+            return VK_ERROR_UNKNOWN;
+    }
+}
+
+VkResult wine_vkGetMemoryWin32HandlePropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits type, HANDLE handle, VkMemoryWin32HandlePropertiesKHR *properties)
+{
+    TRACE("%p %u %p %p\n", device, type, handle, properties);
+
+    /* VUID-vkGetMemoryWin32HandlePropertiesKHR-handleType-00666
+       handleType must not be one of the handle types defined as opaque */
+    return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+}
diff --git a/dlls/winevulkan/vulkan_private.h b/dlls/winevulkan/vulkan_private.h
index e0ab34026f6..87bc1ae74b4 100644
--- a/dlls/winevulkan/vulkan_private.h
+++ b/dlls/winevulkan/vulkan_private.h
@@ -105,6 +105,10 @@ struct wine_device_memory
     VULKAN_OBJECT_HEADER( VkDeviceMemory, device_memory );
     VkDeviceSize size;
     void *vm_map;
+    VkExternalMemoryHandleTypeFlagBits handle_types;
+    BOOL inherit;
+    DWORD access;
+    HANDLE handle;
 };
 
 static inline struct wine_device_memory *wine_device_memory_from_handle(VkDeviceMemory handle)
-- 
2.49.0

From f888674416866d4112ad9d6d9e6435b79a93440b Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Thu, 22 Dec 2022 11:09:20 -0600
Subject: [PATCH 0873/1564] winevulkan: Factor out
 wine_vk_get_physical_device_image_format_properties_2().

---
 dlls/winevulkan/vulkan.c | 39 +++++++++++++++++++--------------------
 1 file changed, 19 insertions(+), 20 deletions(-)

diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index 8f92368f0cb..dc00ec38f3b 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -1569,16 +1569,14 @@ void wine_vkGetPhysicalDeviceExternalBufferPropertiesKHR(VkPhysicalDevice client
     wine_vk_get_physical_device_external_buffer_properties(phys_dev, phys_dev->obj.instance->p_vkGetPhysicalDeviceExternalBufferPropertiesKHR, buffer_info, properties);
 }
 
-VkResult wine_vkGetPhysicalDeviceImageFormatProperties2(VkPhysicalDevice client_physical_device,
-                                                        const VkPhysicalDeviceImageFormatInfo2 *format_info,
-                                                        VkImageFormatProperties2 *properties)
+static VkResult wine_vk_get_physical_device_image_format_properties_2(struct vulkan_physical_device *physical_device,
+        VkResult (*p_vkGetPhysicalDeviceImageFormatProperties2)(VkPhysicalDevice, const VkPhysicalDeviceImageFormatInfo2 *, VkImageFormatProperties2 *),
+        const VkPhysicalDeviceImageFormatInfo2 *format_info, VkImageFormatProperties2 *properties)
 {
-    struct vulkan_physical_device *physical_device = vulkan_physical_device_from_handle(client_physical_device);
-    struct vulkan_instance *instance = physical_device->instance;
     VkExternalImageFormatProperties *external_image_properties;
     VkResult res;
 
-    res = instance->p_vkGetPhysicalDeviceImageFormatProperties2(physical_device->host.physical_device, format_info, properties);
+    res = p_vkGetPhysicalDeviceImageFormatProperties2(physical_device->host.physical_device, format_info, properties);
 
     if ((external_image_properties = find_next_struct(properties,
                                                       VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES)))
@@ -1592,27 +1590,28 @@ VkResult wine_vkGetPhysicalDeviceImageFormatProperties2(VkPhysicalDevice client_
     return res;
 }
 
+VkResult wine_vkGetPhysicalDeviceImageFormatProperties2(VkPhysicalDevice client_physical_device,
+                                                        const VkPhysicalDeviceImageFormatInfo2 *format_info,
+                                                        VkImageFormatProperties2 *properties)
+{
+    struct vulkan_physical_device *physical_device = vulkan_physical_device_from_handle(client_physical_device);
+    struct vulkan_instance *instance = physical_device->instance;
+
+    return wine_vk_get_physical_device_image_format_properties_2(physical_device,
+            instance->p_vkGetPhysicalDeviceImageFormatProperties2,
+            format_info, properties);
+}
+
 VkResult wine_vkGetPhysicalDeviceImageFormatProperties2KHR(VkPhysicalDevice client_physical_device,
                                                            const VkPhysicalDeviceImageFormatInfo2 *format_info,
                                                            VkImageFormatProperties2 *properties)
 {
     struct vulkan_physical_device *physical_device = vulkan_physical_device_from_handle(client_physical_device);
     struct vulkan_instance *instance = physical_device->instance;
-    VkExternalImageFormatProperties *external_image_properties;
-    VkResult res;
 
-    res = instance->p_vkGetPhysicalDeviceImageFormatProperties2KHR(physical_device->host.physical_device, format_info, properties);
-
-    if ((external_image_properties = find_next_struct(properties,
-                                                      VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES)))
-    {
-        VkExternalMemoryProperties *p = &external_image_properties->externalMemoryProperties;
-        p->externalMemoryFeatures = 0;
-        p->exportFromImportedHandleTypes = 0;
-        p->compatibleHandleTypes = 0;
-    }
-
-    return res;
+    return wine_vk_get_physical_device_image_format_properties_2(physical_device,
+            instance->p_vkGetPhysicalDeviceImageFormatProperties2KHR,
+            format_info, properties);
 }
 
 /* From ntdll/unix/sync.c */
-- 
2.49.0

From caf940d85efb6c4c993d4e3cf4e34c8c0f113cde Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 19 May 2021 13:38:12 -0400
Subject: [PATCH 0874/1564] winevulkan: Implement VK_KHR_external_memory_win32
 for images.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winevulkan/make_vulkan |  2 ++
 dlls/winevulkan/vulkan.c    | 39 +++++++++++++++++++++++++++++++------
 2 files changed, 35 insertions(+), 6 deletions(-)

diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index 77ee1715b72..c6d6f7581be 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -298,7 +298,9 @@ STRUCT_CHAIN_CONVERSIONS = {
 
     # Structs which require pNext chain modification
     "VkBufferCreateInfo": [],
+    "VkImageCreateInfo": [],
     "VkMemoryAllocateInfo": ["VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR", "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR"],
+    "VkPhysicalDeviceImageFormatInfo2": [],
 }
 
 # Some struct members are conditionally ignored and callers are free to leave them uninitialized.
diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index dc00ec38f3b..d01d9a3f85b 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -1573,18 +1573,40 @@ static VkResult wine_vk_get_physical_device_image_format_properties_2(struct vul
         VkResult (*p_vkGetPhysicalDeviceImageFormatProperties2)(VkPhysicalDevice, const VkPhysicalDeviceImageFormatInfo2 *, VkImageFormatProperties2 *),
         const VkPhysicalDeviceImageFormatInfo2 *format_info, VkImageFormatProperties2 *properties)
 {
+    VkPhysicalDeviceExternalImageFormatInfo *external_image_info;
     VkExternalImageFormatProperties *external_image_properties;
     VkResult res;
 
+    if ((external_image_info = find_next_struct(format_info, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO))
+            && external_image_info->handleType)
+    {
+        wine_vk_normalize_handle_types_win(&external_image_info->handleType);
+
+        if (external_image_info->handleType == VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT)
+            external_image_info->handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
+
+        wine_vk_normalize_handle_types_host(&external_image_info->handleType);
+        if (!external_image_info->handleType)
+        {
+            FIXME("Unsupported handle type %#x.\n", external_image_info->handleType);
+            return VK_ERROR_FORMAT_NOT_SUPPORTED;
+        }
+    }
+
     res = p_vkGetPhysicalDeviceImageFormatProperties2(physical_device->host.physical_device, format_info, properties);
 
     if ((external_image_properties = find_next_struct(properties,
                                                       VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES)))
     {
         VkExternalMemoryProperties *p = &external_image_properties->externalMemoryProperties;
-        p->externalMemoryFeatures = 0;
-        p->exportFromImportedHandleTypes = 0;
-        p->compatibleHandleTypes = 0;
+
+        if (p->exportFromImportedHandleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT)
+            p->exportFromImportedHandleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+        wine_vk_normalize_handle_types_win(&p->exportFromImportedHandleTypes);
+
+        if (p->compatibleHandleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT)
+            p->compatibleHandleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+        wine_vk_normalize_handle_types_win(&p->compatibleHandleTypes);
     }
 
     return res;
@@ -2248,11 +2270,16 @@ VkResult wine_vkCreateImage(VkDevice client_device, const VkImageCreateInfo *cre
 {
     struct vulkan_device *device = vulkan_device_from_handle(client_device);
     struct wine_phys_dev *physical_device = CONTAINING_RECORD(device->physical_device, struct wine_phys_dev, obj);
-    VkExternalMemoryImageCreateInfo external_memory_info;
+    VkExternalMemoryImageCreateInfo external_memory_info, *update_info;
     VkImageCreateInfo info = *create_info;
 
-    if (physical_device->external_memory_align &&
-        !find_next_struct(info.pNext, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO))
+    if ((update_info = find_next_struct(info.pNext, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO)))
+    {
+        if (update_info->handleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR)
+            update_info->handleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR;
+        wine_vk_normalize_handle_types_host(&update_info->handleTypes);
+    }
+    else if (physical_device->external_memory_align)
     {
         external_memory_info.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
         external_memory_info.pNext = info.pNext;
-- 
2.49.0

From 732ae6cd9f9db09af7f0dad1ee37dc7f400991c7 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 13 Oct 2021 13:16:44 +0200
Subject: [PATCH 0875/1564] winevulkan: Implement support for KMT handles and
 named objects.

---
 configure.ac                                |   1 +
 dlls/sharedgpures.sys/Makefile.in           |   6 +
 dlls/sharedgpures.sys/shared_resource.c     | 347 ++++++++++++++++++++
 dlls/sharedgpures.sys/sharedgpures.sys.spec |   1 +
 dlls/winevulkan/vulkan.c                    | 190 ++++++++++-
 dlls/winevulkan/vulkan_private.h            |   7 +
 include/ddk/wdm.h                           |   1 +
 loader/wine.inf.in                          |  13 +
 8 files changed, 551 insertions(+), 15 deletions(-)
 create mode 100644 dlls/sharedgpures.sys/Makefile.in
 create mode 100644 dlls/sharedgpures.sys/shared_resource.c
 create mode 100644 dlls/sharedgpures.sys/sharedgpures.sys.spec

diff --git a/configure.ac b/configure.ac
index 15e0914ca5b..0f61a2ce5d0 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3127,6 +3127,7 @@ WINE_CONFIG_MAKEFILE(dlls/setupapi/tests)
 WINE_CONFIG_MAKEFILE(dlls/setupx.dll16,enable_win16)
 WINE_CONFIG_MAKEFILE(dlls/sfc)
 WINE_CONFIG_MAKEFILE(dlls/sfc_os)
+WINE_CONFIG_MAKEFILE(dlls/sharedgpures.sys)
 WINE_CONFIG_MAKEFILE(dlls/shcore)
 WINE_CONFIG_MAKEFILE(dlls/shcore/tests)
 WINE_CONFIG_MAKEFILE(dlls/shdoclc)
diff --git a/dlls/sharedgpures.sys/Makefile.in b/dlls/sharedgpures.sys/Makefile.in
new file mode 100644
index 00000000000..9aca43fb45e
--- /dev/null
+++ b/dlls/sharedgpures.sys/Makefile.in
@@ -0,0 +1,6 @@
+MODULE    = sharedgpures.sys
+IMPORTS   = ntoskrnl
+EXTRADLLFLAGS = -Wl,--subsystem,native
+
+SOURCES = \
+	shared_resource.c
diff --git a/dlls/sharedgpures.sys/shared_resource.c b/dlls/sharedgpures.sys/shared_resource.c
new file mode 100644
index 00000000000..e1330888b04
--- /dev/null
+++ b/dlls/sharedgpures.sys/shared_resource.c
@@ -0,0 +1,347 @@
+#include <stdarg.h>
+
+#define NONAMELESSUNION
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winbase.h"
+#include "winternl.h"
+#include "winioctl.h"
+
+#include "ddk/wdm.h"
+
+#include "wine/debug.h"
+#include "wine/list.h"
+#include "wine/server.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(sharedgpures);
+
+static DRIVER_OBJECT *sharedgpures_driver;
+
+struct shared_resource
+{
+    unsigned int ref_count;
+    void *unix_resource;
+    WCHAR *name;
+};
+
+static struct shared_resource *resource_pool;
+static unsigned int resource_pool_size;
+
+/* TODO: If/when ntoskrnl gets support for referencing user handles directly, remove this function */
+static void *reference_client_handle(obj_handle_t handle)
+{
+    HANDLE client_process, kernel_handle;
+    OBJECT_ATTRIBUTES attr;
+    void *object = NULL;
+    CLIENT_ID cid;
+
+    attr.Length = sizeof(OBJECT_ATTRIBUTES);
+    attr.RootDirectory = 0;
+    attr.Attributes = OBJ_KERNEL_HANDLE;
+    attr.ObjectName = NULL;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    cid.UniqueProcess = PsGetCurrentProcessId();
+    cid.UniqueThread = 0;
+
+    if (NtOpenProcess(&client_process, PROCESS_ALL_ACCESS, &attr, &cid) != STATUS_SUCCESS)
+        return NULL;
+
+    if (NtDuplicateObject(client_process, wine_server_ptr_handle(handle), NtCurrentProcess(), &kernel_handle,
+                               0, OBJ_KERNEL_HANDLE, DUPLICATE_SAME_ACCESS) != STATUS_SUCCESS)
+    {
+        NtClose(client_process);
+        return NULL;
+    }
+
+    ObReferenceObjectByHandle(kernel_handle, 0, NULL, KernelMode, &object, NULL);
+
+    NtClose(client_process);
+    NtClose(kernel_handle);
+
+    return object;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_CREATE           CTL_CODE(FILE_DEVICE_VIDEO, 0, METHOD_BUFFERED, FILE_WRITE_ACCESS)
+
+struct shared_resource_create
+{
+    obj_handle_t unix_handle;
+    WCHAR name[1];
+};
+
+static NTSTATUS shared_resource_create(struct shared_resource **res, void *buff, SIZE_T insize, IO_STATUS_BLOCK *iosb)
+{
+    struct shared_resource_create *input = buff;
+    void *unix_resource;
+    unsigned int i;
+    LPWSTR name;
+
+    if (insize < sizeof(*input))
+        return STATUS_INFO_LENGTH_MISMATCH;
+
+    if (input->name[ ((insize - offsetof(struct shared_resource_create, name)) / sizeof(WCHAR)) - 1 ])
+        return STATUS_INVALID_PARAMETER;
+
+    if (!(unix_resource = reference_client_handle(input->unix_handle)))
+        return STATUS_INVALID_HANDLE;
+
+    if (insize == sizeof(*input))
+        name = NULL;
+    else
+    {
+        name = ExAllocatePoolWithTag(NonPagedPool, insize - offsetof(struct shared_resource_create, name), 0);
+        wcscpy(name, &input->name[0]);
+    }
+
+    for (i = 0; i < resource_pool_size; i++)
+        if (!resource_pool[i].ref_count)
+            break;
+
+    if (i == resource_pool_size)
+    {
+        struct shared_resource *expanded_pool =
+            ExAllocatePoolWithTag(NonPagedPool, sizeof(struct shared_resource) * (resource_pool_size + 1024), 0);
+
+        if (resource_pool)
+        {
+            memcpy(expanded_pool, resource_pool, resource_pool_size * sizeof(struct shared_resource));
+            ExFreePoolWithTag(resource_pool, 0);
+        }
+
+        memset(&expanded_pool[resource_pool_size], 0, 1024 * sizeof (struct shared_resource));
+
+        resource_pool = expanded_pool;
+        resource_pool_size += 1024;
+    }
+
+    *res = &resource_pool[i];
+    (*res)->ref_count = 1;
+    (*res)->unix_resource = unix_resource;
+    (*res)->name = name;
+
+    iosb->Information = 0;
+    return STATUS_SUCCESS;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_OPEN             CTL_CODE(FILE_DEVICE_VIDEO, 1, METHOD_BUFFERED, FILE_WRITE_ACCESS)
+
+struct shared_resource_open
+{
+    obj_handle_t kmt_handle;
+    WCHAR name[1];
+};
+
+static unsigned int kmt_to_index(obj_handle_t kmt)
+{
+    if (!(kmt & 0x40000000) || (kmt - 2) % 4)
+        return -1;
+    return (((unsigned int) kmt & ~0x40000000) - 2) / 4;
+}
+
+static NTSTATUS shared_resource_open(struct shared_resource **res, void *buff, SIZE_T insize, IO_STATUS_BLOCK *iosb)
+{
+    struct shared_resource_open *input = buff;
+    unsigned int i;
+
+    if (insize < sizeof(*input))
+        return STATUS_INFO_LENGTH_MISMATCH;
+
+    if (input->kmt_handle)
+    {
+        if (kmt_to_index(input->kmt_handle) >= resource_pool_size)
+            return STATUS_INVALID_HANDLE;
+
+        *res = &resource_pool[kmt_to_index(input->kmt_handle)];
+    }
+    else
+    {
+        if (input->name[ ((insize - offsetof(struct shared_resource_open, name)) / sizeof(WCHAR)) - 1 ])
+            return STATUS_INVALID_PARAMETER;
+
+        /* name lookup */
+        for (i = 0; i < resource_pool_size; i++)
+        {
+            if (resource_pool[i].name && !wcscmp(resource_pool[i].name, input->name))
+            {
+                *res = &resource_pool[i];
+                break;
+            }
+        }
+        if (i == resource_pool_size)
+            return STATUS_OBJECT_NAME_NOT_FOUND;
+    }
+
+    (*res)->ref_count++;
+    iosb->Information = 0;
+    return STATUS_SUCCESS;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_GETKMT           CTL_CODE(FILE_DEVICE_VIDEO, 2, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+static obj_handle_t index_to_kmt(unsigned int idx)
+{
+    return (idx * 4 + 2) | 0x40000000;
+}
+
+static NTSTATUS shared_resource_getkmt(struct shared_resource *res, void *buff, SIZE_T outsize, IO_STATUS_BLOCK *iosb)
+{
+    if (outsize < sizeof(unsigned int))
+        return STATUS_INFO_LENGTH_MISMATCH;
+
+    *((unsigned int *)buff) = index_to_kmt(res - resource_pool);
+
+    iosb->Information = sizeof(unsigned int);
+    return STATUS_SUCCESS;
+}
+
+/* TODO: If/when ntoskrnl gets support for opening user handles directly, remove this function */
+static obj_handle_t open_client_handle(void *object)
+{
+    HANDLE client_process, kernel_handle, handle = NULL;
+    OBJECT_ATTRIBUTES attr;
+    CLIENT_ID cid;
+
+    attr.Length = sizeof(OBJECT_ATTRIBUTES);
+    attr.RootDirectory = 0;
+    attr.Attributes = OBJ_KERNEL_HANDLE;
+    attr.ObjectName = NULL;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    cid.UniqueProcess = PsGetCurrentProcessId();
+    cid.UniqueThread = 0;
+
+    if (NtOpenProcess(&client_process, PROCESS_ALL_ACCESS, &attr, &cid) != STATUS_SUCCESS)
+        return 0;
+
+    if (ObOpenObjectByPointer(object, 0, NULL, GENERIC_ALL, NULL, KernelMode, &kernel_handle) != STATUS_SUCCESS)
+    {
+        NtClose(client_process);
+        return 0;
+    }
+
+    NtDuplicateObject(NtCurrentProcess(), kernel_handle, client_process, &handle,
+                        0, 0, DUPLICATE_SAME_ACCESS);
+
+    NtClose(client_process);
+    NtClose(kernel_handle);
+
+    return wine_server_obj_handle(handle);
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_GET_UNIX_RESOURCE           CTL_CODE(FILE_DEVICE_VIDEO, 3, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+static NTSTATUS shared_resource_get_unix_resource(struct shared_resource *res, void *buff, SIZE_T outsize, IO_STATUS_BLOCK *iosb)
+{
+    if (outsize < sizeof(obj_handle_t))
+        return STATUS_INFO_LENGTH_MISMATCH;
+
+    *((obj_handle_t *)buff) = open_client_handle(res->unix_resource);
+
+    iosb->Information = sizeof(obj_handle_t);
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS WINAPI dispatch_create(DEVICE_OBJECT *device, IRP *irp)
+{
+    irp->IoStatus.u.Status = STATUS_SUCCESS;
+    IoCompleteRequest(irp, IO_NO_INCREMENT);
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS WINAPI dispatch_close(DEVICE_OBJECT *device, IRP *irp)
+{
+    IO_STACK_LOCATION *stack = IoGetCurrentIrpStackLocation(irp);
+    struct shared_resource *res = stack->FileObject->FsContext;
+
+    TRACE("Freeing shared resouce %p.\n", res);
+
+    if (res)
+    {
+        res->ref_count--;
+        if (!res->ref_count && res->unix_resource)
+        {
+            /* TODO: see if its possible to destroy the object here (unlink?) */
+            ObDereferenceObject(res->unix_resource);
+            res->unix_resource = NULL;
+        }
+    }
+
+    irp->IoStatus.u.Status = STATUS_SUCCESS;
+    IoCompleteRequest(irp, IO_NO_INCREMENT);
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS WINAPI dispatch_ioctl(DEVICE_OBJECT *device, IRP *irp)
+{
+    IO_STACK_LOCATION *stack = IoGetCurrentIrpStackLocation( irp );
+    struct shared_resource **res = (struct shared_resource **) &stack->FileObject->FsContext;
+    NTSTATUS status;
+
+    TRACE( "ioctl %#lx insize %lu outsize %lu\n",
+           stack->Parameters.DeviceIoControl.IoControlCode,
+           stack->Parameters.DeviceIoControl.InputBufferLength,
+           stack->Parameters.DeviceIoControl.OutputBufferLength );
+
+    switch (stack->Parameters.DeviceIoControl.IoControlCode)
+    {
+        case IOCTL_SHARED_GPU_RESOURCE_CREATE:
+            status = shared_resource_create( res,
+                                      irp->AssociatedIrp.SystemBuffer,
+                                      stack->Parameters.DeviceIoControl.InputBufferLength,
+                                      &irp->IoStatus );
+            break;
+        case IOCTL_SHARED_GPU_RESOURCE_OPEN:
+            status = shared_resource_open( res,
+                                      irp->AssociatedIrp.SystemBuffer,
+                                      stack->Parameters.DeviceIoControl.InputBufferLength,
+                                      &irp->IoStatus );
+            break;
+        case IOCTL_SHARED_GPU_RESOURCE_GETKMT:
+            status = shared_resource_getkmt( *res,
+                                      irp->AssociatedIrp.SystemBuffer,
+                                      stack->Parameters.DeviceIoControl.OutputBufferLength,
+                                      &irp->IoStatus );
+            break;
+        case IOCTL_SHARED_GPU_RESOURCE_GET_UNIX_RESOURCE:
+            status = shared_resource_get_unix_resource( *res,
+                                      irp->AssociatedIrp.SystemBuffer,
+                                      stack->Parameters.DeviceIoControl.OutputBufferLength,
+                                      &irp->IoStatus );
+            break;
+    default:
+        FIXME( "ioctl %#lx not supported\n", stack->Parameters.DeviceIoControl.IoControlCode );
+        status = STATUS_NOT_SUPPORTED;
+        break;
+    }
+
+    irp->IoStatus.u.Status = status;
+    IoCompleteRequest( irp, IO_NO_INCREMENT );
+    return status;
+}
+
+NTSTATUS WINAPI DriverEntry( DRIVER_OBJECT *driver, UNICODE_STRING *path )
+{
+    static const WCHAR device_nameW[] = L"\\Device\\SharedGpuResource";
+    static const WCHAR link_nameW[] = L"\\??\\SharedGpuResource";
+    UNICODE_STRING device_name, link_name;
+    DEVICE_OBJECT *device;
+    NTSTATUS status;
+
+    sharedgpures_driver = driver;
+
+    driver->MajorFunction[IRP_MJ_CREATE] = dispatch_create;
+    driver->MajorFunction[IRP_MJ_CLOSE] = dispatch_close;
+    driver->MajorFunction[IRP_MJ_DEVICE_CONTROL] = dispatch_ioctl;
+
+    RtlInitUnicodeString(&device_name, device_nameW);
+    RtlInitUnicodeString(&link_name, link_nameW);
+
+    if ((status = IoCreateDevice(driver, 0, &device_name, 0, 0, FALSE, &device)))
+        return status;
+
+    return IoCreateSymbolicLink(&link_name, &device_name);
+}
diff --git a/dlls/sharedgpures.sys/sharedgpures.sys.spec b/dlls/sharedgpures.sys/sharedgpures.sys.spec
new file mode 100644
index 00000000000..76421d7e35b
--- /dev/null
+++ b/dlls/sharedgpures.sys/sharedgpures.sys.spec
@@ -0,0 +1 @@
+# nothing to export
diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index d01d9a3f85b..0ec6f0f2ec4 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -27,6 +27,9 @@
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
+#include "windef.h"
+#include "winnt.h"
+#include "winioctl.h"
 #include "wine/server.h"
 
 #include "vulkan_private.h"
@@ -1525,6 +1528,10 @@ static inline void wine_vk_normalize_handle_types_host(VkExternalMemoryHandleTyp
         VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT;
 }
 
+static const VkExternalMemoryHandleTypeFlagBits wine_vk_handle_over_fd_types =
+                VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT |
+                VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT;
+
 static void wine_vk_get_physical_device_external_buffer_properties(struct wine_phys_dev *phys_dev,
         void (*p_vkGetPhysicalDeviceExternalBufferProperties)(VkPhysicalDevice, const VkPhysicalDeviceExternalBufferInfo *, VkExternalBufferProperties *),
         const VkPhysicalDeviceExternalBufferInfo *buffer_info, VkExternalBufferProperties *properties)
@@ -1532,7 +1539,7 @@ static void wine_vk_get_physical_device_external_buffer_properties(struct wine_p
     VkPhysicalDeviceExternalBufferInfo buffer_info_dup = *buffer_info;
 
     wine_vk_normalize_handle_types_win(&buffer_info_dup.handleType);
-    if (buffer_info_dup.handleType == VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT)
+    if (buffer_info_dup.handleType & wine_vk_handle_over_fd_types)
         buffer_info_dup.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
     wine_vk_normalize_handle_types_host(&buffer_info_dup.handleType);
 
@@ -1545,11 +1552,11 @@ static void wine_vk_get_physical_device_external_buffer_properties(struct wine_p
     p_vkGetPhysicalDeviceExternalBufferProperties(phys_dev->obj.host.physical_device, &buffer_info_dup, properties);
 
     if (properties->externalMemoryProperties.exportFromImportedHandleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT)
-        properties->externalMemoryProperties.exportFromImportedHandleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+        properties->externalMemoryProperties.exportFromImportedHandleTypes |= wine_vk_handle_over_fd_types;
     wine_vk_normalize_handle_types_win(&properties->externalMemoryProperties.exportFromImportedHandleTypes);
 
     if (properties->externalMemoryProperties.compatibleHandleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT)
-        properties->externalMemoryProperties.compatibleHandleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+        properties->externalMemoryProperties.compatibleHandleTypes |= wine_vk_handle_over_fd_types;
     wine_vk_normalize_handle_types_win(&properties->externalMemoryProperties.compatibleHandleTypes);
 }
 
@@ -1582,7 +1589,7 @@ static VkResult wine_vk_get_physical_device_image_format_properties_2(struct vul
     {
         wine_vk_normalize_handle_types_win(&external_image_info->handleType);
 
-        if (external_image_info->handleType == VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT)
+        if (external_image_info->handleType & wine_vk_handle_over_fd_types)
             external_image_info->handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
 
         wine_vk_normalize_handle_types_host(&external_image_info->handleType);
@@ -1601,11 +1608,11 @@ static VkResult wine_vk_get_physical_device_image_format_properties_2(struct vul
         VkExternalMemoryProperties *p = &external_image_properties->externalMemoryProperties;
 
         if (p->exportFromImportedHandleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT)
-            p->exportFromImportedHandleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+            p->exportFromImportedHandleTypes |= wine_vk_handle_over_fd_types;
         wine_vk_normalize_handle_types_win(&p->exportFromImportedHandleTypes);
 
         if (p->compatibleHandleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT)
-            p->compatibleHandleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+            p->compatibleHandleTypes |= wine_vk_handle_over_fd_types;
         wine_vk_normalize_handle_types_win(&p->compatibleHandleTypes);
     }
 
@@ -1858,18 +1865,154 @@ void wine_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(VkPhysicalDevice cli
     properties->externalSemaphoreFeatures = 0;
 }
 
+#define IOCTL_SHARED_GPU_RESOURCE_CREATE           CTL_CODE(FILE_DEVICE_VIDEO, 0, METHOD_BUFFERED, FILE_WRITE_ACCESS)
+
+struct shared_resource_create
+{
+    obj_handle_t unix_handle;
+    WCHAR name[1];
+};
+
 static HANDLE create_gpu_resource(int fd, LPCWSTR name)
 {
-    HANDLE ret = INVALID_HANDLE_VALUE;
+    static const WCHAR shared_gpu_resourceW[] = {'\\','?','?','\\','S','h','a','r','e','d','G','p','u','R','e','s','o','u','r','c','e',0};
+    HANDLE unix_resource = INVALID_HANDLE_VALUE;
+    struct shared_resource_create *inbuff;
+    UNICODE_STRING shared_gpu_resource_us;
+    HANDLE shared_resource;
+    OBJECT_ATTRIBUTES attr;
+    IO_STATUS_BLOCK iosb;
+    NTSTATUS status;
+    DWORD in_size;
 
     TRACE("Creating shared vulkan resource fd %d name %s.\n", fd, debugstr_w(name));
 
+    if (wine_server_fd_to_handle(fd, GENERIC_ALL, 0, &unix_resource) != STATUS_SUCCESS)
+        return INVALID_HANDLE_VALUE;
+
+    init_unicode_string(&shared_gpu_resource_us, shared_gpu_resourceW);
+
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = 0;
+    attr.Attributes = 0;
+    attr.ObjectName = &shared_gpu_resource_us;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    if ((status = NtCreateFile(&shared_resource, GENERIC_READ | GENERIC_WRITE, &attr, &iosb, NULL, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, 0, NULL, 0)))
+    {
+        ERR("Failed to load open a shared resource handle, status %#lx.\n", (long int)status);
+        NtClose(unix_resource);
+        return INVALID_HANDLE_VALUE;
+    }
+
+    in_size = sizeof(*inbuff) + (name ? lstrlenW(name) * sizeof(WCHAR) : 0);
+    inbuff = calloc(1, in_size);
+    inbuff->unix_handle = wine_server_obj_handle(unix_resource);
     if (name)
-        FIXME("Naming gpu resources not supported.\n");
+        lstrcpyW(&inbuff->name[0], name);
 
-    wine_server_fd_to_handle(fd, GENERIC_ALL, 0, &ret);
+    if ((status = NtDeviceIoControlFile(shared_resource, NULL, NULL, NULL, &iosb, IOCTL_SHARED_GPU_RESOURCE_CREATE,
+            inbuff, in_size, NULL, 0)))
 
-    return ret;
+    free(inbuff);
+    NtClose(unix_resource);
+
+    if (status)
+    {
+        ERR("Failed to create video resource, status %#lx.\n", (long int)status);
+        NtClose(shared_resource);
+        return INVALID_HANDLE_VALUE;
+    }
+
+    return shared_resource;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_OPEN             CTL_CODE(FILE_DEVICE_VIDEO, 1, METHOD_BUFFERED, FILE_WRITE_ACCESS)
+
+struct shared_resource_open
+{
+    obj_handle_t kmt_handle;
+    WCHAR name[1];
+};
+
+static HANDLE open_shared_resource(HANDLE kmt_handle, LPCWSTR name)
+{
+    static const WCHAR shared_gpu_resourceW[] = {'\\','?','?','\\','S','h','a','r','e','d','G','p','u','R','e','s','o','u','r','c','e',0};
+    UNICODE_STRING shared_gpu_resource_us;
+    struct shared_resource_open *inbuff;
+    HANDLE shared_resource;
+    OBJECT_ATTRIBUTES attr;
+    IO_STATUS_BLOCK iosb;
+    NTSTATUS status;
+    DWORD in_size;
+
+    init_unicode_string(&shared_gpu_resource_us, shared_gpu_resourceW);
+
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = 0;
+    attr.Attributes = 0;
+    attr.ObjectName = &shared_gpu_resource_us;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    if ((status = NtCreateFile(&shared_resource, GENERIC_READ | GENERIC_WRITE, &attr, &iosb, NULL, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, 0, NULL, 0)))
+    {
+        ERR("Failed to load open a shared resource handle, status %#lx.\n", (long int)status);
+        return INVALID_HANDLE_VALUE;
+    }
+
+    in_size = sizeof(*inbuff) + (name ? lstrlenW(name) * sizeof(WCHAR) : 0);
+    inbuff = calloc(1, in_size);
+    inbuff->kmt_handle = wine_server_obj_handle(kmt_handle);
+    if (name)
+        lstrcpyW(&inbuff->name[0], name);
+
+    status = NtDeviceIoControlFile(shared_resource, NULL, NULL, NULL, &iosb, IOCTL_SHARED_GPU_RESOURCE_OPEN,
+            inbuff, in_size, NULL, 0);
+
+    free(inbuff);
+
+    if (status)
+    {
+        ERR("Failed to open video resource, status %#lx.\n", (long int)status);
+        NtClose(shared_resource);
+        return INVALID_HANDLE_VALUE;
+    }
+
+    return shared_resource;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_GET_UNIX_RESOURCE           CTL_CODE(FILE_DEVICE_VIDEO, 3, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+static int get_shared_resource_fd(HANDLE shared_resource)
+{
+    IO_STATUS_BLOCK iosb;
+    obj_handle_t unix_resource;
+    NTSTATUS status;
+    int ret;
+
+    if (NtDeviceIoControlFile(shared_resource, NULL, NULL, NULL, &iosb, IOCTL_SHARED_GPU_RESOURCE_GET_UNIX_RESOURCE,
+            NULL, 0, &unix_resource, sizeof(unix_resource)))
+        return -1;
+
+    status = wine_server_handle_to_fd(wine_server_ptr_handle(unix_resource), FILE_READ_DATA, &ret, NULL);
+    NtClose(wine_server_ptr_handle(unix_resource));
+    return status == STATUS_SUCCESS ? ret : -1;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_GETKMT           CTL_CODE(FILE_DEVICE_VIDEO, 2, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+static HANDLE get_shared_resource_kmt_handle(HANDLE shared_resource)
+{
+    IO_STATUS_BLOCK iosb;
+    obj_handle_t kmt_handle;
+
+    if (NtDeviceIoControlFile(shared_resource, NULL, NULL, NULL, &iosb, IOCTL_SHARED_GPU_RESOURCE_GETKMT,
+            NULL, 0, &kmt_handle, sizeof(kmt_handle)))
+        return INVALID_HANDLE_VALUE;
+
+    return wine_server_ptr_handle(kmt_handle);
 }
 
 VkResult wine_vkAllocateMemory(VkDevice client_device, const VkMemoryAllocateInfo *alloc_info,
@@ -1911,7 +2054,7 @@ VkResult wine_vkAllocateMemory(VkDevice client_device, const VkMemoryAllocateInf
     if ((export_info = find_next_struct(alloc_info, VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO)))
     {
         memory->handle_types = export_info->handleTypes;
-        if (export_info->handleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT)
+        if (export_info->handleTypes & wine_vk_handle_over_fd_types)
             export_info->handleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
         wine_vk_normalize_handle_types_host(&export_info->handleTypes);
     }
@@ -1932,7 +2075,16 @@ VkResult wine_vkAllocateMemory(VkDevice client_device, const VkMemoryAllocateInf
                 if (handle_import_info->handle)
                     NtDuplicateObject( NtCurrentProcess(), handle_import_info->handle, NtCurrentProcess(), &memory->handle, 0, 0, DUPLICATE_SAME_ACCESS );
                 else if (handle_import_info->name)
-                    FIXME("Importing device memory by resource name not supported.\n");
+                    memory->handle = open_shared_resource( 0, handle_import_info->name );
+                break;
+            case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
+                /* FIXME: the spec says that device memory imported from a KMT handle doesn't keep a reference to the underyling payload.
+                   This means that in cases where on windows an application leaks VkDeviceMemory objects, we leak the full payload.  To
+                   fix this, we would need wine_dev_mem objects to store no reference to the payload, that means no host VkDeviceMemory
+                   object (as objects imported from FDs hold a reference to the payload), and no win32 handle to the object. We would then
+                   extend make_vulkan to have the thunks converting wine_dev_mem to native handles open the VkDeviceMemory from the KMT
+                   handle, use it in the host function, then close it again. */
+                memory->handle = open_shared_resource( handle_import_info->handle, NULL );
                 break;
             default:
                 WARN("Invalid handle type %08x passed in.\n", handle_import_info->handleType);
@@ -1941,7 +2093,7 @@ VkResult wine_vkAllocateMemory(VkDevice client_device, const VkMemoryAllocateInf
         }
 
         if (memory->handle != INVALID_HANDLE_VALUE)
-            wine_server_handle_to_fd(memory->handle, FILE_READ_DATA, &fd_import_info.fd, NULL);
+            fd_import_info.fd = get_shared_resource_fd(memory->handle);
 
         if (fd_import_info.fd == -1)
         {
@@ -2249,7 +2401,7 @@ VkResult wine_vkCreateBuffer(VkDevice client_device, const VkBufferCreateInfo *c
 
     if ((ext_info = find_next_struct(create_info, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO)))
     {
-        if (ext_info->handleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT)
+        if (ext_info->handleTypes & wine_vk_handle_over_fd_types)
             ext_info->handleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
         wine_vk_normalize_handle_types_host(&ext_info->handleTypes);
     }
@@ -2275,7 +2427,7 @@ VkResult wine_vkCreateImage(VkDevice client_device, const VkImageCreateInfo *cre
 
     if ((update_info = find_next_struct(info.pNext, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO)))
     {
-        if (update_info->handleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR)
+        if (update_info->handleTypes & wine_vk_handle_over_fd_types)
             update_info->handleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR;
         wine_vk_normalize_handle_types_host(&update_info->handleTypes);
     }
@@ -2514,6 +2666,7 @@ VkResult wine_vkGetMemoryWin32HandleKHR(VkDevice device, const VkMemoryGetWin32H
 {
     struct wine_device_memory *dev_mem = wine_device_memory_from_handle(handle_info->memory);
     const VkBaseInStructure *chain;
+    HANDLE ret;
 
     TRACE("%p, %p %p\n", device, handle_info, handle);
 
@@ -2528,6 +2681,13 @@ VkResult wine_vkGetMemoryWin32HandleKHR(VkDevice device, const VkMemoryGetWin32H
         case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT:
             return !NtDuplicateObject( NtCurrentProcess(), dev_mem->handle, NtCurrentProcess(), handle, dev_mem->access, dev_mem->inherit ? OBJ_INHERIT : 0, 0) ?
                 VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY;
+        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
+        {
+            if ((ret = get_shared_resource_kmt_handle(dev_mem->handle)) == INVALID_HANDLE_VALUE)
+                return VK_ERROR_OUT_OF_HOST_MEMORY;
+            *handle = ret;
+            return VK_SUCCESS;
+        }
         default:
             FIXME("Unable to get handle of type %x, did the application ignore the capabilities?\n", handle_info->handleType);
             return VK_ERROR_UNKNOWN;
diff --git a/dlls/winevulkan/vulkan_private.h b/dlls/winevulkan/vulkan_private.h
index 87bc1ae74b4..9bd2d4ebeea 100644
--- a/dlls/winevulkan/vulkan_private.h
+++ b/dlls/winevulkan/vulkan_private.h
@@ -240,4 +240,11 @@ static inline void *find_next_struct(const void *s, VkStructureType t)
     return NULL;
 }
 
+static inline void init_unicode_string( UNICODE_STRING *str, const WCHAR *data )
+{
+    str->Length = lstrlenW(data) * sizeof(WCHAR);
+    str->MaximumLength = str->Length + sizeof(WCHAR);
+    str->Buffer = (WCHAR *)data;
+}
+
 #endif /* __WINE_VULKAN_PRIVATE_H */
diff --git a/include/ddk/wdm.h b/include/ddk/wdm.h
index 2ea6a81d432..787fe5853c5 100644
--- a/include/ddk/wdm.h
+++ b/include/ddk/wdm.h
@@ -1871,6 +1871,7 @@ NTSTATUS  WINAPI ObRegisterCallbacks(POB_CALLBACK_REGISTRATION, void**);
 NTSTATUS  WINAPI ObReferenceObjectByHandle(HANDLE,ACCESS_MASK,POBJECT_TYPE,KPROCESSOR_MODE,PVOID*,POBJECT_HANDLE_INFORMATION);
 NTSTATUS  WINAPI ObReferenceObjectByName(UNICODE_STRING*,ULONG,ACCESS_STATE*,ACCESS_MASK,POBJECT_TYPE,KPROCESSOR_MODE,void*,void**);
 NTSTATUS  WINAPI ObReferenceObjectByPointer(void*,ACCESS_MASK,POBJECT_TYPE,KPROCESSOR_MODE);
+NTSTATUS  WINAPI ObOpenObjectByPointer(void *,ULONG,ACCESS_STATE*,ACCESS_MASK,POBJECT_TYPE,KPROCESSOR_MODE,HANDLE*);
 void      WINAPI ObUnRegisterCallbacks(void*);
 
 NTSTATUS  WINAPI PoCallDriver(DEVICE_OBJECT*,IRP*);
diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 29dffbaeb63..ad151a27ea8 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -157,6 +157,7 @@
 AddService=wuauserv,0,wuauService
 AddService=NDIS,0x800,NDISService
 AddService=nsiproxy,0x800,NsiProxyService
+AddService=SharedGpuResources,0x800,SharedGpuResourcesService
 
 [DefaultInstall.ntx86.Services]
 AddService=BITS,0,BITSService
@@ -177,6 +178,7 @@
 AddService=wuauserv,0,wuauService
 AddService=NDIS,0x800,NDISService
 AddService=nsiproxy,0x800,NsiProxyService
+AddService=SharedGpuResources,0x800,SharedGpuResourcesService
 
 [DefaultInstall.ntamd64.Services]
 AddService=BITS,0,BITSService
@@ -197,6 +199,7 @@
 AddService=wuauserv,0,wuauService
 AddService=NDIS,0x800,NDISService
 AddService=nsiproxy,0x800,NsiProxyService
+AddService=SharedGpuResources,0x800,SharedGpuResourcesService
 
 [DefaultInstall.ntarm64.Services]
 AddService=BITS,0,BITSService
@@ -278,6 +281,7 @@ AddService=Winmgmt,0,WinmgmtService
 AddService=wuauserv,0,wuauService
 AddService=NDIS,0x800,NDISService
 AddService=nsiproxy,0x800,NsiProxyService
+AddService=SharedGpuResources,0x800,SharedGpuResourcesService
 
 [Strings]
 MciExtStr="Software\Microsoft\Windows NT\CurrentVersion\MCI Extensions"
@@ -2481,6 +2485,15 @@ LoadOrderGroup="System Bus Extender"
 [NsiProxyServiceKeys]
 HKR,,"Tag",0x10001,1
 
+[SharedGpuResourcesService]
+Description="Shared GPU Resources Manager Service"
+DisplayName="Shared GPU Resources Manager"
+ServiceBinary="%12%\sharedgpures.sys"
+ServiceType=1
+StartType=2
+ErrorControl=1
+LoadOrderGroup="System Bus Extender"
+
 [RpcSsService]
 Description="RPC service"
 DisplayName="Remote Procedure Call (RPC)"
-- 
2.49.0

From 8f2559a523ac6befccecb987a24c86c09fec5d9d Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 13 Oct 2021 13:34:49 +0200
Subject: [PATCH 0876/1564] sharedgpures: Add support for arbitrary metadata.

---
 dlls/sharedgpures.sys/shared_resource.c | 57 +++++++++++++++++++++++--
 1 file changed, 53 insertions(+), 4 deletions(-)

diff --git a/dlls/sharedgpures.sys/shared_resource.c b/dlls/sharedgpures.sys/shared_resource.c
index e1330888b04..42715f7479b 100644
--- a/dlls/sharedgpures.sys/shared_resource.c
+++ b/dlls/sharedgpures.sys/shared_resource.c
@@ -23,6 +23,8 @@ struct shared_resource
     unsigned int ref_count;
     void *unix_resource;
     WCHAR *name;
+    void *metadata;
+    SIZE_T metadata_size;
 };
 
 static struct shared_resource *resource_pool;
@@ -245,6 +247,33 @@ static NTSTATUS shared_resource_get_unix_resource(struct shared_resource *res, v
     return STATUS_SUCCESS;
 }
 
+#define IOCTL_SHARED_GPU_RESOURCE_SET_METADATA           CTL_CODE(FILE_DEVICE_VIDEO, 4, METHOD_BUFFERED, FILE_WRITE_ACCESS)
+
+static NTSTATUS shared_resource_set_metadata(struct shared_resource *res, void *buff, SIZE_T insize, IO_STATUS_BLOCK *iosb)
+{
+    res->metadata = ExAllocatePoolWithTag(NonPagedPool, insize, 0);
+    memcpy(res->metadata, buff, insize);
+    res->metadata_size = insize;
+
+    iosb->Information = 0;
+    return STATUS_SUCCESS;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_GET_METADATA           CTL_CODE(FILE_DEVICE_VIDEO, 5, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+static NTSTATUS shared_resource_get_metadata(struct shared_resource *res, void *buff, SIZE_T outsize, IO_STATUS_BLOCK *iosb)
+{
+    if (!res->metadata)
+        return STATUS_NOT_FOUND;
+
+    if (res->metadata_size > outsize)
+        return STATUS_BUFFER_TOO_SMALL;
+
+    memcpy(buff, res->metadata, res->metadata_size);
+    iosb->Information = res->metadata_size;
+    return STATUS_SUCCESS;
+}
+
 static NTSTATUS WINAPI dispatch_create(DEVICE_OBJECT *device, IRP *irp)
 {
     irp->IoStatus.u.Status = STATUS_SUCCESS;
@@ -262,11 +291,19 @@ static NTSTATUS WINAPI dispatch_close(DEVICE_OBJECT *device, IRP *irp)
     if (res)
     {
         res->ref_count--;
-        if (!res->ref_count && res->unix_resource)
+        if (!res->ref_count)
         {
-            /* TODO: see if its possible to destroy the object here (unlink?) */
-            ObDereferenceObject(res->unix_resource);
-            res->unix_resource = NULL;
+            if (res->unix_resource)
+            {
+                /* TODO: see if its possible to destroy the object here (unlink?) */
+                ObDereferenceObject(res->unix_resource);
+                res->unix_resource = NULL;
+            }
+            if (res->metadata)
+            {
+                ExFreePoolWithTag(res->metadata, 0);
+                res->metadata = NULL;
+            }
         }
     }
 
@@ -312,6 +349,18 @@ static NTSTATUS WINAPI dispatch_ioctl(DEVICE_OBJECT *device, IRP *irp)
                                       stack->Parameters.DeviceIoControl.OutputBufferLength,
                                       &irp->IoStatus );
             break;
+        case IOCTL_SHARED_GPU_RESOURCE_SET_METADATA:
+            status = shared_resource_set_metadata( *res,
+                                      irp->AssociatedIrp.SystemBuffer,
+                                      stack->Parameters.DeviceIoControl.InputBufferLength,
+                                      &irp->IoStatus );
+            break;
+        case IOCTL_SHARED_GPU_RESOURCE_GET_METADATA:
+            status = shared_resource_get_metadata( *res,
+                                      irp->AssociatedIrp.SystemBuffer,
+                                      stack->Parameters.DeviceIoControl.OutputBufferLength,
+                                      &irp->IoStatus );
+            break;
     default:
         FIXME( "ioctl %#lx not supported\n", stack->Parameters.DeviceIoControl.IoControlCode );
         status = STATUS_NOT_SUPPORTED;
-- 
2.49.0

From 46d92feb4fc3cbf1174c41a73b6a3f8e7e9b2735 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 13 Jul 2022 13:11:22 -0400
Subject: [PATCH 0878/1564] sharedgpures.sys: Keep index into resource pool in
 FsContext instead of direct pointer to resource.

This fixes the errors due to the pointers in FsContext becoming invalid when the resource pool was expanded.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/sharedgpures.sys/shared_resource.c | 19 +++++++++++--------
 1 file changed, 11 insertions(+), 8 deletions(-)

diff --git a/dlls/sharedgpures.sys/shared_resource.c b/dlls/sharedgpures.sys/shared_resource.c
index 42715f7479b..8c3fa3764bd 100644
--- a/dlls/sharedgpures.sys/shared_resource.c
+++ b/dlls/sharedgpures.sys/shared_resource.c
@@ -284,7 +284,7 @@ static NTSTATUS WINAPI dispatch_create(DEVICE_OBJECT *device, IRP *irp)
 static NTSTATUS WINAPI dispatch_close(DEVICE_OBJECT *device, IRP *irp)
 {
     IO_STACK_LOCATION *stack = IoGetCurrentIrpStackLocation(irp);
-    struct shared_resource *res = stack->FileObject->FsContext;
+    struct shared_resource *res = &resource_pool[ (UINT_PTR) stack->FileObject->FsContext ];
 
     TRACE("Freeing shared resouce %p.\n", res);
 
@@ -315,7 +315,7 @@ static NTSTATUS WINAPI dispatch_close(DEVICE_OBJECT *device, IRP *irp)
 static NTSTATUS WINAPI dispatch_ioctl(DEVICE_OBJECT *device, IRP *irp)
 {
     IO_STACK_LOCATION *stack = IoGetCurrentIrpStackLocation( irp );
-    struct shared_resource **res = (struct shared_resource **) &stack->FileObject->FsContext;
+    struct shared_resource *res = &resource_pool[ (UINT_PTR) stack->FileObject->FsContext ];
     NTSTATUS status;
 
     TRACE( "ioctl %#lx insize %lu outsize %lu\n",
@@ -326,37 +326,37 @@ static NTSTATUS WINAPI dispatch_ioctl(DEVICE_OBJECT *device, IRP *irp)
     switch (stack->Parameters.DeviceIoControl.IoControlCode)
     {
         case IOCTL_SHARED_GPU_RESOURCE_CREATE:
-            status = shared_resource_create( res,
+            status = shared_resource_create( &res,
                                       irp->AssociatedIrp.SystemBuffer,
                                       stack->Parameters.DeviceIoControl.InputBufferLength,
                                       &irp->IoStatus );
             break;
         case IOCTL_SHARED_GPU_RESOURCE_OPEN:
-            status = shared_resource_open( res,
+            status = shared_resource_open( &res,
                                       irp->AssociatedIrp.SystemBuffer,
                                       stack->Parameters.DeviceIoControl.InputBufferLength,
                                       &irp->IoStatus );
             break;
         case IOCTL_SHARED_GPU_RESOURCE_GETKMT:
-            status = shared_resource_getkmt( *res,
+            status = shared_resource_getkmt( res,
                                       irp->AssociatedIrp.SystemBuffer,
                                       stack->Parameters.DeviceIoControl.OutputBufferLength,
                                       &irp->IoStatus );
             break;
         case IOCTL_SHARED_GPU_RESOURCE_GET_UNIX_RESOURCE:
-            status = shared_resource_get_unix_resource( *res,
+            status = shared_resource_get_unix_resource( res,
                                       irp->AssociatedIrp.SystemBuffer,
                                       stack->Parameters.DeviceIoControl.OutputBufferLength,
                                       &irp->IoStatus );
             break;
         case IOCTL_SHARED_GPU_RESOURCE_SET_METADATA:
-            status = shared_resource_set_metadata( *res,
+            status = shared_resource_set_metadata( res,
                                       irp->AssociatedIrp.SystemBuffer,
                                       stack->Parameters.DeviceIoControl.InputBufferLength,
                                       &irp->IoStatus );
             break;
         case IOCTL_SHARED_GPU_RESOURCE_GET_METADATA:
-            status = shared_resource_get_metadata( *res,
+            status = shared_resource_get_metadata( res,
                                       irp->AssociatedIrp.SystemBuffer,
                                       stack->Parameters.DeviceIoControl.OutputBufferLength,
                                       &irp->IoStatus );
@@ -367,6 +367,9 @@ static NTSTATUS WINAPI dispatch_ioctl(DEVICE_OBJECT *device, IRP *irp)
         break;
     }
 
+    if (!status)
+        stack->FileObject->FsContext = (void *)(UINT_PTR)(res - resource_pool);
+
     irp->IoStatus.u.Status = status;
     IoCompleteRequest( irp, IO_NO_INCREMENT );
     return status;
-- 
2.49.0

From a3e61430166667241882a0837f6bc69066d8592e Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 13 Jul 2022 13:14:04 -0400
Subject: [PATCH 0879/1564] sharedgpures.sys: Add support for associating
 additional NT objects with shared resources.

This is then used to share a shared memory section for shared fences
---
 dlls/sharedgpures.sys/shared_resource.c | 91 +++++++++++++++++++++++++
 1 file changed, 91 insertions(+)

diff --git a/dlls/sharedgpures.sys/shared_resource.c b/dlls/sharedgpures.sys/shared_resource.c
index 8c3fa3764bd..c6ab013ea0d 100644
--- a/dlls/sharedgpures.sys/shared_resource.c
+++ b/dlls/sharedgpures.sys/shared_resource.c
@@ -25,6 +25,8 @@ struct shared_resource
     WCHAR *name;
     void *metadata;
     SIZE_T metadata_size;
+    void **object_pool;
+    unsigned int object_pool_count;
 };
 
 static struct shared_resource *resource_pool;
@@ -274,6 +276,70 @@ static NTSTATUS shared_resource_get_metadata(struct shared_resource *res, void *
     return STATUS_SUCCESS;
 }
 
+#define IOCTL_SHARED_GPU_RESOURCE_SET_OBJECT           CTL_CODE(FILE_DEVICE_VIDEO, 6, METHOD_BUFFERED, FILE_WRITE_ACCESS)
+
+struct shared_resource_set_object
+{
+    unsigned int index;
+    obj_handle_t handle;
+};
+
+static NTSTATUS shared_resource_set_object(struct shared_resource *res, void *buff, SIZE_T insize, IO_STATUS_BLOCK *iosb)
+{
+    struct shared_resource_set_object *params = buff;
+    void *object;
+
+    if (insize < sizeof(*params))
+        return STATUS_INFO_LENGTH_MISMATCH;
+
+    if (!(object = reference_client_handle(params->handle)))
+        return STATUS_INVALID_HANDLE;
+
+    if (params->index >= res->object_pool_count)
+    {
+        void **expanded_pool = ExAllocatePoolWithTag(NonPagedPool, (params->index + 1) * sizeof(void *), 0);
+
+        if (res->object_pool)
+        {
+            memcpy(expanded_pool, res->object_pool, res->object_pool_count * sizeof(void *));
+            ExFreePoolWithTag(res->object_pool, 0);
+        }
+
+        memset(&expanded_pool[res->object_pool_count], 0, (params->index + 1 - res->object_pool_count) * sizeof (void *));
+
+        res->object_pool = expanded_pool;
+        res->object_pool_count = params->index + 1;
+    }
+
+    if (res->object_pool[params->index])
+        ObDereferenceObject(res->object_pool[params->index]);
+
+    res->object_pool[params->index] = object;
+
+    iosb->Information = 0;
+    return STATUS_SUCCESS;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_GET_OBJECT           CTL_CODE(FILE_DEVICE_VIDEO, 6, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+static NTSTATUS shared_resource_get_object(struct shared_resource *res, void *buff, SIZE_T insize, SIZE_T outsize, IO_STATUS_BLOCK *iosb)
+{
+    unsigned int index;
+
+    if (insize < sizeof(unsigned int) || outsize < sizeof(obj_handle_t))
+        return STATUS_INFO_LENGTH_MISMATCH;
+
+    index = *(unsigned int *)buff;
+
+    if (index >= res->object_pool_count || !res->object_pool[index])
+        return STATUS_INVALID_PARAMETER;
+
+    *((obj_handle_t *)buff) = open_client_handle(res->object_pool[index]);
+
+    iosb->Information = sizeof(obj_handle_t);
+    return STATUS_SUCCESS;
+}
+
 static NTSTATUS WINAPI dispatch_create(DEVICE_OBJECT *device, IRP *irp)
 {
     irp->IoStatus.u.Status = STATUS_SUCCESS;
@@ -304,6 +370,18 @@ static NTSTATUS WINAPI dispatch_close(DEVICE_OBJECT *device, IRP *irp)
                 ExFreePoolWithTag(res->metadata, 0);
                 res->metadata = NULL;
             }
+            if (res->object_pool)
+            {
+                unsigned int i;
+                for (i = 0; i < res->object_pool_count; i++)
+                {
+                    if (res->object_pool[i])
+                        ObDereferenceObject(res->object_pool[i]);
+                }
+                ExFreePoolWithTag(res->object_pool, 0);
+                res->object_pool = NULL;
+                res->object_pool_count = 0;
+            }
         }
     }
 
@@ -361,6 +439,19 @@ static NTSTATUS WINAPI dispatch_ioctl(DEVICE_OBJECT *device, IRP *irp)
                                       stack->Parameters.DeviceIoControl.OutputBufferLength,
                                       &irp->IoStatus );
             break;
+        case IOCTL_SHARED_GPU_RESOURCE_SET_OBJECT:
+            status = shared_resource_set_object( res,
+                                      irp->AssociatedIrp.SystemBuffer,
+                                      stack->Parameters.DeviceIoControl.InputBufferLength,
+                                      &irp->IoStatus );
+            break;
+        case IOCTL_SHARED_GPU_RESOURCE_GET_OBJECT:
+            status = shared_resource_get_object( res,
+                                      irp->AssociatedIrp.SystemBuffer,
+                                      stack->Parameters.DeviceIoControl.InputBufferLength,
+                                      stack->Parameters.DeviceIoControl.OutputBufferLength,
+                                      &irp->IoStatus);
+            break;
     default:
         FIXME( "ioctl %#lx not supported\n", stack->Parameters.DeviceIoControl.IoControlCode );
         status = STATUS_NOT_SUPPORTED;
-- 
2.49.0

From d91601740ba23471eac9cf9be18944fe7cb27bad Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Thu, 11 Aug 2022 10:57:01 -0400
Subject: [PATCH 0880/1564] winevulkan: Allowing importing D3D11 Texture
 handles as Vulkan memory objects.

---
 dlls/winevulkan/vulkan.c | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index 0ec6f0f2ec4..4939bc207a9 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -1530,7 +1530,9 @@ static inline void wine_vk_normalize_handle_types_host(VkExternalMemoryHandleTyp
 
 static const VkExternalMemoryHandleTypeFlagBits wine_vk_handle_over_fd_types =
                 VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT |
-                VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT;
+                VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT |
+                VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT |
+                VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT;
 
 static void wine_vk_get_physical_device_external_buffer_properties(struct wine_phys_dev *phys_dev,
         void (*p_vkGetPhysicalDeviceExternalBufferProperties)(VkPhysicalDevice, const VkPhysicalDeviceExternalBufferInfo *, VkExternalBufferProperties *),
@@ -2072,12 +2074,14 @@ VkResult wine_vkAllocateMemory(VkDevice client_device, const VkMemoryAllocateInf
         switch (handle_import_info->handleType)
         {
             case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT:
+            case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT:
                 if (handle_import_info->handle)
                     NtDuplicateObject( NtCurrentProcess(), handle_import_info->handle, NtCurrentProcess(), &memory->handle, 0, 0, DUPLICATE_SAME_ACCESS );
                 else if (handle_import_info->name)
                     memory->handle = open_shared_resource( 0, handle_import_info->name );
                 break;
             case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
+            case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT:
                 /* FIXME: the spec says that device memory imported from a KMT handle doesn't keep a reference to the underyling payload.
                    This means that in cases where on windows an application leaks VkDeviceMemory objects, we leak the full payload.  To
                    fix this, we would need wine_dev_mem objects to store no reference to the payload, that means no host VkDeviceMemory
@@ -2679,9 +2683,11 @@ VkResult wine_vkGetMemoryWin32HandleKHR(VkDevice device, const VkMemoryGetWin32H
     switch(handle_info->handleType)
     {
         case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT:
+        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT:
             return !NtDuplicateObject( NtCurrentProcess(), dev_mem->handle, NtCurrentProcess(), handle, dev_mem->access, dev_mem->inherit ? OBJ_INHERIT : 0, 0) ?
                 VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY;
         case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
+        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT:
         {
             if ((ret = get_shared_resource_kmt_handle(dev_mem->handle)) == INVALID_HANDLE_VALUE)
                 return VK_ERROR_OUT_OF_HOST_MEMORY;
-- 
2.49.0

From 1578ac66145a329ab161bb2e23dc465afed3ef1e Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Fri, 22 Apr 2022 11:53:02 -0400
Subject: [PATCH 0881/1564] winevulkan: Implement
 VK_KHR_external_semaphore_win32 for OPAQUE_WIN32 handleType.

---
 dlls/winevulkan/make_vulkan |  15 +++-
 dlls/winevulkan/vulkan.c    | 173 ++++++++++++++++++++++++++++++++++--
 2 files changed, 178 insertions(+), 10 deletions(-)

diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index c6d6f7581be..4b32f062b68 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -98,7 +98,6 @@ UNSUPPORTED_EXTENSIONS = [
     "VK_EXT_full_screen_exclusive",
     "VK_GOOGLE_display_timing",
     "VK_KHR_external_fence_win32",
-    "VK_KHR_external_semaphore_win32",
     # Relates to external_semaphore and needs type conversions in bitflags.
     "VK_KHR_maintenance7", # Causes infinity recursion in struct convert code
     "VK_KHR_shared_presentable_image", # Needs WSI work.
@@ -112,7 +111,6 @@ UNSUPPORTED_EXTENSIONS = [
     "VK_GOOGLE_surfaceless_query",
     "VK_KHR_external_fence_fd",
     "VK_EXT_external_memory_metal",
-    "VK_KHR_external_semaphore_fd",
     "VK_SEC_amigo_profiling", # Angle specific.
 
     # Extensions which require callback handling
@@ -174,7 +172,7 @@ FUNCTION_OVERRIDES = {
     "vkCreateDevice" : {"extra_param" : "client_ptr"},
     "vkGetPhysicalDeviceExternalBufferProperties" : {"dispatch" : True},
     "vkGetPhysicalDeviceExternalFenceProperties" : {"dispatch" : False},
-    "vkGetPhysicalDeviceExternalSemaphoreProperties" : {"dispatch" : False},
+    "vkGetPhysicalDeviceExternalSemaphoreProperties" : {"dispatch" : True},
 
     # Device functions
     "vkCreateCommandPool" : {"extra_param" : "client_ptr"},
@@ -188,7 +186,12 @@ FUNCTION_OVERRIDES = {
     "vkGetPhysicalDeviceExternalBufferPropertiesKHR" : {"dispatch" : True},
 
     # VK_KHR_external_semaphore_capabilities
-    "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR" : {"dispatch" : False},
+    "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR" : {"dispatch" : True},
+
+    # VK_KHR_external_semaphore_win32
+    "vkCreateSemaphore" : {"dispatch" : True, "extra_param" : "pCreateInfo"},
+    "vkGetSemaphoreWin32HandleKHR" : {"dispatch" : True},
+    "vkImportSemaphoreWin32HandleKHR" : {"dispatch" : True},
 
     # VK_KHR_external_memory_win32
     "vkGetMemoryWin32HandleKHR" : {"dispatch" : True},
@@ -227,12 +230,15 @@ MANUAL_UNIX_THUNKS = {
     "vkCreateDevice",
     "vkCreateImage",
     "vkCreateInstance",
+    "vkCreateSemaphore",
     "vkDestroyCommandPool",
     "vkDestroyDebugReportCallbackEXT",
     "vkDestroyDebugUtilsMessengerEXT",
     "vkDestroyDeferredOperationKHR",
     "vkDestroyDevice",
     "vkDestroyInstance",
+    "vkGetSemaphoreWin32HandleKHR",
+    "vkImportSemaphoreWin32HandleKHR",
     "vkEnumerateDeviceExtensionProperties",
     "vkEnumerateDeviceLayerProperties",
     "vkEnumerateInstanceExtensionProperties",
@@ -301,6 +307,7 @@ STRUCT_CHAIN_CONVERSIONS = {
     "VkImageCreateInfo": [],
     "VkMemoryAllocateInfo": ["VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR", "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR"],
     "VkPhysicalDeviceImageFormatInfo2": [],
+    "VkSemaphoreCreateInfo": ["VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"],
 }
 
 # Some struct members are conditionally ignored and callers are free to leave them uninitialized.
diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index 4939bc207a9..e07c13a0aeb 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -381,6 +381,14 @@ static VkResult wine_vk_physical_device_init(struct wine_phys_dev *object, VkPhy
                     VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME);
             host_properties[i].specVersion = VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION;
         }
+        if (!strcmp(host_properties[i].extensionName, "VK_KHR_external_semaphore_fd"))
+        {
+            TRACE("Substituting VK_KHR_external_semaphore_fd for VK_KHR_external_semaphore_win32\n");
+
+            snprintf(host_properties[i].extensionName, sizeof(host_properties[i].extensionName),
+                    VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME);
+            host_properties[i].specVersion = VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION;
+        }
 
         if (wine_vk_device_extension_supported(host_properties[i].extensionName))
         {
@@ -632,6 +640,12 @@ static VkResult wine_vk_device_convert_create_info(VkPhysicalDevice client_physi
         remove_extensions[remove_count++] = "VK_KHR_external_memory_win32";
     }
 
+    if (find_extension(extensions, extensions_count, "VK_KHR_external_semaphore_win32"))
+    {
+        extra_extensions[extra_count++] = "VK_KHR_external_semaphore_fd";
+        remove_extensions[remove_count++] = "VK_KHR_external_semaphore_win32";
+    }
+
     if (phys_dev->map_placed_align)
     {
         VkPhysicalDeviceMapMemoryPlacedFeaturesEXT *map_placed_features;
@@ -1849,22 +1863,69 @@ VkResult wine_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR(VkPhysicalDevice cl
 
 
 
+static inline void wine_vk_normalize_semaphore_handle_types_win(VkExternalSemaphoreHandleTypeFlags *types)
+{
+    *types &=
+        VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT |
+        VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT |
+        VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT;
+}
+
+static inline void wine_vk_normalize_semaphore_handle_types_host(VkExternalSemaphoreHandleTypeFlags *types)
+{
+    *types &=
+        VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT |
+        VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT;
+}
+
+static void wine_vk_get_physical_device_external_semaphore_properties(struct wine_phys_dev *phys_dev,
+    void (*p_vkGetPhysicalDeviceExternalSemaphoreProperties)(VkPhysicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *, VkExternalSemaphoreProperties *),
+    const VkPhysicalDeviceExternalSemaphoreInfo *semaphore_info, VkExternalSemaphoreProperties *properties)
+{
+    VkPhysicalDeviceExternalSemaphoreInfo semaphore_info_dup = *semaphore_info;
+
+    wine_vk_normalize_semaphore_handle_types_win(&semaphore_info_dup.handleType);
+    if (semaphore_info_dup.handleType == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT)
+        semaphore_info_dup.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+    wine_vk_normalize_semaphore_handle_types_host(&semaphore_info_dup.handleType);
+
+    if (semaphore_info->handleType && !semaphore_info_dup.handleType)
+    {
+        properties->exportFromImportedHandleTypes = 0;
+        properties->compatibleHandleTypes = 0;
+        properties->externalSemaphoreFeatures = 0;
+        return;
+    }
+
+    p_vkGetPhysicalDeviceExternalSemaphoreProperties(phys_dev->obj.host.physical_device, &semaphore_info_dup, properties);
+
+    if (properties->exportFromImportedHandleTypes & VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT)
+        properties->exportFromImportedHandleTypes |= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+    wine_vk_normalize_semaphore_handle_types_win(&properties->exportFromImportedHandleTypes);
+
+    if (properties->compatibleHandleTypes & VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT)
+        properties->compatibleHandleTypes |= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+    wine_vk_normalize_semaphore_handle_types_win(&properties->compatibleHandleTypes);
+}
+
 void wine_vkGetPhysicalDeviceExternalSemaphoreProperties(VkPhysicalDevice client_physical_device,
                                                          const VkPhysicalDeviceExternalSemaphoreInfo *info,
                                                          VkExternalSemaphoreProperties *properties)
 {
-    properties->exportFromImportedHandleTypes = 0;
-    properties->compatibleHandleTypes = 0;
-    properties->externalSemaphoreFeatures = 0;
+    struct wine_phys_dev *phys_dev = wine_phys_dev_from_handle(client_physical_device);
+
+    TRACE("%p, %p, %p\n", phys_dev, info, properties);
+    wine_vk_get_physical_device_external_semaphore_properties(phys_dev, phys_dev->obj.instance->p_vkGetPhysicalDeviceExternalSemaphoreProperties, info, properties);
 }
 
 void wine_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(VkPhysicalDevice client_physical_device,
                                                             const VkPhysicalDeviceExternalSemaphoreInfo *info,
                                                             VkExternalSemaphoreProperties *properties)
 {
-    properties->exportFromImportedHandleTypes = 0;
-    properties->compatibleHandleTypes = 0;
-    properties->externalSemaphoreFeatures = 0;
+    struct wine_phys_dev *phys_dev = wine_phys_dev_from_handle(client_physical_device);
+
+    TRACE("%p, %p, %p\n", phys_dev, info, properties);
+    wine_vk_get_physical_device_external_semaphore_properties(phys_dev, phys_dev->obj.instance->p_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR, info, properties);
 }
 
 #define IOCTL_SHARED_GPU_RESOURCE_CREATE           CTL_CODE(FILE_DEVICE_VIDEO, 0, METHOD_BUFFERED, FILE_WRITE_ACCESS)
@@ -2630,6 +2691,10 @@ NTSTATUS vk_is_available_device_function(void *arg)
     struct vulkan_device *device = vulkan_device_from_handle(params->device);
     if (!strcmp(params->name, "vkGetMemoryWin32HandleKHR") || !strcmp(params->name, "vkGetMemoryWin32HandlePropertiesKHR"))
         params->name = "vkGetMemoryFdKHR";
+    else if (!strcmp(params->name, "vkGetSemaphoreWin32HandleKHR"))
+        params->name = "vkGetSemaphoreFdKHR";
+    else if (!strcmp(params->name, "vkImportSemaphoreWin32HandleKHR"))
+        params->name = "vkImportSemaphoreFdKHR";
     return !!vk_funcs->p_vkGetDeviceProcAddr(device->host.device, params->name);
 }
 
@@ -2663,6 +2728,10 @@ NTSTATUS vk_is_available_device_function32(void *arg)
     char *name = UlongToPtr(params->name);
     if (!strcmp(name, "vkGetMemoryWin32HandleKHR") || !strcmp(name, "vkGetMemoryWin32HandlePropertiesKHR"))
         return !!vk_funcs->p_vkGetDeviceProcAddr(device->host.device, "vkGetMemoryFdKHR");
+    if (!strcmp(name, "vkGetSemaphoreWin32HandleKHR"))
+        return !!vk_funcs->p_vkGetDeviceProcAddr(device->host.device, "vkGetSemaphoreFdKHR");
+    if (!strcmp(name, "vkImportSemaphoreWin32HandleKHR"))
+        return !!vk_funcs->p_vkGetDeviceProcAddr(device->host.device, "vkImportSemaphoreFdKHR");
     return !!vk_funcs->p_vkGetDeviceProcAddr(device->host.device, UlongToPtr(params->name));
 }
 
@@ -2708,3 +2777,95 @@ VkResult wine_vkGetMemoryWin32HandlePropertiesKHR(VkDevice device, VkExternalMem
        handleType must not be one of the handle types defined as opaque */
     return VK_ERROR_INVALID_EXTERNAL_HANDLE;
 }
+
+
+VkResult wine_vkCreateSemaphore(VkDevice client_device, const VkSemaphoreCreateInfo *create_info,
+        const VkAllocationCallbacks *allocator, VkSemaphore *semaphore, void *win_create_info)
+{
+    struct vulkan_device *device = vulkan_device_from_handle(client_device);
+    VkExportSemaphoreCreateInfo *export_semaphore_info;
+
+    TRACE("%p %p %p %p", device, create_info, allocator, semaphore);
+
+    if ((export_semaphore_info = find_next_struct(create_info, VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO)))
+    {
+        if (export_semaphore_info->handleTypes & VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT)
+            export_semaphore_info->handleTypes |= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+        wine_vk_normalize_semaphore_handle_types_host(&export_semaphore_info->handleTypes);
+    }
+
+    if (find_next_struct(win_create_info, VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR))
+        FIXME("VkExportSemaphoreWin32HandleInfoKHR unhandled.\n");
+
+    return device->p_vkCreateSemaphore(device->host.device, create_info, NULL, semaphore);
+}
+
+VkResult wine_vkGetSemaphoreWin32HandleKHR(VkDevice client_device, const VkSemaphoreGetWin32HandleInfoKHR *handle_info,
+        HANDLE *handle)
+{
+    struct vulkan_device *device = vulkan_device_from_handle(client_device);
+    VkSemaphoreGetFdInfoKHR fd_info;
+    VkResult res;
+    int fd;
+
+    fd_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR;
+    fd_info.pNext = handle_info->pNext;
+    fd_info.semaphore = handle_info->semaphore;
+    fd_info.handleType = handle_info->handleType;
+    if (fd_info.handleType == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT)
+        fd_info.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+    wine_vk_normalize_semaphore_handle_types_host(&fd_info.handleType);
+
+    res = device->p_vkGetSemaphoreFdKHR(device->host.device, &fd_info, &fd);
+
+    if (res != VK_SUCCESS)
+        return res;
+
+    if (wine_server_fd_to_handle(fd, GENERIC_ALL, 0, handle) != STATUS_SUCCESS)
+    {
+        close(fd);
+        return VK_ERROR_OUT_OF_HOST_MEMORY;
+    }
+
+    return VK_SUCCESS;
+}
+
+VkResult wine_vkImportSemaphoreWin32HandleKHR(VkDevice client_device,
+        const VkImportSemaphoreWin32HandleInfoKHR *handle_info)
+{
+    struct vulkan_device *device = vulkan_device_from_handle(client_device);
+    VkImportSemaphoreFdInfoKHR fd_info;
+    VkResult res;
+
+    fd_info.sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR;
+    fd_info.pNext = handle_info->pNext;
+    fd_info.semaphore = handle_info->semaphore;
+    fd_info.flags = handle_info->flags;
+    fd_info.handleType = handle_info->handleType;
+
+    if (fd_info.handleType == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT)
+    {
+        if (handle_info->name)
+        {
+            FIXME("Importing win32 semaphore by name not supported.\n");
+            return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+        }
+
+        fd_info.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+        if (wine_server_handle_to_fd(handle_info->handle, GENERIC_ALL, &fd_info.fd, NULL) != STATUS_SUCCESS)
+            return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+    }
+    wine_vk_normalize_semaphore_handle_types_host(&fd_info.handleType);
+
+    if (!fd_info.handleType)
+    {
+        FIXME("Importing win32 semaphore with handle type %#x not supported.\n", handle_info->handleType);
+        return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+    }
+
+    /* importing FDs transfers ownership, importing NT handles does not  */
+    if ((res = device->p_vkImportSemaphoreFdKHR(device->host.device, &fd_info)) != VK_SUCCESS)
+        close(fd_info.fd);
+
+    return res;
+}
-- 
2.49.0

From a4be74766b31a05cf596abfe129aa1beeccb01cc Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 23 Dec 2022 17:49:37 -0600
Subject: [PATCH 0882/1564] winevulkan: Don't convert handles in "unwrapped"
 conversions.

---
 dlls/winevulkan/make_vulkan | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index 4b32f062b68..12df5e2990b 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -1234,7 +1234,8 @@ class VkHandle(object):
     def unwrap_handle(self, name, unwrap):
         if unwrap == Unwrap.HOST:
             return self.host_handle(name)
-        assert unwrap != Unwrap.NONE
+        if unwrap == Unwrap.NONE:
+            return name
         return None
 
     def is_wrapped(self):
-- 
2.49.0

From d1e6ad1df74dc51da7d7807a036b4629e9ed0c8b Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Thu, 14 Jul 2022 15:36:52 -0400
Subject: [PATCH 0883/1564] winevulkan: Add initial support for D3D12-Fence
 compatible timeline semaphores.

---
 dlls/win32u/vulkan.c             |  33 +-
 dlls/winevulkan/make_vulkan      |  40 +-
 dlls/winevulkan/vulkan.c         | 802 +++++++++++++++++++++++++++++--
 dlls/winevulkan/vulkan_private.h |  21 +
 include/wine/vulkan_driver.h     |  11 +
 5 files changed, 859 insertions(+), 48 deletions(-)

diff --git a/dlls/win32u/vulkan.c b/dlls/win32u/vulkan.c
index 667fdfe5c96..692fcb136a6 100644
--- a/dlls/win32u/vulkan.c
+++ b/dlls/win32u/vulkan.c
@@ -1028,6 +1028,7 @@ static BOOL extents_equals( const VkExtent2D *extents, const RECT *rect )
 static VkResult win32u_vkAcquireNextImage2KHR( VkDevice client_device, const VkAcquireNextImageInfoKHR *acquire_info,
                                                uint32_t *image_index )
 {
+    struct vulkan_semaphore *semaphore = vulkan_semaphore_from_handle( acquire_info->semaphore );
     struct swapchain *swapchain = swapchain_from_handle( acquire_info->swapchain );
     struct vulkan_device *device = vulkan_device_from_handle( client_device );
     VkAcquireNextImageInfoKHR acquire_info_host = *acquire_info;
@@ -1036,6 +1037,7 @@ static VkResult win32u_vkAcquireNextImage2KHR( VkDevice client_device, const VkA
     VkResult res;
 
     acquire_info_host.swapchain = swapchain->obj.host.swapchain;
+    acquire_info_host.semaphore = semaphore ? semaphore->host.semaphore : 0;
 
     res = device->p_vkAcquireNextImage2KHR( device->host.device, &acquire_info_host, image_index );
 
@@ -1058,16 +1060,17 @@ static VkResult win32u_vkAcquireNextImage2KHR( VkDevice client_device, const VkA
 }
 
 static VkResult win32u_vkAcquireNextImageKHR( VkDevice client_device, VkSwapchainKHR client_swapchain, uint64_t timeout,
-                                              VkSemaphore semaphore, VkFence fence, uint32_t *image_index )
+                                              VkSemaphore client_semaphore, VkFence fence, uint32_t *image_index )
 {
     struct swapchain *swapchain = swapchain_from_handle( client_swapchain );
     struct vulkan_device *device = vulkan_device_from_handle( client_device );
     struct surface *surface = swapchain->surface;
+    struct vulkan_semaphore *semaphore = vulkan_semaphore_from_handle( client_semaphore );
     RECT client_rect;
     VkResult res;
 
     res = device->p_vkAcquireNextImageKHR( device->host.device, swapchain->obj.host.swapchain, timeout,
-                                              semaphore, fence, image_index );
+                                           semaphore ? semaphore->host.semaphore : 0, fence, image_index );
 
     if (!res && (driver_funcs->p_vulkan_surface_enable_fshack( surface->hwnd, surface->driver_private ) != swapchain->fs_hack_enabled
         || (swapchain->fs_hack_enabled && swapchain->raw_monitor_dpi != NtUserGetWinMonitorDpi( surface->hwnd, MDT_RAW_DPI ))))
@@ -1262,6 +1265,8 @@ static VkResult win32u_vkQueuePresentKHR( VkQueue client_queue, const VkPresentI
     VkSwapchainKHR swapchains_buffer[16], *swapchains = swapchains_buffer;
     VkPresentInfoKHR present_info_host = *present_info;
     struct vulkan_device *device = queue->device;
+    struct vulkan_semaphore *semaphore;
+    VkSemaphore *semaphores = NULL;
     VkResult res;
     UINT i;
 
@@ -1271,9 +1276,30 @@ static VkResult win32u_vkQueuePresentKHR( VkQueue client_queue, const VkPresentI
 
     TRACE( "queue %p, present_info %p\n", queue, present_info );
 
+    if (present_info->waitSemaphoreCount)
+    {
+        semaphores = malloc( present_info->waitSemaphoreCount * sizeof(*semaphores) );
+        for (i = 0; i < present_info->waitSemaphoreCount; ++i)
+        {
+            semaphore = vulkan_semaphore_from_handle(present_info->pWaitSemaphores[i]);
+
+            if (semaphore->d3d12_fence)
+            {
+                FIXME("Waiting on D3D12-Fence compatible timeline semaphore not supported.\n");
+                free( semaphores );
+                return VK_ERROR_OUT_OF_HOST_MEMORY;
+            }
+            semaphores[i] = semaphore->host.semaphore;
+        }
+        present_info_host.pWaitSemaphores = semaphores;
+    }
+
     if (present_info->swapchainCount > ARRAY_SIZE(swapchains_buffer) &&
         !(swapchains = malloc( present_info->swapchainCount * sizeof(*swapchains) )))
+    {
+        free( semaphores );
         return VK_ERROR_OUT_OF_HOST_MEMORY;
+    }
 
     for (i = 0; i < present_info->swapchainCount; i++)
     {
@@ -1407,6 +1435,7 @@ static VkResult win32u_vkQueuePresentKHR( VkQueue client_queue, const VkPresentI
     }
 
     if (swapchains != swapchains_buffer) free( swapchains );
+    free( semaphores );
 
     if (TRACE_ON( fps ))
     {
diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index 12df5e2990b..53edd964673 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -177,7 +177,14 @@ FUNCTION_OVERRIDES = {
     # Device functions
     "vkCreateCommandPool" : {"extra_param" : "client_ptr"},
     "vkGetDeviceProcAddr" : {"dispatch" : False},
-    "vkAllocateMemory" : {"extra_param" : "pAllocateInfo"},
+    "vkAllocateMemory" : {"dispatch" : True},
+    "vkGetSemaphoreCounterValue" : {"dispatch" : True},
+    "vkSignalSemaphore" : {"dispatch" : True},
+    "vkWaitSemaphores" : {"dispatch" : True},
+    "vkQueueBindSparse" : {"dispatch" : True},
+    "vkQueueSubmit" : {"dispatch" : True},
+    "vkQueueSubmit2" : {"dispatch" : True},
+    "vkDestroySemaphore" : {"dispatch" : True},
 
     # VK_KHR_external_fence_capabilities
     "vkGetPhysicalDeviceExternalFencePropertiesKHR" : {"dispatch" : False},
@@ -189,13 +196,21 @@ FUNCTION_OVERRIDES = {
     "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR" : {"dispatch" : True},
 
     # VK_KHR_external_semaphore_win32
-    "vkCreateSemaphore" : {"dispatch" : True, "extra_param" : "pCreateInfo"},
+    "vkCreateSemaphore" : {"dispatch" : True },
     "vkGetSemaphoreWin32HandleKHR" : {"dispatch" : True},
     "vkImportSemaphoreWin32HandleKHR" : {"dispatch" : True},
 
     # VK_KHR_external_memory_win32
     "vkGetMemoryWin32HandleKHR" : {"dispatch" : True},
     "vkGetMemoryWin32HandlePropertiesKHR" : {"dispatch" : True},
+
+    # VK_KHR_timeline_semaphore
+    "vkGetSemaphoreCounterValueKHR" : {"dispatch" : True},
+    "vkSignalSemaphoreKHR" : {"dispatch" : True},
+    "vkWaitSemaphoresKHR" : {"dispatch" : True},
+
+    # VK_KHR_synchronization2
+    "vkQueueSubmit2KHR" : {"dispatch" : True},
 }
 
 # functions for which a user driver entry must be generated
@@ -271,6 +286,17 @@ MANUAL_UNIX_THUNKS = {
     "vkMapMemory2KHR",
     "vkUnmapMemory",
     "vkUnmapMemory2KHR",
+    "vkGetSemaphoreCounterValue",
+    "vkSignalSemaphore",
+    "vkWaitSemaphores",
+    "vkQueueBindSparse",
+    "vkQueueSubmit",
+    "vkQueueSubmit2",
+    "vkDestroySemaphore",
+    "vkGetSemaphoreCounterValueKHR",
+    "vkSignalSemaphoreKHR",
+    "vkWaitSemaphoresKHR",
+    "vkQueueSubmit2KHR",
 }
 
 # loader functions which are entirely manually implemented
@@ -305,9 +331,13 @@ STRUCT_CHAIN_CONVERSIONS = {
     # Structs which require pNext chain modification
     "VkBufferCreateInfo": [],
     "VkImageCreateInfo": [],
-    "VkMemoryAllocateInfo": ["VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR", "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR"],
+    "VkMemoryAllocateInfo": [],
     "VkPhysicalDeviceImageFormatInfo2": [],
-    "VkSemaphoreCreateInfo": ["VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"],
+    "VkPhysicalDeviceExternalSemaphoreInfo": [],
+    "VkSemaphoreCreateInfo": [],
+    "VkSubmitInfo": [],
+    "VkSubmitInfo2": [],
+    "VkBindSparseInfo" : [],
 }
 
 # Some struct members are conditionally ignored and callers are free to leave them uninitialized.
@@ -1219,6 +1249,8 @@ class VkHandle(object):
             return "vulkan_instance_from_handle({0})->host.instance".format(name)
         if self.name == "VkDeviceMemory":
             return "wine_device_memory_from_handle({0})->host.device_memory".format(name)
+        if self.name == "VkSemaphore":
+            return "vulkan_semaphore_from_handle({0})->host.semaphore".format(name)
         if self.name == "VkPhysicalDevice":
             return "vulkan_physical_device_from_handle({0})->host.physical_device".format(name)
         if self.name == "VkQueue":
diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index e07c13a0aeb..7ea61349269 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -24,6 +24,7 @@
 #include "config.h"
 #include <time.h>
 #include <unistd.h>
+#include <stdbool.h>
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -56,6 +57,12 @@ static struct wine_phys_dev *wine_phys_dev_from_handle(VkPhysicalDevice handle)
     return CONTAINING_RECORD(object, struct wine_phys_dev, obj);
 }
 
+static struct wine_semaphore *wine_semaphore_from_handle(VkSemaphore handle)
+{
+    struct vulkan_semaphore *object = vulkan_semaphore_from_handle(handle);
+    return CONTAINING_RECORD(object, struct wine_semaphore, obj);
+}
+
 static void vulkan_object_init_ptr( struct vulkan_object *obj, UINT64 host_handle, struct vulkan_client_object *client )
 {
     obj->host_handle = host_handle;
@@ -92,6 +99,24 @@ static uint32_t wine_vk_count_struct_(void *s, VkStructureType t)
 
 const struct vulkan_funcs *vk_funcs;
 
+#define wine_vk_find_unlink_struct(s, t) wine_vk_find_unlink_struct_((void *)s, VK_STRUCTURE_TYPE_##t)
+static void *wine_vk_find_unlink_struct_(void *s, VkStructureType t)
+{
+    VkBaseInStructure *prev = s;
+    VkBaseInStructure *header;
+
+    for (header = (VkBaseInStructure *)prev->pNext; header; prev = header, header = (VkBaseInStructure *)header->pNext)
+    {
+        if (header->sType == t) {
+            prev->pNext = header->pNext;
+            header->pNext = NULL;
+            return header;
+        }
+    }
+
+    return NULL;
+}
+
 static int vulkan_object_compare(const void *key, const struct rb_entry *entry)
 {
     struct vulkan_object *object = RB_ENTRY_VALUE(entry, struct vulkan_object, entry);
@@ -646,6 +671,9 @@ static VkResult wine_vk_device_convert_create_info(VkPhysicalDevice client_physi
         remove_extensions[remove_count++] = "VK_KHR_external_semaphore_win32";
     }
 
+    if (!find_extension(extensions, extensions_count, "VK_KHR_timeline_semaphore"))
+        extra_extensions[extra_count++] = "VK_KHR_timeline_semaphore";
+
     if (phys_dev->map_placed_align)
     {
         VkPhysicalDeviceMapMemoryPlacedFeaturesEXT *map_placed_features;
@@ -1883,11 +1911,37 @@ static void wine_vk_get_physical_device_external_semaphore_properties(struct win
     const VkPhysicalDeviceExternalSemaphoreInfo *semaphore_info, VkExternalSemaphoreProperties *properties)
 {
     VkPhysicalDeviceExternalSemaphoreInfo semaphore_info_dup = *semaphore_info;
+    VkSemaphoreTypeCreateInfo semaphore_type_info, *p_semaphore_type_info;
+
+    switch(semaphore_info->handleType)
+    {
+        case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT:
+            semaphore_info_dup.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+            break;
+        case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT:
+        {
+            if ((p_semaphore_type_info = find_next_struct(&semaphore_info_dup, VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO)))
+            {
+                p_semaphore_type_info->semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE;
+                p_semaphore_type_info->initialValue = 0;
+            }
+            else
+            {
+                semaphore_type_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
+                semaphore_type_info.pNext = semaphore_info_dup.pNext;
+                semaphore_type_info.semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE;
+                semaphore_type_info.initialValue = 0;
+
+                semaphore_info_dup.pNext = &semaphore_type_info;
+            }
 
-    wine_vk_normalize_semaphore_handle_types_win(&semaphore_info_dup.handleType);
-    if (semaphore_info_dup.handleType == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT)
-        semaphore_info_dup.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
-    wine_vk_normalize_semaphore_handle_types_host(&semaphore_info_dup.handleType);
+            semaphore_info_dup.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+            break;
+        }
+        default:
+            semaphore_info_dup.handleType = 0;
+            break;
+    }
 
     if (semaphore_info->handleType && !semaphore_info_dup.handleType)
     {
@@ -1900,11 +1954,11 @@ static void wine_vk_get_physical_device_external_semaphore_properties(struct win
     p_vkGetPhysicalDeviceExternalSemaphoreProperties(phys_dev->obj.host.physical_device, &semaphore_info_dup, properties);
 
     if (properties->exportFromImportedHandleTypes & VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT)
-        properties->exportFromImportedHandleTypes |= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+        properties->exportFromImportedHandleTypes = semaphore_info->handleType;
     wine_vk_normalize_semaphore_handle_types_win(&properties->exportFromImportedHandleTypes);
 
     if (properties->compatibleHandleTypes & VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT)
-        properties->compatibleHandleTypes |= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+        properties->compatibleHandleTypes = semaphore_info->handleType;
     wine_vk_normalize_semaphore_handle_types_win(&properties->compatibleHandleTypes);
 }
 
@@ -2079,13 +2133,11 @@ static HANDLE get_shared_resource_kmt_handle(HANDLE shared_resource)
 }
 
 VkResult wine_vkAllocateMemory(VkDevice client_device, const VkMemoryAllocateInfo *alloc_info,
-                               const VkAllocationCallbacks *allocator, VkDeviceMemory *ret,
-                               void *win_pAllocateInfo)
+                               const VkAllocationCallbacks *allocator, VkDeviceMemory *ret)
 {
     struct vulkan_device *device = vulkan_device_from_handle(client_device);
     struct wine_phys_dev *physical_device = CONTAINING_RECORD(device->physical_device, struct wine_phys_dev, obj);
     struct vulkan_instance *instance = device->physical_device->instance;
-    const VkMemoryAllocateInfo *win_alloc_info = win_pAllocateInfo;
     struct wine_device_memory *memory;
     VkMemoryAllocateInfo info = *alloc_info;
     VkImportMemoryHostPointerInfoEXT host_pointer_info;
@@ -2109,8 +2161,8 @@ VkResult wine_vkAllocateMemory(VkDevice client_device, const VkMemoryAllocateInf
     fd_import_info.pNext = NULL;
 
     /* find and process handle import/export info and grab it */
-    handle_import_info = find_next_struct(win_alloc_info, VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR);
-    handle_export_info = find_next_struct(win_alloc_info, VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR);
+    handle_import_info = wine_vk_find_unlink_struct(&info, IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR);
+    handle_export_info = wine_vk_find_unlink_struct(&info, EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR);
     if (handle_export_info && handle_export_info->pAttributes && handle_export_info->pAttributes->lpSecurityDescriptor)
         FIXME("Support for custom security descriptor not implemented.\n");
 
@@ -2778,72 +2830,312 @@ VkResult wine_vkGetMemoryWin32HandlePropertiesKHR(VkDevice device, VkExternalMem
     return VK_ERROR_INVALID_EXTERNAL_HANDLE;
 }
 
+#define IOCTL_SHARED_GPU_RESOURCE_SET_OBJECT           CTL_CODE(FILE_DEVICE_VIDEO, 6, METHOD_BUFFERED, FILE_WRITE_ACCESS)
+
+static bool set_shared_resource_object(HANDLE shared_resource, unsigned int index, HANDLE handle)
+{
+    IO_STATUS_BLOCK iosb;
+    struct shared_resource_set_object
+    {
+        unsigned int index;
+        obj_handle_t handle;
+    } params;
+
+    params.index = index;
+    params.handle = wine_server_obj_handle(handle);
+
+    return NtDeviceIoControlFile(shared_resource, NULL, NULL, NULL, &iosb, IOCTL_SHARED_GPU_RESOURCE_SET_OBJECT,
+            &params, sizeof(params), NULL, 0) == STATUS_SUCCESS;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_GET_OBJECT           CTL_CODE(FILE_DEVICE_VIDEO, 6, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+static HANDLE get_shared_resource_object(HANDLE shared_resource, unsigned int index)
+{
+    IO_STATUS_BLOCK iosb;
+    obj_handle_t handle;
+
+    if (NtDeviceIoControlFile(shared_resource, NULL, NULL, NULL, &iosb, IOCTL_SHARED_GPU_RESOURCE_GET_OBJECT,
+            &index, sizeof(index), &handle, sizeof(handle)))
+        return NULL;
+
+    return wine_server_ptr_handle(handle);
+}
+
+static void d3d12_semaphore_lock(struct wine_semaphore *semaphore)
+{
+    assert( semaphore->handle_type == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT );
+    pthread_mutex_lock(&semaphore->d3d12_fence_shm->mutex);
+}
+
+static void d3d12_semaphore_unlock(struct wine_semaphore *semaphore)
+{
+    assert( semaphore->handle_type == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT );
+    pthread_mutex_unlock(&semaphore->d3d12_fence_shm->mutex);
+}
 
 VkResult wine_vkCreateSemaphore(VkDevice client_device, const VkSemaphoreCreateInfo *create_info,
-        const VkAllocationCallbacks *allocator, VkSemaphore *semaphore, void *win_create_info)
+        const VkAllocationCallbacks *allocator, VkSemaphore *semaphore)
 {
     struct vulkan_device *device = vulkan_device_from_handle(client_device);
-    VkExportSemaphoreCreateInfo *export_semaphore_info;
 
-    TRACE("%p %p %p %p", device, create_info, allocator, semaphore);
+    VkExportSemaphoreWin32HandleInfoKHR *export_handle_info = wine_vk_find_unlink_struct(create_info, EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR);
+    VkExportSemaphoreCreateInfo *export_semaphore_info, timeline_export_info;
+    VkSemaphoreCreateInfo create_info_dup = *create_info;
+    VkSemaphoreTypeCreateInfo *found_type_info, type_info;
+    VkSemaphoreGetFdInfoKHR fd_info;
+    pthread_mutexattr_t mutex_attr;
+    struct wine_semaphore *object;
+    OBJECT_ATTRIBUTES attr;
+    HANDLE section_handle;
+    LARGE_INTEGER li;
+    VkResult res;
+    SIZE_T size;
+    int fd;
+
+    TRACE("(%p, %p, %p, %p)\n", device, create_info, allocator, semaphore);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    if (!(object = calloc(1, sizeof(*object))))
+        return VK_ERROR_OUT_OF_HOST_MEMORY;
+
+    object->handle = INVALID_HANDLE_VALUE;
 
-    if ((export_semaphore_info = find_next_struct(create_info, VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO)))
+    if ((export_semaphore_info = find_next_struct(&create_info_dup, VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO)))
     {
+        object->export_types = export_semaphore_info->handleTypes;
         if (export_semaphore_info->handleTypes & VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT)
             export_semaphore_info->handleTypes |= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
         wine_vk_normalize_semaphore_handle_types_host(&export_semaphore_info->handleTypes);
     }
 
-    if (find_next_struct(win_create_info, VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR))
-        FIXME("VkExportSemaphoreWin32HandleInfoKHR unhandled.\n");
+    if ((res = device->p_vkCreateSemaphore(device->host.device, &create_info_dup, NULL, &object->semaphore)) != VK_SUCCESS)
+        goto done;
+
+    if (export_semaphore_info && export_semaphore_info->handleTypes == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT)
+    {
+        fd_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR;
+        fd_info.pNext = NULL;
+        fd_info.semaphore = object->semaphore;
+        fd_info.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+
+        if ((res = device->p_vkGetSemaphoreFdKHR(device->host.device, &fd_info, &fd)) == VK_SUCCESS)
+        {
+            object->handle = create_gpu_resource(fd, export_handle_info ? export_handle_info->name : NULL);
+            close(fd);
+        }
 
-    return device->p_vkCreateSemaphore(device->host.device, create_info, NULL, semaphore);
+        if (object->handle == INVALID_HANDLE_VALUE)
+        {
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto done;
+        }
+    }
+    else if (object->export_types & VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+    {
+        /* compatibleHandleTypes doesn't include any other types */
+        assert(object->export_types == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT);
+        object->handle_type = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT;
+
+        timeline_export_info.sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO;
+        timeline_export_info.pNext = NULL;
+        timeline_export_info.handleTypes = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+
+        type_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
+        type_info.pNext = &timeline_export_info;
+        type_info.semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE;
+        type_info.initialValue = 0;
+
+        create_info_dup.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
+        create_info_dup.pNext = &type_info;
+        create_info_dup.flags = 0;
+
+        if ((res = device->p_vkCreateSemaphore(device->host.device, &create_info_dup, NULL, &object->fence_timeline_semaphore)) != VK_SUCCESS)
+            goto done;
+
+        fd_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR;
+        fd_info.pNext = NULL;
+        fd_info.semaphore = object->fence_timeline_semaphore;
+        fd_info.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+
+        if ((res = device->p_vkGetSemaphoreFdKHR(device->host.device, &fd_info, &fd)) == VK_SUCCESS)
+        {
+            object->handle = create_gpu_resource(fd, export_handle_info ? export_handle_info->name : NULL);
+            close(fd);
+        }
+
+        if (object->handle == INVALID_HANDLE_VALUE)
+        {
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto done;
+        }
+
+        /* Shared Fence Memory */
+        InitializeObjectAttributes(&attr, NULL, 0, NULL, NULL);
+        size = li.QuadPart = sizeof(*object->d3d12_fence_shm);
+        if (NtCreateSection(&section_handle, STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ | SECTION_MAP_WRITE, &attr, &li, PAGE_READWRITE, SEC_COMMIT, NULL))
+        {
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto done;
+        }
+
+        if (!set_shared_resource_object(object->handle, 0, section_handle))
+        {
+            NtClose(section_handle);
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto done;
+        }
+
+        if (NtMapViewOfSection(section_handle, GetCurrentProcess(), (void**) &object->d3d12_fence_shm, 0, 0, NULL, &size, ViewShare, 0, PAGE_READWRITE))
+        {
+            NtClose(section_handle);
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto done;
+        }
+
+        NtClose(section_handle);
+
+        if ((found_type_info = find_next_struct(create_info, VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO)))
+            object->d3d12_fence_shm->virtual_value = found_type_info->initialValue;
+
+        pthread_mutexattr_init(&mutex_attr);
+        pthread_mutexattr_setpshared(&mutex_attr, PTHREAD_PROCESS_SHARED);
+        if (pthread_mutex_init(&object->d3d12_fence_shm->mutex, &mutex_attr))
+        {
+            pthread_mutexattr_destroy(&mutex_attr);
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto done;
+        }
+        pthread_mutexattr_destroy(&mutex_attr);
+
+        vulkan_object_init(&object->obj.obj, object->fence_timeline_semaphore);
+        vulkan_instance_insert_object(device->physical_device->instance, &object->obj.obj);
+        object->obj.d3d12_fence = TRUE;
+    }
+    if (object->fence_timeline_semaphore == VK_NULL_HANDLE)
+    {
+        vulkan_object_init(&object->obj.obj, object->semaphore);
+        vulkan_instance_insert_object(device->physical_device->instance, &object->obj.obj);
+    }
+    *semaphore = object->obj.client.handle;
+
+    done:
+
+    if (res != VK_SUCCESS)
+    {
+        if (object->d3d12_fence_shm)
+        {
+            pthread_mutex_destroy(&object->d3d12_fence_shm->mutex);
+            NtUnmapViewOfSection(GetCurrentProcess(), object->d3d12_fence_shm);
+        }
+        if (object->handle != INVALID_HANDLE_VALUE)
+            NtClose(object->handle);
+        if (object->semaphore != VK_NULL_HANDLE)
+            device->p_vkDestroySemaphore(device->host.device, object->semaphore, NULL);
+        if (object->fence_timeline_semaphore != VK_NULL_HANDLE)
+            device->p_vkDestroySemaphore(device->host.device, object->fence_timeline_semaphore, NULL);
+        free(object);
+    }
+
+    return res;
 }
 
 VkResult wine_vkGetSemaphoreWin32HandleKHR(VkDevice client_device, const VkSemaphoreGetWin32HandleInfoKHR *handle_info,
         HANDLE *handle)
+{
+    struct wine_semaphore *semaphore = wine_semaphore_from_handle(handle_info->semaphore);
+
+    if (!(semaphore->export_types & handle_info->handleType))
+        return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+
+    if (NtDuplicateObject( NtCurrentProcess(), semaphore->handle, NtCurrentProcess(), handle, 0, 0, DUPLICATE_SAME_ACCESS ))
+        return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+
+    return VK_SUCCESS;
+}
+
+void wine_vkDestroySemaphore(VkDevice client_device, VkSemaphore semaphore_handle, const VkAllocationCallbacks *allocator)
 {
     struct vulkan_device *device = vulkan_device_from_handle(client_device);
-    VkSemaphoreGetFdInfoKHR fd_info;
-    VkResult res;
-    int fd;
+    struct wine_semaphore *semaphore = wine_semaphore_from_handle(semaphore_handle);
 
-    fd_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR;
-    fd_info.pNext = handle_info->pNext;
-    fd_info.semaphore = handle_info->semaphore;
-    fd_info.handleType = handle_info->handleType;
-    if (fd_info.handleType == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT)
-        fd_info.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
-    wine_vk_normalize_semaphore_handle_types_host(&fd_info.handleType);
+    TRACE("%p, %p, %p\n", device, semaphore, allocator);
 
-    res = device->p_vkGetSemaphoreFdKHR(device->host.device, &fd_info, &fd);
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
 
-    if (res != VK_SUCCESS)
-        return res;
+    if (!semaphore)
+        return;
 
-    if (wine_server_fd_to_handle(fd, GENERIC_ALL, 0, handle) != STATUS_SUCCESS)
-    {
-        close(fd);
-        return VK_ERROR_OUT_OF_HOST_MEMORY;
-    }
+    if (semaphore->handle != INVALID_HANDLE_VALUE)
+        NtClose(semaphore->handle);
 
-    return VK_SUCCESS;
+    if (semaphore->d3d12_fence_shm)
+        NtUnmapViewOfSection(GetCurrentProcess(), semaphore->d3d12_fence_shm);
+
+    vulkan_instance_remove_object(device->physical_device->instance, &semaphore->obj.obj);
+    device->p_vkDestroySemaphore(device->host.device, semaphore->semaphore, NULL);
+
+    if (semaphore->fence_timeline_semaphore)
+        device->p_vkDestroySemaphore(device->host.device, semaphore->fence_timeline_semaphore, NULL);
+
+    free(semaphore);
 }
 
 VkResult wine_vkImportSemaphoreWin32HandleKHR(VkDevice client_device,
         const VkImportSemaphoreWin32HandleInfoKHR *handle_info)
 {
     struct vulkan_device *device = vulkan_device_from_handle(client_device);
+    struct wine_semaphore *semaphore = wine_semaphore_from_handle(handle_info->semaphore);
+    struct wine_semaphore output_semaphore;
+    VkSemaphoreTypeCreateInfo type_info;
     VkImportSemaphoreFdInfoKHR fd_info;
+    VkSemaphoreCreateInfo create_info;
+    HANDLE d3d12_fence_shm;
+    NTSTATUS stat;
     VkResult res;
+    SIZE_T size;
+
+    TRACE("(%p, %p). semaphore = %p handle = %p\n", device, handle_info, semaphore, handle_info->handle);
+
+    if (handle_info->handleType == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT && !semaphore->fence_timeline_semaphore)
+    {
+        type_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
+        type_info.pNext = NULL;
+        type_info.semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE;
+        type_info.initialValue = 0;
+
+        create_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
+        create_info.pNext = &type_info;
+        create_info.flags = 0;
+
+        if ((res = device->p_vkCreateSemaphore(device->host.device, &create_info, NULL, &semaphore->fence_timeline_semaphore)) != VK_SUCCESS)
+        {
+            ERR("Failed to create timeline semaphore backing D3D12 semaphore. vr %d.\n", res);
+            return res;
+        };
+
+        vulkan_instance_remove_object(device->physical_device->instance, &semaphore->obj.obj);
+        vulkan_object_init(&semaphore->obj.obj, semaphore->fence_timeline_semaphore);
+        vulkan_instance_insert_object(device->physical_device->instance, &semaphore->obj.obj);
+        semaphore->obj.d3d12_fence = TRUE;
+    }
+
+    output_semaphore = *semaphore;
+    output_semaphore.handle = NULL;
+    output_semaphore.handle_type = handle_info->handleType;
+    output_semaphore.d3d12_fence_shm = NULL;
 
     fd_info.sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR;
     fd_info.pNext = handle_info->pNext;
-    fd_info.semaphore = handle_info->semaphore;
+    fd_info.semaphore = output_semaphore.obj.host.semaphore;
     fd_info.flags = handle_info->flags;
     fd_info.handleType = handle_info->handleType;
 
-    if (fd_info.handleType == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT)
+    if (handle_info->handleType == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT ||
+        handle_info->handleType == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
     {
         if (handle_info->name)
         {
@@ -2851,10 +3143,49 @@ VkResult wine_vkImportSemaphoreWin32HandleKHR(VkDevice client_device,
             return VK_ERROR_INVALID_EXTERNAL_HANDLE;
         }
 
+        if (NtDuplicateObject( NtCurrentProcess(), handle_info->handle, NtCurrentProcess(), &output_semaphore.handle, 0, 0, DUPLICATE_SAME_ACCESS ))
+            return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+
         fd_info.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
-        if (wine_server_handle_to_fd(handle_info->handle, GENERIC_ALL, &fd_info.fd, NULL) != STATUS_SUCCESS)
+        if ((fd_info.fd = get_shared_resource_fd(output_semaphore.handle)) == -1)
+        {
+            WARN("Invalid handle %p.\n", handle_info->handle);
+            NtClose(output_semaphore.handle);
             return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+        }
+
+        if (handle_info->handleType == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+        {
+            if (handle_info->flags & VK_SEMAPHORE_IMPORT_TEMPORARY_BIT)
+            {
+                FIXME("Temporarily importing d3d12 fences unsupported.\n");
+                close(fd_info.fd);
+                NtClose(output_semaphore.handle);
+                return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+            }
+
+            if (!(d3d12_fence_shm = get_shared_resource_object(output_semaphore.handle, 0)))
+            {
+                ERR("Failed to get D3D12 semaphore memory.\n");
+                close(fd_info.fd);
+                NtClose(output_semaphore.handle);
+                return VK_ERROR_OUT_OF_HOST_MEMORY;
+            }
+
+            size = sizeof(*output_semaphore.d3d12_fence_shm);
+            if ((stat = NtMapViewOfSection(d3d12_fence_shm, GetCurrentProcess(), (void**) &output_semaphore.d3d12_fence_shm, 0, 0, NULL, &size, ViewShare, 0, PAGE_READWRITE)))
+            {
+                ERR("Failed to map D3D12 semaphore memory. stat %#x.\n", (int)stat);
+                close(fd_info.fd);
+                NtClose(d3d12_fence_shm);
+                NtClose(output_semaphore.handle);
+                return VK_ERROR_OUT_OF_HOST_MEMORY;
+            }
+
+            NtClose(d3d12_fence_shm);
+        }
     }
+
     wine_vk_normalize_semaphore_handle_types_host(&fd_info.handleType);
 
     if (!fd_info.handleType)
@@ -2863,9 +3194,396 @@ VkResult wine_vkImportSemaphoreWin32HandleKHR(VkDevice client_device,
         return VK_ERROR_INVALID_EXTERNAL_HANDLE;
     }
 
-    /* importing FDs transfers ownership, importing NT handles does not  */
-    if ((res = device->p_vkImportSemaphoreFdKHR(device->host.device, &fd_info)) != VK_SUCCESS)
+    if ((res = device->p_vkImportSemaphoreFdKHR(device->host.device, &fd_info)) == VK_SUCCESS)
+    {
+        if (semaphore->handle)
+            NtClose(semaphore->handle);
+        if (semaphore->d3d12_fence_shm)
+            NtUnmapViewOfSection(GetCurrentProcess(), semaphore->d3d12_fence_shm);
+
+        *semaphore = output_semaphore;
+    }
+    else
+    {
+        if (output_semaphore.handle)
+            NtClose(output_semaphore.handle);
+        if (output_semaphore.d3d12_fence_shm)
+            NtUnmapViewOfSection(GetCurrentProcess(), output_semaphore.d3d12_fence_shm);
+
+        /* importing FDs transfers ownership, importing NT handles does not  */
         close(fd_info.fd);
+    }
 
     return res;
 }
+
+static VkResult vk_get_semaphore_counter_value(VkDevice device_handle, VkSemaphore semaphore_handle, uint64_t *value, bool khr)
+{
+    struct wine_semaphore *semaphore = wine_semaphore_from_handle(semaphore_handle);
+    struct vulkan_device *device = vulkan_device_from_handle(device_handle);
+
+    if (khr)
+        return device->p_vkGetSemaphoreCounterValueKHR(device->host.device, semaphore->obj.host.semaphore, value);
+    else
+        return device->p_vkGetSemaphoreCounterValue(device->host.device, semaphore->obj.host.semaphore, value);
+}
+
+static VkResult wine_vk_get_semaphore_counter_value(VkDevice device_handle, VkSemaphore semaphore_handle, uint64_t *value, bool khr)
+{
+    struct wine_semaphore *semaphore = wine_semaphore_from_handle(semaphore_handle);
+
+    if (semaphore->handle_type == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+    {
+        d3d12_semaphore_lock(semaphore);
+        *value = semaphore->d3d12_fence_shm->virtual_value;
+        d3d12_semaphore_unlock(semaphore);
+        return VK_SUCCESS;
+    }
+
+    return vk_get_semaphore_counter_value(device_handle, semaphore_handle, value, khr);
+}
+
+VkResult wine_vkGetSemaphoreCounterValue(VkDevice device_handle, VkSemaphore semaphore_handle, uint64_t *value)
+{
+    return wine_vk_get_semaphore_counter_value(device_handle, semaphore_handle, value, false);
+}
+
+VkResult wine_vkGetSemaphoreCounterValueKHR(VkDevice device_handle, VkSemaphore semaphore_handle, uint64_t *value)
+{
+    return wine_vk_get_semaphore_counter_value(device_handle, semaphore_handle, value, true);
+}
+
+static VkResult vk_signal_semaphore(VkDevice device_handle, const VkSemaphoreSignalInfo *signal_info, bool khr)
+{
+    struct wine_semaphore *semaphore = wine_semaphore_from_handle(signal_info->semaphore);
+    struct vulkan_device *device = vulkan_device_from_handle(device_handle);
+    VkSemaphoreSignalInfo dup_signal_info = *signal_info;
+
+    dup_signal_info.semaphore = semaphore->obj.host.semaphore;
+    if (khr)
+        return device->p_vkSignalSemaphoreKHR(device->host.device, &dup_signal_info);
+    else
+        return device->p_vkSignalSemaphore(device->host.device, &dup_signal_info);
+}
+
+static NTSTATUS wine_vk_signal_semaphore(VkDevice device, const VkSemaphoreSignalInfo *signal_info, bool khr)
+{
+    struct wine_semaphore *semaphore = wine_semaphore_from_handle(signal_info->semaphore);
+
+    TRACE("(%p, %p)\n", device, signal_info);
+
+    if (semaphore->handle_type == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+    {
+        FIXME("Signalling D3D12-Fence compatible timeline semaphore not supported.\n");
+        return VK_ERROR_OUT_OF_HOST_MEMORY;
+    }
+
+    return vk_signal_semaphore(device, signal_info, khr);
+}
+
+VkResult wine_vkSignalSemaphore(VkDevice device, const VkSemaphoreSignalInfo *signal_info)
+{
+    return wine_vk_signal_semaphore(device, signal_info, false);
+}
+
+VkResult wine_vkSignalSemaphoreKHR(VkDevice device, const VkSemaphoreSignalInfo *signal_info)
+{
+    return wine_vk_signal_semaphore(device, signal_info, true);
+}
+
+static VkSemaphore *unwrap_semaphore_array(const VkSemaphore *in, uint32_t count, struct conversion_context *ctx)
+{
+    VkSemaphore *out;
+    unsigned int i;
+
+    if (!in || !count) return NULL;
+
+    out = conversion_context_alloc(ctx, count * sizeof(*out));
+    for (i = 0; i < count; ++i)
+        out[i] = in[i] ? wine_semaphore_from_handle(in[i])->obj.host.semaphore : VK_NULL_HANDLE;
+
+    return out;
+}
+
+static VkResult vk_wait_semaphores(struct vulkan_device *device, const VkSemaphoreWaitInfo *wait_info, uint64_t timeout, bool khr)
+{
+    VkSemaphoreWaitInfo wait_info_dup = *wait_info;
+    struct conversion_context ctx;
+    VkResult ret;
+
+    init_conversion_context(&ctx);
+    wait_info_dup.pSemaphores = unwrap_semaphore_array(wait_info->pSemaphores, wait_info->semaphoreCount, &ctx);
+    if (khr)
+        ret = device->p_vkWaitSemaphoresKHR(device->host.device, &wait_info_dup, timeout);
+    else
+        ret = device->p_vkWaitSemaphores(device->host.device, &wait_info_dup, timeout);
+    free_conversion_context(&ctx);
+    return ret;
+}
+
+static VkResult wine_vk_wait_semaphores(VkDevice device_handle, const VkSemaphoreWaitInfo *wait_info, uint64_t timeout, bool khr)
+{
+    unsigned int i;
+
+    TRACE("(%p, %p, 0x%s)\n", device_handle, wait_info, wine_dbgstr_longlong(timeout));
+
+    for (i = 0; i < wait_info->semaphoreCount; i++)
+    {
+        struct wine_semaphore *semaphore = wine_semaphore_from_handle(wait_info->pSemaphores[i]);
+
+        if (semaphore->handle_type == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+        {
+            FIXME("Waiting on D3D12-Fence compatible timeline semaphores not supported.");
+            return VK_ERROR_OUT_OF_HOST_MEMORY;
+        }
+    }
+    return vk_wait_semaphores(vulkan_device_from_handle(device_handle), wait_info, timeout, khr);
+}
+
+VkResult wine_vkWaitSemaphores(VkDevice device, const VkSemaphoreWaitInfo *wait_info, uint64_t timeout)
+{
+    return wine_vk_wait_semaphores(device, wait_info, timeout, false);
+}
+
+VkResult wine_vkWaitSemaphoresKHR(VkDevice device, const VkSemaphoreWaitInfo *wait_info, uint64_t timeout)
+{
+    return wine_vk_wait_semaphores(device, wait_info, timeout, true);
+}
+
+VkResult vk_queue_submit_unwrap(struct vulkan_queue *queue, uint32_t submit_count, const VkSubmitInfo *submits_orig, VkFence fence)
+{
+    struct conversion_context ctx;
+    VkSubmitInfo *submits;
+    unsigned int i, j;
+    VkResult ret;
+
+    init_conversion_context(&ctx);
+    MEMDUP(&ctx, submits, submits_orig, submit_count);
+    for (i = 0; i < submit_count; ++i)
+    {
+        submits[i].pWaitSemaphores = unwrap_semaphore_array(submits[i].pWaitSemaphores, submits[i].waitSemaphoreCount, &ctx);
+        submits[i].pSignalSemaphores = unwrap_semaphore_array(submits[i].pSignalSemaphores, submits[i].signalSemaphoreCount, &ctx);
+        if (submits[i].pCommandBuffers && submits[i].commandBufferCount)
+        {
+            VkCommandBuffer *out;
+
+            out = conversion_context_alloc(&ctx, submits[i].commandBufferCount * sizeof(*out));
+            for (j = 0; j < submits[i].commandBufferCount; ++j)
+                out[j] = wine_cmd_buffer_from_handle(submits[i].pCommandBuffers[j])->host.command_buffer;
+            submits[i].pCommandBuffers = out;
+        }
+    }
+    ret = queue->device->p_vkQueueSubmit(queue->host.queue, submit_count, submits, fence);
+    free_conversion_context(&ctx);
+    return ret;
+}
+
+VkResult wine_vkQueueSubmit(VkQueue queue_handle, uint32_t submit_count, const VkSubmitInfo *submits, VkFence fence)
+{
+    struct vulkan_queue *queue = vulkan_queue_from_handle(queue_handle);
+    unsigned int i, k;
+
+    TRACE("(%p %u %p 0x%s)\n", queue_handle, submit_count, submits, wine_dbgstr_longlong(fence));
+
+    for (i = 0; i < submit_count; i++)
+    {
+        for (k = 0; k < submits[i].waitSemaphoreCount; k++)
+        {
+            if (wine_semaphore_from_handle(submits[i].pWaitSemaphores[k])->handle_type ==
+                    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+            {
+                FIXME("Queue submissions with waits on D3D12-Fence compatible timeline semaphores not supported.\n");
+                return VK_ERROR_OUT_OF_HOST_MEMORY;
+            }
+        }
+
+        for (k = 0; k < submits[i].signalSemaphoreCount; k++)
+        {
+            if (wine_semaphore_from_handle(submits[i].pSignalSemaphores[k])->handle_type ==
+                    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+            {
+                FIXME("Queue submissions with signalling D3D12-Fence compatible timeline semaphores not supported.\n");
+                return VK_ERROR_OUT_OF_HOST_MEMORY;
+            }
+        }
+    }
+    return vk_queue_submit_unwrap(queue, submit_count, submits, fence);
+}
+
+static void duplicate_array_for_unwrapping(struct conversion_context *ctx, void **ptr, unsigned int size)
+{
+    void *out;
+
+    if (!*ptr || !size)
+        return;
+
+    out = conversion_context_alloc(ctx, size);
+    memcpy(out, *ptr, size);
+    *ptr = out;
+}
+
+VkResult vk_queue_submit_2_unwrap(struct vulkan_queue *queue, uint32_t submit_count, const VkSubmitInfo2 *submits_orig,
+        VkFence fence, bool khr)
+{
+    struct conversion_context ctx;
+    VkSubmitInfo2 *submits;
+    unsigned int i, j;
+    VkResult ret;
+
+    init_conversion_context(&ctx);
+    MEMDUP(&ctx, submits, submits_orig, submit_count);
+    for (i = 0; i < submit_count; ++i)
+    {
+        duplicate_array_for_unwrapping(&ctx, (void **)&submits[i].pWaitSemaphoreInfos,
+                submits[i].waitSemaphoreInfoCount * sizeof(*submits[i].pWaitSemaphoreInfos));
+        for (j = 0; j < submits[i].waitSemaphoreInfoCount; ++j)
+            if (submits[i].pWaitSemaphoreInfos[j].semaphore)
+                ((VkSemaphoreSubmitInfo *)submits[i].pWaitSemaphoreInfos)[j].semaphore
+                        = wine_semaphore_from_handle(submits[i].pWaitSemaphoreInfos[j].semaphore)->obj.host.semaphore;
+
+        duplicate_array_for_unwrapping(&ctx, (void **)&submits[i].pSignalSemaphoreInfos,
+                submits[i].signalSemaphoreInfoCount * sizeof(*submits[i].pSignalSemaphoreInfos));
+        for (j = 0; j < submits[i].signalSemaphoreInfoCount; ++j)
+            if (submits[i].pSignalSemaphoreInfos[j].semaphore)
+                ((VkSemaphoreSubmitInfo *)submits[i].pSignalSemaphoreInfos)[j].semaphore
+                        = wine_semaphore_from_handle(submits[i].pSignalSemaphoreInfos[j].semaphore)->obj.host.semaphore;
+
+        if (submits[i].pCommandBufferInfos && submits[i].commandBufferInfoCount)
+        {
+            duplicate_array_for_unwrapping(&ctx, (void **)&submits[i].pCommandBufferInfos,
+                    submits[i].commandBufferInfoCount * sizeof(*submits[i].pCommandBufferInfos));
+            for (j = 0; j < submits[i].commandBufferInfoCount; ++j)
+                ((VkCommandBufferSubmitInfo *)submits[i].pCommandBufferInfos)[j].commandBuffer
+                        = wine_cmd_buffer_from_handle(submits[i].pCommandBufferInfos[j].commandBuffer)->host.command_buffer;
+        }
+    }
+    if (khr)
+        ret = queue->device->p_vkQueueSubmit2KHR(queue->host.queue, submit_count, submits, fence);
+    else
+        ret = queue->device->p_vkQueueSubmit2(queue->host.queue, submit_count, submits, fence);
+    free_conversion_context(&ctx);
+    return ret;
+}
+
+static VkResult vk_queue_submit_2(VkQueue queue_handle, uint32_t submit_count, const VkSubmitInfo2 *submits, VkFence fence, bool khr)
+{
+    struct vulkan_queue *queue = vulkan_queue_from_handle(queue_handle);
+    unsigned int i, k;
+
+    TRACE("(%p, %u, %p, %s)\n", queue_handle, submit_count, submits, wine_dbgstr_longlong(fence));
+
+    for (i = 0; i < submit_count; i++)
+    {
+        for (k = 0; k < submits[i].waitSemaphoreInfoCount; k++)
+        {
+            if (wine_semaphore_from_handle(submits[i].pWaitSemaphoreInfos[k].semaphore)->handle_type ==
+                    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+            {
+                FIXME("Queue submissions with waits on D3D12-Fence compatible timeline semaphores not supported.\n");
+                return VK_ERROR_OUT_OF_HOST_MEMORY;
+            }
+        }
+
+        for (k = 0; k < submits[i].signalSemaphoreInfoCount; k++)
+        {
+            if (wine_semaphore_from_handle(submits[i].pSignalSemaphoreInfos[k].semaphore)->handle_type ==
+                    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+            {
+                FIXME("Queue submissions signalling D3D12-Fence compatible timeline semaphores not supported.\n");
+                return VK_ERROR_OUT_OF_HOST_MEMORY;
+            }
+        }
+    }
+
+    return vk_queue_submit_2_unwrap(queue, submit_count, submits, fence, khr);
+}
+
+VkResult wine_vkQueueSubmit2(VkQueue queue, uint32_t submit_count, const VkSubmitInfo2 *submits, VkFence fence)
+{
+    return vk_queue_submit_2(queue, submit_count, submits, fence, false);
+}
+
+VkResult wine_vkQueueSubmit2KHR(VkQueue queue, uint32_t submit_count, const VkSubmitInfo2 *submits, VkFence fence)
+{
+    return vk_queue_submit_2(queue, submit_count, submits, fence, true);
+}
+
+VkResult wine_vkQueueBindSparse(VkQueue queue_handle, uint32_t bind_info_count, const VkBindSparseInfo *bind_info, VkFence fence)
+{
+    struct vulkan_queue *queue = vulkan_queue_from_handle(queue_handle);
+    struct wine_semaphore *semaphore;
+    struct conversion_context ctx;
+    VkBindSparseInfo *batch;
+    unsigned int i, j, k;
+    VkResult ret;
+
+    TRACE("(%p, %u, %p, 0x%s)\n", queue, bind_info_count, bind_info, wine_dbgstr_longlong(fence));
+
+    for (i = 0; i < bind_info_count; i++)
+    {
+        batch = (VkBindSparseInfo *)&bind_info[i];
+
+        for (k = 0; k < batch->waitSemaphoreCount; k++)
+        {
+            semaphore = wine_semaphore_from_handle(batch->pWaitSemaphores[k]);
+
+            if (semaphore->handle_type == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+            {
+                FIXME("Waiting on D3D12-Fence compatible timeline semaphore not supported.\n");
+                return VK_ERROR_OUT_OF_HOST_MEMORY;
+            }
+        }
+
+        for(k = 0; k < batch->signalSemaphoreCount; k++)
+        {
+            semaphore = wine_semaphore_from_handle(batch->pSignalSemaphores[k]);
+
+            if (semaphore->handle_type == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+            {
+                FIXME("Signalling D3D12-Fence compatible timeline semaphore not supported.\n");
+                return VK_ERROR_OUT_OF_HOST_MEMORY;
+            }
+        }
+    }
+
+    init_conversion_context(&ctx);
+    for (i = 0; i < bind_info_count; ++i)
+    {
+        batch = (VkBindSparseInfo *)&bind_info[i];
+        batch->pWaitSemaphores = unwrap_semaphore_array(batch->pWaitSemaphores, batch->waitSemaphoreCount, &ctx);
+        batch->pSignalSemaphores = unwrap_semaphore_array(batch->pSignalSemaphores, batch->signalSemaphoreCount, &ctx);
+
+        duplicate_array_for_unwrapping(&ctx, (void **)&batch->pBufferBinds, batch->bufferBindCount * sizeof(*batch->pBufferBinds));
+        for (j = 0; j < batch->bufferBindCount; ++j)
+        {
+            VkSparseBufferMemoryBindInfo *bind = (VkSparseBufferMemoryBindInfo *)&batch->pBufferBinds[j];
+            duplicate_array_for_unwrapping(&ctx, (void **)&bind->pBinds, bind->bindCount * sizeof(*bind->pBinds));
+            for (k = 0; k < bind->bindCount; ++k)
+                if (bind->pBinds[k].memory)
+                    ((VkSparseMemoryBind *)bind->pBinds)[k].memory = wine_device_memory_from_handle(bind->pBinds[k].memory)->host.device_memory;
+        }
+
+        duplicate_array_for_unwrapping(&ctx, (void **)&batch->pImageOpaqueBinds, batch->imageOpaqueBindCount * sizeof(*batch->pImageOpaqueBinds));
+        for (j = 0; j < batch->imageOpaqueBindCount; ++j)
+        {
+            VkSparseImageOpaqueMemoryBindInfo *bind = (VkSparseImageOpaqueMemoryBindInfo *)&batch->pImageOpaqueBinds[j];
+            duplicate_array_for_unwrapping(&ctx, (void **)&bind->pBinds, bind->bindCount * sizeof(*bind->pBinds));
+            for (k = 0; k < bind->bindCount; ++k)
+                if (bind->pBinds[k].memory)
+                    ((VkSparseMemoryBind *)bind->pBinds)[k].memory = wine_device_memory_from_handle(bind->pBinds[k].memory)->host.device_memory;
+        }
+
+        duplicate_array_for_unwrapping(&ctx, (void **)&batch->pImageBinds, batch->imageBindCount * sizeof(*batch->pImageBinds));
+        for (j = 0; j < batch->imageBindCount; ++j)
+        {
+            VkSparseImageMemoryBindInfo *bind = (VkSparseImageMemoryBindInfo *)&batch->pImageBinds[j];
+            duplicate_array_for_unwrapping(&ctx, (void **)&bind->pBinds, bind->bindCount * sizeof(*bind->pBinds));
+            for (k = 0; k < bind->bindCount; ++k)
+                if (bind->pBinds[k].memory)
+                    ((VkSparseImageMemoryBind *)bind->pBinds)[k].memory = wine_device_memory_from_handle(bind->pBinds[k].memory)->host.device_memory;
+        }
+    }
+    ret = queue->device->p_vkQueueBindSparse(queue->host.queue, bind_info_count, bind_info, fence);
+    free_conversion_context(&ctx);
+    return ret;
+}
diff --git a/dlls/winevulkan/vulkan_private.h b/dlls/winevulkan/vulkan_private.h
index 9bd2d4ebeea..a0aa1818cf5 100644
--- a/dlls/winevulkan/vulkan_private.h
+++ b/dlls/winevulkan/vulkan_private.h
@@ -170,6 +170,24 @@ static inline void free_conversion_context(struct conversion_context *pool)
         free(entry);
 }
 
+struct wine_semaphore
+{
+    struct vulkan_semaphore obj;
+    VkSemaphore semaphore;
+    VkSemaphore fence_timeline_semaphore;
+
+    VkExternalSemaphoreHandleTypeFlagBits export_types;
+
+    /* mutable members */
+    VkExternalSemaphoreHandleTypeFlagBits handle_type;
+    HANDLE handle;
+    struct
+    {
+        pthread_mutex_t mutex;
+        uint64_t virtual_value;
+    } *d3d12_fence_shm;
+};
+
 static inline void *conversion_context_alloc(struct conversion_context *pool, size_t size)
 {
     if (pool->used + size <= sizeof(pool->buffer))
@@ -247,4 +265,7 @@ static inline void init_unicode_string( UNICODE_STRING *str, const WCHAR *data )
     str->Buffer = (WCHAR *)data;
 }
 
+#define MEMDUP(ctx, dst, src, count) dst = conversion_context_alloc((ctx), sizeof(*(dst)) * (count)); \
+    memcpy((void *)(dst), (src), sizeof(*(dst)) * (count));
+
 #endif /* __WINE_VULKAN_PRIVATE_H */
diff --git a/include/wine/vulkan_driver.h b/include/wine/vulkan_driver.h
index 919e02ecaa9..3af7eb25cef 100644
--- a/include/wine/vulkan_driver.h
+++ b/include/wine/vulkan_driver.h
@@ -156,6 +156,17 @@ static inline struct vulkan_swapchain *vulkan_swapchain_from_handle( VkSwapchain
     return (struct vulkan_swapchain *)(UINT_PTR)handle;
 }
 
+struct vulkan_semaphore
+{
+    VULKAN_OBJECT_HEADER( VkSemaphore, semaphore );
+    BOOL d3d12_fence;
+};
+
+static inline struct vulkan_semaphore *vulkan_semaphore_from_handle( VkSemaphore handle )
+{
+    return (struct vulkan_semaphore *)(UINT_PTR)handle;
+}
+
 struct vulkan_funcs
 {
     /* Vulkan global functions. These are the only calls at this point a graphics driver
-- 
2.49.0

From a3af46bef93ee63fd12f18ebeb11f7e1fa42a547 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 27 Dec 2022 17:59:06 -0600
Subject: [PATCH 0884/1564] winevulkan: Only append VK_KHR_timeline_semaphore
 for Vk API version < 1.2.

CW-Bug-Id: #22526
---
 dlls/winevulkan/vulkan.c     | 28 +++++++++++++++++++++++++++-
 include/wine/vulkan_driver.h |  2 ++
 2 files changed, 29 insertions(+), 1 deletion(-)

diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index 7ea61349269..f8af4de2d85 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -361,6 +361,7 @@ static VkResult wine_vk_physical_device_init(struct wine_phys_dev *object, VkPhy
     BOOL have_memory_placed = FALSE, have_map_memory2 = FALSE;
     uint32_t num_host_properties, num_properties = 0;
     VkExtensionProperties *host_properties = NULL;
+    VkPhysicalDeviceProperties physdev_properties;
     BOOL have_external_memory_host = FALSE;
     VkResult res;
     unsigned int i, j;
@@ -370,6 +371,9 @@ static VkResult wine_vk_physical_device_init(struct wine_phys_dev *object, VkPhy
 
     instance->p_vkGetPhysicalDeviceMemoryProperties(host_physical_device, &object->memory_properties);
 
+    instance->p_vkGetPhysicalDeviceProperties(host_physical_device, &physdev_properties);
+    object->obj.api_version = physdev_properties.apiVersion;
+
     res = instance->p_vkEnumerateDeviceExtensionProperties(host_physical_device,
             NULL, &num_host_properties, NULL);
     if (res != VK_SUCCESS)
@@ -671,7 +675,8 @@ static VkResult wine_vk_device_convert_create_info(VkPhysicalDevice client_physi
         remove_extensions[remove_count++] = "VK_KHR_external_semaphore_win32";
     }
 
-    if (!find_extension(extensions, extensions_count, "VK_KHR_timeline_semaphore"))
+    if ((phys_dev->obj.api_version < VK_API_VERSION_1_2 || phys_dev->obj.instance->api_version < VK_API_VERSION_1_2)
+                && !find_extension(extensions, extensions_count, "VK_KHR_timeline_semaphore"))
         extra_extensions[extra_count++] = "VK_KHR_timeline_semaphore";
 
     if (phys_dev->map_placed_align)
@@ -1190,6 +1195,8 @@ VkResult wine_vkCreateInstance(const VkInstanceCreateInfo *create_info,
                 app_info->engineVersion);
         TRACE("API version %#x.\n", app_info->apiVersion);
 
+        instance->obj.api_version = app_info->apiVersion;
+
         if (app_info->pEngineName && !strcmp(app_info->pEngineName, "idTech"))
             instance->quirks |= WINEVULKAN_QUIRK_GET_DEVICE_PROC_ADDR;
     }
@@ -1920,6 +1927,25 @@ static void wine_vk_get_physical_device_external_semaphore_properties(struct win
             break;
         case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT:
         {
+            unsigned int i;
+
+            if (phys_dev->obj.api_version < VK_API_VERSION_1_2 ||
+                phys_dev->obj.instance->api_version < VK_API_VERSION_1_2)
+            {
+                for (i = 0; i < phys_dev->extension_count; i++)
+                {
+                    if (!strcmp(phys_dev->extensions[i].extensionName, "VK_KHR_timeline_semaphore"))
+                        break;
+                }
+                if (i == phys_dev->extension_count)
+                {
+                    properties->exportFromImportedHandleTypes = 0;
+                    properties->compatibleHandleTypes = 0;
+                    properties->externalSemaphoreFeatures = 0;
+                    return;
+                }
+            }
+
             if ((p_semaphore_type_info = find_next_struct(&semaphore_info_dup, VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO)))
             {
                 p_semaphore_type_info->semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE;
diff --git a/include/wine/vulkan_driver.h b/include/wine/vulkan_driver.h
index 3af7eb25cef..fe989bbf809 100644
--- a/include/wine/vulkan_driver.h
+++ b/include/wine/vulkan_driver.h
@@ -82,6 +82,7 @@ struct vulkan_instance
 #undef USE_VK_FUNC
     void (*p_insert_object)( struct vulkan_instance *instance, struct vulkan_object *obj );
     void (*p_remove_object)( struct vulkan_instance *instance, struct vulkan_object *obj );
+    uint32_t api_version;
 };
 
 static inline struct vulkan_instance *vulkan_instance_from_handle( VkInstance handle )
@@ -94,6 +95,7 @@ struct vulkan_physical_device
 {
     VULKAN_OBJECT_HEADER( VkPhysicalDevice, physical_device );
     struct vulkan_instance *instance;
+    uint32_t api_version;
     bool has_swapchain_maintenance1;
 };
 
-- 
2.49.0

From 41c59aed472f6d4872ee66341e28c48c2564f48c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 20 Jan 2025 15:51:39 +0100
Subject: [PATCH 0885/1564] winevulkan: Force copying VkSubmitInfo[2]
 structures.

Based on patches by Derek Lesho.

CW-Bug-Id: #22526
---
 dlls/winevulkan/make_vulkan      | 48 ++++++++++++++++++++++----------
 dlls/winevulkan/vulkan.c         |  2 +-
 dlls/winevulkan/vulkan_private.h |  2 ++
 3 files changed, 36 insertions(+), 16 deletions(-)

diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index 53edd964673..a1e26f01294 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -182,7 +182,7 @@ FUNCTION_OVERRIDES = {
     "vkSignalSemaphore" : {"dispatch" : True},
     "vkWaitSemaphores" : {"dispatch" : True},
     "vkQueueBindSparse" : {"dispatch" : True},
-    "vkQueueSubmit" : {"dispatch" : True},
+    "vkQueueSubmit" : {"dispatch" : True, "extra_param" : "pSubmits"},
     "vkQueueSubmit2" : {"dispatch" : True},
     "vkDestroySemaphore" : {"dispatch" : True},
 
@@ -335,11 +335,16 @@ STRUCT_CHAIN_CONVERSIONS = {
     "VkPhysicalDeviceImageFormatInfo2": [],
     "VkPhysicalDeviceExternalSemaphoreInfo": [],
     "VkSemaphoreCreateInfo": [],
-    "VkSubmitInfo": [],
+    "VkSubmitInfo": ["VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR"],
     "VkSubmitInfo2": [],
     "VkBindSparseInfo" : [],
 }
 
+STRUCT_COPY = {
+    "VkSubmitInfo",
+    "VkSubmitInfo2",
+};
+
 # Some struct members are conditionally ignored and callers are free to leave them uninitialized.
 # We can't deduce that from XML, so we allow expressing it here.
 MEMBER_LENGTH_EXPRESSIONS = {
@@ -1592,15 +1600,15 @@ class VkMember(VkVariable):
                         values=values, object_type=object_type, bit_width=bit_width, returnedonly=returnedonly,
                         parent=parent, selection=selection, selector=selector)
 
-    def copy(self, input, output, direction, conv, unwrap, parent_const, conversions):
+    def copy(self, input, output, direction, conv, unwrap, copy, parent_const, conversions):
         """ Helper method for use by conversion logic to generate a C-code statement to copy this member.
             - `conv` indicates whether the statement is in a struct alignment conversion path. """
 
         win_type = "win32" if conv else "win64"
         suffix = convert_suffix(direction, win_type, unwrap, self.is_wrapped())
         is_const = self.is_const() if self.is_pointer() else parent_const
 
-        if self.needs_conversion(conv, unwrap, direction, False):
+        if self.needs_conversion(conv, unwrap, direction, False) and not copy:
             if self.is_dynamic_array():
                 # Array length is either a variable name (string) or an int.
                 count = self.get_dyn_array_len(input, conv)
@@ -1650,6 +1658,11 @@ class VkMember(VkVariable):
             for l in self.array_lens:
                 bytes_count = "{0} * ".format(l) + bytes_count
             return "memcpy({0}{1}, {2}{1}, {3});\n".format(output, self.name, input, bytes_count)
+        elif self.is_dynamic_array() and copy:
+            if self.type == "void":
+                return "MEMDUP_VOID(ctx, {0}{1}, {2}{1}, {3});\n".format(output, self.name, input, self.get_dyn_array_len(input, conv))
+            else:
+                return "MEMDUP(ctx, {0}{1}, {2}{1}, {3});\n".format(output, self.name, input, self.get_dyn_array_len(input, conv))
         elif conv and direction == Direction.OUTPUT and self.is_pointer():
             return "{0}{1} = PtrToUlong({2}{1});\n".format(output, self.name, input)
         elif conv and direction == Direction.INPUT and self.is_pointer():
@@ -2374,17 +2387,21 @@ class VkStruct(Sequence):
 
 
 class StructConversionFunction(object):
-    def __init__(self, struct, direction, conv, unwrap, const):
+    def __init__(self, struct, direction, conv, unwrap, const, copy=False):
         self.direction = direction
         self.operand = struct
         self.type = struct.name
         self.conv = conv
         self.unwrap = unwrap
         self.const = const
+        self.copy = copy
 
-        name = "convert_{0}_".format(self.type)
-        win_type = "win32" if self.conv else "win64"
-        name += convert_suffix(direction, win_type, unwrap, struct.is_wrapped())
+        if copy:
+            name = "copy_{0}".format(self.type)
+        else:
+            name = "convert_{0}_".format(self.type)
+            win_type = "win32" if self.conv else "win64"
+            name += convert_suffix(direction, win_type, unwrap, struct.is_wrapped())
         self.name = name
 
     def __eq__(self, other):
@@ -2416,7 +2433,7 @@ class StructConversionFunction(object):
 
         body = ""
 
-        if not self.conv:
+        if not self.conv and not self.copy:
             body += "#ifdef _WIN64\n"
 
         needs_alloc = self.direction != Direction.OUTPUT and self.operand.needs_alloc(self.conv, self.unwrap)
@@ -2426,8 +2443,11 @@ class StructConversionFunction(object):
         if self.direction == Direction.OUTPUT and self.const:
             win_type = "const " + win_type
 
-        if self.conv:
+        if self.copy:
+            body += "void {0}(".format(self.name)
+        else:
             body += "static void {0}(".format(self.name)
+        if self.conv:
 
             if self.direction == Direction.OUTPUT:
                 params = ["const {0} *in".format(self.type), "{0} *out".format(win_type)]
@@ -2444,8 +2464,6 @@ class StructConversionFunction(object):
             body += ")\n"
 
         else:
-            body += "static void {0}(".format(self.name)
-
             params = ["const {0} *in".format(self.type), "{0} *out".format(self.type)]
 
             # Generate parameter list
@@ -2488,7 +2506,7 @@ class StructConversionFunction(object):
                 body += " || ".join("selector == {}".format(s) for s in m.selection)
                 body += ")\n    "
 
-            body += "    " + m.copy("in->", "out->", self.direction, self.conv, self.unwrap, self.const, conversions)
+            body += "    " + m.copy("in->", "out->", self.direction, self.conv, self.unwrap, self.copy, self.const, conversions)
 
         if needs_extensions:
             if self.conv and self.direction == Direction.INPUT:
@@ -2547,7 +2565,7 @@ class StructConversionFunction(object):
                     if m.name == "pNext":
                         copy_body += ident + "out_ext->pNext = NULL;\n"
                         continue
-                    copy_body += ident + m.copy("in_ext->", "out_ext->", self.direction, self.conv, Unwrap.HOST, self.const, conversions)
+                    copy_body += ident + m.copy("in_ext->", "out_ext->", self.direction, self.conv, Unwrap.HOST, self.copy, self.const, conversions)
 
                 # Generate the definition of "in_ext" if we need it
                 if "in_ext->" in copy_body:
@@ -2582,7 +2600,7 @@ class StructConversionFunction(object):
             body += "        FIXME(\"Unexpected pNext\\n\");\n"
 
         body += "}\n"
-        if not self.conv:
+        if not self.conv and not self.copy:
             body += "#endif /* _WIN64 */\n"
         body += "\n"
 
diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index f8af4de2d85..c23c19edf1b 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -3404,7 +3404,7 @@ VkResult vk_queue_submit_unwrap(struct vulkan_queue *queue, uint32_t submit_coun
     return ret;
 }
 
-VkResult wine_vkQueueSubmit(VkQueue queue_handle, uint32_t submit_count, const VkSubmitInfo *submits, VkFence fence)
+VkResult wine_vkQueueSubmit(VkQueue queue_handle, uint32_t submit_count, const VkSubmitInfo *submits, VkFence fence, void *submits_win_ptr)
 {
     struct vulkan_queue *queue = vulkan_queue_from_handle(queue_handle);
     unsigned int i, k;
diff --git a/dlls/winevulkan/vulkan_private.h b/dlls/winevulkan/vulkan_private.h
index a0aa1818cf5..c36c52ec327 100644
--- a/dlls/winevulkan/vulkan_private.h
+++ b/dlls/winevulkan/vulkan_private.h
@@ -267,5 +267,7 @@ static inline void init_unicode_string( UNICODE_STRING *str, const WCHAR *data )
 
 #define MEMDUP(ctx, dst, src, count) dst = conversion_context_alloc((ctx), sizeof(*(dst)) * (count)); \
     memcpy((void *)(dst), (src), sizeof(*(dst)) * (count));
+#define MEMDUP_VOID(ctx, dst, src, size) dst = conversion_context_alloc((ctx), size); \
+    memcpy((void *)(dst), (src), size);
 
 #endif /* __WINE_VULKAN_PRIVATE_H */
-- 
2.49.0

From 3fea66f351255efe5b1d4afe0a99c9b52c5b987b Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 31 Jul 2023 11:12:21 -0600
Subject: [PATCH 0886/1564] winevulkan: Support waiting for and signalling
 d3d12 shared fences.

CW-Bug-Id: #22526
---
 dlls/winevulkan/vulkan.c         | 718 +++++++++++++++++++++++++------
 dlls/winevulkan/vulkan_private.h |  23 +-
 include/wine/vulkan_driver.h     |  17 +
 3 files changed, 622 insertions(+), 136 deletions(-)

diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index c23c19edf1b..974c1f98d6d 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -25,6 +25,13 @@
 #include <time.h>
 #include <unistd.h>
 #include <stdbool.h>
+#include <errno.h>
+#include <stdio.h>
+#include <assert.h>
+#include <limits.h>
+#ifdef HAVE_SYS_SYSCALL_H
+# include <sys/syscall.h>
+#endif
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -32,6 +39,7 @@
 #include "winnt.h"
 #include "winioctl.h"
 #include "wine/server.h"
+#include "wine/list.h"
 
 #include "vulkan_private.h"
 #include "wine/vulkan_driver.h"
@@ -41,6 +49,8 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(vulkan);
 
+static int debug_level;
+
 static PFN_vkCreateInstance p_vkCreateInstance;
 static PFN_vkEnumerateInstanceVersion p_vkEnumerateInstanceVersion;
 static PFN_vkEnumerateInstanceExtensionProperties p_vkEnumerateInstanceExtensionProperties;
@@ -191,6 +201,38 @@ static void append_debug_utils_object(const VkDebugUtilsObjectNameInfoEXT *objec
     dst->object_name_len = append_string(object->pObjectName, strings, strings_len);
 }
 
+static void signal_timeline_sem(struct vulkan_device *device, VkSemaphore sem, uint64_t *value)
+{
+    /* May be called from native thread. */
+    struct VkSemaphoreSignalInfo info = { 0 };
+    VkResult res;
+
+    info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO;
+    info.semaphore = sem;
+    ++*value;
+    info.value = *value;
+    if (device->physical_device->api_version < VK_API_VERSION_1_2 || device->physical_device->instance->api_version < VK_API_VERSION_1_2)
+        res = device->p_vkSignalSemaphoreKHR(device->host.device, &info);
+    else
+        res = device->p_vkSignalSemaphore(device->host.device, &info);
+    if (res != VK_SUCCESS)
+        fprintf(stderr, "err:winevulkan:signal_timeline_sem vkSignalSemaphore failed, res=%d.\n", res);
+}
+
+static VkResult wait_semaphores(struct vulkan_device *device, const VkSemaphoreWaitInfo *wait_info, uint64_t timeout)
+{
+    if (device->physical_device->api_version < VK_API_VERSION_1_2 || device->physical_device->instance->api_version < VK_API_VERSION_1_2)
+        return device->p_vkWaitSemaphoresKHR(device->host.device, wait_info, timeout);
+    return device->p_vkWaitSemaphores(device->host.device, wait_info, timeout);
+}
+
+static VkResult get_semaphore_value(struct vulkan_device *device, VkSemaphore sem, uint64_t *value)
+{
+    if (device->physical_device->api_version < VK_API_VERSION_1_2 || device->physical_device->instance->api_version < VK_API_VERSION_1_2)
+        return device->p_vkGetSemaphoreCounterValueKHR(device->host.device, sem, value);
+    return device->p_vkGetSemaphoreCounterValue(device->host.device, sem, value);
+}
+
 static VkBool32 debug_utils_callback_conversion(VkDebugUtilsMessageSeverityFlagBitsEXT severity,
     VkDebugUtilsMessageTypeFlagsEXT message_types,
     const VkDebugUtilsMessengerCallbackDataEXT *callback_data,
@@ -1035,6 +1077,10 @@ VkResult wine_vkCreateDevice(VkPhysicalDevice client_physical_device, const VkDe
         native_create_device_context = callback->context;
     }
 
+    pthread_mutex_init(&device->signaller_mutex, NULL);
+    list_init(&device->sem_poll_list);
+    list_init(&device->free_fence_ops_list);
+
     init_conversion_context(&ctx);
     res = wine_vk_device_convert_create_info(client_physical_device, &ctx, create_info, &create_info_host);
     if (res == VK_SUCCESS)
@@ -1073,6 +1119,7 @@ VkResult wine_vkCreateDevice(VkPhysicalDevice client_physical_device, const VkDe
     if (res != VK_SUCCESS)
     {
         WARN("Failed to create device, res=%d.\n", res);
+        pthread_mutex_destroy(&device->signaller_mutex);
         free(device);
         return res;
     }
@@ -1216,6 +1263,7 @@ VkResult wine_vkCreateInstance(const VkInstanceCreateInfo *create_info,
 
 void wine_vkDestroyDevice(VkDevice client_device, const VkAllocationCallbacks *allocator)
 {
+    struct pending_d3d12_fence_op *op, *next;
     struct vulkan_device *device = vulkan_device_from_handle(client_device);
     struct vulkan_instance *instance = device->physical_device->instance;
     unsigned int i;
@@ -1225,6 +1273,26 @@ void wine_vkDestroyDevice(VkDevice client_device, const VkAllocationCallbacks *a
     if (!device)
         return;
 
+    if (device->signaller_thread)
+    {
+        TRACE("Shutting down signaller thread.\n");
+        pthread_mutex_lock(&device->signaller_mutex);
+        device->stop = 1;
+        signal_timeline_sem(device, device->sem_poll_update.sem, &device->sem_poll_update.value);
+        pthread_mutex_unlock(&device->signaller_mutex);
+        pthread_join(device->signaller_thread, NULL);
+        device->p_vkDestroySemaphore(device->host.device, device->sem_poll_update.sem, NULL);
+        pthread_cond_destroy(&device->sem_poll_updated_cond);
+        TRACE("Signaller thread shut down.\n");
+    }
+    pthread_mutex_destroy(&device->signaller_mutex);
+
+    LIST_FOR_EACH_ENTRY_SAFE(op, next, &device->free_fence_ops_list, struct pending_d3d12_fence_op, entry)
+    {
+        device->p_vkDestroySemaphore(device->host.device, op->local_sem.sem, NULL);
+        free(op);
+    }
+
     device->p_vkDestroyDevice(device->host.device, NULL /* pAllocator */);
     for (i = 0; i < device->queue_count; i++)
         vulkan_instance_remove_object(instance, &device->queues[i].obj);
@@ -2900,6 +2968,363 @@ static void d3d12_semaphore_unlock(struct wine_semaphore *semaphore)
     pthread_mutex_unlock(&semaphore->d3d12_fence_shm->mutex);
 }
 
+static VkSemaphore create_timeline_semaphore(struct vulkan_device *device)
+{
+    VkSemaphoreTypeCreateInfo timeline_info = { 0 };
+    VkSemaphoreCreateInfo create_info = { 0 };
+    VkSemaphore sem = 0;
+    VkResult res;
+
+    timeline_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
+    timeline_info.semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE;
+    create_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
+    create_info.pNext = &timeline_info;
+
+    res = device->p_vkCreateSemaphore(device->host.device, &create_info, NULL, &sem);
+    if (res != VK_SUCCESS)
+        ERR("vkCreateSemaphore failed, res=%d\n", res);
+    return sem;
+}
+
+static void release_fence_op(struct vulkan_device *device, struct pending_d3d12_fence_op *op)
+{
+    list_remove(&op->entry);
+    vulkan_instance_remove_object(device->physical_device->instance, &op->semaphore->obj.obj);
+    vulkan_object_init(&op->semaphore->obj.obj, op->semaphore->semaphore);
+    vulkan_instance_insert_object(device->physical_device->instance, &op->semaphore->obj.obj);
+    op->semaphore = NULL;
+    list_add_head(&device->free_fence_ops_list, &op->entry);
+}
+
+static int wait_info_realloc(VkSemaphoreWaitInfo *wait_info, uint32_t *wait_alloc_count)
+{
+    VkSemaphore *new_sem;
+    uint64_t *new_values;
+
+    if (wait_info->semaphoreCount + 1 <= *wait_alloc_count)
+        return 1;
+    new_sem = realloc((void *)wait_info->pSemaphores, *wait_alloc_count * 2 * sizeof(*new_sem));
+    if (!new_sem)
+    {
+        fprintf(stderr, "err:winevulkan:wait_info_realloc no memory.\n");
+        return 0;
+    }
+    new_values = realloc((void *)wait_info->pValues, *wait_alloc_count * 2 * sizeof(*new_values));
+    if (!new_values)
+    {
+        fprintf(stderr, "err:winevulkan:wait_info_realloc no memory.\n");
+        return 0;
+    }
+    *wait_alloc_count *= 2;
+    wait_info->pSemaphores = new_sem;
+    wait_info->pValues = new_values;
+    return 1;
+}
+
+static int add_sem_wait(VkSemaphoreWaitInfo *wait_info, uint32_t *wait_alloc_count, VkSemaphore sem, uint64_t value)
+{
+    if (!wait_info_realloc(wait_info, wait_alloc_count))
+        return 0;
+    ((VkSemaphore *)wait_info->pSemaphores)[wait_info->semaphoreCount] = sem;
+    ((uint64_t *)wait_info->pValues)[wait_info->semaphoreCount] = value;
+    ++wait_info->semaphoreCount;
+    return 1;
+}
+
+static int semaphore_process(struct vulkan_device *device, struct wine_semaphore *sem,
+        VkSemaphoreWaitInfo *wait_info, uint32_t *wait_alloc_count)
+{
+    /* Called from native thread. */
+    struct pending_d3d12_fence_op *op, *op2;
+    uint64_t global_sem_wait_value;
+    int virtual_value_updated = 0;
+    uint64_t value, virtual_value;
+    VkResult res;
+
+    /* Check local pending signal ops completion, update shared semaphore. */
+    d3d12_semaphore_lock( sem );
+    LIST_FOR_EACH_ENTRY_SAFE(op, op2, &sem->pending_signals, struct pending_d3d12_fence_op, entry)
+    {
+        if (op->virtual_value <= sem->d3d12_fence_shm->virtual_value)
+            goto signal_op_complete;
+
+        res = get_semaphore_value(device, op->local_sem.sem, &value);
+        if (res != VK_SUCCESS)
+        {
+            fprintf(stderr, "err:winevulkan:semaphore_process vkGetSemaphoreCounterValue failed, res=%d.\n", res);
+            goto signal_op_complete;
+        }
+        if (value <= op->local_sem.value)
+        {
+            if (!add_sem_wait(wait_info, wait_alloc_count, op->local_sem.sem, op->local_sem.value + 1))
+            {
+                d3d12_semaphore_unlock(sem);
+                return 0;
+            }
+            continue;
+        }
+
+        sem->d3d12_fence_shm->virtual_value = op->virtual_value;
+        virtual_value_updated = 1;
+signal_op_complete:
+        ++op->local_sem.value;
+        release_fence_op(device, op);
+    }
+
+    if (virtual_value_updated)
+        signal_timeline_sem(device, sem->fence_timeline_semaphore, &sem->d3d12_fence_shm->physical_value);
+    global_sem_wait_value = sem->d3d12_fence_shm->physical_value + 1;
+    virtual_value = sem->d3d12_fence_shm->virtual_value;
+    d3d12_semaphore_unlock(sem);
+
+    /* Complete satisfied local waits. */
+    LIST_FOR_EACH_ENTRY_SAFE(op, op2, &sem->pending_waits, struct pending_d3d12_fence_op, entry)
+    {
+        if (op->virtual_value > virtual_value)
+            continue;
+
+        signal_timeline_sem(device, op->local_sem.sem, &op->local_sem.value);
+        release_fence_op(device, op);
+    }
+
+    /* Only poll shared semaphore if there are waits pending. */
+    if (list_empty(&sem->pending_waits))
+        return 1;
+    return add_sem_wait(wait_info, wait_alloc_count, sem->fence_timeline_semaphore, global_sem_wait_value);
+}
+
+#define SIGNALLER_INITIAL_WAIT_COUNT 256
+
+void *signaller_worker(void *arg)
+{
+#ifdef HAVE_SYS_SYSCALL_H
+    int unix_tid = syscall( __NR_gettid );
+#else
+    int unix_tid = -1;
+#endif
+    struct vulkan_device *device = arg;
+    struct wine_semaphore *sem;
+    VkSemaphoreWaitInfo wait_info = { 0 };
+    uint32_t wait_alloc_count = 0;
+    VkResult res;
+
+    if (debug_level)
+        fprintf(stderr, "[%d] msg:winevulkan:signaller_worker started.\n", unix_tid);
+
+    wait_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO;
+    wait_info.flags = VK_SEMAPHORE_WAIT_ANY_BIT;
+    wait_alloc_count = SIGNALLER_INITIAL_WAIT_COUNT;
+    if (!(wait_info.pSemaphores = malloc(sizeof(*wait_info.pSemaphores) * wait_alloc_count)))
+    {
+        fprintf(stderr, "err:winevulkan:signaller_worker no memory.\n");
+        return NULL;
+    }
+    if (!(wait_info.pValues = malloc(sizeof(*wait_info.pValues) * wait_alloc_count)))
+    {
+        fprintf(stderr, "err:winevulkan:signaller_worker no memory.\n");
+        free((void *)wait_info.pSemaphores);
+        return NULL;
+    }
+
+    for (;;)
+    {
+        pthread_mutex_lock(&device->signaller_mutex);
+        if (device->stop)
+        {
+            pthread_mutex_unlock(&device->signaller_mutex);
+            break;
+        }
+        wait_info.semaphoreCount = 1;
+        *(VkSemaphore *)wait_info.pSemaphores = device->sem_poll_update.sem;
+        *(uint64_t *)wait_info.pValues = device->sem_poll_update.value + 1;
+        LIST_FOR_EACH_ENTRY(sem, &device->sem_poll_list, struct wine_semaphore, poll_entry)
+        {
+            if (!semaphore_process(device, sem, &wait_info, &wait_alloc_count))
+            {
+                pthread_mutex_unlock(&device->signaller_mutex);
+                break;
+            }
+        }
+        device->sem_poll_update_value = device->sem_poll_update.value;
+        pthread_cond_signal(&device->sem_poll_updated_cond);
+        pthread_mutex_unlock(&device->signaller_mutex);
+        while ((res = wait_semaphores(device, &wait_info, 3000000000ull)) == VK_TIMEOUT)
+        {
+            if (wait_info.semaphoreCount > 1)
+                fprintf(stderr, "err:winevulkan:signaller_worker wait timed out with non-empty poll list.\n");
+        }
+        if (res != VK_SUCCESS)
+        {
+            fprintf(stderr, "err:winevulkan:signaller_worker error waiting for semaphores, vr %d.\n", res);
+            break;
+        }
+    }
+
+    free((void *)wait_info.pSemaphores);
+    free((void *)wait_info.pValues);
+    if (debug_level)
+        fprintf(stderr, "[%d] msg:winevulkan:signaller_worker exiting.\n", unix_tid);
+
+    return NULL;
+}
+
+static void register_sem_poll(struct vulkan_device *device, struct wine_semaphore *semaphore)
+{
+    pthread_mutex_lock(&device->signaller_mutex);
+    if (!device->signaller_thread)
+    {
+        device->sem_poll_update.sem = create_timeline_semaphore(device);
+        device->sem_poll_update.value = 0;
+        pthread_cond_init(&device->sem_poll_updated_cond, NULL);
+        if (TRACE_ON(vulkan))
+            debug_level = 4;
+        else if (WARN_ON(vulkan))
+            debug_level = 3;
+        else if (FIXME_ON(vulkan))
+            debug_level = 2;
+        else if (ERR_ON(vulkan))
+            debug_level = 1;
+        else
+            debug_level = 0;
+        if (pthread_create(&device->signaller_thread, NULL, signaller_worker, device))
+            ERR("Failed to create signaller_worker.\n");
+        WARN("d3d12 fence used, created signaller worker.\n");
+    }
+    assert(!semaphore->poll_entry.next);
+    list_add_head(&device->sem_poll_list, &semaphore->poll_entry);
+    signal_timeline_sem(device, device->sem_poll_update.sem, &device->sem_poll_update.value);
+    pthread_mutex_unlock(&device->signaller_mutex);
+}
+
+static void update_sem_poll_wait_processed(struct vulkan_device *device)
+{
+    uint64_t update_value;
+
+    signal_timeline_sem(device, device->sem_poll_update.sem, &device->sem_poll_update.value);
+    update_value = device->sem_poll_update.value;
+    while (device->sem_poll_update_value < update_value)
+        pthread_cond_wait(&device->sem_poll_updated_cond, &device->signaller_mutex);
+}
+
+static void unregister_sem_poll(struct vulkan_device *device, struct wine_semaphore *semaphore)
+{
+    struct list *entry;
+
+    pthread_mutex_lock(&device->signaller_mutex);
+    list_remove(&semaphore->poll_entry);
+    semaphore->poll_entry.next = semaphore->poll_entry.prev = NULL;
+    update_sem_poll_wait_processed(device);
+    pthread_mutex_unlock(&device->signaller_mutex);
+
+    while ((entry = list_head(&semaphore->pending_waits)))
+        release_fence_op(device, CONTAINING_RECORD(entry, struct pending_d3d12_fence_op, entry));
+    while ((entry = list_head(&semaphore->pending_signals)))
+        release_fence_op(device, CONTAINING_RECORD(entry, struct pending_d3d12_fence_op, entry));
+}
+
+static struct pending_d3d12_fence_op *get_free_fence_op(struct vulkan_device *device)
+{
+    struct pending_d3d12_fence_op *op;
+    struct list *entry;
+
+    if ((entry = list_head(&device->free_fence_ops_list)))
+    {
+        list_remove(entry);
+        return CONTAINING_RECORD(entry, struct pending_d3d12_fence_op, entry);
+    }
+
+    if (!(op = malloc(sizeof(*op))))
+    {
+        ERR("No memory.\n");
+        return NULL;
+    }
+    op->local_sem.sem = create_timeline_semaphore(device);
+    op->local_sem.value = 0;
+    ++device->allocated_fence_ops_count;
+    TRACE("Total allocated fence ops %u.\n", device->allocated_fence_ops_count);
+    return op;
+}
+
+static void add_sem_wait_op(struct vulkan_device *device, struct wine_semaphore *semaphore, uint64_t virtual_value,
+        VkSemaphore *phys_semaphore, uint64_t *phys_wait_value)
+{
+    struct pending_d3d12_fence_op *op;
+
+    pthread_mutex_lock(&device->signaller_mutex);
+    LIST_FOR_EACH_ENTRY(op, &semaphore->pending_waits, struct pending_d3d12_fence_op, entry)
+    {
+        if (op->virtual_value == virtual_value)
+        {
+            *phys_semaphore = op->local_sem.sem;
+            *phys_wait_value = op->local_sem.value + 1;
+            pthread_mutex_unlock(&device->signaller_mutex);
+            return;
+        }
+    }
+    if ((op = get_free_fence_op(device)))
+    {
+        op->virtual_value = virtual_value;
+        *phys_semaphore = op->local_sem.sem;
+        *phys_wait_value = op->local_sem.value + 1;
+        op->semaphore = semaphore;
+        list_add_tail(&semaphore->pending_waits, &op->entry);
+        vulkan_instance_remove_object(device->physical_device->instance, &semaphore->obj.obj);
+        vulkan_object_init(&semaphore->obj.obj, op->local_sem.sem);
+        vulkan_instance_insert_object(device->physical_device->instance, &semaphore->obj.obj);
+
+        signal_timeline_sem(device, device->sem_poll_update.sem, &device->sem_poll_update.value);
+        TRACE("added wait op, semaphore %p, %s, temp sem %s, %s.\n", semaphore, wine_dbgstr_longlong(virtual_value),
+                wine_dbgstr_longlong(op->local_sem.sem), wine_dbgstr_longlong(op->local_sem.value));
+    }
+    else
+    {
+        *phys_semaphore = 0;
+        *phys_wait_value = 0;
+    }
+    pthread_mutex_unlock(&device->signaller_mutex);
+}
+
+static void add_sem_signal_op(struct vulkan_device *device, struct wine_semaphore *semaphore, uint64_t virtual_value,
+        VkSemaphore *phys_semaphore, uint64_t *phys_signal_value, BOOL signal_immediate)
+{
+    struct pending_d3d12_fence_op *op;
+    uint64_t value;
+
+    pthread_mutex_lock(&device->signaller_mutex);
+    if ((op = get_free_fence_op(device)))
+    {
+        op->virtual_value = virtual_value;
+        *phys_semaphore = op->local_sem.sem;
+        *phys_signal_value = op->local_sem.value + 1;
+        op->semaphore = semaphore;
+        list_add_tail(&semaphore->pending_signals, &op->entry);
+        vulkan_instance_remove_object(device->physical_device->instance, &semaphore->obj.obj);
+        vulkan_object_init(&semaphore->obj.obj, op->local_sem.sem);
+        vulkan_instance_insert_object(device->physical_device->instance, &semaphore->obj.obj);
+
+        if (signal_immediate)
+        {
+            value = op->local_sem.value;
+            signal_timeline_sem(device, op->local_sem.sem, &value);
+            update_sem_poll_wait_processed(device);
+            TRACE("signal op %p, semaphore %p, %s, temp sem %s, %s.\n", op, semaphore, wine_dbgstr_longlong(virtual_value),
+                    wine_dbgstr_longlong(op->local_sem.sem), wine_dbgstr_longlong(op->local_sem.value));
+        }
+        else
+        {
+            signal_timeline_sem(device, device->sem_poll_update.sem, &device->sem_poll_update.value);
+            TRACE("added signal op, semaphore %p, %s, temp sem %s, %s.\n", semaphore, wine_dbgstr_longlong(virtual_value),
+                    wine_dbgstr_longlong(op->local_sem.sem), wine_dbgstr_longlong(op->local_sem.value));
+        }
+    }
+    else
+    {
+        *phys_semaphore = 0;
+        *phys_signal_value = 0;
+    }
+    pthread_mutex_unlock(&device->signaller_mutex);
+}
+
 VkResult wine_vkCreateSemaphore(VkDevice client_device, const VkSemaphoreCreateInfo *create_info,
         const VkAllocationCallbacks *allocator, VkSemaphore *semaphore)
 {
@@ -2927,6 +3352,9 @@ VkResult wine_vkCreateSemaphore(VkDevice client_device, const VkSemaphoreCreateI
     if (!(object = calloc(1, sizeof(*object))))
         return VK_ERROR_OUT_OF_HOST_MEMORY;
 
+    list_init(&object->pending_signals);
+    list_init(&object->pending_waits);
+
     object->handle = INVALID_HANDLE_VALUE;
 
     if ((export_semaphore_info = find_next_struct(&create_info_dup, VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO)))
@@ -3064,6 +3492,12 @@ VkResult wine_vkCreateSemaphore(VkDevice client_device, const VkSemaphoreCreateI
             device->p_vkDestroySemaphore(device->host.device, object->fence_timeline_semaphore, NULL);
         free(object);
     }
+    else if (object->handle_type == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+        register_sem_poll(device, object);
+    if (res == VK_SUCCESS)
+    {
+        TRACE("-> %p (native %#llx, shared %#llx).\n", object, (long long)object->semaphore, (long long)object->fence_timeline_semaphore);
+    }
 
     return res;
 }
@@ -3095,6 +3529,9 @@ void wine_vkDestroySemaphore(VkDevice client_device, VkSemaphore semaphore_handl
     if (!semaphore)
         return;
 
+    if (semaphore->poll_entry.next)
+        unregister_sem_poll(device, semaphore);
+
     if (semaphore->handle != INVALID_HANDLE_VALUE)
         NtClose(semaphore->handle);
 
@@ -3126,6 +3563,9 @@ VkResult wine_vkImportSemaphoreWin32HandleKHR(VkDevice client_device,
 
     TRACE("(%p, %p). semaphore = %p handle = %p\n", device, handle_info, semaphore, handle_info->handle);
 
+    if (semaphore->poll_entry.next)
+        unregister_sem_poll(device, semaphore);
+
     if (handle_info->handleType == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT && !semaphore->fence_timeline_semaphore)
     {
         type_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
@@ -3228,6 +3668,9 @@ VkResult wine_vkImportSemaphoreWin32HandleKHR(VkDevice client_device,
             NtUnmapViewOfSection(GetCurrentProcess(), semaphore->d3d12_fence_shm);
 
         *semaphore = output_semaphore;
+        assert(!semaphore->poll_entry.next);
+        if (semaphore->handle_type == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+            register_sem_poll(device, semaphore);
     }
     else
     {
@@ -3243,20 +3686,10 @@ VkResult wine_vkImportSemaphoreWin32HandleKHR(VkDevice client_device,
     return res;
 }
 
-static VkResult vk_get_semaphore_counter_value(VkDevice device_handle, VkSemaphore semaphore_handle, uint64_t *value, bool khr)
-{
-    struct wine_semaphore *semaphore = wine_semaphore_from_handle(semaphore_handle);
-    struct vulkan_device *device = vulkan_device_from_handle(device_handle);
-
-    if (khr)
-        return device->p_vkGetSemaphoreCounterValueKHR(device->host.device, semaphore->obj.host.semaphore, value);
-    else
-        return device->p_vkGetSemaphoreCounterValue(device->host.device, semaphore->obj.host.semaphore, value);
-}
-
 static VkResult wine_vk_get_semaphore_counter_value(VkDevice device_handle, VkSemaphore semaphore_handle, uint64_t *value, bool khr)
 {
     struct wine_semaphore *semaphore = wine_semaphore_from_handle(semaphore_handle);
+    struct vulkan_device *device = vulkan_device_from_handle(device_handle);
 
     if (semaphore->handle_type == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
     {
@@ -3266,7 +3699,10 @@ static VkResult wine_vk_get_semaphore_counter_value(VkDevice device_handle, VkSe
         return VK_SUCCESS;
     }
 
-    return vk_get_semaphore_counter_value(device_handle, semaphore_handle, value, khr);
+    if (khr)
+        return device->p_vkGetSemaphoreCounterValueKHR(device->host.device, semaphore->obj.host.semaphore, value);
+    else
+        return device->p_vkGetSemaphoreCounterValue(device->host.device, semaphore->obj.host.semaphore, value);
 }
 
 VkResult wine_vkGetSemaphoreCounterValue(VkDevice device_handle, VkSemaphore semaphore_handle, uint64_t *value)
@@ -3279,116 +3715,194 @@ VkResult wine_vkGetSemaphoreCounterValueKHR(VkDevice device_handle, VkSemaphore
     return wine_vk_get_semaphore_counter_value(device_handle, semaphore_handle, value, true);
 }
 
-static VkResult vk_signal_semaphore(VkDevice device_handle, const VkSemaphoreSignalInfo *signal_info, bool khr)
+static NTSTATUS wine_vk_signal_semaphore(VkDevice device_handle, const VkSemaphoreSignalInfo *signal_info, bool khr)
 {
     struct wine_semaphore *semaphore = wine_semaphore_from_handle(signal_info->semaphore);
     struct vulkan_device *device = vulkan_device_from_handle(device_handle);
     VkSemaphoreSignalInfo dup_signal_info = *signal_info;
 
-    dup_signal_info.semaphore = semaphore->obj.host.semaphore;
+    TRACE("(%p, %p)\n", device, signal_info);
+
+    if (semaphore->handle_type == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+    {
+        add_sem_signal_op(device, semaphore, signal_info->value, &dup_signal_info.semaphore, &dup_signal_info.value, TRUE);
+        return VK_SUCCESS;
+    }
+    else
+        dup_signal_info.semaphore = semaphore->obj.host.semaphore;
+
     if (khr)
         return device->p_vkSignalSemaphoreKHR(device->host.device, &dup_signal_info);
     else
         return device->p_vkSignalSemaphore(device->host.device, &dup_signal_info);
 }
 
-static NTSTATUS wine_vk_signal_semaphore(VkDevice device, const VkSemaphoreSignalInfo *signal_info, bool khr)
+VkResult wine_vkSignalSemaphore(VkDevice device_handle, const VkSemaphoreSignalInfo *signal_info)
 {
-    struct wine_semaphore *semaphore = wine_semaphore_from_handle(signal_info->semaphore);
-
-    TRACE("(%p, %p)\n", device, signal_info);
-
-    if (semaphore->handle_type == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
-    {
-        FIXME("Signalling D3D12-Fence compatible timeline semaphore not supported.\n");
-        return VK_ERROR_OUT_OF_HOST_MEMORY;
-    }
-
-    return vk_signal_semaphore(device, signal_info, khr);
+    return wine_vk_signal_semaphore(device_handle, signal_info, false);
 }
 
-VkResult wine_vkSignalSemaphore(VkDevice device, const VkSemaphoreSignalInfo *signal_info)
+VkResult wine_vkSignalSemaphoreKHR(VkDevice device_handle, const VkSemaphoreSignalInfo *signal_info)
 {
-    return wine_vk_signal_semaphore(device, signal_info, false);
+    return wine_vk_signal_semaphore(device_handle, signal_info, true);
 }
 
-VkResult wine_vkSignalSemaphoreKHR(VkDevice device, const VkSemaphoreSignalInfo *signal_info)
+static void unwrap_semaphore(struct vulkan_device *device, VkSemaphore *sem_handle, uint64_t *value, BOOL signal)
 {
-    return wine_vk_signal_semaphore(device, signal_info, true);
+    struct wine_semaphore *sem = wine_semaphore_from_handle(*sem_handle);
+
+    if (!sem)
+        return;
+
+    if (sem->handle_type != VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+    {
+        *sem_handle = sem->obj.host.semaphore;
+        return;
+    }
+    if (signal)
+        add_sem_signal_op(device, sem, *value, sem_handle, value, FALSE);
+    else
+        add_sem_wait_op(device, sem, *value, sem_handle, value);
 }
 
-static VkSemaphore *unwrap_semaphore_array(const VkSemaphore *in, uint32_t count, struct conversion_context *ctx)
+static VkResult unwrap_semaphore_array(const VkSemaphore **sems, const uint64_t **values_out,
+        uint32_t count, struct conversion_context *ctx, BOOL signal, struct vulkan_device *device)
 {
+    const uint64_t *values = NULL;
+    const VkSemaphore *in;
     VkSemaphore *out;
     unsigned int i;
 
-    if (!in || !count) return NULL;
+    in = *sems;
+    *sems = NULL;
+
+    if (!in || !count)
+        return VK_SUCCESS;
 
     out = conversion_context_alloc(ctx, count * sizeof(*out));
     for (i = 0; i < count; ++i)
-        out[i] = in[i] ? wine_semaphore_from_handle(in[i])->obj.host.semaphore : VK_NULL_HANDLE;
-
-    return out;
+    {
+        struct wine_semaphore *sem;
+        if (!in[i])
+        {
+            out[i] = VK_NULL_HANDLE;
+            continue;
+        }
+        sem = wine_semaphore_from_handle(in[i]);
+        if (sem->handle_type != VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+        {
+            out[i] = sem->obj.host.semaphore;
+            continue;
+        }
+        if (!values_out)
+        {
+            ERR("D3D12 fence without values specified.\n");
+            return VK_ERROR_UNKNOWN;
+        }
+        if (!values)
+        {
+            values = *values_out;
+            *values_out = conversion_context_alloc(ctx, count * sizeof(*values_out));
+            memcpy((void *)*values_out, values, count * sizeof(*values));
+        }
+        if (signal)
+            add_sem_signal_op(device, sem, values[i], &out[i], (uint64_t *)&(*values_out)[i], FALSE);
+        else
+            add_sem_wait_op(device, sem, values[i], &out[i], (uint64_t *)&(*values_out)[i]);
+    }
+    *sems = out;
+    return VK_SUCCESS;
 }
 
-static VkResult vk_wait_semaphores(struct vulkan_device *device, const VkSemaphoreWaitInfo *wait_info, uint64_t timeout, bool khr)
+static VkResult wine_vk_wait_semaphores(VkDevice device_handle, const VkSemaphoreWaitInfo *wait_info, uint64_t timeout, bool khr)
 {
+    struct vulkan_device *device = vulkan_device_from_handle(device_handle);
     VkSemaphoreWaitInfo wait_info_dup = *wait_info;
     struct conversion_context ctx;
     VkResult ret;
 
     init_conversion_context(&ctx);
-    wait_info_dup.pSemaphores = unwrap_semaphore_array(wait_info->pSemaphores, wait_info->semaphoreCount, &ctx);
+    if ((ret = unwrap_semaphore_array(&wait_info_dup.pSemaphores, &wait_info_dup.pValues,
+            wait_info->semaphoreCount, &ctx, FALSE, device)))
+        goto done;
+
     if (khr)
         ret = device->p_vkWaitSemaphoresKHR(device->host.device, &wait_info_dup, timeout);
     else
         ret = device->p_vkWaitSemaphores(device->host.device, &wait_info_dup, timeout);
+done:
     free_conversion_context(&ctx);
     return ret;
 }
 
-static VkResult wine_vk_wait_semaphores(VkDevice device_handle, const VkSemaphoreWaitInfo *wait_info, uint64_t timeout, bool khr)
-{
-    unsigned int i;
-
-    TRACE("(%p, %p, 0x%s)\n", device_handle, wait_info, wine_dbgstr_longlong(timeout));
-
-    for (i = 0; i < wait_info->semaphoreCount; i++)
-    {
-        struct wine_semaphore *semaphore = wine_semaphore_from_handle(wait_info->pSemaphores[i]);
-
-        if (semaphore->handle_type == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
-        {
-            FIXME("Waiting on D3D12-Fence compatible timeline semaphores not supported.");
-            return VK_ERROR_OUT_OF_HOST_MEMORY;
-        }
-    }
-    return vk_wait_semaphores(vulkan_device_from_handle(device_handle), wait_info, timeout, khr);
-}
-
 VkResult wine_vkWaitSemaphores(VkDevice device, const VkSemaphoreWaitInfo *wait_info, uint64_t timeout)
 {
+    TRACE("%p %p %s.\n", device, wait_info, wine_dbgstr_longlong(timeout));
+
     return wine_vk_wait_semaphores(device, wait_info, timeout, false);
 }
 
 VkResult wine_vkWaitSemaphoresKHR(VkDevice device, const VkSemaphoreWaitInfo *wait_info, uint64_t timeout)
 {
+    TRACE("%p %p %s.\n", device, wait_info, wine_dbgstr_longlong(timeout));
+
     return wine_vk_wait_semaphores(device, wait_info, timeout, true);
 }
 
-VkResult vk_queue_submit_unwrap(struct vulkan_queue *queue, uint32_t submit_count, const VkSubmitInfo *submits_orig, VkFence fence)
+struct struct_chain_def
+{
+    VkStructureType sType;
+    unsigned int size;
+};
+
+VkResult wine_vkQueueSubmit(VkQueue queue_handle, uint32_t submit_count, const VkSubmitInfo *submits_orig, VkFence fence,
+        void *submits_win_ptr)
 {
+    struct vulkan_queue *queue = vulkan_queue_from_handle(queue_handle);
+    struct vulkan_device *device = queue->device;
+    VkTimelineSemaphoreSubmitInfo *timeline_submit_info;
+    const VkSubmitInfo *submits_win = submits_win_ptr;
+    VkD3D12FenceSubmitInfoKHR *d3d12_submit_info;
+    const uint64_t **values;
     struct conversion_context ctx;
     VkSubmitInfo *submits;
     unsigned int i, j;
     VkResult ret;
 
+    TRACE("(%p %u %p 0x%s)\n", queue_handle, submit_count, submits_orig, wine_dbgstr_longlong(fence));
+
     init_conversion_context(&ctx);
     MEMDUP(&ctx, submits, submits_orig, submit_count);
     for (i = 0; i < submit_count; ++i)
     {
-        submits[i].pWaitSemaphores = unwrap_semaphore_array(submits[i].pWaitSemaphores, submits[i].waitSemaphoreCount, &ctx);
-        submits[i].pSignalSemaphores = unwrap_semaphore_array(submits[i].pSignalSemaphores, submits[i].signalSemaphoreCount, &ctx);
+        timeline_submit_info = find_next_struct(&submits[i], VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO);
+        d3d12_submit_info = find_next_struct(&submits_win[i], VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR);
+        if (d3d12_submit_info && timeline_submit_info)
+            WARN("Both TIMELINE_SEMAPHORE_SUBMIT_INFO and D3D12_FENCE_SUBMIT_INFO_KHR specified.\n");
+        if (d3d12_submit_info && !timeline_submit_info)
+        {
+            timeline_submit_info = conversion_context_alloc(&ctx, sizeof(*timeline_submit_info));
+            timeline_submit_info->sType = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO;
+            timeline_submit_info->pNext = submits[i].pNext;
+            timeline_submit_info->waitSemaphoreValueCount = d3d12_submit_info->waitSemaphoreValuesCount;
+            MEMDUP(&ctx, timeline_submit_info->pWaitSemaphoreValues, d3d12_submit_info->pWaitSemaphoreValues, d3d12_submit_info->waitSemaphoreValuesCount);
+            timeline_submit_info->signalSemaphoreValueCount = d3d12_submit_info->signalSemaphoreValuesCount;
+            MEMDUP(&ctx, timeline_submit_info->pSignalSemaphoreValues, d3d12_submit_info->pSignalSemaphoreValues, d3d12_submit_info->signalSemaphoreValuesCount);
+            submits[i].pNext = timeline_submit_info;
+        }
+
+        if (timeline_submit_info)
+            values = &timeline_submit_info->pWaitSemaphoreValues;
+        else
+            values = NULL;
+        unwrap_semaphore_array(&submits[i].pWaitSemaphores, values, submits[i].waitSemaphoreCount, &ctx, FALSE, device);
+
+        if (timeline_submit_info)
+            values = &timeline_submit_info->pSignalSemaphoreValues;
+        else
+            values = NULL;
+        unwrap_semaphore_array(&submits[i].pSignalSemaphores, values, submits[i].signalSemaphoreCount, &ctx, TRUE, device);
+
         if (submits[i].pCommandBuffers && submits[i].commandBufferCount)
         {
             VkCommandBuffer *out;
@@ -3404,38 +3918,6 @@ VkResult vk_queue_submit_unwrap(struct vulkan_queue *queue, uint32_t submit_coun
     return ret;
 }
 
-VkResult wine_vkQueueSubmit(VkQueue queue_handle, uint32_t submit_count, const VkSubmitInfo *submits, VkFence fence, void *submits_win_ptr)
-{
-    struct vulkan_queue *queue = vulkan_queue_from_handle(queue_handle);
-    unsigned int i, k;
-
-    TRACE("(%p %u %p 0x%s)\n", queue_handle, submit_count, submits, wine_dbgstr_longlong(fence));
-
-    for (i = 0; i < submit_count; i++)
-    {
-        for (k = 0; k < submits[i].waitSemaphoreCount; k++)
-        {
-            if (wine_semaphore_from_handle(submits[i].pWaitSemaphores[k])->handle_type ==
-                    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
-            {
-                FIXME("Queue submissions with waits on D3D12-Fence compatible timeline semaphores not supported.\n");
-                return VK_ERROR_OUT_OF_HOST_MEMORY;
-            }
-        }
-
-        for (k = 0; k < submits[i].signalSemaphoreCount; k++)
-        {
-            if (wine_semaphore_from_handle(submits[i].pSignalSemaphores[k])->handle_type ==
-                    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
-            {
-                FIXME("Queue submissions with signalling D3D12-Fence compatible timeline semaphores not supported.\n");
-                return VK_ERROR_OUT_OF_HOST_MEMORY;
-            }
-        }
-    }
-    return vk_queue_submit_unwrap(queue, submit_count, submits, fence);
-}
-
 static void duplicate_array_for_unwrapping(struct conversion_context *ctx, void **ptr, unsigned int size)
 {
     void *out;
@@ -3448,14 +3930,16 @@ static void duplicate_array_for_unwrapping(struct conversion_context *ctx, void
     *ptr = out;
 }
 
-VkResult vk_queue_submit_2_unwrap(struct vulkan_queue *queue, uint32_t submit_count, const VkSubmitInfo2 *submits_orig,
-        VkFence fence, bool khr)
+static VkResult vk_queue_submit_2(VkQueue queue_handle, uint32_t submit_count, const VkSubmitInfo2 *submits_orig, VkFence fence, bool khr)
 {
+    struct vulkan_queue *queue = vulkan_queue_from_handle(queue_handle);
     struct conversion_context ctx;
     VkSubmitInfo2 *submits;
     unsigned int i, j;
     VkResult ret;
 
+    TRACE("(%p, %u, %p, %s)\n", queue_handle, submit_count, submits_orig, wine_dbgstr_longlong(fence));
+
     init_conversion_context(&ctx);
     MEMDUP(&ctx, submits, submits_orig, submit_count);
     for (i = 0; i < submit_count; ++i)
@@ -3463,16 +3947,14 @@ VkResult vk_queue_submit_2_unwrap(struct vulkan_queue *queue, uint32_t submit_co
         duplicate_array_for_unwrapping(&ctx, (void **)&submits[i].pWaitSemaphoreInfos,
                 submits[i].waitSemaphoreInfoCount * sizeof(*submits[i].pWaitSemaphoreInfos));
         for (j = 0; j < submits[i].waitSemaphoreInfoCount; ++j)
-            if (submits[i].pWaitSemaphoreInfos[j].semaphore)
-                ((VkSemaphoreSubmitInfo *)submits[i].pWaitSemaphoreInfos)[j].semaphore
-                        = wine_semaphore_from_handle(submits[i].pWaitSemaphoreInfos[j].semaphore)->obj.host.semaphore;
+            unwrap_semaphore(queue->device, &((VkSemaphoreSubmitInfo *)submits[i].pWaitSemaphoreInfos)[j].semaphore,
+                    &((VkSemaphoreSubmitInfo *)submits[i].pWaitSemaphoreInfos)[j].value, FALSE);
 
         duplicate_array_for_unwrapping(&ctx, (void **)&submits[i].pSignalSemaphoreInfos,
                 submits[i].signalSemaphoreInfoCount * sizeof(*submits[i].pSignalSemaphoreInfos));
         for (j = 0; j < submits[i].signalSemaphoreInfoCount; ++j)
-            if (submits[i].pSignalSemaphoreInfos[j].semaphore)
-                ((VkSemaphoreSubmitInfo *)submits[i].pSignalSemaphoreInfos)[j].semaphore
-                        = wine_semaphore_from_handle(submits[i].pSignalSemaphoreInfos[j].semaphore)->obj.host.semaphore;
+            unwrap_semaphore(queue->device, &((VkSemaphoreSubmitInfo *)submits[i].pSignalSemaphoreInfos)[j].semaphore,
+                    &((VkSemaphoreSubmitInfo *)submits[i].pSignalSemaphoreInfos)[j].value, TRUE);
 
         if (submits[i].pCommandBufferInfos && submits[i].commandBufferInfoCount)
         {
@@ -3483,6 +3965,7 @@ VkResult vk_queue_submit_2_unwrap(struct vulkan_queue *queue, uint32_t submit_co
                         = wine_cmd_buffer_from_handle(submits[i].pCommandBufferInfos[j].commandBuffer)->host.command_buffer;
         }
     }
+
     if (khr)
         ret = queue->device->p_vkQueueSubmit2KHR(queue->host.queue, submit_count, submits, fence);
     else
@@ -3491,39 +3974,6 @@ VkResult vk_queue_submit_2_unwrap(struct vulkan_queue *queue, uint32_t submit_co
     return ret;
 }
 
-static VkResult vk_queue_submit_2(VkQueue queue_handle, uint32_t submit_count, const VkSubmitInfo2 *submits, VkFence fence, bool khr)
-{
-    struct vulkan_queue *queue = vulkan_queue_from_handle(queue_handle);
-    unsigned int i, k;
-
-    TRACE("(%p, %u, %p, %s)\n", queue_handle, submit_count, submits, wine_dbgstr_longlong(fence));
-
-    for (i = 0; i < submit_count; i++)
-    {
-        for (k = 0; k < submits[i].waitSemaphoreInfoCount; k++)
-        {
-            if (wine_semaphore_from_handle(submits[i].pWaitSemaphoreInfos[k].semaphore)->handle_type ==
-                    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
-            {
-                FIXME("Queue submissions with waits on D3D12-Fence compatible timeline semaphores not supported.\n");
-                return VK_ERROR_OUT_OF_HOST_MEMORY;
-            }
-        }
-
-        for (k = 0; k < submits[i].signalSemaphoreInfoCount; k++)
-        {
-            if (wine_semaphore_from_handle(submits[i].pSignalSemaphoreInfos[k].semaphore)->handle_type ==
-                    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
-            {
-                FIXME("Queue submissions signalling D3D12-Fence compatible timeline semaphores not supported.\n");
-                return VK_ERROR_OUT_OF_HOST_MEMORY;
-            }
-        }
-    }
-
-    return vk_queue_submit_2_unwrap(queue, submit_count, submits, fence, khr);
-}
-
 VkResult wine_vkQueueSubmit2(VkQueue queue, uint32_t submit_count, const VkSubmitInfo2 *submits, VkFence fence)
 {
     return vk_queue_submit_2(queue, submit_count, submits, fence, false);
@@ -3576,8 +4026,8 @@ VkResult wine_vkQueueBindSparse(VkQueue queue_handle, uint32_t bind_info_count,
     for (i = 0; i < bind_info_count; ++i)
     {
         batch = (VkBindSparseInfo *)&bind_info[i];
-        batch->pWaitSemaphores = unwrap_semaphore_array(batch->pWaitSemaphores, batch->waitSemaphoreCount, &ctx);
-        batch->pSignalSemaphores = unwrap_semaphore_array(batch->pSignalSemaphores, batch->signalSemaphoreCount, &ctx);
+        unwrap_semaphore_array(&batch->pWaitSemaphores, NULL, batch->waitSemaphoreCount, &ctx, FALSE, queue->device);
+        unwrap_semaphore_array(&batch->pSignalSemaphores, NULL, batch->signalSemaphoreCount, &ctx, TRUE, queue->device);
 
         duplicate_array_for_unwrapping(&ctx, (void **)&batch->pBufferBinds, batch->bufferBindCount * sizeof(*batch->pBufferBinds));
         for (j = 0; j < batch->bufferBindCount; ++j)
diff --git a/dlls/winevulkan/vulkan_private.h b/dlls/winevulkan/vulkan_private.h
index c36c52ec327..6d0f5c7ccb5 100644
--- a/dlls/winevulkan/vulkan_private.h
+++ b/dlls/winevulkan/vulkan_private.h
@@ -21,6 +21,7 @@
 #define __WINE_VULKAN_PRIVATE_H
 
 #include <pthread.h>
+#include <stdbool.h>
 
 #include "vulkan_loader.h"
 #include "vulkan_thunks.h"
@@ -41,6 +42,19 @@ static inline struct wine_cmd_buffer *wine_cmd_buffer_from_handle(VkCommandBuffe
     return (struct wine_cmd_buffer *)(UINT_PTR)client->unix_handle;
 }
 
+struct wine_semaphore;
+
+struct pending_d3d12_fence_op
+{
+    /* Vulkan native local semaphore. */
+    struct local_timeline_semaphore local_sem;
+
+    /* Operation values. */
+    struct list entry;
+    uint64_t virtual_value;
+    struct wine_semaphore *semaphore;
+};
+
 struct wine_debug_utils_messenger;
 
 struct wine_debug_report_callback
@@ -174,18 +188,23 @@ struct wine_semaphore
 {
     struct vulkan_semaphore obj;
     VkSemaphore semaphore;
-    VkSemaphore fence_timeline_semaphore;
 
     VkExternalSemaphoreHandleTypeFlagBits export_types;
 
     /* mutable members */
     VkExternalSemaphoreHandleTypeFlagBits handle_type;
+    struct list poll_entry;
+    struct list pending_waits;
+    struct list pending_signals;
     HANDLE handle;
     struct
     {
+        /* Shared mem access mutex. The non-shared parts access is guarded with device global signaller_mutex. */
         pthread_mutex_t mutex;
-        uint64_t virtual_value;
+        uint64_t virtual_value, physical_value;
     } *d3d12_fence_shm;
+    /* The Vulkan shared semaphore is only waited or signaled in signaller_worker(). */
+    VkSemaphore fence_timeline_semaphore;
 };
 
 static inline void *conversion_context_alloc(struct conversion_context *pool, size_t size)
diff --git a/include/wine/vulkan_driver.h b/include/wine/vulkan_driver.h
index fe989bbf809..3bb0c81cc00 100644
--- a/include/wine/vulkan_driver.h
+++ b/include/wine/vulkan_driver.h
@@ -48,6 +48,7 @@ struct vulkan_client_object
 
 #include "wine/vulkan.h"
 #include "wine/rbtree.h"
+#include "wine/list.h"
 
 /* Wine internal vulkan driver version, needs to be bumped upon vulkan_funcs changes. */
 #define WINE_VULKAN_DRIVER_VERSION 35
@@ -104,6 +105,12 @@ static inline struct vulkan_physical_device *vulkan_physical_device_from_handle(
     return (struct vulkan_physical_device *)(UINT_PTR)client->unix_handle;
 }
 
+struct local_timeline_semaphore
+{
+    VkSemaphore sem;
+    uint64_t value;
+};
+
 struct vulkan_device
 {
     VULKAN_OBJECT_HEADER( VkDevice, device );
@@ -114,6 +121,16 @@ struct vulkan_device
     uint64_t queue_count;
     struct vulkan_queue *queues;
     VkQueueFamilyProperties *queue_props;
+
+    pthread_t signaller_thread;
+    pthread_mutex_t signaller_mutex;
+    BOOL stop;
+    struct list free_fence_ops_list;
+    struct list sem_poll_list;
+    struct local_timeline_semaphore sem_poll_update;
+    pthread_cond_t sem_poll_updated_cond;
+    uint64_t sem_poll_update_value; /* set to sem_poll_update.value by signaller thread once update is processed. */
+    unsigned int allocated_fence_ops_count;
 };
 
 static inline struct vulkan_device *vulkan_device_from_handle( VkDevice handle )
-- 
2.49.0

From ee80d1767ac742422c8d271c4d0846db6ed7a868 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 7 Aug 2023 17:49:30 -0600
Subject: [PATCH 0887/1564] winevulkan: Support resetting shared fence value.

CW-Bug-Id: #22526
---
 dlls/winevulkan/vulkan.c         | 54 ++++++++++++++++++++++++++------
 dlls/winevulkan/vulkan_private.h | 10 ++++++
 2 files changed, 55 insertions(+), 9 deletions(-)

diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index 974c1f98d6d..7f85e9d9608 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -209,8 +209,8 @@ static void signal_timeline_sem(struct vulkan_device *device, VkSemaphore sem, u
 
     info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO;
     info.semaphore = sem;
-    ++*value;
-    info.value = *value;
+    info.value = *value + 1;
+    __atomic_store_n(value, info.value, __ATOMIC_RELEASE);
     if (device->physical_device->api_version < VK_API_VERSION_1_2 || device->physical_device->instance->api_version < VK_API_VERSION_1_2)
         res = device->p_vkSignalSemaphoreKHR(device->host.device, &info);
     else
@@ -3040,14 +3040,13 @@ static int semaphore_process(struct vulkan_device *device, struct wine_semaphore
     int virtual_value_updated = 0;
     uint64_t value, virtual_value;
     VkResult res;
+    uint32_t i;
 
     /* Check local pending signal ops completion, update shared semaphore. */
     d3d12_semaphore_lock( sem );
+    virtual_value = sem->d3d12_fence_shm->virtual_value;
     LIST_FOR_EACH_ENTRY_SAFE(op, op2, &sem->pending_signals, struct pending_d3d12_fence_op, entry)
     {
-        if (op->virtual_value <= sem->d3d12_fence_shm->virtual_value)
-            goto signal_op_complete;
-
         res = get_semaphore_value(device, op->local_sem.sem, &value);
         if (res != VK_SUCCESS)
         {
@@ -3064,28 +3063,64 @@ static int semaphore_process(struct vulkan_device *device, struct wine_semaphore
             continue;
         }
 
+        virtual_value = max( sem->d3d12_fence_shm->virtual_value, op->virtual_value );
         sem->d3d12_fence_shm->virtual_value = op->virtual_value;
         virtual_value_updated = 1;
 signal_op_complete:
-        ++op->local_sem.value;
+        op->local_sem.value = value;
         release_fence_op(device, op);
     }
 
+    if (sem->d3d12_fence_shm->virtual_value < virtual_value)
+    {
+        uint32_t idx = sem->d3d12_fence_shm->reset_backlog_count;
+
+        if (debug_level >= 3)
+            fprintf(stderr, "warn:winevulkan:semaphore_process resetting semaphore %p virtual value.\n", sem);
+        if (idx == ARRAY_SIZE(sem->d3d12_fence_shm->reset_backlog))
+        {
+            sem->d3d12_fence_shm->last_dropped_reset_physical = sem->d3d12_fence_shm->reset_backlog[0].physical_at_reset;
+            --idx;
+            memmove(&sem->d3d12_fence_shm->reset_backlog[0], &sem->d3d12_fence_shm->reset_backlog[1],
+                    sizeof(*sem->d3d12_fence_shm->reset_backlog) * sem->d3d12_fence_shm->reset_backlog_count);
+        }
+        else
+        {
+            ++sem->d3d12_fence_shm->reset_backlog_count;
+        }
+        sem->d3d12_fence_shm->last_reset_physical = sem->d3d12_fence_shm->physical_value + 1;
+        sem->d3d12_fence_shm->reset_backlog[idx].physical_at_reset = sem->d3d12_fence_shm->last_reset_physical;
+        sem->d3d12_fence_shm->reset_backlog[idx].virtual_before_reset = virtual_value;
+    }
     if (virtual_value_updated)
         signal_timeline_sem(device, sem->fence_timeline_semaphore, &sem->d3d12_fence_shm->physical_value);
     global_sem_wait_value = sem->d3d12_fence_shm->physical_value + 1;
-    virtual_value = sem->d3d12_fence_shm->virtual_value;
-    d3d12_semaphore_unlock(sem);
 
     /* Complete satisfied local waits. */
     LIST_FOR_EACH_ENTRY_SAFE(op, op2, &sem->pending_waits, struct pending_d3d12_fence_op, entry)
     {
         if (op->virtual_value > virtual_value)
-            continue;
+        {
+            if (op->shared_physical_value > sem->d3d12_fence_shm->last_reset_physical)
+                continue;
+            for (i = 0; i < sem->d3d12_fence_shm->reset_backlog_count; ++i)
+            {
+                if (sem->d3d12_fence_shm->reset_backlog[i].physical_at_reset >= op->shared_physical_value
+                        && sem->d3d12_fence_shm->reset_backlog[i].virtual_before_reset >= op->virtual_value)
+                    break;
+            }
+            if (i == sem->d3d12_fence_shm->reset_backlog_count)
+            {
+                if (sem->d3d12_fence_shm->last_dropped_reset_physical < op->shared_physical_value)
+                    continue;
+                fprintf(stderr, "err:winevulkan:semaphore_process wait needs reset backlog beyond cut off.\n");
+            }
+        }
 
         signal_timeline_sem(device, op->local_sem.sem, &op->local_sem.value);
         release_fence_op(device, op);
     }
+    d3d12_semaphore_unlock(sem);
 
     /* Only poll shared semaphore if there are waits pending. */
     if (list_empty(&sem->pending_waits))
@@ -3264,6 +3299,7 @@ static void add_sem_wait_op(struct vulkan_device *device, struct wine_semaphore
     if ((op = get_free_fence_op(device)))
     {
         op->virtual_value = virtual_value;
+        op->shared_physical_value = __atomic_load_n(&semaphore->d3d12_fence_shm->physical_value, __ATOMIC_ACQUIRE) + 1;
         *phys_semaphore = op->local_sem.sem;
         *phys_wait_value = op->local_sem.value + 1;
         op->semaphore = semaphore;
diff --git a/dlls/winevulkan/vulkan_private.h b/dlls/winevulkan/vulkan_private.h
index 6d0f5c7ccb5..1acd7c5a129 100644
--- a/dlls/winevulkan/vulkan_private.h
+++ b/dlls/winevulkan/vulkan_private.h
@@ -52,6 +52,7 @@ struct pending_d3d12_fence_op
     /* Operation values. */
     struct list entry;
     uint64_t virtual_value;
+    uint64_t shared_physical_value;
     struct wine_semaphore *semaphore;
 };
 
@@ -202,6 +203,15 @@ struct wine_semaphore
         /* Shared mem access mutex. The non-shared parts access is guarded with device global signaller_mutex. */
         pthread_mutex_t mutex;
         uint64_t virtual_value, physical_value;
+        uint64_t last_reset_physical;
+        uint64_t last_dropped_reset_physical;
+        struct
+        {
+            uint64_t physical_at_reset;
+            uint64_t virtual_before_reset;
+        }
+        reset_backlog[16];
+        uint32_t reset_backlog_count;
     } *d3d12_fence_shm;
     /* The Vulkan shared semaphore is only waited or signaled in signaller_worker(). */
     VkSemaphore fence_timeline_semaphore;
-- 
2.49.0

From 8010fca5898d4b9bde97cebdcd990d99c6d4d3ed Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 4 Aug 2023 13:14:43 -0600
Subject: [PATCH 0888/1564] winevulkan: Also remap Win32 functions in
 vk_is_available_instance_function().

CW-Bug-Id: #22526
---
 dlls/winevulkan/vulkan.c | 33 ++++++++++++++++++---------------
 1 file changed, 18 insertions(+), 15 deletions(-)

diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index 7f85e9d9608..e8bb97dd03e 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -2816,12 +2816,23 @@ void wine_vkDestroyDeferredOperationKHR(VkDevice device_handle,
     free(object);
 }
 
+static void substitute_function_name(const char **name)
+{
+    if (!strcmp(*name, "vkGetMemoryWin32HandleKHR") || !strcmp(*name, "vkGetMemoryWin32HandlePropertiesKHR"))
+        *name = "vkGetMemoryFdKHR";
+    else if (!strcmp(*name, "vkGetSemaphoreWin32HandleKHR"))
+        *name = "vkGetSemaphoreFdKHR";
+    else if (!strcmp(*name, "vkImportSemaphoreWin32HandleKHR"))
+        *name = "vkImportSemaphoreFdKHR";
+}
+
 #ifdef _WIN64
 
 NTSTATUS vk_is_available_instance_function(void *arg)
 {
     struct is_available_instance_function_params *params = arg;
     struct wine_instance *instance = wine_instance_from_handle(params->instance);
+    substitute_function_name(&params->name);
 
     if (!strcmp(params->name, "vkCreateWin32SurfaceKHR"))
         return instance->enable_win32_surface;
@@ -2835,12 +2846,7 @@ NTSTATUS vk_is_available_device_function(void *arg)
 {
     struct is_available_device_function_params *params = arg;
     struct vulkan_device *device = vulkan_device_from_handle(params->device);
-    if (!strcmp(params->name, "vkGetMemoryWin32HandleKHR") || !strcmp(params->name, "vkGetMemoryWin32HandlePropertiesKHR"))
-        params->name = "vkGetMemoryFdKHR";
-    else if (!strcmp(params->name, "vkGetSemaphoreWin32HandleKHR"))
-        params->name = "vkGetSemaphoreFdKHR";
-    else if (!strcmp(params->name, "vkImportSemaphoreWin32HandleKHR"))
-        params->name = "vkImportSemaphoreFdKHR";
+    substitute_function_name(&params->name);
     return !!vk_funcs->p_vkGetDeviceProcAddr(device->host.device, params->name);
 }
 
@@ -2854,13 +2860,15 @@ NTSTATUS vk_is_available_instance_function32(void *arg)
         UINT32 name;
     } *params = arg;
     struct wine_instance *instance = wine_instance_from_handle(UlongToPtr(params->instance));
+    const char *name = UlongToPtr(params->name);
 
     if (!strcmp(UlongToPtr(params->name), "vkCreateWin32SurfaceKHR"))
         return instance->enable_win32_surface;
     if (!strcmp(UlongToPtr(params->name), "vkGetPhysicalDeviceWin32PresentationSupportKHR"))
         return instance->enable_win32_surface;
 
-    return !!vk_funcs->p_vkGetInstanceProcAddr(instance->obj.host.instance, UlongToPtr(params->name));
+    substitute_function_name(&name);
+    return !!vk_funcs->p_vkGetInstanceProcAddr(instance->obj.host.instance, name);
 }
 
 NTSTATUS vk_is_available_device_function32(void *arg)
@@ -2871,14 +2879,9 @@ NTSTATUS vk_is_available_device_function32(void *arg)
         UINT32 name;
     } *params = arg;
     struct vulkan_device *device = vulkan_device_from_handle(UlongToPtr(params->device));
-    char *name = UlongToPtr(params->name);
-    if (!strcmp(name, "vkGetMemoryWin32HandleKHR") || !strcmp(name, "vkGetMemoryWin32HandlePropertiesKHR"))
-        return !!vk_funcs->p_vkGetDeviceProcAddr(device->host.device, "vkGetMemoryFdKHR");
-    if (!strcmp(name, "vkGetSemaphoreWin32HandleKHR"))
-        return !!vk_funcs->p_vkGetDeviceProcAddr(device->host.device, "vkGetSemaphoreFdKHR");
-    if (!strcmp(name, "vkImportSemaphoreWin32HandleKHR"))
-        return !!vk_funcs->p_vkGetDeviceProcAddr(device->host.device, "vkImportSemaphoreFdKHR");
-    return !!vk_funcs->p_vkGetDeviceProcAddr(device->host.device, UlongToPtr(params->name));
+    const char *name = UlongToPtr(params->name);
+    substitute_function_name(&name);
+    return !!vk_funcs->p_vkGetDeviceProcAddr(device->host.device, name);
 }
 
 VkResult wine_vkGetMemoryWin32HandleKHR(VkDevice device, const VkMemoryGetWin32HandleInfoKHR *handle_info, HANDLE *handle)
-- 
2.49.0

From 5862f278d2c7a59c0b6c491cbd97e79fe2449a1d Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 4 Aug 2023 14:30:26 -0600
Subject: [PATCH 0889/1564] winevulkan: Expose VK_KHR_win32_keyed_mutex
 extension.

CW-Bug-Id: #22372
---
 dlls/winevulkan/make_vulkan |  5 ++---
 dlls/winevulkan/vulkan.c    | 25 +++++++++++++++++++++++--
 2 files changed, 25 insertions(+), 5 deletions(-)

diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index a1e26f01294..13fdf2db0df 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -101,7 +101,6 @@ UNSUPPORTED_EXTENSIONS = [
     "VK_KHR_video_encode_h265", # StdVideoH265HrdParameters cannot be handled
     "VK_KHR_video_decode_h265", # by struct conversions.
     "VK_KHR_video_maintenance2", # Also affected by StdVideoH265HrdParameters.
-    "VK_KHR_win32_keyed_mutex",
     "VK_NV_external_memory_rdma", # Needs shared resources work.
     "VK_NV_external_compute_queue", # Has a new dispatchable handle
 
@@ -335,8 +334,8 @@ STRUCT_CHAIN_CONVERSIONS = {
     "VkPhysicalDeviceImageFormatInfo2": [],
     "VkPhysicalDeviceExternalSemaphoreInfo": [],
     "VkSemaphoreCreateInfo": [],
-    "VkSubmitInfo": ["VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR"],
-    "VkSubmitInfo2": [],
+    "VkSubmitInfo": ["VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR", "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR"],
+    "VkSubmitInfo2": ["VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR"],
     "VkBindSparseInfo" : [],
 }
 
diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index e8bb97dd03e..181ce81f0f0 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -404,7 +404,7 @@ static VkResult wine_vk_physical_device_init(struct wine_phys_dev *object, VkPhy
     uint32_t num_host_properties, num_properties = 0;
     VkExtensionProperties *host_properties = NULL;
     VkPhysicalDeviceProperties physdev_properties;
-    BOOL have_external_memory_host = FALSE;
+    BOOL have_external_memory_host = FALSE, have_external_memory_fd = FALSE, have_external_semaphore_fd = FALSE;
     VkResult res;
     unsigned int i, j;
 
@@ -451,6 +451,7 @@ static VkResult wine_vk_physical_device_init(struct wine_phys_dev *object, VkPhy
             snprintf(host_properties[i].extensionName, sizeof(host_properties[i].extensionName),
                     VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME);
             host_properties[i].specVersion = VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION;
+            have_external_memory_fd = TRUE;
         }
         if (!strcmp(host_properties[i].extensionName, "VK_KHR_external_semaphore_fd"))
         {
@@ -459,6 +460,7 @@ static VkResult wine_vk_physical_device_init(struct wine_phys_dev *object, VkPhy
             snprintf(host_properties[i].extensionName, sizeof(host_properties[i].extensionName),
                     VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME);
             host_properties[i].specVersion = VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION;
+            have_external_semaphore_fd = TRUE;
         }
 
         if (wine_vk_device_extension_supported(host_properties[i].extensionName))
@@ -478,7 +480,8 @@ static VkResult wine_vk_physical_device_init(struct wine_phys_dev *object, VkPhy
             have_map_memory2 = TRUE;
     }
 
-    TRACE("Host supported extensions %u, Wine supported extensions %u\n", num_host_properties, num_properties);
+    if (have_external_memory_fd && have_external_semaphore_fd)
+        ++num_properties; /* VK_KHR_win32_keyed_mutex */
 
     if (!(object->extensions = calloc(num_properties, sizeof(*object->extensions))))
     {
@@ -494,7 +497,15 @@ static VkResult wine_vk_physical_device_init(struct wine_phys_dev *object, VkPhy
             j++;
         }
     }
+    if (have_external_memory_fd && have_external_semaphore_fd)
+    {
+        strcpy(object->extensions[j].extensionName, VK_KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME);
+        object->extensions[j].specVersion = VK_KHR_WIN32_KEYED_MUTEX_SPEC_VERSION;
+        TRACE("Enabling extension '%s' for physical device %p\n", object->extensions[j].extensionName, object);
+        ++j;
+    }
     object->extension_count = num_properties;
+    TRACE("Host supported extensions %u, Wine supported extensions %u\n", num_host_properties, num_properties);
 
     if (zero_bits && have_memory_placed && have_map_memory2)
     {
@@ -717,6 +728,16 @@ static VkResult wine_vk_device_convert_create_info(VkPhysicalDevice client_physi
         remove_extensions[remove_count++] = "VK_KHR_external_semaphore_win32";
     }
 
+    if (find_extension(extensions, extensions_count, "VK_KHR_win32_keyed_mutex"))
+    {
+        if (!find_extension(extensions, extensions_count, "VK_KHR_external_memory_win32"))
+            extra_extensions[extra_count++] = "VK_KHR_external_memory_fd";
+        if (!find_extension(extensions, extensions_count, "VK_KHR_external_semaphore_win32"))
+            extra_extensions[extra_count++] = "VK_KHR_external_semaphore_fd";
+        remove_extensions[remove_count++] = "VK_KHR_win32_keyed_mutex";
+    }
+
+
     if ((phys_dev->obj.api_version < VK_API_VERSION_1_2 || phys_dev->obj.instance->api_version < VK_API_VERSION_1_2)
                 && !find_extension(extensions, extensions_count, "VK_KHR_timeline_semaphore"))
         extra_extensions[extra_count++] = "VK_KHR_timeline_semaphore";
-- 
2.49.0

From e357f58dd809d534b6bcca59ca53615a04061dd4 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 4 Aug 2023 17:52:14 -0600
Subject: [PATCH 0890/1564] winevulkan: Implement
 vkGetMemoryWin32HandlePropertiesKHR().

CW-Bug-Id: #22372
---
 dlls/winevulkan/vulkan.c | 21 +++++++++++++++++----
 1 file changed, 17 insertions(+), 4 deletions(-)

diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index 181ce81f0f0..89985f08371 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -2939,13 +2939,26 @@ VkResult wine_vkGetMemoryWin32HandleKHR(VkDevice device, const VkMemoryGetWin32H
     }
 }
 
-VkResult wine_vkGetMemoryWin32HandlePropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits type, HANDLE handle, VkMemoryWin32HandlePropertiesKHR *properties)
+VkResult wine_vkGetMemoryWin32HandlePropertiesKHR(VkDevice device_handle, VkExternalMemoryHandleTypeFlagBits type, HANDLE handle, VkMemoryWin32HandlePropertiesKHR *properties)
 {
+    struct vulkan_device *device = vulkan_device_from_handle(device_handle);
+    struct wine_phys_dev *physical_device = CONTAINING_RECORD(device->physical_device, struct wine_phys_dev, obj);
+    unsigned int i;
+
     TRACE("%p %u %p %p\n", device, type, handle, properties);
 
-    /* VUID-vkGetMemoryWin32HandlePropertiesKHR-handleType-00666
-       handleType must not be one of the handle types defined as opaque */
-    return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+    if (!(type & wine_vk_handle_over_fd_types))
+    {
+        FIXME("type %#x.\n", type);
+        return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+    }
+
+    properties->memoryTypeBits = 0;
+    for (i = 0; i < physical_device->memory_properties.memoryTypeCount; ++i)
+        if (physical_device->memory_properties.memoryTypes[i].propertyFlags == VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT)
+            properties->memoryTypeBits |= 1u << i;
+
+    return VK_SUCCESS;
 }
 
 #define IOCTL_SHARED_GPU_RESOURCE_SET_OBJECT           CTL_CODE(FILE_DEVICE_VIDEO, 6, METHOD_BUFFERED, FILE_WRITE_ACCESS)
-- 
2.49.0

From 1ecb8ea9c4d8812431aa17c4f710c2f49bc71f3f Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 4 Aug 2023 19:13:05 -0600
Subject: [PATCH 0891/1564] winevulkan: Use resource allocated size when
 importing shared textures.

CW-Bug-Id: #22372
---
 dlls/sharedgpures.sys/shared_resource.c | 28 +++++++++++++
 dlls/winevulkan/vulkan.c                | 54 +++++++++++++++++++++++--
 2 files changed, 78 insertions(+), 4 deletions(-)

diff --git a/dlls/sharedgpures.sys/shared_resource.c b/dlls/sharedgpures.sys/shared_resource.c
index c6ab013ea0d..ad836662af0 100644
--- a/dlls/sharedgpures.sys/shared_resource.c
+++ b/dlls/sharedgpures.sys/shared_resource.c
@@ -27,6 +27,7 @@ struct shared_resource
     SIZE_T metadata_size;
     void **object_pool;
     unsigned int object_pool_count;
+    UINT64 resource_size;
 };
 
 static struct shared_resource *resource_pool;
@@ -72,6 +73,7 @@ static void *reference_client_handle(obj_handle_t handle)
 
 struct shared_resource_create
 {
+    UINT64 resource_size;
     obj_handle_t unix_handle;
     WCHAR name[1];
 };
@@ -125,6 +127,7 @@ static NTSTATUS shared_resource_create(struct shared_resource **res, void *buff,
     (*res)->ref_count = 1;
     (*res)->unix_resource = unix_resource;
     (*res)->name = name;
+    (*res)->resource_size = input->resource_size;
 
     iosb->Information = 0;
     return STATUS_SUCCESS;
@@ -138,6 +141,11 @@ struct shared_resource_open
     WCHAR name[1];
 };
 
+struct shared_resource_info
+{
+    UINT64 resource_size;
+};
+
 static unsigned int kmt_to_index(obj_handle_t kmt)
 {
     if (!(kmt & 0x40000000) || (kmt - 2) % 4)
@@ -340,6 +348,20 @@ static NTSTATUS shared_resource_get_object(struct shared_resource *res, void *bu
     return STATUS_SUCCESS;
 }
 
+#define IOCTL_SHARED_GPU_RESOURCE_GET_INFO CTL_CODE(FILE_DEVICE_VIDEO, 7, METHOD_BUFFERED, FILE_READ_ACCESS)
+static NTSTATUS shared_resource_get_info(struct shared_resource *res, void *buff, SIZE_T outsize, IO_STATUS_BLOCK *iosb)
+{
+    struct shared_resource_info *info = buff;
+
+    if (sizeof(*info) > outsize)
+        return STATUS_BUFFER_TOO_SMALL;
+
+    info->resource_size = res->resource_size;
+    iosb->Information = sizeof(*info);
+    return STATUS_SUCCESS;
+}
+
+
 static NTSTATUS WINAPI dispatch_create(DEVICE_OBJECT *device, IRP *irp)
 {
     irp->IoStatus.u.Status = STATUS_SUCCESS;
@@ -452,6 +474,12 @@ static NTSTATUS WINAPI dispatch_ioctl(DEVICE_OBJECT *device, IRP *irp)
                                       stack->Parameters.DeviceIoControl.OutputBufferLength,
                                       &irp->IoStatus);
             break;
+        case IOCTL_SHARED_GPU_RESOURCE_GET_INFO:
+            status = shared_resource_get_info( res,
+                                      irp->AssociatedIrp.SystemBuffer,
+                                      stack->Parameters.DeviceIoControl.OutputBufferLength,
+                                      &irp->IoStatus );
+            break;
     default:
         FIXME( "ioctl %#lx not supported\n", stack->Parameters.DeviceIoControl.IoControlCode );
         status = STATUS_NOT_SUPPORTED;
diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index 89985f08371..cafb8d15139 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -2101,11 +2101,12 @@ void wine_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(VkPhysicalDevice cli
 
 struct shared_resource_create
 {
+    UINT64 resource_size;
     obj_handle_t unix_handle;
     WCHAR name[1];
 };
 
-static HANDLE create_gpu_resource(int fd, LPCWSTR name)
+static HANDLE create_gpu_resource(int fd, LPCWSTR name, UINT64 resource_size)
 {
     static const WCHAR shared_gpu_resourceW[] = {'\\','?','?','\\','S','h','a','r','e','d','G','p','u','R','e','s','o','u','r','c','e',0};
     HANDLE unix_resource = INVALID_HANDLE_VALUE;
@@ -2141,6 +2142,7 @@ static HANDLE create_gpu_resource(int fd, LPCWSTR name)
     in_size = sizeof(*inbuff) + (name ? lstrlenW(name) * sizeof(WCHAR) : 0);
     inbuff = calloc(1, in_size);
     inbuff->unix_handle = wine_server_obj_handle(unix_resource);
+    inbuff->resource_size = resource_size;
     if (name)
         lstrcpyW(&inbuff->name[0], name);
 
@@ -2168,6 +2170,11 @@ struct shared_resource_open
     WCHAR name[1];
 };
 
+struct shared_resource_info
+{
+    UINT64 resource_size;
+};
+
 static HANDLE open_shared_resource(HANDLE kmt_handle, LPCWSTR name)
 {
     static const WCHAR shared_gpu_resourceW[] = {'\\','?','?','\\','S','h','a','r','e','d','G','p','u','R','e','s','o','u','r','c','e',0};
@@ -2215,6 +2222,21 @@ static HANDLE open_shared_resource(HANDLE kmt_handle, LPCWSTR name)
     return shared_resource;
 }
 
+#define IOCTL_SHARED_GPU_RESOURCE_GET_INFO CTL_CODE(FILE_DEVICE_VIDEO, 7, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+static BOOL shared_resource_get_info(HANDLE handle, struct shared_resource_info *info)
+{
+    IO_STATUS_BLOCK iosb;
+    unsigned int status;
+
+    status = NtDeviceIoControlFile(handle, NULL, NULL, NULL, &iosb, IOCTL_SHARED_GPU_RESOURCE_GET_INFO,
+            NULL, 0, info, sizeof(*info));
+    if (status)
+        ERR("Failed to get shared resource info, status %#x.\n", status);
+
+    return !status;
+}
+
 #define IOCTL_SHARED_GPU_RESOURCE_GET_UNIX_RESOURCE           CTL_CODE(FILE_DEVICE_VIDEO, 3, METHOD_BUFFERED, FILE_READ_ACCESS)
 
 static int get_shared_resource_fd(HANDLE shared_resource)
@@ -2294,11 +2316,15 @@ VkResult wine_vkAllocateMemory(VkDevice client_device, const VkMemoryAllocateInf
     /* Vulkan consumes imported FDs, but not imported HANDLEs */
     if (handle_import_info)
     {
+        struct shared_resource_info res_info;
+
         fd_import_info.sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR;
         fd_import_info.pNext = info.pNext;
         fd_import_info.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
         info.pNext = &fd_import_info;
 
+        TRACE("import handle type %#x.\n", handle_import_info->handleType);
+
         switch (handle_import_info->handleType)
         {
             case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT:
@@ -2334,6 +2360,26 @@ VkResult wine_vkAllocateMemory(VkDevice client_device, const VkMemoryAllocateInf
             result = VK_ERROR_INVALID_EXTERNAL_HANDLE;
             goto done;
         }
+
+        /* From VkMemoryAllocateInfo spec: "if the parameters define an import operation and the external handle type is
+         * VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT,
+         * or VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT, allocationSize is ignored.". Although test suggests
+         * that it is also true for opaque Win32 handles. */
+        if (shared_resource_get_info(memory->handle, &res_info))
+        {
+            if (res_info.resource_size)
+            {
+                TRACE("Shared resource size %llu.\n", (long long)res_info.resource_size);
+                if (info.allocationSize && info.allocationSize != res_info.resource_size)
+                    FIXME("Shared resource allocationSize %llu, resource_size %llu.\n",
+                            (long long)info.allocationSize, (long long)res_info.resource_size);
+                info.allocationSize = res_info.resource_size;
+            }
+            else
+            {
+                ERR("Zero shared resource size.\n");
+            }
+        }
     }
     else if (physical_device->external_memory_align && (mem_flags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) &&
         !find_next_struct(alloc_info->pNext, VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT))
@@ -2414,7 +2460,7 @@ VkResult wine_vkAllocateMemory(VkDevice client_device, const VkMemoryAllocateInf
 
         if (device->p_vkGetMemoryFdKHR(device->host.device, &get_fd_info, &fd) == VK_SUCCESS)
         {
-            memory->handle = create_gpu_resource(fd, handle_export_info ? handle_export_info->name : NULL);
+            memory->handle = create_gpu_resource(fd, handle_export_info ? handle_export_info->name : NULL, alloc_info->allocationSize);
             memory->access = handle_export_info ? handle_export_info->dwAccess : GENERIC_ALL;
             if (handle_export_info && handle_export_info->pAttributes)
                 memory->inherit = handle_export_info->pAttributes->bInheritHandle;
@@ -3450,7 +3496,7 @@ VkResult wine_vkCreateSemaphore(VkDevice client_device, const VkSemaphoreCreateI
 
         if ((res = device->p_vkGetSemaphoreFdKHR(device->host.device, &fd_info, &fd)) == VK_SUCCESS)
         {
-            object->handle = create_gpu_resource(fd, export_handle_info ? export_handle_info->name : NULL);
+            object->handle = create_gpu_resource(fd, export_handle_info ? export_handle_info->name : NULL, 0);
             close(fd);
         }
 
@@ -3489,7 +3535,7 @@ VkResult wine_vkCreateSemaphore(VkDevice client_device, const VkSemaphoreCreateI
 
         if ((res = device->p_vkGetSemaphoreFdKHR(device->host.device, &fd_info, &fd)) == VK_SUCCESS)
         {
-            object->handle = create_gpu_resource(fd, export_handle_info ? export_handle_info->name : NULL);
+            object->handle = create_gpu_resource(fd, export_handle_info ? export_handle_info->name : NULL, 0);
             close(fd);
         }
 
-- 
2.49.0

From 5d703324e0fcbb1a7ad19daa194e342135291e06 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Thu, 10 Aug 2023 20:09:33 -0600
Subject: [PATCH 0892/1564] winevulkan: Share keyed mutex data.

CW-Bug-Id: #22372
---
 dlls/winevulkan/vulkan.c         | 196 ++++++++++++++++++++++++++++++-
 dlls/winevulkan/vulkan_private.h |  13 ++
 include/wine/vulkan_driver.h     |   2 +
 3 files changed, 209 insertions(+), 2 deletions(-)

diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index cafb8d15139..f51a332faba 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -685,7 +685,8 @@ static const char *find_extension(const char *const *extensions, uint32_t count,
 }
 
 static VkResult wine_vk_device_convert_create_info(VkPhysicalDevice client_physical_device,
-        struct conversion_context *ctx, const VkDeviceCreateInfo *src, VkDeviceCreateInfo *dst)
+        struct conversion_context *ctx, const VkDeviceCreateInfo *src, VkDeviceCreateInfo *dst,
+        struct vulkan_device *device)
 {
     static const char *wine_xr_extension_name = "VK_WINE_openxr_device_extensions";
     struct wine_phys_dev *phys_dev = wine_phys_dev_from_handle(client_physical_device);
@@ -735,6 +736,7 @@ static VkResult wine_vk_device_convert_create_info(VkPhysicalDevice client_physi
         if (!find_extension(extensions, extensions_count, "VK_KHR_external_semaphore_win32"))
             extra_extensions[extra_count++] = "VK_KHR_external_semaphore_fd";
         remove_extensions[remove_count++] = "VK_KHR_win32_keyed_mutex";
+        device->keyed_mutexes_enabled = TRUE;
     }
 
 
@@ -1103,7 +1105,7 @@ VkResult wine_vkCreateDevice(VkPhysicalDevice client_physical_device, const VkDe
     list_init(&device->free_fence_ops_list);
 
     init_conversion_context(&ctx);
-    res = wine_vk_device_convert_create_info(client_physical_device, &ctx, create_info, &create_info_host);
+    res = wine_vk_device_convert_create_info(client_physical_device, &ctx, create_info, &create_info_host, device);
     if (res == VK_SUCCESS)
     {
         VkPhysicalDeviceFeatures features = {0};
@@ -2269,6 +2271,191 @@ static HANDLE get_shared_resource_kmt_handle(HANDLE shared_resource)
     return wine_server_ptr_handle(kmt_handle);
 }
 
+static bool set_shared_resource_object(HANDLE shared_resource, unsigned int index, HANDLE handle);
+static HANDLE get_shared_resource_object(HANDLE shared_resource, unsigned int index);
+
+static void destroy_keyed_mutex(struct vulkan_device *device, struct wine_device_memory *memory)
+{
+    if (memory->keyed_mutex_shm)
+    {
+        NtUnmapViewOfSection(GetCurrentProcess(), memory->keyed_mutex_shm);
+        memory->keyed_mutex_shm = NULL;
+    }
+    if (memory->keyed_mutex_sem)
+    {
+        device->p_vkDestroySemaphore(device->host.device, memory->keyed_mutex_sem, NULL);
+        memory->keyed_mutex_sem = VK_NULL_HANDLE;
+    }
+}
+
+static void create_keyed_mutex(struct vulkan_device *device, struct wine_device_memory *memory)
+{
+    VkExportSemaphoreCreateInfo timeline_export_info;
+    VkSemaphoreTypeCreateInfo type_info;
+    VkSemaphoreCreateInfo create_info;
+    VkSemaphoreGetFdInfoKHR fd_info;
+    pthread_mutexattr_t mutex_attr;
+    OBJECT_ATTRIBUTES attr;
+    HANDLE section_handle;
+    LARGE_INTEGER li;
+    HANDLE handle;
+    SIZE_T size;
+    VkResult vr;
+    int fd;
+
+    InitializeObjectAttributes(&attr, NULL, 0, NULL, NULL);
+    size = li.QuadPart = sizeof(*memory->keyed_mutex_shm);
+    if (NtCreateSection(&section_handle, STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ | SECTION_MAP_WRITE, &attr, &li, PAGE_READWRITE, SEC_COMMIT, NULL))
+    {
+        ERR("NtCreateSection failed.\n");
+        return;
+    }
+
+    if (!set_shared_resource_object(memory->handle, 0, section_handle))
+    {
+        NtClose(section_handle);
+        ERR("set_shared_resource_object failed.\n");
+        return;
+    }
+
+    if (NtMapViewOfSection(section_handle, GetCurrentProcess(), (void**) &memory->keyed_mutex_shm, 0, 0, NULL, &size, ViewShare, 0, PAGE_READWRITE))
+    {
+        NtClose(section_handle);
+        ERR("NtMapViewOfSection failed.\n");
+        return;
+    }
+
+    NtClose(section_handle);
+
+    timeline_export_info.sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO;
+    timeline_export_info.pNext = NULL;
+    timeline_export_info.handleTypes = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+
+    type_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
+    type_info.pNext = &timeline_export_info;
+    type_info.semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE;
+    type_info.initialValue = 0;
+
+    create_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
+    create_info.pNext = &type_info;
+    create_info.flags = 0;
+
+    if ((vr = device->p_vkCreateSemaphore(device->host.device, &create_info, NULL, &memory->keyed_mutex_sem)) != VK_SUCCESS)
+    {
+        ERR("Failed to create semaphore, vr %d.\n", vr);
+        goto error;
+    }
+    fd_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR;
+    fd_info.pNext = NULL;
+    fd_info.semaphore = memory->keyed_mutex_sem;
+    fd_info.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+
+    if ((vr = device->p_vkGetSemaphoreFdKHR(device->host.device, &fd_info, &fd)) != VK_SUCCESS)
+    {
+        ERR("Failed to export semaphore fd, vr %d.\n", vr);
+        goto error;
+    }
+    if (wine_server_fd_to_handle(fd, GENERIC_ALL, 0, &handle) != STATUS_SUCCESS)
+    {
+        ERR("wine_server_fd_to_handle failed.\n");
+        close(fd);
+        goto error;
+    }
+    close(fd);
+    if (!set_shared_resource_object(memory->handle, 1, handle))
+    {
+        ERR("set_shared_resource_object failed.\n");
+        NtClose(handle);
+        goto error;
+    }
+    NtClose(handle);
+
+    pthread_mutexattr_init(&mutex_attr);
+    pthread_mutexattr_setpshared(&mutex_attr, PTHREAD_PROCESS_SHARED);
+    if (pthread_mutex_init(&memory->keyed_mutex_shm->mutex, &mutex_attr))
+    memory->keyed_mutex_shm->instance_id_counter = 1;
+    memory->keyed_mutex_instance_id = ++memory->keyed_mutex_shm->instance_id_counter;
+    TRACE("memory %p, created keyed mutex.\n", memory);
+    return;
+
+error:
+    destroy_keyed_mutex(device, memory);
+}
+
+static void import_keyed_mutex(struct vulkan_device *device, struct wine_device_memory *memory)
+{
+    VkSemaphoreTypeCreateInfo type_info;
+    VkImportSemaphoreFdInfoKHR fd_info;
+    VkSemaphoreCreateInfo create_info;
+    HANDLE section_handle, sem_handle;
+    SIZE_T size;
+
+    VkResult vr;
+
+    if (!(section_handle = get_shared_resource_object(memory->handle, 0)))
+    {
+        TRACE("No section handle.\n");
+        return;
+    }
+    if (!(sem_handle = get_shared_resource_object(memory->handle, 1)))
+    {
+        ERR("No smeaphore handle.\n");
+        NtClose(section_handle);
+        return;
+    }
+
+    size = sizeof(*memory->keyed_mutex_shm);
+    if (NtMapViewOfSection(section_handle, GetCurrentProcess(), (void**) &memory->keyed_mutex_shm, 0, 0, NULL, &size, ViewShare, 0, PAGE_READWRITE))
+    {
+        ERR("NtMapViewOfSection failed.\n");
+        goto error;
+    }
+
+    type_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
+    type_info.pNext = NULL;
+    type_info.semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE;
+    type_info.initialValue = 0;
+
+    create_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
+    create_info.pNext = &type_info;
+    create_info.flags = 0;
+
+    if ((vr = device->p_vkCreateSemaphore(device->host.device, &create_info, NULL, &memory->keyed_mutex_sem)) != VK_SUCCESS)
+    {
+        ERR("Failed to create semaphore, vr %d.\n", vr);
+        goto error;
+    }
+
+    fd_info.sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR;
+    fd_info.pNext = NULL;
+    fd_info.semaphore = memory->keyed_mutex_sem;
+    fd_info.flags = 0;
+    fd_info.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+
+    if (wine_server_handle_to_fd(sem_handle, FILE_READ_DATA, &fd_info.fd, NULL))
+    {
+        ERR("wine_server_handle_to_fd failed.\n");
+        goto error;
+    }
+
+    vr = device->p_vkImportSemaphoreFdKHR(device->host.device, &fd_info);
+    if (vr != VK_SUCCESS)
+    {
+        ERR("vkImportSemaphoreFdKHR failed, vr %d.\n", vr);
+        close(fd_info.fd);
+        goto error;
+    }
+    /* Not closing fd on successful import, the driver now owns it. */
+
+    memory->keyed_mutex_instance_id = InterlockedIncrement64((LONGLONG *)&memory->keyed_mutex_shm->instance_id_counter);
+    TRACE("memory %p, imported keyed mutex.\n", memory);
+    return;
+error:
+    NtClose(section_handle);
+    NtClose(sem_handle);
+    destroy_keyed_mutex(device, memory);
+}
+
 VkResult wine_vkAllocateMemory(VkDevice client_device, const VkMemoryAllocateInfo *alloc_info,
                                const VkAllocationCallbacks *allocator, VkDeviceMemory *ret)
 {
@@ -2380,6 +2567,8 @@ VkResult wine_vkAllocateMemory(VkDevice client_device, const VkMemoryAllocateInf
                 ERR("Zero shared resource size.\n");
             }
         }
+        if (device->keyed_mutexes_enabled)
+            import_keyed_mutex(device, memory);
     }
     else if (physical_device->external_memory_align && (mem_flags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) &&
         !find_next_struct(alloc_info->pNext, VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT))
@@ -2467,6 +2656,8 @@ VkResult wine_vkAllocateMemory(VkDevice client_device, const VkMemoryAllocateInf
             else
                 memory->inherit = FALSE;
             close(fd);
+            if (device->keyed_mutexes_enabled)
+                create_keyed_mutex(device, memory);
         }
 
         if (memory->handle == INVALID_HANDLE_VALUE)
@@ -2507,6 +2698,7 @@ void wine_vkFreeMemory(VkDevice client_device, VkDeviceMemory memory_handle, con
         return;
     memory = wine_device_memory_from_handle(memory_handle);
 
+    destroy_keyed_mutex(device, memory);
     if (memory->vm_map && !physical_device->external_memory_align)
     {
         const VkMemoryUnmapInfoKHR info =
diff --git a/dlls/winevulkan/vulkan_private.h b/dlls/winevulkan/vulkan_private.h
index 1acd7c5a129..d01eb8f0914 100644
--- a/dlls/winevulkan/vulkan_private.h
+++ b/dlls/winevulkan/vulkan_private.h
@@ -115,6 +115,16 @@ static inline struct wine_cmd_pool *wine_cmd_pool_from_handle(VkCommandPool hand
     return (struct wine_cmd_pool *)(UINT_PTR)client->unix_handle;
 }
 
+struct keyed_mutex_shm
+{
+    pthread_mutex_t mutex;
+    uint64_t instance_id_counter;
+    uint64_t acquired_to_instance;
+    uint64_t key;
+    uint64_t timeline_value;
+    uint64_t timeline_queued_release;
+};
+
 struct wine_device_memory
 {
     VULKAN_OBJECT_HEADER( VkDeviceMemory, device_memory );
@@ -124,6 +134,9 @@ struct wine_device_memory
     BOOL inherit;
     DWORD access;
     HANDLE handle;
+    struct keyed_mutex_shm *keyed_mutex_shm;
+    VkSemaphore keyed_mutex_sem;
+    uint64_t keyed_mutex_instance_id;
 };
 
 static inline struct wine_device_memory *wine_device_memory_from_handle(VkDeviceMemory handle)
diff --git a/include/wine/vulkan_driver.h b/include/wine/vulkan_driver.h
index 3bb0c81cc00..15d03383e12 100644
--- a/include/wine/vulkan_driver.h
+++ b/include/wine/vulkan_driver.h
@@ -131,6 +131,8 @@ struct vulkan_device
     pthread_cond_t sem_poll_updated_cond;
     uint64_t sem_poll_update_value; /* set to sem_poll_update.value by signaller thread once update is processed. */
     unsigned int allocated_fence_ops_count;
+
+    BOOL keyed_mutexes_enabled;
 };
 
 static inline struct vulkan_device *vulkan_device_from_handle( VkDevice handle )
-- 
2.49.0

From 66ff445cc8033cbd845aad360b18e37ad1b797f9 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 4 Aug 2023 20:46:30 -0600
Subject: [PATCH 0893/1564] winevulkan: Support keyed mutex waits and signals
 in submits.

CW-Bug-Id: #22372
---
 dlls/winevulkan/make_vulkan |  11 +-
 dlls/winevulkan/vulkan.c    | 280 ++++++++++++++++++++++++++++++++++--
 2 files changed, 269 insertions(+), 22 deletions(-)

diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index 13fdf2db0df..3c528037826 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -181,7 +181,7 @@ FUNCTION_OVERRIDES = {
     "vkSignalSemaphore" : {"dispatch" : True},
     "vkWaitSemaphores" : {"dispatch" : True},
     "vkQueueBindSparse" : {"dispatch" : True},
-    "vkQueueSubmit" : {"dispatch" : True, "extra_param" : "pSubmits"},
+    "vkQueueSubmit" : {"dispatch" : True},
     "vkQueueSubmit2" : {"dispatch" : True},
     "vkDestroySemaphore" : {"dispatch" : True},
 
@@ -334,15 +334,12 @@ STRUCT_CHAIN_CONVERSIONS = {
     "VkPhysicalDeviceImageFormatInfo2": [],
     "VkPhysicalDeviceExternalSemaphoreInfo": [],
     "VkSemaphoreCreateInfo": [],
-    "VkSubmitInfo": ["VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR", "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR"],
-    "VkSubmitInfo2": ["VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR"],
+    "VkSubmitInfo": [],
+    "VkSubmitInfo2": [],
     "VkBindSparseInfo" : [],
 }
 
-STRUCT_COPY = {
-    "VkSubmitInfo",
-    "VkSubmitInfo2",
-};
+STRUCT_COPY = {};
 
 # Some struct members are conditionally ignored and callers are free to leave them uninitialized.
 # We can't deduce that from XML, so we allow expressing it here.
diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index f51a332faba..5e3cad1ab45 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -2456,6 +2456,111 @@ error:
     destroy_keyed_mutex(device, memory);
 }
 
+static VkResult acquire_keyed_mutex(struct vulkan_device *device, struct wine_device_memory *memory, uint64_t key,
+        uint32_t timeout_ms)
+{
+    ULONG end_wait, curr_tick, remaining_wait;
+    VkSemaphoreWaitInfo wait_info = { 0 };
+    uint64_t timeline;
+    VkResult vr;
+
+    if (!memory->keyed_mutex_shm)
+        return VK_ERROR_UNKNOWN;
+
+    wait_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO;
+    wait_info.semaphoreCount = 1;
+    wait_info.pSemaphores = &memory->keyed_mutex_sem;
+    wait_info.pValues = &timeline;
+
+    end_wait = NtGetTickCount() + timeout_ms;
+
+    while (1)
+    {
+        pthread_mutex_lock(&memory->keyed_mutex_shm->mutex);
+
+        if (memory->keyed_mutex_shm->acquired_to_instance)
+        {
+            if ((vr = get_semaphore_value(device, memory->keyed_mutex_sem, &timeline)) != VK_SUCCESS)
+            {
+                pthread_mutex_unlock(&memory->keyed_mutex_shm->mutex);
+                return VK_ERROR_UNKNOWN;
+            }
+            assert(timeline == memory->keyed_mutex_shm->timeline_value
+                    || timeline == memory->keyed_mutex_shm->timeline_value + 1);
+            if (timeline == memory->keyed_mutex_shm->timeline_value + 1)
+            {
+                /* released from queue. */
+                assert(memory->keyed_mutex_shm->timeline_queued_release == timeline);
+                memory->keyed_mutex_shm->timeline_queued_release = 0;
+                ++memory->keyed_mutex_shm->timeline_value;
+                memory->keyed_mutex_shm->acquired_to_instance = 0;
+            }
+        }
+
+        if (memory->keyed_mutex_shm->acquired_to_instance == memory->keyed_mutex_instance_id
+                && !memory->keyed_mutex_shm->timeline_queued_release)
+        {
+            /* Already acquired to this device. */
+            pthread_mutex_unlock(&memory->keyed_mutex_shm->mutex);
+            return VK_ERROR_UNKNOWN;
+        }
+        if (!memory->keyed_mutex_shm->acquired_to_instance && memory->keyed_mutex_shm->key == key)
+        {
+            /* Can acquire. */
+            memory->keyed_mutex_shm->acquired_to_instance = memory->keyed_mutex_instance_id;
+            pthread_mutex_unlock(&memory->keyed_mutex_shm->mutex);
+            return VK_SUCCESS;
+        }
+        curr_tick = NtGetTickCount();
+        if (!timeout_ms || curr_tick >= end_wait)
+        {
+            pthread_mutex_unlock(&memory->keyed_mutex_shm->mutex);
+            return VK_TIMEOUT;
+        }
+        remaining_wait = timeout_ms == INFINITE ? INFINITE : end_wait - curr_tick;
+        timeline = memory->keyed_mutex_shm->timeline_value + 1;
+        pthread_mutex_unlock(&memory->keyed_mutex_shm->mutex);
+
+        vr = wait_semaphores(device, &wait_info, remaining_wait * 1000000ull);
+        if (vr != VK_SUCCESS && vr != VK_TIMEOUT)
+        {
+            ERR("vkWaitSemaphores failed, vr %d.\n", vr);
+            return VK_ERROR_UNKNOWN;
+        }
+    }
+}
+
+static VkResult release_keyed_mutex(struct vulkan_device *device, struct wine_device_memory *memory, uint64_t key,
+        uint64_t *timeline_value)
+{
+    if (!memory->keyed_mutex_shm)
+        return VK_ERROR_UNKNOWN;
+
+    pthread_mutex_lock(&memory->keyed_mutex_shm->mutex);
+    if (memory->keyed_mutex_shm->acquired_to_instance != memory->keyed_mutex_instance_id
+            || memory->keyed_mutex_shm->timeline_queued_release)
+    {
+        pthread_mutex_unlock(&memory->keyed_mutex_shm->mutex);
+        return VK_ERROR_UNKNOWN;
+    }
+    memory->keyed_mutex_shm->key = key;
+    if (timeline_value)
+    {
+        /* Return timeline value to signal from queue. */
+        *timeline_value = memory->keyed_mutex_shm->timeline_value + 1;
+        memory->keyed_mutex_shm->timeline_queued_release = *timeline_value;
+    }
+    else
+    {
+        /* Release immediately. */
+        memory->keyed_mutex_shm->acquired_to_instance = 0;
+        signal_timeline_sem(device, memory->keyed_mutex_sem, &memory->keyed_mutex_shm->timeline_value);
+    }
+    pthread_mutex_unlock(&memory->keyed_mutex_shm->mutex);
+
+    return VK_SUCCESS;
+}
+
 VkResult wine_vkAllocateMemory(VkDevice client_device, const VkMemoryAllocateInfo *alloc_info,
                                const VkAllocationCallbacks *allocator, VkDeviceMemory *ret)
 {
@@ -4166,17 +4271,125 @@ struct struct_chain_def
     unsigned int size;
 };
 
-VkResult wine_vkQueueSubmit(VkQueue queue_handle, uint32_t submit_count, const VkSubmitInfo *submits_orig, VkFence fence,
-        void *submits_win_ptr)
+static VkResult process_keyed_mutexes(struct conversion_context *ctx, struct vulkan_device *device,
+        uint32_t submit_count, const void *submits_win, size_t submit_size, uint32_t **signal_counts,
+        VkSemaphoreSubmitInfo ***signal_infos)
+{
+    VkWin32KeyedMutexAcquireReleaseInfoKHR *keyed_mutex_info;
+    struct wine_device_memory *memory;
+    VkResult ret = VK_ERROR_UNKNOWN;
+    uint32_t i, j, signal_count = 0;
+    void *ptr;
+
+    for (i = 0; i < submit_count; ++i)
+    {
+        ptr = (char *)submits_win + i * submit_size;
+        if (!(keyed_mutex_info = find_next_struct(ptr, VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR)))
+            continue;
+        for (j = 0; j < keyed_mutex_info->acquireCount; ++j)
+        {
+            memory = wine_device_memory_from_handle(keyed_mutex_info->pAcquireSyncs[j]);
+            if ((ret = acquire_keyed_mutex(device, memory, keyed_mutex_info->pAcquireKeys[j],
+                    keyed_mutex_info->pAcquireTimeouts[j])) == VK_SUCCESS)
+                continue;
+            while (j)
+            {
+                --j;
+                memory = wine_device_memory_from_handle(keyed_mutex_info->pAcquireSyncs[j]);
+                release_keyed_mutex(device, memory, keyed_mutex_info->pAcquireKeys[j], NULL);
+            }
+            goto error;
+        }
+        /* Pre-check release error conditions. */
+        for (j = 0; j < keyed_mutex_info->releaseCount; ++j)
+        {
+            memory = wine_device_memory_from_handle(keyed_mutex_info->pReleaseSyncs[j]);
+            if (!memory->keyed_mutex_shm)
+                goto error;
+            if (memory->keyed_mutex_shm->acquired_to_instance != memory->keyed_mutex_instance_id)
+                goto error;
+        }
+        signal_count += keyed_mutex_info->releaseCount;
+    }
+
+    if (!signal_count)
+    {
+        *signal_counts = NULL;
+        return VK_SUCCESS;
+    }
+    *signal_counts = conversion_context_alloc(ctx, sizeof(**signal_counts) * submit_count);
+    *signal_infos = conversion_context_alloc(ctx, sizeof(**signal_infos) * submit_count);
+    for (i = 0; i < submit_count; ++i)
+    {
+        ptr = (char *)submits_win + i * submit_size;
+        if (!(keyed_mutex_info = wine_vk_find_unlink_struct(ptr, WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR)))
+        {
+            (*signal_counts)[i] = 0;
+            continue;
+        }
+        (*signal_counts)[i] = keyed_mutex_info->releaseCount;
+        (*signal_infos)[i] = conversion_context_alloc(ctx, sizeof(***signal_infos) * keyed_mutex_info->releaseCount);
+        for (j = 0; j < keyed_mutex_info->releaseCount; ++j)
+        {
+            memory = wine_device_memory_from_handle(keyed_mutex_info->pReleaseSyncs[j]);
+            (*signal_infos)[i][j].sType = VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO;
+            (*signal_infos)[i][j].pNext = NULL;
+            (*signal_infos)[i][j].semaphore = memory->keyed_mutex_sem;
+            (*signal_infos)[i][j].stageMask = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;
+            (*signal_infos)[i][j].deviceIndex = 0;
+            ret = release_keyed_mutex(device, memory, keyed_mutex_info->pReleaseKeys[j], &(*signal_infos)[i][j].value);
+            if (ret != VK_SUCCESS)
+            {
+                /* This should only be possible if a racing submit queued release before us, currently not handled. */
+                ERR("release_keyed_mutex failed, ret %d.\n", ret);
+                (*signal_infos)[i][j].value = 0;
+            }
+        }
+    }
+
+    return VK_SUCCESS;
+
+error:
+    while (i)
+    {
+        --i;
+        ptr = (char *)submits_win + i * submit_size;
+        if (!(keyed_mutex_info = wine_vk_find_unlink_struct(ptr, WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR)))
+            continue;
+        for (j = 0; j < keyed_mutex_info->acquireCount; ++j)
+        {
+            memory = wine_device_memory_from_handle(keyed_mutex_info->pAcquireSyncs[j]);
+            release_keyed_mutex(device, memory, keyed_mutex_info->pAcquireKeys[j], NULL);
+        }
+    }
+    return ret;
+}
+
+static void duplicate_array_for_unwrapping_copy_size(struct conversion_context *ctx, void **ptr, unsigned int size,
+        unsigned int copy_size)
+{
+    void *out;
+
+    if (!size)
+        return;
+
+    out = conversion_context_alloc(ctx, size);
+    if (*ptr)
+        memcpy(out, *ptr, copy_size);
+    *ptr = out;
+}
+
+VkResult wine_vkQueueSubmit(VkQueue queue_handle, uint32_t submit_count, const VkSubmitInfo *submits_orig, VkFence fence)
 {
     struct vulkan_queue *queue = vulkan_queue_from_handle(queue_handle);
     struct vulkan_device *device = queue->device;
-    VkTimelineSemaphoreSubmitInfo *timeline_submit_info;
-    const VkSubmitInfo *submits_win = submits_win_ptr;
+    VkTimelineSemaphoreSubmitInfo *timeline_submit_info, ts_info_copy;
     VkD3D12FenceSubmitInfoKHR *d3d12_submit_info;
     const uint64_t **values;
     struct conversion_context ctx;
     VkSubmitInfo *submits;
+    VkSemaphoreSubmitInfo **km_infos;
+    uint32_t *km_counts;
     unsigned int i, j;
     VkResult ret;
 
@@ -4184,10 +4397,13 @@ VkResult wine_vkQueueSubmit(VkQueue queue_handle, uint32_t submit_count, const V
 
     init_conversion_context(&ctx);
     MEMDUP(&ctx, submits, submits_orig, submit_count);
+    if ((ret = process_keyed_mutexes(&ctx, device, submit_count, submits, sizeof(*submits), &km_counts, &km_infos)))
+        return ret;
+
     for (i = 0; i < submit_count; ++i)
     {
         timeline_submit_info = find_next_struct(&submits[i], VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO);
-        d3d12_submit_info = find_next_struct(&submits_win[i], VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR);
+        d3d12_submit_info = wine_vk_find_unlink_struct(&submits[i], D3D12_FENCE_SUBMIT_INFO_KHR);
         if (d3d12_submit_info && timeline_submit_info)
             WARN("Both TIMELINE_SEMAPHORE_SUBMIT_INFO and D3D12_FENCE_SUBMIT_INFO_KHR specified.\n");
         if (d3d12_submit_info && !timeline_submit_info)
@@ -4213,6 +4429,36 @@ VkResult wine_vkQueueSubmit(VkQueue queue_handle, uint32_t submit_count, const V
         else
             values = NULL;
         unwrap_semaphore_array(&submits[i].pSignalSemaphores, values, submits[i].signalSemaphoreCount, &ctx, TRUE, device);
+        if (km_counts && km_counts[i])
+        {
+            if (timeline_submit_info)
+            {
+                ts_info_copy = *timeline_submit_info;
+                timeline_submit_info = &ts_info_copy;
+                duplicate_array_for_unwrapping_copy_size(&ctx, (void **)&timeline_submit_info->pSignalSemaphoreValues,
+                        (timeline_submit_info->signalSemaphoreValueCount + km_counts[i]) * sizeof(*timeline_submit_info->pSignalSemaphoreValues),
+                        timeline_submit_info->signalSemaphoreValueCount * sizeof(*timeline_submit_info->pSignalSemaphoreValues));
+            }
+            else
+            {
+                timeline_submit_info = &ts_info_copy;
+                timeline_submit_info->sType = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO;
+                timeline_submit_info->pNext = submits[i].pNext;
+                timeline_submit_info->waitSemaphoreValueCount = 0;
+                timeline_submit_info->signalSemaphoreValueCount = 0;
+                timeline_submit_info->pSignalSemaphoreValues = conversion_context_alloc(&ctx, km_counts[i] * sizeof(*timeline_submit_info->pSignalSemaphoreValues));
+                submits[i].pNext = timeline_submit_info;
+            }
+            duplicate_array_for_unwrapping_copy_size(&ctx, (void **)&submits[i].pSignalSemaphores,
+                    (submits[i].signalSemaphoreCount + km_counts[i]) * sizeof(*submits[i].pSignalSemaphores),
+                    submits[i].signalSemaphoreCount * sizeof(*submits[i].pSignalSemaphores));
+            for (j = 0; j < km_counts[i]; ++j)
+            {
+                ((uint64_t *)timeline_submit_info->pSignalSemaphoreValues)[j + timeline_submit_info->signalSemaphoreValueCount++]
+                        = km_infos[i][j].value;
+                ((VkSemaphore *)submits[i].pSignalSemaphores)[j + submits[i].signalSemaphoreCount++] = km_infos[i][j].semaphore;
+            }
+        }
 
         if (submits[i].pCommandBuffers && submits[i].commandBufferCount)
         {
@@ -4231,20 +4477,17 @@ VkResult wine_vkQueueSubmit(VkQueue queue_handle, uint32_t submit_count, const V
 
 static void duplicate_array_for_unwrapping(struct conversion_context *ctx, void **ptr, unsigned int size)
 {
-    void *out;
-
-    if (!*ptr || !size)
-        return;
-
-    out = conversion_context_alloc(ctx, size);
-    memcpy(out, *ptr, size);
-    *ptr = out;
+    duplicate_array_for_unwrapping_copy_size(ctx, ptr, size, size);
 }
 
-static VkResult vk_queue_submit_2(VkQueue queue_handle, uint32_t submit_count, const VkSubmitInfo2 *submits_orig, VkFence fence, bool khr)
+static VkResult vk_queue_submit_2(VkQueue queue_handle, uint32_t submit_count, const VkSubmitInfo2 *submits_orig,
+        VkFence fence, bool khr)
 {
     struct vulkan_queue *queue = vulkan_queue_from_handle(queue_handle);
+    struct vulkan_device *device = queue->device;
     struct conversion_context ctx;
+    VkSemaphoreSubmitInfo **km_infos;
+    uint32_t *km_counts, count;
     VkSubmitInfo2 *submits;
     unsigned int i, j;
     VkResult ret;
@@ -4253,6 +4496,8 @@ static VkResult vk_queue_submit_2(VkQueue queue_handle, uint32_t submit_count, c
 
     init_conversion_context(&ctx);
     MEMDUP(&ctx, submits, submits_orig, submit_count);
+    if ((ret = process_keyed_mutexes(&ctx, device, submit_count, submits, sizeof(*submits), &km_counts, &km_infos)))
+        return ret;
     for (i = 0; i < submit_count; ++i)
     {
         duplicate_array_for_unwrapping(&ctx, (void **)&submits[i].pWaitSemaphoreInfos,
@@ -4261,11 +4506,16 @@ static VkResult vk_queue_submit_2(VkQueue queue_handle, uint32_t submit_count, c
             unwrap_semaphore(queue->device, &((VkSemaphoreSubmitInfo *)submits[i].pWaitSemaphoreInfos)[j].semaphore,
                     &((VkSemaphoreSubmitInfo *)submits[i].pWaitSemaphoreInfos)[j].value, FALSE);
 
-        duplicate_array_for_unwrapping(&ctx, (void **)&submits[i].pSignalSemaphoreInfos,
+        count = submits[i].signalSemaphoreInfoCount + (km_counts ? km_counts[i] : 0);
+        duplicate_array_for_unwrapping_copy_size(&ctx, (void **)&submits[i].pSignalSemaphoreInfos,
+                count * sizeof(*submits[i].pSignalSemaphoreInfos),
                 submits[i].signalSemaphoreInfoCount * sizeof(*submits[i].pSignalSemaphoreInfos));
         for (j = 0; j < submits[i].signalSemaphoreInfoCount; ++j)
             unwrap_semaphore(queue->device, &((VkSemaphoreSubmitInfo *)submits[i].pSignalSemaphoreInfos)[j].semaphore,
                     &((VkSemaphoreSubmitInfo *)submits[i].pSignalSemaphoreInfos)[j].value, TRUE);
+        for (; j < count; ++j)
+            ((VkSemaphoreSubmitInfo *)submits[i].pSignalSemaphoreInfos)[j] = km_infos[i][j - submits[i].signalSemaphoreInfoCount];
+        submits[i].signalSemaphoreInfoCount = count;
 
         if (submits[i].pCommandBufferInfos && submits[i].commandBufferInfoCount)
         {
-- 
2.49.0

From fb6f74b22d7479c9b3a6a420707b5d403d6ef614 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Thu, 10 Aug 2023 12:23:26 -0600
Subject: [PATCH 0894/1564] winevulkan: Export custom functions for acquiring
 and releasing keyed mutexes.

CW-Bug-Id: #22372
---
 dlls/winevulkan/make_vulkan   | 11 +++++++++++
 dlls/winevulkan/vk_custom.xml | 24 ++++++++++++++++++++++++
 dlls/winevulkan/vulkan.c      | 12 ++++++++++++
 3 files changed, 47 insertions(+)
 create mode 100644 dlls/winevulkan/vk_custom.xml

diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index 3c528037826..1451242833f 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -210,6 +210,10 @@ FUNCTION_OVERRIDES = {
 
     # VK_KHR_synchronization2
     "vkQueueSubmit2KHR" : {"dispatch" : True},
+
+    # Custom functions
+    "wine_vkAcquireKeyedMutex" : {"dispatch": True},
+    "wine_vkReleaseKeyedMutex" : {"dispatch": True},
 }
 
 # functions for which a user driver entry must be generated
@@ -296,6 +300,9 @@ MANUAL_UNIX_THUNKS = {
     "vkSignalSemaphoreKHR",
     "vkWaitSemaphoresKHR",
     "vkQueueSubmit2KHR",
+    # Custom functions
+    "wine_vkAcquireKeyedMutex",
+    "wine_vkReleaseKeyedMutex",
 }
 
 # loader functions which are entirely manually implemented
@@ -3356,6 +3363,10 @@ class VkRegistry(object):
 
         root.extend(video_root)
 
+        tree_custom = ET.parse("vk_custom.xml")
+        root_custom = tree_custom.getroot()
+        root.extend(root_custom)
+
         self._parse_enums(root)
         self._parse_types(root)
         self._parse_commands(root)
diff --git a/dlls/winevulkan/vk_custom.xml b/dlls/winevulkan/vk_custom.xml
new file mode 100644
index 00000000000..a9fd68548c4
--- /dev/null
+++ b/dlls/winevulkan/vk_custom.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<registry>
+    <commands>
+        <command successcodes="VK_SUCCESS,VK_TIMEOUT" errorcodes="VK_ERROR_UNKNOWN">
+            <proto><type>VkResult</type> <name>wine_vkAcquireKeyedMutex</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkDeviceMemory</type> <name>memory</name></param>
+            <param><type>uint64_t</type> <name>key</name></param>
+            <param><type>uint32_t</type> <name>timeout_ms</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_UNKNOWN">
+            <proto><type>VkResult</type> <name>wine_vkReleaseKeyedMutex</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkDeviceMemory</type> <name>memory</name></param>
+            <param><type>uint64_t</type> <name>key</name></param>
+        </command>
+    </commands>
+    <feature api="vulkan,vulkansc" name="WINE_CUSTOM" comment="Wine custom functions.">
+        <require>
+            <command name="wine_vkAcquireKeyedMutex"/>
+            <command name="wine_vkReleaseKeyedMutex"/>
+        </require>
+    </feature>
+</registry>
diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index 5e3cad1ab45..754cdd981c8 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -3188,6 +3188,8 @@ static void substitute_function_name(const char **name)
         *name = "vkGetSemaphoreFdKHR";
     else if (!strcmp(*name, "vkImportSemaphoreWin32HandleKHR"))
         *name = "vkImportSemaphoreFdKHR";
+    else if (!strcmp(*name, "wine_vkAcquireKeyedMutex") || !strcmp(*name, "wine_vkReleaseKeyedMutex"))
+        *name = "vkImportSemaphoreFdKHR";
 }
 
 #ifdef _WIN64
@@ -4624,3 +4626,13 @@ VkResult wine_vkQueueBindSparse(VkQueue queue_handle, uint32_t bind_info_count,
     free_conversion_context(&ctx);
     return ret;
 }
+
+VkResult wine_wine_vkAcquireKeyedMutex(VkDevice device, VkDeviceMemory memory, uint64_t key, uint32_t timeout_ms)
+{
+    return acquire_keyed_mutex(vulkan_device_from_handle(device), wine_device_memory_from_handle(memory), key, timeout_ms);
+}
+
+VkResult wine_wine_vkReleaseKeyedMutex(VkDevice device, VkDeviceMemory memory, uint64_t key)
+{
+    return release_keyed_mutex(vulkan_device_from_handle(device), wine_device_memory_from_handle(memory), key, NULL);
+}
-- 
2.49.0

From f258a47db8e32fad8e7782ae55ae526e0e4db569 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 1 Dec 2023 21:24:03 +0100
Subject: [PATCH 0999/1564] vrclient: winevulkan: Add struct unwrappers for
 vrclient.

---
 dlls/winevulkan/vulkan.c | 47 ++++++++++++++++++++++++++++++++++++++++
 1 file changed, 47 insertions(+)

diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index 754cdd981c8..78c9a29bf95 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -962,6 +962,7 @@ static VkResult wine_vk_instance_init_physical_devices(struct wine_instance *obj
         res = wine_vk_physical_device_init(phys_dev, host_physical_devices[i], &client_instance->phys_devs[i], instance);
         if (res != VK_SUCCESS)
             goto err;
+        TRACE("added host_physical_devices[i] %p.\n", host_physical_devices[i]);
     }
     object->phys_dev_count = phys_dev_count;
 
@@ -4636,3 +4637,49 @@ VkResult wine_wine_vkReleaseKeyedMutex(VkDevice device, VkDeviceMemory memory, u
 {
     return release_keyed_mutex(vulkan_device_from_handle(device), wine_device_memory_from_handle(memory), key, NULL);
 }
+
+DECLSPEC_EXPORT VkDevice __wine_get_native_VkDevice(VkDevice handle)
+{
+    struct vulkan_device *device = vulkan_device_from_handle(handle);
+
+    return device->host.device;
+}
+
+DECLSPEC_EXPORT VkInstance __wine_get_native_VkInstance(VkInstance handle)
+{
+    struct vulkan_instance *instance = vulkan_instance_from_handle(handle);
+
+    return instance->host.instance;
+}
+
+DECLSPEC_EXPORT VkPhysicalDevice __wine_get_native_VkPhysicalDevice(VkPhysicalDevice handle)
+{
+    struct vulkan_physical_device *phys_dev;
+
+    if (!handle) return NULL;
+
+    phys_dev = vulkan_physical_device_from_handle(handle);
+    return phys_dev->host.physical_device;
+}
+
+DECLSPEC_EXPORT VkQueue __wine_get_native_VkQueue(VkQueue handle)
+{
+    struct vulkan_queue *queue = vulkan_queue_from_handle(handle);
+
+    return queue->host.queue;
+}
+
+DECLSPEC_EXPORT VkPhysicalDevice __wine_get_wrapped_VkPhysicalDevice(VkInstance handle, VkPhysicalDevice native_phys_dev)
+{
+    struct wine_instance *instance = wine_instance_from_handle(handle);
+    unsigned int i;
+
+    for (i = 0; i < instance->phys_dev_count; ++i)
+    {
+        if (instance->phys_devs[i].obj.host.physical_device == native_phys_dev)
+            return instance->phys_devs[i].obj.client.physical_device;
+    }
+
+    ERR("Unknown native physical device: %p, instance %p, handle %p\n", native_phys_dev, instance, handle);
+    return NULL;
+}
-- 
2.49.0

From 75f1e7d903d65aedfcf791ca6cd5aa35d610ed65 Mon Sep 17 00:00:00 2001
From: Arkadiusz Hiler <ahiler@codeweavers.com>
Date: Fri, 3 Jan 2025 14:57:18 +0200
Subject: [PATCH 1025/1564] winevulkan: Make device memory wrapper available in
 callbacks.

With VK_EXT_device_address_binding_report we can get debug_util
callbacks used to track memory bindings. Since it's the host's
implementation that starts the callback we have to be sure that we have
a way of converting it to the client side's variant before it's added to
the handle map - i.e. we don't know the host handle at that time yet.

Link: https://gitlab.winehq.org/wine/wine/-/merge_requests/5658
---
 dlls/winevulkan/vulkan.c         | 34 +++++++++++++++++++++++++++++++-
 dlls/winevulkan/vulkan_private.h |  2 ++
 2 files changed, 35 insertions(+), 1 deletion(-)

diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index 78c9a29bf95..5ada61c09bb 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -233,6 +233,25 @@ static VkResult get_semaphore_value(struct vulkan_device *device, VkSemaphore se
     return device->p_vkGetSemaphoreCounterValue(device->host.device, sem, value);
 }
 
+
+static void set_transient_client_handle(struct wine_instance *instance, uint64_t client_handle)
+{
+    uint64_t *handle = pthread_getspecific(instance->transient_object_handle);
+    if (!handle)
+    {
+        handle = malloc(sizeof(uint64_t));
+        pthread_setspecific(instance->transient_object_handle, handle);
+    }
+    *handle = client_handle;
+}
+
+static uint64_t get_transient_handle(struct wine_instance *instance)
+{
+    uint64_t *handle = pthread_getspecific(instance->transient_object_handle);
+    return handle && *handle;
+}
+
+
 static VkBool32 debug_utils_callback_conversion(VkDebugUtilsMessageSeverityFlagBitsEXT severity,
     VkDebugUtilsMessageTypeFlagsEXT message_types,
     const VkDebugUtilsMessengerCallbackDataEXT *callback_data,
@@ -243,6 +262,8 @@ static VkBool32 debug_utils_callback_conversion(VkDebugUtilsMessageSeverityFlagB
     struct wine_debug_utils_messenger *object;
     struct debug_utils_object dummy_object, *objects;
     struct debug_utils_label dummy_label, *labels;
+    VkInstance instance;
+    struct wine_instance *wine_instance;
     UINT size, strings_len;
     char *ptr, *strings;
     ULONG ret_len;
@@ -252,13 +273,16 @@ static VkBool32 debug_utils_callback_conversion(VkDebugUtilsMessageSeverityFlagB
     TRACE("%i, %u, %p, %p\n", severity, message_types, callback_data, user_data);
 
     object = user_data;
+    instance = object->instance->host.instance;
 
-    if (!object->instance->host.instance)
+    if (!instance)
     {
         /* instance wasn't yet created, this is a message from the host loader */
         return VK_FALSE;
     }
 
+    wine_instance = CONTAINING_RECORD(object->instance, struct wine_instance, obj);
+
     if ((address = callback_data->pNext))
     {
         if (address->sType != VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT) address = NULL;
@@ -315,6 +339,8 @@ static VkBool32 debug_utils_callback_conversion(VkDebugUtilsMessageSeverityFlagB
         if (wine_vk_is_type_wrapped(objects[i].object_type))
         {
             objects[i].object_handle = client_handle_from_host(object->instance, objects[i].object_handle);
+            if (!objects[i].object_handle)
+                objects[i].object_handle = get_transient_handle(wine_instance);
             if (!objects[i].object_handle)
             {
                 WARN("handle conversion failed 0x%s\n", wine_dbgstr_longlong(callback_data->pObjects[i].objectHandle));
@@ -1272,6 +1298,8 @@ VkResult wine_vkCreateInstance(const VkInstanceCreateInfo *create_info,
             instance->quirks |= WINEVULKAN_QUIRK_GET_DEVICE_PROC_ADDR;
     }
 
+    pthread_key_create(&instance->transient_object_handle, free);
+
     TRACE("Created instance %p, host_instance %p.\n", instance, instance->obj.host.instance);
 
     for (i = 0; i < instance->phys_dev_count; i++)
@@ -1343,6 +1371,8 @@ void wine_vkDestroyInstance(VkInstance client_instance, const VkAllocationCallba
     }
     vulkan_instance_remove_object(&instance->obj, &instance->obj.obj);
 
+    pthread_key_delete(instance->transient_object_handle);
+
     if (instance->objects.compare) pthread_rwlock_destroy(&instance->objects_lock);
     free(instance->utils_messengers);
     free(instance);
@@ -2568,6 +2598,7 @@ VkResult wine_vkAllocateMemory(VkDevice client_device, const VkMemoryAllocateInf
     struct vulkan_device *device = vulkan_device_from_handle(client_device);
     struct wine_phys_dev *physical_device = CONTAINING_RECORD(device->physical_device, struct wine_phys_dev, obj);
     struct vulkan_instance *instance = device->physical_device->instance;
+    struct wine_instance *wine_instance = CONTAINING_RECORD(instance, struct wine_instance, obj);
     struct wine_device_memory *memory;
     VkMemoryAllocateInfo info = *alloc_info;
     VkImportMemoryHostPointerInfoEXT host_pointer_info;
@@ -2745,6 +2776,7 @@ VkResult wine_vkAllocateMemory(VkDevice client_device, const VkMemoryAllocateInf
         }
     }
 
+    set_transient_client_handle(wine_instance, (uintptr_t)memory);
     result = device->p_vkAllocateMemory(device->host.device, &info, NULL, &host_device_memory);
     if (result == VK_SUCCESS && memory->handle == INVALID_HANDLE_VALUE && export_info && export_info->handleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT)
     {
diff --git a/dlls/winevulkan/vulkan_private.h b/dlls/winevulkan/vulkan_private.h
index d01eb8f0914..9544a4785e2 100644
--- a/dlls/winevulkan/vulkan_private.h
+++ b/dlls/winevulkan/vulkan_private.h
@@ -97,6 +97,8 @@ struct wine_instance
     struct rb_tree objects;
     pthread_rwlock_t objects_lock;
 
+    pthread_key_t transient_object_handle;
+
     /* We cache devices as we need to wrap them as they are dispatchable objects. */
     uint32_t phys_dev_count;
     struct wine_phys_dev phys_devs[];
-- 
2.49.0

From 536b96d2e36e15e17c0f4ec29cbddf7fc9e13e64 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Sat, 11 Jan 2025 10:43:59 +0100
Subject: [PATCH 1068/1564] winevulkan: Use aligned types for 64bit atomics.

---
 dlls/winevulkan/vulkan.c         | 4 ++--
 dlls/winevulkan/vulkan_private.h | 4 ++--
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index 5ada61c09bb..47f598d5177 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -201,7 +201,7 @@ static void append_debug_utils_object(const VkDebugUtilsObjectNameInfoEXT *objec
     dst->object_name_len = append_string(object->pObjectName, strings, strings_len);
 }
 
-static void signal_timeline_sem(struct vulkan_device *device, VkSemaphore sem, uint64_t *value)
+static void signal_timeline_sem(struct vulkan_device *device, VkSemaphore sem, UINT64 *value)
 {
     /* May be called from native thread. */
     struct VkSemaphoreSignalInfo info = { 0 };
@@ -3739,7 +3739,7 @@ static void add_sem_signal_op(struct vulkan_device *device, struct wine_semaphor
         VkSemaphore *phys_semaphore, uint64_t *phys_signal_value, BOOL signal_immediate)
 {
     struct pending_d3d12_fence_op *op;
-    uint64_t value;
+    UINT64 value;
 
     pthread_mutex_lock(&device->signaller_mutex);
     if ((op = get_free_fence_op(device)))
diff --git a/dlls/winevulkan/vulkan_private.h b/dlls/winevulkan/vulkan_private.h
index 9544a4785e2..9a6a4680af5 100644
--- a/dlls/winevulkan/vulkan_private.h
+++ b/dlls/winevulkan/vulkan_private.h
@@ -123,7 +123,7 @@ struct keyed_mutex_shm
     uint64_t instance_id_counter;
     uint64_t acquired_to_instance;
     uint64_t key;
-    uint64_t timeline_value;
+    UINT64 timeline_value;
     uint64_t timeline_queued_release;
 };
 
@@ -217,7 +217,7 @@ struct wine_semaphore
     {
         /* Shared mem access mutex. The non-shared parts access is guarded with device global signaller_mutex. */
         pthread_mutex_t mutex;
-        uint64_t virtual_value, physical_value;
+        UINT64 virtual_value, physical_value;
         uint64_t last_reset_physical;
         uint64_t last_dropped_reset_physical;
         struct
-- 
2.49.0

From cbfed73d83f525cf424d22219a15cea83e075d71 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 21 Feb 2025 09:53:34 -0600
Subject: [PATCH 1440/1564] winevulkan: Filter out duplicate structures in
 VkDeviceCreateInfo chain.

CW-Bug-Id: #24917
---
 dlls/winevulkan/vulkan.c | 25 +++++++++++++++++++++++++
 1 file changed, 25 insertions(+)

diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index 47f598d5177..ffe892c03eb 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -1071,6 +1071,29 @@ VkResult wine_vkAllocateCommandBuffers(VkDevice client_device, const VkCommandBu
     return res;
 }
 
+static void filter_duplicate_structures(const VkBaseInStructure **in)
+{
+    const VkBaseInStructure *h;
+    VkBaseInStructure **h2;
+
+    for (h = *in; h; h = h->pNext)
+    {
+        if (h->sType == 1000284001 /*VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT*/
+                || h->sType == VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO)
+            continue;
+
+        for (h2 = (VkBaseInStructure **)in; *h2 != h; h2 = (VkBaseInStructure **)&(*h2)->pNext)
+        {
+            if ((*h2)->sType == h->sType)
+            {
+                ERR("Duplicate sType %d in the chain, keeping the last.\n", h->sType);
+                *h2 = (VkBaseInStructure *)(*h2)->pNext;
+                break;
+            }
+        }
+    }
+}
+
 VkResult wine_vkCreateDevice(VkPhysicalDevice client_physical_device, const VkDeviceCreateInfo *create_info,
                              const VkAllocationCallbacks *allocator, VkDevice *ret, void *client_ptr)
 {
@@ -1089,6 +1112,8 @@ VkResult wine_vkCreateDevice(VkPhysicalDevice client_physical_device, const VkDe
     void *native_create_device_context = NULL;
     VkCreateInfoWineDeviceCallback *callback;
 
+    filter_duplicate_structures((const VkBaseInStructure **)&create_info);
+
     if (allocator)
         FIXME("Support for allocation callbacks not implemented yet\n");
 
-- 
2.49.0

From 861289f7a9d550b70eb6376f614a269f78f8a956 Mon Sep 17 00:00:00 2001
From: Arkadiusz Hiler <ahiler@codeweavers.com>
Date: Mon, 21 Apr 2025 09:21:03 +0300
Subject: [PATCH 1489/1564] Revert "winevulkan: Filter out duplicate structures
 in VkDeviceCreateInfo chain."

This reverts commit b63f6a87e6602c7d29f3e89b5bf2d70ab08b2a80.

Not needed anymore.
---
 dlls/winevulkan/vulkan.c | 25 -------------------------
 1 file changed, 25 deletions(-)

diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index ffe892c03eb..47f598d5177 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -1071,29 +1071,6 @@ VkResult wine_vkAllocateCommandBuffers(VkDevice client_device, const VkCommandBu
     return res;
 }
 
-static void filter_duplicate_structures(const VkBaseInStructure **in)
-{
-    const VkBaseInStructure *h;
-    VkBaseInStructure **h2;
-
-    for (h = *in; h; h = h->pNext)
-    {
-        if (h->sType == 1000284001 /*VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT*/
-                || h->sType == VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO)
-            continue;
-
-        for (h2 = (VkBaseInStructure **)in; *h2 != h; h2 = (VkBaseInStructure **)&(*h2)->pNext)
-        {
-            if ((*h2)->sType == h->sType)
-            {
-                ERR("Duplicate sType %d in the chain, keeping the last.\n", h->sType);
-                *h2 = (VkBaseInStructure *)(*h2)->pNext;
-                break;
-            }
-        }
-    }
-}
-
 VkResult wine_vkCreateDevice(VkPhysicalDevice client_physical_device, const VkDeviceCreateInfo *create_info,
                              const VkAllocationCallbacks *allocator, VkDevice *ret, void *client_ptr)
 {
@@ -1112,8 +1089,6 @@ VkResult wine_vkCreateDevice(VkPhysicalDevice client_physical_device, const VkDe
     void *native_create_device_context = NULL;
     VkCreateInfoWineDeviceCallback *callback;
 
-    filter_duplicate_structures((const VkBaseInStructure **)&create_info);
-
     if (allocator)
         FIXME("Support for allocation callbacks not implemented yet\n");
 
-- 
2.49.0

--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -716,11 +716,17 @@
         struct conversion_context *ctx, const VkDeviceCreateInfo *src, VkDeviceCreateInfo *dst,
         struct vulkan_device *device)
 {
+    static const char *wine_xr_extension_name = "VK_WINE_openxr_device_extensions";
     struct wine_phys_dev *phys_dev = wine_phys_dev_from_handle(client_physical_device);
-    const char *extra_extensions[3], * const*extensions = src->ppEnabledExtensionNames;
+    const char *extra_extensions[65], * const*extensions = src->ppEnabledExtensionNames;
     unsigned int i, extra_count = 0, extensions_count = src->enabledExtensionCount;
+    unsigned int j, remove_count = 0;
+    const char *remove_extensions[65];
+    VkBaseOutStructure *header;
 
     *dst = *src;
+    if ((header = (VkBaseOutStructure *)dst->pNext) && header->sType == VK_STRUCTURE_TYPE_CREATE_INFO_WINE_DEVICE_CALLBACK)
+        dst->pNext = header->pNext;
 
     /* Should be filtered out by loader as ICDs don't support layers. */
     dst->enabledLayerCount = 0;


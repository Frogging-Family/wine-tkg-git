From f2c660f82a08369e6e76c99a12b4fc0db6878f88 Mon Sep 17 00:00:00 2001
From: llde <lorenzofersteam@live.it>
Date: Fri, 13 Jan 2023 15:30:12 +0100
Subject: [PATCH] winevulkan: implement shared resources

---
 dlls/winevulkan/make_vulkan      |  30 +-
 dlls/winevulkan/vulkan.c         | 594 ++++++++++++++++++++++++++-----
 dlls/winevulkan/vulkan_private.h |  82 +++++
 3 files changed, 617 insertions(+), 89 deletions(-)

diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index 20f6e464915..beb93d87ad2 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -113,7 +113,6 @@ UNSUPPORTED_EXTENSIONS = [
     "VK_EXT_physical_device_drm",
     "VK_GOOGLE_surfaceless_query",
     "VK_KHR_external_fence_fd",
-    "VK_KHR_external_memory_fd",
     "VK_KHR_external_semaphore_fd",
     "VK_SEC_amigo_profiling", # Angle specific.
 
@@ -129,7 +128,8 @@ UNSUPPORTED_EXTENSIONS = [
 # winevulkan may nonetheless use, or extensions we want to generate headers for
 # but not expose to applications (useful for test commits)
 UNEXPOSED_EXTENSIONS = {
-    "VK_KHR_external_memory_win32",
+#HACK With this the functions isn't generated in latest winevulkan commits. However as this is an unix only extension, it should be hidden in code 
+#    "VK_KHR_external_memory_fd", 
 }
 
 # The Vulkan loader provides entry-points for core functionality and important
@@ -195,7 +195,7 @@ FUNCTION_OVERRIDES = {
     "vkEnumerateDeviceLayerProperties": {"dispatch": True, "driver": False, "thunk": ThunkType.NONE},
     "vkEnumeratePhysicalDeviceGroups" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkEnumeratePhysicalDevices" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
-    "vkGetPhysicalDeviceExternalBufferProperties" : {"dispatch" : False, "driver" : False, "thunk" : ThunkType.NONE},
+    "vkGetPhysicalDeviceExternalBufferProperties" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkGetPhysicalDeviceExternalFenceProperties" : {"dispatch" : False, "driver" : False, "thunk" : ThunkType.NONE},
     "vkGetPhysicalDeviceExternalSemaphoreProperties" : {"dispatch" : False, "driver" : False, "thunk" : ThunkType.NONE},
     "vkGetPhysicalDeviceImageFormatProperties2" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.PRIVATE},
@@ -211,12 +211,12 @@ FUNCTION_OVERRIDES = {
     "vkGetDeviceProcAddr" : {"dispatch" : False, "driver" : True, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.NONE},
     "vkGetDeviceQueue" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkGetDeviceQueue2" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.NONE},
-    "vkAllocateMemory" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.PRIVATE},
-    "vkFreeMemory" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.PRIVATE},
+    "vkAllocateMemory" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
+    "vkFreeMemory" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkMapMemory" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.PRIVATE},
     "vkUnmapMemory" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.PRIVATE},
-    "vkCreateBuffer" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.PRIVATE},
-    "vkCreateImage" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.PRIVATE},
+    "vkCreateBuffer" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
+    "vkCreateImage" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
 
     # VK_KHR_surface
     "vkDestroySurfaceKHR" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.NONE},
@@ -245,7 +245,7 @@ FUNCTION_OVERRIDES = {
     "vkGetPhysicalDeviceExternalFencePropertiesKHR" : {"dispatch" : False, "driver" : False, "thunk" : ThunkType.NONE},
 
     # VK_KHR_external_memory_capabilities
-    "vkGetPhysicalDeviceExternalBufferPropertiesKHR" : {"dispatch" : False, "driver" : False, "thunk" : ThunkType.NONE},
+    "vkGetPhysicalDeviceExternalBufferPropertiesKHR" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkGetPhysicalDeviceImageFormatProperties2KHR" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.PRIVATE},
 
     # VK_KHR_external_semaphore_capabilities
@@ -269,12 +269,24 @@ FUNCTION_OVERRIDES = {
     # VK_EXT_debug_report
     "vkCreateDebugReportCallbackEXT" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkDestroyDebugReportCallbackEXT" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.NONE},
+       
+    # VK_KHR_external_memory_win32
+    "vkGetMemoryWin32HandleKHR" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
+    "vkGetMemoryWin32HandlePropertiesKHR" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
+
 }
 
 STRUCT_CHAIN_CONVERSIONS = {
     # Ignore to not confuse host loader.
     "VkDeviceCreateInfo": ["VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO"],
     "VkInstanceCreateInfo": ["VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO"],
+
+    # Structs which require pNext chain modification
+    # In current winevulkan this script doesn't generate struct chain converison function properly, so hand implment them and stub this 
+#    "VkBufferCreateInfo": [],
+ #   "VkImageCreateInfo": [],
+ #   "VkMemoryAllocateInfo": ["VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR", "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR"],
+#    "VkPhysicalDeviceImageFormatInfo2": [],
 }
 
 # Some struct members are conditionally ignored and callers are free to leave them uninitialized.
@@ -1474,7 +1486,7 @@ class VkMember(VkVariable):
                 if direction == Direction.OUTPUT:
                     LOGGER.err("OUTPUT parameter {0}.{1} cannot be unwrapped".format(self.type, self.name))
                 elif self.optional:
-                    return "{0}{1} = {2} ? {3} : 0;\n".format(output, self.name,
+                    return "{0}{1} = {2} ? {3} : VK_NULL_HANDLE;\n".format(output, self.name,
                         self.value(input, conv), handle.driver_handle(self.value(input, conv)))
                 else:
                     return "{0}{1} = {2};\n".format(output, self.name, handle.driver_handle(self.value(input, conv)))
diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index 1df10cc89a6..05aff5f0cde 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -23,6 +23,14 @@
 
 #include "config.h"
 #include <time.h>
+#include <unistd.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winnt.h"
+#include "winioctl.h"
+#include "wine/server.h"
 
 #include "vulkan_private.h"
 #include "wine/vulkan_driver.h"
@@ -45,6 +53,135 @@ static ULONG_PTR zero_bits(void)
 {
     return is_wow64() ? 0x7fffffff : 0;
 }
+static HANDLE create_gpu_resource(int fd, LPCWSTR name)
+{
+    static const WCHAR shared_gpu_resourceW[] = {'\\','?','?','\\','S','h','a','r','e','d','G','p','u','R','e','s','o','u','r','c','e',0};
+    HANDLE unix_resource = INVALID_HANDLE_VALUE;
+    struct shared_resource_create *inbuff;
+    UNICODE_STRING shared_gpu_resource_us;
+    HANDLE shared_resource;
+    OBJECT_ATTRIBUTES attr;
+    IO_STATUS_BLOCK iosb;
+    NTSTATUS status;
+    DWORD in_size;
+ 
+     TRACE("Creating shared vulkan resource fd %d name %s.\n", fd, debugstr_w(name));
+ 
+    if (wine_server_fd_to_handle(fd, GENERIC_ALL, 0, &unix_resource) != STATUS_SUCCESS)
+        return INVALID_HANDLE_VALUE;
+
+    init_unicode_string(&shared_gpu_resource_us, shared_gpu_resourceW);
+
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = 0;
+    attr.Attributes = 0;
+    attr.ObjectName = &shared_gpu_resource_us;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    if ((status = NtCreateFile(&shared_resource, GENERIC_READ | GENERIC_WRITE, &attr, &iosb, NULL, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, 0, NULL, 0)))
+    {
+        ERR("Failed to load open a shared resource handle, status %#lx.\n", (long int)status);
+        NtClose(unix_resource);
+        return INVALID_HANDLE_VALUE;
+    }
+
+    in_size = sizeof(*inbuff) + (name ? lstrlenW(name) * sizeof(WCHAR) : 0);
+    inbuff = calloc(1, in_size);
+    inbuff->unix_handle = wine_server_obj_handle(unix_resource);
+    if (name)
+        lstrcpyW(&inbuff->name[0], name);
+
+    if ((status = NtDeviceIoControlFile(shared_resource, NULL, NULL, NULL, &iosb, IOCTL_SHARED_GPU_RESOURCE_CREATE,
+            inbuff, in_size, NULL, 0)))
+
+    free(inbuff);
+    NtClose(unix_resource);
+    if (status)
+    {
+        ERR("Failed to create video resource, status %#lx.\n", (long int)status);
+        NtClose(shared_resource);
+        return INVALID_HANDLE_VALUE;
+    }
+
+    return shared_resource;
+}
+
+
+static HANDLE open_shared_resource(HANDLE kmt_handle, LPCWSTR name)
+{
+    static const WCHAR shared_gpu_resourceW[] = {'\\','?','?','\\','S','h','a','r','e','d','G','p','u','R','e','s','o','u','r','c','e',0};
+    UNICODE_STRING shared_gpu_resource_us;
+    struct shared_resource_open *inbuff;
+    HANDLE shared_resource;
+    OBJECT_ATTRIBUTES attr;
+    IO_STATUS_BLOCK iosb;
+    NTSTATUS status;
+    DWORD in_size;
+
+    init_unicode_string(&shared_gpu_resource_us, shared_gpu_resourceW);
+
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = 0;
+    attr.Attributes = 0;
+    attr.ObjectName = &shared_gpu_resource_us;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    if ((status = NtCreateFile(&shared_resource, GENERIC_READ | GENERIC_WRITE, &attr, &iosb, NULL, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, 0, NULL, 0)))
+    {
+        ERR("Failed to load open a shared resource handle, status %#lx.\n", (long int)status);
+        return INVALID_HANDLE_VALUE;
+    }
+
+    in_size = sizeof(*inbuff) + (name ? lstrlenW(name) * sizeof(WCHAR) : 0);
+    inbuff = calloc(1, in_size);
+    inbuff->kmt_handle = wine_server_obj_handle(kmt_handle);
+    if (name)
+        lstrcpyW(&inbuff->name[0], name);
+
+    status = NtDeviceIoControlFile(shared_resource, NULL, NULL, NULL, &iosb, IOCTL_SHARED_GPU_RESOURCE_OPEN,
+            inbuff, in_size, NULL, 0);
+
+    free(inbuff);
+
+    if (status)
+    {
+        ERR("Failed to open video resource, status %#lx.\n", (long int)status);
+        NtClose(shared_resource);
+        return INVALID_HANDLE_VALUE;
+    }
+
+    return shared_resource;
+}
+
+static int get_shared_resource_fd(HANDLE shared_resource)
+{
+    IO_STATUS_BLOCK iosb;
+    obj_handle_t unix_resource;
+    NTSTATUS status;
+    int ret;
+
+    if (NtDeviceIoControlFile(shared_resource, NULL, NULL, NULL, &iosb, IOCTL_SHARED_GPU_RESOURCE_GET_UNIX_RESOURCE,
+            NULL, 0, &unix_resource, sizeof(unix_resource)))
+        return -1;
+
+    status = wine_server_handle_to_fd(wine_server_ptr_handle(unix_resource), FILE_READ_DATA, &ret, NULL);
+    NtClose(wine_server_ptr_handle(unix_resource));
+    return status == STATUS_SUCCESS ? ret : -1;
+}
+
+static HANDLE get_shared_resource_kmt_handle(HANDLE shared_resource)
+{
+    IO_STATUS_BLOCK iosb;
+    obj_handle_t kmt_handle;
+
+    if (NtDeviceIoControlFile(shared_resource, NULL, NULL, NULL, &iosb, IOCTL_SHARED_GPU_RESOURCE_GETKMT,
+            NULL, 0, &kmt_handle, sizeof(kmt_handle)))
+        return INVALID_HANDLE_VALUE;
+
+    return wine_server_ptr_handle(kmt_handle);
+}
 
 #define wine_vk_count_struct(s, t) wine_vk_count_struct_((void *)s, VK_STRUCTURE_TYPE_##t)
 static uint32_t wine_vk_count_struct_(void *s, VkStructureType t)
@@ -267,11 +404,16 @@ static struct wine_phys_dev *wine_vk_physical_device_alloc(struct wine_instance
         ERR("Failed to enumerate device extensions, res=%d\n", res);
         goto err;
     }
+    if (!(object->extensions = calloc(num_host_properties, sizeof(*object->extensions))))
+    {
+        ERR("Failed to allocate memory for device extensions!\n");
+        goto err;
+    }
 
     /* Count list of extensions for which we have an implementation.
      * TODO: perform translation for platform specific extensions.
      */
-    for (i = 0; i < num_host_properties; i++)
+    for (i = 0, j = 0; i < num_host_properties; i++)
     {
         if (wine_vk_device_extension_supported(host_properties[i].extensionName))
         {
@@ -281,27 +423,26 @@ static struct wine_phys_dev *wine_vk_physical_device_alloc(struct wine_instance
         else
         {
             TRACE("Skipping extension '%s', no implementation found in winevulkan.\n", host_properties[i].extensionName);
+            continue;
         }
         if (!strcmp(host_properties[i].extensionName, "VK_EXT_external_memory_host"))
             have_external_memory_host = TRUE;
-    }
 
-    TRACE("Host supported extensions %u, Wine supported extensions %u\n", num_host_properties, num_properties);
-
-    if (!(object->extensions = calloc(num_properties, sizeof(*object->extensions))))
-    {
-        ERR("Failed to allocate memory for device extensions!\n");
-        goto err;
-    }
-
-    for (i = 0, j = 0; i < num_host_properties; i++)
-    {
-        if (wine_vk_device_extension_supported(host_properties[i].extensionName))
+        if (!strcmp(host_properties[i].extensionName, "VK_KHR_external_memory_fd"))
         {
-            object->extensions[j] = host_properties[i];
-            j++;
+            TRACE("Substituting VK_KHR_external_memory_fd with VK_KHR_external_memory_win32\n");
+
+            snprintf(host_properties[i].extensionName, sizeof(host_properties[i].extensionName),
+                    VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME);
+            host_properties[i].specVersion = VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION;
         }
+        object->extensions[j] = host_properties[i];
+        j++;
     }
+
+    TRACE("Host supported extensions %u, Wine supported extensions %u\n", num_host_properties, num_properties);
+
+    object->extensions = realloc(object->extensions, num_properties * sizeof(*object->extensions));
     object->extension_count = num_properties;
 
     if (use_external_memory() && have_external_memory_host)
@@ -394,39 +535,63 @@ static void wine_vk_device_get_queues(struct wine_device *device,
 static VkResult wine_vk_device_convert_create_info(struct wine_phys_dev *phys_dev,
         struct conversion_context *ctx, const VkDeviceCreateInfo *src, VkDeviceCreateInfo *dst)
 {
-    unsigned int i;
-
+    unsigned int i, found_external_mem = FALSE, found_ext_mem_host = FALSE;
+    int pos_ext_mem_win32 = -1;
+    const char **new_extensions;
+    unsigned int new_extension_count = src->enabledExtensionCount;
+    
     *dst = *src;
 
     /* Should be filtered out by loader as ICDs don't support layers. */
     dst->enabledLayerCount = 0;
     dst->ppEnabledLayerNames = NULL;
 
-    TRACE("Enabled %u extensions.\n", dst->enabledExtensionCount);
     for (i = 0; i < dst->enabledExtensionCount; i++)
     {
         const char *extension_name = dst->ppEnabledExtensionNames[i];
         TRACE("Extension %u: %s.\n", i, debugstr_a(extension_name));
-        if (!wine_vk_device_extension_supported(extension_name))
+        if (!strcmp(extension_name, "VK_KHR_external_memory"))
+        {
+            found_external_mem = TRUE;
+        }
+        if (!strcmp(extension_name, "VK_EXT_external_memory_host"))
+        {
+            found_ext_mem_host = TRUE;
+        }
+
+        if (!strcmp(extension_name, "VK_KHR_external_memory_win32"))
+        {
+            TRACE("Replacing VK_KHR_external_memory_win32 with VK_KHR_external_memory_fd for unix side device creation\n");
+            if(!wine_vk_device_extension_supported("VK_KHR_external_memory_fd")) /*Check if fd extension is available when asking for wine32 external memory*/
+            {
+                WARN("Extension %s is not supported.\n", debugstr_a("VK_KHR_external_memory_fd"));
+                return VK_ERROR_EXTENSION_NOT_PRESENT;
+            }
+            pos_ext_mem_win32 = i;
+        }
+        else if (!wine_vk_device_extension_supported(extension_name))
         {
             WARN("Extension %s is not supported.\n", debugstr_a(extension_name));
             return VK_ERROR_EXTENSION_NOT_PRESENT;
         }
     }
-
-    if (phys_dev->external_memory_align)
+    
+    if (phys_dev->external_memory_align && !found_external_mem) new_extension_count++;
+    if (phys_dev->external_memory_align && !found_ext_mem_host) new_extension_count++;
+    if (new_extension_count > dst->enabledExtensionCount || pos_ext_mem_win32 >= 0) /*Need extension fixup*/
     {
-        const char **new_extensions;
-
-        new_extensions = conversion_context_alloc(ctx, (dst->enabledExtensionCount + 2) *
-                                                  sizeof(*dst->ppEnabledExtensionNames));
-        memcpy(new_extensions, src->ppEnabledExtensionNames,
-               dst->enabledExtensionCount * sizeof(*dst->ppEnabledExtensionNames));
-        new_extensions[dst->enabledExtensionCount++] = "VK_KHR_external_memory";
-        new_extensions[dst->enabledExtensionCount++] = "VK_EXT_external_memory_host";
+        new_extensions = conversion_context_alloc(ctx, new_extension_count * sizeof(*dst->ppEnabledExtensionNames));
+        memcpy(new_extensions, src->ppEnabledExtensionNames, dst->enabledExtensionCount * sizeof(*dst->ppEnabledExtensionNames));
+        if(pos_ext_mem_win32)  new_extensions[pos_ext_mem_win32] = "VK_KHR_external_memory_fd";
+        if (phys_dev->external_memory_align)
+        {
+            if(!found_external_mem) new_extensions[dst->enabledExtensionCount++] = "VK_KHR_external_memory";
+            if(!found_ext_mem_host) new_extensions[dst->enabledExtensionCount++] = "VK_EXT_external_memory_host";
+        }
         dst->ppEnabledExtensionNames = new_extensions;
     }
-
+    
+    TRACE("Enabled %u extensions.\n", dst->enabledExtensionCount);
     return VK_SUCCESS;
 }
 
@@ -1216,64 +1381,136 @@ void wine_vkGetPhysicalDeviceExternalFencePropertiesKHR(VkPhysicalDevice phys_de
     properties->externalFenceFeatures = 0;
 }
 
+static inline void wine_vk_normalize_handle_types_win(VkExternalMemoryHandleTypeFlags *types)
+{
+    *types &=
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT;
+}
+
+static inline void wine_vk_normalize_handle_types_host(VkExternalMemoryHandleTypeFlags *types)
+{
+    *types &=
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT |
+/*      predicated on VK_KHR_external_memory_dma_buf
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT | */
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT;
+}
+
+static const VkExternalMemoryHandleTypeFlagBits wine_vk_handle_over_fd_types =
+                VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT | VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT;
+
+
+static void wine_vk_get_physical_device_external_buffer_properties(struct wine_phys_dev* phys_dev,
+        void (*p_vkGetPhysicalDeviceExternalBufferProperties)(VkPhysicalDevice, const VkPhysicalDeviceExternalBufferInfo *, VkExternalBufferProperties *),
+        const VkPhysicalDeviceExternalBufferInfo *buffer_info, VkExternalBufferProperties *properties)
+{
+    VkPhysicalDeviceExternalBufferInfo buffer_info_dup = *buffer_info;
+
+    wine_vk_normalize_handle_types_win(&buffer_info_dup.handleType);
+    if (buffer_info_dup.handleType & wine_vk_handle_over_fd_types)
+        buffer_info_dup.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
+    wine_vk_normalize_handle_types_host(&buffer_info_dup.handleType);
+
+    if (buffer_info->handleType && !buffer_info_dup.handleType)
+    {
+        memset(&properties->externalMemoryProperties, 0, sizeof(properties->externalMemoryProperties));
+        return;
+    }
+
+    p_vkGetPhysicalDeviceExternalBufferProperties(phys_dev->phys_dev, &buffer_info_dup, properties);
+
+    if (properties->externalMemoryProperties.exportFromImportedHandleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT)
+        properties->externalMemoryProperties.exportFromImportedHandleTypes |= wine_vk_handle_over_fd_types;
+    wine_vk_normalize_handle_types_win(&properties->externalMemoryProperties.exportFromImportedHandleTypes);
+
+    if (properties->externalMemoryProperties.compatibleHandleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT)
+        properties->externalMemoryProperties.compatibleHandleTypes |= wine_vk_handle_over_fd_types;
+    wine_vk_normalize_handle_types_win(&properties->externalMemoryProperties.compatibleHandleTypes);
+}
+
 void wine_vkGetPhysicalDeviceExternalBufferProperties(VkPhysicalDevice phys_dev,
                                                       const VkPhysicalDeviceExternalBufferInfo *buffer_info,
                                                       VkExternalBufferProperties *properties)
 {
-    memset(&properties->externalMemoryProperties, 0, sizeof(properties->externalMemoryProperties));
+    struct wine_phys_dev * actual_phys_dev = wine_phys_dev_from_handle(phys_dev);
+    wine_vk_get_physical_device_external_buffer_properties(actual_phys_dev, actual_phys_dev->instance->funcs.p_vkGetPhysicalDeviceExternalBufferProperties, buffer_info, properties);
 }
 
 void wine_vkGetPhysicalDeviceExternalBufferPropertiesKHR(VkPhysicalDevice phys_dev,
                                                          const VkPhysicalDeviceExternalBufferInfo *buffer_info,
                                                          VkExternalBufferProperties *properties)
 {
-    memset(&properties->externalMemoryProperties, 0, sizeof(properties->externalMemoryProperties));
+    struct wine_phys_dev * actual_phys_dev = wine_phys_dev_from_handle(phys_dev);
+    wine_vk_get_physical_device_external_buffer_properties(actual_phys_dev, actual_phys_dev->instance->funcs.p_vkGetPhysicalDeviceExternalBufferPropertiesKHR, buffer_info, properties);
 }
 
-VkResult wine_vkGetPhysicalDeviceImageFormatProperties2(VkPhysicalDevice phys_dev_handle,
-                                                        const VkPhysicalDeviceImageFormatInfo2 *format_info,
-                                                        VkImageFormatProperties2 *properties)
+static VkResult wine_vk_get_physical_device_image_format_properties_2(struct wine_phys_dev* phys_dev,
+        VkResult (*p_vkGetPhysicalDeviceImageFormatProperties2)(VkPhysicalDevice, const VkPhysicalDeviceImageFormatInfo2*, VkImageFormatProperties2*),
+        const VkPhysicalDeviceImageFormatInfo2 *format_info, VkImageFormatProperties2 *properties)
 {
-    struct wine_phys_dev *phys_dev = wine_phys_dev_from_handle(phys_dev_handle);
+    VkPhysicalDeviceExternalImageFormatInfo external_image_info_dup;
+    const VkPhysicalDeviceExternalImageFormatInfo *external_image_info;
     VkExternalImageFormatProperties *external_image_properties;
     VkResult res;
+    if ((external_image_info = find_next_struct(format_info, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO)) && external_image_info->handleType)
+    {
+        external_image_info_dup = *external_image_info;
+ 
+        wine_vk_normalize_handle_types_win(&external_image_info_dup.handleType);
+ 
+        if (external_image_info_dup.handleType & wine_vk_handle_over_fd_types)
+            external_image_info_dup.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
 
-    res = phys_dev->instance->funcs.p_vkGetPhysicalDeviceImageFormatProperties2(phys_dev->phys_dev,
-            format_info, properties);
-
-    if ((external_image_properties = find_next_struct(properties,
-                                                      VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES)))
+        wine_vk_normalize_handle_types_host(&external_image_info_dup.handleType);
+        if (!external_image_info_dup.handleType)
+        {
+            WARN("Unsupported handle type %#x.\n", external_image_info->handleType);
+            return VK_ERROR_FORMAT_NOT_SUPPORTED;
+        }
+        link_in_pchain(format_info, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO, &external_image_info_dup);
+    }
+ 
+    res = p_vkGetPhysicalDeviceImageFormatProperties2(phys_dev->phys_dev, format_info, properties);
+    if (external_image_info && external_image_info->handleType) 
+        link_in_pchain(format_info, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO, external_image_info); /*Restore correct pChain structure*/
+    
+    if ((external_image_properties = find_next_struct(properties, VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES)))
     {
         VkExternalMemoryProperties *p = &external_image_properties->externalMemoryProperties;
-        p->externalMemoryFeatures = 0;
-        p->exportFromImportedHandleTypes = 0;
-        p->compatibleHandleTypes = 0;
+        if (p->exportFromImportedHandleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT)
+            p->exportFromImportedHandleTypes |= wine_vk_handle_over_fd_types;
+        wine_vk_normalize_handle_types_win(&p->exportFromImportedHandleTypes);
+
+        if (p->compatibleHandleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT)
+            p->compatibleHandleTypes |= wine_vk_handle_over_fd_types;
+        wine_vk_normalize_handle_types_win(&p->compatibleHandleTypes);
     }
 
-    return res;
+    return res; 
+}
+
+VkResult wine_vkGetPhysicalDeviceImageFormatProperties2(VkPhysicalDevice phys_dev_handle,
+                                                        const VkPhysicalDeviceImageFormatInfo2 *format_info,
+                                                        VkImageFormatProperties2 *properties)
+{
+    struct wine_phys_dev* phys_dev = wine_phys_dev_from_handle(phys_dev_handle);
+    return wine_vk_get_physical_device_image_format_properties_2(phys_dev, phys_dev->instance->funcs.p_vkGetPhysicalDeviceImageFormatProperties2, format_info, properties);
 }
 
 VkResult wine_vkGetPhysicalDeviceImageFormatProperties2KHR(VkPhysicalDevice phys_dev_handle,
                                                            const VkPhysicalDeviceImageFormatInfo2 *format_info,
                                                            VkImageFormatProperties2 *properties)
 {
-    struct wine_phys_dev *phys_dev = wine_phys_dev_from_handle(phys_dev_handle);
-    VkExternalImageFormatProperties *external_image_properties;
-    VkResult res;
-
-    res = phys_dev->instance->funcs.p_vkGetPhysicalDeviceImageFormatProperties2KHR(phys_dev->phys_dev,
-            format_info, properties);
-
-    if ((external_image_properties = find_next_struct(properties,
-                                                      VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES)))
-    {
-        VkExternalMemoryProperties *p = &external_image_properties->externalMemoryProperties;
-        p->externalMemoryFeatures = 0;
-        p->exportFromImportedHandleTypes = 0;
-        p->compatibleHandleTypes = 0;
-    }
-
-    return res;
+    struct wine_phys_dev* phys_dev = wine_phys_dev_from_handle(phys_dev_handle);
+    return wine_vk_get_physical_device_image_format_properties_2(phys_dev, phys_dev->instance->funcs.p_vkGetPhysicalDeviceImageFormatProperties2KHR, format_info, properties);
 }
 
 /* From ntdll/unix/sync.c */
@@ -1496,12 +1733,29 @@ VkResult wine_vkAllocateMemory(VkDevice handle, const VkMemoryAllocateInfo *allo
 {
     struct wine_device *device = wine_device_from_handle(handle);
     struct wine_device_memory *memory;
-    VkMemoryAllocateInfo info = *alloc_info;
+    VkMemoryAllocateInfo info;
     VkImportMemoryHostPointerInfoEXT host_pointer_info;
+    const VkImportMemoryWin32HandleInfoKHR *handle_import_info = NULL;
+    const VkExportMemoryWin32HandleInfoKHR *handle_export_info = NULL;
+    VkBaseOutStructure *pre_i = NULL, *pre_e = NULL;
+    int fd;
+    VkExportMemoryAllocateInfo *export_info = NULL;
+    VkImportMemoryFdInfoKHR fd_import_info;
     uint32_t mem_flags;
     void *mapping = NULL;
     VkResult result;
+    VkMemoryGetFdInfoKHR get_fd_info;
+    SIZE_T alloc_size = alloc_info->allocationSize;
+
+    if (!(memory = malloc(sizeof(*memory))))
+        return VK_ERROR_OUT_OF_HOST_MEMORY;
 
+    export_info = find_next_struct(alloc_info,VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO);
+    handle_import_info = find_next_struct(alloc_info, VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR);
+    handle_export_info = find_next_struct(alloc_info, VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR);
+    if(handle_import_info) pre_i = unlink_in_pchain(alloc_info,VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR );
+    if(handle_export_info) pre_e = unlink_in_pchain(alloc_info,VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR );
+    info = *alloc_info;
     /* For host visible memory, we try to use VK_EXT_external_memory_host on wow64
      * to ensure that mapped pointer is 32-bit. */
     mem_flags = device->phys_dev->memory_properties.memoryTypes[alloc_info->memoryTypeIndex].propertyFlags;
@@ -1513,17 +1767,16 @@ VkResult wine_vkAllocateMemory(VkDevice handle, const VkMemoryAllocateInfo *allo
             .sType = VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT,
         };
         uint32_t i, align = device->phys_dev->external_memory_align - 1;
-        SIZE_T alloc_size = info.allocationSize;
         static int once;
 
         if (!once++)
             FIXME("Using VK_EXT_external_memory_host\n");
 
-        if (NtAllocateVirtualMemory(GetCurrentProcess(), &mapping, zero_bits(), &alloc_size,
-                                    MEM_COMMIT, PAGE_READWRITE))
+        if ((result = NtAllocateVirtualMemory(GetCurrentProcess(), &mapping, zero_bits(), &alloc_size,
+                                    MEM_COMMIT, PAGE_READWRITE)))
         {
             ERR("NtAllocateVirtualMemory failed\n");
-            return VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto done;
         }
 
         result = device->funcs.p_vkGetMemoryHostPointerPropertiesEXT(device->device,
@@ -1531,7 +1784,7 @@ VkResult wine_vkAllocateMemory(VkDevice handle, const VkMemoryAllocateInfo *allo
         if (result != VK_SUCCESS)
         {
             ERR("vkGetMemoryHostPointerPropertiesEXT failed: %d\n", result);
-            return result;
+            goto done;
         }
 
         if (!(props.memoryTypeBits & (1u << info.memoryTypeIndex)))
@@ -1569,19 +1822,116 @@ VkResult wine_vkAllocateMemory(VkDevice handle, const VkMemoryAllocateInfo *allo
             info.allocationSize = (info.allocationSize + align) & ~align;
         }
     }
+    
+    memory->memory = VK_NULL_HANDLE;
+    memory->handle = INVALID_HANDLE_VALUE;
+    fd_import_info.fd = -1;
+    fd_import_info.pNext = NULL;
+    if (handle_export_info && handle_export_info->pAttributes && handle_export_info->pAttributes->lpSecurityDescriptor)
+        FIXME("Support for custom security descriptor not implemented.\n");
 
-    if (!(memory = malloc(sizeof(*memory))))
-        return VK_ERROR_OUT_OF_HOST_MEMORY;
+    /* find and process handle import/export info and grab it */
+    if (export_info)
+    {
+        memory->handle_types = export_info->handleTypes;
+        if (export_info->handleTypes & wine_vk_handle_over_fd_types)
+            export_info->handleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
+        wine_vk_normalize_handle_types_host(&export_info->handleTypes);
+    }
 
-    result = device->funcs.p_vkAllocateMemory(device->device, &info, NULL, &memory->memory);
-    if (result != VK_SUCCESS)
+    /* Vulkan consumes imported FDs, but not imported HANDLEs */
+    if (handle_import_info)
     {
-        free(memory);
-        return result;
+        fd_import_info.sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR;
+        fd_import_info.pNext = info.pNext;
+        fd_import_info.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
+
+        switch (handle_import_info->handleType)
+        {
+            case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT:
+                if (handle_import_info->handle)
+                    NtDuplicateObject( NtCurrentProcess(), handle_import_info->handle, NtCurrentProcess(), &memory->handle, 0, 0, DUPLICATE_SAME_ACCESS );
+                else if (handle_import_info->name)
+                    memory->handle = open_shared_resource( 0, handle_import_info->name );
+                break;
+            case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
+                /* FIXME: the spec says that device memory imported from a KMT handle doesn't keep a reference to the underyling payload.
+                   This means that in cases where on windows an application leaks VkDeviceMemory objects, we leak the full payload.  To
+                   fix this, we would need wine_dev_mem objects to store no reference to the payload, that means no host VkDeviceMemory
+                   object (as objects imported from FDs hold a reference to the payload), and no win32 handle to the object. We would then
+                   extend make_vulkan to have the thunks converting wine_dev_mem to native handles open the VkDeviceMemory from the KMT
+                   handle, use it in the host function, then close it again. */
+                memory->handle = open_shared_resource( handle_import_info->handle, NULL );
+                break;
+            default:
+                WARN("Invalid handle type %08x passed in.\n", handle_import_info->handleType);
+                result = VK_ERROR_INVALID_EXTERNAL_HANDLE;
+                goto done;
+        }
+
+        if (memory->handle != INVALID_HANDLE_VALUE)
+            fd_import_info.fd = get_shared_resource_fd(memory->handle);
+
+        if (fd_import_info.fd == -1)
+        {
+            TRACE("Couldn't access resource handle or name. type=%08x handle=%p name=%s\n", handle_import_info->handleType, handle_import_info->handle,
+                    handle_import_info->name ? debugstr_w(handle_import_info->name) : "");
+            result = VK_ERROR_INVALID_EXTERNAL_HANDLE;
+            goto done;
+        }
+    }
+    info.pNext = fd_import_info.fd == -1 ? info.pNext : &fd_import_info;
+
+    result = device->funcs.p_vkAllocateMemory(device->device, &info, NULL, &memory->memory);
+    if( result != VK_SUCCESS) goto done;
+    if (memory->handle == INVALID_HANDLE_VALUE && export_info && export_info->handleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT)
+    {
+        get_fd_info.sType = VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR;
+        get_fd_info.pNext = NULL;
+        get_fd_info.memory = memory->memory;
+        get_fd_info.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
+        if (device->funcs.p_vkGetMemoryFdKHR(device->device, &get_fd_info, &fd) == VK_SUCCESS)
+        {
+            memory->handle = create_gpu_resource(fd, handle_export_info ? handle_export_info->name : NULL);
+            memory->access = handle_export_info ? handle_export_info->dwAccess : GENERIC_ALL;
+            if (handle_export_info && handle_export_info->pAttributes)
+                memory->inherit = handle_export_info->pAttributes->bInheritHandle;
+            else
+                memory->inherit = FALSE;
+            close(fd);
+        }
+        if (memory->handle == INVALID_HANDLE_VALUE)
+        {
+            result = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto done;
+        }
     }
 
     memory->mapping = mapping;
     *ret = (VkDeviceMemory)(uintptr_t)memory;
+    
+done:
+    if (export_info)
+    {
+        export_info->handleTypes = memory->handle_types;
+    }
+    if(handle_export_info)  relink_in_pchain(alloc_info, handle_export_info, pre_e );
+    if(handle_export_info)  relink_in_pchain(alloc_info, handle_import_info, pre_i  );
+    
+    if(result != VK_SUCCESS)
+    {
+        if (fd_import_info.fd != -1)
+            close(fd_import_info.fd);
+        if (memory->handle != INVALID_HANDLE_VALUE)
+            NtClose(memory->handle);
+        if (memory->memory) 
+            device->funcs.p_vkFreeMemory(device->device, memory->memory, NULL);
+        if (alloc_size != 0 && mapping ) 
+            NtFreeVirtualMemory(GetCurrentProcess(), &mapping, &alloc_size, MEM_RELEASE);
+
+        free(memory);
+        return result;
+    }
     return VK_SUCCESS;
 }
 
@@ -1602,6 +1952,9 @@ void wine_vkFreeMemory(VkDevice handle, VkDeviceMemory memory_handle, const VkAl
         NtFreeVirtualMemory(GetCurrentProcess(), &memory->mapping, &alloc_size, MEM_RELEASE);
     }
 
+    if (memory->handle != INVALID_HANDLE_VALUE)
+        NtClose(memory->handle);
+
     free(memory);
 }
 
@@ -1647,30 +2000,59 @@ VkResult wine_vkCreateBuffer(VkDevice handle, const VkBufferCreateInfo *create_i
                              const VkAllocationCallbacks *allocator, VkBuffer *buffer)
 {
     struct wine_device *device = wine_device_from_handle(handle);
-    VkExternalMemoryBufferCreateInfo external_memory_info;
+    VkExternalMemoryBufferCreateInfo external_memory_info, *memory_info;
     VkBufferCreateInfo info = *create_info;
+    VkResult res;
+
+    memory_info = find_next_struct(info.pNext, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO);
+    if(memory_info)
+    {
+        external_memory_info = *memory_info;
+        if (external_memory_info.handleTypes & wine_vk_handle_over_fd_types)
+            external_memory_info.handleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR;
+        wine_vk_normalize_handle_types_host(&external_memory_info.handleTypes);
+        link_in_pchain(&info, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO, &external_memory_info);
+    }
 
     if (device->phys_dev->external_memory_align &&
-        !find_next_struct(info.pNext, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO))
+        !memory_info)
     {
         external_memory_info.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
         external_memory_info.pNext = info.pNext;
         external_memory_info.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT;
         info.pNext = &external_memory_info;
     }
+    
+    res = device->funcs.p_vkCreateBuffer(device->device, &info, NULL, buffer);
+    
+    if(memory_info)
+    {
+        link_in_pchain(&info, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO, memory_info); /*Restore pChain*/
+    }
 
-    return device->funcs.p_vkCreateBuffer(device->device, &info, NULL, buffer);
+    return res;
 }
 
 VkResult wine_vkCreateImage(VkDevice handle, const VkImageCreateInfo *create_info,
                             const VkAllocationCallbacks *allocator, VkImage *image)
 {
     struct wine_device *device = wine_device_from_handle(handle);
-    VkExternalMemoryImageCreateInfo external_memory_info;
+    VkExternalMemoryImageCreateInfo external_memory_info, *memory_info;
     VkImageCreateInfo info = *create_info;
+    VkResult res;
+    
+    memory_info = find_next_struct(info.pNext, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO);
+    if(memory_info)
+    {
+        external_memory_info = *memory_info;
+        if (external_memory_info.handleTypes & wine_vk_handle_over_fd_types)
+            external_memory_info.handleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR;
+        wine_vk_normalize_handle_types_host(&external_memory_info.handleTypes);
+        link_in_pchain(&info, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO, &external_memory_info);
+    }
 
     if (device->phys_dev->external_memory_align &&
-        !find_next_struct(info.pNext, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO))
+        !memory_info)
     {
         external_memory_info.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
         external_memory_info.pNext = info.pNext;
@@ -1678,7 +2060,12 @@ VkResult wine_vkCreateImage(VkDevice handle, const VkImageCreateInfo *create_inf
         info.pNext = &external_memory_info;
     }
 
-    return device->funcs.p_vkCreateImage(device->device, &info, NULL, image);
+    res = device->funcs.p_vkCreateImage(device->device, &info, NULL, image);
+    if(memory_info)
+    {
+        link_in_pchain(&info, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO, memory_info); /*Restore pChain*/
+    }
+    return res;
 }
 
 static inline void adjust_max_image_count(struct wine_phys_dev *phys_dev, VkSurfaceCapabilitiesKHR* capabilities)
@@ -1859,6 +2246,9 @@ NTSTATUS vk_is_available_device_function(void *arg)
 {
     struct is_available_device_function_params *params = arg;
     struct wine_device *device = wine_device_from_handle(params->device);
+    if (!strcmp(params->name, "vkGetMemoryWin32HandleKHR") || !strcmp(params->name, "vkGetMemoryWin32HandlePropertiesKHR"))
+        return !!vk_funcs->p_vkGetDeviceProcAddr(device->device, "vkGetMemoryFdKHR");
+
     return !!vk_funcs->p_vkGetDeviceProcAddr(device->device, params->name);
 }
 
@@ -1883,5 +2273,49 @@ NTSTATUS vk_is_available_device_function32(void *arg)
         UINT32 name;
     } *params = arg;
     struct wine_device *device = wine_device_from_handle(UlongToPtr(params->device));
+    if (!strcmp(UlongToPtr(params->name), "vkGetMemoryWin32HandleKHR") || !strcmp(UlongToPtr(params->name), "vkGetMemoryWin32HandlePropertiesKHR"))
+        return !!vk_funcs->p_vkGetDeviceProcAddr(device->device, "vkGetMemoryFdKHR");
+    
     return !!vk_funcs->p_vkGetDeviceProcAddr(device->device, UlongToPtr(params->name));
 }
+
+VkResult wine_vkGetMemoryWin32HandlePropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits type, HANDLE handle, VkMemoryWin32HandlePropertiesKHR *properties)
+{
+    TRACE("%p %u %p %p\n", device, type, handle, properties);
+    /* VUID-vkGetMemoryWin32HandlePropertiesKHR-handleType-00666
+       handleType must not be one of the handle types defined as opaque */
+    return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+}
+
+VkResult wine_vkGetMemoryWin32HandleKHR(VkDevice device, const VkMemoryGetWin32HandleInfoKHR *handle_info, HANDLE *handle)
+{
+    HANDLE ret;
+    
+    struct wine_device_memory *dev_mem = wine_device_memory_from_handle(handle_info->memory);
+    const VkBaseInStructure *chain;
+    
+    TRACE("%p, %p %p\n", device, handle_info, handle);
+
+    if (!(dev_mem->handle_types & handle_info->handleType))
+        return VK_ERROR_UNKNOWN;
+
+    if ((chain = handle_info->pNext))
+        FIXME("Ignoring a linked structure of type %u.\n", chain->sType);
+
+    switch(handle_info->handleType)
+    {
+        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT:
+            return !NtDuplicateObject( NtCurrentProcess(), dev_mem->handle, NtCurrentProcess(), handle, dev_mem->access, dev_mem->inherit ? OBJ_INHERIT : 0, 0) ?
+                VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY;
+        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
+        {
+            if ((ret = get_shared_resource_kmt_handle(dev_mem->handle)) == INVALID_HANDLE_VALUE)
+                return VK_ERROR_OUT_OF_HOST_MEMORY;
+            *handle = ret;
+            return VK_SUCCESS;
+        }
+        default:
+            FIXME("Unable to get handle of type %x, did the application ignore the capabilities?\n", handle_info->handleType);
+            return VK_ERROR_UNKNOWN;
+    }
+}
diff --git a/dlls/winevulkan/vulkan_private.h b/dlls/winevulkan/vulkan_private.h
index 60e21114940..a33e0ca9277 100644
--- a/dlls/winevulkan/vulkan_private.h
+++ b/dlls/winevulkan/vulkan_private.h
@@ -25,9 +25,13 @@
 
 #include <pthread.h>
 
+
 #include "vulkan_loader.h"
 #include "vulkan_thunks.h"
 
+#define WIN32_NO_STATUS
+#include "wine/server.h"
+
 /* Some extensions have callbacks for those we need to be able to
  * get the wine wrapper for a native handle
  */
@@ -175,6 +179,13 @@ static inline struct wine_cmd_pool *wine_cmd_pool_from_handle(VkCommandPool hand
 struct wine_device_memory
 {
     VkDeviceMemory memory;
+    VkExternalMemoryHandleTypeFlagBits handle_types;
+
+    BOOL inherit;
+    DWORD access;
+
+    HANDLE handle;
+
     void *mapping;
 };
 
@@ -327,4 +338,75 @@ static inline void *find_next_struct(const void *s, VkStructureType t)
     return NULL;
 }
 
+/*
+ Replace the first occurence of the type structure in the pchain with another instance of said structure.
+ For when the type isn't first occurrence of the chain.
+ */
+static inline void  link_in_pchain(const void* in, VkStructureType type, const void* repl )
+{
+    VkBaseOutStructure* prev = NULL;
+    VkBaseOutStructure *header;
+    VkBaseOutStructure* replc = (VkBaseOutStructure*) repl;
+    for (header = (VkBaseOutStructure*)in; header; header = header->pNext)
+    {
+        if (header->sType == type)
+        {
+            break;
+        }
+        prev = header;
+    }
+    prev->pNext = replc;
+}
+/*
+ Remove the first occurrence of the type member of the pChain returning it's parent
+ */
+static inline VkBaseOutStructure* unlink_in_pchain(const void* in, VkStructureType type)
+{
+    VkBaseOutStructure *header;
+    VkBaseOutStructure* prev = NULL;
+    for (header = (VkBaseOutStructure*)in; header; header = header->pNext)
+    {
+        if (header->sType == type)
+        {
+            prev->pNext = header->pNext;
+            break;
+        }
+        prev = header;
+    }
+    return prev;
+}
+/*
+ Re-link struct in pchain, linking it to prev
+ */
+static inline void relink_in_pchain(const void* in, const void* rein, VkBaseOutStructure* prev)
+{
+    VkBaseOutStructure* reinc = (VkBaseOutStructure*) rein;
+    reinc->pNext = prev->pNext;
+    prev->pNext = reinc;
+}
+
+struct shared_resource_open
+{
+    obj_handle_t kmt_handle;
+    WCHAR name[1];
+};
+
+struct shared_resource_create
+{
+    obj_handle_t unix_handle;
+    WCHAR name[1];
+};
+
+static inline void init_unicode_string( UNICODE_STRING *str, const WCHAR *data )
+{
+    str->Length = lstrlenW(data) * sizeof(WCHAR);
+    str->MaximumLength = str->Length + sizeof(WCHAR);
+    str->Buffer = (WCHAR *)data;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_CREATE           CTL_CODE(FILE_DEVICE_VIDEO, 0, METHOD_BUFFERED, FILE_WRITE_ACCESS)
+#define IOCTL_SHARED_GPU_RESOURCE_OPEN             CTL_CODE(FILE_DEVICE_VIDEO, 1, METHOD_BUFFERED, FILE_WRITE_ACCESS)
+#define IOCTL_SHARED_GPU_RESOURCE_GET_UNIX_RESOURCE           CTL_CODE(FILE_DEVICE_VIDEO, 3, METHOD_BUFFERED, FILE_READ_ACCESS)
+#define IOCTL_SHARED_GPU_RESOURCE_GETKMT           CTL_CODE(FILE_DEVICE_VIDEO, 2, METHOD_BUFFERED, FILE_READ_ACCESS)
+
 #endif /* __WINE_VULKAN_PRIVATE_H */
-- 
2.39.0


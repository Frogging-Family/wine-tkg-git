From a2efaf1d8b8a848dfe60d5c45238d48a6a653b68 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 13 Jul 2022 13:08:41 -0400
Subject: [PATCH 02/14] ntoskrnl, server: Support referencing section objects.

Needed for the shared resource manager to track the shared memory object for shared fences.
---
 dlls/ntoskrnl.exe/ntoskrnl.c | 12 +++++++++++-
 server/mapping.c             | 14 +++++++++++++-
 2 files changed, 24 insertions(+), 2 deletions(-)

diff --git a/dlls/ntoskrnl.exe/ntoskrnl.c b/dlls/ntoskrnl.exe/ntoskrnl.c
index 38a25bc5092..1802d483bbf 100644
--- a/dlls/ntoskrnl.exe/ntoskrnl.c
+++ b/dlls/ntoskrnl.exe/ntoskrnl.c
@@ -260,6 +260,15 @@ POBJECT_TYPE WINAPI ObGetObjectType( void *object )
     return header->type;
 }
 
+static const WCHAR section_type_name[] = {'S','e','c','t','i','o','n',0};
+
+static struct _OBJECT_TYPE section_type =
+{
+    section_type_name
+};
+
+static POBJECT_TYPE p_section_type = &section_type;
+
 static const POBJECT_TYPE *known_types[] =
 {
     &ExEventObjectType,
@@ -269,7 +278,8 @@ static const POBJECT_TYPE *known_types[] =
     &IoFileObjectType,
     &PsProcessType,
     &PsThreadType,
-    &SeTokenObjectType
+    &SeTokenObjectType,
+    &p_section_type,
 };
 
 DECLARE_CRITICAL_SECTION(handle_map_cs);
diff --git a/server/mapping.c b/server/mapping.c
index 4c90673a5c5..67896165048 100644
--- a/server/mapping.c
+++ b/server/mapping.c
@@ -160,6 +160,7 @@ struct type_descr mapping_type =
 struct mapping
 {
     struct object   obj;             /* object header */
+    struct list     kernel_object;   /* list of kernel object pointers */
     mem_size_t      size;            /* mapping size */
     unsigned int    flags;           /* SEC_* flags */
     struct fd      *fd;              /* fd for mapped file */
@@ -171,6 +172,7 @@ struct mapping
 
 static void mapping_dump( struct object *obj, int verbose );
 static struct fd *mapping_get_fd( struct object *obj );
+static struct list *mapping_get_kernel_obj_list( struct object *obj );
 static void mapping_destroy( struct object *obj );
 static enum server_fd_type mapping_get_fd_type( struct fd *fd );
 
@@ -195,7 +197,7 @@ static const struct object_ops mapping_ops =
     directory_link_name,         /* link_name */
     default_unlink_name,         /* unlink_name */
     no_open_file,                /* open_file */
-    no_kernel_obj_list,          /* get_kernel_obj_list */
+    mapping_get_kernel_obj_list, /* get_kernel_obj_list */
     no_close_handle,             /* close_handle */
     mapping_destroy              /* destroy */
 };
@@ -903,6 +905,8 @@ static struct mapping *create_mapping( struct object *root, const struct unicode
     if (get_error() == STATUS_OBJECT_NAME_EXISTS)
         return mapping;  /* Nothing else to do */
 
+    list_init( &mapping->kernel_object );
+
     mapping->size        = size;
     mapping->fd          = NULL;
     mapping->shared      = NULL;
@@ -995,6 +999,8 @@ struct mapping *create_fd_mapping( struct object *root, const struct unicode_str
     if (!(mapping = create_named_object( root, &mapping_ops, name, attr, sd ))) return NULL;
     if (get_error() == STATUS_OBJECT_NAME_EXISTS) return mapping;  /* Nothing else to do */
 
+    list_init( &mapping->kernel_object );
+
     mapping->shared    = NULL;
     mapping->committed = NULL;
     mapping->flags     = SEC_FILE;
@@ -1101,6 +1107,12 @@ static struct fd *mapping_get_fd( struct object *obj )
     return (struct fd *)grab_object( mapping->fd );
 }
 
+static struct list *mapping_get_kernel_obj_list( struct object *obj )
+{
+    struct mapping *mapping = (struct mapping *)obj;
+    return &mapping->kernel_object;
+}
+
 static void mapping_destroy( struct object *obj )
 {
     struct mapping *mapping = (struct mapping *)obj;
-- 
2.37.1

From 730fd8b7cb22b630b82be1e12104bdfe5946a027 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 13 Jul 2022 13:11:22 -0400
Subject: [PATCH 03/14] sharedgpures.sys: Keep index into resource pool in
 FsContext instead of direct pointer to resource.

This fixes the errors due to the pointers in FsContext becoming invalid when the resource pool was expanded.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/sharedgpures.sys/shared_resource.c | 19 +++++++++++--------
 1 file changed, 11 insertions(+), 8 deletions(-)

diff --git a/dlls/sharedgpures.sys/shared_resource.c b/dlls/sharedgpures.sys/shared_resource.c
index b0a2aebdb01..0cd30c4a256 100644
--- a/dlls/sharedgpures.sys/shared_resource.c
+++ b/dlls/sharedgpures.sys/shared_resource.c
@@ -285,7 +285,7 @@ static NTSTATUS WINAPI dispatch_create(DEVICE_OBJECT *device, IRP *irp)
 static NTSTATUS WINAPI dispatch_close(DEVICE_OBJECT *device, IRP *irp)
 {
     IO_STACK_LOCATION *stack = IoGetCurrentIrpStackLocation(irp);
-    struct shared_resource *res = stack->FileObject->FsContext;
+    struct shared_resource *res = &resource_pool[ (UINT_PTR) stack->FileObject->FsContext ];
 
     TRACE("Freeing shared resouce %p.\n", res);
 
@@ -316,7 +316,7 @@ static NTSTATUS WINAPI dispatch_close(DEVICE_OBJECT *device, IRP *irp)
 static NTSTATUS WINAPI dispatch_ioctl(DEVICE_OBJECT *device, IRP *irp)
 {
     IO_STACK_LOCATION *stack = IoGetCurrentIrpStackLocation( irp );
-    struct shared_resource **res = (struct shared_resource **) &stack->FileObject->FsContext;
+    struct shared_resource *res = &resource_pool[ (UINT_PTR) stack->FileObject->FsContext ];
     NTSTATUS status;
 
     TRACE( "ioctl %lx insize %lu outsize %lu\n",
@@ -327,37 +327,37 @@ static NTSTATUS WINAPI dispatch_ioctl(DEVICE_OBJECT *device, IRP *irp)
     switch (stack->Parameters.DeviceIoControl.IoControlCode)
     {
         case IOCTL_SHARED_GPU_RESOURCE_CREATE:
-            status = shared_resource_create( res,
+            status = shared_resource_create( &res,
                                       irp->AssociatedIrp.SystemBuffer,
                                       stack->Parameters.DeviceIoControl.InputBufferLength,
                                       &irp->IoStatus );
             break;
         case IOCTL_SHARED_GPU_RESOURCE_OPEN:
-            status = shared_resource_open( res,
+            status = shared_resource_open( &res,
                                       irp->AssociatedIrp.SystemBuffer,
                                       stack->Parameters.DeviceIoControl.InputBufferLength,
                                       &irp->IoStatus );
             break;
         case IOCTL_SHARED_GPU_RESOURCE_GETKMT:
-            status = shared_resource_getkmt( *res,
+            status = shared_resource_getkmt( res,
                                       irp->AssociatedIrp.SystemBuffer,
                                       stack->Parameters.DeviceIoControl.OutputBufferLength,
                                       &irp->IoStatus );
             break;
         case IOCTL_SHARED_GPU_RESOURCE_GET_UNIX_RESOURCE:
-            status = shared_resource_get_unix_resource( *res,
+            status = shared_resource_get_unix_resource( res,
                                       irp->AssociatedIrp.SystemBuffer,
                                       stack->Parameters.DeviceIoControl.OutputBufferLength,
                                       &irp->IoStatus );
             break;
         case IOCTL_SHARED_GPU_RESOURCE_SET_METADATA:
-            status = shared_resource_set_metadata( *res,
+            status = shared_resource_set_metadata( res,
                                       irp->AssociatedIrp.SystemBuffer,
                                       stack->Parameters.DeviceIoControl.InputBufferLength,
                                       &irp->IoStatus );
             break;
         case IOCTL_SHARED_GPU_RESOURCE_GET_METADATA:
-            status = shared_resource_get_metadata( *res,
+            status = shared_resource_get_metadata( res,
                                       irp->AssociatedIrp.SystemBuffer,
                                       stack->Parameters.DeviceIoControl.OutputBufferLength,
                                       &irp->IoStatus );
@@ -368,6 +368,9 @@ static NTSTATUS WINAPI dispatch_ioctl(DEVICE_OBJECT *device, IRP *irp)
         break;
     }
 
+    if (!status)
+        stack->FileObject->FsContext = (UINT_PTR)(res - resource_pool);
+
     irp->IoStatus.u.Status = status;
     IoCompleteRequest( irp, IO_NO_INCREMENT );
     return status;
-- 
2.37.1

From c2e10847a3a9921c9d611dc4118dcb8c0bee0d4e Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 13 Jul 2022 13:14:04 -0400
Subject: [PATCH 04/14] sharedgpures.sys: Add support for associating
 additional NT objects with shared resources.

This is then used to share a shared memory section for shared fences
---
 dlls/sharedgpures.sys/shared_resource.c | 91 +++++++++++++++++++++++++
 1 file changed, 91 insertions(+)

diff --git a/dlls/sharedgpures.sys/shared_resource.c b/dlls/sharedgpures.sys/shared_resource.c
index 0cd30c4a256..ce0e778166f 100644
--- a/dlls/sharedgpures.sys/shared_resource.c
+++ b/dlls/sharedgpures.sys/shared_resource.c
@@ -25,6 +25,8 @@ struct shared_resource
     WCHAR *name;
     void *metadata;
     SIZE_T metadata_size;
+    void **object_pool;
+    unsigned int object_pool_count;
 };
 
 static struct shared_resource *resource_pool;
@@ -275,6 +277,70 @@ static NTSTATUS shared_resource_get_metadata(struct shared_resource *res, void *
     return STATUS_SUCCESS;
 }
 
+#define IOCTL_SHARED_GPU_RESOURCE_SET_OBJECT           CTL_CODE(FILE_DEVICE_VIDEO, 6, METHOD_BUFFERED, FILE_WRITE_ACCESS)
+
+struct shared_resource_set_object
+{
+    unsigned int index;
+    obj_handle_t handle;
+};
+
+static NTSTATUS shared_resource_set_object(struct shared_resource *res, void *buff, SIZE_T insize, IO_STATUS_BLOCK *iosb)
+{
+    struct shared_resource_set_object *params = buff;
+    void *object;
+
+    if (insize < sizeof(*params))
+        return STATUS_INFO_LENGTH_MISMATCH;
+
+    if (!(object = reference_client_handle(params->handle)))
+        return STATUS_INVALID_HANDLE;
+
+    if (params->index >= res->object_pool_count)
+    {
+        void **expanded_pool = ExAllocatePoolWithTag(NonPagedPool, (params->index + 1) * sizeof(void *), 0);
+
+        if (res->object_pool)
+        {
+            memcpy(expanded_pool, res->object_pool, res->object_pool_count * sizeof(void *));
+            ExFreePoolWithTag(res->object_pool, 0);
+        }
+
+        memset(&expanded_pool[res->object_pool_count], 0, (params->index + 1 - res->object_pool_count) * sizeof (void *));
+
+        res->object_pool = expanded_pool;
+        res->object_pool_count = params->index + 1;
+    }
+
+    if (res->object_pool[params->index])
+        ObDereferenceObject(res->object_pool[params->index]);
+
+    res->object_pool[params->index] = object;
+
+    iosb->Information = 0;
+    return STATUS_SUCCESS;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_GET_OBJECT           CTL_CODE(FILE_DEVICE_VIDEO, 6, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+static NTSTATUS shared_resource_get_object(struct shared_resource *res, void *buff, SIZE_T insize, SIZE_T outsize, IO_STATUS_BLOCK *iosb)
+{
+    unsigned int index;
+
+    if (insize < sizeof(unsigned int) || outsize < sizeof(obj_handle_t))
+        return STATUS_INFO_LENGTH_MISMATCH;
+
+    index = *(unsigned int *)buff;
+
+    if (index >= res->object_pool_count || !res->object_pool[index])
+        return STATUS_INVALID_PARAMETER;
+
+    *((obj_handle_t *)buff) = open_client_handle(res->object_pool[index]);
+
+    iosb->Information = sizeof(obj_handle_t);
+    return STATUS_SUCCESS;
+}
+
 static NTSTATUS WINAPI dispatch_create(DEVICE_OBJECT *device, IRP *irp)
 {
     irp->IoStatus.u.Status = STATUS_SUCCESS;
@@ -305,6 +371,18 @@ static NTSTATUS WINAPI dispatch_close(DEVICE_OBJECT *device, IRP *irp)
                 ExFreePoolWithTag(res->metadata, 0);
                 res->metadata = NULL;
             }
+            if (res->object_pool)
+            {
+                unsigned int i;
+                for (i = 0; i < res->object_pool_count; i++)
+                {
+                    if (res->object_pool[i])
+                        ObDereferenceObject(res->object_pool[i]);
+                }
+                ExFreePoolWithTag(res->object_pool, 0);
+                res->object_pool = NULL;
+                res->object_pool_count = 0;
+            }
         }
     }
 
@@ -362,6 +440,19 @@ static NTSTATUS WINAPI dispatch_ioctl(DEVICE_OBJECT *device, IRP *irp)
                                       stack->Parameters.DeviceIoControl.OutputBufferLength,
                                       &irp->IoStatus );
             break;
+        case IOCTL_SHARED_GPU_RESOURCE_SET_OBJECT:
+            status = shared_resource_set_object( res,
+                                      irp->AssociatedIrp.SystemBuffer,
+                                      stack->Parameters.DeviceIoControl.InputBufferLength,
+                                      &irp->IoStatus );
+            break;
+        case IOCTL_SHARED_GPU_RESOURCE_GET_OBJECT:
+            status = shared_resource_get_object( res,
+                                      irp->AssociatedIrp.SystemBuffer,
+                                      stack->Parameters.DeviceIoControl.InputBufferLength,
+                                      stack->Parameters.DeviceIoControl.OutputBufferLength,
+                                      &irp->IoStatus);
+            break;
     default:
         FIXME( "ioctl %lx not supported\n", stack->Parameters.DeviceIoControl.IoControlCode );
         status = STATUS_NOT_SUPPORTED;
-- 
2.37.1

From 3e193e81d02fbe57d538eb05733baddbe57158b7 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Thu, 14 Jul 2022 15:44:46 -0400
Subject: [PATCH 05/14] winevulkan: NULL check optional parameters when
 accessing host object.

---
 dlls/winevulkan/make_vulkan | 12 +++++++++---
 1 file changed, 9 insertions(+), 3 deletions(-)

diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index b81a9a1faea..a9cf215031a 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -1514,7 +1514,7 @@ class VkMember(object):
 class VkParam(object):
     """ Helper class which describes a parameter to a function call. """
 
-    def __init__(self, type_info, const=None, pointer=None, name=None, array_len=None, dyn_array_len=None, object_type=None):
+    def __init__(self, type_info, const=None, pointer=None, name=None, array_len=None, dyn_array_len=None, object_type=None, optional=False):
         self.const = const
         self.name = name
         self.array_len = array_len
@@ -1522,6 +1522,7 @@ class VkParam(object):
         self.pointer = pointer
         self.object_type = object_type
         self.type_info = type_info
+        self.optional = optional
         self.type = type_info["name"] # For convenience
         self.handle = type_info["data"] if type_info["category"] == "handle" else None
         self.struct = type_info["data"] if type_info["category"] == "struct" else None
@@ -1561,12 +1562,14 @@ class VkParam(object):
         # Some uint64_t are actually handles with a separate type param
         object_type = param.get("objecttype", None)
 
+        optional = param.get("optional", False)
+
         # Since we have parsed all types before hand, this should not happen.
         type_info = types.get(type_elem.text, None)
         if type_info is None:
             LOGGER.err("type info not found for: {0}".format(type_elem.text))
 
-        return VkParam(type_info, const=const, pointer=pointer, name=name, array_len=array_len, dyn_array_len=dyn_array_len, object_type=object_type)
+        return VkParam(type_info, const=const, pointer=pointer, name=name, array_len=array_len, dyn_array_len=dyn_array_len, object_type=object_type, optional=optional)
 
     def _set_conversions(self):
         """ Internal helper function to configure any needed conversion functions. """
@@ -1903,7 +1906,10 @@ class VkParam(object):
             # the wine driver's handle to calls which are wrapped by the driver.
             p = "{0}{1}".format(params_prefix, self.name)
             driver_handle = self.handle.driver_handle(p) if self.is_handle() else None
-            return driver_handle if driver_handle else p
+            if driver_handle and self.optional:
+                return "{0} ? {1} : VK_NULL_HANDLE".format(p, driver_handle)
+            else:
+                return driver_handle if driver_handle else p
 
 
 class VkStruct(Sequence):
-- 
2.37.1

From ef1dedf4c9e1b8f415593a6bcf669f7f7d0ed168 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Fri, 15 Jul 2022 15:12:52 -0400
Subject: [PATCH 11/14] winegstreamer: Add MF_MT_VIDEO_NOMINAL_RANGE attribute
 to base video output type.

---
 dlls/winegstreamer/media_source.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/winegstreamer/media_source.c b/dlls/winegstreamer/media_source.c
index eab85c29bed..63e61e84f44 100644
--- a/dlls/winegstreamer/media_source.c
+++ b/dlls/winegstreamer/media_source.c
@@ -882,6 +882,8 @@ static HRESULT media_stream_init_desc(struct media_stream *stream)
         IMFMediaType *base_type = mf_media_type_from_wg_format(&format);
         GUID base_subtype;
 
+        IMFMediaType_SetUINT32(base_type, &MF_MT_VIDEO_NOMINAL_RANGE, MFNominalRange_Normal);
+
         IMFMediaType_GetGUID(base_type, &MF_MT_SUBTYPE, &base_subtype);
 
         stream_types[0] = base_type;
-- 
2.37.1

From 65e8ff36eff59d827c4beedaf75a3f0418f05e16 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Fri, 22 Apr 2022 11:53:02 -0400
Subject: [PATCH 01/14] winevulkan: Implement VK_KHR_external_semaphore_win32
 for OPAQUE_WIN32 handleType.

---
 dlls/winevulkan/make_vulkan |  14 ++-
 dlls/winevulkan/vulkan.c    | 188 ++++++++++++++++++++++++++++++++++--
 2 files changed, 191 insertions(+), 11 deletions(-)

diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index 89b2e7ee1e2..b81a9a1faea 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -98,7 +98,6 @@ UNSUPPORTED_EXTENSIONS = [
     "VK_EXT_hdr_metadata", # Needs WSI work.
     "VK_GOOGLE_display_timing",
     "VK_KHR_external_fence_win32",
-    "VK_KHR_external_semaphore_win32",
     # Relates to external_semaphore and needs type conversions in bitflags.
     "VK_KHR_shared_presentable_image", # Needs WSI work.
     "VK_KHR_win32_keyed_mutex",
@@ -111,7 +110,6 @@ UNSUPPORTED_EXTENSIONS = [
     "VK_EXT_physical_device_drm",
     "VK_GOOGLE_surfaceless_query",
     "VK_KHR_external_fence_fd",
-    "VK_KHR_external_semaphore_fd",
     "VK_SEC_amigo_profiling", # Angle specific.

     # Extensions which require callback handling
@@ -126,6 +124,7 @@ UNSUPPORTED_EXTENSIONS = [
 # but not expose to applications (useful for test commits)
 UNEXPOSED_EXTENSIONS = {
     "VK_KHR_external_memory_fd",
+    "VK_KHR_external_semaphore_fd",
 }
 
 # The Vulkan loader provides entry-points for core functionality and important
@@ -192,7 +191,7 @@ FUNCTION_OVERRIDES = {
     "vkEnumeratePhysicalDevices" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkGetPhysicalDeviceExternalBufferProperties" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkGetPhysicalDeviceExternalFenceProperties" : {"dispatch" : False, "driver" : False, "thunk" : ThunkType.NONE},
-    "vkGetPhysicalDeviceExternalSemaphoreProperties" : {"dispatch" : False, "driver" : False, "thunk" : ThunkType.NONE},
+    "vkGetPhysicalDeviceExternalSemaphoreProperties" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkGetPhysicalDeviceImageFormatProperties2" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.PRIVATE},
     "vkGetPhysicalDeviceProperties2" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.PUBLIC, "loader_thunk" : ThunkType.PRIVATE},
     "vkGetPhysicalDeviceProperties2KHR" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.PUBLIC, "loader_thunk" : ThunkType.PRIVATE},
@@ -205,6 +204,7 @@ FUNCTION_OVERRIDES = {
     "vkCreateComputePipelines" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.PRIVATE},
     "vkCreateGraphicsPipelines" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.PRIVATE},
     "vkCreateImage" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
+    "vkCreateSemaphore" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkDestroyCommandPool" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkDestroyDevice" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkFreeCommandBuffers" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
@@ -244,7 +244,7 @@ FUNCTION_OVERRIDES = {
     "vkGetPhysicalDeviceImageFormatProperties2KHR" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.PRIVATE},
 
     # VK_KHR_external_semaphore_capabilities
-    "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR" : {"dispatch" : False, "driver" : False, "thunk" : ThunkType.NONE},
+    "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
 
     # VK_KHR_device_group_creation
     "vkEnumeratePhysicalDeviceGroupsKHR" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
@@ -274,6 +274,10 @@ FUNCTION_OVERRIDES = {
     # VK_KHR_external_memory_win32
     "vkGetMemoryWin32HandleKHR" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkGetMemoryWin32HandlePropertiesKHR" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
+
+    # VK_KHR_external_semaphore_win32
+    "vkGetSemaphoreWin32HandleKHR" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
+    "vkImportSemaphoreWin32HandleKHR" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
 }
 
 STRUCT_CHAIN_CONVERSIONS = {
@@ -286,6 +290,7 @@ STRUCT_CHAIN_CONVERSIONS = {
     "VkImageCreateInfo": [],
     "VkMemoryAllocateInfo": ["VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR", "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR"],
     "VkPhysicalDeviceImageFormatInfo2": [],
+    "VkSemaphoreCreateInfo": ["VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"],
 }
 
 
diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index ce2c464c462..70ab0dddf0f 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -285,6 +285,15 @@ static struct VkPhysicalDevice_T *wine_vk_physical_device_alloc(struct VkInstanc
             host_properties[i].specVersion = VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION;
         }
 
+        if (!strcmp(host_properties[i].extensionName, "VK_KHR_external_semaphore_fd"))
+        {
+            TRACE("Substituting VK_KHR_external_semaphore_fd for VK_KHR_external_semaphore_win32\n");
+
+            snprintf(host_properties[i].extensionName, sizeof(host_properties[i].extensionName),
+                    VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME);
+            host_properties[i].specVersion = VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION;
+        }
+
         if (wine_vk_device_extension_supported(host_properties[i].extensionName))
         {
             TRACE("Enabling extension '%s' for physical device %p\n", host_properties[i].extensionName, object);
@@ -408,7 +417,7 @@ static VkResult wine_vk_device_convert_create_info(const VkDeviceCreateInfo *src
 
     for (i = 0; i < src->enabledExtensionCount; i++)
     {
-        if (!strcmp(src->ppEnabledExtensionNames[i], "VK_KHR_external_memory_win32"))
+        if (!strcmp(src->ppEnabledExtensionNames[i], "VK_KHR_external_memory_win32") || !strcmp(src->ppEnabledExtensionNames[i], "VK_KHR_external_semaphore_win32"))
         {
             replace_win32 = 1;
             break;
@@ -426,6 +435,8 @@ static VkResult wine_vk_device_convert_create_info(const VkDeviceCreateInfo *src
         {
             if (replace_win32 && !strcmp(src->ppEnabledExtensionNames[i], "VK_KHR_external_memory_win32"))
                 new_extensions_list[o] = strdup("VK_KHR_external_memory_fd");
+            else if (replace_win32 && !strcmp(src->ppEnabledExtensionNames[i], "VK_KHR_external_semaphore_win32"))
+                new_extensions_list[o] = strdup("VK_KHR_external_semaphore_fd");
             else
                 new_extensions_list[o] = strdup(dst->ppEnabledExtensionNames[i]);
             ++o;
@@ -1627,6 +1638,51 @@ NTSTATUS wine_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(void *args)
     return res;
 }
 
+static inline void wine_vk_normalize_semaphore_handle_types_win(VkExternalSemaphoreHandleTypeFlags *types)
+{
+    *types &=
+        VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT |
+        VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT |
+        VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT;
+}
+
+static inline void wine_vk_normalize_semaphore_handle_types_host(VkExternalSemaphoreHandleTypeFlags *types)
+{
+    *types &=
+        VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT |
+        VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT;
+}
+
+static void wine_vk_get_physical_device_external_semaphore_properties(VkPhysicalDevice phys_dev,
+    void (*p_vkGetPhysicalDeviceExternalSemaphoreProperties)(VkPhysicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *, VkExternalSemaphoreProperties *),
+    const VkPhysicalDeviceExternalSemaphoreInfo *semaphore_info, VkExternalSemaphoreProperties *properties)
+{
+    VkPhysicalDeviceExternalSemaphoreInfo semaphore_info_dup = *semaphore_info;
+
+    wine_vk_normalize_semaphore_handle_types_win(&semaphore_info_dup.handleType);
+    if (semaphore_info_dup.handleType == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT)
+        semaphore_info_dup.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+    wine_vk_normalize_semaphore_handle_types_host(&semaphore_info_dup.handleType);
+
+    if (semaphore_info->handleType && !semaphore_info_dup.handleType)
+    {
+        properties->exportFromImportedHandleTypes = 0;
+        properties->compatibleHandleTypes = 0;
+        properties->externalSemaphoreFeatures = 0;
+        return;
+    }
+
+    p_vkGetPhysicalDeviceExternalSemaphoreProperties(phys_dev->phys_dev, &semaphore_info_dup, properties);
+
+    if (properties->exportFromImportedHandleTypes & VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT)
+        properties->exportFromImportedHandleTypes |= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+    wine_vk_normalize_semaphore_handle_types_win(&properties->exportFromImportedHandleTypes);
+
+    if (properties->compatibleHandleTypes & VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT)
+        properties->compatibleHandleTypes |= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+    wine_vk_normalize_semaphore_handle_types_win(&properties->compatibleHandleTypes);
+}
+
 NTSTATUS wine_vkGetPhysicalDeviceExternalSemaphoreProperties(void *args)
 {
     struct vkGetPhysicalDeviceExternalSemaphoreProperties_params *params = args;
@@ -1635,9 +1691,8 @@ NTSTATUS wine_vkGetPhysicalDeviceExternalSemaphoreProperties(void *args)
     VkExternalSemaphoreProperties *properties = params->pExternalSemaphoreProperties;
 
     TRACE("%p, %p, %p\n", phys_dev, semaphore_info, properties);
-    properties->exportFromImportedHandleTypes = 0;
-    properties->compatibleHandleTypes = 0;
-    properties->externalSemaphoreFeatures = 0;
+    wine_vk_get_physical_device_external_semaphore_properties(phys_dev, phys_dev->instance->funcs.p_vkGetPhysicalDeviceExternalSemaphoreProperties, semaphore_info, properties);
+
     return STATUS_SUCCESS;
 }
 
@@ -1649,9 +1704,8 @@ NTSTATUS wine_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(void *args)
     VkExternalSemaphoreProperties *properties = params->pExternalSemaphoreProperties;
 
     TRACE("%p, %p, %p\n", phys_dev, semaphore_info, properties);
-    properties->exportFromImportedHandleTypes = 0;
-    properties->compatibleHandleTypes = 0;
-    properties->externalSemaphoreFeatures = 0;
+    wine_vk_get_physical_device_external_semaphore_properties(phys_dev, phys_dev->instance->funcs.p_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR, semaphore_info, properties);
+
     return STATUS_SUCCESS;
 }
 
@@ -2008,6 +2062,10 @@ BOOL WINAPI wine_vk_is_available_device_function(VkDevice device, const char *na
 {
     if (!strcmp(name, "vkGetMemoryWin32HandleKHR") || !strcmp(name, "vkGetMemoryWin32HandlePropertiesKHR"))
         name = "vkGetMemoryFdKHR";
+    if (!strcmp(name, "vkGetSemaphoreWin32HandleKHR"))
+        name = "vkGetSemaphoreFdKHR";
+    if (!strcmp(name, "vkImportSemaphoreWin32HandleKHR"))
+        name = "vkImportSemaphoreFdKHR";
     return !!vk_funcs->p_vkGetDeviceProcAddr(device->device, name);
 }
 
@@ -2480,3 +2538,119 @@ NTSTATUS wine_vkCreateImage(void *args)
 
     return res;
 }
+
+NTSTATUS wine_vkCreateSemaphore(void *args)
+{
+    struct vkCreateSemaphore_params *params = args;
+    VkDevice device = params->device;
+    const VkSemaphoreCreateInfo *create_info = params->pCreateInfo;
+    const VkAllocationCallbacks *allocator = params->pAllocator;
+    VkSemaphore *semaphore = params->pSemaphore;
+
+    VkSemaphoreCreateInfo create_info_host = *create_info;
+    VkExportSemaphoreCreateInfo *export_semaphore_info;
+    VkResult res;
+
+    TRACE("%p %p %p %p", device, create_info, allocator, semaphore);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    if ((res = convert_VkSemaphoreCreateInfo_struct_chain(create_info->pNext, &create_info_host)))
+    {
+        WARN("Failed to convert VkSemaphoreCreateInfo pNext chain, res=%d.\n", res);
+        return res;
+    }
+
+    if ((export_semaphore_info = wine_vk_find_struct(&create_info_host, EXPORT_SEMAPHORE_CREATE_INFO)))
+    {
+        if (export_semaphore_info->handleTypes & VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT)
+            export_semaphore_info->handleTypes |= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+        wine_vk_normalize_semaphore_handle_types_host(&export_semaphore_info->handleTypes);
+    }
+
+    if (wine_vk_find_struct(&create_info_host,  EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR))
+        FIXME("VkExportSemaphoreWin32HandleInfoKHR unhandled.\n");
+
+    res = device->funcs.p_vkCreateSemaphore(device->device, &create_info_host, NULL, semaphore);
+
+    free_VkSemaphoreCreateInfo_struct_chain(&create_info_host);
+
+    return res;
+}
+
+NTSTATUS wine_vkGetSemaphoreWin32HandleKHR(void *args)
+{
+    struct vkGetSemaphoreWin32HandleKHR_params *params = args;
+    VkDevice device = params->device;
+    const VkSemaphoreGetWin32HandleInfoKHR *handle_info = params->pGetWin32HandleInfo;
+    HANDLE *handle = params->pHandle;
+
+    VkSemaphoreGetFdInfoKHR_host fd_info;
+    VkResult res;
+    int fd;
+
+    fd_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR;
+    fd_info.pNext = handle_info->pNext;
+    fd_info.semaphore = handle_info->semaphore;
+    fd_info.handleType = handle_info->handleType;
+    if (fd_info.handleType == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT)
+        fd_info.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+    wine_vk_normalize_semaphore_handle_types_host(&fd_info.handleType);
+
+    res = device->funcs.p_vkGetSemaphoreFdKHR(device->device, &fd_info, &fd);
+
+    if (res != VK_SUCCESS)
+        return res;
+
+    if (wine_server_fd_to_handle(fd, GENERIC_ALL, 0, handle) != STATUS_SUCCESS)
+    {
+        close(fd);
+        return VK_ERROR_OUT_OF_HOST_MEMORY;
+    }
+
+    return VK_SUCCESS;
+}
+
+NTSTATUS wine_vkImportSemaphoreWin32HandleKHR(void *args)
+{
+    struct vkImportSemaphoreWin32HandleKHR_params *params = args;
+    VkDevice device = params->device;
+    const VkImportSemaphoreWin32HandleInfoKHR *handle_info = params->pImportSemaphoreWin32HandleInfo;
+
+    VkImportSemaphoreFdInfoKHR_host fd_info;
+    VkResult res;
+    int fd;
+
+    fd_info.sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR;
+    fd_info.pNext = handle_info->pNext;
+    fd_info.semaphore = handle_info->semaphore;
+    fd_info.flags = handle_info->flags;
+    fd_info.handleType = handle_info->handleType;
+
+    if (fd_info.handleType == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT)
+    {
+        if (handle_info->name)
+        {
+            FIXME("Importing win32 semaphore by name not supported.\n");
+            return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+        }
+
+        fd_info.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+        if (wine_server_handle_to_fd(handle_info->handle, GENERIC_ALL, &fd, NULL) != STATUS_SUCCESS)
+            return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+    }
+    wine_vk_normalize_semaphore_handle_types_host(&fd_info.handleType);
+
+    if (!fd_info.handleType)
+    {
+        FIXME("Importing win32 semaphore with handle type %#x not supported.\n", handle_info->handleType);
+        return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+    }
+
+    /* importing FDs transfers ownership, importing NT handles does not  */
+    if ((res = device->funcs.p_vkImportSemaphoreFdKHR(device->device, &fd_info)) != VK_SUCCESS)
+        close(fd);
+
+    return res;
+}
-- 
2.37.1

From 9584889b6d5099efaa77344e688f2f8352eb1b3b Mon Sep 17 00:00:00 2001
From: Dmitry Skvortsov <lvb.crd@protonmail.com>
Date: Thu, 11 Aug 2022 21:59:59 +0300
Subject: [PATCH] megacommit (fshack)

dd5f79790d01f4dbddcaa7970cbc2af10fa8c193 Derek Lesho winevulkan: Add initial support for D3D12-Fence compatible timeline semaphores.
e8992e62caafe2ca81f587050c077ada5a65ef85 Derek Lesho winevulkan: Implement vkWaitForFences and vkSignalSemaphore for D3D12-Fence compatible timeline semaphores.
e2bbca036deb6f86a8cdf8a1c9e24656bceb2a8b Derek Lesho winevulkan: Copy VkSubmitInfo structs so that they don't contain pointers to the source object.
86d9e6efd9a9cab8bd551fa1652af845ba38bee7 Derek Lesho winevulkan: Support waiting for and signalling D3D12-Fence style timeline semaphores in Vulkan Queues.
d27f6727eb2dba67e0a9e176a32db88f21ec0b82 Derek Lesho winevulkan: Add support for signalling VkFence from virtualized VkQueues.
6d5ad56d49af8a355476dc37b89681b9a2b7b44b Derek Lesho winevulkan: Flush virtual queue before providing native handle.
22118a4146aa2ccbb6829c4c9ea8c9b4d521f9e0 Derek Lesho winevulkan: Allowing importing D3D11 Texture handles as Vulkan memory objects.
c68248d2dd50bd11ed8deab7c483d9ddd6a06377 Derek Lesho winevulkan: Expose VK_EXT_memory_priority and VK_KHR_win32_keyed_mutex for Crysis: Remastered.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winevulkan/make_vulkan      |   51 +-
 dlls/winevulkan/vulkan.c         | 2238 ++++++++++++++++++++++++++++--
 dlls/winevulkan/vulkan_loader.h  |    2 +
 dlls/winevulkan/vulkan_private.h |  108 ++
 4 files changed, 2268 insertions(+), 131 deletions(-)

diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index cff1ab3f24f..12f0f1150d6 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -100,7 +100,6 @@ UNSUPPORTED_EXTENSIONS = [
     "VK_KHR_external_fence_win32",
     # Relates to external_semaphore and needs type conversions in bitflags.
     "VK_KHR_shared_presentable_image", # Needs WSI work.
-    "VK_KHR_win32_keyed_mutex",
     "VK_NV_external_memory_rdma", # Needs shared resources work.
 
     # Extensions for other platforms
@@ -215,6 +214,7 @@ FUNCTION_OVERRIDES = {
     "vkCreateBuffer" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkCreateCommandPool" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkCreateComputePipelines" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.PRIVATE},
+    "vkCreateFence" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkCreateGraphicsPipelines" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.PRIVATE},
     "vkCreateImage" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkCreateComputePipelines" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.PRIVATE},
@@ -222,11 +222,22 @@ FUNCTION_OVERRIDES = {
     "vkCreateSemaphore" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkDestroyCommandPool" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkDestroyDevice" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
+    "vkDestroyFence" : {"dispatch" : True, "driver" : False, "thunk": ThunkType.NONE},
+    "vkDestroySemaphore" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkFreeCommandBuffers" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkFreeMemory" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkGetDeviceProcAddr" : {"dispatch" : False, "driver" : True, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.NONE},
     "vkGetDeviceQueue" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkGetDeviceQueue2" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.NONE},
+    "vkGetSemaphoreCounterValue" : {"dispatch": True, "driver": False, "thunk" : ThunkType.PRIVATE},
+    "vkResetFences" : {"dispatch" : True, "driver": False, "thunk" : ThunkType.PRIVATE},
+    "vkSignalSemaphore" : {"dispatch": True, "driver": False, "thunk" : ThunkType.PRIVATE},
+    "vkWaitForFences" : {"dispatch": True, "driver": False, "thunk": ThunkType.PRIVATE},
+    "vkWaitSemaphores" : {"dispatch": True, "driver": False, "thunk" : ThunkType.PRIVATE},
+    "vkQueueBindSparse" : {"dispatch": True, "driver": False, "thunk" : ThunkType.PRIVATE},
+    "vkQueueSubmit" : {"dispatch": True, "driver": False, "thunk" : ThunkType.PRIVATE},
+    "vkQueueSubmit2" : {"dispatch": True, "driver": False, "thunk" : ThunkType.PRIVATE},
+    "vkQueueWaitIdle" : {"dispatch": True, "driver": False, "thunk" : ThunkType.NONE},
 
     # VK_KHR_surface
     "vkDestroySurfaceKHR" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.NONE},
@@ -249,7 +260,7 @@ FUNCTION_OVERRIDES = {
     "vkCreateSwapchainKHR" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.NONE},
     "vkDestroySwapchainKHR" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.NONE},
     "vkGetSwapchainImagesKHR": {"dispatch" : True, "driver" : True, "thunk" : ThunkType.NONE},
-    "vkQueuePresentKHR": {"dispatch" : True, "driver" : True, "thunk" : ThunkType.NONE},
+    "vkQueuePresentKHR": {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PRIVATE},
 
     # VK_KHR_external_fence_capabilities
     "vkGetPhysicalDeviceExternalFencePropertiesKHR" : {"dispatch" : False, "driver" : False, "thunk" : ThunkType.NONE},
@@ -296,6 +307,14 @@ FUNCTION_OVERRIDES = {
     # VK_KHR_external_semaphore_win32
     "vkGetSemaphoreWin32HandleKHR" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkImportSemaphoreWin32HandleKHR" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
+
+    # VK_KHR_timeline_semaphore
+    "vkGetSemaphoreCounterValueKHR" : {"dispatch": True, "driver": False, "thunk" : ThunkType.PRIVATE},
+    "vkSignalSemaphoreKHR" : {"dispatch": True, "driver": False, "thunk" : ThunkType.PRIVATE},
+    "vkWaitSemaphoresKHR" : {"dispatch": True, "driver": False, "thunk" : ThunkType.PRIVATE},
+
+    # VK_KHR_synchronization2
+    "vkQueueSubmit2KHR" : {"dispatch": True, "driver": False, "thunk" : ThunkType.PRIVATE},
 }
 
 STRUCT_CHAIN_CONVERSIONS = {
@@ -308,7 +327,10 @@ STRUCT_CHAIN_CONVERSIONS = {
     "VkImageCreateInfo": [],
     "VkMemoryAllocateInfo": ["VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR", "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR"],
     "VkPhysicalDeviceImageFormatInfo2": [],
+    "VkPhysicalDeviceExternalSemaphoreInfo": [],
     "VkSemaphoreCreateInfo": ["VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"],
+    "VkSubmitInfo": ["VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR", "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR"],
+    "VkSubmitInfo2" : ["VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR"],
 }
 
 
@@ -1136,6 +1158,10 @@ class VkHandle(object):
             return "wine_surface_from_handle({0})->surface".format(name)
         if self.name == "VkDeviceMemory":
             return "wine_dev_mem_from_handle({0})->dev_mem".format(name)
+        if self.name == "VkSemaphore":
+            return "wine_semaphore_host_handle( wine_semaphore_from_handle({0}) )".format(name)
+        if self.name == "VkFence":
+            return "wine_fence_from_handle({0})->fence".format(name)
 
         native_handle_name = None
 
@@ -1270,9 +1296,10 @@ class VkMember(object):
         return VkMember(const=const, struct_fwd_decl=struct_fwd_decl, _type=member_type, pointer=pointer, name=name_elem.text,
                 array_len=array_len, dyn_array_len=dyn_array_len, optional=optional, values=values, object_type=object_type, bit_width=bit_width)
 
-    def copy(self, input, output, direction, conv):
+    def copy(self, input, output, direction, conv, deep_copy=False):
         """ Helper method for use by conversion logic to generate a C-code statement to copy this member.
-            - `conv` indicates whether the statement is in a struct alignment conversion path. """
+            - `conv` indicates whether the statement is in a struct alignment conversion path.
+            - `deep_copy` indicates whether a pointers members need to have their data copied. """
 
         if (conv and self.needs_conversion()) or self.needs_unwrapping():
             if self.is_dynamic_array():
@@ -1310,6 +1337,9 @@ class VkMember(object):
         elif self.is_static_array():
             bytes_count = "{0} * sizeof({1})".format(self.array_len, self.type)
             return "memcpy({0}{1}, {2}{1}, {3});\n".format(output, self.name, input, bytes_count)
+        elif deep_copy and self.is_dynamic_array():
+            count = self.dyn_array_len if isinstance(self.dyn_array_len, int) else "{0}{1}".format(input, self.dyn_array_len)
+            return "{0}{1} = memdup({2}{1}, {3}, sizeof({0}{1}[0]));\n".format(output, self.name, input, count)
         else:
             return "{0}{1} = {2}{1};\n".format(output, self.name, input)
 
@@ -1788,9 +1818,6 @@ class VkParam(object):
         # 'parent' param requiring conversion.
         if self.is_struct():
             for m in self.struct:
-                if not m.is_struct():
-                    continue
-
                 if not m.needs_conversion() and not m.needs_unwrapping():
                     continue
 
@@ -2562,10 +2589,11 @@ class FreeFunction(object):
 
 
 class StructChainConversionFunction(object):
-    def __init__(self, direction, struct, ignores):
+    def __init__(self, direction, struct, ignores, deep_copy):
         self.direction = direction
         self.struct = struct
         self.ignores = ignores
+        self.deep_copy = deep_copy
         self.type = struct.name
 
         self.name = "convert_{0}_struct_chain".format(self.type)
@@ -2615,8 +2643,8 @@ class StructChainConversionFunction(object):
                 if m.name == "pNext":
                     body += "            out->pNext = NULL;\n"
                 else:
-                    convert = m.copy("in->", "out->", self.direction, conv=True)
-                    unwrap = m.copy("in->", "out->", self.direction, conv=False)
+                    convert = m.copy("in->", "out->", self.direction, conv=True, deep_copy=self.deep_copy)
+                    unwrap = m.copy("in->", "out->", self.direction, conv=False, deep_copy=self.deep_copy)
                     if unwrap == convert:
                         body += "            " + unwrap
                     else:
@@ -2752,7 +2780,8 @@ class VkGenerator(object):
 
         for struct in self.registry.structs:
             if struct.name in STRUCT_CHAIN_CONVERSIONS:
-                self.struct_chain_conversions.append(StructChainConversionFunction(Direction.INPUT, struct, STRUCT_CHAIN_CONVERSIONS[struct.name]))
+                self.struct_chain_conversions.append(StructChainConversionFunction(Direction.INPUT, struct, STRUCT_CHAIN_CONVERSIONS[struct.name],
+                                                                                   struct.name == "VkSubmitInfo" or struct.name == "VkSubmitInfo2"))
                 self.struct_chain_conversions.append(FreeStructChainFunction(struct))
                 # Once we decide to support pNext chains conversion everywhere, move this under get_conversions
                 for e in struct.struct_extensions:
diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index e065c0bc253..1024bf04037 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -26,6 +26,12 @@
 #include <time.h>
 #include <stdlib.h>
 #include <unistd.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <assert.h>
+#include <errno.h>
+#include <poll.h>
+#include <sys/eventfd.h>
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -33,6 +39,7 @@
 #include "winnt.h"
 #include "winioctl.h"
 #include "wine/server.h"
+#include "wine/list.h"
 
 #include "vulkan_private.h"
 #include "winreg.h"
@@ -237,8 +244,14 @@ static struct VkPhysicalDevice_T *wine_vk_physical_device_alloc(struct VkInstanc
     struct VkPhysicalDevice_T *object;
     uint32_t num_host_properties, num_properties = 0;
     VkExtensionProperties *host_properties = NULL;
+#if defined(USE_STRUCT_CONVERSION)
+    VkPhysicalDeviceProperties_host physdev_properties;
+#else
+    VkPhysicalDeviceProperties physdev_properties;
+#endif
     VkResult res;
     unsigned int i, j;
+    bool has_memory_priority = false;
 
     if (!(object = calloc(1, sizeof(*object))))
         return NULL;
@@ -247,6 +260,9 @@ static struct VkPhysicalDevice_T *wine_vk_physical_device_alloc(struct VkInstanc
     object->instance = instance;
     object->phys_dev = phys_dev;
 
+    instance->funcs.p_vkGetPhysicalDeviceProperties(phys_dev, &physdev_properties);
+    object->api_version = physdev_properties.apiVersion;
+
     WINE_VK_ADD_DISPATCHABLE_MAPPING(instance, object, phys_dev);
 
     res = instance->funcs.p_vkEnumerateDeviceExtensionProperties(phys_dev,
@@ -293,6 +309,10 @@ static struct VkPhysicalDevice_T *wine_vk_physical_device_alloc(struct VkInstanc
                     VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME);
             host_properties[i].specVersion = VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION;
         }
+        if (!strcmp(host_properties[i].extensionName, "VK_EXT_memory_priority"))
+        {
+            has_memory_priority = true;
+        }
 
         if (wine_vk_device_extension_supported(host_properties[i].extensionName))
         {
@@ -305,6 +325,12 @@ static struct VkPhysicalDevice_T *wine_vk_physical_device_alloc(struct VkInstanc
         }
     }
 
+    if (instance->quirks & WINEVULKAN_QUIRK_EXPOSE_KEYED_MUTEX)
+        num_properties++;
+
+    if (!has_memory_priority && (instance->quirks & WINEVULKAN_QUIRK_EXPOSE_MEM_PRIORITY))
+        num_properties++;
+
     TRACE("Host supported extensions %u, Wine supported extensions %u\n", num_host_properties, num_properties);
 
     if (!(object->extensions = calloc(num_properties, sizeof(*object->extensions))))
@@ -321,6 +347,27 @@ static struct VkPhysicalDevice_T *wine_vk_physical_device_alloc(struct VkInstanc
             j++;
         }
     }
+
+    if (instance->quirks & WINEVULKAN_QUIRK_EXPOSE_KEYED_MUTEX)
+    {
+        TRACE("Faking VK_KHR_win32_keyed_mutex extension.\n");
+        snprintf(object->extensions[j].extensionName, sizeof(object->extensions[j].extensionName),
+                VK_KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME);
+        object->extensions[j].specVersion = VK_KHR_WIN32_KEYED_MUTEX_SPEC_VERSION;
+        j++;
+    }
+
+    if (!has_memory_priority && (instance->quirks & WINEVULKAN_QUIRK_EXPOSE_MEM_PRIORITY))
+    {
+        TRACE("Faking VK_EXT_memory_priority extension.\n");
+        snprintf(object->extensions[j].extensionName, sizeof(object->extensions[j].extensionName),
+                VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME);
+        object->extensions[j].specVersion = VK_EXT_MEMORY_PRIORITY_SPEC_VERSION;
+        j++;
+
+        object->fake_memory_priority = true;
+    }
+
     object->extension_count = num_properties;
 
     free(host_properties);
@@ -366,6 +413,14 @@ static void wine_vk_device_get_queues(struct VkDevice_T *device,
         queue->queue_index = i;
         queue->flags = flags;
 
+        pthread_mutex_init(&queue->submissions_mutex, NULL);
+        pthread_cond_init(&queue->submissions_cond, NULL);
+        list_init(&queue->submissions);
+
+        pthread_mutex_init(&queue->signaller_mutex, NULL);
+        pthread_cond_init(&queue->signaller_cond, NULL);
+        list_init(&queue->signal_ops);
+
         /* The Vulkan spec says:
          *
          * "vkGetDeviceQueue must only be used to get queues that were created
@@ -397,10 +452,10 @@ static void wine_vk_device_free_create_info(VkDeviceCreateInfo *create_info)
         free((void *)create_info->ppEnabledExtensionNames);
 }
 
-static VkResult wine_vk_device_convert_create_info(const VkDeviceCreateInfo *src,
+static VkResult wine_vk_device_convert_create_info(VkPhysicalDevice phys_dev, const VkDeviceCreateInfo *src,
         VkDeviceCreateInfo *dst)
 {
-    unsigned int i, replace_win32 = 0;
+    unsigned int i, replace_win32 = 0, timeline_enabled = 0, drop_extension = 0, wine_extension_count;
     VkResult res;
 
     *dst = *src;
@@ -411,32 +466,74 @@ static VkResult wine_vk_device_convert_create_info(const VkDeviceCreateInfo *src
         return res;
     }
 
+    if (phys_dev->fake_memory_priority)
+    {
+        VkBaseOutStructure *header;
+
+        for (header = (void *) dst; header; header = header->pNext)
+        {
+            if (header->pNext && header->pNext->sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT)
+            {
+                VkBaseOutStructure *memory_priority = header->pNext;
+
+                header->pNext = memory_priority->pNext;
+                free(memory_priority);
+                break;
+            }
+        }
+    }
+
     /* Should be filtered out by loader as ICDs don't support layers. */
     dst->enabledLayerCount = 0;
     dst->ppEnabledLayerNames = NULL;
 
-    for (i = 0; i < src->enabledExtensionCount; i++)
+    for (i = 0; i < dst->enabledExtensionCount; i++)
     {
-        if (!strcmp(src->ppEnabledExtensionNames[i], "VK_KHR_external_memory_win32") || !strcmp(src->ppEnabledExtensionNames[i], "VK_KHR_external_semaphore_win32"))
-        {
+        const char *extension_name = dst->ppEnabledExtensionNames[i];
+        if (!strcmp(extension_name, "VK_KHR_external_memory_win32") || !strcmp(extension_name, "VK_KHR_external_semaphore_win32"))
             replace_win32 = 1;
-            break;
-        }
+        else if (!strcmp(extension_name, "VK_KHR_win32_keyed_mutex") || (phys_dev->fake_memory_priority && !strcmp(extension_name, "VK_EXT_memory_priority")))
+            drop_extension = 1;
+        else if (!strcmp(extension_name, "VK_KHR_timeline_semaphore"))
+            timeline_enabled = 1;
     }
 
-    if (replace_win32)
+    if (replace_win32 || drop_extension)
     {
-        unsigned int o = 0;
+        unsigned int o = 0, j;
         char **new_extensions_list;
- 
-        new_extensions_list = malloc(sizeof(char *) * (dst->enabledExtensionCount));
+
+        new_extensions_list = malloc(sizeof(char *) * (dst->enabledExtensionCount + replace_win32));
 
         for (i = 0; i < dst->enabledExtensionCount; i++)
         {
+            if (drop_extension && (!strcmp(src->ppEnabledExtensionNames[i], "VK_KHR_win32_keyed_mutex") ||
+                (phys_dev->fake_memory_priority && !strcmp(src->ppEnabledExtensionNames[i], "VK_EXT_memory_priority"))))
+            {
+                TRACE("Ignoring active extension %s.\n", src->ppEnabledExtensionNames[i]);
+                continue;
+            }
+
             if (replace_win32 && !strcmp(src->ppEnabledExtensionNames[i], "VK_KHR_external_memory_win32"))
                 new_extensions_list[o] = strdup("VK_KHR_external_memory_fd");
             else if (replace_win32 && !strcmp(src->ppEnabledExtensionNames[i], "VK_KHR_external_semaphore_win32"))
+            {
                 new_extensions_list[o] = strdup("VK_KHR_external_semaphore_fd");
+
+                /* D3D12-Fence interoperable semaphores are implemented using timeline semaphores */
+                if (!timeline_enabled && (phys_dev->api_version < VK_API_VERSION_1_2 || phys_dev->instance->api_version < VK_API_VERSION_1_2))
+                {
+                    for (j = 0; j < phys_dev->extension_count; j++)
+                    {
+                        if (!strcmp(phys_dev->extensions[j].extensionName, "VK_KHR_timeline_semaphore"))
+                        {
+                            new_extensions_list[++o] = strdup("VK_KHR_timeline_semaphore");
+                            break;
+                        }
+                    }
+                }
+
+            }
             else
                 new_extensions_list[o] = strdup(dst->ppEnabledExtensionNames[i]);
             ++o;
@@ -444,10 +541,13 @@ static VkResult wine_vk_device_convert_create_info(const VkDeviceCreateInfo *src
 
         dst->enabledExtensionCount = o;
         dst->ppEnabledExtensionNames = (const char * const *)new_extensions_list;
+
     }
 
+    wine_extension_count = dst->enabledExtensionCount;
+
     TRACE("Enabled %u extensions.\n", dst->enabledExtensionCount);
-    for (i = 0; i < dst->enabledExtensionCount; i++)
+    for (i = 0; i < wine_extension_count; i++)
     {
         TRACE("Extension %u: %s.\n", i, debugstr_a(dst->ppEnabledExtensionNames[i]));
     }
@@ -455,6 +555,11 @@ static VkResult wine_vk_device_convert_create_info(const VkDeviceCreateInfo *src
     return VK_SUCCESS;
 }
 
+static bool is_virtual_queue(struct VkQueue_T *queue)
+{
+    return __atomic_load_n(&queue->virtual_queue, __ATOMIC_ACQUIRE);
+}
+
 /* Helper function used for freeing a device structure. This function supports full
  * and partial object cleanups and can thus be used for vkCreateDevice failures.
  */
@@ -471,6 +576,28 @@ static void wine_vk_device_free(struct VkDevice_T *device)
         for (i = 0; i < device->queue_count; i++)
         {
             queue = &device->queues[i];
+
+            if (is_virtual_queue(queue))
+            {
+                pthread_mutex_lock(&queue->submissions_mutex);
+                pthread_mutex_lock(&queue->signaller_mutex);
+                queue->stop = 1;
+                pthread_mutex_unlock(&queue->submissions_mutex);
+                pthread_mutex_unlock(&queue->signaller_mutex);
+
+                pthread_cond_signal(&queue->submissions_cond);
+                pthread_cond_signal(&queue->signaller_cond);
+
+                pthread_join(queue->virtual_queue_thread, NULL);
+                pthread_join(queue->signal_thread, NULL);
+            }
+
+            pthread_mutex_destroy(&queue->submissions_mutex);
+            pthread_mutex_destroy(&queue->signaller_mutex);
+
+            pthread_cond_destroy(&queue->submissions_cond);
+            pthread_cond_destroy(&queue->signaller_cond);
+
             if (queue && queue->queue)
                 WINE_VK_REMOVE_HANDLE_MAPPING(device->phys_dev->instance, queue);
         }
@@ -781,7 +907,7 @@ NTSTATUS wine_vkCreateDevice(void *args)
     object->base.base.loader_magic = VULKAN_ICD_MAGIC_VALUE;
     object->phys_dev = phys_dev;
 
-    res = wine_vk_device_convert_create_info(create_info, &create_info_host);
+    res = wine_vk_device_convert_create_info(phys_dev, create_info, &create_info_host);
     if (res != VK_SUCCESS)
         goto fail;
 
@@ -1013,6 +1130,23 @@ VkResult WINAPI __wine_create_vk_instance_with_callback(const VkInstanceCreateIn
     ALL_VK_INSTANCE_FUNCS()
 #undef USE_VK_FUNC
 
+    if ((app_info = create_info->pApplicationInfo))
+    {
+        TRACE("Application name %s, application version %#x.\n",
+                debugstr_a(app_info->pApplicationName), app_info->applicationVersion);
+        TRACE("Engine name %s, engine version %#x.\n", debugstr_a(app_info->pEngineName),
+                app_info->engineVersion);
+        TRACE("API version %#x.\n", app_info->apiVersion);
+
+        object->api_version = app_info->apiVersion;
+
+        if (app_info->pEngineName && !strcmp(app_info->pEngineName, "idTech"))
+            object->quirks |= WINEVULKAN_QUIRK_GET_DEVICE_PROC_ADDR;
+
+        if (app_info->pEngineName && !strcmp(app_info->pEngineName, "nvpro-sample"))
+            object->quirks |= (WINEVULKAN_QUIRK_EXPOSE_MEM_PRIORITY | WINEVULKAN_QUIRK_EXPOSE_KEYED_MUTEX);
+    }
+
     /* Cache physical devices for vkEnumeratePhysicalDevices within the instance as
      * each vkPhysicalDevice is a dispatchable object, which means we need to wrap
      * the native physical devices and present those to the application.
@@ -1026,18 +1160,6 @@ VkResult WINAPI __wine_create_vk_instance_with_callback(const VkInstanceCreateIn
         return res;
     }
 
-    if ((app_info = create_info->pApplicationInfo))
-    {
-        TRACE("Application name %s, application version %#x.\n",
-                debugstr_a(app_info->pApplicationName), app_info->applicationVersion);
-        TRACE("Engine name %s, engine version %#x.\n", debugstr_a(app_info->pEngineName),
-                app_info->engineVersion);
-        TRACE("API version %#x.\n", app_info->apiVersion);
-
-        if (app_info->pEngineName && !strcmp(app_info->pEngineName, "idTech"))
-            object->quirks |= WINEVULKAN_QUIRK_GET_DEVICE_PROC_ADDR;
-    }
-
     object->quirks |= WINEVULKAN_QUIRK_ADJUST_MAX_IMAGE_COUNT;
 
     *instance = object;
@@ -1469,7 +1591,9 @@ static inline void wine_vk_normalize_handle_types_host(VkExternalMemoryHandleTyp
 
 static const VkExternalMemoryHandleTypeFlagBits wine_vk_handle_over_fd_types =
                 VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT |
-                VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT;
+                VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT |
+                VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT |
+                VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT;
 
 static void wine_vk_get_physical_device_external_buffer_properties(VkPhysicalDevice phys_dev,
         void (*p_vkGetPhysicalDeviceExternalBufferProperties)(VkPhysicalDevice, const VkPhysicalDeviceExternalBufferInfo *, VkExternalBufferProperties *),
@@ -1776,29 +1900,90 @@ static void wine_vk_get_physical_device_external_semaphore_properties(VkPhysical
     void (*p_vkGetPhysicalDeviceExternalSemaphoreProperties)(VkPhysicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *, VkExternalSemaphoreProperties *),
     const VkPhysicalDeviceExternalSemaphoreInfo *semaphore_info, VkExternalSemaphoreProperties *properties)
 {
-    VkPhysicalDeviceExternalSemaphoreInfo semaphore_info_dup = *semaphore_info;
+    VkPhysicalDeviceExternalSemaphoreInfo semaphore_info_dup = *semaphore_info, semaphore_info_host;
+    VkSemaphoreTypeCreateInfo semaphore_type_info, *p_semaphore_type_info;
+    unsigned int i;
+    VkResult res;
+
+    if ((res = convert_VkPhysicalDeviceExternalSemaphoreInfo_struct_chain(semaphore_info->pNext, &semaphore_info_dup)) < 0)
+    {
+        WARN("Failed to convert VkPhysicalDeviceExternalSemaphoreInfo pNext chain, res=%d.\n", res);
+
+        properties->exportFromImportedHandleTypes = 0;
+        properties->compatibleHandleTypes = 0;
+        properties->externalSemaphoreFeatures = 0;
+        return;
+    }
+
+    semaphore_info_host = semaphore_info_dup;
+
+    switch(semaphore_info->handleType)
+    {
+        case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT:
+            semaphore_info_host.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+            break;
+        case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT:
+        {
+            if (phys_dev->api_version < VK_API_VERSION_1_2 ||
+                phys_dev->instance->api_version < VK_API_VERSION_1_2)
+            {
+                for (i = 0; i < phys_dev->extension_count; i++)
+                {
+                    if (!strcmp(phys_dev->extensions[i].extensionName, "VK_KHR_timeline_semaphore"))
+                        break;
+                }
+                if (i == phys_dev->extension_count)
+                {
+                    free_VkPhysicalDeviceExternalSemaphoreInfo_struct_chain(&semaphore_info_dup);
+                    properties->exportFromImportedHandleTypes = 0;
+                    properties->compatibleHandleTypes = 0;
+                    properties->externalSemaphoreFeatures = 0;
+                    return;
+                }
+            }
+
+            if ((p_semaphore_type_info = wine_vk_find_struct(&semaphore_info_host, SEMAPHORE_TYPE_CREATE_INFO)))
+            {
+                p_semaphore_type_info->semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE;
+                p_semaphore_type_info->initialValue = 0;
+            }
+            else
+            {
+                semaphore_type_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
+                semaphore_type_info.pNext = semaphore_info_host.pNext;
+                semaphore_type_info.semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE;
+                semaphore_type_info.initialValue = 0;
+
+                semaphore_info_host.pNext = &semaphore_type_info;
+            }
 
-    wine_vk_normalize_semaphore_handle_types_win(&semaphore_info_dup.handleType);
-    if (semaphore_info_dup.handleType == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT)
-        semaphore_info_dup.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
-    wine_vk_normalize_semaphore_handle_types_host(&semaphore_info_dup.handleType);
+            semaphore_info_host.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+            break;
+        }
+        default:
+            semaphore_info_host.handleType = 0;
+    }
 
-    if (semaphore_info->handleType && !semaphore_info_dup.handleType)
+    if (semaphore_info->handleType && !semaphore_info_host.handleType)
     {
+        free_VkPhysicalDeviceExternalSemaphoreInfo_struct_chain(&semaphore_info_dup);
+
         properties->exportFromImportedHandleTypes = 0;
         properties->compatibleHandleTypes = 0;
         properties->externalSemaphoreFeatures = 0;
         return;
     }
 
-    p_vkGetPhysicalDeviceExternalSemaphoreProperties(phys_dev->phys_dev, &semaphore_info_dup, properties);
+    p_vkGetPhysicalDeviceExternalSemaphoreProperties(phys_dev->phys_dev, &semaphore_info_host, properties);
+
+    free_VkPhysicalDeviceExternalSemaphoreInfo_struct_chain(&semaphore_info_dup);
 
     if (properties->exportFromImportedHandleTypes & VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT)
-        properties->exportFromImportedHandleTypes |= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+        properties->exportFromImportedHandleTypes = semaphore_info->handleType;
     wine_vk_normalize_semaphore_handle_types_win(&properties->exportFromImportedHandleTypes);
 
     if (properties->compatibleHandleTypes & VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT)
-        properties->compatibleHandleTypes |= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+        properties->compatibleHandleTypes = semaphore_info->handleType;
     wine_vk_normalize_semaphore_handle_types_win(&properties->compatibleHandleTypes);
 }
 
@@ -2844,7 +3029,7 @@ NTSTATUS wine_vkAcquireNextImage2KHR(void *args)
     image_info_host.pNext = pAcquireInfo->pNext;
     image_info_host.swapchain = object->swapchain;
     image_info_host.timeout = pAcquireInfo->timeout;
-    image_info_host.semaphore = pAcquireInfo->semaphore;
+    image_info_host.semaphore = wine_semaphore_from_handle(pAcquireInfo->semaphore)->semaphore;
     image_info_host.fence = pAcquireInfo->fence;
     image_info_host.deviceMask = pAcquireInfo->deviceMask;
 
@@ -3338,11 +3523,8 @@ static VkResult record_graphics_cmd(VkDevice device, struct VkSwapchainKHR_T *sw
     return VK_SUCCESS;
 }
 
-NTSTATUS wine_vkQueuePresentKHR(void *args)
+static VkResult fshack_vk_queue_present(VkQueue queue, const VkPresentInfoKHR *pPresentInfo)
 {
-    struct vkQueuePresentKHR_params *params = args;
-    VkQueue queue = params->queue;
-    const VkPresentInfoKHR *pPresentInfo = params->pPresentInfo;
     VkResult res;
     VkPresentInfoKHR our_presentInfo;
     VkSwapchainKHR *arr;
@@ -3800,6 +3991,23 @@ NTSTATUS wine_vkAllocateMemory(void *args)
         return res;
     }
 
+    if (device->phys_dev->fake_memory_priority)
+    {
+        VkBaseOutStructure *header;
+
+        for (header = (void *) &allocate_info_dup; header; header = header->pNext)
+        {
+            if (header->pNext && header->pNext->sType == VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT)
+            {
+                VkBaseOutStructure *memory_priority = header->pNext;
+
+                header->pNext = memory_priority->pNext;
+                free(memory_priority);
+                break;
+            }
+        }
+    }
+
     if (!(object = calloc(1, sizeof(*object))))
     {
         free_VkMemoryAllocateInfo_struct_chain(&allocate_info_dup);
@@ -3835,12 +4043,14 @@ NTSTATUS wine_vkAllocateMemory(void *args)
         switch (handle_import_info->handleType)
         {
             case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT:
+            case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT:
                 if (handle_import_info->handle)
                     NtDuplicateObject( NtCurrentProcess(), handle_import_info->handle, NtCurrentProcess(), &object->handle, 0, 0, DUPLICATE_SAME_ACCESS );
                 else if (handle_import_info->name)
                     object->handle = open_shared_resource( 0, handle_import_info->name );
                 break;
             case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
+            case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT:
                 /* FIXME: the spec says that device memory imported from a KMT handle doesn't keep a reference to the underyling payload.
                    This means that in cases where on windows an application leaks VkDeviceMemory objects, we leak the full payload.  To
                    fix this, we would need wine_dev_mem objects to store no reference to the payload, that means no host VkDeviceMemory
@@ -3942,9 +4152,11 @@ NTSTATUS wine_vkGetMemoryWin32HandleKHR(void *args)
     switch(handle_info->handleType)
     {
         case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT:
+        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT:
             return !NtDuplicateObject( NtCurrentProcess(), dev_mem->handle, NtCurrentProcess(), handle, dev_mem->access, dev_mem->inherit ? OBJ_INHERIT : 0, 0) ?
                 VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY;
         case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
+        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT:
         {
             if ((ret = get_shared_resource_kmt_handle(dev_mem->handle)) == INVALID_HANDLE_VALUE)
                 return VK_ERROR_OUT_OF_HOST_MEMORY;
@@ -4084,118 +4296,1904 @@ NTSTATUS wine_vkCreateImage(void *args)
     return res;
 }
 
-NTSTATUS wine_vkCreateSemaphore(void *args)
+#define IOCTL_SHARED_GPU_RESOURCE_SET_OBJECT           CTL_CODE(FILE_DEVICE_VIDEO, 6, METHOD_BUFFERED, FILE_WRITE_ACCESS)
+
+static bool set_shared_resource_object(HANDLE shared_resource, unsigned int index, HANDLE handle)
 {
-    struct vkCreateSemaphore_params *params = args;
-    VkDevice device = params->device;
-    const VkSemaphoreCreateInfo *create_info = params->pCreateInfo;
-    const VkAllocationCallbacks *allocator = params->pAllocator;
-    VkSemaphore *semaphore = params->pSemaphore;
+    IO_STATUS_BLOCK iosb;
+    struct shared_resource_set_object
+    {
+        unsigned int index;
+        obj_handle_t handle;
+    } params;
 
-    VkSemaphoreCreateInfo create_info_host = *create_info;
-    VkExportSemaphoreCreateInfo *export_semaphore_info;
-    VkResult res;
+    params.index = index;
+    params.handle = wine_server_obj_handle(handle);
 
-    TRACE("%p %p %p %p", device, create_info, allocator, semaphore);
+    return NtDeviceIoControlFile(shared_resource, NULL, NULL, NULL, &iosb, IOCTL_SHARED_GPU_RESOURCE_SET_OBJECT,
+            &params, sizeof(params), NULL, 0) == STATUS_SUCCESS;
+}
 
-    if (allocator)
-        FIXME("Support for allocation callbacks not implemented yet\n");
+#define IOCTL_SHARED_GPU_RESOURCE_GET_OBJECT           CTL_CODE(FILE_DEVICE_VIDEO, 6, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+static HANDLE get_shared_resource_object(HANDLE shared_resource, unsigned int index)
+{
+    IO_STATUS_BLOCK iosb;
+    obj_handle_t handle;
+
+    if (NtDeviceIoControlFile(shared_resource, NULL, NULL, NULL, &iosb, IOCTL_SHARED_GPU_RESOURCE_GET_OBJECT,
+            &index, sizeof(index), &handle, sizeof(handle)))
+        return NULL;
+
+    return wine_server_ptr_handle(handle);
+}
+
+static void d3d12_semaphore_lock(struct wine_semaphore *semaphore)
+{
+    assert( semaphore->handle_type == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT );
+    pthread_mutex_lock(&semaphore->d3d12_fence_shm->mutex);
+}
+
+static void d3d12_semaphore_unlock(struct wine_semaphore *semaphore)
+{
+    assert( semaphore->handle_type == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT );
+    pthread_mutex_unlock(&semaphore->d3d12_fence_shm->mutex);
+}
+
+/* returns -1 when there is no queued update that would satisfy the wait */
+static uint64_t d3d12_semaphore_try_get_wait_value_locked(struct wine_semaphore *semaphore, uint64_t virtual_value,
+        struct VkQueue_T *waiting_queue)
+{
+    struct pending_update *update;
+    uint64_t ret = -1;
+    unsigned int i;
+
+    if (semaphore->d3d12_fence_shm->virtual_value >= virtual_value)
+        return 0;
 
-    if ((res = convert_VkSemaphoreCreateInfo_struct_chain(create_info->pNext, &create_info_host)))
+    for (i = 0; i < semaphore->d3d12_fence_shm->pending_updates_count; i++)
     {
-        WARN("Failed to convert VkSemaphoreCreateInfo pNext chain, res=%d.\n", res);
-        return res;
+        update = &semaphore->d3d12_fence_shm->pending_updates[i];
+
+        if (update->virtual_value < virtual_value)
+            continue;
+
+        if (update->signalling_pid == getpid() && waiting_queue && update->signalling_queue == waiting_queue)
+            return 0;
+
+        ret = min(ret, update->physical_value);
     }
 
-    if ((export_semaphore_info = wine_vk_find_struct(&create_info_host, EXPORT_SEMAPHORE_CREATE_INFO)))
+    return ret;
+}
+
+static struct pending_wait *d3d12_semaphore_push_wait_locked(struct wine_semaphore *semaphore, uint64_t virtual_value)
+{
+    struct pending_wait *wait;
+    unsigned int i;
+
+    for (i = 0; i < ARRAY_SIZE(semaphore->d3d12_fence_shm->pending_waits); i++)
     {
-        if (export_semaphore_info->handleTypes & VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT)
-            export_semaphore_info->handleTypes |= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
-        wine_vk_normalize_semaphore_handle_types_host(&export_semaphore_info->handleTypes);
+        wait = &semaphore->d3d12_fence_shm->pending_waits[i];
+        if (!wait->present)
+            break;
     }
 
-    if (wine_vk_find_struct(&create_info_host,  EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR))
-        FIXME("VkExportSemaphoreWin32HandleInfoKHR unhandled.\n");
-
-    res = device->funcs.p_vkCreateSemaphore(device->device, &create_info_host, NULL, semaphore);
+    if (i == ARRAY_SIZE(semaphore->d3d12_fence_shm->pending_waits))
+    {
+        FIXME("Failed to wait on semaphore %p, maximum waits exceeded.\n", semaphore);
+        return NULL;
+    }
 
-    free_VkSemaphoreCreateInfo_struct_chain(&create_info_host);
+    wait->present = true;
+    wait->satisfied = false;
+    wait->virtual_value = virtual_value;
+    wait->physical_value = 0;
 
-    return res;
+    return wait;
 }
 
-NTSTATUS wine_vkGetSemaphoreWin32HandleKHR(void *args)
+static uint64_t d3d12_semaphore_pop_wait_locked(struct wine_semaphore *semaphore, struct pending_wait *wait)
 {
-    struct vkGetSemaphoreWin32HandleKHR_params *params = args;
-    VkDevice device = params->device;
-    const VkSemaphoreGetWin32HandleInfoKHR *handle_info = params->pGetWin32HandleInfo;
-    HANDLE *handle = params->pHandle;
+    wait->satisfied = false;
+    wait->present = false;
 
-    VkSemaphoreGetFdInfoKHR_host fd_info;
-    VkResult res;
-    int fd;
+    return wait->physical_value;
+}
 
-    fd_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR;
-    fd_info.pNext = handle_info->pNext;
-    fd_info.semaphore = handle_info->semaphore;
-    fd_info.handleType = handle_info->handleType;
-    if (fd_info.handleType == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT)
-        fd_info.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
-    wine_vk_normalize_semaphore_handle_types_host(&fd_info.handleType);
+static void d3d12_semaphore_satisfy_waits_locked(struct wine_semaphore *semaphore, uint64_t virtual_value,
+        uint64_t physical_value)
+{
+    struct pending_wait *wait;
+    unsigned int i;
 
-    res = device->funcs.p_vkGetSemaphoreFdKHR(device->device, &fd_info, &fd);
+    for (i = 0; i < ARRAY_SIZE(semaphore->d3d12_fence_shm->pending_waits); i++)
+    {
+        wait = &semaphore->d3d12_fence_shm->pending_waits[i];
 
-    if (res != VK_SUCCESS)
-        return res;
+        if (wait->present && !wait->satisfied && wait->virtual_value <= virtual_value)
+        {
+            wait->satisfied = true;
+            wait->physical_value = physical_value;
+            pthread_cond_signal(&wait->cond);
+        }
+    }
+}
+
+static uint64_t d3d12_semaphore_add_pending_signal_locked(struct wine_semaphore *semaphore, uint64_t virtual_value,
+        struct VkQueue_T *signalling_queue)
+{
+    struct pending_update *update;
 
-    if (wine_server_fd_to_handle(fd, GENERIC_ALL, 0, handle) != STATUS_SUCCESS)
+    if (semaphore->d3d12_fence_shm->pending_updates_count == ARRAY_SIZE(semaphore->d3d12_fence_shm->pending_updates))
     {
-        close(fd);
-        return VK_ERROR_OUT_OF_HOST_MEMORY;
+        FIXME("Failed to queue signal on d3d12 semaphore, maximum concurrent signals exceeded.\n");
+        return 0;
     }
 
-    return VK_SUCCESS;
+    update = &semaphore->d3d12_fence_shm->pending_updates[
+        semaphore->d3d12_fence_shm->pending_updates_count++];
+
+    update->virtual_value = virtual_value;
+    update->physical_value = ++semaphore->d3d12_fence_shm->counter;
+    update->signalling_pid = getpid();
+    update->signalling_queue = signalling_queue;
+
+    return update->physical_value;
 }
 
-NTSTATUS wine_vkImportSemaphoreWin32HandleKHR(void *args)
+static struct pending_update d3d12_semaphore_peek_added_signal_locked(struct wine_semaphore *semaphore)
 {
-    struct vkImportSemaphoreWin32HandleKHR_params *params = args;
-    VkDevice device = params->device;
-    const VkImportSemaphoreWin32HandleInfoKHR *handle_info = params->pImportSemaphoreWin32HandleInfo;
-
-    VkImportSemaphoreFdInfoKHR_host fd_info;
-    VkResult res;
-    int fd;
+    return semaphore->d3d12_fence_shm->pending_updates[semaphore->d3d12_fence_shm->pending_updates_count - 1];
+}
 
-    fd_info.sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR;
-    fd_info.pNext = handle_info->pNext;
-    fd_info.semaphore = handle_info->semaphore;
-    fd_info.flags = handle_info->flags;
-    fd_info.handleType = handle_info->handleType;
+static bool d3d12_semaphore_pop_pending_signal_locked(struct wine_semaphore *semaphore, uint64_t phys_val, struct pending_update *ret)
+{
+    struct pending_update *update;
+    unsigned int i;
 
-    if (fd_info.handleType == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT)
+    for (i = 0; i < semaphore->d3d12_fence_shm->pending_updates_count; i++)
     {
-        if (handle_info->name)
+        if (semaphore->d3d12_fence_shm->pending_updates[i].physical_value == phys_val)
         {
-            FIXME("Importing win32 semaphore by name not supported.\n");
-            return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+            update = &semaphore->d3d12_fence_shm->pending_updates[i];
+            if (ret)
+                *ret = *update;
+            *update = semaphore->d3d12_fence_shm->pending_updates[--semaphore->d3d12_fence_shm->pending_updates_count];
+            return true;
         }
-
-        fd_info.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
-        if (wine_server_handle_to_fd(handle_info->handle, GENERIC_ALL, &fd, NULL) != STATUS_SUCCESS)
-            return VK_ERROR_INVALID_EXTERNAL_HANDLE;
     }
-    wine_vk_normalize_semaphore_handle_types_host(&fd_info.handleType);
 
-    if (!fd_info.handleType)
+    return false;
+}
+
+static void d3d12_semaphore_update_phys_val_locked(struct wine_semaphore *sem, uint64_t phys_val)
+{
+    struct pending_update pending;
+
+    /* Based off linked VKD3D-Proton implementation, but we don't signal CPU waits here.
+        * https://github.com/HansKristian-Work/vkd3d-proton/blob/829ac72e3d381006a843c183e613e8ee77e0b292/libs/vkd3d/command.c#L758 */
+    while (sem->d3d12_fence_shm->physical_value < phys_val)
     {
-        FIXME("Importing win32 semaphore with handle type %#x not supported.\n", handle_info->handleType);
-        return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+        sem->d3d12_fence_shm->physical_value++;
+
+        if (d3d12_semaphore_pop_pending_signal_locked(sem, sem->d3d12_fence_shm->physical_value, &pending))
+            sem->d3d12_fence_shm->virtual_value = pending.virtual_value;
     }
+}
 
-    /* importing FDs transfers ownership, importing NT handles does not  */
-    if ((res = device->funcs.p_vkImportSemaphoreFdKHR(device->device, &fd_info)) != VK_SUCCESS)
-        close(fd);
+NTSTATUS wine_vkCreateSemaphore(void *args)
+{
+    struct vkCreateSemaphore_params *params = args;
+    VkDevice device = params->device;
+    const VkSemaphoreCreateInfo *create_info = params->pCreateInfo;
+    const VkAllocationCallbacks *allocator = params->pAllocator;
+    VkSemaphore *semaphore = params->pSemaphore;
 
-    return res;
+    VkExportSemaphoreWin32HandleInfoKHR *export_handle_info = wine_vk_find_struct(create_info, EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR);
+    VkExportSemaphoreCreateInfo *export_semaphore_info, timeline_export_info;
+    VkSemaphoreCreateInfo create_info_dup = *create_info, create_info_host;
+    VkSemaphoreTypeCreateInfo *found_type_info, type_info;
+    VkSemaphoreGetFdInfoKHR_host fd_info;
+    pthread_mutexattr_t mutex_attr;
+    struct wine_semaphore *object;
+    pthread_condattr_t cond_attr;
+    OBJECT_ATTRIBUTES attr;
+    HANDLE section_handle;
+    LARGE_INTEGER li;
+    unsigned int i;
+    VkResult res;
+    SIZE_T size;
+    int fd;
+
+    TRACE("(%p, %p, %p, %p)\n", device, create_info, allocator, semaphore);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    if ((res = convert_VkSemaphoreCreateInfo_struct_chain(create_info->pNext, &create_info_dup)))
+    {
+        WARN("Failed to convert VkSemaphoreCreateInfo pNext chain, res=%d.\n", res);
+        return res;
+    }
+
+    if (!(object = calloc(1, sizeof(*object))))
+    {
+        free_VkSemaphoreCreateInfo_struct_chain(&create_info_dup);
+        return VK_ERROR_OUT_OF_HOST_MEMORY;
+    }
+    object->handle = INVALID_HANDLE_VALUE;
+
+    create_info_host = create_info_dup;
+
+    if ((export_semaphore_info = wine_vk_find_struct(&create_info_host, EXPORT_SEMAPHORE_CREATE_INFO)))
+    {
+        object->export_types = export_semaphore_info->handleTypes;
+        if (export_semaphore_info->handleTypes & VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT)
+            export_semaphore_info->handleTypes |= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+        wine_vk_normalize_semaphore_handle_types_host(&export_semaphore_info->handleTypes);
+    }
+
+    if ((res = device->funcs.p_vkCreateSemaphore(device->device, &create_info_host, NULL, &object->semaphore)) != VK_SUCCESS)
+        goto done;
+
+    if (export_semaphore_info && export_semaphore_info->handleTypes == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT)
+    {
+        fd_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR;
+        fd_info.pNext = NULL;
+        fd_info.semaphore = object->semaphore;
+        fd_info.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+
+        if ((res = device->funcs.p_vkGetSemaphoreFdKHR(device->device, &fd_info, &fd)) == VK_SUCCESS)
+        {
+            object->handle = create_gpu_resource(fd, export_handle_info ? export_handle_info->name : NULL);
+            close(fd);
+        }
+
+        if (object->handle == INVALID_HANDLE_VALUE)
+        {
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto done;
+        }
+    }
+    else if (object->export_types & VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+    {
+        /* compatibleHandleTypes doesn't include any other types */
+        assert(object->export_types == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT);
+        object->handle_type = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT;
+
+        timeline_export_info.sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO;
+        timeline_export_info.pNext = NULL;
+        timeline_export_info.handleTypes = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+
+        type_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
+        type_info.pNext = &timeline_export_info;
+        type_info.semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE;
+        type_info.initialValue = 0;
+
+        create_info_host.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
+        create_info_host.pNext = &type_info;
+        create_info_host.flags = 0;
+
+        if ((res = device->funcs.p_vkCreateSemaphore(device->device, &create_info_host, NULL, &object->fence_timeline_semaphore)) != VK_SUCCESS)
+            goto done;
+
+        fd_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR;
+        fd_info.pNext = NULL;
+        fd_info.semaphore = object->fence_timeline_semaphore;
+        fd_info.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+
+        if ((res = device->funcs.p_vkGetSemaphoreFdKHR(device->device, &fd_info, &fd)) == VK_SUCCESS)
+        {
+            object->handle = create_gpu_resource(fd, export_handle_info ? export_handle_info->name : NULL);
+            close(fd);
+        }
+
+        if (object->handle == INVALID_HANDLE_VALUE)
+        {
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto done;
+        }
+
+        /* Shared Fence Memory */
+        InitializeObjectAttributes(&attr, NULL, 0, NULL, NULL);
+        size = li.QuadPart = sizeof(*object->d3d12_fence_shm);
+        if (NtCreateSection(&section_handle, STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ | SECTION_MAP_WRITE, &attr, &li, PAGE_READWRITE, SEC_COMMIT, NULL))
+        {
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto done;
+        }
+
+        if (!set_shared_resource_object(object->handle, 0, section_handle))
+        {
+            NtClose(section_handle);
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto done;
+        }
+
+        if (NtMapViewOfSection(section_handle, GetCurrentProcess(), (void**) &object->d3d12_fence_shm, 0, 0, NULL, &size, ViewShare, 0, PAGE_READWRITE))
+        {
+            NtClose(section_handle);
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto done;
+        }
+
+        NtClose(section_handle);
+
+        if ((found_type_info = wine_vk_find_struct(create_info, SEMAPHORE_TYPE_CREATE_INFO)))
+            object->d3d12_fence_shm->virtual_value = found_type_info->initialValue;
+
+        pthread_mutexattr_init(&mutex_attr);
+        pthread_mutexattr_setpshared(&mutex_attr, PTHREAD_PROCESS_SHARED);
+        if (pthread_mutex_init(&object->d3d12_fence_shm->mutex, &mutex_attr))
+        {
+            pthread_mutexattr_destroy(&mutex_attr);
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto done;
+        }
+        pthread_mutexattr_destroy(&mutex_attr);
+
+        for (i = 0; i < ARRAY_SIZE(object->d3d12_fence_shm->pending_waits); i++)
+        {
+            pthread_condattr_init(&cond_attr);
+            pthread_condattr_setpshared(&cond_attr, PTHREAD_PROCESS_SHARED);
+            pthread_cond_init(&object->d3d12_fence_shm->pending_waits[i].cond, &cond_attr);
+            pthread_condattr_destroy(&cond_attr);
+        }
+
+        WINE_VK_ADD_NON_DISPATCHABLE_MAPPING(device->phys_dev->instance, object, object->fence_timeline_semaphore);
+    }
+
+    WINE_VK_ADD_NON_DISPATCHABLE_MAPPING(device->phys_dev->instance, object, object->semaphore);
+    *semaphore = wine_semaphore_to_handle(object);
+
+    done:
+
+    if (res != VK_SUCCESS)
+    {
+        pthread_mutex_destroy(&object->d3d12_fence_shm->mutex);
+        if (object->d3d12_fence_shm)
+            NtUnmapViewOfSection(GetCurrentProcess(), object->d3d12_fence_shm);
+        if (object->handle != INVALID_HANDLE_VALUE)
+            NtClose(object->handle);
+        if (object->semaphore != VK_NULL_HANDLE)
+            device->funcs.p_vkDestroySemaphore(device->device, object->semaphore, NULL);
+        if (object->fence_timeline_semaphore != VK_NULL_HANDLE)
+            device->funcs.p_vkDestroySemaphore(device->device, object->fence_timeline_semaphore, NULL);
+        free(object);
+    }
+
+    free_VkSemaphoreCreateInfo_struct_chain(&create_info_dup);
+
+    return res;
+}
+
+NTSTATUS wine_vkGetSemaphoreWin32HandleKHR(void *args)
+{
+    struct vkGetSemaphoreWin32HandleKHR_params *params = args;
+    const VkSemaphoreGetWin32HandleInfoKHR *handle_info = params->pGetWin32HandleInfo;
+    HANDLE *handle = params->pHandle;
+
+    struct wine_semaphore *semaphore = wine_semaphore_from_handle(handle_info->semaphore);
+
+    if (!(semaphore->export_types & handle_info->handleType))
+        return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+
+    if (NtDuplicateObject( NtCurrentProcess(), semaphore->handle, NtCurrentProcess(), handle, 0, 0, DUPLICATE_SAME_ACCESS ))
+        return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+
+    return VK_SUCCESS;
+}
+
+NTSTATUS wine_vkDestroySemaphore(void *args)
+{
+    struct vkDestroySemaphore_params *params = args;
+    VkDevice device = params->device;
+    VkSemaphore handle = params->semaphore;
+    const VkAllocationCallbacks *allocator = params->pAllocator;
+
+    struct wine_semaphore *semaphore = wine_semaphore_from_handle(handle);
+
+    TRACE("%p 0x%s, %p\n", device, wine_dbgstr_longlong(handle), allocator);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    if (!handle)
+        return VK_SUCCESS;
+
+    if (semaphore->handle != INVALID_HANDLE_VALUE)
+        NtClose(semaphore->handle);
+
+    if (semaphore->d3d12_fence_shm)
+        NtUnmapViewOfSection(GetCurrentProcess(), semaphore->d3d12_fence_shm);
+
+    WINE_VK_REMOVE_HANDLE_MAPPING(device->phys_dev->instance, semaphore);
+    device->funcs.p_vkDestroySemaphore(device->device, semaphore->semaphore, NULL);
+
+    if (semaphore->fence_timeline_semaphore)
+        device->funcs.p_vkDestroySemaphore(device->device, semaphore->fence_timeline_semaphore, NULL);
+
+    free(semaphore);
+    return VK_SUCCESS;
+}
+
+NTSTATUS wine_vkImportSemaphoreWin32HandleKHR(void *args)
+{
+    struct vkImportSemaphoreWin32HandleKHR_params *params = args;
+    VkDevice device = params->device;
+    const VkImportSemaphoreWin32HandleInfoKHR *handle_info = params->pImportSemaphoreWin32HandleInfo;
+
+    struct wine_semaphore *semaphore = wine_semaphore_from_handle(handle_info->semaphore);
+    VkImportSemaphoreFdInfoKHR_host fd_info;
+    struct wine_semaphore output_semaphore;
+    VkSemaphoreTypeCreateInfo type_info;
+    VkSemaphoreCreateInfo create_info;
+    HANDLE d3d12_fence_shm;
+    NTSTATUS stat;
+    VkResult res;
+    SIZE_T size;
+
+    TRACE("(%p, %p). semaphore = %p handle = %p\n", device, handle_info, handle_info->semaphore, handle_info->handle);
+
+    if (handle_info->handleType == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT && !semaphore->fence_timeline_semaphore)
+    {
+        type_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
+        type_info.pNext = NULL;
+        type_info.semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE;
+        type_info.initialValue = 0;
+
+        create_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
+        create_info.pNext = &type_info;
+        create_info.flags = 0;
+
+        if ((res = device->funcs.p_vkCreateSemaphore(device->device, &create_info, NULL, &semaphore->fence_timeline_semaphore)) != VK_SUCCESS)
+        {
+            ERR("Failed to create timeline semaphore backing D3D12 semaphore. vr %d.\n", res);
+            return res;
+        };
+
+        WINE_VK_ADD_NON_DISPATCHABLE_MAPPING(device->phys_dev->instance, semaphore, semaphore->fence_timeline_semaphore);
+    }
+
+    output_semaphore = *semaphore;
+    output_semaphore.handle = NULL;
+    output_semaphore.handle_type = handle_info->handleType;
+    output_semaphore.d3d12_fence_shm = NULL;
+
+    fd_info.sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR;
+    fd_info.pNext = handle_info->pNext;
+    fd_info.semaphore = wine_semaphore_host_handle(&output_semaphore);
+    fd_info.flags = handle_info->flags;
+    fd_info.handleType = handle_info->handleType;
+
+    if (handle_info->handleType == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT ||
+        handle_info->handleType == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+    {
+        if (handle_info->name)
+        {
+            FIXME("Importing win32 semaphore by name not supported.\n");
+            return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+        }
+
+        if (NtDuplicateObject( NtCurrentProcess(), handle_info->handle, NtCurrentProcess(), &output_semaphore.handle, 0, 0, DUPLICATE_SAME_ACCESS ))
+            return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+
+        fd_info.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+        if ((fd_info.fd = get_shared_resource_fd(output_semaphore.handle)) == -1)
+        {
+            WARN("Invalid handle %p.\n", handle_info->handle);
+            NtClose(output_semaphore.handle);
+            return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+        }
+
+        if (handle_info->handleType == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+        {
+            if (handle_info->flags & VK_SEMAPHORE_IMPORT_TEMPORARY_BIT)
+            {
+                FIXME("Temporarily importing d3d12 fences unsupported.\n");
+                close(fd_info.fd);
+                NtClose(output_semaphore.handle);
+                return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+            }
+
+            if (!(d3d12_fence_shm = get_shared_resource_object(output_semaphore.handle, 0)))
+            {
+                ERR("Failed to get D3D12 semaphore memory.\n");
+                close(fd_info.fd);
+                NtClose(output_semaphore.handle);
+                return VK_ERROR_OUT_OF_HOST_MEMORY;
+            }
+
+            size = sizeof(*output_semaphore.d3d12_fence_shm);
+            if ((stat = NtMapViewOfSection(d3d12_fence_shm, GetCurrentProcess(), (void**) &output_semaphore.d3d12_fence_shm, 0, 0, NULL, &size, ViewShare, 0, PAGE_READWRITE)))
+            {
+                ERR("Failed to map D3D12 semaphore memory. stat %#x.\n", stat);
+                close(fd_info.fd);
+                NtClose(d3d12_fence_shm);
+                NtClose(output_semaphore.handle);
+                return VK_ERROR_OUT_OF_HOST_MEMORY;
+            }
+
+            NtClose(d3d12_fence_shm);
+        }
+    }
+
+    wine_vk_normalize_semaphore_handle_types_host(&fd_info.handleType);
+
+    if (!fd_info.handleType)
+    {
+        FIXME("Importing win32 semaphore with handle type %#x not supported.\n", handle_info->handleType);
+        return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+    }
+
+    if ((res = device->funcs.p_vkImportSemaphoreFdKHR(device->device, &fd_info)) == VK_SUCCESS)
+    {
+        if (semaphore->handle)
+            NtClose(semaphore->handle);
+        if (semaphore->d3d12_fence_shm)
+            NtUnmapViewOfSection(GetCurrentProcess(), semaphore->d3d12_fence_shm);
+
+        *semaphore = output_semaphore;
+    }
+    else
+    {
+        if (output_semaphore.handle)
+            NtClose(output_semaphore.handle);
+        if (output_semaphore.d3d12_fence_shm)
+            NtUnmapViewOfSection(GetCurrentProcess(), output_semaphore.d3d12_fence_shm);
+
+        /* importing FDs transfers ownership, importing NT handles does not  */
+        close(fd_info.fd);
+    }
+
+    return res;
+}
+
+
+static NTSTATUS vk_get_semaphore_counter_value(VkDevice device, VkSemaphore semaphore, uint64_t *value, bool khr);
+static NTSTATUS wine_vk_get_semaphore_counter_value(VkDevice device, VkSemaphore handle, uint64_t *value, bool khr)
+{
+    struct wine_semaphore *semaphore = wine_semaphore_from_handle(handle);
+
+    if (semaphore->handle_type == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+    {
+        d3d12_semaphore_lock(semaphore);
+        *value = semaphore->d3d12_fence_shm->virtual_value;
+        d3d12_semaphore_unlock(semaphore);
+        return VK_SUCCESS;
+    }
+
+    return vk_get_semaphore_counter_value(device, handle, value, khr);
+}
+
+static NTSTATUS vk_get_semaphore_counter_value(VkDevice device, VkSemaphore semaphore, uint64_t *value, bool khr)
+{
+    if (khr)
+        return thunk_vkGetSemaphoreCounterValueKHR(device, semaphore, value);
+    else
+        return thunk_vkGetSemaphoreCounterValue(device, semaphore, value);
+}
+
+NTSTATUS wine_vkGetSemaphoreCounterValue(void *args)
+{
+    struct vkGetSemaphoreCounterValue_params *params = args;
+    VkDevice device = params->device;
+    VkSemaphore semaphore = params->semaphore;
+    uint64_t *value = params->pValue;
+
+    return wine_vk_get_semaphore_counter_value(device, semaphore, value, false);
+}
+
+NTSTATUS wine_vkGetSemaphoreCounterValueKHR(void *args)
+{
+    struct vkGetSemaphoreCounterValue_params *params = args;
+    VkDevice device = params->device;
+    VkSemaphore semaphore = params->semaphore;
+    uint64_t *value = params->pValue;
+
+    return wine_vk_get_semaphore_counter_value(device, semaphore, value, true);
+}
+
+static NTSTATUS vk_signal_semaphore(VkDevice device, const VkSemaphoreSignalInfo *signal_info, bool khr);
+static NTSTATUS wine_vk_signal_semaphore(VkDevice device, const VkSemaphoreSignalInfo *signal_info, bool khr)
+{
+    uint64_t phys_val;
+    VkResult vr;
+
+    struct wine_semaphore *semaphore = wine_semaphore_from_handle(signal_info->semaphore);
+
+    TRACE("(%p, %p)\n", device, signal_info);
+
+    if (semaphore->handle_type == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+    {
+        d3d12_semaphore_lock(semaphore);
+
+        /* vkWaitSemaphore w/ WAIT_ANY wakes on every physical value increment to check if the wait is satisfied, so
+           if there are no scheduled signals, step the physical value */
+        if ((vr = vk_get_semaphore_counter_value(device, signal_info->semaphore, &phys_val, khr)) != VK_SUCCESS)
+        {
+            d3d12_semaphore_unlock(semaphore);
+            return vr;
+        }
+
+        d3d12_semaphore_update_phys_val_locked(semaphore, phys_val);
+
+        if (!semaphore->d3d12_fence_shm->pending_updates_count)
+        {
+            VkSemaphoreSignalInfo step_signal_info;
+
+            assert(semaphore->d3d12_fence_shm->counter == phys_val);
+            phys_val++;
+
+            semaphore->d3d12_fence_shm->counter = semaphore->d3d12_fence_shm->physical_value = phys_val;
+
+            step_signal_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO;
+            step_signal_info.pNext = NULL;
+            step_signal_info.semaphore = signal_info->semaphore;
+            step_signal_info.value = phys_val;
+
+            vr = vk_signal_semaphore(device, &step_signal_info, khr);
+            if (vr != VK_SUCCESS)
+            {
+                d3d12_semaphore_unlock(semaphore);
+                return vr;
+            }
+        }
+
+        /* If a queue is already waiting on the pending physical value of a previous submit, this won't wake it up. */
+        d3d12_semaphore_satisfy_waits_locked(semaphore, signal_info->value, 0);
+        semaphore->d3d12_fence_shm->virtual_value = signal_info->value;
+
+        d3d12_semaphore_unlock(semaphore);
+        return VK_SUCCESS;
+    }
+
+    return vk_signal_semaphore(device, signal_info, khr);
+}
+
+static NTSTATUS vk_signal_semaphore(VkDevice device, const VkSemaphoreSignalInfo *signal_info, bool khr)
+{
+    if (khr)
+        return thunk_vkSignalSemaphoreKHR(device, signal_info);
+    else
+        return thunk_vkSignalSemaphore(device, signal_info);
+}
+
+NTSTATUS wine_vkSignalSemaphore(void *args)
+{
+    struct vkSignalSemaphore_params *params = args;
+    VkDevice device = params->device;
+    const VkSemaphoreSignalInfo *signal_info = params->pSignalInfo;
+
+    return wine_vk_signal_semaphore(device, signal_info, false);
+}
+
+NTSTATUS wine_vkSignalSemaphoreKHR(void *args)
+{
+    struct vkSignalSemaphore_params *params = args;
+    VkDevice device = params->device;
+    const VkSemaphoreSignalInfo *signal_info = params->pSignalInfo;
+
+    return wine_vk_signal_semaphore(device, signal_info, true);
+}
+
+static NTSTATUS vk_wait_semaphores(VkDevice device, const VkSemaphoreWaitInfo *wait_info, uint64_t timeout, bool khr);
+static NTSTATUS wine_vk_wait_semaphores(VkDevice device, const VkSemaphoreWaitInfo *wait_info, uint64_t timeout, bool khr)
+{
+    VkSemaphoreWaitInfo wait_info_dup = *wait_info;
+    struct timespec abs_timeout, start_time;
+    struct pending_wait **pending_waits;
+    struct pending_wait *pending_wait;
+    unsigned int i, remaining_waits;
+    VkSemaphore* semaphores_dup;
+    uint64_t *values_dup;
+    uint64_t phys_val;
+    int wait_stat;
+    VkResult res;
+
+    TRACE("(%p, %p, 0x%s)\n", device, wait_info, wine_dbgstr_longlong(timeout));
+
+    if (timeout)
+    {
+        clock_gettime(CLOCK_REALTIME, &start_time);
+
+        abs_timeout.tv_sec = start_time.tv_sec + (timeout / NANOSECONDS_IN_A_SECOND);
+        abs_timeout.tv_nsec = start_time.tv_nsec + (timeout % NANOSECONDS_IN_A_SECOND);
+        if (abs_timeout.tv_nsec >= NANOSECONDS_IN_A_SECOND)
+        {
+            abs_timeout.tv_sec++;
+            abs_timeout.tv_nsec-=NANOSECONDS_IN_A_SECOND;
+        }
+    }
+
+    wait_info_dup.pSemaphores = semaphores_dup = calloc(wait_info->semaphoreCount, sizeof(VkSemaphore));
+    wait_info_dup.pValues = values_dup = calloc(wait_info->semaphoreCount, sizeof(uint64_t));
+    pending_waits = calloc(wait_info->semaphoreCount, sizeof(struct pending_wait *));
+
+    for (i = 0; i < wait_info->semaphoreCount; i++)
+    {
+        struct wine_semaphore *semaphore = wine_semaphore_from_handle(wait_info->pSemaphores[i]);
+
+        semaphores_dup[i] = wait_info->pSemaphores[i];
+        values_dup[i] = wait_info->pValues[i];
+
+        if (semaphore->handle_type == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+        {
+            d3d12_semaphore_lock(semaphore);
+            if ((values_dup[i] = d3d12_semaphore_try_get_wait_value_locked(semaphore, wait_info->pValues[i], NULL)) == -1)
+            {
+                if (!timeout)
+                {
+                    d3d12_semaphore_unlock(semaphore);
+                    continue;
+                }
+
+                pending_wait = d3d12_semaphore_push_wait_locked(semaphore, wait_info->pValues[i]);
+
+                if (wait_info->flags & VK_SEMAPHORE_WAIT_ANY_BIT)
+                {
+                    /* Keep scheduling a wait of current physical_value+1 until the desired virtual value is signaled */
+                    values_dup[i] = semaphore->d3d12_fence_shm->physical_value + 1;
+                    pending_waits[i] = pending_wait;
+                }
+                else
+                {
+                    while (!pending_wait->satisfied && wait_stat != ETIMEDOUT)
+                        wait_stat = pthread_cond_timedwait(&pending_wait->cond, &semaphore->d3d12_fence_shm->mutex, &abs_timeout);
+
+                    values_dup[i] = d3d12_semaphore_pop_wait_locked(semaphore, pending_wait);
+
+                    if (wait_stat == ETIMEDOUT)
+                    {
+                        d3d12_semaphore_unlock(semaphore);
+                        free(semaphores_dup);
+                        free(values_dup);
+                        free(pending_waits);
+                        return VK_TIMEOUT;
+                    }
+                }
+            }
+            d3d12_semaphore_unlock(semaphore);
+        }
+    }
+
+    do
+    {
+        if (timeout)
+        {
+            clock_gettime(CLOCK_REALTIME, &start_time);
+
+            if (start_time.tv_sec > abs_timeout.tv_sec ||
+                    (start_time.tv_sec == abs_timeout.tv_sec && start_time.tv_nsec >= abs_timeout.tv_nsec))
+                timeout = 0;
+            else
+                timeout = ((abs_timeout.tv_sec - start_time.tv_sec) * NANOSECONDS_IN_A_SECOND) +
+                    (abs_timeout.tv_nsec - start_time.tv_nsec);
+        }
+
+        remaining_waits = 0;
+        res = vk_wait_semaphores(device, &wait_info_dup, timeout, khr);
+
+        for (i = 0; i < wait_info->semaphoreCount; i++)
+        {
+            struct wine_semaphore * semaphore = wine_semaphore_from_handle(wait_info->pSemaphores[i]);
+
+            if (pending_waits[i])
+            {
+                remaining_waits++;
+
+                d3d12_semaphore_lock(semaphore);
+                if (res != VK_SUCCESS || pending_waits[i]->satisfied)
+                {
+                    values_dup[i] = pending_waits[i]->physical_value;
+                    d3d12_semaphore_pop_wait_locked(semaphore, pending_waits[i]);
+                    pending_waits[i] = NULL;
+                }
+                d3d12_semaphore_unlock(semaphore);
+            }
+        }
+    }
+    while (res == VK_SUCCESS && remaining_waits);
+
+    /* Make sure the physical value we waited on is processed before returning */
+    for (i = 0; i < wait_info_dup.semaphoreCount; i++)
+    {
+        struct wine_semaphore *semaphore = wine_semaphore_from_handle(wait_info_dup.pSemaphores[i]);
+
+        if (semaphore->handle_type == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+        {
+            d3d12_semaphore_lock(semaphore);
+            if (wait_info->flags & VK_SEMAPHORE_WAIT_ANY_BIT)
+            {
+                if (!vk_get_semaphore_counter_value(device, semaphores_dup[i], &phys_val, khr))
+                    d3d12_semaphore_update_phys_val_locked(semaphore, phys_val);
+            }
+            else
+                d3d12_semaphore_update_phys_val_locked(semaphore, values_dup[i]);
+            d3d12_semaphore_unlock(semaphore);
+        }
+    }
+
+    free(semaphores_dup);
+    free(values_dup);
+    free(pending_waits);
+    return res;
+}
+
+static NTSTATUS vk_wait_semaphores(VkDevice device, const VkSemaphoreWaitInfo *wait_info, uint64_t timeout, bool khr)
+{
+    if (khr)
+        return thunk_vkWaitSemaphoresKHR(device, wait_info, timeout);
+    else
+        return thunk_vkWaitSemaphores(device, wait_info, timeout);
+}
+
+NTSTATUS wine_vkWaitSemaphores(void *args)
+{
+    struct vkWaitSemaphores_params *params = args;
+    VkDevice device = params->device;
+    const VkSemaphoreWaitInfo *wait_info = params->pWaitInfo;
+    uint64_t timeout = params->timeout;
+
+    return wine_vk_wait_semaphores(device, wait_info, timeout, false);
+}
+
+NTSTATUS wine_vkWaitSemaphoresKHR(void *args)
+{
+    struct vkWaitSemaphores_params *params = args;
+    VkDevice device = params->device;
+    const VkSemaphoreWaitInfo *wait_info = params->pWaitInfo;
+    uint64_t timeout = params->timeout;
+
+    return wine_vk_wait_semaphores(device, wait_info, timeout, true);
+}
+
+struct signal_op
+{
+    enum
+    {
+        SIGNAL_TYPE_SEMAPHORE,
+        SIGNAL_TYPE_FENCE,
+    } signal_type;
+
+    union
+    {
+        struct
+        {
+            struct wine_semaphore *obj;
+            uint64_t phys_val;
+
+            bool khr;
+        } semaphore;
+
+        struct wine_fence *fence;
+    };
+
+    struct list entry;
+};
+
+static void *queue_signaller_worker(void *arg)
+{
+    struct VkQueue_T *queue = (struct VkQueue_T *)arg;
+    VkSemaphoreWaitInfo wait_info;
+    struct signal_op *signal_op;
+    VkSemaphore sem_handle;
+    bool device_lost;
+    VkFence fence;
+    uint64_t buf;
+    VkResult vr;
+
+    for (;;)
+    {
+        pthread_mutex_lock(&queue->signaller_mutex);
+
+        while (!queue->stop && list_empty(&queue->signal_ops))
+            pthread_cond_wait(&queue->signaller_cond, &queue->signaller_mutex);
+
+        if (queue->stop)
+        {
+            assert( list_empty(&queue->signal_ops) );
+            pthread_mutex_unlock(&queue->signaller_mutex);
+            return NULL;
+        }
+
+        signal_op = LIST_ENTRY(list_head(&queue->signal_ops), struct signal_op, entry);
+        list_remove(&signal_op->entry);
+
+        device_lost = queue->device_lost;
+
+        pthread_mutex_unlock(&queue->signaller_mutex);
+
+        if (signal_op->signal_type == SIGNAL_TYPE_SEMAPHORE)
+        {
+            wait_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO;
+            wait_info.pNext = NULL;
+            wait_info.flags = 0;
+            wait_info.semaphoreCount = 1;
+            sem_handle = wine_semaphore_to_handle(signal_op->semaphore.obj);
+            wait_info.pSemaphores = &sem_handle;
+            wait_info.pValues = &signal_op->semaphore.phys_val;
+            if (!device_lost && (vr = vk_wait_semaphores(queue->device, &wait_info, -1, signal_op->semaphore.khr)) < 0)
+            {
+                /* likely GPU hang */
+                fprintf(stderr, "winevulkan/queue_signaller_worker: Semaphore wait failed, vr %d.\n", vr);
+                continue;
+            }
+
+            d3d12_semaphore_lock(signal_op->semaphore.obj);
+            d3d12_semaphore_update_phys_val_locked(signal_op->semaphore.obj, signal_op->semaphore.phys_val);
+            d3d12_semaphore_unlock(signal_op->semaphore.obj);
+        }
+        else
+        {
+            fence = wine_fence_to_handle(signal_op->fence);
+
+            if (!device_lost && (vr = thunk_vkWaitForFences(queue->device, 1, &fence, VK_TRUE, -1)) < 0)
+            {
+                /* likely GPU hang */
+                fprintf(stderr, "winevulkan/queue_signaller_worker: Fence wait failed, vr %d.\n", vr);
+                continue;
+            }
+
+            buf = 1;
+            assert( write(signal_op->fence->eventfd, &buf, sizeof(buf)) != -1 );
+        }
+
+        free(signal_op);
+    }
+
+    return NULL;
+}
+
+static VkSubmitInfo *copy_VkSubmitInfo(const VkSubmitInfo *in, uint32_t submit_count)
+{
+    VkSubmitInfo *out = malloc(sizeof(*out) * submit_count);
+    unsigned int i;
+
+    for (i = 0; i < submit_count; i++)
+    {
+        out[i].sType = in[i].sType;
+        out[i].waitSemaphoreCount = in[i].waitSemaphoreCount;
+        out[i].pWaitSemaphores = memdup(in[i].pWaitSemaphores, in[i].waitSemaphoreCount, sizeof(out[i].pWaitSemaphores[0]));
+        out[i].pWaitDstStageMask = memdup(in[i].pWaitDstStageMask, in[i].waitSemaphoreCount, sizeof(out[i].pWaitDstStageMask[0]));
+        out[i].commandBufferCount = in[i].commandBufferCount;
+        out[i].pCommandBuffers = memdup(in[i].pCommandBuffers, in[i].commandBufferCount, sizeof(out[i].pCommandBuffers[0]));
+        out[i].signalSemaphoreCount = in[i].signalSemaphoreCount;
+        out[i].pSignalSemaphores = memdup(in[i].pSignalSemaphores, in[i].signalSemaphoreCount, sizeof(out[i].pSignalSemaphores[0]));
+
+        convert_VkSubmitInfo_struct_chain(in[i].pNext, &out[i]);
+    }
+
+    return out;
+}
+
+static void free_copied_VkSubmitInfo(VkSubmitInfo *info, uint32_t submit_count)
+{
+    unsigned int i;
+
+    for (i = 0; i < submit_count; i++)
+    {
+        free_VkSubmitInfo_struct_chain(&info[i]);
+
+        free((VkSemaphore *)         info[i].pWaitSemaphores);
+        free((VkPipelineStageFlags*) info[i].pWaitDstStageMask);
+        free((VkCommandBuffer*)      info[i].pCommandBuffers);
+        free((VkSemaphore*)          info[i].pSignalSemaphores);
+    }
+
+    free(info);
+}
+
+static VkSubmitInfo2 *copy_VkSubmitInfo2(const VkSubmitInfo2 *in, uint32_t submit_count)
+{
+    VkSubmitInfo2 *out = malloc(sizeof(*out) * submit_count);
+    VkCommandBufferSubmitInfo *cmdbuf_submit_info;
+    VkSemaphoreSubmitInfo *sem_submit_info;
+    unsigned int i, k;
+
+    for (i = 0; i < submit_count; i++)
+    {
+        out[i].sType = in[i].sType;
+        out[i].flags = in[i].flags;
+
+        out[i].waitSemaphoreInfoCount = in[i].waitSemaphoreInfoCount;
+        out[i].pWaitSemaphoreInfos = sem_submit_info = memdup(in[i].pWaitSemaphoreInfos,
+                                            in[i].waitSemaphoreInfoCount,
+                                            sizeof(out[i].pWaitSemaphoreInfos[0]));
+        for (k = 0; k < out[i].waitSemaphoreInfoCount; k++)
+        {
+            if (sem_submit_info[k].pNext)
+            {
+                FIXME("pNext chain conversion for VkSemaphoreSubmitInfo not supported.\n");
+                sem_submit_info[k].pNext = NULL;
+            }
+        }
+
+        out[i].commandBufferInfoCount = in[i].commandBufferInfoCount;
+        out[i].pCommandBufferInfos = cmdbuf_submit_info = memdup(in[i].pCommandBufferInfos,
+                                            in[i].commandBufferInfoCount,
+                                            sizeof(out[i].pCommandBufferInfos[0]));
+        for (k = 0; k < out[i].commandBufferInfoCount; k++)
+        {
+            if (cmdbuf_submit_info[k].pNext)
+            {
+                FIXME("pNext chain conversion for VkCommandBufferSubmitInfo not supported.\n");
+                cmdbuf_submit_info[k].pNext = NULL;
+            }
+        }
+
+        out[i].signalSemaphoreInfoCount = in[i].signalSemaphoreInfoCount;
+        out[i].pSignalSemaphoreInfos = sem_submit_info =memdup(in[i].pSignalSemaphoreInfos,
+                                              in[i].signalSemaphoreInfoCount,
+                                              sizeof(out[i].pSignalSemaphoreInfos[0]));
+        for (k = 0; k < out[i].signalSemaphoreInfoCount; k++)
+        {
+            if (sem_submit_info[k].pNext)
+            {
+                FIXME("pNext chain conversion for VkSemaphoreSubmitInfo not supported.\n");
+                sem_submit_info[k].pNext = NULL;
+            }
+        }
+
+        convert_VkSubmitInfo2_struct_chain(in[i].pNext, &out[i]);
+    }
+
+    return out;
+}
+
+static void free_copied_VkSubmitInfo2(VkSubmitInfo2 *info, uint32_t submit_count)
+{
+    unsigned int i;
+
+    for (i = 0; i < submit_count; i++)
+    {
+        free_VkSubmitInfo2_struct_chain(&info[i]);
+
+        free((VkSemaphoreSubmitInfo  *)    info[i].pWaitSemaphoreInfos);
+        free((VkCommandBufferSubmitInfo *) info[i].pCommandBufferInfos);
+        free((VkSemaphoreSubmitInfo *)     info[i].pSignalSemaphoreInfos);
+    }
+
+    free(info);
+}
+
+struct queue_submit_unit
+{
+    uint32_t submit_count;
+    VkSubmitInfo *submits;
+    VkSubmitInfo2 *submits2;
+    VkFence fence;
+    bool khr;
+
+    struct pending_wait **waits;
+
+    struct list entry;
+};
+
+/* Abstracts away the differences between VkSubmitInfo and VkSubmitInfo2. */
+static bool for_each_d3d12_semaphore(struct queue_submit_unit *unit, bool signal,
+                                     struct wine_semaphore **semaphore_out, uint64_t **value_out, uint32_t counter)
+{
+    VkTimelineSemaphoreSubmitInfo *timeline_values;
+    struct wine_semaphore *semaphore;
+    unsigned int i, j, k;
+    uint32_t sem_count;
+
+    for (i = 0, k = 0; i < unit->submit_count; i++)
+    {
+        if (unit->submits)
+        {
+            timeline_values = wine_vk_find_struct(&unit->submits[i], TIMELINE_SEMAPHORE_SUBMIT_INFO);
+
+            if (signal)
+                sem_count = unit->submits[i].signalSemaphoreCount;
+            else
+                sem_count = unit->submits[i].waitSemaphoreCount;
+
+            for (j = 0; j < sem_count; j++)
+            {
+                if (signal)
+                    semaphore = wine_semaphore_from_handle(unit->submits[i].pSignalSemaphores[j]);
+                else
+                    semaphore = wine_semaphore_from_handle(unit->submits[i].pWaitSemaphores[j]);
+
+                if (semaphore->handle_type != VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+                    continue;
+
+                if (k++ == counter)
+                {
+                    *semaphore_out = semaphore;
+                    if (signal)
+                        *value_out = (uint64_t *) &timeline_values->pSignalSemaphoreValues[j];
+                    else
+                        *value_out = (uint64_t *) &timeline_values->pWaitSemaphoreValues[j];
+                    return true;
+                }
+            }
+        }
+        else
+        {
+            if (signal)
+                sem_count = unit->submits2[i].signalSemaphoreInfoCount;
+            else
+                sem_count = unit->submits2[i].waitSemaphoreInfoCount;
+
+            for (j = 0; j < sem_count; j++)
+            {
+                if (signal)
+                    semaphore = wine_semaphore_from_handle(unit->submits2[i].pSignalSemaphoreInfos[j].semaphore);
+                else
+                    semaphore = wine_semaphore_from_handle(unit->submits2[i].pWaitSemaphoreInfos[j].semaphore);
+
+                if (semaphore->handle_type != VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+                    continue;
+
+                if (k++ == counter)
+                {
+                    *semaphore_out = semaphore;
+                    if (signal)
+                        *value_out = (uint64_t *) &unit->submits2[i].pSignalSemaphoreInfos[j].value;
+                    else
+                        *value_out = (uint64_t *) &unit->submits2[i].pWaitSemaphoreInfos[j].value;
+                    return true;
+                }
+            }
+        }
+    }
+
+    return false;
+}
+
+static void *virtual_queue_worker(void *arg)
+{
+    struct VkQueue_T *queue = (struct VkQueue_T *)arg;
+    struct queue_submit_unit *submit_unit;
+    struct signal_op *signal_op;
+    struct wine_semaphore *sem;
+    struct pending_wait *wait;
+    struct wine_fence *fence;
+    bool device_lost = false;
+    uint64_t *timeline_value;
+    unsigned int i;
+    VkResult vr;
+
+    for (;;)
+    {
+        pthread_mutex_lock(&queue->submissions_mutex);
+
+        while (!queue->stop && list_empty(&queue->submissions))
+            pthread_cond_wait(&queue->submissions_cond, &queue->submissions_mutex);
+
+        if (queue->stop)
+        {
+            assert( list_empty(&queue->submissions) );
+            pthread_mutex_unlock(&queue->submissions_mutex);
+            return NULL;
+        }
+
+        submit_unit = LIST_ENTRY(list_head(&queue->submissions), struct queue_submit_unit, entry);
+        list_remove(&submit_unit->entry);
+
+        pthread_mutex_unlock(&queue->submissions_mutex);
+
+        if (device_lost)
+            goto free_submit_unit;
+
+        /* Wait for all fences to have a pending signal */
+        for (i = 0; for_each_d3d12_semaphore(submit_unit, false, &sem, &timeline_value, i); i++)
+        {
+            if ((wait = submit_unit->waits[i++]))
+            {
+                assert(wait);
+                d3d12_semaphore_lock(sem);
+
+                while (!wait->satisfied)
+                    pthread_cond_wait(&wait->cond, &sem->d3d12_fence_shm->mutex);
+
+                *timeline_value = d3d12_semaphore_pop_wait_locked(sem, wait);
+
+                d3d12_semaphore_unlock(sem);
+            }
+        }
+
+        for (i = 0; for_each_d3d12_semaphore(submit_unit, true, &sem, &timeline_value, i); i++)
+        {
+            d3d12_semaphore_lock(sem);
+
+            *timeline_value = d3d12_semaphore_add_pending_signal_locked(sem, *timeline_value, queue);
+        }
+
+        if (submit_unit->submits)
+            vr = thunk_vkQueueSubmit(queue, submit_unit->submit_count, submit_unit->submits, submit_unit->fence);
+        else
+        {
+            if (submit_unit->khr)
+                vr = thunk_vkQueueSubmit2KHR(queue, submit_unit->submit_count, submit_unit->submits2, submit_unit->fence);
+            else
+                vr = thunk_vkQueueSubmit2(queue, submit_unit->submit_count, submit_unit->submits2, submit_unit->fence);
+        }
+
+        pthread_mutex_lock(&queue->signaller_mutex);
+
+        for (i = 0; for_each_d3d12_semaphore(submit_unit, true, &sem, &timeline_value, i); i++)
+        {
+            if (vr == VK_SUCCESS)
+            {
+                struct pending_update added_signal = d3d12_semaphore_peek_added_signal_locked(sem);
+                d3d12_semaphore_satisfy_waits_locked(sem, added_signal.virtual_value, added_signal.physical_value);
+
+                signal_op = malloc(sizeof(*signal_op));
+                signal_op->signal_type = SIGNAL_TYPE_SEMAPHORE;
+                signal_op->semaphore.obj = sem;
+                signal_op->semaphore.phys_val = added_signal.physical_value;
+                signal_op->semaphore.khr = submit_unit->khr;
+
+                list_add_tail(&queue->signal_ops, &signal_op->entry);
+            }
+            else
+            {
+                d3d12_semaphore_pop_pending_signal_locked(sem, *timeline_value, NULL);
+            }
+
+            d3d12_semaphore_unlock(sem);
+        }
+
+        if (vr == VK_SUCCESS && (fence = wine_fence_from_handle(submit_unit->fence)))
+        {
+            signal_op = malloc(sizeof(*signal_op));
+            signal_op->signal_type = SIGNAL_TYPE_FENCE;
+            signal_op->fence = fence;
+
+            list_add_tail(&queue->signal_ops, &signal_op->entry);
+        }
+
+        pthread_cond_signal(&queue->signaller_cond);
+        pthread_mutex_unlock(&queue->signaller_mutex);
+
+        if (vr != VK_SUCCESS)
+        {
+            fprintf(stderr, "winevulkan/virtual_queue_worker: queue submission failed with %d, treating as DEVICE_LOST.\n", vr);
+            pthread_mutex_lock(&queue->submissions_mutex);
+            queue->device_lost = device_lost = true;
+            pthread_mutex_unlock(&queue->submissions_mutex);
+
+            if ((fence = wine_fence_from_handle(submit_unit->fence)))
+            {
+                uint64_t buf = 1;
+                assert( write(fence->eventfd, &buf, sizeof(buf)) != -1 );
+            }
+        }
+
+free_submit_unit:
+        if (submit_unit->submits)
+            free_copied_VkSubmitInfo(submit_unit->submits, submit_unit->submit_count);
+        else
+            free_copied_VkSubmitInfo2(submit_unit->submits2, submit_unit->submit_count);
+        free(submit_unit->waits);
+        free(submit_unit);
+
+        pthread_mutex_lock(&queue->submissions_mutex);
+        if (list_empty(&queue->submissions))
+        {
+            queue->processing = false;
+        }
+        pthread_cond_signal(&queue->submissions_cond);
+        pthread_mutex_unlock(&queue->submissions_mutex);
+    }
+
+    return NULL;
+}
+
+static void init_virtual_queue(struct VkQueue_T *queue)
+{
+    if (is_virtual_queue(queue))
+        return;
+
+    pthread_mutex_lock(&queue->submissions_mutex);
+
+    if (queue->virtual_queue)
+    {
+        pthread_mutex_unlock(&queue->submissions_mutex);
+        return;
+    }
+
+    __atomic_store_n(&queue->virtual_queue, 1, __ATOMIC_RELEASE);
+
+    pthread_create(&queue->virtual_queue_thread, NULL, virtual_queue_worker, queue);
+    pthread_create(&queue->signal_thread, NULL, queue_signaller_worker, queue);
+
+    queue->virtual_queue = true;
+
+    pthread_mutex_unlock(&queue->submissions_mutex);
+}
+
+static NTSTATUS virtual_queue_submit(struct VkQueue_T *queue, uint32_t submit_count, const VkSubmitInfo *submits, VkFence fence)
+{
+    VkTimelineSemaphoreSubmitInfo *timeline_submit_info, *host_timeline_values;
+    VkD3D12FenceSubmitInfoKHR *d3d12_submit_info;
+    struct queue_submit_unit *submit_unit;
+    struct wine_semaphore *sem;
+    unsigned int i, j, k;
+    uint64_t wait_value;
+    bool device_lost;
+
+    init_virtual_queue(queue);
+
+    pthread_mutex_lock(&queue->submissions_mutex);
+    device_lost = queue->device_lost;
+    pthread_mutex_unlock(&queue->submissions_mutex);
+    if (device_lost)
+        return VK_ERROR_DEVICE_LOST;
+
+    submit_unit = malloc(sizeof(*submit_unit));
+    submit_unit->submit_count = submit_count;
+    submit_unit->submits = copy_VkSubmitInfo(submits, submit_count);
+    submit_unit->submits2 = NULL;
+    submit_unit->fence = fence;
+    submit_unit->waits = NULL;
+    submit_unit->khr = queue->device->phys_dev->api_version < VK_API_VERSION_1_2 ||
+                       queue->device->phys_dev->instance->api_version < VK_API_VERSION_1_2;
+
+    /* As D3D12 fences are rewindable, we add the wait synchronously as not to miss a temporarily signalled value
+     between vkQueueSubmit and processing the submit unit*/
+    for (i = 0, k = 0; i < submit_count; i++)
+    {
+        timeline_submit_info = wine_vk_find_struct(&submits[i], TIMELINE_SEMAPHORE_SUBMIT_INFO);
+        d3d12_submit_info = wine_vk_find_struct(&submits[i], D3D12_FENCE_SUBMIT_INFO_KHR);
+
+        host_timeline_values = wine_vk_find_struct(&submit_unit->submits[i], TIMELINE_SEMAPHORE_SUBMIT_INFO);
+
+        if (d3d12_submit_info && !host_timeline_values)
+        {
+            host_timeline_values = malloc(sizeof(*host_timeline_values));
+
+            host_timeline_values->sType = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO;
+            host_timeline_values->pNext = submit_unit->submits[i].pNext;
+            host_timeline_values->waitSemaphoreValueCount = d3d12_submit_info->waitSemaphoreValuesCount;
+            host_timeline_values->pWaitSemaphoreValues =
+                    memdup(d3d12_submit_info->pWaitSemaphoreValues, d3d12_submit_info->waitSemaphoreValuesCount,
+                        sizeof(host_timeline_values->pWaitSemaphoreValues[0]));
+            host_timeline_values->signalSemaphoreValueCount = d3d12_submit_info->signalSemaphoreValuesCount;
+            host_timeline_values->pSignalSemaphoreValues =
+                    memdup(d3d12_submit_info->pSignalSemaphoreValues, d3d12_submit_info->signalSemaphoreValuesCount,
+                        sizeof(host_timeline_values->pSignalSemaphoreValues[0]));
+
+            submit_unit->submits[i].pNext = host_timeline_values;
+        }
+
+        for (j = 0; j < submits[i].waitSemaphoreCount; j++)
+        {
+            sem = wine_semaphore_from_handle(submits[i].pWaitSemaphores[j]);
+
+            if (sem->handle_type != VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+                continue;
+
+            if (timeline_submit_info)
+                wait_value = timeline_submit_info->pWaitSemaphoreValues[j];
+            else
+                wait_value = d3d12_submit_info->pWaitSemaphoreValues[j];
+
+            submit_unit->waits = realloc(submit_unit->waits, (k + 1) * sizeof(*submit_unit->waits));
+            submit_unit->waits[k] = NULL;
+
+            d3d12_semaphore_lock(sem);
+
+            if ((((uint64_t*)host_timeline_values->pWaitSemaphoreValues)[j] =
+                                d3d12_semaphore_try_get_wait_value_locked(sem, wait_value, queue)) == -1)
+                submit_unit->waits[k] = d3d12_semaphore_push_wait_locked(sem, wait_value);
+
+            d3d12_semaphore_unlock(sem);
+            k++;
+        }
+    }
+
+    pthread_mutex_lock(&queue->submissions_mutex);
+    queue->processing = true;
+    if (fence)
+    {
+        wine_fence_from_handle(fence)->queue = queue;
+        wine_fence_from_handle(fence)->wait_assist = true;
+    }
+    list_add_tail(&queue->submissions, &submit_unit->entry);
+    pthread_cond_signal(&queue->submissions_cond);
+    pthread_mutex_unlock(&queue->submissions_mutex);
+
+    return VK_SUCCESS;
+}
+
+NTSTATUS wine_vkQueueSubmit(void *args)
+{
+    struct vkQueueSubmit_params *params = args;
+    VkQueue queue = params->queue;
+    uint32_t submit_count = params->submitCount;
+    const VkSubmitInfo *submits = params->pSubmits;
+    VkFence fence = params->fence;
+
+    unsigned int i, k;
+
+    TRACE("(%p %u %p 0x%s)\n", queue, submit_count, submits, wine_dbgstr_longlong(fence));
+
+    if (is_virtual_queue(queue))
+        return virtual_queue_submit(queue, submit_count, submits, fence);
+
+    for (i = 0; i < submit_count; i++)
+    {
+        if (wine_vk_find_struct(&submits[i], WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR))
+            FIXME("VkWin32KeyedMutexAcquireReleaseInfoKHR structure unhandled.\n");
+
+        for (k = 0; k < submits[i].waitSemaphoreCount; k++)
+        {
+            if (wine_semaphore_from_handle(submits[i].pWaitSemaphores[k])->handle_type ==
+                    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+                return virtual_queue_submit(queue, submit_count, submits, fence);
+        }
+
+        for (k = 0; k < submits[i].signalSemaphoreCount; k++)
+        {
+            if (wine_semaphore_from_handle(submits[i].pSignalSemaphores[k])->handle_type ==
+                    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+                return virtual_queue_submit(queue, submit_count, submits, fence);
+        }
+    }
+
+    if (fence)
+        wine_fence_from_handle(fence)->queue = queue;
+
+    return thunk_vkQueueSubmit(queue, submit_count, submits, fence);
+}
+
+static NTSTATUS virtual_queue_submit2(struct VkQueue_T *queue, uint32_t submit_count, const VkSubmitInfo2 *submits, VkFence fence, bool khr)
+{
+    VkSemaphoreSubmitInfo *sem_submit_info;
+    struct queue_submit_unit *submit_unit;
+    VkSubmitInfo2 *queue_submit;
+    struct wine_semaphore *sem;
+    unsigned int i, j, k;
+    uint64_t wait_value;
+    bool device_lost;
+
+    init_virtual_queue(queue);
+
+    pthread_mutex_lock(&queue->submissions_mutex);
+    device_lost = queue->device_lost;
+    pthread_mutex_unlock(&queue->submissions_mutex);
+    if (device_lost)
+        return VK_ERROR_DEVICE_LOST;
+
+    submit_unit = malloc(sizeof(*submit_unit));
+    submit_unit->submit_count = submit_count;
+    submit_unit->submits = NULL;
+    submit_unit->submits2 = copy_VkSubmitInfo2(submits, submit_count);
+    submit_unit->fence = fence;
+    submit_unit->waits = NULL;
+    submit_unit->khr = khr;
+
+    /* As D3D12 fences are rewindable, we add the wait synchronously as not to miss a temporarily signalled value
+     between vkQueueSubmit and processing the submit unit */
+    for (i = 0, k = 0; i < submit_count; i++)
+    {
+        queue_submit = &submit_unit->submits2[i];
+
+        for (j = 0; j < queue_submit->waitSemaphoreInfoCount; j++)
+        {
+            sem_submit_info = (VkSemaphoreSubmitInfo *) &queue_submit->pWaitSemaphoreInfos[j];
+            sem = wine_semaphore_from_handle(sem_submit_info->semaphore);
+
+            if (sem->handle_type != VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+                continue;
+
+            wait_value = sem_submit_info->value;
+
+            submit_unit->waits = realloc(submit_unit->waits, (k + 1) * sizeof(*submit_unit->waits));
+            submit_unit->waits[k] = NULL;
+
+            d3d12_semaphore_lock(sem);
+
+            if ((sem_submit_info->value =
+                                d3d12_semaphore_try_get_wait_value_locked(sem, wait_value, queue)) == -1)
+                submit_unit->waits[k] = d3d12_semaphore_push_wait_locked(sem, wait_value);
+
+            d3d12_semaphore_unlock(sem);
+            k++;
+        }
+    }
+
+    pthread_mutex_lock(&queue->submissions_mutex);
+    queue->processing = true;
+    if (fence)
+    {
+        wine_fence_from_handle(fence)->queue = queue;
+        wine_fence_from_handle(fence)->wait_assist = true;
+    }
+    list_add_tail(&queue->submissions, &submit_unit->entry);
+    pthread_cond_signal(&queue->submissions_cond);
+    pthread_mutex_unlock(&queue->submissions_mutex);
+
+    return VK_SUCCESS;
+}
+
+static NTSTATUS vk_queue_submit_2(VkQueue queue, uint32_t submit_count, const VkSubmitInfo2 *submits, VkFence fence, bool khr)
+{
+    unsigned int i, k;
+
+    TRACE("(%p, %u, %p, %s)\n", queue, submit_count, submits, wine_dbgstr_longlong(fence));
+
+    if (is_virtual_queue(queue))
+        return virtual_queue_submit2(queue, submit_count, submits, fence, khr);
+
+    for (i = 0; i < submit_count; i++)
+    {
+        if (wine_vk_find_struct(&submits[i], WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR))
+            FIXME("VkWin32KeyedMutexAcquireReleaseInfoKHR structure unhandled.\n");
+
+        for (k = 0; k < submits[i].waitSemaphoreInfoCount; k++)
+        {
+            if (wine_semaphore_from_handle(submits[i].pWaitSemaphoreInfos[k].semaphore)->handle_type ==
+                    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+                return virtual_queue_submit2(queue, submit_count, submits, fence, khr);
+        }
+
+        for (k = 0; k < submits[i].signalSemaphoreInfoCount; k++)
+        {
+            if (wine_semaphore_from_handle(submits[i].pSignalSemaphoreInfos[k].semaphore)->handle_type ==
+                    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+                return virtual_queue_submit2(queue, submit_count, submits, fence, khr);
+        }
+    }
+
+    if (fence)
+        wine_fence_from_handle(fence)->queue = queue;
+
+    if (khr)
+        return thunk_vkQueueSubmit2KHR(queue, submit_count, submits, fence);
+    else
+        return thunk_vkQueueSubmit2(queue, submit_count, submits, fence);
+}
+
+NTSTATUS wine_vkQueueSubmit2(void *args)
+{
+    struct vkQueueSubmit2_params *params = args;
+    VkQueue queue = params->queue;
+    uint32_t submit_count = params->submitCount;
+    const VkSubmitInfo2 *submits = params->pSubmits;
+    VkFence fence = params->fence;
+
+    return vk_queue_submit_2(queue, submit_count, submits, fence, false);
+}
+
+NTSTATUS wine_vkQueueSubmit2KHR(void *args)
+{
+    struct vkQueueSubmit2_params *params = args;
+    VkQueue queue = params->queue;
+    uint32_t submit_count = params->submitCount;
+    const VkSubmitInfo2 *submits = params->pSubmits;
+    VkFence fence = params->fence;
+
+    return vk_queue_submit_2(queue, submit_count, submits, fence, true);
+}
+
+static inline VkSemaphore *convert_VkSemaphore_array_win_to_host(const VkSemaphore *in, uint32_t count)
+{
+    VkSemaphore *out;
+    unsigned int i;
+
+    if (!in || !count) return NULL;
+
+    out = malloc(count * sizeof(*out));
+    for (i = 0; i < count; i++)
+    {
+        out[i] = in[i] ? wine_semaphore_from_handle(in[i])->semaphore : VK_NULL_HANDLE;
+    }
+
+    return out;
+}
+
+static inline void free_VkSemaphore_array(VkSemaphore *in, uint32_t count)
+{
+    if (!in) return;
+
+    free(in);
+}
+
+NTSTATUS wine_vkQueuePresentKHR(void *args)
+{
+    struct vkQueuePresentKHR_params *params = args;
+    VkQueue queue = params->queue;
+    const VkPresentInfoKHR *present_info = params->pPresentInfo;
+
+    VkPresentInfoKHR host_present_info = *present_info;
+    struct wine_semaphore *semaphore;
+    VkSemaphore *host_semaphores;
+    unsigned int i;
+    VkResult vr;
+
+    TRACE("%p %p\n", queue, present_info);
+
+    for (i = 0; i < present_info->waitSemaphoreCount; i++)
+    {
+        semaphore = wine_semaphore_from_handle(present_info->pWaitSemaphores[i]);
+
+        if (semaphore->handle_type == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+        {
+            FIXME("Waiting on D3D12-Fence compatible timeline semaphore not supported.\n");
+            return VK_ERROR_OUT_OF_HOST_MEMORY;
+        }
+    }
+
+    if (is_virtual_queue(queue))
+    {
+        pthread_mutex_lock(&queue->submissions_mutex);
+        while (queue->processing)
+            pthread_cond_wait(&queue->submissions_cond, &queue->submissions_mutex);
+        pthread_mutex_unlock(&queue->submissions_mutex);
+    }
+
+    host_present_info.pWaitSemaphores = host_semaphores = convert_VkSemaphore_array_win_to_host(present_info->pWaitSemaphores, present_info->waitSemaphoreCount);
+    vr = fshack_vk_queue_present(queue, &host_present_info);
+    free_VkSemaphore_array(host_semaphores, present_info->waitSemaphoreCount);
+    return vr;
+}
+
+NTSTATUS wine_vkQueueBindSparse(void *args)
+{
+    struct vkQueueBindSparse_params *params = args;
+    VkQueue queue = params->queue;
+    uint32_t bind_info_count = params->bindInfoCount;
+    const VkBindSparseInfo *bind_info = params->pBindInfo;
+    VkFence fence = params->fence;
+
+    struct wine_semaphore *semaphore;
+    const VkBindSparseInfo *batch;
+    unsigned int i, k;
+
+    TRACE("(%p, %u, %p, 0x%s)\n", queue, bind_info_count, bind_info, wine_dbgstr_longlong(fence));
+
+    if (is_virtual_queue(queue))
+    {
+        FIXME("Can't process sparse bind calls on virtual queue, flushing.\n");
+        pthread_mutex_lock(&queue->submissions_mutex);
+        while (queue->processing)
+            pthread_cond_wait(&queue->submissions_cond, &queue->submissions_mutex);
+        pthread_mutex_unlock(&queue->submissions_mutex);
+    }
+
+    for (i = 0; i < bind_info_count; i++)
+    {
+        batch = &bind_info[i];
+
+        for (k = 0; k < batch->waitSemaphoreCount; k++)
+        {
+            semaphore = wine_semaphore_from_handle(batch->pWaitSemaphores[k]);
+
+            if (semaphore->handle_type == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+            {
+                FIXME("Waiting on D3D12-Fence compatible timeline semaphore not supported.\n");
+                return VK_ERROR_OUT_OF_HOST_MEMORY;
+            }
+        }
+
+        for(k = 0; k < batch->signalSemaphoreCount; k++)
+        {
+            semaphore = wine_semaphore_from_handle(batch->pSignalSemaphores[k]);
+
+            if (semaphore->handle_type == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+            {
+                FIXME("Signalling D3D12-Fence compatible timeline semaphore not supported.\n");
+                return VK_ERROR_OUT_OF_HOST_MEMORY;
+            }
+        }
+    }
+
+    return thunk_vkQueueBindSparse(queue, bind_info_count, bind_info, fence);
+}
+
+NTSTATUS wine_vkCreateFence(void *args)
+{
+    struct vkCreateFence_params *params = args;
+    VkDevice device = params->device;
+    const VkFenceCreateInfo *create_info = params->pCreateInfo;
+    const VkAllocationCallbacks *allocator = params->pAllocator;
+    VkFence *fence = params->pFence;
+
+    struct wine_fence *object;
+    VkResult vr;
+
+    TRACE("(%p, %p, %p, %p)\n", device, create_info, allocator, fence);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    if (!(object = calloc(1, sizeof(*object))))
+        return VK_ERROR_OUT_OF_HOST_MEMORY;
+
+    if ((object->eventfd = eventfd(0, EFD_CLOEXEC)) == -1)
+        ERR("Failed to create eventfd for fence.\n");
+
+    if ((vr = device->funcs.p_vkCreateFence(device->device, create_info, allocator, &object->fence)) == VK_SUCCESS)
+        *fence = wine_fence_to_handle(object);
+    else
+        free(object);
+
+    return vr;
+}
+
+NTSTATUS wine_vkDestroyFence(void *args)
+{
+    struct vkDestroyFence_params *params = args;
+    VkDevice device = params->device;
+    VkFence handle = params->fence;
+    const VkAllocationCallbacks *allocator = params->pAllocator;
+
+    struct wine_fence *fence = wine_fence_from_handle(handle);
+
+    TRACE("(%p, %p, %p)\n", device, fence, allocator);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    if (fence->eventfd != -1)
+        close(fence->eventfd);
+
+    device->funcs.p_vkDestroyFence(device->device, fence->fence, allocator);
+    free(fence);
+
+    return STATUS_SUCCESS;
+}
+
+NTSTATUS wine_vkResetFences(void *args)
+{
+    struct vkResetFences_params *params = args;
+    VkDevice device = params->device;
+    uint32_t fence_count = params->fenceCount;
+    const VkFence *fences = params->pFences;
+
+    struct wine_fence *fence;
+    unsigned int i;
+    uint64_t buf;
+    VkResult vr;
+
+    TRACE("(%p, %u, %p)\n", device, fence_count, fences);
+
+    if ((vr = thunk_vkResetFences(device, fence_count, fences)) != VK_SUCCESS)
+        return vr;
+
+    for (i = 0; i < fence_count; i++)
+    {
+        fence = wine_fence_from_handle(fences[i]);
+
+        fence->queue = NULL;
+        fence->swapchain = NULL;
+        if (fence->wait_assist)
+        {
+            fence->wait_assist = false;
+            if (read(fence->eventfd, &buf, sizeof(buf)) == -1)
+                ERR("Failed to reset event fd.\n");
+        }
+    }
+
+    return VK_SUCCESS;
+}
+
+NTSTATUS wine_vkWaitForFences(void *args)
+{
+    struct vkWaitForFences_params *params = args;
+    VkDevice device = params->device;
+    uint32_t fence_count = params->fenceCount;
+    const VkFence *fences = params->pFences;
+    VkBool32 wait_all = params->waitAll;
+    uint64_t timeout = params->timeout;
+
+    struct signal_op *signal_op;
+    bool assisted_wait = false;
+    struct wine_fence *fence;
+    struct pollfd *wait_fds;
+    struct pollfd wait_fd;
+    unsigned int i;
+    VkResult vr;
+    int ret;
+
+    TRACE("(%p, %u, %p, %u, 0x%s)\n", device, fence_count, fences, wait_all, wine_dbgstr_longlong(timeout));
+
+    for (i = 0; i < fence_count; i++)
+    {
+        fence = wine_fence_from_handle(fences[i]);
+        if (!fence->wait_assist)
+            continue;
+
+        if (!wait_all && fence_count > 1)
+        {
+            assisted_wait = true;
+            break;
+        }
+
+        wait_fd.fd = fence->eventfd;
+        wait_fd.events = POLLIN;
+        ret = poll(&wait_fd, 1, timeout / 1000000);
+        if (ret == -1)
+        {
+            ERR("Failed to poll wait assisted fence.\n");
+            return VK_ERROR_OUT_OF_HOST_MEMORY;
+        }
+        if (!ret)
+            return VK_TIMEOUT;
+
+        if (wait_fd.revents & (POLLERR | POLLHUP | POLLNVAL))
+            ERR("Polling on fd %d returned %#x.", fence->eventfd, wait_fd.revents);
+        return VK_SUCCESS;
+    }
+
+    if (assisted_wait)
+    {
+        /* Turn all non assisted waits into assisted waits, then poll on all */
+        wait_fds = malloc( sizeof(wait_fds[0]) * fence_count );
+
+        for (i = 0; i < fence_count; i++)
+        {
+            if (!fence->wait_assist)
+            {
+                assert(fence->queue || fence->swapchain);
+
+                if (fence->queue)
+                {
+                    fence->wait_assist = true;
+
+                    /* If virtual-queue requiring work was submitted after the work signalling this mutex,
+                     * we will end up unnecessarily waiting on that work first,
+                     * but this will only happen once per queue */
+                    init_virtual_queue(fence->queue);
+
+                    signal_op = malloc(sizeof(*signal_op));
+                    signal_op->signal_type = SIGNAL_TYPE_FENCE;
+                    signal_op->fence = fence;
+
+                    pthread_mutex_lock(&fence->queue->signaller_mutex);
+                    list_add_tail(&fence->queue->signal_ops, &signal_op->entry);
+                    pthread_cond_signal(&fence->queue->signaller_cond);
+                    pthread_mutex_unlock(&fence->queue->signaller_mutex);
+                }
+                else
+                {
+                    FIXME("Wait assist for swapchain signaled fences not supported.\n");
+                    free(wait_fds);
+                    return VK_ERROR_OUT_OF_HOST_MEMORY;
+                }
+            }
+
+            wait_fds[i].fd = fence->eventfd;
+            wait_fds[i].events = POLLIN;
+        }
+
+        if (poll(wait_fds, fence_count, timeout / 1000000) == -1)
+        {
+            ERR("Failed to poll wait assisted fences.\n");
+            vr = VK_ERROR_OUT_OF_HOST_MEMORY;
+        }
+
+        free(wait_fds);
+    }
+    else
+    {
+        vr = thunk_vkWaitForFences(device, fence_count, fences, wait_all, timeout);
+    }
+
+    return vr;
+}
+
+NTSTATUS wine_vkQueueWaitIdle(void *args)
+{
+    struct vkQueueWaitIdle_params *params = args;
+    VkQueue queue = params->queue;
+
+    TRACE("(%p)\n", queue);
+
+    if (is_virtual_queue(queue))
+    {
+        pthread_mutex_lock(&queue->submissions_mutex);
+        while (queue->processing)
+            pthread_cond_wait(&queue->submissions_cond, &queue->submissions_mutex);
+        pthread_mutex_unlock(&queue->submissions_mutex);
+    }
+
+    return queue->device->funcs.p_vkQueueWaitIdle(queue->queue);
 }
diff --git a/dlls/winevulkan/vulkan_loader.h b/dlls/winevulkan/vulkan_loader.h
index 275242657e3..10281bbc01f 100644
--- a/dlls/winevulkan/vulkan_loader.h
+++ b/dlls/winevulkan/vulkan_loader.h
@@ -42,6 +42,8 @@
 #define WINEVULKAN_QUIRK_GET_DEVICE_PROC_ADDR 0x00000001
 #define WINEVULKAN_QUIRK_ADJUST_MAX_IMAGE_COUNT 0x00000002
 #define WINEVULKAN_QUIRK_IGNORE_EXPLICIT_LAYERS 0x00000004
+#define WINEVULKAN_QUIRK_EXPOSE_MEM_PRIORITY 0x00000008
+#define WINEVULKAN_QUIRK_EXPOSE_KEYED_MUTEX 0x00000010
 
 /* Base 'class' for our Vulkan dispatchable objects such as VkDevice and VkInstance.
  * This structure MUST be the first element of a dispatchable object as the ICD
diff --git a/dlls/winevulkan/vulkan_private.h b/dlls/winevulkan/vulkan_private.h
index 88a87dd4317..4585a24bdcd 100644
--- a/dlls/winevulkan/vulkan_private.h
+++ b/dlls/winevulkan/vulkan_private.h
@@ -27,6 +27,7 @@
 #define VK_NO_PROTOTYPES
 
 #include <pthread.h>
+#include <stdbool.h>
 
 #include "wine/list.h"
 
@@ -124,6 +125,8 @@ struct VkInstance_T
     struct vulkan_instance_funcs funcs;
     VkInstance instance; /* native instance */
 
+    uint32_t api_version;
+
     /* We cache devices as we need to wrap them as they are
      * dispatchable objects.
      */
@@ -150,9 +153,13 @@ struct VkPhysicalDevice_T
     struct VkInstance_T *instance; /* parent */
     VkPhysicalDevice phys_dev; /* native physical device */
 
+    uint32_t api_version;
+
     VkExtensionProperties *extensions;
     uint32_t extension_count;
 
+    bool fake_memory_priority;
+
     struct wine_vk_mapping mapping;
 };
 
@@ -166,6 +173,22 @@ struct VkQueue_T
     uint32_t queue_index;
     VkDeviceQueueCreateFlags flags;
 
+    bool virtual_queue;
+    bool processing;
+    bool device_lost;
+
+    pthread_t virtual_queue_thread;
+    pthread_mutex_t submissions_mutex;
+    pthread_cond_t submissions_cond;
+    struct list submissions;
+
+    pthread_t signal_thread;
+    pthread_mutex_t signaller_mutex;
+    pthread_cond_t signaller_cond;
+    struct list signal_ops;
+
+    bool stop;
+
     struct wine_vk_mapping mapping;
 };
 
@@ -266,6 +289,79 @@ static inline VkDeviceMemory wine_dev_mem_to_handle(struct wine_dev_mem *dev_mem
     return (VkDeviceMemory)(uintptr_t)dev_mem;
 }
 
+struct wine_semaphore
+{
+    VkSemaphore semaphore;
+    VkSemaphore fence_timeline_semaphore;
+
+    VkExternalSemaphoreHandleTypeFlagBits export_types;
+
+    struct wine_vk_mapping mapping;
+
+    /* mutable members */
+    VkExternalSemaphoreHandleTypeFlagBits handle_type;
+    HANDLE handle;
+    struct
+    {
+        pthread_mutex_t mutex;
+        uint64_t virtual_value, physical_value, counter;
+
+        struct pending_wait
+        {
+            bool present, satisfied;
+            uint64_t virtual_value;
+            uint64_t physical_value;
+            pthread_cond_t cond;
+        } pending_waits[100];
+
+        struct pending_update
+        {
+            uint64_t virtual_value;
+            uint64_t physical_value;
+            pid_t signalling_pid;
+            struct VkQueue_T *signalling_queue;
+        } pending_updates[100];
+        uint32_t pending_updates_count;
+    } *d3d12_fence_shm;
+};
+
+static inline struct wine_semaphore *wine_semaphore_from_handle(VkSemaphore handle)
+{
+    return (struct wine_semaphore *)(uintptr_t)handle;
+}
+
+static inline VkSemaphore wine_semaphore_to_handle(struct wine_semaphore *semaphore)
+{
+    return (VkSemaphore)(uintptr_t)semaphore;
+}
+
+static inline VkSemaphore wine_semaphore_host_handle(struct wine_semaphore *semaphore)
+{
+    if (semaphore->handle_type == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+        return semaphore->fence_timeline_semaphore;
+    return semaphore->semaphore;
+}
+
+struct wine_fence
+{
+    VkFence fence;
+
+    struct VkQueue_T *queue;
+    struct VkSwapchainKHR_T *swapchain;
+    bool wait_assist;
+    int eventfd;
+};
+
+static inline struct wine_fence *wine_fence_from_handle(VkFence handle)
+{
+    return (struct wine_fence *)(uintptr_t)handle;
+}
+
+static inline VkFence wine_fence_to_handle(struct wine_fence *fence)
+{
+    return (VkFence)(uintptr_t)fence;
+}
+
 BOOL wine_vk_device_extension_supported(const char *name) DECLSPEC_HIDDEN;
 BOOL wine_vk_instance_extension_supported(const char *name) DECLSPEC_HIDDEN;
 
@@ -297,4 +393,16 @@ static inline void init_unicode_string( UNICODE_STRING *str, const WCHAR *data )
     str->Buffer = (WCHAR *)data;
 }
 
+static inline void *memdup(const void *in, size_t number, size_t size)
+{
+    void *out;
+
+    if (!in)
+        return NULL;
+
+    out = malloc(number * size);
+    memcpy(out, in, number * size);
+    return out;
+}
+
 #endif /* __WINE_VULKAN_PRIVATE_H */
-- 
2.37.1

From c3edb990858a5a430427e7dd70aea76ecaaad23a Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Mon, 22 Aug 2022 16:20:23 -0400
Subject: [PATCH] winevulkan: Fix vkWaitSemaphores implementation with 32-bit
 time_t value.

---
 dlls/winevulkan/vulkan.c | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index 1024bf04037..61b74e49b1f 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -30,6 +30,7 @@
 #include <stdio.h>
 #include <assert.h>
 #include <errno.h>
+#include <limits.h>
 #include <poll.h>
 #include <sys/eventfd.h>
 
@@ -4988,6 +4989,7 @@ static NTSTATUS wine_vk_wait_semaphores(VkDevice device, const VkSemaphoreWaitIn
     unsigned int i, remaining_waits;
     VkSemaphore* semaphores_dup;
     uint64_t *values_dup;
+    int64_t tv_sec_wide;
     uint64_t phys_val;
     int wait_stat;
     VkResult res;
@@ -4998,13 +5000,18 @@ static NTSTATUS wine_vk_wait_semaphores(VkDevice device, const VkSemaphoreWaitIn
     {
         clock_gettime(CLOCK_REALTIME, &start_time);
 
-        abs_timeout.tv_sec = start_time.tv_sec + (timeout / NANOSECONDS_IN_A_SECOND);
+        abs_timeout.tv_sec = tv_sec_wide = start_time.tv_sec + (timeout / NANOSECONDS_IN_A_SECOND);
         abs_timeout.tv_nsec = start_time.tv_nsec + (timeout % NANOSECONDS_IN_A_SECOND);
         if (abs_timeout.tv_nsec >= NANOSECONDS_IN_A_SECOND)
         {
             abs_timeout.tv_sec++;
+            tv_sec_wide++;
             abs_timeout.tv_nsec-=NANOSECONDS_IN_A_SECOND;
         }
+
+        /* tv_sec is still! 32-bit on x86 */
+        if (tv_sec_wide > abs_timeout.tv_sec)
+            abs_timeout.tv_sec = INT_MAX;
     }
 
     wait_info_dup.pSemaphores = semaphores_dup = calloc(wait_info->semaphoreCount, sizeof(VkSemaphore));
-- 
2.37.2


From 82270d26980c8f83894994ec9c51cd2dcb8decde Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 18 Oct 2019 11:39:19 +0200
Subject: [PATCH] winex11.drv: Pass XEvent instead of XClientMessageEvent to
 handlers.

This is to avoid a dubious cast from XClientMessageEvent to XEvent in
next patch.
---
 dlls/winex11.drv/event.c  | 20 +++++++++++++-------
 dlls/winex11.drv/x11drv.h |  8 ++++----
 dlls/winex11.drv/xdnd.c   | 11 +++++++----
 3 files changed, 24 insertions(+), 15 deletions(-)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index 4656247b51c..2cb60b7937c 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -639,8 +639,10 @@ static void set_focus( Display *display, HWND hwnd, Time time )
 /**********************************************************************
  *              handle_manager_message
  */
-static void handle_manager_message( HWND hwnd, XClientMessageEvent *event )
+static void handle_manager_message( HWND hwnd, XEvent *xev )
 {
+    XClientMessageEvent *event = &xev->xclient;
+
     if (hwnd != GetDesktopWindow()) return;
     if (systray_atom && event->data.l[1] == systray_atom)
         change_systray_owner( event->display, event->data.l[2] );
@@ -650,8 +652,9 @@ static void handle_manager_message( HWND hwnd, XClientMessageEvent *event )
 /**********************************************************************
  *              handle_wm_protocols
  */
-static void handle_wm_protocols( HWND hwnd, XClientMessageEvent *event )
+static void handle_wm_protocols( HWND hwnd, XEvent *xev )
 {
+    XClientMessageEvent *event = &xev->xclient;
     Atom protocol = (Atom)event->data.l[0];
     Time event_time = (Time)event->data.l[1];

@@ -1699,8 +1702,10 @@ static void EVENT_DropURLs( HWND hWnd, XClientMessageEvent *event )
 /**********************************************************************
  *              handle_xembed_protocol
  */
-static void handle_xembed_protocol( HWND hwnd, XClientMessageEvent *event )
+static void handle_xembed_protocol( HWND hwnd, XEvent *xev )
 {
+    XClientMessageEvent *event = &xev->xclient;
+
     switch (event->data.l[1])
     {
     case XEMBED_EMBEDDED_NOTIFY:
@@ -1755,8 +1760,9 @@ static void handle_xembed_protocol( HWND hwnd, XClientMessageEvent *event )
 /**********************************************************************
  *              handle_dnd_protocol
  */
-static void handle_dnd_protocol( HWND hwnd, XClientMessageEvent *event )
+static void handle_dnd_protocol( HWND hwnd, XEvent *xev )
 {
+    XClientMessageEvent *event = &xev->xclient;
     Window root, child;
     int root_x, root_y, child_x, child_y;
     unsigned int u;
@@ -1775,8 +1781,8 @@ static void handle_dnd_protocol( HWND hwnd, XClientMessageEvent *event )

 struct client_message_handler
 {
-    int    atom;                                  /* protocol atom */
-    void (*handler)(HWND, XClientMessageEvent *); /* corresponding handler function */
+    int    atom;                     /* protocol atom */
+    void (*handler)(HWND, XEvent *); /* corresponding handler function */
 };

 static const struct client_message_handler client_messages[] =
@@ -1812,7 +1818,7 @@ static BOOL X11DRV_ClientMessage( HWND hwnd, XEvent *xev )
     {
         if (event->message_type == X11DRV_Atoms[client_messages[i].atom - FIRST_XATOM])
         {
-            client_messages[i].handler( hwnd, event );
+            client_messages[i].handler( hwnd, xev );
             return TRUE;
         }
     }
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 97311254b91..4054e86f4ee 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -294,10 +294,10 @@ extern BOOL IME_SetCompositionString(DWORD dwIndex, LPCVOID lpComp,
                                      DWORD dwReadLen) DECLSPEC_HIDDEN;
 extern void IME_SetResultString(LPWSTR lpResult, DWORD dwResultlen) DECLSPEC_HIDDEN;

-extern void X11DRV_XDND_EnterEvent( HWND hWnd, XClientMessageEvent *event ) DECLSPEC_HIDDEN;
-extern void X11DRV_XDND_PositionEvent( HWND hWnd, XClientMessageEvent *event ) DECLSPEC_HIDDEN;
-extern void X11DRV_XDND_DropEvent( HWND hWnd, XClientMessageEvent *event ) DECLSPEC_HIDDEN;
-extern void X11DRV_XDND_LeaveEvent( HWND hWnd, XClientMessageEvent *event ) DECLSPEC_HIDDEN;
+extern void X11DRV_XDND_EnterEvent( HWND hWnd, XEvent *xev ) DECLSPEC_HIDDEN;
+extern void X11DRV_XDND_PositionEvent( HWND hWnd, XEvent *xev ) DECLSPEC_HIDDEN;
+extern void X11DRV_XDND_DropEvent( HWND hWnd, XEvent *xev ) DECLSPEC_HIDDEN;
+extern void X11DRV_XDND_LeaveEvent( HWND hWnd, XEvent *xev ) DECLSPEC_HIDDEN;
 extern void X11DRV_CLIPBOARD_ImportSelection( Display *display, Window win, Atom selection,
                                               Atom *targets, UINT count,
                                               void (*callback)( Atom, UINT, HANDLE )) DECLSPEC_HIDDEN;
diff --git a/dlls/winex11.drv/xdnd.c b/dlls/winex11.drv/xdnd.c
index eb685613b7b..2ab5b9157dc 100644
--- a/dlls/winex11.drv/xdnd.c
+++ b/dlls/winex11.drv/xdnd.c
@@ -188,8 +188,9 @@ static long X11DRV_XDND_DROPEFFECTToXdndAction(DWORD effect)
  *
  * Handle an XdndEnter event.
  */
-void X11DRV_XDND_EnterEvent( HWND hWnd, XClientMessageEvent *event )
+void X11DRV_XDND_EnterEvent( HWND hWnd, XEvent *xev )
 {
+    XClientMessageEvent *event = &xev->xclient;
     int version;
     Atom *xdndtypes;
     unsigned long count = 0;
@@ -287,8 +288,9 @@ static HWND window_accepting_files(HWND hwnd)
  *
  * Handle an XdndPosition event.
  */
-void X11DRV_XDND_PositionEvent( HWND hWnd, XClientMessageEvent *event )
+void X11DRV_XDND_PositionEvent( HWND hWnd, XEvent *xev )
 {
+    XClientMessageEvent *event = &xev->xclient;
     XClientMessageEvent e;
     int accept = 0; /* Assume we're not accepting */
     IDropTarget *dropTarget = NULL;
@@ -401,8 +403,9 @@ void X11DRV_XDND_PositionEvent( HWND hWnd, XClientMessageEvent *event )
  *
  * Handle an XdndDrop event.
  */
-void X11DRV_XDND_DropEvent( HWND hWnd, XClientMessageEvent *event )
+void X11DRV_XDND_DropEvent( HWND hWnd, XEvent *xev )
 {
+    XClientMessageEvent *event = &xev->xclient;
     XClientMessageEvent e;
     IDropTarget *dropTarget;
     DWORD effect = XDNDDropEffect;
@@ -493,7 +496,7 @@ void X11DRV_XDND_DropEvent( HWND hWnd, XClientMessageEvent *event )
  *
  * Handle an XdndLeave event.
  */
-void X11DRV_XDND_LeaveEvent( HWND hWnd, XClientMessageEvent *event )
+void X11DRV_XDND_LeaveEvent( HWND hWnd, XEvent *xev )
 {
     IDropTarget *dropTarget;

From 5a06b183da6427149d3ca5677613d10c0429eb8b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 23 Dec 2019 14:38:44 +0100
Subject: [PATCH] winex11.drv: Pass XEvent instead of Display to set_focus.

---
 dlls/winex11.drv/event.c | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index 1ef76d506ed..2e9ff2173cf 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -603,7 +603,7 @@ static void set_input_focus( struct x11drv_win_data *data )
 /**********************************************************************
  *              set_focus
  */
-static void set_focus( Display *display, HWND hwnd, Time time )
+static void set_focus( XEvent *xev, HWND hwnd, Time time )
 {
     HWND focus;
     Window win;
@@ -622,7 +622,7 @@ static void set_focus( Display *display, HWND hwnd, Time time )
     if (win)
     {
         TRACE( "setting focus to %p (%lx) time=%ld\n", focus, win, time );
-        XSetInputFocus( display, win, RevertToParent, time );
+        XSetInputFocus( xev->xany.display, win, RevertToParent, time );
     }
 }

@@ -721,7 +721,7 @@ static void handle_wm_protocols( HWND hwnd, XEvent *xev )
                                        MAKELONG( HTMENU, WM_LBUTTONDOWN ) );
             if (ma != MA_NOACTIVATEANDEAT && ma != MA_NOACTIVATE)
             {
-                set_focus( event->display, hwnd, event_time );
+                set_focus( xev, hwnd, event_time );
                 return;
             }
         }
@@ -730,7 +730,7 @@ static void handle_wm_protocols( HWND hwnd, XEvent *xev )
             hwnd = GetForegroundWindow();
             if (!hwnd) hwnd = last_focus;
             if (!hwnd) hwnd = GetDesktopWindow();
-            set_focus( event->display, hwnd, event_time );
+            set_focus( xev, hwnd, event_time );
             return;
         }
         /* try to find some other window to give the focus to */
@@ -738,7 +738,7 @@ static void handle_wm_protocols( HWND hwnd, XEvent *xev )
         if (hwnd) hwnd = GetAncestor( hwnd, GA_ROOT );
         if (!hwnd) hwnd = GetActiveWindow();
         if (!hwnd) hwnd = last_focus;
-        if (hwnd && can_activate_window(hwnd)) set_focus( event->display, hwnd, event_time );
+        if (hwnd && can_activate_window(hwnd)) set_focus( xev, hwnd, event_time );
     }
     else if (protocol == x11drv_atom(_NET_WM_PING))
     {
@@ -818,7 +818,7 @@ static BOOL X11DRV_FocusIn( HWND hwnd, XEvent *xev )
         if (hwnd) hwnd = GetAncestor( hwnd, GA_ROOT );
         if (!hwnd) hwnd = GetActiveWindow();
         if (!hwnd) hwnd = x11drv_thread_data()->last_focus;
-        if (hwnd && can_activate_window(hwnd)) set_focus( event->display, hwnd, CurrentTime );
+        if (hwnd && can_activate_window(hwnd)) set_focus( xev, hwnd, CurrentTime );
     }
     else SetForegroundWindow( hwnd );
     return TRUE;
From b9dcf02b582ef877ebb85396c64aa7faf2565377 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 7 Oct 2019 12:58:23 +0200
Subject: [PATCH] winex11.drv: Merge FocusIn/FocusOut NotifyGrab/NotifyUngrab
 cases.

The return value was different as well, this makes it consistent. The
switch is also going to go away.
---
 dlls/winex11.drv/event.c | 15 ++++++++++-----
 1 file changed, 10 insertions(+), 5 deletions(-)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index f23cf7e710b..a6e025152ef 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -801,7 +801,7 @@ static BOOL X11DRV_FocusIn( HWND hwnd, XEvent *xev )
     case NotifyGrab:
         /* these are received when moving undecorated managed windows on mutter */
         keyboard_grabbed = TRUE;
-        return FALSE;
+        break;
     case NotifyWhileGrabbed:
         keyboard_grabbed = TRUE;
         break;
@@ -811,9 +811,12 @@ static BOOL X11DRV_FocusIn( HWND hwnd, XEvent *xev )
     case NotifyUngrab:
         keyboard_grabbed = FALSE;
         retry_grab_clipping_window();
-        return TRUE; /* ignore wm specific NotifyUngrab / NotifyGrab events w.r.t focus */
+        break;
     }

+    /* ignore wm specific NotifyUngrab / NotifyGrab events w.r.t focus */
+    if (event->mode == NotifyGrab || event->mode == NotifyUngrab) return FALSE;
+
     if ((xic = X11DRV_get_ic( hwnd ))) XSetICFocus( xic );
     if (use_take_focus)
     {
@@ -903,7 +906,7 @@ static BOOL X11DRV_FocusOut( HWND hwnd, XEvent *xev )
     case NotifyUngrab:
         /* these are received when moving undecorated managed windows on mutter */
         keyboard_grabbed = FALSE;
-        return FALSE;
+        break;
     case NotifyNormal:
         keyboard_grabbed = FALSE;
         break;
@@ -918,10 +921,12 @@ static BOOL X11DRV_FocusOut( HWND hwnd, XEvent *xev )
          * FocusIn with NotifyUngrab mode.
          */
         retry_grab_clipping_window();
-
-        return TRUE; /* ignore wm specific NotifyUngrab / NotifyGrab events w.r.t focus */
+        break;
     }

+    /* ignore wm specific NotifyUngrab / NotifyGrab events w.r.t focus */
+    if (event->mode == NotifyGrab || event->mode == NotifyUngrab) return FALSE;
+
     focus_out( event->display, hwnd );
     return TRUE;
 }
From f2ed642f0944e77921494d00bb582a9eede637c1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 19 Sep 2019 15:42:09 +0200
Subject: [PATCH] winex11.drv: Wait for pointer grab on FocusIn/WM_TAKE_FOCUS
 events.

The FocusIn/WM_TAKE_FOCUS events are received as soon as a window is
clicked, but when some modifier key is pressed or when the click is on
the window frame, the WM may still be controlling the window size or
position. It usually grabs the cursor while doing so - and if not then
there's apparently nothing we can do.

When using undecorated mode we handle this case "correctly" by going
through the corresponding Windows non-client message loop until mouse
buttons are released, but when using decorated windows the window
decoration is empty from the Wine perspective and any window event is
considered as happening in the client area.

This leads to some issues when the window is moved or resized, with
applications applying clipping rectangles immediately and not updating
it on subsequent window move/resize messages. Delaying the WM_ACTIVATE
until the WM releases its grab and the window move is complete helps
solving this situation.

This delay is implemented here by resending the FocusIn/WM_TAKE_FOCUS
events to the window until the cursor can be grabbed and then processing
them normally.
---
 dlls/winex11.drv/event.c | 39 ++++++++++++++++++++++++++++++++++++---
 1 file changed, 36 insertions(+), 3 deletions(-)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index a6e025152ef..a13cd15bc04 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -323,6 +323,24 @@ static enum event_merge_action merge_raw_motion_events( XIRawEvent *prev, XIRawE
 }
 #endif

+static int try_grab_pointer( Display *display )
+{
+    if (!grab_pointer)
+        return 1;
+
+    /* if we are already clipping the cursor in the current thread, we should not
+     * call XGrabPointer here or it would change the confine-to window. */
+    if (clipping_cursor && x11drv_thread_data()->clip_hwnd)
+        return 1;
+
+    if (XGrabPointer( display, root_window, False, 0, GrabModeAsync, GrabModeAsync,
+                      None, None, CurrentTime ) != GrabSuccess)
+        return 0;
+
+    XUngrabPointer( display, CurrentTime );
+    return 1;
+}
+
 /***********************************************************************
  *           merge_events
  *
@@ -618,8 +636,16 @@ static void set_focus( XEvent *xev, HWND hwnd, Time time )
     Window win;
     GUITHREADINFO threadinfo;

-    TRACE( "setting foreground window to %p\n", hwnd );
-    SetForegroundWindow( hwnd );
+    if (!try_grab_pointer( xev->xany.display ))
+    {
+        XSendEvent( xev->xany.display, xev->xany.window, False, 0, xev );
+        return;
+    }
+    else
+    {
+        TRACE( "setting foreground window to %p\n", hwnd );
+        SetForegroundWindow( hwnd );
+    }

     threadinfo.cbSize = sizeof(threadinfo);
     GetGUIThreadInfo(0, &threadinfo);
@@ -822,8 +848,15 @@ static BOOL X11DRV_FocusIn( HWND hwnd, XEvent *xev )
         if (!hwnd) hwnd = GetActiveWindow();
         if (!hwnd) hwnd = x11drv_thread_data()->last_focus;
         if (hwnd && can_activate_window(hwnd)) set_focus( xev, hwnd, CurrentTime );
+        return TRUE;
     }
-    else SetForegroundWindow( hwnd );
+    else if (!try_grab_pointer( event->display ))
+    {
+        XSendEvent( event->display, event->window, False, 0, xev );
+        return FALSE;
+    }
+
+    SetForegroundWindow( hwnd );
     return TRUE;
 }

From cbaa1a01df27ebd5b21fdb57ae7c1df8ddf75b23 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 9 Dec 2021 11:53:02 +0100
Subject: [PATCH] winex11.drv: Release pointer grab on focus change.

When using WM_TAKE_FOCUS, the foreground window will only receive the
FocusOut message after we have called XSetInputFocus. As we are waiting
for the cursor to be released, we have to tell it to release its grab
so we can try to grab it ourselves.
---
 dlls/winex11.drv/event.c  | 2 ++
 dlls/winex11.drv/window.c | 2 ++
 dlls/winex11.drv/x11drv.h | 3 ++-
 3 files changed, 6 insertions(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index a13cd15bc04..67ef62ba3cc 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -638,6 +638,8 @@ static void set_focus( XEvent *xev, HWND hwnd, Time time )

     if (!try_grab_pointer( xev->xany.display ))
     {
+        /* ask the foreground window to release its grab before trying to get ours */
+        SendMessageW( GetForegroundWindow(), WM_X11DRV_RELEASE_CURSOR, 0, 0 );
         XSendEvent( xev->xany.display, xev->xany.window, False, 0, xev );
         return;
     }
diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 1bac11b373a..f76e020323a 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -2898,6 +2898,8 @@ LRESULT CDECL X11DRV_WindowMessage( HWND hwnd, UINT msg, WPARAM wp, LPARAM lp )
         return 0;
     case WM_X11DRV_ADD_TAB:
         taskbar_add_tab( hwnd );
+    case WM_X11DRV_RELEASE_CURSOR:
+        ungrab_clipping_window();
         return 0;
     default:
         FIXME( "got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp );
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 4054e86f4ee..1bdb26bff40 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -580,7 +580,8 @@ enum x11drv_window_messages
     WM_X11DRV_CLIP_CURSOR_NOTIFY,
     WM_X11DRV_CLIP_CURSOR_REQUEST,
     WM_X11DRV_DELETE_TAB,
-    WM_X11DRV_ADD_TAB
+    WM_X11DRV_ADD_TAB,
+    WM_X11DRV_RELEASE_CURSOR,
 };

 /* _NET_WM_STATE properties that we keep track of */
From 181f064c19948961bec9878a0600e35dee3409f1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 1 Oct 2019 11:21:24 +0200
Subject: [PATCH] winex11.drv: Restore pointer grab on FocusIn events.

This reverts commit 92177b0b161e91f1d609615d89d8e3199feea33f.

We introduced unnecessary complexity by adding the last_clip_* state,
we can instead use the ClipCursor state.

This restores the ClipCursor on FocusIn events by sending a
WM_X11DRV_CLIP_CURSOR message to the foreground window, which will query
the current clipping rect from the server and apply it.
---
 dlls/winex11.drv/event.c  | 10 +++-------
 dlls/winex11.drv/mouse.c  | 24 ------------------------
 dlls/winex11.drv/x11drv.h |  1 -
 3 files changed, 3 insertions(+), 32 deletions(-)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index 4c6b2e542fd..cf0305b2a4d 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -838,10 +838,12 @@ static BOOL X11DRV_FocusIn( HWND hwnd, XEvent *xev )
         break;
     case NotifyUngrab:
         keyboard_grabbed = FALSE;
-        retry_grab_clipping_window();
         break;
     }

+    /* ask the foreground window to re-apply the current ClipCursor rect */
+    SendMessageW( GetForegroundWindow(), WM_X11DRV_CLIP_CURSOR_REQUEST, 0, 0 );
+
     /* ignore wm specific NotifyUngrab / NotifyGrab events w.r.t focus */
     if (event->mode == NotifyGrab || event->mode == NotifyUngrab) return FALSE;

@@ -950,12 +952,6 @@ static BOOL X11DRV_FocusOut( HWND hwnd, XEvent *xev )
         break;
     case NotifyGrab:
         keyboard_grabbed = TRUE;
-
-        /* This will do nothing due to keyboard_grabbed == TRUE, but it
-         * will save the current clipping rect so we can restore it on
-         * FocusIn with NotifyUngrab mode.
-         */
-        retry_grab_clipping_window();
         break;
     }

diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
index 59f37681811..73c7527144e 100644
--- a/dlls/winex11.drv/mouse.c
+++ b/dlls/winex11.drv/mouse.c
@@ -128,9 +128,6 @@ XContext cursor_context = 0;
 static HWND cursor_window;
 static HCURSOR last_cursor;
 static DWORD last_cursor_change;
-static RECT last_clip_rect;
-static HWND last_clip_foreground_window;
-static BOOL last_clip_refused;
 static RECT clip_rect;
 static Cursor create_cursor( HANDLE handle );

@@ -450,15 +447,8 @@ static BOOL grab_clipping_window( const RECT *clip )
     if (keyboard_grabbed)
     {
         WARN( "refusing to clip to %s\n", wine_dbgstr_rect(clip) );
-        last_clip_refused = TRUE;
-        last_clip_foreground_window = GetForegroundWindow();
-        last_clip_rect = *clip;
         return FALSE;
     }
-    else
-    {
-        last_clip_refused = FALSE;
-    }

     /* enable XInput2 unless we are already clipping */
     if (!data->clip_hwnd) X11DRV_XInput2_Enable( data->display, None, PointerMotionMask );
@@ -529,20 +519,6 @@ void reset_clipping_window(void)
     ClipCursor( NULL );  /* make sure the clip rectangle is reset too */
 }

-/***********************************************************************
- *      retry_grab_clipping_window
- *
- * Restore the current clip rectangle or retry the last one if it has
- * been refused because of an active keyboard grab.
- */
-void retry_grab_clipping_window(void)
-{
-    if (clipping_cursor)
-        ClipCursor( &clip_rect );
-    else if (last_clip_refused && GetForegroundWindow() == last_clip_foreground_window)
-        ClipCursor( &last_clip_rect );
-}
-
 /***********************************************************************
  *             clip_cursor_notify
  *
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 1bdb26bff40..145fe5313d4 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -679,7 +679,6 @@ extern LRESULT clip_cursor_notify( HWND hwnd, HWND prev_clip_hwnd, HWND new_clip
 extern LRESULT clip_cursor_request( HWND hwnd, BOOL fullscreen, BOOL reset ) DECLSPEC_HIDDEN;
 extern void ungrab_clipping_window(void) DECLSPEC_HIDDEN;
 extern void reset_clipping_window(void) DECLSPEC_HIDDEN;
-extern void retry_grab_clipping_window(void) DECLSPEC_HIDDEN;
 extern BOOL clip_fullscreen_window( HWND hwnd, BOOL reset ) DECLSPEC_HIDDEN;
 extern void move_resize_window( HWND hwnd, int dir ) DECLSPEC_HIDDEN;
 extern void X11DRV_InitKeyboard( Display *display ) DECLSPEC_HIDDEN;
From 601f89d0f682dba5bebdf8964d9c388cdf3d2235 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 4 Oct 2019 13:57:33 +0200
Subject: [PATCH] Revert "winex11.drv: Only grab or warp the cursor when
 keyboard isn't grabbed."

This reverts commit 54f8077c41f715cfcf9c2bc016d964b720911326.

We are now delaying FocusIn events until cursor grab is released,
eventually restoring the last ClipCursor, and we also release our grab
on FocusOut events. This keyboard grab tracking isn't needed anymore.
---
 dlls/winex11.drv/event.c  | 37 -------------------------------------
 dlls/winex11.drv/mouse.c  | 12 ------------
 dlls/winex11.drv/x11drv.h |  1 -
 3 files changed, 50 deletions(-)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index cf0305b2a4d..b7f5614f222 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -148,9 +148,6 @@ static const char * event_names[MAX_EVENT_HANDLERS] =
     "SelectionNotify", "ColormapNotify", "ClientMessage", "MappingNotify", "GenericEvent"
 };

-/* is someone else grabbing the keyboard, for example the WM, when manipulating the window */
-BOOL keyboard_grabbed = FALSE;
-
 int xinput2_opcode = 0;

 /* return the name of an X event */
@@ -824,23 +821,6 @@ static BOOL X11DRV_FocusIn( HWND hwnd, XEvent *xev )
     if (event->detail == NotifyPointer) return FALSE;
     if (hwnd == GetDesktopWindow()) return FALSE;

-    switch (event->mode)
-    {
-    case NotifyGrab:
-        /* these are received when moving undecorated managed windows on mutter */
-        keyboard_grabbed = TRUE;
-        break;
-    case NotifyWhileGrabbed:
-        keyboard_grabbed = TRUE;
-        break;
-    case NotifyNormal:
-        keyboard_grabbed = FALSE;
-        break;
-    case NotifyUngrab:
-        keyboard_grabbed = FALSE;
-        break;
-    }
-
     /* ask the foreground window to re-apply the current ClipCursor rect */
     SendMessageW( GetForegroundWindow(), WM_X11DRV_CLIP_CURSOR_REQUEST, 0, 0 );

@@ -902,23 +909,6 @@ static BOOL X11DRV_FocusOut( HWND hwnd, XEvent *xev )
     }
     if (!hwnd) return FALSE;

-    switch (event->mode)
-    {
-    case NotifyUngrab:
-        /* these are received when moving undecorated managed windows on mutter */
-        keyboard_grabbed = FALSE;
-        break;
-    case NotifyNormal:
-        keyboard_grabbed = FALSE;
-        break;
-    case NotifyWhileGrabbed:
-        keyboard_grabbed = TRUE;
-        break;
-    case NotifyGrab:
-        keyboard_grabbed = TRUE;
-        break;
-    }
-
     /* ignore wm specific NotifyUngrab / NotifyGrab events w.r.t focus */
     if (event->mode == NotifyGrab || event->mode == NotifyUngrab) return FALSE;

diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
index 73c7527144e..1d6f9d1c5b9 100644
--- a/dlls/winex11.drv/mouse.c
+++ b/dlls/winex11.drv/mouse.c
@@ -444,12 +444,6 @@ static BOOL grab_clipping_window( const RECT *clip )
                                     GetModuleHandleW(0), NULL )))
         return TRUE;

-    if (keyboard_grabbed)
-    {
-        WARN( "refusing to clip to %s\n", wine_dbgstr_rect(clip) );
-        return FALSE;
-    }
-
     /* enable XInput2 unless we are already clipping */
     if (!data->clip_hwnd) X11DRV_XInput2_Enable( data->display, None, PointerMotionMask );

@@ -1514,12 +1508,6 @@ BOOL CDECL X11DRV_SetCursorPos( INT x, INT y )
     struct x11drv_thread_data *data = x11drv_init_thread_data();
     POINT pos = virtual_screen_to_root( x, y );

-    if (keyboard_grabbed)
-    {
-        WARN( "refusing to warp to %u, %u\n", pos.x, pos.y );
-        return FALSE;
-    }
-
     if (!clipping_cursor &&
         XGrabPointer( data->display, root_window, False,
                       PointerMotionMask | ButtonPressMask | ButtonReleaseMask,
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 145fe5313d4..4e6dcceb441 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -421,7 +421,6 @@ extern Colormap default_colormap DECLSPEC_HIDDEN;
 extern XPixmapFormatValues **pixmap_formats DECLSPEC_HIDDEN;
 extern Window root_window DECLSPEC_HIDDEN;
 extern BOOL clipping_cursor DECLSPEC_HIDDEN;
-extern BOOL keyboard_grabbed DECLSPEC_HIDDEN;
 extern unsigned int screen_bpp DECLSPEC_HIDDEN;
 extern BOOL use_xkb DECLSPEC_HIDDEN;
 extern BOOL usexrandr DECLSPEC_HIDDEN;
From eb12dcf3498a14e8d26c2e4b9a53498e61b43ebc Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 17 Dec 2019 16:58:07 +0100
Subject: [PATCH] Revert "winex11.drv: Only call XWarpPointer if we can get
 exclusive pointer grab."

This reverts commit 74efb3e872aebf57a42d62b52e149ae26f320c9a.

We are now only activating windows only once the window manager has
released its grab, it should be safer to let them move the pointer
around and this should not be needed anymore.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47771
---
 dlls/winex11.drv/mouse.c | 13 -------------
 1 file changed, 13 deletions(-)

diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
index 1d6f9d1c5b9..157ba0be84e 100644
--- a/dlls/winex11.drv/mouse.c
+++ b/dlls/winex11.drv/mouse.c
@@ -1508,21 +1508,8 @@ BOOL CDECL X11DRV_SetCursorPos( INT x, INT y )
     struct x11drv_thread_data *data = x11drv_init_thread_data();
     POINT pos = virtual_screen_to_root( x, y );

-    if (!clipping_cursor &&
-        XGrabPointer( data->display, root_window, False,
-                      PointerMotionMask | ButtonPressMask | ButtonReleaseMask,
-                      GrabModeAsync, GrabModeAsync, None, None, CurrentTime ) != GrabSuccess)
-    {
-        WARN( "refusing to warp pointer to %u, %u without exclusive grab\n", pos.x, pos.y );
-        return FALSE;
-    }
-
     XWarpPointer( data->display, root_window, root_window, 0, 0, 0, 0, pos.x, pos.y );
     data->warp_serial = NextRequest( data->display );
-
-    if (!clipping_cursor)
-        XUngrabPointer( data->display, CurrentTime );
-
     XNoOp( data->display );
     XFlush( data->display ); /* avoids bad mouse lag in games that do their own mouse warping */
     TRACE( "warped to %d,%d serial %lu\n", x, y, data->warp_serial );
From 626129a6ea5b7b948d192d53c94137cf0b80e938 Mon Sep 17 00:00:00 2001
From: Giovanni Mascellani <gmascellani@codeweavers.com>
Date: Mon, 15 Mar 2021 12:01:25 -0500
Subject: [PATCH] winex11.drv: Flush X connection after ungrabbing the pointer.

CW-Bug-Id: #18169
---
 dlls/winex11.drv/mouse.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
index 157ba0be84e..d02163cbaa8 100644
--- a/dlls/winex11.drv/mouse.c
+++ b/dlls/winex11.drv/mouse.c
@@ -497,7 +497,11 @@ void ungrab_clipping_window(void)

     TRACE( "no longer clipping\n" );
     XUnmapWindow( display, clip_window );
-    if (clipping_cursor) XUngrabPointer( display, CurrentTime );
+    if (clipping_cursor)
+    {
+        XUngrabPointer( display, CurrentTime );
+        XFlush( display );
+    }
     clipping_cursor = FALSE;
     SendNotifyMessageW( GetDesktopWindow(), WM_X11DRV_CLIP_CURSOR_NOTIFY, 0, 0 );
 }
From 42ffa67ffd96b6f43e01acf844c12728b0824619 Mon Sep 17 00:00:00 2001
From: Giovanni Mascellani <gmascellani@codeweavers.com>
Date: Mon, 7 Dec 2020 09:31:52 +0100
Subject: [PATCH] winex11.drv: Recognize the keyboard in a locale-independent
 way.

Try to recognize the keyboard comparing keysyms instead of converting
them to multibyte strings, which makes the process locale-dependent and
therefore more fragile.

Unfortunately this means that the layout tables might need to be
updated. However, this change is known to fix the recognitions of a few
keys in the French layout.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=30984
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45605
CW-Bug-Id: #16793
---
 dlls/winex11.drv/keyboard.c | 64 ++++++++++++++++++-------------------
 1 file changed, 31 insertions(+), 33 deletions(-)

diff --git a/dlls/winex11.drv/keyboard.c b/dlls/winex11.drv/keyboard.c
index 567f3d845b6..450211a17f5 100644
--- a/dlls/winex11.drv/keyboard.c
+++ b/dlls/winex11.drv/keyboard.c
@@ -1417,6 +1417,35 @@ BOOL X11DRV_KeyEvent( HWND hwnd, XEvent *xev )
     return TRUE;
 }

+/* From the point of view of this function there are two types of
+ * keys: those for which the mapping to vkey and scancode depends on
+ * the keyboard layout (i.e., letters, numbers, punctuation) and those
+ * for which it doesn't (control keys); since this function is used to
+ * recognize the keyboard layout and map keysyms to vkeys and
+ * scancodes, we are only concerned about the first type, and map
+ * everything in the second type to zero.
+ */
+static char keysym_to_char( KeySym keysym )
+{
+    /* Dead keys */
+    if (0xfe50 <= keysym && keysym < 0xfed0)
+        return KEYBOARD_MapDeadKeysym( keysym );
+
+    /* Control keys (there is nothing allocated below 0xfc00, but I
+       take some margin in case something is added in the future) */
+    if (0xf000 <= keysym && keysym < 0x10000)
+        return 0;
+
+    /* XFree86 vendor keys */
+    if (0x10000000 <= keysym)
+        return 0;
+
+    /* "Normal" keys: return last octet, because our tables don't have
+       more than that; it would be better to extend the tables and
+       compare the whole keysym, but it's a lot of work... */
+    return keysym & 0xff;
+}
+
 /**********************************************************************
  *		X11DRV_KEYBOARD_DetectLayout
  *
@@ -1447,24 +1476,7 @@ X11DRV_KEYBOARD_DetectLayout( Display *display )
       /* get data for keycode from X server */
       for (i = 0; i < syms; i++) {
         if (!(keysym = keycode_to_keysym (display, keyc, i))) continue;
-	/* Allow both one-byte and two-byte national keysyms */
-	if ((keysym < 0x8000) && (keysym != ' '))
-        {
-#ifdef HAVE_XKB
-            if (!use_xkb || !XkbTranslateKeySym(display, &keysym, 0, &ckey[keyc][i], 1, NULL))
-#endif
-            {
-                TRACE("XKB could not translate keysym %04lx\n", keysym);
-                /* FIXME: query what keysym is used as Mode_switch, fill XKeyEvent
-                 * with appropriate ShiftMask and Mode_switch, use XLookupString
-                 * to get character in the local encoding.
-                 */
-                ckey[keyc][i] = keysym & 0xFF;
-            }
-        }
-	else {
-	  ckey[keyc][i] = KEYBOARD_MapDeadKeysym(keysym);
-	}
+        ckey[keyc][i] = keysym_to_char(keysym);
       }
   }

@@ -1674,21 +1686,7 @@ void X11DRV_InitKeyboard( Display *display )
 	      int maxlen=0,maxval=-1,ok;
 	      for (i=0; i<syms; i++) {
 		keysym = keycode_to_keysym(display, keyc, i);
-		if ((keysym<0x8000) && (keysym!=' '))
-                {
-#ifdef HAVE_XKB
-                    if (!use_xkb || !XkbTranslateKeySym(display, &keysym, 0, &ckey[i], 1, NULL))
-#endif
-                    {
-                        /* FIXME: query what keysym is used as Mode_switch, fill XKeyEvent
-                         * with appropriate ShiftMask and Mode_switch, use XLookupString
-                         * to get character in the local encoding.
-                         */
-                        ckey[i] = (keysym <= 0x7F) ? keysym : 0;
-                    }
-		} else {
-		  ckey[i] = KEYBOARD_MapDeadKeysym(keysym);
-		}
+                ckey[i] = keysym_to_char(keysym);
 	      }
 	      /* find key with longest match streak */
 	      for (keyn=0; keyn<MAIN_LEN; keyn++) {
From e5c188782a91a829fafe3f102796ab1081f216c7 Mon Sep 17 00:00:00 2001
From: Giovanni Mascellani <gmascellani@codeweavers.com>
Date: Mon, 7 Dec 2020 09:49:53 +0100
Subject: [PATCH] winex11.drv: Dump keysyms and translations for all keys.

Dump all we can see about the user keyboard, so that their +keyboard
logs can be used to fix layout tables.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=30984
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45605
CW-Bug-Id: #16793
---
 dlls/winex11.drv/keyboard.c | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/dlls/winex11.drv/keyboard.c b/dlls/winex11.drv/keyboard.c
index 450211a17f5..d04d1db9102 100644
--- a/dlls/winex11.drv/keyboard.c
+++ b/dlls/winex11.drv/keyboard.c
@@ -1477,6 +1477,19 @@ X11DRV_KEYBOARD_DetectLayout( Display *display )
       for (i = 0; i < syms; i++) {
         if (!(keysym = keycode_to_keysym (display, keyc, i))) continue;
         ckey[keyc][i] = keysym_to_char(keysym);
+        if (TRACE_ON(keyboard))
+        {
+            char buf[32];
+            WCHAR bufW[32];
+            int len, lenW;
+            KeySym orig_keysym = keysym;
+            len = XkbTranslateKeySym(display, &keysym, 0, buf, sizeof(buf), NULL);
+            lenW = MultiByteToWideChar(CP_UNIXCP, 0, buf, len, bufW, ARRAY_SIZE(bufW));
+            if (lenW < ARRAY_SIZE(bufW))
+                bufW[lenW] = 0;
+            TRACE("keycode %u, index %d, orig_keysym 0x%04lx, keysym 0x%04lx, buf %s, bufW %s\n",
+                    keyc, i, orig_keysym, keysym, debugstr_a(buf), debugstr_w(bufW));
+        }
       }
   }

From 1eb3f357442e867566cfef2e423a0542e8c53e29 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 15 Mar 2021 11:31:37 -0500
Subject: [PATCH] HACK: winex11.drv: Add WINE_ALLOW_XIM option.

---
 dlls/winex11.drv/x11drv_main.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index 64f12cd96d2..e5a1ccf775a 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -642,6 +642,13 @@ static BOOL process_attach(void)
     dlopen( SONAME_LIBXEXT, RTLD_NOW|RTLD_GLOBAL );
 #endif

+    {
+        const char *e = getenv("WINE_ALLOW_XIM");
+        if(e){
+            use_xim = IS_OPTION_TRUE(*e);
+        }
+    }
+
     setup_options();

     if ((thread_data_tls_index = TlsAlloc()) == TLS_OUT_OF_INDEXES) return FALSE;
From d0ce33cfce4a46244ac6cef9d3a6d043e64e837a Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 12 Feb 2018 09:15:07 -0600
Subject: [PATCH] winex11.drv: Log more information about X11 errors.

---
 dlls/winex11.drv/x11drv_main.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index e5a1ccf775a..8c2688f2a58 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -316,6 +316,9 @@ static int error_handler( Display *display, XErrorEvent *error_evt )
              error_evt->serial, error_evt->request_code );
         DebugBreak();  /* force an entry in the debugger */
     }
+    TRACE("passing on error %d req %d:%d res 0x%lx\n",
+            error_evt->error_code, error_evt->request_code,
+            error_evt->minor_code, error_evt->resourceid);
     old_error_handler( display, error_evt );
     return 0;
 }
From 19b86fe3d35e00c8985e0c616cd7bc2eeb5e2df7 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Wed, 27 Jun 2018 10:06:48 -0500
Subject: [PATCH] HACK: winex11.drv: Let the WM focus our windows by default.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This should fix game windows not being in focus when first started
and when exiting, which can cause surprising keyboard behavior (e.g.
accidentally Alt-F4ing Steam itself, which is in the background).

This may break modal dialogs in some WMs (fvwm2?) which do not respect
our responses to WM_TAKE_FOCUS. For games that show that issue, we can
re-enable UseTakeFocus.

From Zeb:

"""
The basic problem, if I understand it correctly, is that Wine uses the
"globally active" focus model by default. This means that the window
manager won't focus our windows unless we respond in the affirmative to
a WM_TAKE_FOCUS event. Since the GUI thread isn't processing messages,
this doesn't happen.

Luckily, there is a very easy workaround: create the registry key
HKCU\Software\Wine\X11 Driver and set the somewhat inaptly named value
"UseTakeFocus" to "N" (i.e. No). This causes Wine to use the "locally
active" model instead, which means that the window manager will focus
our windows when it sees fit—i.e. when the user clicks on them, or when
they are created.
"""
---
 dlls/winex11.drv/x11drv_main.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index 8c2688f2a58..6bf4a0a4211 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -68,7 +68,7 @@ BOOL usexrandr = TRUE;
 BOOL usexcomposite = TRUE;
 BOOL use_xfixes = FALSE;
 BOOL use_xkb = TRUE;
-BOOL use_take_focus = TRUE;
+BOOL use_take_focus = FALSE;
 BOOL use_primary_selection = FALSE;
 BOOL use_system_cursors = TRUE;
 BOOL show_systray = TRUE;

From 055346363a41aba711a286a6bce35a7a679e2fa3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 12 Mar 2021 18:27:41 +0100
Subject: [PATCH] winex11.drv: Store swapchain surfaces associations.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Based on a patch from Felix Hädicke <felixhaedicke@web.de>.
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45277
CW-Bug-Id: 16608
---
 dlls/winex11.drv/vulkan.c | 21 ++++++++++++++++++++-
 1 file changed, 20 insertions(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index d805b3c8be4..948e963b12b 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -54,6 +54,7 @@ static CRITICAL_SECTION_DEBUG critsect_debug =
 static CRITICAL_SECTION context_section = { &critsect_debug, -1, 0, 0, 0, 0 };

 static XContext vulkan_hwnd_context;
+static XContext vulkan_swapchain_context;

 #define VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR 1000004000

@@ -143,6 +144,7 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
 #undef LOAD_OPTIONAL_FUNCPTR

     vulkan_hwnd_context = XUniqueContext();
+    vulkan_swapchain_context = XUniqueContext();

     return TRUE;

@@ -303,6 +305,8 @@ static VkResult X11DRV_vkCreateSwapchainKHR(VkDevice device,
 {
     struct wine_vk_surface *x11_surface = surface_from_handle(create_info->surface);
     VkSwapchainCreateInfoKHR create_info_host;
+    VkResult result;
+
     TRACE("%p %p %p %p\n", device, create_info, allocator, swapchain);

     if (allocator)
@@ -314,7 +318,14 @@ static VkResult X11DRV_vkCreateSwapchainKHR(VkDevice device,
     create_info_host = *create_info;
     create_info_host.surface = x11_surface->surface;

-    return pvkCreateSwapchainKHR(device, &create_info_host, NULL /* allocator */, swapchain);
+    result = pvkCreateSwapchainKHR(device, &create_info_host, NULL /* allocator */, swapchain);
+    if (result == VK_SUCCESS)
+    {
+        EnterCriticalSection(&context_section);
+        XSaveContext(gdi_display, (XID)(*swapchain), vulkan_swapchain_context, (char *)wine_vk_surface_grab(x11_surface));
+        LeaveCriticalSection(&context_section);
+    }
+    return result;
 }

 static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
@@ -426,12 +437,20 @@ static void X11DRV_vkDestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface
 static void X11DRV_vkDestroySwapchainKHR(VkDevice device, VkSwapchainKHR swapchain,
          const VkAllocationCallbacks *allocator)
 {
+    struct wine_vk_surface *surface;
+
     TRACE("%p, 0x%s %p\n", device, wine_dbgstr_longlong(swapchain), allocator);

     if (allocator)
         FIXME("Support for allocation callbacks not implemented yet\n");

     pvkDestroySwapchainKHR(device, swapchain, NULL /* allocator */);
+
+    EnterCriticalSection(&context_section);
+    if (!XFindContext(gdi_display, (XID)swapchain, vulkan_swapchain_context, (char **)&surface))
+        wine_vk_surface_release(surface);
+    XDeleteContext(gdi_display, (XID)swapchain, vulkan_swapchain_context);
+    LeaveCriticalSection(&context_section);
 }

 static VkResult X11DRV_vkEnumerateInstanceExtensionProperties(const char *layer_name,
From 6f66c2d03485428ba639457225eceedfe2d46a25 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 22 Apr 2021 23:38:16 +0200
Subject: [PATCH] winex11.drv: Hook vkAcquireNextImage(2)KHR functions.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45277
---
 dlls/winemac.drv/vulkan.c    |  2 ++
 dlls/winevulkan/make_vulkan  |  2 ++
 dlls/winex11.drv/vulkan.c    | 19 +++++++++++++++++++
 include/wine/vulkan_driver.h |  6 ++++++
 4 files changed, 29 insertions(+)

diff --git a/dlls/winemac.drv/vulkan.c b/dlls/winemac.drv/vulkan.c
index bc2128df275..6de6832fbd7 100644
--- a/dlls/winemac.drv/vulkan.c
+++ b/dlls/winemac.drv/vulkan.c
@@ -589,6 +589,8 @@ static VkSurfaceKHR macdrv_wine_get_native_surface(VkSurfaceKHR surface)

 static const struct vulkan_funcs vulkan_funcs =
 {
+    NULL,
+    NULL,
     macdrv_vkCreateInstance,
     macdrv_vkCreateSwapchainKHR,
     macdrv_vkCreateWin32SurfaceKHR,
diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index e198256b31c..360b2087eb9 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -227,6 +227,8 @@ FUNCTION_OVERRIDES = {
     "vkGetPhysicalDeviceWin32PresentationSupportKHR" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},

     # VK_KHR_swapchain
+    "vkAcquireNextImageKHR" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
+    "vkAcquireNextImage2KHR": {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
     "vkCreateSwapchainKHR" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
     "vkDestroySwapchainKHR" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
     "vkGetSwapchainImagesKHR": {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index 948e963b12b..c844ad35bb3 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -79,6 +79,7 @@ typedef struct VkXlibSurfaceCreateInfoKHR
     Window window;
 } VkXlibSurfaceCreateInfoKHR;

+static VkResult (*pvkAcquireNextImageKHR)(VkDevice, VkSwapchainKHR, uint64_t, VkSemaphore, VkFence, uint32_t *);
 static VkResult (*pvkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
 static VkResult (*pvkCreateSwapchainKHR)(VkDevice, const VkSwapchainCreateInfoKHR *, const VkAllocationCallbacks *, VkSwapchainKHR *);
 static VkResult (*pvkCreateXlibSurfaceKHR)(VkInstance, const VkXlibSurfaceCreateInfoKHR *, const VkAllocationCallbacks *, VkSurfaceKHR *);
@@ -120,6 +121,7 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)

 #define LOAD_FUNCPTR(f) if (!(p##f = dlsym(vulkan_handle, #f))) goto fail
 #define LOAD_OPTIONAL_FUNCPTR(f) p##f = dlsym(vulkan_handle, #f)
+    LOAD_FUNCPTR(vkAcquireNextImageKHR);
     LOAD_FUNCPTR(vkCreateInstance);
     LOAD_FUNCPTR(vkCreateSwapchainKHR);
     LOAD_FUNCPTR(vkCreateXlibSurfaceKHR);
@@ -293,6 +295,21 @@ static VkResult X11DRV_create_vk_instance_with_callback(const VkInstanceCreateIn
     return res;
 }

+static VkResult X11DRV_vkAcquireNextImageKHR(VkDevice device,
+        VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore,
+        VkFence fence, uint32_t *image_index)
+{
+    return pvkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, image_index);
+}
+
+static VkResult X11DRV_vkAcquireNextImage2KHR(VkDevice device,
+        const VkAcquireNextImageInfoKHR *acquire_info, uint32_t *image_index)
+{
+    static int once;
+    if (!once++) FIXME("Emulating vkGetPhysicalDeviceSurfaceCapabilities2KHR with vkGetPhysicalDeviceSurfaceCapabilitiesKHR, pNext is ignored.\n");
+    return X11DRV_vkAcquireNextImageKHR(device, acquire_info->swapchain, acquire_info->timeout, acquire_info->semaphore, acquire_info->fence, image_index);
+}
+
 static VkResult X11DRV_vkCreateInstance(const VkInstanceCreateInfo *create_info,
         const VkAllocationCallbacks *allocator, VkInstance *instance)
 {
@@ -719,6 +736,8 @@ static VkSurfaceKHR X11DRV_wine_get_native_surface(VkSurfaceKHR surface)

 static const struct vulkan_funcs vulkan_funcs =
 {
+    X11DRV_vkAcquireNextImage2KHR,
+    X11DRV_vkAcquireNextImageKHR,
     X11DRV_vkCreateInstance,
     X11DRV_vkCreateSwapchainKHR,
     X11DRV_vkCreateWin32SurfaceKHR,
diff --git a/include/wine/vulkan_driver.h b/include/wine/vulkan_driver.h
index 09b94d2775f..f244e44ecf1 100644
--- a/include/wine/vulkan_driver.h
+++ b/include/wine/vulkan_driver.h
@@ -21,6 +21,8 @@ struct vulkan_funcs
      * needs to provide. Other function calls will be provided indirectly by dispatch
      * tables part of dispatchable Vulkan objects such as VkInstance or vkDevice.
      */
+    VkResult (*p_vkAcquireNextImage2KHR)(VkDevice, const VkAcquireNextImageInfoKHR *, uint32_t *);
+    VkResult (*p_vkAcquireNextImageKHR)(VkDevice, VkSwapchainKHR, uint64_t, VkSemaphore, VkFence, uint32_t *);
     VkResult (*p_vkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
     VkResult (*p_vkCreateSwapchainKHR)(VkDevice, const VkSwapchainCreateInfoKHR *, const VkAllocationCallbacks *, VkSwapchainKHR *);
     VkResult (*p_vkCreateWin32SurfaceKHR)(VkInstance, const VkWin32SurfaceCreateInfoKHR *, const VkAllocationCallbacks *, VkSurfaceKHR *);
@@ -55,6 +57,10 @@ static inline void *get_vulkan_driver_device_proc_addr(

     name += 2;

+    if (!strcmp(name, "AcquireNextImage2KHR"))
+        return vulkan_funcs->p_vkAcquireNextImage2KHR;
+    if (!strcmp(name, "AcquireNextImageKHR"))
+        return vulkan_funcs->p_vkAcquireNextImageKHR;
     if (!strcmp(name, "CreateSwapchainKHR"))
         return vulkan_funcs->p_vkCreateSwapchainKHR;
     if (!strcmp(name, "DestroySwapchainKHR"))
From 861c624e111454245326a0dcabeb2059ad15890c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 22 Oct 2021 00:23:49 +0200
Subject: [PATCH] winex11.drv: Rename X11DRV_FLUSH_GL_DRAWABLE to
 X11DRV_PRESENT_DRAWABLE.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45277
CW-Bug-Id: 16608
---
 dlls/winex11.drv/init.c   |  8 ++++----
 dlls/winex11.drv/opengl.c | 40 +++++++++++++++++++--------------------
 dlls/winex11.drv/x11drv.h |  8 ++++----
 3 files changed, 28 insertions(+), 28 deletions(-)

diff --git a/dlls/winex11.drv/init.c b/dlls/winex11.drv/init.c
index 5b31c352a23..0e8d2ffbf9e 100644
--- a/dlls/winex11.drv/init.c
+++ b/dlls/winex11.drv/init.c
@@ -230,16 +230,16 @@ static INT CDECL X11DRV_ExtEscape( PHYSDEV dev, INT escape, INT in_count, LPCVOI
                     return TRUE;
                 }
                 break;
-            case X11DRV_FLUSH_GL_DRAWABLE:
-                if (in_count >= sizeof(struct x11drv_escape_flush_gl_drawable))
+            case X11DRV_PRESENT_DRAWABLE:
+                if (in_count >= sizeof(struct x11drv_escape_present_drawable))
                 {
-                    const struct x11drv_escape_flush_gl_drawable *data = in_data;
+                    const struct x11drv_escape_present_drawable *data = in_data;
                     RECT rect = physDev->dc_rect;

                     OffsetRect( &rect, -physDev->dc_rect.left, -physDev->dc_rect.top );
                     if (data->flush) XFlush( gdi_display );
                     XSetFunction( gdi_display, physDev->gc, GXcopy );
-                    XCopyArea( gdi_display, data->gl_drawable, physDev->drawable, physDev->gc,
+                    XCopyArea( gdi_display, data->drawable, physDev->drawable, physDev->gc,
                                0, 0, rect.right, rect.bottom,
                                physDev->dc_rect.left, physDev->dc_rect.top );
                     add_device_bounds( physDev, &rect );
diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index 567205f742c..3f3deae59ba 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -1942,20 +1942,20 @@ static BOOL WINAPI glxdrv_wglShareLists(struct wgl_context *org, struct wgl_cont

 static void wglFinish(void)
 {
-    struct x11drv_escape_flush_gl_drawable escape;
+    struct x11drv_escape_present_drawable escape;
     struct gl_drawable *gl;
     struct wgl_context *ctx = NtCurrentTeb()->glContext;

-    escape.code = X11DRV_FLUSH_GL_DRAWABLE;
-    escape.gl_drawable = 0;
+    escape.code = X11DRV_PRESENT_DRAWABLE;
+    escape.drawable = 0;
     escape.flush = FALSE;

     if ((gl = get_gl_drawable( WindowFromDC( ctx->hdc ), 0 )))
     {
         switch (gl->type)
         {
-        case DC_GL_PIXMAP_WIN: escape.gl_drawable = gl->pixmap; break;
-        case DC_GL_CHILD_WIN:  escape.gl_drawable = gl->window; break;
+        case DC_GL_PIXMAP_WIN: escape.drawable = gl->pixmap; break;
+        case DC_GL_CHILD_WIN:  escape.drawable = gl->window; break;
         default: break;
         }
         sync_context(ctx);
@@ -1963,25 +1963,25 @@ static void wglFinish(void)
     }

     pglFinish();
-    if (escape.gl_drawable) ExtEscape( ctx->hdc, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
+    if (escape.drawable) ExtEscape( ctx->hdc, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
 }

 static void wglFlush(void)
 {
-    struct x11drv_escape_flush_gl_drawable escape;
+    struct x11drv_escape_present_drawable escape;
     struct gl_drawable *gl;
     struct wgl_context *ctx = NtCurrentTeb()->glContext;

-    escape.code = X11DRV_FLUSH_GL_DRAWABLE;
-    escape.gl_drawable = 0;
+    escape.code = X11DRV_PRESENT_DRAWABLE;
+    escape.drawable = 0;
     escape.flush = FALSE;

     if ((gl = get_gl_drawable( WindowFromDC( ctx->hdc ), 0 )))
     {
         switch (gl->type)
         {
-        case DC_GL_PIXMAP_WIN: escape.gl_drawable = gl->pixmap; break;
-        case DC_GL_CHILD_WIN:  escape.gl_drawable = gl->window; break;
+        case DC_GL_PIXMAP_WIN: escape.drawable = gl->pixmap; break;
+        case DC_GL_CHILD_WIN:  escape.drawable = gl->window; break;
         default: break;
         }
         sync_context(ctx);
@@ -1989,7 +1989,7 @@ static void wglFlush(void)
     }

     pglFlush();
-    if (escape.gl_drawable) ExtEscape( ctx->hdc, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
+    if (escape.drawable) ExtEscape( ctx->hdc, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
 }

 static const GLubyte *wglGetString(GLenum name)
@@ -3304,15 +3304,15 @@ static void X11DRV_WineGL_LoadExtensions(void)
  */
 static BOOL WINAPI glxdrv_wglSwapBuffers( HDC hdc )
 {
-    struct x11drv_escape_flush_gl_drawable escape;
+    struct x11drv_escape_present_drawable escape;
     struct gl_drawable *gl;
     struct wgl_context *ctx = NtCurrentTeb()->glContext;
     INT64 ust, msc, sbc, target_sbc = 0;

     TRACE("(%p)\n", hdc);

-    escape.code = X11DRV_FLUSH_GL_DRAWABLE;
-    escape.gl_drawable = 0;
+    escape.code = X11DRV_PRESENT_DRAWABLE;
+    escape.drawable = 0;
     escape.flush = !pglXWaitForSbcOML;

     if (!(gl = get_gl_drawable( WindowFromDC( hdc ), hdc )))
@@ -3333,7 +3333,7 @@ static BOOL WINAPI glxdrv_wglSwapBuffers( HDC hdc )
     {
     case DC_GL_PIXMAP_WIN:
         if (ctx) sync_context( ctx );
-        escape.gl_drawable = gl->pixmap;
+        escape.drawable = gl->pixmap;
         if (pglXCopySubBufferMESA) {
             /* (glX)SwapBuffers has an implicit glFlush effect, however
              * GLX_MESA_copy_sub_buffer doesn't. Make sure GL is flushed before
@@ -3354,10 +3354,10 @@ static BOOL WINAPI glxdrv_wglSwapBuffers( HDC hdc )
     case DC_GL_WINDOW:
     case DC_GL_CHILD_WIN:
         if (ctx) sync_context( ctx );
-        if (gl->type == DC_GL_CHILD_WIN) escape.gl_drawable = gl->window;
+        if (gl->type == DC_GL_CHILD_WIN) escape.drawable = gl->window;
         /* fall through */
     default:
-        if (escape.gl_drawable && pglXSwapBuffersMscOML)
+        if (escape.drawable && pglXSwapBuffersMscOML)
         {
             pglFlush();
             target_sbc = pglXSwapBuffersMscOML( gdi_display, gl->drawable, 0, 0, 0 );
@@ -3367,12 +3367,12 @@ static BOOL WINAPI glxdrv_wglSwapBuffers( HDC hdc )
         break;
     }

-    if (escape.gl_drawable && pglXWaitForSbcOML)
+    if (escape.drawable && pglXWaitForSbcOML)
         pglXWaitForSbcOML( gdi_display, gl->drawable, target_sbc, &ust, &msc, &sbc );

     release_gl_drawable( gl );

-    if (escape.gl_drawable) ExtEscape( ctx->hdc, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
+    if (escape.drawable) ExtEscape( ctx->hdc, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
     return TRUE;
 }

diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index f389f3e0836..33b2fc485ef 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -291,7 +291,7 @@ enum x11drv_escape_codes
     X11DRV_SET_DRAWABLE,     /* set current drawable for a DC */
     X11DRV_START_EXPOSURES,  /* start graphics exposures */
     X11DRV_END_EXPOSURES,    /* end graphics exposures */
-    X11DRV_FLUSH_GL_DRAWABLE, /* flush changes made to the gl drawable */
+    X11DRV_PRESENT_DRAWABLE, /* present the drawable on screen */
     X11DRV_FLUSH_GDI_DISPLAY /* flush the gdi display */
 };

@@ -357,10 +357,10 @@ struct x11drv_escape_get_drawable
     int                      pixel_format; /* internal GL pixel format */
 };

-struct x11drv_escape_flush_gl_drawable
+struct x11drv_escape_present_drawable
 {
-    enum x11drv_escape_codes code;         /* escape code (X11DRV_FLUSH_GL_DRAWABLE) */
-    Drawable                 gl_drawable;  /* GL drawable */
+    enum x11drv_escape_codes code;         /* escape code (X11DRV_PRESENT_DRAWABLE) */
+    Drawable                 drawable;     /* GL / VK drawable */
     BOOL                     flush;        /* flush X11 before copying */
 };

From 6e57f48457f8df1d67a894a7497b1d70d43f784f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 22 Oct 2021 00:30:19 +0200
Subject: [PATCH] winex11.drv: Support child window vulkan rendering.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Based on a patch from Felix Hädicke <felixhaedicke@web.de>.
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45277
CW-Bug-Id: 16608
---
 dlls/winex11.drv/vulkan.c | 90 +++++++++++++++++++++++++++++++++++----
 dlls/winex11.drv/window.c | 15 +++++++
 dlls/winex11.drv/x11drv.h |  1 +
 3 files changed, 97 insertions(+), 9 deletions(-)

diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index c844ad35bb3..d702105c64b 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -32,6 +32,7 @@
 #include "wine/debug.h"
 #include "wine/heap.h"
 #include "x11drv.h"
+#include "xcomposite.h"

 #define VK_NO_PROTOTYPES
 #define WINE_VK_HOST
@@ -66,6 +67,8 @@ struct wine_vk_surface
     struct list entry;
     Window window;
     VkSurfaceKHR surface; /* native surface */
+    BOOL offscreen; /* drawable is offscreen */
+    HDC hdc;
     HWND hwnd;
     DWORD hwnd_thread_id;
 };
@@ -231,15 +234,54 @@ static void wine_vk_surface_release(struct wine_vk_surface *surface)
 void wine_vk_surface_destroy(HWND hwnd)
 {
     struct wine_vk_surface *surface;
+    HDC hdc = 0;
+
     EnterCriticalSection(&context_section);
     if (!XFindContext(gdi_display, (XID)hwnd, vulkan_hwnd_context, (char **)&surface))
     {
+        hdc = surface->hdc;
         surface->hwnd_thread_id = 0;
-        surface->hwnd = NULL;
+        surface->hwnd = 0;
+        surface->hdc = 0;
         wine_vk_surface_release(surface);
     }
     XDeleteContext(gdi_display, (XID)hwnd, vulkan_hwnd_context);
     LeaveCriticalSection(&context_section);
+    if (hdc) ReleaseDC(hwnd, hdc);
+}
+
+static BOOL wine_vk_surface_set_offscreen(struct wine_vk_surface *surface, BOOL offscreen)
+{
+#ifdef SONAME_LIBXCOMPOSITE
+    if (usexcomposite)
+    {
+        if (!surface->offscreen && offscreen)
+        {
+            FIXME("Redirecting vulkan surface offscreen, expect degraded performance.\n");
+            pXCompositeRedirectWindow(gdi_display, surface->window, CompositeRedirectManual);
+        }
+        else if (surface->offscreen && !offscreen)
+        {
+            FIXME("Putting vulkan surface back onscreen, expect standard performance.\n");
+            pXCompositeUnredirectWindow(gdi_display, surface->window, CompositeRedirectManual);
+        }
+        surface->offscreen = offscreen;
+        return TRUE;
+    }
+#endif
+
+    if (offscreen) FIXME("Application requires child window rendering, which is not implemented yet!\n");
+    surface->offscreen = offscreen;
+    return !offscreen;
+}
+
+void sync_vk_surface(HWND hwnd, BOOL known_child)
+{
+    struct wine_vk_surface *surface;
+    EnterCriticalSection(&context_section);
+    if (!XFindContext(gdi_display, (XID)hwnd, vulkan_hwnd_context, (char **)&surface))
+        wine_vk_surface_set_offscreen(surface, known_child);
+    LeaveCriticalSection(&context_section);
 }

 void vulkan_thread_detach(void)
@@ -299,7 +341,30 @@ static VkResult X11DRV_vkAcquireNextImageKHR(VkDevice device,
         VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore,
         VkFence fence, uint32_t *image_index)
 {
-    return pvkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, image_index);
+    struct x11drv_escape_present_drawable escape;
+    struct wine_vk_surface *surface = NULL;
+    VkResult result;
+    HDC hdc = 0;
+
+    EnterCriticalSection(&context_section);
+    if (!XFindContext(gdi_display, (XID)swapchain, vulkan_swapchain_context, (char **)&surface))
+    {
+        wine_vk_surface_grab(surface);
+        hdc = surface->hdc;
+    }
+    LeaveCriticalSection(&context_section);
+
+    result = pvkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, image_index);
+    if (result == VK_SUCCESS && hdc && surface && surface->offscreen)
+    {
+        escape.code = X11DRV_PRESENT_DRAWABLE;
+        escape.drawable = surface->window;
+        escape.flush = TRUE;
+        ExtEscape(hdc, X11DRV_ESCAPE, sizeof(escape), (char *)&escape, 0, NULL);
+    }
+
+    if (surface) wine_vk_surface_release(surface);
+    return result;
 }

 static VkResult X11DRV_vkAcquireNextImage2KHR(VkDevice device,
@@ -358,13 +423,6 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
     if (allocator)
         FIXME("Support for allocation callbacks not implemented yet\n");

-    /* TODO: support child window rendering. */
-    if (create_info->hwnd && GetAncestor(create_info->hwnd, GA_PARENT) != GetDesktopWindow())
-    {
-        FIXME("Application requires child window rendering, which is not implemented yet!\n");
-        return VK_ERROR_INCOMPATIBLE_DRIVER;
-    }
-
     x11_surface = heap_alloc_zero(sizeof(*x11_surface));
     if (!x11_surface)
         return VK_ERROR_OUT_OF_HOST_MEMORY;
@@ -373,6 +431,7 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
     x11_surface->hwnd = create_info->hwnd;
     if (x11_surface->hwnd)
     {
+        x11_surface->hdc = GetDC(create_info->hwnd);
         x11_surface->window = create_client_window(create_info->hwnd, &default_visual);
         x11_surface->hwnd_thread_id = GetWindowThreadProcessId(x11_surface->hwnd, NULL);
     }
@@ -390,6 +449,15 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
         goto err;
     }

+    if (create_info->hwnd && (GetWindow( create_info->hwnd, GW_CHILD ) || GetAncestor( create_info->hwnd, GA_PARENT ) != GetDesktopWindow()))
+    {
+        if (!wine_vk_surface_set_offscreen(x11_surface, TRUE))
+        {
+            res = VK_ERROR_INCOMPATIBLE_DRIVER;
+            goto err;
+        }
+    }
+
     create_info_host.sType = VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR;
     create_info_host.pNext = NULL;
     create_info_host.flags = 0; /* reserved */
diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 916350c685a..77c5d4ea480 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -1741,6 +1741,15 @@ void CDECL X11DRV_SetWindowStyle( HWND hwnd, INT offset, STYLESTRUCT *style )
 {
     struct x11drv_win_data *data;
     DWORD changed = style->styleNew ^ style->styleOld;
+    HWND parent = GetAncestor( hwnd, GA_PARENT );
+
+    if (offset == GWL_STYLE && (changed & WS_CHILD))
+    {
+        if (GetWindow( parent, GW_CHILD ) || GetAncestor( parent, GA_PARENT ) != GetDesktopWindow())
+            sync_vk_surface( parent, TRUE );
+        else
+            sync_vk_surface( parent, FALSE );
+    }

     if (hwnd == GetDesktopWindow()) return;
     if (!(data = get_win_data( hwnd ))) return;
@@ -1767,6 +1776,10 @@ void CDECL X11DRV_DestroyWindow( HWND hwnd )
 {
     struct x11drv_thread_data *thread_data = x11drv_thread_data();
     struct x11drv_win_data *data;
+    HWND parent = GetAncestor( hwnd, GA_PARENT );
+
+    if (!GetWindow( parent, GW_CHILD ) && GetAncestor( parent, GA_PARENT ) == GetDesktopWindow())
+        sync_vk_surface( parent, FALSE );

     if (!(data = get_win_data( hwnd ))) return;

@@ -1980,6 +1993,7 @@ static struct x11drv_win_data *X11DRV_create_win_data( HWND hwnd, const RECT *wi
      * that will need clipping support.
      */
     sync_gl_drawable( parent, TRUE );
+    sync_vk_surface( parent, TRUE );

     display = thread_init_display();
     init_clip_window();  /* make sure the clip window is initialized in this thread */
@@ -2318,6 +2332,7 @@ void CDECL X11DRV_SetParent( HWND hwnd, HWND parent, HWND old_parent )
      * that will need clipping support.
      */
     sync_gl_drawable( parent, TRUE );
+    sync_vk_surface( parent, TRUE );

     fetch_icon_data( hwnd, 0, 0 );
 }
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 33b2fc485ef..9c8def1b068 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -646,6 +646,7 @@ extern void sync_gl_drawable( HWND hwnd, BOOL known_child ) DECLSPEC_HIDDEN;
 extern void set_gl_drawable_parent( HWND hwnd, HWND parent ) DECLSPEC_HIDDEN;
 extern void destroy_gl_drawable( HWND hwnd ) DECLSPEC_HIDDEN;
 extern void wine_vk_surface_destroy( HWND hwnd ) DECLSPEC_HIDDEN;
+extern void sync_vk_surface( HWND hwnd, BOOL known_child ) DECLSPEC_HIDDEN;
 extern void vulkan_thread_detach(void) DECLSPEC_HIDDEN;

 extern void wait_for_withdrawn_state( HWND hwnd, BOOL set ) DECLSPEC_HIDDEN;

From 15cf1fe27d3431e6c77d7de0e3f04809198d2572 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 22 Oct 2021 00:49:09 +0200
Subject: [PATCH] winex11.drv: Wait on vkAcquireNextImageKHR before flushing.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

To prevent tearing, when present mode is mailbox or fifo.

Based on a patch from Felix Hädicke <felixhaedicke@web.de>.
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45277
CW-Bug-Id: 16608
---
 dlls/winex11.drv/vulkan.c | 35 +++++++++++++++++++++++++++++++++++
 1 file changed, 35 insertions(+)

diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index d702105c64b..1a077d9323e 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -67,6 +67,7 @@ struct wine_vk_surface
     struct list entry;
     Window window;
     VkSurfaceKHR surface; /* native surface */
+    VkPresentModeKHR present_mode;
     BOOL offscreen; /* drawable is offscreen */
     HDC hdc;
     HWND hwnd;
@@ -103,6 +104,9 @@ static VkResult (*pvkGetPhysicalDeviceSurfaceSupportKHR)(VkPhysicalDevice, uint3
 static VkBool32 (*pvkGetPhysicalDeviceXlibPresentationSupportKHR)(VkPhysicalDevice, uint32_t, Display *, VisualID);
 static VkResult (*pvkGetSwapchainImagesKHR)(VkDevice, VkSwapchainKHR, uint32_t *, VkImage *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
+static VkResult (*pvkWaitForFences)(VkDevice device, uint32_t fenceCount, const VkFence *pFences, VkBool32 waitAll, uint64_t timeout);
+static VkResult (*pvkCreateFence)(VkDevice device, const VkFenceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence);
+static void (*pvkDestroyFence)(VkDevice device, VkFence fence, const VkAllocationCallbacks *pAllocator);

 static void *X11DRV_get_vk_device_proc_addr(const char *name);
 static void *X11DRV_get_vk_instance_proc_addr(VkInstance instance, const char *name);
@@ -145,6 +149,9 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
     LOAD_FUNCPTR(vkQueuePresentKHR);
     LOAD_OPTIONAL_FUNCPTR(vkGetDeviceGroupSurfacePresentModesKHR);
     LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDevicePresentRectanglesKHR);
+    LOAD_FUNCPTR(vkWaitForFences);
+    LOAD_FUNCPTR(vkCreateFence);
+    LOAD_FUNCPTR(vkDestroyFence);
 #undef LOAD_FUNCPTR
 #undef LOAD_OPTIONAL_FUNCPTR

@@ -341,9 +348,12 @@ static VkResult X11DRV_vkAcquireNextImageKHR(VkDevice device,
         VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore,
         VkFence fence, uint32_t *image_index)
 {
+    static int once;
     struct x11drv_escape_present_drawable escape;
     struct wine_vk_surface *surface = NULL;
     VkResult result;
+    VkFence orig_fence;
+    BOOL wait_fence = FALSE;
     HDC hdc = 0;

     EnterCriticalSection(&context_section);
@@ -354,15 +364,35 @@ static VkResult X11DRV_vkAcquireNextImageKHR(VkDevice device,
     }
     LeaveCriticalSection(&context_section);

+    if (!surface || !surface->offscreen)
+        wait_fence = FALSE;
+    else if (surface->present_mode == VK_PRESENT_MODE_MAILBOX_KHR ||
+             surface->present_mode == VK_PRESENT_MODE_FIFO_KHR)
+        wait_fence = TRUE;
+
+    orig_fence = fence;
+    if (wait_fence && !fence)
+    {
+        VkFenceCreateInfo create_info;
+        create_info.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
+        create_info.pNext = NULL;
+        create_info.flags = 0;
+        pvkCreateFence(device, &create_info, NULL, &fence);
+    }
+
     result = pvkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, image_index);
     if (result == VK_SUCCESS && hdc && surface && surface->offscreen)
     {
+        if (wait_fence) pvkWaitForFences(device, 1, &fence, 0, timeout);
         escape.code = X11DRV_PRESENT_DRAWABLE;
         escape.drawable = surface->window;
         escape.flush = TRUE;
         ExtEscape(hdc, X11DRV_ESCAPE, sizeof(escape), (char *)&escape, 0, NULL);
+        if (surface->present_mode == VK_PRESENT_MODE_MAILBOX_KHR)
+            if (once++) FIXME("Application requires child window rendering with mailbox present mode, expect possible tearing!\n");
     }

+    if (fence != orig_fence) pvkDestroyFence(device, fence, NULL);
     if (surface) wine_vk_surface_release(surface);
     return result;
 }
@@ -400,6 +430,11 @@ static VkResult X11DRV_vkCreateSwapchainKHR(VkDevice device,
     create_info_host = *create_info;
     create_info_host.surface = x11_surface->surface;

+    /* force fifo when running offscreen so the acquire fence is more likely to be vsynced */
+    if (x11_surface->offscreen && create_info->presentMode == VK_PRESENT_MODE_MAILBOX_KHR)
+        create_info_host.presentMode = VK_PRESENT_MODE_FIFO_KHR;
+    x11_surface->present_mode = create_info->presentMode;
+
     result = pvkCreateSwapchainKHR(device, &create_info_host, NULL /* allocator */, swapchain);
     if (result == VK_SUCCESS)
     {
From f06b97c57d0abd9ab25289d3ccce12737beef51a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 12 Mar 2021 00:10:49 +0100
Subject: [PATCH] winex11.drv: Move Xfixes extension query to process_attach.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45277
CW-Bug-Id: 16608
---
 dlls/winex11.drv/clipboard.c   | 26 ++------------
 dlls/winex11.drv/x11drv.h      |  2 ++
 dlls/winex11.drv/x11drv_main.c | 63 ++++++++++++++++++++++++++++++++++
 dlls/winex11.drv/xfixes.h      | 36 +++++++++++++++++++
 4 files changed, 103 insertions(+), 24 deletions(-)
 create mode 100644 dlls/winex11.drv/xfixes.h

diff --git a/dlls/winex11.drv/clipboard.c b/dlls/winex11.drv/clipboard.c
index a13d0a55b76..7953ae5d925 100644
--- a/dlls/winex11.drv/clipboard.c
+++ b/dlls/winex11.drv/clipboard.c
@@ -77,6 +77,7 @@
 #include <assert.h>

 #include "x11drv.h"
+#include "xfixes.h"

 #ifdef HAVE_X11_EXTENSIONS_XFIXES_H
 #include <X11/extensions/Xfixes.h>
@@ -196,7 +197,6 @@ static UINT rendered_formats;
 static ULONG64 last_clipboard_update;
 static struct clipboard_format **current_x11_formats;
 static unsigned int nb_current_x11_formats;
-static BOOL use_xfixes;

 Display *clipboard_display = NULL;

@@ -1975,28 +1975,6 @@ static BOOL selection_notify_event( HWND hwnd, XEvent *event )
 static void xfixes_init(void)
 {
 #ifdef SONAME_LIBXFIXES
-    typeof(XFixesSelectSelectionInput) *pXFixesSelectSelectionInput;
-    typeof(XFixesQueryExtension) *pXFixesQueryExtension;
-    typeof(XFixesQueryVersion) *pXFixesQueryVersion;
-
-    int event_base, error_base;
-    int major = 3, minor = 0;
-    void *handle;
-
-    handle = dlopen(SONAME_LIBXFIXES, RTLD_NOW);
-    if (!handle) return;
-
-    pXFixesQueryExtension = dlsym(handle, "XFixesQueryExtension");
-    if (!pXFixesQueryExtension) return;
-    pXFixesQueryVersion = dlsym(handle, "XFixesQueryVersion");
-    if (!pXFixesQueryVersion) return;
-    pXFixesSelectSelectionInput = dlsym(handle, "XFixesSelectSelectionInput");
-    if (!pXFixesSelectSelectionInput) return;
-
-    if (!pXFixesQueryExtension(clipboard_display, &event_base, &error_base))
-        return;
-    pXFixesQueryVersion(clipboard_display, &major, &minor);
-    use_xfixes = (major >= 1);
     if (!use_xfixes) return;

     pXFixesSelectSelectionInput(clipboard_display, import_window, x11drv_atom(CLIPBOARD),
@@ -2010,7 +1988,7 @@ static void xfixes_init(void)
                 XFixesSelectionWindowDestroyNotifyMask |
                 XFixesSelectionClientCloseNotifyMask);
     }
-    X11DRV_register_event_handler(event_base + XFixesSelectionNotify,
+    X11DRV_register_event_handler(xfixes_event_base + XFixesSelectionNotify,
             selection_notify_event, "XFixesSelectionNotify");
     TRACE("xfixes succesully initialized\n");
 #else
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index dd7b9be0524..8dc74aa2e39 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -435,6 +435,7 @@ extern BOOL show_systray DECLSPEC_HIDDEN;
 extern BOOL grab_pointer DECLSPEC_HIDDEN;
 extern BOOL grab_fullscreen DECLSPEC_HIDDEN;
 extern BOOL usexcomposite DECLSPEC_HIDDEN;
+extern BOOL use_xfixes DECLSPEC_HIDDEN;
 extern BOOL managed_mode DECLSPEC_HIDDEN;
 extern BOOL decorated_mode DECLSPEC_HIDDEN;
 extern BOOL private_color_map DECLSPEC_HIDDEN;
@@ -442,6 +443,7 @@ extern int primary_monitor DECLSPEC_HIDDEN;
 extern int copy_default_colors DECLSPEC_HIDDEN;
 extern int alloc_system_colors DECLSPEC_HIDDEN;
 extern int xrender_error_base DECLSPEC_HIDDEN;
+extern int xfixes_event_base DECLSPEC_HIDDEN;
 extern HMODULE x11drv_module DECLSPEC_HIDDEN;
 extern char *process_name DECLSPEC_HIDDEN;
 extern Display *clipboard_display DECLSPEC_HIDDEN;
diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index 32beb84a009..bf5cbaf7ef9 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -46,6 +46,7 @@

 #include "x11drv.h"
 #include "xcomposite.h"
+#include "xfixes.h"
 #include "wine/server.h"
 #include "wine/unicode.h"
 #include "wine/debug.h"
@@ -65,6 +66,7 @@ Window root_window;
 BOOL usexvidmode = TRUE;
 BOOL usexrandr = TRUE;
 BOOL usexcomposite = TRUE;
+BOOL use_xfixes = FALSE;
 BOOL use_xkb = TRUE;
 BOOL use_take_focus = TRUE;
 BOOL use_primary_selection = FALSE;
@@ -83,6 +85,7 @@ int copy_default_colors = 128;
 int alloc_system_colors = 256;
 DWORD thread_data_tls_index = TLS_OUT_OF_INDEXES;
 int xrender_error_base = 0;
+int xfixes_event_base = 0;
 HMODULE x11drv_module = 0;
 char *process_name = NULL;

@@ -510,6 +513,63 @@ static void X11DRV_XComposite_Init(void)
 }
 #endif /* defined(SONAME_LIBXCOMPOSITE) */

+#ifdef SONAME_LIBXFIXES
+
+#define MAKE_FUNCPTR(f) typeof(f) * p##f;
+MAKE_FUNCPTR(XFixesQueryExtension)
+MAKE_FUNCPTR(XFixesQueryVersion)
+MAKE_FUNCPTR(XFixesCreateRegion)
+MAKE_FUNCPTR(XFixesCreateRegionFromGC)
+MAKE_FUNCPTR(XFixesSelectSelectionInput)
+#undef MAKE_FUNCPTR
+
+static void x11drv_load_xfixes(void)
+{
+    int event, error, major = 3, minor = 0;
+    void *xfixes;
+
+    if (!(xfixes = dlopen(SONAME_LIBXFIXES, RTLD_NOW)))
+    {
+        WARN("Xfixes library %s not found, disabled.\n", SONAME_LIBXFIXES);
+        return;
+    }
+
+#define LOAD_FUNCPTR(f) \
+    if (!(p##f = dlsym(xfixes, #f)))                          \
+    {                                                         \
+        WARN("Xfixes function %s not found, disabled\n", #f); \
+        dlclose(xfixes);                                      \
+        return;                                               \
+    }
+    LOAD_FUNCPTR(XFixesQueryExtension)
+    LOAD_FUNCPTR(XFixesQueryVersion)
+    LOAD_FUNCPTR(XFixesCreateRegion)
+    LOAD_FUNCPTR(XFixesCreateRegionFromGC)
+    LOAD_FUNCPTR(XFixesSelectSelectionInput)
+#undef LOAD_FUNCPTR
+
+    if (!pXFixesQueryExtension(gdi_display, &event, &error))
+    {
+        WARN("Xfixes extension not found, disabled.\n");
+        dlclose(xfixes);
+        return;
+    }
+
+    if (!pXFixesQueryVersion(gdi_display, &major, &minor) ||
+        major < 2)
+    {
+        WARN("Xfixes version 2.0 not found, disabled.\n");
+        dlclose(xfixes);
+        return;
+    }
+
+    TRACE("Xfixes, error %d, event %d, version %d.%d found\n",
+          error, event, major, minor);
+    use_xfixes = TRUE;
+    xfixes_event_base = event;
+}
+#endif /* SONAME_LIBXFIXES */
+
 static void init_visuals( Display *display, int screen )
 {
     int count;
@@ -616,6 +676,9 @@ static BOOL process_attach(void)
     X11DRV_XF86VM_Init();
     /* initialize XRandR */
     X11DRV_XRandR_Init();
+#ifdef SONAME_LIBXFIXES
+    x11drv_load_xfixes();
+#endif
 #ifdef SONAME_LIBXCOMPOSITE
     X11DRV_XComposite_Init();
 #endif
diff --git a/dlls/winex11.drv/xfixes.h b/dlls/winex11.drv/xfixes.h
new file mode 100644
index 00000000000..3ab31201d3d
--- /dev/null
+++ b/dlls/winex11.drv/xfixes.h
@@ -0,0 +1,36 @@
+/*
+ * Wine X11DRV Xfixes interface
+ *
+ * Copyright 2021 Rémi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+#ifndef __WINE_XFIXES_H
+#define __WINE_XFIXES_H
+
+#ifndef __WINE_CONFIG_H
+# error You must include config.h to use this header
+#endif
+
+#ifdef SONAME_LIBXFIXES
+#include <X11/extensions/Xfixes.h>
+#define MAKE_FUNCPTR(f) extern typeof(f) * p##f DECLSPEC_HIDDEN;
+MAKE_FUNCPTR(XFixesQueryExtension)
+MAKE_FUNCPTR(XFixesQueryVersion)
+MAKE_FUNCPTR(XFixesSelectSelectionInput)
+#undef MAKE_FUNCPTR
+#endif /* defined(SONAME_LIBXFIXES) */
+
+#endif /* __WINE_XFIXES_H */
From a412390af147ece7fb1fb6c381fc6822cbc44915 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 30 Jan 2020 14:44:00 -0600
Subject: [PATCH] HACK: user32: Don't resize new windows to fit the display.

---
 dlls/user32/win.c    | 4 ++--
 dlls/user32/winpos.c | 2 --
 2 files changed, 2 insertions(+), 4 deletions(-)

diff --git a/dlls/user32/win.c b/dlls/user32/win.c
index 4f1f70d9802..0783daee5d9 100644
--- a/dlls/user32/win.c
+++ b/dlls/user32/win.c
@@ -1739,8 +1739,8 @@ HWND WIN_CreateWindowEx( CREATESTRUCTW *cs, LPCWSTR className, HINSTANCE module,
     if ((cs->style & WS_THICKFRAME) || !(cs->style & (WS_POPUP | WS_CHILD)))
     {
         MINMAXINFO info = WINPOS_GetMinMaxInfo( hwnd );
-        cx = max( min( cx, info.ptMaxTrackSize.x ), info.ptMinTrackSize.x );
-        cy = max( min( cy, info.ptMaxTrackSize.y ), info.ptMinTrackSize.y );
+        cx = max( cx, info.ptMinTrackSize.x );
+        cy = max( cy, info.ptMinTrackSize.y );
     }

     if (cx < 0) cx = 0;
diff --git a/dlls/user32/winpos.c b/dlls/user32/winpos.c
index ff23206b395..e03f1149914 100644
--- a/dlls/user32/winpos.c
+++ b/dlls/user32/winpos.c
@@ -1663,8 +1663,6 @@ LONG WINPOS_HandleWindowPosChanging( HWND hwnd, WINDOWPOS *winpos )
     if ((style & WS_THICKFRAME) || ((style & (WS_POPUP | WS_CHILD)) == 0))
     {
 	MINMAXINFO info = WINPOS_GetMinMaxInfo( hwnd );
-        winpos->cx = min( winpos->cx, info.ptMaxTrackSize.x );
-        winpos->cy = min( winpos->cy, info.ptMaxTrackSize.y );
 	if (!(style & WS_MINIMIZE))
 	{
             winpos->cx = max( winpos->cx, info.ptMinTrackSize.x );
From 728e589b581520fc430bcdbaca9ee618a2c873df Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 26 Feb 2021 08:59:56 -0600
Subject: [PATCH] HACK: winex11.drv: Add WM detection code.

---
 dlls/winex11.drv/window.c      | 78 ++++++++++++++++++++++++++++++++++
 dlls/winex11.drv/x11drv.h      |  6 +++
 dlls/winex11.drv/x11drv_main.c |  4 ++
 include/wine/gdi_driver.h      | 18 ++++++++
 4 files changed, 106 insertions(+)

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index f76e020323a..99d8fd3871e 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -106,6 +106,82 @@ static CRITICAL_SECTION_DEBUG critsect_debug =
 static CRITICAL_SECTION win_data_section = { &critsect_debug, -1, 0, 0, 0, 0 };


+static int detect_wm(Display *dpy)
+{
+    Display *display = dpy ? dpy : thread_init_display(); /* DefaultRootWindow is a macro... */
+    Window root = DefaultRootWindow(display), *wm_check;
+    Atom type;
+    int format;
+    unsigned long count, remaining;
+    char *wm_name;
+
+    static int cached = -1;
+
+    if(cached < 0){
+
+        if (XGetWindowProperty( display, root, x11drv_atom(_NET_SUPPORTING_WM_CHECK), 0,
+                                 sizeof(*wm_check)/sizeof(CARD32), False, x11drv_atom(WINDOW),
+                                 &type, &format, &count, &remaining, (unsigned char **)&wm_check ) == Success){
+            if (type == x11drv_atom(WINDOW)){
+                if(XGetWindowProperty( display, *wm_check, x11drv_atom(_NET_WM_NAME), 0,
+                            256/sizeof(CARD32), False, x11drv_atom(UTF8_STRING),
+                            &type, &format, &count, &remaining, (unsigned char **)&wm_name) == Success &&
+                        type == x11drv_atom(UTF8_STRING)){
+                    /* noop */
+                }else if(XGetWindowProperty( display, *wm_check, x11drv_atom(WM_NAME), 0,
+                            256/sizeof(CARD32), False, x11drv_atom(STRING),
+                            &type, &format, &count, &remaining, (unsigned char **)&wm_name) == Success &&
+                        type == x11drv_atom(STRING)){
+                    /* noop */
+                }else
+                    wm_name = NULL;
+
+                if(wm_name){
+                    TRACE("Got WM name %s\n", wm_name);
+
+                    if((strcmp(wm_name, "GNOME Shell") == 0) ||
+                            (strcmp(wm_name, "Mutter") == 0))
+                        cached = WINE_WM_X11_MUTTER;
+                    else if(strcmp(wm_name, "steamcompmgr") == 0)
+                        cached = WINE_WM_X11_STEAMCOMPMGR;
+                    else if(strcmp(wm_name, "KWin") == 0)
+                        cached = WINE_WM_X11_KDE;
+                    else
+                        cached = WINE_WM_UNKNOWN;
+
+                    XFree(wm_name);
+                }else{
+                    TRACE("WM did not set _NET_WM_NAME or WM_NAME\n");
+                    cached = WINE_WM_UNKNOWN;
+                }
+            }else
+                cached = WINE_WM_UNKNOWN;
+
+            XFree(wm_check);
+        }else
+            cached = WINE_WM_UNKNOWN;
+
+        __wine_set_window_manager(cached);
+    }
+
+    return cached;
+}
+
+BOOL wm_is_mutter(Display *display)
+{
+    return detect_wm(display) == WINE_WM_X11_MUTTER;
+}
+
+BOOL wm_is_kde(Display *display)
+{
+    return detect_wm(display) == WINE_WM_X11_KDE;
+}
+
+BOOL wm_is_steamcompmgr(Display *display)
+{
+    return detect_wm(display) == WINE_WM_X11_STEAMCOMPMGR;
+}
+
 /***********************************************************************
  * http://standards.freedesktop.org/startup-notification-spec
  */
@@ -1843,6 +1919,8 @@ BOOL CDECL X11DRV_CreateDesktopWindow( HWND hwnd )
 {
     unsigned int width, height;

+    detect_wm( gdi_display );
+
     /* retrieve the real size of the desktop */
     SERVER_START_REQ( get_window_rectangles )
     {
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 4e6dcceb441..91cb02b902e 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -462,6 +462,7 @@ enum x11drv_atoms
     XATOM_TEXT,
     XATOM_TIMESTAMP,
     XATOM_UTF8_STRING,
+    XATOM_STRING,
     XATOM_RAW_ASCENT,
     XATOM_RAW_DESCENT,
     XATOM_RAW_CAP_HEIGHT,
@@ -469,6 +470,7 @@ enum x11drv_atoms
     XATOM_Rel_Y,
     XATOM_WM_PROTOCOLS,
     XATOM_WM_DELETE_WINDOW,
+    XATOM_WM_NAME,
     XATOM_WM_STATE,
     XATOM_WM_TAKE_FOCUS,
     XATOM_DndProtocol,
@@ -478,6 +480,7 @@ enum x11drv_atoms
     XATOM__NET_STARTUP_INFO_BEGIN,
     XATOM__NET_STARTUP_INFO,
     XATOM__NET_SUPPORTED,
+    XATOM__NET_SUPPORTING_WM_CHECK,
     XATOM__NET_SYSTEM_TRAY_OPCODE,
     XATOM__NET_SYSTEM_TRAY_S0,
     XATOM__NET_SYSTEM_TRAY_VISUAL,
@@ -528,6 +531,7 @@ enum x11drv_atoms
     XATOM_WCF_SYLK,
     XATOM_WCF_TIFF,
     XATOM_WCF_WAVE,
+    XATOM_WINDOW,
     XATOM_image_bmp,
     XATOM_image_gif,
     XATOM_image_jpeg,
@@ -654,6 +658,8 @@ extern void change_systray_owner( Display *display, Window systray_window ) DECL
 extern void update_systray_balloon_position(void) DECLSPEC_HIDDEN;
 extern HWND create_foreign_window( Display *display, Window window ) DECLSPEC_HIDDEN;
 extern BOOL update_clipboard( HWND hwnd ) DECLSPEC_HIDDEN;
+extern BOOL wm_is_mutter(Display *) DECLSPEC_HIDDEN;
+extern BOOL wm_is_steamcompmgr(Display *) DECLSPEC_HIDDEN;

 static inline void mirror_rect( const RECT *window_rect, RECT *rect )
 {
diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index 6bf4a0a4211..c979f968877 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -146,6 +146,7 @@ static const char * const atom_names[NB_XATOMS - FIRST_XATOM] =
     "TEXT",
     "TIMESTAMP",
     "UTF8_STRING",
+    "STRING",
     "RAW_ASCENT",
     "RAW_DESCENT",
     "RAW_CAP_HEIGHT",
@@ -153,6 +154,7 @@ static const char * const atom_names[NB_XATOMS - FIRST_XATOM] =
     "Rel Y",
     "WM_PROTOCOLS",
     "WM_DELETE_WINDOW",
+    "WM_NAME",
     "WM_STATE",
     "WM_TAKE_FOCUS",
     "DndProtocol",
@@ -162,6 +164,7 @@ static const char * const atom_names[NB_XATOMS - FIRST_XATOM] =
     "_NET_STARTUP_INFO_BEGIN",
     "_NET_STARTUP_INFO",
     "_NET_SUPPORTED",
+    "_NET_SUPPORTING_WM_CHECK",
     "_NET_SYSTEM_TRAY_OPCODE",
     "_NET_SYSTEM_TRAY_S0",
     "_NET_SYSTEM_TRAY_VISUAL",
@@ -212,6 +215,7 @@ static const char * const atom_names[NB_XATOMS - FIRST_XATOM] =
     "WCF_SYLK",
     "WCF_TIFF",
     "WCF_WAVE",
+    "WINDOW",
     "image/bmp",
     "image/gif",
     "image/jpeg",
diff --git a/include/wine/gdi_driver.h b/include/wine/gdi_driver.h
index 567a6c21608..7e0135430e1 100644
--- a/include/wine/gdi_driver.h
+++ b/include/wine/gdi_driver.h
@@ -349,4 +349,22 @@ extern void CDECL __wine_set_display_driver( struct user_driver_funcs *funcs, UI
 extern struct opengl_funcs * CDECL __wine_get_wgl_driver( HDC hdc, UINT version );
 extern const struct vulkan_funcs * CDECL __wine_get_vulkan_driver( UINT version );

+/* HACK: We use some WM specific hacks in user32 and we need the user
+ * driver to export that information. */
+
+#define WINE_WM_UNKNOWN          0
+#define WINE_WM_X11_MUTTER       1
+#define WINE_WM_X11_STEAMCOMPMGR 2
+#define WINE_WM_X11_KDE          3
+
+static inline LONG_PTR __wine_get_window_manager(void)
+{
+    return (LONG_PTR)GetPropA(GetDesktopWindow(), "__wine_window_manager");
+}
+
+static inline void __wine_set_window_manager(LONG_PTR window_manager)
+{
+    SetPropA(GetDesktopWindow(), "__wine_window_manager", (HANDLE)window_manager);
+}
+
 #endif /* __WINE_WINE_GDI_DRIVER_H */

From 376cf4fd52c091b39b1373c4fc42d56b0c755512 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 12 Mar 2020 15:53:07 +0100
Subject: [PATCH] HACK: gamescope: user32: On steamcompmgr, don't limit window
 size to screen size

---
 dlls/user32/win.c    | 10 ++++++++++
 dlls/user32/winpos.c | 10 ++++++++++
 2 files changed, 20 insertions(+)

diff --git a/dlls/user32/win.c b/dlls/user32/win.c
index 0783daee5d9..4618c73d95f 100644
--- a/dlls/user32/win.c
+++ b/dlls/user32/win.c
@@ -1739,6 +1739,16 @@ HWND WIN_CreateWindowEx( CREATESTRUCTW *cs, LPCWSTR className, HINSTANCE module,
     if ((cs->style & WS_THICKFRAME) || !(cs->style & (WS_POPUP | WS_CHILD)))
     {
         MINMAXINFO info = WINPOS_GetMinMaxInfo( hwnd );
+
+        /* HACK: This code changes the window's size to fit the display. However,
+         * some games (Bayonetta, Dragon's Dogma) will then have the incorrect
+         * render size. So just let windows be too big to fit the display. */
+        if (__wine_get_window_manager() != WINE_WM_X11_STEAMCOMPMGR)
+        {
+            cx = min( cx, info.ptMaxTrackSize.x );
+            cy = min( cy, info.ptMaxTrackSize.y );
+        }
+
         cx = max( cx, info.ptMinTrackSize.x );
         cy = max( cy, info.ptMinTrackSize.y );
     }
diff --git a/dlls/user32/winpos.c b/dlls/user32/winpos.c
index e03f1149914..c5ecffa561c 100644
--- a/dlls/user32/winpos.c
+++ b/dlls/user32/winpos.c
@@ -1663,6 +1663,16 @@ LONG WINPOS_HandleWindowPosChanging( HWND hwnd, WINDOWPOS *winpos )
     if ((style & WS_THICKFRAME) || ((style & (WS_POPUP | WS_CHILD)) == 0))
     {
 	MINMAXINFO info = WINPOS_GetMinMaxInfo( hwnd );
+
+        /* HACK: This code changes the window's size to fit the display. However,
+         * some games (Bayonetta, Dragon's Dogma) will then have the incorrect
+         * render size. So just let windows be too big to fit the display. */
+        if (__wine_get_window_manager() != WINE_WM_X11_STEAMCOMPMGR)
+        {
+            winpos->cx = min( winpos->cx, info.ptMaxTrackSize.x );
+            winpos->cy = min( winpos->cy, info.ptMaxTrackSize.y );
+        }
+
 	if (!(style & WS_MINIMIZE))
 	{
             winpos->cx = max( winpos->cx, info.ptMinTrackSize.x );
From 8e7dcb8367325d91cfa2b7d6bd5e4495cda71889 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 16 Mar 2020 19:52:52 +0100
Subject: [PATCH] HACK: gamescope: user32: Pretend that windows are undecorated
 with gamescope.

The original commit made all window have their client rect always match
their window rects. This was to make sure games always use the full
available window size, even when windowed, and end up with an optimal
rendering area.

Some games, such as Bayonetta or Dragon's Dogma: Dark Arisen, ask for an
optimal window size, but, when in windowed mode, the client rect is then
adjusted to add a title bar and borders. On Windows, the back buffer is
always the requested size, but the rendering is then scaled to match the
client rect. With Proton and gamescope, we want to avoid this suboptimal
scaling, and make sure both front and back buffer are optimally sized,
including when in windowed mode.

Then, we still need to keep adjustments on WS_POPUP / WS_EX_TOOLWINDOW
windows:

This styles usually translates into a single pixel border, and is used
for splash screens. Several of them do not expect their client rect to
be sized as the window rect and it causes a visible 1px white border on
the bottom and the right of the window.

WS_EX_TOOLWINDOW should be safe enough, as it means the window is not
supposed to be displayed in the taskbar or in the alt-tab menu, which is
unlikely for an actual game window. WS_POPUP otoh means that only a 1px
border is used, which should not make much of a difference with an
undecorated window (although it could cause suboptimal client rect
sizes, which we wanted to solve in the first place).

CW-Bug-Id: #17639
CW-Bug-Id: #20038
---
 dlls/user32/nonclient.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/dlls/user32/nonclient.c b/dlls/user32/nonclient.c
index b47616bb639..ff9f9b8e197 100644
--- a/dlls/user32/nonclient.c
+++ b/dlls/user32/nonclient.c
@@ -28,6 +28,7 @@
 #include "user_private.h"
 #include "controls.h"
 #include "wine/debug.h"
+#include "wine/gdi_driver.h"

 WINE_DEFAULT_DEBUG_CHANNEL(nonclient);

@@ -60,6 +61,9 @@ static void adjust_window_rect( RECT *rect, DWORD style, BOOL menu, DWORD exStyl
 {
     int adjust = 0;

+    if (__wine_get_window_manager() == WINE_WM_X11_STEAMCOMPMGR && !((style & WS_POPUP) && (exStyle & WS_EX_TOOLWINDOW)))
+        return;
+
     if ((exStyle & (WS_EX_STATICEDGE|WS_EX_DLGMODALFRAME)) == WS_EX_STATICEDGE)
         adjust = 1; /* for the outer frame always present */
     else if ((exStyle & WS_EX_DLGMODALFRAME) || (style & (WS_THICKFRAME|WS_DLGFRAME)))
@@ -357,6 +361,9 @@ LRESULT NC_HandleNCCalcSize( HWND hwnd, WPARAM wparam, RECT *winRect )
     if (winRect == NULL)
         return 0;

+    if (__wine_get_window_manager() == WINE_WM_X11_STEAMCOMPMGR && !((style & WS_POPUP) && (exStyle & WS_EX_TOOLWINDOW)))
+        return 0;
+
     if (!(style & WS_MINIMIZE))
     {

From 132d293262d95a5ab8810ebbda13028fac2e9f78 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 28 May 2021 17:41:43 +0200
Subject: [PATCH] HACK: gamescope: winex11.drv: Disable gamescope hacks for
 Street Fighter V.

CW-Bug-Id: #18903
---
 dlls/winex11.drv/window.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 99d8fd3871e..01b12f96e03 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -114,6 +114,7 @@ static int detect_wm(Display *dpy)
     int format;
     unsigned long count, remaining;
     char *wm_name;
+    char const *sgi = getenv("SteamGameId");

     static int cached = -1;

@@ -161,6 +162,11 @@ static int detect_wm(Display *dpy)
         }else
             cached = WINE_WM_UNKNOWN;

+        /* Street Fighter V expects a certain sequence of window resizes
+           or gets stuck on startup. The AdjustWindowRect / WM_NCCALCSIZE
+           hacks confuse it completely, so let's disable them */
+        if (sgi && !strcmp(sgi, "310950")) cached = WINE_WM_UNKNOWN;
+
         __wine_set_window_manager(cached);
     }

From 7563c241f385299b4639c3b939558c2ba430886e Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 18 Sep 2018 14:48:58 -0500
Subject: [PATCH] winex11.drv: Allow the application to change window size and
 states during PropertyNotify.

On focus loss, fullscreened DDLC changes to a 1x1 pixel window and
minimizes. On restore, it un-minimizes and changes back to fullscreen
size. However, this restoring happens during the PropertyNotify handler,
which means we didn't update size or the NET_WM_STATEs.
---
 dlls/winex11.drv/window.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 01b12f96e03..294d84bfccc 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -2615,7 +2615,7 @@ void CDECL X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags
     }

     /* don't change position if we are about to minimize or maximize a managed window */
-    if (!event_type &&
+    if ((!event_type || event_type == PropertyNotify) &&
         !(data->managed && (swp_flags & SWP_STATECHANGED) && (new_style & (WS_MINIMIZE|WS_MAXIMIZE))))
         sync_window_position( data, swp_flags, &old_window_rect, &old_whole_rect, &old_client_rect );

@@ -2649,7 +2649,7 @@ void CDECL X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags
         else
         {
             if (swp_flags & (SWP_FRAMECHANGED|SWP_STATECHANGED)) set_wm_hints( data );
-            if (!event_type) update_net_wm_states( data );
+            if (!event_type || event_type == PropertyNotify) update_net_wm_states( data );
         }
     }

From 32821e17a97f4e0afb703eaf17280cadb8030a16 Mon Sep 17 00:00:00 2001
From: Alexey Prokhin <alexey@prokhin.ru>
Date: Wed, 17 Oct 2018 19:55:27 +0300
Subject: [PATCH] winex11.drv: Ignore clip_reset when trying to clip the mouse
 after the desktop has been resized.

This fixes the mouse clipping when the desktop is resized multiple times in a row.
---
 dlls/winex11.drv/mouse.c | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
index d02163cbaa8..d2ff071a9f2 100644
--- a/dlls/winex11.drv/mouse.c
+++ b/dlls/winex11.drv/mouse.c
@@ -579,9 +579,10 @@ BOOL clip_fullscreen_window( HWND hwnd, BOOL reset )
     release_win_data( data );
     if (!fullscreen) return FALSE;
     if (!(thread_data = x11drv_thread_data())) return FALSE;
-    if (GetTickCount() - thread_data->clip_reset < 1000) return FALSE;
-    if (!reset && clipping_cursor && thread_data->clip_hwnd) return FALSE;  /* already clipping */
-
+    if (!reset) {
+        if (GetTickCount() - thread_data->clip_reset < 1000) return FALSE;
+        if (!reset && clipping_cursor && thread_data->clip_hwnd) return FALSE;  /* already clipping */
+    }
     monitor = MonitorFromWindow( hwnd, MONITOR_DEFAULTTONEAREST );
     if (!monitor) return FALSE;
     monitor_info.cbSize = sizeof(monitor_info);
From 36535de250f26fbfd46c6383179e4c9bfe2ce956 Mon Sep 17 00:00:00 2001
From: Alexey Prokhin <alexey@prokhin.ru>
Date: Sat, 20 Oct 2018 18:07:12 +0300
Subject: [PATCH] winex11.drv: Enable fullscreen clipping even if not already
 clipping.

---
 dlls/winex11.drv/mouse.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
index d2ff071a9f2..9635d264e14 100644
--- a/dlls/winex11.drv/mouse.c
+++ b/dlls/winex11.drv/mouse.c
@@ -1571,12 +1571,12 @@ BOOL CDECL X11DRV_ClipCursor( LPCRECT clip )
         {
             if (grab_clipping_window( clip )) return TRUE;
         }
-        else /* if currently clipping, check if we should switch to fullscreen clipping */
+        else /* check if we should switch to fullscreen clipping */
         {
             struct x11drv_thread_data *data = x11drv_thread_data();
-            if (data && data->clip_hwnd)
+            if (data)
             {
-                if (EqualRect( clip, &clip_rect ) || clip_fullscreen_window( foreground, TRUE ))
+                if ((data->clip_hwnd && EqualRect( clip, &clip_rect ) && !EqualRect(&clip_rect, &virtual_rect)) || clip_fullscreen_window( foreground, TRUE ))
                     return TRUE;
             }
         }
From 3ebc519f891b4fe027e1161bebdcfd4eeed7c079 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 11 Jan 2019 11:31:13 -0600
Subject: [PATCH] winex11.drv: Don't show border if WS_CAPTION is unset.

Into the Breach wants a borderless window with WS_THICKFRAME. If we
leave the BORDER and RESIZEH styles on, then we get a window with a
border and a caption on Linux.
---
 dlls/winex11.drv/window.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 294d84bfccc..319a28d6fa3 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -414,7 +414,10 @@ static unsigned long get_mwm_decorations( struct x11drv_win_data *data,
         if (style & WS_MAXIMIZEBOX) ret |= MWM_DECOR_MAXIMIZE;
     }
     if (ex_style & WS_EX_DLGMODALFRAME) ret |= MWM_DECOR_BORDER;
-    else if (style & WS_THICKFRAME) ret |= MWM_DECOR_BORDER | MWM_DECOR_RESIZEH;
+    else if (style & WS_THICKFRAME){
+        if((style & WS_CAPTION) == WS_CAPTION)
+             ret |= MWM_DECOR_BORDER | MWM_DECOR_RESIZEH;
+    }
     else if ((style & (WS_DLGFRAME|WS_BORDER)) == WS_DLGFRAME) ret |= MWM_DECOR_BORDER;
     return ret;
 }
From 24d7f2bda1e98905206476fa3664ea8fa7bd7dd1 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 11 Jan 2019 11:34:03 -0600
Subject: [PATCH] winex11.drv: Ignore ConfigureNotify messages if there is a
 FULLSCREEN WM state pending.

Into the Breach goes fullscreen by first maximizing, then setting the
window to fullscreen in a separate call. Mutter processes the maximize
request _after_ Wine has sent the fullscreen request. As a result, we
get a ConfigureNotify for the size of the workspace when we expect the
window to be fullscreened. We then notify ITB that it is no longer
fullscreen, which begins the process over again, causing an infinite
loop.

This fixes that by setting a flag if we have a fullscreen request
pending and ignoring ConfigureNotify requests if it is set. We unset it
when we receive a _NET_WM_STATE PropertyNotify event that contains the
FULLSCREEN flag.
---
 dlls/winex11.drv/event.c  | 35 +++++++++++++++++++++++++++++++++++
 dlls/winex11.drv/window.c |  3 +++
 dlls/winex11.drv/x11drv.h |  1 +
 3 files changed, 39 insertions(+)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index b7f5614f222..42c66f911ce 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -1129,6 +1129,12 @@ static BOOL X11DRV_ConfigureNotify( HWND hwnd, XEvent *xev )
                event->serial, data->configure_serial );
         goto done;
     }
+    if (data->pending_fullscreen)
+    {
+        TRACE( "win %p/%lx event %d,%d,%dx%d pending_fullscreen is pending, so ignoring\n",
+               hwnd, data->whole_window, event->x, event->y, event->width, event->height );
+        goto done;
+    }

     /* Get geometry */

@@ -1362,15 +1368,44 @@ static void handle_wm_state_notify( HWND hwnd, XPropertyEvent *event, BOOL updat
 }


+static void handle__net_wm_state_notify( HWND hwnd, XPropertyEvent *event )
+{
+    struct x11drv_win_data *data = get_win_data( hwnd );
+
+    if(data->pending_fullscreen)
+    {
+        read_net_wm_states( event->display, data );
+        if(data->net_wm_state & (1 << NET_WM_STATE_FULLSCREEN)){
+            data->pending_fullscreen = FALSE;
+            TRACE("PropertyNotify _NET_WM_STATE, now 0x%x, pending_fullscreen no longer pending.\n",
+                    data->net_wm_state);
+        }else
+            TRACE("PropertyNotify _NET_WM_STATE, now 0x%x, pending_fullscreen still pending.\n",
+                    data->net_wm_state);
+    }
+
+    release_win_data( data );
+}
+
+
 /***********************************************************************
  *           X11DRV_PropertyNotify
  */
 static BOOL X11DRV_PropertyNotify( HWND hwnd, XEvent *xev )
 {
     XPropertyEvent *event = &xev->xproperty;
+    char *name;

     if (!hwnd) return FALSE;
+
+    name = XGetAtomName(event->display, event->atom);
+    if(name){
+        TRACE("win %p PropertyNotify atom: %s, state: 0x%x\n", hwnd, name, event->state);
+        XFree(name);
+    }
+
     if (event->atom == x11drv_atom(WM_STATE)) handle_wm_state_notify( hwnd, event, TRUE );
+    else if (event->atom == x11drv_atom(_NET_WM_STATE)) handle__net_wm_state_notify( hwnd, event );
     return TRUE;
 }

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 319a28d6fa3..1d42801291c 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -1260,6 +1260,7 @@ static void unmap_window( HWND hwnd )

         data->mapped = FALSE;
         data->net_wm_state = 0;
+        data->pending_fullscreen = FALSE;
     }
     release_win_data( data );
 }
@@ -1276,6 +1277,7 @@ void make_window_embedded( struct x11drv_win_data *data )
         if (!data->managed) XUnmapWindow( data->display, data->whole_window );
         else XWithdrawWindow( data->display, data->whole_window, data->vis.screen );
         data->net_wm_state = 0;
+        data->pending_fullscreen = FALSE;
     }
     data->embedded = TRUE;
     data->managed = TRUE;
@@ -1759,6 +1761,7 @@ static void destroy_whole_window( struct x11drv_win_data *data, BOOL already_des
     data->whole_colormap = 0;
     data->wm_state = WithdrawnState;
     data->net_wm_state = 0;
+    data->pending_fullscreen = FALSE;
     data->mapped = FALSE;
     if (data->xic)
     {
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 91cb02b902e..9767fdcf681 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -621,6 +621,7 @@ struct x11drv_win_data
     BOOL        use_alpha : 1;  /* does window use an alpha channel? */
     BOOL        skip_taskbar : 1; /* does window should be deleted from taskbar */
     BOOL        add_taskbar : 1; /* does window should be added to taskbar regardless of style */
+    BOOL        pending_fullscreen : 1;
     int         wm_state;       /* current value of the WM_STATE property */
     DWORD       net_wm_state;   /* bit mask of active x11drv_net_wm_state values */
     Window      embedder;       /* window id of embedder */
From b036845239c5b01f3715ef0d3b24e5044137836c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 26 Jun 2019 18:42:37 +0200
Subject: [PATCH] HACK: mutter: winex11.drv: Workaround mutter issue #649.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

When decorations are modified too quickly, mutter loses tracks of the
reparenting requests and does not gives focus back to the window.

Signed-off-by: Rémi Bernon <rbernon@codeweavers.com>
---
 dlls/winex11.drv/window.c | 43 ++++++++++++++++++++++++++++++++++++++-
 dlls/winex11.drv/x11drv.h |  4 ++++
 2 files changed, 46 insertions(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 1d42801291c..1b292df11fe 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -48,7 +48,6 @@
 #include "x11drv.h"
 #include "wine/debug.h"
 #include "wine/server.h"
-#include "mwm.h"

 WINE_DEFAULT_DEBUG_CHANNEL(x11drv);

@@ -814,6 +813,13 @@ static void set_size_hints( struct x11drv_win_data *data, DWORD style )
     XFree( size_hints );
 }

+static Bool is_unmap_notify( Display *display, XEvent *event, XPointer arg )
+{
+    struct x11drv_win_data *data = (struct x11drv_win_data *)arg;
+    return event->xany.serial >= data->unmapnotify_serial &&
+           event->xany.window == data->whole_window &&
+           event->type == UnmapNotify;
+}

 /***********************************************************************
  *              set_mwm_hints
@@ -821,6 +827,7 @@ static void set_size_hints( struct x11drv_win_data *data, DWORD style )
 static void set_mwm_hints( struct x11drv_win_data *data, DWORD style, DWORD ex_style )
 {
     MwmHints mwm_hints;
+    int enable_mutter_workaround, mapped;

     if (data->hwnd == GetDesktopWindow())
     {
@@ -848,12 +855,46 @@ static void set_mwm_hints( struct x11drv_win_data *data, DWORD style, DWORD ex_s
     TRACE( "%p setting mwm hints to %lx,%lx (style %x exstyle %x)\n",
            data->hwnd, mwm_hints.decorations, mwm_hints.functions, style, ex_style );

+    enable_mutter_workaround = wm_is_mutter(data->display) && GetFocus() == data->hwnd &&
+                               !!data->prev_hints.decorations != !!mwm_hints.decorations &&
+                               root_window == DefaultRootWindow(data->display);
+
+    /* workaround for mutter gitlab bug #649, we cannot trust the
+     * data->mapped flag as mapping is asynchronous.
+     */
+    if (enable_mutter_workaround)
+    {
+        XWindowAttributes attr;
+
+        mapped = data->mapped;
+        if (XGetWindowAttributes( data->display, data->whole_window, &attr ))
+            mapped = (attr.map_state != IsUnmapped);
+    }
+
     mwm_hints.flags = MWM_HINTS_FUNCTIONS | MWM_HINTS_DECORATIONS;
     mwm_hints.input_mode = 0;
     mwm_hints.status = 0;
+    data->unmapnotify_serial = NextRequest( data->display );
     XChangeProperty( data->display, data->whole_window, x11drv_atom(_MOTIF_WM_HINTS),
                      x11drv_atom(_MOTIF_WM_HINTS), 32, PropModeReplace,
                      (unsigned char*)&mwm_hints, sizeof(mwm_hints)/sizeof(long) );
+
+    if (enable_mutter_workaround)
+    {
+        XEvent event;
+
+        /* workaround for mutter gitlab bug #649, wait for the map notify
+         * event each time the decorations are modified before modifying
+         * them again.
+         */
+        if (mapped)
+        {
+            TRACE("workaround mutter bug #649, waiting for UnmapNotify\n");
+            XPeekIfEvent( data->display, &event, is_unmap_notify, (XPointer)data );
+        }
+    }
+
+    data->prev_hints = mwm_hints;
 }


diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 9767fdcf681..bd8492c57b7 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -62,6 +62,8 @@ typedef int Status;
 #include "wine/gdi_driver.h"
 #include "wine/list.h"

+#include "mwm.h"
+
 #define MAX_DASHLEN 16

 #define WINE_XDND_VERSION 5
@@ -625,12 +627,14 @@ struct x11drv_win_data
     int         wm_state;       /* current value of the WM_STATE property */
     DWORD       net_wm_state;   /* bit mask of active x11drv_net_wm_state values */
     Window      embedder;       /* window id of embedder */
+    unsigned long unmapnotify_serial; /* serial number of last UnmapNotify event */
     unsigned long configure_serial; /* serial number of last configure request */
     struct window_surface *surface;
     Pixmap         icon_pixmap;
     Pixmap         icon_mask;
     unsigned long *icon_bits;
     unsigned int   icon_size;
+    MwmHints prev_hints;
 };

 extern struct x11drv_win_data *get_win_data( HWND hwnd ) DECLSPEC_HIDDEN;
From fd82e3a50b586a6c1d05246b3ceb86cb00b59d9e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 24 Jul 2019 11:34:15 +0200
Subject: [PATCH] HACK: mutter: winex11.drv: Workaround mutter issue #676.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Changing decorations of a fullscreen and unredirected window breaks
compositing. So, we now ignore any decoration changes while window is
bypassing the compositor.

Decoration state will be restored as soon as the window changes its
state again. The windows are only bypassing compositor if they are also
fullscreen, so this should not have any visible side effect.

Signed-off-by: Rémi Bernon <rbernon@codeweavers.com>
---
 dlls/winex11.drv/event.c       | 13 +++++++++++++
 dlls/winex11.drv/window.c      | 29 ++++++++++++++++++++++++++++-
 dlls/winex11.drv/x11drv.h      |  3 +++
 dlls/winex11.drv/x11drv_main.c |  1 +
 4 files changed, 45 insertions(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index 42c66f911ce..f29e1bd7d1f 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -1404,6 +1404,19 @@ static BOOL X11DRV_PropertyNotify( HWND hwnd, XEvent *xev )
         XFree(name);
     }

+    if (event->atom == x11drv_atom(_NET_WM_BYPASS_COMPOSITOR))
+    {
+        struct x11drv_win_data *data = get_win_data( hwnd );
+        if (!data) return TRUE;
+
+        /* workaround for mutter gitlab bug #676, changing decorations of a
+         * fullscreen and unredirected window freezes the compositing.
+         */
+        if (wm_is_mutter( data->display )) set_wm_hints( data );
+
+        release_win_data( data );
+    }
+
     if (event->atom == x11drv_atom(WM_STATE)) handle_wm_state_notify( hwnd, event, TRUE );
     else if (event->atom == x11drv_atom(_NET_WM_STATE)) handle__net_wm_state_notify( hwnd, event );
     return TRUE;
diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 1b292df11fe..2c3a9c32bc6 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -829,6 +829,33 @@ static void set_mwm_hints( struct x11drv_win_data *data, DWORD style, DWORD ex_s
     MwmHints mwm_hints;
     int enable_mutter_workaround, mapped;

+    /* workaround for mutter gitlab bug #676, changing decorations of a
+     * fullscreen and unredirected window freezes the compositing.
+     * The window style will be updated again once the window has returned
+     * from fullscreen.
+     */
+    if (wm_is_mutter(data->display) && (data->net_wm_state & (1 << NET_WM_STATE_FULLSCREEN)))
+    {
+        Atom type;
+        int format;
+        unsigned long *property, net_wm_bypass_compositor = 0, count, remaining;
+
+        if (XGetWindowProperty( data->display, data->whole_window, x11drv_atom(_NET_WM_BYPASS_COMPOSITOR), 0,
+                                1, False, XA_CARDINAL, &type, &format, &count, &remaining,
+                                (unsigned char **)&property ) == Success &&
+            property)
+        {
+            net_wm_bypass_compositor = *property;
+            XFree(property);
+        }
+
+        if (net_wm_bypass_compositor)
+        {
+            TRACE("workaround mutter bug, ignoring decorations while compositor is bypassed\n");
+            return;
+        }
+    }
+
     if (data->hwnd == GetDesktopWindow())
     {
         if (is_desktop_fullscreen()) mwm_hints.decorations = 0;
@@ -1040,7 +1067,7 @@ static void make_owner_managed( HWND hwnd )
  *
  * Set all the window manager hints for a window.
  */
-static void set_wm_hints( struct x11drv_win_data *data )
+void set_wm_hints( struct x11drv_win_data *data )
 {
     DWORD style, ex_style;

diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index bd8492c57b7..86d44997f43 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -486,6 +486,7 @@ enum x11drv_atoms
     XATOM__NET_SYSTEM_TRAY_OPCODE,
     XATOM__NET_SYSTEM_TRAY_S0,
     XATOM__NET_SYSTEM_TRAY_VISUAL,
+    XATOM__NET_WM_BYPASS_COMPOSITOR,
     XATOM__NET_WM_ICON,
     XATOM__NET_WM_MOVERESIZE,
     XATOM__NET_WM_NAME,
@@ -666,6 +667,8 @@ extern BOOL update_clipboard( HWND hwnd ) DECLSPEC_HIDDEN;
 extern BOOL wm_is_mutter(Display *) DECLSPEC_HIDDEN;
 extern BOOL wm_is_steamcompmgr(Display *) DECLSPEC_HIDDEN;

+extern void set_wm_hints( struct x11drv_win_data *data ) DECLSPEC_HIDDEN;
+
 static inline void mirror_rect( const RECT *window_rect, RECT *rect )
 {
     int width = window_rect->right - window_rect->left;
diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index c979f968877..1e7c140641f 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -168,6 +168,7 @@ static const char * const atom_names[NB_XATOMS - FIRST_XATOM] =
     "_NET_SYSTEM_TRAY_OPCODE",
     "_NET_SYSTEM_TRAY_S0",
     "_NET_SYSTEM_TRAY_VISUAL",
+    "_NET_WM_BYPASS_COMPOSITOR",
     "_NET_WM_ICON",
     "_NET_WM_MOVERESIZE",
     "_NET_WM_NAME",
From 27dd29bb185d04018493cdd2a025ff4961121769 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 9 Dec 2019 20:28:20 +0100
Subject: [PATCH] HACK: mutter: winex11.drv: Add a bit of delay before
 restoring mouse grabs on FocusIn.

---
 dlls/winex11.drv/event.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index f29e1bd7d1f..77d2990f01e 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -821,6 +821,14 @@ static BOOL X11DRV_FocusIn( HWND hwnd, XEvent *xev )
     if (event->detail == NotifyPointer) return FALSE;
     if (hwnd == GetDesktopWindow()) return FALSE;

+    /* Focus was just restored but it can be right after super was
+     * pressed and gnome-shell needs a bit of time to respond and
+     * toggle the activity view. If we grab the cursor right away
+     * it will cancel it and super key will do nothing.
+     */
+    if (event->mode == NotifyUngrab && wm_is_mutter(event->display))
+        Sleep(100);
+
     /* ask the foreground window to re-apply the current ClipCursor rect */
     SendMessageW( GetForegroundWindow(), WM_X11DRV_CLIP_CURSOR_REQUEST, 0, 0 );

From 985434fc5279470782763af3da1b4afec57d7ce0 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 21 Aug 2018 14:47:33 -0500
Subject: [PATCH] HACK: mutter: winex11.drv: Workaround mutter issue #273.

This would cause fullscreen windows to lose keyboard focus.
---
 dlls/winex11.drv/event.c  | 18 ++++++++++++++++++
 dlls/winex11.drv/window.c |  8 ++++++++
 dlls/winex11.drv/x11drv.h |  1 +
 3 files changed, 27 insertions(+)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index 77d2990f01e..b59d4105557 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -870,9 +870,27 @@ static void focus_out( Display *display , HWND hwnd )
     Window focus_win;
     int revert;
     XIC xic;
+    struct x11drv_win_data *data;

     if (ximInComposeMode) return;

+    data = get_win_data(hwnd);
+    if(data){
+        ULONGLONG now = GetTickCount64();
+        if(data->take_focus_back > 0 &&
+                now >= data->take_focus_back &&
+                now - data->take_focus_back < 1000){
+            data->take_focus_back = 0;
+            TRACE("workaround mutter bug, taking focus back\n");
+            XSetInputFocus( data->display, data->whole_window, RevertToParent, CurrentTime);
+            release_win_data(data);
+            /* don't inform win32 client */
+            return;
+        }
+        data->take_focus_back = 0;
+        release_win_data(data);
+    }
+
     x11drv_thread_data()->last_focus = hwnd;
     if ((xic = X11DRV_get_ic( hwnd ))) XUnsetICFocus( xic );

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 2c3a9c32bc6..45a45a29f1a 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -921,6 +921,14 @@ static void set_mwm_hints( struct x11drv_win_data *data, DWORD style, DWORD ex_s
         }
     }

+    if (wm_is_mutter(data->display) && GetFocus() == data->hwnd &&
+            !!data->prev_hints.decorations != !!mwm_hints.decorations)
+    {
+        /* workaround for mutter gitlab bug #273 */
+        TRACE("workaround mutter bug, setting take_focus_back\n");
+        data->take_focus_back = GetTickCount64();
+    }
+
     data->prev_hints = mwm_hints;
 }

diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 86d44997f43..52990283ce7 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -625,6 +625,7 @@ struct x11drv_win_data
     BOOL        skip_taskbar : 1; /* does window should be deleted from taskbar */
     BOOL        add_taskbar : 1; /* does window should be added to taskbar regardless of style */
     BOOL        pending_fullscreen : 1;
+    ULONGLONG   take_focus_back;
     int         wm_state;       /* current value of the WM_STATE property */
     DWORD       net_wm_state;   /* bit mask of active x11drv_net_wm_state values */
     Window      embedder;       /* window id of embedder */
From d2c3166e776eb399cd6b9e94b6fc954591bebdc8 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 25 Sep 2020 12:58:52 +0300
Subject: [PATCH] HACK: mutter: winex11.drv: Avoid setting empty shape for
 window on mutter.

---
 dlls/winex11.drv/bitblt.c | 17 +++++++++++++++--
 1 file changed, 15 insertions(+), 2 deletions(-)

diff --git a/dlls/winex11.drv/bitblt.c b/dlls/winex11.drv/bitblt.c
index fad183b0b01..1254fff14bf 100644
--- a/dlls/winex11.drv/bitblt.c
+++ b/dlls/winex11.drv/bitblt.c
@@ -1736,8 +1736,21 @@ static void update_surface_region( struct x11drv_window_surface *surface )

     if ((data = X11DRV_GetRegionData( rgn, 0 )))
     {
-        XShapeCombineRectangles( gdi_display, surface->window, ShapeBounding, 0, 0,
-                                 (XRectangle *)data->Buffer, data->rdh.nCount, ShapeSet, YXBanded );
+        if (!data->rdh.nCount && wm_is_mutter(gdi_display))
+        {
+            XRectangle xrect;
+
+            xrect.x = xrect.y = -1;
+            xrect.width = 1;
+            xrect.height = 1;
+            XShapeCombineRectangles( gdi_display, surface->window, ShapeBounding, 0, 0,
+                                     &xrect, 1, ShapeSet, YXBanded );
+        }
+        else
+        {
+            XShapeCombineRectangles( gdi_display, surface->window, ShapeBounding, 0, 0,
+                                     (XRectangle *)data->Buffer, data->rdh.nCount, ShapeSet, YXBanded );
+        }
         HeapFree( GetProcessHeap(), 0, data );
     }

From 39000841d68b3d8401bd5602113fdc146fc1ee43 Mon Sep 17 00:00:00 2001
From: Arkadiusz Hiler <ahiler@codeweavers.com>
Date: Tue, 8 Jun 2021 16:01:54 +0300
Subject: [PATCH] winex11.drv: Send missed KEYUP events on KeymapNotify.

Full focus lost / focus gained events on the Windows side are not
feasible for X11's FocusIn/FocusOut events generated by keyboard grabs
(see XGrabKeyboard()) that are used for example for Atl+Tab handling.
Using them would degrade user's experience, especially with our full
screen hack, by causing the window to minimize or flash multiple times
depending on a game/window manager combo.

Because of that the programs may miss on some KEYUP events that happen
during the grab, and since there are no focus changes on the Windows
side the state doesn't get resynced.

This change attempts to improve user experience by syncing any missed
key release events that happened while the window haven't had focus on
the X11 side.

There's no syncing of key presses as those are more problematic because
of window manager quirks, e.g. on KDE it may end up syncing the Tab
press portion of Alt+Tab. Luckily missing key events for keys that were
pressed and not released while the WM had the keyboard grab is not
nearly as confusing as stuck keys.

For Warhammer: Chaosbane, theHunter: Call of the Wild, Far Cry Primal
and many other games that end up with stuck Alt after Alt+Tabbing.

CW-Bug-ID: #17046
CW-Bug-ID: #18904
---
 dlls/winex11.drv/event.c    |  2 ++
 dlls/winex11.drv/keyboard.c | 43 +++++++++++++++++++++++++++++++++++--
 dlls/winex11.drv/mouse.c    |  2 ++
 dlls/winex11.drv/x11drv.h   |  1 +
 4 files changed, 46 insertions(+), 2 deletions(-)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index b59d4105557..271a70940f1 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -821,6 +821,8 @@ static BOOL X11DRV_FocusIn( HWND hwnd, XEvent *xev )
     if (event->detail == NotifyPointer) return FALSE;
     if (hwnd == GetDesktopWindow()) return FALSE;

+    x11drv_thread_data()->keymapnotify_hwnd = hwnd;
+
     /* Focus was just restored but it can be right after super was
      * pressed and gnome-shell needs a bit of time to respond and
      * toggle the activity view. If we grab the cursor right away
diff --git a/dlls/winex11.drv/keyboard.c b/dlls/winex11.drv/keyboard.c
index d04d1db9102..720b4869544 100644
--- a/dlls/winex11.drv/keyboard.c
+++ b/dlls/winex11.drv/keyboard.c
@@ -1209,11 +1209,19 @@ BOOL X11DRV_KeymapNotify( HWND hwnd, XEvent *event )
     int i, j;
     BYTE keystate[256];
     WORD vkey;
+    DWORD flags;
+    KeyCode keycode;
+    HWND keymapnotify_hwnd;
     BOOL changed = FALSE;
     struct {
         WORD vkey;
+        WORD scan;
         WORD pressed;
     } keys[256];
+    struct x11drv_thread_data *thread_data = x11drv_thread_data();
+
+    keymapnotify_hwnd = thread_data->keymapnotify_hwnd;
+    thread_data->keymapnotify_hwnd = NULL;

     if (!get_async_key_state( keystate )) return FALSE;

@@ -1228,11 +1236,17 @@ BOOL X11DRV_KeymapNotify( HWND hwnd, XEvent *event )
     {
         for (j = 0; j < 8; j++)
         {
-            vkey = keyc2vkey[(i * 8) + j];
+            keycode = (i * 8) + j;
+            vkey = keyc2vkey[keycode];

             /* If multiple keys map to the same vkey, we want to report it as
              * pressed iff any of them are pressed. */
-            if (!keys[vkey & 0xff].vkey) keys[vkey & 0xff].vkey = vkey;
+            if (!keys[vkey & 0xff].vkey)
+            {
+                keys[vkey & 0xff].vkey = vkey;
+                keys[vkey & 0xff].scan = keyc2scan[keycode] & 0xff;
+            }
+
             if (event->xkeymap.key_vector[i] & (1<<j)) keys[vkey & 0xff].pressed = TRUE;
         }
     }
@@ -1244,6 +1258,31 @@ BOOL X11DRV_KeymapNotify( HWND hwnd, XEvent *event )
             TRACE( "Adjusting state for vkey %#.2x. State before %#.2x\n",
                    keys[vkey].vkey, keystate[vkey]);

+            /* This KeymapNotify follows a FocusIn(mode=NotifyUngrab) event,
+             * which is caused by a keyboard grab being released.
+             * See XGrabKeyboard().
+             *
+             * We might have missed some key press/release events while the
+             * keyboard was grabbed, but keyboard grab doesn't generate focus
+             * lost / focus gained events on the Windows side, so the affected
+             * program is not aware that it needs to resync the keyboard state.
+             *
+             * This, for example, may cause Alt being stuck after using Alt+Tab.
+             *
+             * To work around that problem we sync any possible key releases.
+             *
+             * Syncing key presses is not feasible as window managers differ in
+             * event sequences, e.g. KDE performs two keyboard grabs for
+             * Alt+Tab, which would sync the Tab press.
+             */
+            if (keymapnotify_hwnd && !keys[vkey].pressed)
+            {
+                TRACE( "Sending KEYUP for a modifier %#.2x\n", vkey);
+                flags = KEYEVENTF_KEYUP;
+                if (keys[vkey].vkey & 0x1000) flags |= KEYEVENTF_EXTENDEDKEY;
+                X11DRV_send_keyboard_input( keymapnotify_hwnd, vkey, keys[vkey].scan, flags, GetTickCount() );
+            }
+
             update_key_state( keystate, vkey, keys[vkey].pressed );
             changed = TRUE;
         }
diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
index 321b631d6ca..511550a8486 100644
--- a/dlls/winex11.drv/mouse.c
+++ b/dlls/winex11.drv/mouse.c
@@ -1796,6 +1796,8 @@ BOOL X11DRV_EnterNotify( HWND hwnd, XEvent *xev )

     TRACE( "hwnd %p/%lx pos %d,%d detail %d\n", hwnd, event->window, event->x, event->y, event->detail );

+    x11drv_thread_data()->keymapnotify_hwnd = hwnd;
+
     if (event->detail == NotifyVirtual) return FALSE;
     if (hwnd == x11drv_thread_data()->grab_hwnd) return FALSE;

diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 52990283ce7..213143014a7 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -369,6 +369,7 @@ struct x11drv_thread_data
     XEvent  *current_event;        /* event currently being processed */
     HWND     grab_hwnd;            /* window that currently grabs the mouse */
     HWND     last_focus;           /* last window that had focus */
+    HWND     keymapnotify_hwnd;    /* window that should receive modifier release events */
     XIM      xim;                  /* input method */
     HWND     last_xic_hwnd;        /* last xic window */
     XFontSet font_set;             /* international text drawing font set */
From 695c72575c72161501a2ac508ba1db649e96d1dd Mon Sep 17 00:00:00 2001
From: Arkadiusz Hiler <ahiler@codeweavers.com>
Date: Fri, 2 Jul 2021 16:01:28 +0300
Subject: [PATCH] user32: Allow the backends to defer restoring minimized
 windows.

When restoring a minimized window the WM_SYSCOMMAND SC_RESTORE message
should arrive after WM_NCACTIVATE but before WM_ACTIVATE and WM_SETFOCUS.

Some games depend on that ordering and the related window state.

For example Project CARS 3 expects window to be both active and in the
foreground (wrt GetActiveWindow() and GetForegroundWindow()) when
receiving those messages.

Without being active the window doesn't restore properly, see
82c6ec3a32f4 ("winex11.drv: Activate window when restoring from iconic state.")

But if the activate messages arrive before the window is in the
foreground, the game tries to re-acquire DirectInput DISCL_FOREGROUND
devices too early and fails, which results in non-working keyboards and
controllers.

CW-Bug-Id: #19011
---
 dlls/win32u/input.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/dlls/win32u/input.c b/dlls/win32u/input.c
index 34cc3880cc9..2e1362eaff5 100644
--- a/dlls/win32u/input.c
+++ b/dlls/win32u/input.c
@@ -1222,6 +1222,12 @@ static BOOL set_active_window( HWND hwnd, HWND *prev, BOOL mouse, BOOL focus )
                       (LPARAM)previous );
         if (NtUserGetAncestor( hwnd, GA_PARENT ) == get_desktop_window())
             post_message( get_desktop_window(), WM_PARENTNOTIFY, WM_NCACTIVATE, (LPARAM)hwnd );
+
+        if (NtUserGetProp( hwnd, L"__WINE_RESTORE_WINDOW" ))
+        {
+            NtUserSetProp( hwnd, L"__WINE_RESTORE_WINDOW", NULL );
+            send_message( hwnd, WM_SYSCOMMAND, SC_RESTORE, 0 );
+        }
     }

     /* now change focus if necessary */
From ed85dc3dd49a6aae8347dae8a3b4300713fc3f6d Mon Sep 17 00:00:00 2001
From: Arkadiusz Hiler <ahiler@codeweavers.com>
Date: Fri, 2 Jul 2021 16:01:29 +0300
Subject: [PATCH] winex11.drv: Use __WINE_RESTORE_PROPERTY so Window is
 un-minimized on FocusIn.

On X11 / XWayland the PropertyNotify for WM_STATE change from
IconicState to NormalState arrives before the WM_TAKE_FOCUS
ClientMessage or the FocusIn event.

Converting that state change too early to a WM_SYSCOMMAND SC_RESTORE
message results in it (and the ACTIVATE events because of the previous
HAX) arriving without the window being set to foregrounds first.

This breaks the expectations of Project CARS 3 which tries on window
activation / restoration to re-acquire DirectInput devices with
cooperative level set to DISCL_FOREGROUND, which fails.

Signed-off-by: Arkadiusz Hiler <ahiler@codeweavers.com>

CW-Bug-Id: #19011
---
 dlls/winex11.drv/event.c | 11 +++++++----
 1 file changed, 7 insertions(+), 4 deletions(-)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index 271a70940f1..3a903eebd7e 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -80,6 +80,8 @@ extern BOOL ximInComposeMode;
 #define XEMBED_UNREGISTER_ACCELERATOR 13
 #define XEMBED_ACTIVATE_ACCELERATOR   14

+static const WCHAR restore_window_propW[] = {'_','_','W','I','N','E','_','R','E','S','T','O','R','E','_','W','I','N','D','O','W',0};
+
 Bool (*pXGetEventData)( Display *display, XEvent /*XGenericEventCookie*/ *event ) = NULL;
 void (*pXFreeEventData)( Display *display, XEvent /*XGenericEventCookie*/ *event ) = NULL;

@@ -586,7 +588,7 @@ static inline BOOL can_activate_window( HWND hwnd )

     if (!(style & WS_VISIBLE)) return FALSE;
     if ((style & (WS_POPUP|WS_CHILD)) == WS_CHILD) return FALSE;
-    if (style & WS_MINIMIZE) return FALSE;
+    if ((style & WS_MINIMIZE) && !GetPropW( hwnd, restore_window_propW )) return FALSE;
     if (GetWindowLongW( hwnd, GWL_EXSTYLE ) & WS_EX_NOACTIVATE) return FALSE;
     if (hwnd == GetDesktopWindow()) return FALSE;
     if (GetWindowRect( hwnd, &rect ) && IsRectEmpty( &rect )) return FALSE;
@@ -1371,9 +1373,10 @@ static void handle_wm_state_notify( HWND hwnd, XPropertyEvent *event, BOOL updat
             {
                 TRACE( "restoring win %p/%lx\n", data->hwnd, data->whole_window );
                 release_win_data( data );
-                if ((style & (WS_MINIMIZE | WS_VISIBLE)) == (WS_MINIMIZE | WS_VISIBLE))
-                    SetActiveWindow( hwnd );
-                SendMessageW( hwnd, WM_SYSCOMMAND, SC_RESTORE, 0 );
+                if ((style & (WS_MINIMIZE | WS_VISIBLE)) == (WS_MINIMIZE | WS_VISIBLE) && GetActiveWindow() != hwnd)
+                    SetPropW( hwnd, restore_window_propW, (HANDLE) TRUE );
+                else
+                    SendMessageW( hwnd, WM_SYSCOMMAND, SC_RESTORE, 0 );
                 return;
             }
             TRACE( "not restoring win %p/%lx style %08x\n", data->hwnd, data->whole_window, style );
From f7c3d6caddfa5f34f11a063021444389c697e8e8 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Sat, 11 Dec 2021 13:28:36 +0100
Subject: [PATCH] winevulkan: Fullscreen hack

Includes work by Georg Lehmann, Zhiyi Zhang, Brendan Shanks, and Joshua
Ashton.
---
 dlls/winevulkan/make_vulkan      |   19 +-
 dlls/winevulkan/vulkan.c         | 1397 ++++++++++++++++++++++++++++++
 dlls/winevulkan/vulkan_private.h |   38 +
 3 files changed, 1449 insertions(+), 5 deletions(-)

diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index 360b2087eb9..705a4a6e24e 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -228,11 +228,11 @@ FUNCTION_OVERRIDES = {

     # VK_KHR_swapchain
     "vkAcquireNextImageKHR" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
-    "vkAcquireNextImage2KHR": {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
-    "vkCreateSwapchainKHR" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
-    "vkDestroySwapchainKHR" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
-    "vkGetSwapchainImagesKHR": {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
-    "vkQueuePresentKHR": {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
+    "vkAcquireNextImage2KHR": {"dispatch" : True, "driver" : True, "thunk" : ThunkType.NONE},
+    "vkCreateSwapchainKHR" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.NONE},
+    "vkDestroySwapchainKHR" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.NONE},
+    "vkGetSwapchainImagesKHR": {"dispatch" : True, "driver" : True, "thunk" : ThunkType.NONE},
+    "vkQueuePresentKHR": {"dispatch" : True, "driver" : True, "thunk" : ThunkType.NONE},

     # VK_KHR_external_fence_capabilities
     "vkGetPhysicalDeviceExternalFencePropertiesKHR" : {"dispatch" : False, "driver" : False, "thunk" : ThunkType.NONE},
@@ -1083,6 +1083,8 @@ class VkHandle(object):
     def native_handle(self, name):
         """ Provide access to the native handle of a wrapped object. """

+        if self.name == "VkSwapchainKHR":
+            return "((struct VkSwapchainKHR_T *)(uintptr_t) ({0}))->swapchain".format(name)
         if self.name == "VkCommandPool":
             return "wine_cmd_pool_from_handle({0})->command_pool".format(name)
         if self.name == "VkDebugUtilsMessengerEXT":
@@ -2580,6 +2658,12 @@ class VkGenerator(object):
         f.write("\n")
         f.write("    /* winevulkan specific functions */\n")
         f.write("    VkSurfaceKHR (*p_wine_get_native_surface)(VkSurfaceKHR);\n")
+        f.write("\n    /* Optional. Returns TRUE if FS hack is active, otherwise returns FALSE. If\n")
+        f.write("     * it returns TRUE, then real_sz will contain the actual display\n")
+        f.write("     * resolution; user_sz will contain the app's requested mode; and dst_blit\n")
+        f.write("     * will contain the area to blit the user image to in real coordinates.\n")
+        f.write("     * All parameters are optional. */\n")
+        f.write("    VkBool32 (*query_fs_hack)(VkSurfaceKHR surface, VkExtent2D *real_sz, VkExtent2D *user_sz, VkRect2D *dst_blit, VkFilter *filter);\n")
         f.write("};\n\n")

         f.write("extern const struct vulkan_funcs * CDECL __wine_get_vulkan_driver(HDC hdc, UINT version);\n\n")
diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index 9f12660a407..3c8bd452eca 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -22,6 +22,7 @@
 #endif

 #include "config.h"
+#include <math.h>
 #include <time.h>
 #include <stdlib.h>

@@ -1657,6 +1658,751 @@ NTSTATUS wine_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(void *args)
     return STATUS_SUCCESS;
 }

+VkResult WINAPI wine_vkSetPrivateDataEXT(VkDevice device, VkObjectType object_type, uint64_t object_handle,
+        VkPrivateDataSlotEXT private_data_slot, uint64_t data)
+{
+    TRACE("%p, %#x, 0x%s, 0x%s, 0x%s\n", device, object_type, wine_dbgstr_longlong(object_handle),
+            wine_dbgstr_longlong(private_data_slot), wine_dbgstr_longlong(data));
+
+    object_handle = wine_vk_unwrap_handle(object_type, object_handle);
+    return device->funcs.p_vkSetPrivateDataEXT(device->device, object_type, object_handle, private_data_slot, data);
+}
+
+void WINAPI wine_vkGetPrivateDataEXT(VkDevice device, VkObjectType object_type, uint64_t object_handle,
+        VkPrivateDataSlotEXT private_data_slot, uint64_t *data)
+{
+    TRACE("%p, %#x, 0x%s, 0x%s, %p\n", device, object_type, wine_dbgstr_longlong(object_handle),
+            wine_dbgstr_longlong(private_data_slot), data);
+
+    object_handle = wine_vk_unwrap_handle(object_type, object_handle);
+    device->funcs.p_vkGetPrivateDataEXT(device->device, object_type, object_handle, private_data_slot, data);
+}
+
+/*
+#version 450
+
+layout(binding = 0) uniform sampler2D texSampler;
+layout(binding = 1, rgba8) uniform writeonly image2D outImage;
+layout(push_constant) uniform pushConstants {
+    //both in real image coords
+    vec2 offset;
+    vec2 extents;
+} constants;
+
+layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
+
+void main()
+{
+    vec2 texcoord = (vec2(gl_GlobalInvocationID.xy) - constants.offset) / constants.extents;
+    vec4 c = texture(texSampler, texcoord);
+    imageStore(outImage, ivec2(gl_GlobalInvocationID.xy), c.bgra);
+}
+*/
+const uint32_t blit_comp_spv[] = {
+    0x07230203,0x00010000,0x00080006,0x00000037,0x00000000,0x00020011,0x00000001,0x0006000b,
+    0x00000001,0x4c534c47,0x6474732e,0x3035342e,0x00000000,0x0003000e,0x00000000,0x00000001,
+    0x0006000f,0x00000005,0x00000004,0x6e69616d,0x00000000,0x0000000d,0x00060010,0x00000004,
+    0x00000011,0x00000008,0x00000008,0x00000001,0x00030003,0x00000002,0x000001c2,0x00040005,
+    0x00000004,0x6e69616d,0x00000000,0x00050005,0x00000009,0x63786574,0x64726f6f,0x00000000,
+    0x00080005,0x0000000d,0x475f6c67,0x61626f6c,0x766e496c,0x7461636f,0x496e6f69,0x00000044,
+    0x00060005,0x00000012,0x68737570,0x736e6f43,0x746e6174,0x00000073,0x00050006,0x00000012,
+    0x00000000,0x7366666f,0x00007465,0x00050006,0x00000012,0x00000001,0x65747865,0x0073746e,
+    0x00050005,0x00000014,0x736e6f63,0x746e6174,0x00000073,0x00030005,0x00000021,0x00000063,
+    0x00050005,0x00000025,0x53786574,0x6c706d61,0x00007265,0x00050005,0x0000002c,0x4974756f,
+    0x6567616d,0x00000000,0x00040047,0x0000000d,0x0000000b,0x0000001c,0x00050048,0x00000012,
+    0x00000000,0x00000023,0x00000000,0x00050048,0x00000012,0x00000001,0x00000023,0x00000008,
+    0x00030047,0x00000012,0x00000002,0x00040047,0x00000025,0x00000022,0x00000000,0x00040047,
+    0x00000025,0x00000021,0x00000000,0x00040047,0x0000002c,0x00000022,0x00000000,0x00040047,
+    0x0000002c,0x00000021,0x00000001,0x00030047,0x0000002c,0x00000019,0x00040047,0x00000036,
+    0x0000000b,0x00000019,0x00020013,0x00000002,0x00030021,0x00000003,0x00000002,0x00030016,
+    0x00000006,0x00000020,0x00040017,0x00000007,0x00000006,0x00000002,0x00040020,0x00000008,
+    0x00000007,0x00000007,0x00040015,0x0000000a,0x00000020,0x00000000,0x00040017,0x0000000b,
+    0x0000000a,0x00000003,0x00040020,0x0000000c,0x00000001,0x0000000b,0x0004003b,0x0000000c,
+    0x0000000d,0x00000001,0x00040017,0x0000000e,0x0000000a,0x00000002,0x0004001e,0x00000012,
+    0x00000007,0x00000007,0x00040020,0x00000013,0x00000009,0x00000012,0x0004003b,0x00000013,
+    0x00000014,0x00000009,0x00040015,0x00000015,0x00000020,0x00000001,0x0004002b,0x00000015,
+    0x00000016,0x00000000,0x00040020,0x00000017,0x00000009,0x00000007,0x0004002b,0x00000015,
+    0x0000001b,0x00000001,0x00040017,0x0000001f,0x00000006,0x00000004,0x00040020,0x00000020,
+    0x00000007,0x0000001f,0x00090019,0x00000022,0x00000006,0x00000001,0x00000000,0x00000000,
+    0x00000000,0x00000001,0x00000000,0x0003001b,0x00000023,0x00000022,0x00040020,0x00000024,
+    0x00000000,0x00000023,0x0004003b,0x00000024,0x00000025,0x00000000,0x0004002b,0x00000006,
+    0x00000028,0x00000000,0x00090019,0x0000002a,0x00000006,0x00000001,0x00000000,0x00000000,
+    0x00000000,0x00000002,0x00000004,0x00040020,0x0000002b,0x00000000,0x0000002a,0x0004003b,
+    0x0000002b,0x0000002c,0x00000000,0x00040017,0x00000030,0x00000015,0x00000002,0x0004002b,
+    0x0000000a,0x00000034,0x00000008,0x0004002b,0x0000000a,0x00000035,0x00000001,0x0006002c,
+    0x0000000b,0x00000036,0x00000034,0x00000034,0x00000035,0x00050036,0x00000002,0x00000004,
+    0x00000000,0x00000003,0x000200f8,0x00000005,0x0004003b,0x00000008,0x00000009,0x00000007,
+    0x0004003b,0x00000020,0x00000021,0x00000007,0x0004003d,0x0000000b,0x0000000f,0x0000000d,
+    0x0007004f,0x0000000e,0x00000010,0x0000000f,0x0000000f,0x00000000,0x00000001,0x00040070,
+    0x00000007,0x00000011,0x00000010,0x00050041,0x00000017,0x00000018,0x00000014,0x00000016,
+    0x0004003d,0x00000007,0x00000019,0x00000018,0x00050083,0x00000007,0x0000001a,0x00000011,
+    0x00000019,0x00050041,0x00000017,0x0000001c,0x00000014,0x0000001b,0x0004003d,0x00000007,
+    0x0000001d,0x0000001c,0x00050088,0x00000007,0x0000001e,0x0000001a,0x0000001d,0x0003003e,
+    0x00000009,0x0000001e,0x0004003d,0x00000023,0x00000026,0x00000025,0x0004003d,0x00000007,
+    0x00000027,0x00000009,0x00070058,0x0000001f,0x00000029,0x00000026,0x00000027,0x00000002,
+    0x00000028,0x0003003e,0x00000021,0x00000029,0x0004003d,0x0000002a,0x0000002d,0x0000002c,
+    0x0004003d,0x0000000b,0x0000002e,0x0000000d,0x0007004f,0x0000000e,0x0000002f,0x0000002e,
+    0x0000002e,0x00000000,0x00000001,0x0004007c,0x00000030,0x00000031,0x0000002f,0x0004003d,
+    0x0000001f,0x00000032,0x00000021,0x0009004f,0x0000001f,0x00000033,0x00000032,0x00000032,
+    0x00000002,0x00000001,0x00000000,0x00000003,0x00040063,0x0000002d,0x00000031,0x00000033,
+    0x000100fd,0x00010038
+};
+
+static VkResult create_pipeline(VkDevice device, struct VkSwapchainKHR_T *swapchain, VkShaderModule shaderModule)
+{
+    VkResult res;
+#if defined(USE_STRUCT_CONVERSION)
+    VkComputePipelineCreateInfo_host pipelineInfo = {0};
+#else
+    VkComputePipelineCreateInfo pipelineInfo = {0};
+#endif
+
+    pipelineInfo.sType = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;
+    pipelineInfo.stage.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
+    pipelineInfo.stage.stage = VK_SHADER_STAGE_COMPUTE_BIT;
+    pipelineInfo.stage.module = shaderModule;
+    pipelineInfo.stage.pName = "main";
+    pipelineInfo.layout = swapchain->pipeline_layout;
+    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;
+    pipelineInfo.basePipelineIndex = -1;
+
+    res = device->funcs.p_vkCreateComputePipelines(device->device, VK_NULL_HANDLE, 1, &pipelineInfo, NULL, &swapchain->pipeline);
+    if(res != VK_SUCCESS){
+        ERR("vkCreateComputePipelines: %d\n", res);
+        return res;
+    }
+
+    return VK_SUCCESS;
+}
+
+static VkResult create_descriptor_set(VkDevice device, struct VkSwapchainKHR_T *swapchain, struct fs_hack_image *hack)
+{
+    VkResult res;
+#if defined(USE_STRUCT_CONVERSION)
+    VkDescriptorSetAllocateInfo_host descriptorAllocInfo = {0};
+    VkWriteDescriptorSet_host descriptorWrites[2] = {{0}, {0}};
+    VkDescriptorImageInfo_host userDescriptorImageInfo = {0}, realDescriptorImageInfo = {0};
+#else
+    VkDescriptorSetAllocateInfo descriptorAllocInfo = {0};
+    VkWriteDescriptorSet descriptorWrites[2] = {{0}, {0}};
+    VkDescriptorImageInfo userDescriptorImageInfo = {0}, realDescriptorImageInfo = {0};
+#endif
+
+    descriptorAllocInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
+    descriptorAllocInfo.descriptorPool = swapchain->descriptor_pool;
+    descriptorAllocInfo.descriptorSetCount = 1;
+    descriptorAllocInfo.pSetLayouts = &swapchain->descriptor_set_layout;
+
+    res = device->funcs.p_vkAllocateDescriptorSets(device->device, &descriptorAllocInfo, &hack->descriptor_set);
+    if(res != VK_SUCCESS){
+        ERR("vkAllocateDescriptorSets: %d\n", res);
+        return res;
+    }
+
+    userDescriptorImageInfo.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
+    userDescriptorImageInfo.imageView = hack->user_view;
+    userDescriptorImageInfo.sampler = swapchain->sampler;
+
+    realDescriptorImageInfo.imageLayout = VK_IMAGE_LAYOUT_GENERAL;
+    realDescriptorImageInfo.imageView = hack->blit_view;
+
+    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
+    descriptorWrites[0].dstSet = hack->descriptor_set;
+    descriptorWrites[0].dstBinding = 0;
+    descriptorWrites[0].dstArrayElement = 0;
+    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
+    descriptorWrites[0].descriptorCount = 1;
+    descriptorWrites[0].pImageInfo = &userDescriptorImageInfo;
+
+    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
+    descriptorWrites[1].dstSet = hack->descriptor_set;
+    descriptorWrites[1].dstBinding = 1;
+    descriptorWrites[1].dstArrayElement = 0;
+    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;
+    descriptorWrites[1].descriptorCount = 1;
+    descriptorWrites[1].pImageInfo = &realDescriptorImageInfo;
+
+    device->funcs.p_vkUpdateDescriptorSets(device->device, 2, descriptorWrites, 0, NULL);
+
+    return VK_SUCCESS;
+}
+
+static VkResult init_blit_images(VkDevice device, struct VkSwapchainKHR_T *swapchain)
+{
+    VkResult res;
+    VkSamplerCreateInfo samplerInfo = {0};
+    VkDescriptorPoolSize poolSizes[2] = {{0}, {0}};
+    VkDescriptorPoolCreateInfo poolInfo = {0};
+    VkDescriptorSetLayoutBinding layoutBindings[2] = {{0}, {0}};
+    VkDescriptorSetLayoutCreateInfo descriptorLayoutInfo = {0};
+    VkPipelineLayoutCreateInfo pipelineLayoutInfo = {0};
+    VkPushConstantRange pushConstants;
+    VkShaderModuleCreateInfo shaderInfo = {0};
+    VkShaderModule shaderModule = 0;
+    VkDeviceSize blitMemTotal = 0, offs;
+    VkImageCreateInfo imageInfo = {0};
+#if defined(USE_STRUCT_CONVERSION)
+    VkMemoryRequirements_host blitMemReq;
+    VkMemoryAllocateInfo_host allocInfo = {0};
+    VkPhysicalDeviceMemoryProperties_host memProperties;
+    VkImageViewCreateInfo_host viewInfo = {0};
+#else
+    VkMemoryRequirements blitMemReq;
+    VkMemoryAllocateInfo allocInfo = {0};
+    VkPhysicalDeviceMemoryProperties memProperties;
+    VkImageViewCreateInfo viewInfo = {0};
+#endif
+    uint32_t blit_memory_type = -1, i;
+
+    samplerInfo.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
+    samplerInfo.magFilter = swapchain->fs_hack_filter;
+    samplerInfo.minFilter = swapchain->fs_hack_filter;
+    samplerInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER;
+    samplerInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER;
+    samplerInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER;
+    samplerInfo.anisotropyEnable = VK_FALSE;
+    samplerInfo.maxAnisotropy = 1;
+    samplerInfo.borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK;
+    samplerInfo.unnormalizedCoordinates = VK_FALSE;
+    samplerInfo.compareEnable = VK_FALSE;
+    samplerInfo.compareOp = VK_COMPARE_OP_ALWAYS;
+    samplerInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;
+    samplerInfo.mipLodBias = 0.0f;
+    samplerInfo.minLod = 0.0f;
+    samplerInfo.maxLod = 0.0f;
+
+    res = device->funcs.p_vkCreateSampler(device->device, &samplerInfo, NULL, &swapchain->sampler);
+    if(res != VK_SUCCESS)
+    {
+        WARN("vkCreateSampler failed, res=%d\n", res);
+        return res;
+    }
+
+    poolSizes[0].type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
+    poolSizes[0].descriptorCount = swapchain->n_images;
+    poolSizes[1].type = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;
+    poolSizes[1].descriptorCount = swapchain->n_images;
+
+    poolInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
+    poolInfo.poolSizeCount = 2;
+    poolInfo.pPoolSizes = poolSizes;
+    poolInfo.maxSets = swapchain->n_images;
+
+    res = device->funcs.p_vkCreateDescriptorPool(device->device, &poolInfo, NULL, &swapchain->descriptor_pool);
+    if(res != VK_SUCCESS){
+        ERR("vkCreateDescriptorPool: %d\n", res);
+        goto fail;
+    }
+
+    layoutBindings[0].binding = 0;
+    layoutBindings[0].descriptorCount = 1;
+    layoutBindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
+    layoutBindings[0].pImmutableSamplers = NULL;
+    layoutBindings[0].stageFlags = VK_SHADER_STAGE_COMPUTE_BIT;
+
+    layoutBindings[1].binding = 1;
+    layoutBindings[1].descriptorCount = 1;
+    layoutBindings[1].descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;
+    layoutBindings[1].pImmutableSamplers = NULL;
+    layoutBindings[1].stageFlags = VK_SHADER_STAGE_COMPUTE_BIT;
+
+    descriptorLayoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
+    descriptorLayoutInfo.bindingCount = 2;
+    descriptorLayoutInfo.pBindings = layoutBindings;
+
+    res = device->funcs.p_vkCreateDescriptorSetLayout(device->device, &descriptorLayoutInfo, NULL, &swapchain->descriptor_set_layout);
+    if(res != VK_SUCCESS){
+        ERR("vkCreateDescriptorSetLayout: %d\n", res);
+        goto fail;
+    }
+
+    pushConstants.stageFlags = VK_SHADER_STAGE_COMPUTE_BIT;
+    pushConstants.offset = 0;
+    pushConstants.size = 4 * sizeof(float); /* 2 * vec2 */
+
+    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
+    pipelineLayoutInfo.setLayoutCount = 1;
+    pipelineLayoutInfo.pSetLayouts = &swapchain->descriptor_set_layout;
+    pipelineLayoutInfo.pushConstantRangeCount = 1;
+    pipelineLayoutInfo.pPushConstantRanges = &pushConstants;
+
+    res = device->funcs.p_vkCreatePipelineLayout(device->device, &pipelineLayoutInfo, NULL, &swapchain->pipeline_layout);
+    if(res != VK_SUCCESS){
+        ERR("vkCreatePipelineLayout: %d\n", res);
+        goto fail;
+    }
+
+    shaderInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
+    shaderInfo.codeSize = sizeof(blit_comp_spv);
+    shaderInfo.pCode = blit_comp_spv;
+
+    res = device->funcs.p_vkCreateShaderModule(device->device, &shaderInfo, NULL, &shaderModule);
+    if(res != VK_SUCCESS){
+        ERR("vkCreateShaderModule: %d\n", res);
+        goto fail;
+    }
+
+    res = create_pipeline(device, swapchain, shaderModule);
+    if(res != VK_SUCCESS)
+        goto fail;
+
+    device->funcs.p_vkDestroyShaderModule(device->device, shaderModule, NULL);
+
+    if(!(swapchain->surface_usage & VK_IMAGE_USAGE_STORAGE_BIT)){
+        TRACE("using intermediate blit images\n");
+        /* create intermediate blit images */
+        for(i = 0; i < swapchain->n_images; ++i){
+            struct fs_hack_image *hack = &swapchain->fs_hack_images[i];
+
+            imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
+            imageInfo.imageType = VK_IMAGE_TYPE_2D;
+            imageInfo.extent.width = swapchain->real_extent.width;
+            imageInfo.extent.height = swapchain->real_extent.height;
+            imageInfo.extent.depth = 1;
+            imageInfo.mipLevels = 1;
+            imageInfo.arrayLayers = 1;
+            imageInfo.format = VK_FORMAT_R8G8B8A8_UNORM;
+            imageInfo.tiling = VK_IMAGE_TILING_OPTIMAL;
+            imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
+            imageInfo.usage = VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT;
+            imageInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
+            imageInfo.samples = VK_SAMPLE_COUNT_1_BIT;
+            res = device->funcs.p_vkCreateImage(device->device, &imageInfo, NULL, &hack->blit_image);
+            if(res != VK_SUCCESS){
+                ERR("vkCreateImage failed: %d\n", res);
+                goto fail;
+            }
+
+            device->funcs.p_vkGetImageMemoryRequirements(device->device, hack->blit_image, &blitMemReq);
+
+            offs = blitMemTotal % blitMemReq.alignment;
+            if(offs)
+                blitMemTotal += blitMemReq.alignment - offs;
+
+            blitMemTotal += blitMemReq.size;
+        }
+
+        /* allocate backing memory */
+        device->phys_dev->instance->funcs.p_vkGetPhysicalDeviceMemoryProperties(device->phys_dev->phys_dev, &memProperties);
+
+        for(i = 0; i < memProperties.memoryTypeCount; i++){
+            if((memProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT) == VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT){
+                if(blitMemReq.memoryTypeBits & (1 << i)){
+                    blit_memory_type = i;
+                    break;
+                }
+            }
+        }
+
+        if(blit_memory_type == -1){
+            ERR("unable to find suitable memory type\n");
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto fail;
+        }
+
+        allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
+        allocInfo.allocationSize = blitMemTotal;
+        allocInfo.memoryTypeIndex = blit_memory_type;
+
+        res = device->funcs.p_vkAllocateMemory(device->device, &allocInfo, NULL, &swapchain->blit_image_memory);
+        if(res != VK_SUCCESS){
+            ERR("vkAllocateMemory: %d\n", res);
+            goto fail;
+        }
+
+        /* bind backing memory and create imageviews */
+        blitMemTotal = 0;
+        for(i = 0; i < swapchain->n_images; ++i){
+            struct fs_hack_image *hack = &swapchain->fs_hack_images[i];
+
+            device->funcs.p_vkGetImageMemoryRequirements(device->device, hack->blit_image, &blitMemReq);
+
+            offs = blitMemTotal % blitMemReq.alignment;
+            if(offs)
+                blitMemTotal += blitMemReq.alignment - offs;
+
+            res = device->funcs.p_vkBindImageMemory(device->device, hack->blit_image, swapchain->blit_image_memory, blitMemTotal);
+            if(res != VK_SUCCESS){
+                ERR("vkBindImageMemory: %d\n", res);
+                goto fail;
+            }
+
+            blitMemTotal += blitMemReq.size;
+        }
+    }else
+        TRACE("blitting directly to swapchain images\n");
+
+    /* create imageviews */
+    for(i = 0; i < swapchain->n_images; ++i){
+        struct fs_hack_image *hack = &swapchain->fs_hack_images[i];
+
+        viewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
+        viewInfo.image = hack->blit_image ? hack->blit_image : hack->swapchain_image;
+        viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
+        viewInfo.format = VK_FORMAT_R8G8B8A8_UNORM;
+        viewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+        viewInfo.subresourceRange.baseMipLevel = 0;
+        viewInfo.subresourceRange.levelCount = 1;
+        viewInfo.subresourceRange.baseArrayLayer = 0;
+        viewInfo.subresourceRange.layerCount = 1;
+
+        res = device->funcs.p_vkCreateImageView(device->device, &viewInfo, NULL, &hack->blit_view);
+        if(res != VK_SUCCESS){
+            ERR("vkCreateImageView(blit): %d\n", res);
+            goto fail;
+        }
+
+        res = create_descriptor_set(device, swapchain, hack);
+        if(res != VK_SUCCESS)
+            goto fail;
+    }
+
+    return VK_SUCCESS;
+
+fail:
+    for(i = 0; i < swapchain->n_images; ++i){
+        struct fs_hack_image *hack = &swapchain->fs_hack_images[i];
+
+        device->funcs.p_vkDestroyImageView(device->device, hack->blit_view, NULL);
+        hack->blit_view = VK_NULL_HANDLE;
+
+        device->funcs.p_vkDestroyImage(device->device, hack->blit_image, NULL);
+        hack->blit_image = VK_NULL_HANDLE;
+    }
+
+    device->funcs.p_vkDestroyShaderModule(device->device, shaderModule, NULL);
+
+    device->funcs.p_vkDestroyPipeline(device->device, swapchain->pipeline, NULL);
+    swapchain->pipeline = VK_NULL_HANDLE;
+
+    device->funcs.p_vkDestroyPipelineLayout(device->device, swapchain->pipeline_layout, NULL);
+    swapchain->pipeline_layout = VK_NULL_HANDLE;
+
+    device->funcs.p_vkDestroyDescriptorSetLayout(device->device, swapchain->descriptor_set_layout, NULL);
+    swapchain->descriptor_set_layout = VK_NULL_HANDLE;
+
+    device->funcs.p_vkDestroyDescriptorPool(device->device, swapchain->descriptor_pool, NULL);
+    swapchain->descriptor_pool = VK_NULL_HANDLE;
+
+    device->funcs.p_vkFreeMemory(device->device, swapchain->blit_image_memory, NULL);
+    swapchain->blit_image_memory = VK_NULL_HANDLE;
+
+    device->funcs.p_vkDestroySampler(device->device, swapchain->sampler, NULL);
+    swapchain->sampler = VK_NULL_HANDLE;
+
+    return res;
+}
+
+static void destroy_fs_hack_image(VkDevice device, struct VkSwapchainKHR_T *swapchain, struct fs_hack_image *hack)
+{
+    device->funcs.p_vkDestroyImageView(device->device, hack->user_view, NULL);
+    device->funcs.p_vkDestroyImageView(device->device, hack->blit_view, NULL);
+    device->funcs.p_vkDestroyImage(device->device, hack->user_image, NULL);
+    device->funcs.p_vkDestroyImage(device->device, hack->blit_image, NULL);
+    if(hack->cmd)
+        device->funcs.p_vkFreeCommandBuffers(device->device,
+                swapchain->cmd_pools[hack->cmd_queue_idx],
+                    1, &hack->cmd);
+    device->funcs.p_vkDestroySemaphore(device->device, hack->blit_finished, NULL);
+}
+
+#if defined(USE_STRUCT_CONVERSION)
+static VkResult init_fs_hack_images(VkDevice device, struct VkSwapchainKHR_T *swapchain, VkSwapchainCreateInfoKHR_host *createinfo)
+#else
+static VkResult init_fs_hack_images(VkDevice device, struct VkSwapchainKHR_T *swapchain, VkSwapchainCreateInfoKHR *createinfo)
+#endif
+{
+    VkResult res;
+    VkImage *real_images = NULL;
+    VkDeviceSize userMemTotal = 0, offs;
+    VkImageCreateInfo imageInfo = {0};
+    VkSemaphoreCreateInfo semaphoreInfo = {0};
+#if defined(USE_STRUCT_CONVERSION)
+    VkMemoryRequirements_host userMemReq;
+    VkMemoryAllocateInfo_host allocInfo = {0};
+    VkPhysicalDeviceMemoryProperties_host memProperties;
+    VkImageViewCreateInfo_host viewInfo = {0};
+#else
+    VkMemoryRequirements userMemReq;
+    VkMemoryAllocateInfo allocInfo = {0};
+    VkPhysicalDeviceMemoryProperties memProperties;
+    VkImageViewCreateInfo viewInfo = {0};
+#endif
+    uint32_t count, i = 0, user_memory_type = -1;
+
+    res = device->funcs.p_vkGetSwapchainImagesKHR(device->device, swapchain->swapchain, &count, NULL);
+    if(res != VK_SUCCESS)
+    {
+        WARN("vkGetSwapchainImagesKHR failed, res=%d\n", res);
+        return res;
+    }
+
+    real_images = malloc(count * sizeof(VkImage));
+    swapchain->cmd_pools = calloc(device->queue_count, sizeof(VkCommandPool));
+    swapchain->fs_hack_images = calloc(count, sizeof(struct fs_hack_image));
+    if(!real_images || !swapchain->cmd_pools || !swapchain->fs_hack_images)
+        goto fail;
+
+    res = device->funcs.p_vkGetSwapchainImagesKHR(device->device, swapchain->swapchain, &count, real_images);
+    if(res != VK_SUCCESS)
+    {
+        WARN("vkGetSwapchainImagesKHR failed, res=%d\n", res);
+        goto fail;
+    }
+
+    /* create user images */
+    for(i = 0; i < count; ++i){
+        struct fs_hack_image *hack = &swapchain->fs_hack_images[i];
+
+        hack->swapchain_image = real_images[i];
+
+        semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
+        res = device->funcs.p_vkCreateSemaphore(device->device, &semaphoreInfo, NULL, &hack->blit_finished);
+        if(res != VK_SUCCESS)
+        {
+            WARN("vkCreateSemaphore failed, res=%d\n", res);
+            goto fail;
+        }
+
+        imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
+        imageInfo.imageType = VK_IMAGE_TYPE_2D;
+        imageInfo.extent.width = swapchain->user_extent.width;
+        imageInfo.extent.height = swapchain->user_extent.height;
+        imageInfo.extent.depth = 1;
+        imageInfo.mipLevels = 1;
+        imageInfo.arrayLayers = createinfo->imageArrayLayers;
+        imageInfo.format = createinfo->imageFormat;
+        imageInfo.tiling = VK_IMAGE_TILING_OPTIMAL;
+        imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
+        imageInfo.usage = createinfo->imageUsage | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT;
+        imageInfo.sharingMode = createinfo->imageSharingMode;
+        imageInfo.samples = VK_SAMPLE_COUNT_1_BIT;
+        imageInfo.queueFamilyIndexCount = createinfo->queueFamilyIndexCount;
+        imageInfo.pQueueFamilyIndices = createinfo->pQueueFamilyIndices;
+        res = device->funcs.p_vkCreateImage(device->device, &imageInfo, NULL, &hack->user_image);
+        if(res != VK_SUCCESS){
+            ERR("vkCreateImage failed: %d\n", res);
+            goto fail;
+        }
+
+        device->funcs.p_vkGetImageMemoryRequirements(device->device, hack->user_image, &userMemReq);
+
+        offs = userMemTotal % userMemReq.alignment;
+        if(offs)
+            userMemTotal += userMemReq.alignment - offs;
+
+        userMemTotal += userMemReq.size;
+
+        swapchain->n_images++;
+    }
+
+    /* allocate backing memory */
+    device->phys_dev->instance->funcs.p_vkGetPhysicalDeviceMemoryProperties(device->phys_dev->phys_dev, &memProperties);
+
+    for (i = 0; i < memProperties.memoryTypeCount; i++){
+        if((memProperties.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT) == VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT){
+            if(userMemReq.memoryTypeBits & (1 << i)){
+                user_memory_type = i;
+                break;
+            }
+        }
+    }
+
+    if(user_memory_type == -1){
+        ERR("unable to find suitable memory type\n");
+        res = VK_ERROR_OUT_OF_HOST_MEMORY;
+        goto fail;
+    }
+
+    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
+    allocInfo.allocationSize = userMemTotal;
+    allocInfo.memoryTypeIndex = user_memory_type;
+
+    res = device->funcs.p_vkAllocateMemory(device->device, &allocInfo, NULL, &swapchain->user_image_memory);
+    if(res != VK_SUCCESS){
+        ERR("vkAllocateMemory: %d\n", res);
+        goto fail;
+    }
+
+    /* bind backing memory and create imageviews */
+    userMemTotal = 0;
+    for(i = 0; i < count; ++i){
+        device->funcs.p_vkGetImageMemoryRequirements(device->device, swapchain->fs_hack_images[i].user_image, &userMemReq);
+
+        offs = userMemTotal % userMemReq.alignment;
+        if(offs)
+            userMemTotal += userMemReq.alignment - offs;
+
+        res = device->funcs.p_vkBindImageMemory(device->device, swapchain->fs_hack_images[i].user_image, swapchain->user_image_memory, userMemTotal);
+        if(res != VK_SUCCESS){
+            ERR("vkBindImageMemory: %d\n", res);
+            goto fail;
+        }
+
+        userMemTotal += userMemReq.size;
+
+        viewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
+        viewInfo.image = swapchain->fs_hack_images[i].user_image;
+        viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
+        viewInfo.format = createinfo->imageFormat;
+        viewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+        viewInfo.subresourceRange.baseMipLevel = 0;
+        viewInfo.subresourceRange.levelCount = 1;
+        viewInfo.subresourceRange.baseArrayLayer = 0;
+        viewInfo.subresourceRange.layerCount = 1;
+
+        res = device->funcs.p_vkCreateImageView(device->device, &viewInfo, NULL, &swapchain->fs_hack_images[i].user_view);
+        if(res != VK_SUCCESS){
+            ERR("vkCreateImageView(user): %d\n", res);
+            goto fail;
+        }
+    }
+
+    free(real_images);
+
+    return VK_SUCCESS;
+
+fail:
+    for(i = 0; i < swapchain->n_images; ++i)
+        destroy_fs_hack_image(device, swapchain, &swapchain->fs_hack_images[i]);
+    free(real_images);
+    free(swapchain->cmd_pools);
+    free(swapchain->fs_hack_images);
+    return res;
+}
+
+#if defined(USE_STRUCT_CONVERSION)
+static inline void convert_VkSwapchainCreateInfoKHR_win_to_host(const VkSwapchainCreateInfoKHR *in, VkSwapchainCreateInfoKHR_host *out)
+#else
+static inline void convert_VkSwapchainCreateInfoKHR_win_to_host(const VkSwapchainCreateInfoKHR *in, VkSwapchainCreateInfoKHR *out)
+#endif
+{
+    if (!in) return;
+
+    out->sType = in->sType;
+    out->pNext = in->pNext;
+    out->flags = in->flags;
+    out->surface = wine_surface_from_handle(in->surface)->driver_surface;
+    out->minImageCount = in->minImageCount;
+    out->imageFormat = in->imageFormat;
+    out->imageColorSpace = in->imageColorSpace;
+    out->imageExtent = in->imageExtent;
+    out->imageArrayLayers = in->imageArrayLayers;
+    out->imageUsage = in->imageUsage;
+    out->imageSharingMode = in->imageSharingMode;
+    out->queueFamilyIndexCount = in->queueFamilyIndexCount;
+    out->pQueueFamilyIndices = in->pQueueFamilyIndices;
+    out->preTransform = in->preTransform;
+    out->compositeAlpha = in->compositeAlpha;
+    out->presentMode = in->presentMode;
+    out->clipped = in->clipped;
+    out->oldSwapchain = in->oldSwapchain;
+}
+
+NTSTATUS wine_vkCreateSwapchainKHR(void *args)
+{
+    struct vkCreateSwapchainKHR_params *params = args;
+    VkDevice device = params->device;
+    const VkSwapchainCreateInfoKHR *create_info = params->pCreateInfo;
+    const VkAllocationCallbacks *allocator = params->pAllocator;
+    VkSwapchainKHR *swapchain = params->pSwapchain;
+#if defined(USE_STRUCT_CONVERSION)
+    VkSwapchainCreateInfoKHR_host native_info;
+#else
+    VkSwapchainCreateInfoKHR native_info;
+#endif
+    VkResult result;
+    VkExtent2D user_sz;
+    struct VkSwapchainKHR_T *object;
+
+    TRACE("%p, %p, %p, %p\n", device, create_info, allocator, swapchain);
+
+    if (!(object = calloc(1, sizeof(*object))))
+    {
+        ERR("Failed to allocate memory for swapchain\n");
+        return VK_ERROR_OUT_OF_HOST_MEMORY;
+    }
+
+    convert_VkSwapchainCreateInfoKHR_win_to_host(create_info, &native_info);
+
+    if(native_info.oldSwapchain)
+        native_info.oldSwapchain = ((struct VkSwapchainKHR_T *)(UINT_PTR)native_info.oldSwapchain)->swapchain;
+
+    if(vk_funcs->query_fs_hack &&
+            vk_funcs->query_fs_hack(native_info.surface, &object->real_extent, &user_sz, &object->blit_dst, &object->fs_hack_filter) &&
+            native_info.imageExtent.width == user_sz.width &&
+            native_info.imageExtent.height == user_sz.height)
+    {
+        uint32_t count;
+        VkSurfaceCapabilitiesKHR caps = {0};
+
+        device->phys_dev->instance->funcs.p_vkGetPhysicalDeviceQueueFamilyProperties(device->phys_dev->phys_dev, &count, NULL);
+
+        device->queue_props = malloc(sizeof(VkQueueFamilyProperties) * count);
+
+        device->phys_dev->instance->funcs.p_vkGetPhysicalDeviceQueueFamilyProperties(device->phys_dev->phys_dev, &count, device->queue_props);
+
+        result = device->phys_dev->instance->funcs.p_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device->phys_dev->phys_dev, native_info.surface, &caps);
+        if(result != VK_SUCCESS)
+        {
+            TRACE("vkGetPhysicalDeviceSurfaceCapabilities failed, res=%d\n", result);
+            free(object);
+            return result;
+        }
+
+        object->surface_usage = caps.supportedUsageFlags;
+        TRACE("surface usage flags: 0x%x\n", object->surface_usage);
+
+        native_info.imageExtent = object->real_extent;
+        native_info.imageUsage |= VK_IMAGE_USAGE_TRANSFER_DST_BIT; /* XXX: check if supported by surface */
+
+        if(native_info.imageFormat != VK_FORMAT_B8G8R8A8_UNORM &&
+                native_info.imageFormat != VK_FORMAT_B8G8R8A8_SRGB){
+            FIXME("swapchain image format is not BGRA8 UNORM/SRGB. Things may go badly. %d\n", native_info.imageFormat);
+        }
+
+        object->fs_hack_enabled = TRUE;
+    }
+
+    result = device->funcs.p_vkCreateSwapchainKHR(device->device, &native_info, NULL, &object->swapchain);
+    if(result != VK_SUCCESS)
+    {
+        TRACE("vkCreateSwapchainKHR failed, res=%d\n", result);
+        free(object);
+        return result;
+    }
+
+    WINE_VK_ADD_NON_DISPATCHABLE_MAPPING(device->phys_dev->instance, object, object->swapchain);
+
+    if(object->fs_hack_enabled){
+        object->user_extent = create_info->imageExtent;
+
+        result = init_fs_hack_images(device, object, &native_info);
+        if(result != VK_SUCCESS){
+            ERR("creating fs hack images failed: %d\n", result);
+            device->funcs.p_vkDestroySwapchainKHR(device->device, object->swapchain, NULL);
+            WINE_VK_REMOVE_HANDLE_MAPPING(device->phys_dev->instance, object);
+            free(object);
+            return result;
+        }
+
+        /* FIXME: would be nice to do this on-demand, but games can use up all
+         * memory so we fail to allocate later */
+        result = init_blit_images(device, object);
+        if(result != VK_SUCCESS){
+            ERR("creating blit images failed: %d\n", result);
+            device->funcs.p_vkDestroySwapchainKHR(device->device, object->swapchain, NULL);
+            WINE_VK_REMOVE_HANDLE_MAPPING(device->phys_dev->instance, object);
+            free(object);
+            return result;
+        }
+    }
+
+    *swapchain = (uint64_t)(UINT_PTR)object;
+
+    return result;
+}
+
 NTSTATUS wine_vkCreateWin32SurfaceKHR(void *args)
 {
     struct vkCreateWin32SurfaceKHR_params *params = args;
@@ -1736,6 +2482,7 @@ NTSTATUS wine_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(void *args)
     VkSurfaceKHR surface = params->surface;
     VkSurfaceCapabilitiesKHR *capabilities = params->pSurfaceCapabilities;
     VkResult res;
+    VkExtent2D user_res;

     TRACE("%p, 0x%s, %p\n", phys_dev, wine_dbgstr_longlong(surface), capabilities);

@@ -1744,6 +2491,13 @@ NTSTATUS wine_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(void *args)
     if (res == VK_SUCCESS)
         adjust_max_image_count(phys_dev, capabilities);

+    if (res == VK_SUCCESS && vk_funcs->query_fs_hack &&
+            vk_funcs->query_fs_hack(wine_surface_from_handle(surface)->driver_surface, NULL, &user_res, NULL, NULL)){
+        capabilities->currentExtent = user_res;
+        capabilities->minImageExtent = user_res;
+        capabilities->maxImageExtent = user_res;
+    }
+
     return res;
 }

@@ -1754,6 +2508,7 @@ NTSTATUS wine_vkGetPhysicalDeviceSurfaceCapabilities2KHR(void *args)
     const VkPhysicalDeviceSurfaceInfo2KHR *surface_info = params->pSurfaceInfo;
     VkSurfaceCapabilities2KHR *capabilities = params->pSurfaceCapabilities;
     VkResult res;
+    VkExtent2D user_res;

     TRACE("%p, %p, %p\n", phys_dev, surface_info, capabilities);

@@ -1762,6 +2517,13 @@ NTSTATUS wine_vkGetPhysicalDeviceSurfaceCapabilities2KHR(void *args)
     if (res == VK_SUCCESS)
         adjust_max_image_count(phys_dev, &capabilities->surfaceCapabilities);

+    if (res == VK_SUCCESS && vk_funcs->query_fs_hack &&
+            vk_funcs->query_fs_hack(wine_surface_from_handle(surface_info->surface)->driver_surface, NULL, &user_res, NULL, NULL)){
+        capabilities->surfaceCapabilities.currentExtent = user_res;
+        capabilities->surfaceCapabilities.minImageExtent = user_res;
+        capabilities->surfaceCapabilities.maxImageExtent = user_res;
+    }
+
     return res;
 }

@@ -1894,6 +2656,641 @@ NTSTATUS wine_vkDestroyDebugReportCallbackEXT(void *args)
     return STATUS_SUCCESS;
 }

+NTSTATUS wine_vkAcquireNextImage2KHR(void *args)
+{
+    struct vkAcquireNextImage2KHR_params *params = args;
+    VkDevice device = params->device;
+    const VkAcquireNextImageInfoKHR *pAcquireInfo = params->pAcquireInfo;
+    uint32_t *pImageIndex = params->pImageIndex;
+#if defined(USE_STRUCT_CONVERSION)
+    VkAcquireNextImageInfoKHR_host image_info_host = {0};
+#else
+    VkAcquireNextImageInfoKHR image_info_host = {0};
+#endif
+    struct VkSwapchainKHR_T *object = (struct VkSwapchainKHR_T *)(UINT_PTR)pAcquireInfo->swapchain;
+    TRACE("%p, %p, %p\n", device, pAcquireInfo, pImageIndex);
+
+    image_info_host.sType = pAcquireInfo->sType;
+    image_info_host.pNext = pAcquireInfo->pNext;
+    image_info_host.swapchain = object->swapchain;
+    image_info_host.timeout = pAcquireInfo->timeout;
+    image_info_host.semaphore = pAcquireInfo->semaphore;
+    image_info_host.fence = pAcquireInfo->fence;
+    image_info_host.deviceMask = pAcquireInfo->deviceMask;
+
+    return device->funcs.p_vkAcquireNextImage2KHR(device->device, &image_info_host, pImageIndex);
+}
+
+NTSTATUS wine_vkDestroySwapchainKHR(void *args)
+{
+    struct vkDestroySwapchainKHR_params *params = args;
+    VkDevice device = params->device;
+    VkSwapchainKHR swapchain = params->swapchain;
+    const VkAllocationCallbacks *pAllocator = params->pAllocator;
+    struct VkSwapchainKHR_T *object = (struct VkSwapchainKHR_T *)(UINT_PTR)swapchain;
+    uint32_t i;
+
+    TRACE("%p, 0x%s, %p\n", device, wine_dbgstr_longlong(swapchain), pAllocator);
+
+    if(!object)
+        return STATUS_SUCCESS;
+
+    if(object->fs_hack_enabled){
+        for(i = 0; i < object->n_images; ++i)
+            destroy_fs_hack_image(device, object, &object->fs_hack_images[i]);
+
+        for(i = 0; i < device->queue_count; ++i)
+            if(object->cmd_pools[i])
+                device->funcs.p_vkDestroyCommandPool(device->device, object->cmd_pools[i], NULL);
+
+        device->funcs.p_vkDestroyPipeline(device->device, object->pipeline, NULL);
+        device->funcs.p_vkDestroyPipelineLayout(device->device, object->pipeline_layout, NULL);
+        device->funcs.p_vkDestroyDescriptorSetLayout(device->device, object->descriptor_set_layout, NULL);
+        device->funcs.p_vkDestroyDescriptorPool(device->device, object->descriptor_pool, NULL);
+        device->funcs.p_vkDestroySampler(device->device, object->sampler, NULL);
+        device->funcs.p_vkFreeMemory(device->device, object->user_image_memory, NULL);
+        device->funcs.p_vkFreeMemory(device->device, object->blit_image_memory, NULL);
+        free(object->cmd_pools);
+        free(object->fs_hack_images);
+    }
+
+    device->funcs.p_vkDestroySwapchainKHR(device->device, object->swapchain, NULL);
+
+    WINE_VK_REMOVE_HANDLE_MAPPING(device->phys_dev->instance, object);
+    free(object);
+    return STATUS_SUCCESS;
+}
+
+NTSTATUS wine_vkGetSwapchainImagesKHR(void *args)
+{
+    struct vkGetSwapchainImagesKHR_params *params = args;
+    VkDevice device = params->device;
+    VkSwapchainKHR swapchain = params->swapchain;
+    uint32_t *pSwapchainImageCount = params->pSwapchainImageCount;
+    VkImage *pSwapchainImages = params->pSwapchainImages;
+    struct VkSwapchainKHR_T *object = (struct VkSwapchainKHR_T *)(UINT_PTR)swapchain;
+    uint32_t i;
+
+    TRACE("%p, 0x%s, %p, %p\n", device, wine_dbgstr_longlong(swapchain), pSwapchainImageCount, pSwapchainImages);
+
+    if(pSwapchainImages && object->fs_hack_enabled){
+        if(*pSwapchainImageCount > object->n_images)
+            *pSwapchainImageCount = object->n_images;
+        for(i = 0; i < *pSwapchainImageCount ; ++i)
+            pSwapchainImages[i] = object->fs_hack_images[i].user_image;
+        return *pSwapchainImageCount == object->n_images ? VK_SUCCESS : VK_INCOMPLETE;
+    }
+
+    return device->funcs.p_vkGetSwapchainImagesKHR(device->device, object->swapchain, pSwapchainImageCount, pSwapchainImages);
+}
+
+static VkCommandBuffer create_hack_cmd(VkQueue queue, struct VkSwapchainKHR_T *swapchain, uint32_t queue_idx)
+{
+#if defined(USE_STRUCT_CONVERSION)
+    VkCommandBufferAllocateInfo_host allocInfo = {0};
+#else
+    VkCommandBufferAllocateInfo allocInfo = {0};
+#endif
+    VkCommandBuffer cmd;
+    VkResult result;
+
+    if(!swapchain->cmd_pools[queue_idx]){
+        VkCommandPoolCreateInfo poolInfo = {0};
+
+        poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
+        poolInfo.queueFamilyIndex = queue_idx;
+
+        result = queue->device->funcs.p_vkCreateCommandPool(queue->device->device, &poolInfo, NULL, &swapchain->cmd_pools[queue_idx]);
+        if(result != VK_SUCCESS){
+            ERR("vkCreateCommandPool failed, res=%d\n", result);
+            return NULL;
+        }
+    }
+
+    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
+    allocInfo.commandPool = swapchain->cmd_pools[queue_idx];
+    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
+    allocInfo.commandBufferCount = 1;
+
+    result = queue->device->funcs.p_vkAllocateCommandBuffers(queue->device->device, &allocInfo, &cmd);
+    if(result != VK_SUCCESS){
+        ERR("vkAllocateCommandBuffers failed, res=%d\n", result);
+        return NULL;
+    }
+
+    return cmd;
+}
+
+static VkResult record_compute_cmd(VkDevice device, struct VkSwapchainKHR_T *swapchain, struct fs_hack_image *hack)
+{
+    VkResult result;
+    VkImageCopy region = {0};
+#if defined(USE_STRUCT_CONVERSION)
+    VkImageMemoryBarrier_host barriers[3] = {{0}};
+    VkCommandBufferBeginInfo_host beginInfo = {0};
+#else
+    VkImageMemoryBarrier barriers[3] = {{0}};
+    VkCommandBufferBeginInfo beginInfo = {0};
+#endif
+    float constants[4];
+
+    TRACE("recording compute command\n");
+
+#if 0
+    /* DOOM runs out of memory when allocating blit images after loading. */
+    if(!swapchain->blit_image_memory){
+        result = init_blit_images(device, swapchain);
+        if(result != VK_SUCCESS)
+            return result;
+    }
+#endif
+
+    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
+    beginInfo.flags = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT;
+
+    device->funcs.p_vkBeginCommandBuffer(hack->cmd, &beginInfo);
+
+    /* for the cs we run... */
+    /* transition user image from PRESENT_SRC to SHADER_READ */
+    barriers[0].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
+    barriers[0].oldLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
+    barriers[0].newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
+    barriers[0].srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+    barriers[0].dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+    barriers[0].image = hack->user_image;
+    barriers[0].subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+    barriers[0].subresourceRange.baseMipLevel = 0;
+    barriers[0].subresourceRange.levelCount = 1;
+    barriers[0].subresourceRange.baseArrayLayer = 0;
+    barriers[0].subresourceRange.layerCount = 1;
+    barriers[0].srcAccessMask = 0;
+    barriers[0].dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
+
+    /* storage image... */
+    /* transition blit image from whatever to GENERAL */
+    barriers[1].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
+    barriers[1].oldLayout = VK_IMAGE_LAYOUT_UNDEFINED;
+    barriers[1].newLayout = VK_IMAGE_LAYOUT_GENERAL;
+    barriers[1].srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+    barriers[1].dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+    barriers[1].image = hack->blit_image ? hack->blit_image : hack->swapchain_image;
+    barriers[1].subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+    barriers[1].subresourceRange.baseMipLevel = 0;
+    barriers[1].subresourceRange.levelCount = 1;
+    barriers[1].subresourceRange.baseArrayLayer = 0;
+    barriers[1].subresourceRange.layerCount = 1;
+    barriers[1].srcAccessMask = 0;
+    barriers[1].dstAccessMask = VK_ACCESS_SHADER_WRITE_BIT;
+
+    device->funcs.p_vkCmdPipelineBarrier(
+            hack->cmd,
+            VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
+            VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
+            0,
+            0, NULL,
+            0, NULL,
+            2, barriers
+    );
+
+    /* perform blit shader */
+    device->funcs.p_vkCmdBindPipeline(hack->cmd,
+            VK_PIPELINE_BIND_POINT_COMPUTE, swapchain->pipeline);
+
+    device->funcs.p_vkCmdBindDescriptorSets(hack->cmd,
+            VK_PIPELINE_BIND_POINT_COMPUTE, swapchain->pipeline_layout,
+            0, 1, &hack->descriptor_set, 0, NULL);
+
+    /* vec2: blit dst offset in real coords */
+    constants[0] = swapchain->blit_dst.offset.x;
+    constants[1] = swapchain->blit_dst.offset.y;
+    /* vec2: blit dst extents in real coords */
+    constants[2] = swapchain->blit_dst.extent.width;
+    constants[3] = swapchain->blit_dst.extent.height;
+    device->funcs.p_vkCmdPushConstants(hack->cmd,
+            swapchain->pipeline_layout, VK_SHADER_STAGE_COMPUTE_BIT,
+            0, sizeof(constants), constants);
+
+    /* local sizes in shader are 8 */
+    device->funcs.p_vkCmdDispatch(hack->cmd, ceil(swapchain->real_extent.width / 8.),
+            ceil(swapchain->real_extent.height / 8.), 1);
+
+    /* transition user image from SHADER_READ back to PRESENT_SRC */
+    barriers[0].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
+    barriers[0].oldLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
+    barriers[0].newLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
+    barriers[0].srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+    barriers[0].dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+    barriers[0].image = hack->user_image;
+    barriers[0].subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+    barriers[0].subresourceRange.baseMipLevel = 0;
+    barriers[0].subresourceRange.levelCount = 1;
+    barriers[0].subresourceRange.baseArrayLayer = 0;
+    barriers[0].subresourceRange.layerCount = 1;
+    barriers[0].srcAccessMask = VK_ACCESS_SHADER_READ_BIT;
+    barriers[0].dstAccessMask = 0;
+
+    device->funcs.p_vkCmdPipelineBarrier(
+            hack->cmd,
+            VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
+            VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
+            0,
+            0, NULL,
+            0, NULL,
+            1, barriers
+    );
+
+    if(hack->blit_image){
+        /* for the copy... */
+        /* no transition, just a barrier for our access masks (w -> r) */
+        barriers[0].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
+        barriers[0].oldLayout = VK_IMAGE_LAYOUT_GENERAL;
+        barriers[0].newLayout = VK_IMAGE_LAYOUT_GENERAL;
+        barriers[0].srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+        barriers[0].dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+        barriers[0].image = hack->blit_image;
+        barriers[0].subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+        barriers[0].subresourceRange.baseMipLevel = 0;
+        barriers[0].subresourceRange.levelCount = 1;
+        barriers[0].subresourceRange.baseArrayLayer = 0;
+        barriers[0].subresourceRange.layerCount = 1;
+        barriers[0].srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;
+        barriers[0].dstAccessMask = VK_ACCESS_TRANSFER_READ_BIT;
+
+        /* for the copy... */
+        /* transition swapchain image from whatever to TRANSFER_DST
+         * we don't care about the contents... */
+        barriers[1].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
+        barriers[1].oldLayout = VK_IMAGE_LAYOUT_UNDEFINED;
+        barriers[1].newLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
+        barriers[1].srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+        barriers[1].dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+        barriers[1].image = hack->swapchain_image;
+        barriers[1].subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+        barriers[1].subresourceRange.baseMipLevel = 0;
+        barriers[1].subresourceRange.levelCount = 1;
+        barriers[1].subresourceRange.baseArrayLayer = 0;
+        barriers[1].subresourceRange.layerCount = 1;
+        barriers[1].srcAccessMask = 0;
+        barriers[1].dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
+
+        device->funcs.p_vkCmdPipelineBarrier(
+                hack->cmd,
+                VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
+                VK_PIPELINE_STAGE_TRANSFER_BIT,
+                0,
+                0, NULL,
+                0, NULL,
+                2, barriers
+        );
+
+        /* copy from blit image to swapchain image */
+        region.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+        region.srcSubresource.layerCount = 1;
+        region.srcOffset.x = 0;
+        region.srcOffset.y = 0;
+        region.srcOffset.z = 0;
+        region.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+        region.dstSubresource.layerCount = 1;
+        region.dstOffset.x = 0;
+        region.dstOffset.y = 0;
+        region.dstOffset.z = 0;
+        region.extent.width = swapchain->real_extent.width;
+        region.extent.height = swapchain->real_extent.height;
+        region.extent.depth = 1;
+
+        device->funcs.p_vkCmdCopyImage(hack->cmd,
+                hack->blit_image, VK_IMAGE_LAYOUT_GENERAL,
+                hack->swapchain_image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
+                1, &region);
+
+        /* transition swapchain image from TRANSFER_DST_OPTIMAL to PRESENT_SRC */
+        barriers[0].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
+        barriers[0].oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
+        barriers[0].newLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
+        barriers[0].srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+        barriers[0].dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+        barriers[0].image = hack->swapchain_image;
+        barriers[0].subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+        barriers[0].subresourceRange.baseMipLevel = 0;
+        barriers[0].subresourceRange.levelCount = 1;
+        barriers[0].subresourceRange.baseArrayLayer = 0;
+        barriers[0].subresourceRange.layerCount = 1;
+        barriers[0].srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
+        barriers[0].dstAccessMask = 0;
+
+        device->funcs.p_vkCmdPipelineBarrier(
+                hack->cmd,
+                VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
+                VK_PIPELINE_STAGE_TRANSFER_BIT,
+                0,
+                0, NULL,
+                0, NULL,
+                1, barriers
+        );
+    }else{
+        /* transition swapchain image from GENERAL to PRESENT_SRC */
+        barriers[0].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
+        barriers[0].oldLayout = VK_IMAGE_LAYOUT_GENERAL;
+        barriers[0].newLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
+        barriers[0].srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+        barriers[0].dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+        barriers[0].image = hack->swapchain_image;
+        barriers[0].subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+        barriers[0].subresourceRange.baseMipLevel = 0;
+        barriers[0].subresourceRange.levelCount = 1;
+        barriers[0].subresourceRange.baseArrayLayer = 0;
+        barriers[0].subresourceRange.layerCount = 1;
+        barriers[0].srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;
+        barriers[0].dstAccessMask = 0;
+
+        device->funcs.p_vkCmdPipelineBarrier(
+                hack->cmd,
+                VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
+                VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
+                0,
+                0, NULL,
+                0, NULL,
+                1, barriers
+        );
+    }
+
+    result = device->funcs.p_vkEndCommandBuffer(hack->cmd);
+    if(result != VK_SUCCESS){
+        ERR("vkEndCommandBuffer: %d\n", result);
+        return result;
+    }
+
+    return VK_SUCCESS;
+}
+
+static VkResult record_graphics_cmd(VkDevice device, struct VkSwapchainKHR_T *swapchain, struct fs_hack_image *hack)
+{
+    VkResult result;
+    VkImageBlit blitregion = {0};
+    VkImageSubresourceRange range = {0};
+    VkClearColorValue black = {{0.f, 0.f, 0.f}};
+#if defined(USE_STRUCT_CONVERSION)
+    VkImageMemoryBarrier_host barriers[2] = {{0}};
+    VkCommandBufferBeginInfo_host beginInfo = {0};
+#else
+    VkImageMemoryBarrier barriers[2] = {{0}};
+    VkCommandBufferBeginInfo beginInfo = {0};
+#endif
+
+    TRACE("recording graphics command\n");
+
+    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
+    beginInfo.flags = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT;
+
+    device->funcs.p_vkBeginCommandBuffer(hack->cmd, &beginInfo);
+
+    /* transition real image from whatever to TRANSFER_DST_OPTIMAL */
+    barriers[0].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
+    barriers[0].oldLayout = VK_IMAGE_LAYOUT_UNDEFINED;
+    barriers[0].newLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
+    barriers[0].srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+    barriers[0].dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+    barriers[0].image = hack->swapchain_image;
+    barriers[0].subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+    barriers[0].subresourceRange.baseMipLevel = 0;
+    barriers[0].subresourceRange.levelCount = 1;
+    barriers[0].subresourceRange.baseArrayLayer = 0;
+    barriers[0].subresourceRange.layerCount = 1;
+    barriers[0].srcAccessMask = 0;
+    barriers[0].dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
+
+    /* transition user image from PRESENT_SRC to TRANSFER_SRC_OPTIMAL */
+    barriers[1].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
+    barriers[1].oldLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
+    barriers[1].newLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
+    barriers[1].srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+    barriers[1].dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+    barriers[1].image = hack->user_image;
+    barriers[1].subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+    barriers[1].subresourceRange.baseMipLevel = 0;
+    barriers[1].subresourceRange.levelCount = 1;
+    barriers[1].subresourceRange.baseArrayLayer = 0;
+    barriers[1].subresourceRange.layerCount = 1;
+    barriers[1].srcAccessMask = 0;
+    barriers[1].dstAccessMask = VK_ACCESS_TRANSFER_READ_BIT;
+
+    device->funcs.p_vkCmdPipelineBarrier(
+            hack->cmd,
+            VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
+            VK_PIPELINE_STAGE_TRANSFER_BIT,
+            0,
+            0, NULL,
+            0, NULL,
+            2, barriers
+    );
+
+    /* clear the image */
+    range.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+    range.baseMipLevel = 0;
+    range.levelCount = 1;
+    range.baseArrayLayer = 0;
+    range.layerCount = 1;
+
+    device->funcs.p_vkCmdClearColorImage(
+            hack->cmd, hack->swapchain_image,
+            VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
+            &black, 1, &range);
+
+    /* perform blit */
+    blitregion.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+    blitregion.srcSubresource.layerCount = 1;
+    blitregion.srcOffsets[0].x = 0;
+    blitregion.srcOffsets[0].y = 0;
+    blitregion.srcOffsets[0].z = 0;
+    blitregion.srcOffsets[1].x = swapchain->user_extent.width;
+    blitregion.srcOffsets[1].y = swapchain->user_extent.height;
+    blitregion.srcOffsets[1].z = 1;
+    blitregion.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+    blitregion.dstSubresource.layerCount = 1;
+    blitregion.dstOffsets[0].x = swapchain->blit_dst.offset.x;
+    blitregion.dstOffsets[0].y = swapchain->blit_dst.offset.y;
+    blitregion.dstOffsets[0].z = 0;
+    blitregion.dstOffsets[1].x = swapchain->blit_dst.offset.x + swapchain->blit_dst.extent.width;
+    blitregion.dstOffsets[1].y = swapchain->blit_dst.offset.y + swapchain->blit_dst.extent.height;
+    blitregion.dstOffsets[1].z = 1;
+
+    device->funcs.p_vkCmdBlitImage(hack->cmd,
+            hack->user_image, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
+            hack->swapchain_image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
+            1, &blitregion, swapchain->fs_hack_filter);
+
+    /* transition real image from TRANSFER_DST to PRESENT_SRC */
+    barriers[0].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
+    barriers[0].oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
+    barriers[0].newLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
+    barriers[0].srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+    barriers[0].dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+    barriers[0].image = hack->swapchain_image;
+    barriers[0].subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+    barriers[0].subresourceRange.baseMipLevel = 0;
+    barriers[0].subresourceRange.levelCount = 1;
+    barriers[0].subresourceRange.baseArrayLayer = 0;
+    barriers[0].subresourceRange.layerCount = 1;
+    barriers[0].srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
+    barriers[0].dstAccessMask = 0;
+
+    /* transition user image from TRANSFER_SRC_OPTIMAL to back to PRESENT_SRC */
+    barriers[1].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
+    barriers[1].oldLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
+    barriers[1].newLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
+    barriers[1].srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+    barriers[1].dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
+    barriers[1].image = hack->user_image;
+    barriers[1].subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
+    barriers[1].subresourceRange.baseMipLevel = 0;
+    barriers[1].subresourceRange.levelCount = 1;
+    barriers[1].subresourceRange.baseArrayLayer = 0;
+    barriers[1].subresourceRange.layerCount = 1;
+    barriers[1].srcAccessMask = VK_ACCESS_TRANSFER_READ_BIT;
+    barriers[1].dstAccessMask = 0;
+
+    device->funcs.p_vkCmdPipelineBarrier(
+            hack->cmd,
+            VK_PIPELINE_STAGE_TRANSFER_BIT,
+            VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
+            0,
+            0, NULL,
+            0, NULL,
+            2, barriers
+    );
+
+    result = device->funcs.p_vkEndCommandBuffer(hack->cmd);
+    if(result != VK_SUCCESS){
+        ERR("vkEndCommandBuffer: %d\n", result);
+        return result;
+    }
+
+    return VK_SUCCESS;
+}
+
+NTSTATUS wine_vkQueuePresentKHR(void *args)
+{
+    struct vkQueuePresentKHR_params *params = args;
+    VkQueue queue = params->queue;
+    const VkPresentInfoKHR *pPresentInfo = params->pPresentInfo;
+    VkResult res;
+    VkPresentInfoKHR our_presentInfo;
+    VkSwapchainKHR *arr;
+    VkCommandBuffer *blit_cmds = NULL;
+    VkSubmitInfo submitInfo = {0};
+    VkSemaphore blit_sema;
+    struct VkSwapchainKHR_T *swapchain;
+    uint32_t i, n_hacks = 0;
+    uint32_t queue_idx;
+
+    TRACE("%p, %p\n", queue, pPresentInfo);
+
+    our_presentInfo = *pPresentInfo;
+
+    for(i = 0; i < our_presentInfo.swapchainCount; ++i){
+        swapchain = (struct VkSwapchainKHR_T *)(UINT_PTR)our_presentInfo.pSwapchains[i];
+
+        if(swapchain->fs_hack_enabled){
+            struct fs_hack_image *hack = &swapchain->fs_hack_images[our_presentInfo.pImageIndices[i]];
+
+            if(!blit_cmds){
+                queue_idx = queue->family_index;
+                blit_cmds = malloc(our_presentInfo.swapchainCount * sizeof(VkCommandBuffer));
+                blit_sema = hack->blit_finished;
+            }
+
+            if(!hack->cmd || hack->cmd_queue_idx != queue_idx){
+                if(hack->cmd)
+                    queue->device->funcs.p_vkFreeCommandBuffers(queue->device->device,
+                            swapchain->cmd_pools[hack->cmd_queue_idx],
+                            1, &hack->cmd);
+
+                hack->cmd_queue_idx = queue_idx;
+                hack->cmd = create_hack_cmd(queue, swapchain, queue_idx);
+
+                if(!hack->cmd){
+                    free(blit_cmds);
+                    return VK_ERROR_DEVICE_LOST;
+                }
+
+                if(queue->device->queue_props[queue_idx].queueFlags & VK_QUEUE_GRAPHICS_BIT)
+                    res = record_graphics_cmd(queue->device, swapchain, hack);
+                else if(queue->device->queue_props[queue_idx].queueFlags & VK_QUEUE_COMPUTE_BIT)
+                    res = record_compute_cmd(queue->device, swapchain, hack);
+                else{
+                    ERR("Present queue is neither graphics nor compute queue!\n");
+                    res = VK_ERROR_DEVICE_LOST;
+                }
+
+                if(res != VK_SUCCESS){
+                    queue->device->funcs.p_vkFreeCommandBuffers(queue->device->device,
+                            swapchain->cmd_pools[hack->cmd_queue_idx],
+                            1, &hack->cmd);
+                    hack->cmd = NULL;
+                    free(blit_cmds);
+                    return res;
+                }
+            }
+
+            blit_cmds[n_hacks] = hack->cmd;
+
+            ++n_hacks;
+        }
+    }
+
+    if(n_hacks > 0){
+        VkPipelineStageFlags waitStage, *waitStages, *waitStages_arr = NULL;
+
+        if(pPresentInfo->waitSemaphoreCount > 1){
+            waitStages_arr = malloc(sizeof(VkPipelineStageFlags) * pPresentInfo->waitSemaphoreCount);
+            for(i = 0; i < pPresentInfo->waitSemaphoreCount; ++i)
+                waitStages_arr[i] = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;
+            waitStages = waitStages_arr;
+        }else{
+            waitStage = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;
+            waitStages = &waitStage;
+        }
+
+        /* blit user image to real image */
+        submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
+        submitInfo.waitSemaphoreCount = pPresentInfo->waitSemaphoreCount;
+        submitInfo.pWaitSemaphores = pPresentInfo->pWaitSemaphores;
+        submitInfo.pWaitDstStageMask = waitStages;
+        submitInfo.commandBufferCount = n_hacks;
+        submitInfo.pCommandBuffers = blit_cmds;
+        submitInfo.signalSemaphoreCount = 1;
+        submitInfo.pSignalSemaphores = &blit_sema;
+
+        res = queue->device->funcs.p_vkQueueSubmit(queue->queue, 1, &submitInfo, VK_NULL_HANDLE);
+        if(res != VK_SUCCESS)
+            ERR("vkQueueSubmit: %d\n", res);
+
+        free(waitStages_arr);
+        free(blit_cmds);
+
+        our_presentInfo.waitSemaphoreCount = 1;
+        our_presentInfo.pWaitSemaphores = &blit_sema;
+    }
+
+    arr = malloc(our_presentInfo.swapchainCount * sizeof(VkSwapchainKHR));
+    if(!arr){
+        ERR("Failed to allocate memory for swapchain array\n");
+        return VK_ERROR_OUT_OF_HOST_MEMORY;
+    }
+
+    for(i = 0; i < our_presentInfo.swapchainCount; ++i)
+        arr[i] = ((struct VkSwapchainKHR_T *)(UINT_PTR)our_presentInfo.pSwapchains[i])->swapchain;
+
+    our_presentInfo.pSwapchains = arr;
+
+    res = queue->device->funcs.p_vkQueuePresentKHR(queue->queue, &our_presentInfo);
+
+    free(arr);
+
+    return res;
+
+}
+
 BOOL WINAPI wine_vk_is_available_instance_function(VkInstance instance, const char *name)
 {
     return !!vk_funcs->p_vkGetInstanceProcAddr(instance->instance, name);
diff --git a/dlls/winevulkan/vulkan_private.h b/dlls/winevulkan/vulkan_private.h
index 666ef95e1b1..491e4cbe4a7 100644
--- a/dlls/winevulkan/vulkan_private.h
+++ b/dlls/winevulkan/vulkan_private.h
@@ -63,6 +63,44 @@ struct VkDevice_T
     struct VkQueue_T* queues;
     uint32_t queue_count;

+    VkQueueFamilyProperties *queue_props;
+
+    struct wine_vk_mapping mapping;
+};
+
+struct fs_hack_image
+{
+    uint32_t cmd_queue_idx;
+    VkCommandBuffer cmd;
+    VkImage swapchain_image;
+    VkImage blit_image;
+    VkImage user_image;
+    VkSemaphore blit_finished;
+    VkImageView user_view, blit_view;
+    VkDescriptorSet descriptor_set;
+};
+
+struct VkSwapchainKHR_T
+{
+    VkSwapchainKHR swapchain; /* native swapchain */
+
+    /* fs hack data below */
+    BOOL fs_hack_enabled;
+    VkExtent2D user_extent;
+    VkExtent2D real_extent;
+    VkImageUsageFlags surface_usage;
+    VkRect2D blit_dst;
+    VkCommandPool *cmd_pools; /* VkCommandPool[device->queue_count] */
+    VkDeviceMemory user_image_memory, blit_image_memory;
+    uint32_t n_images;
+    struct fs_hack_image *fs_hack_images; /* struct fs_hack_image[n_images] */
+    VkFilter fs_hack_filter;
+    VkSampler sampler;
+    VkDescriptorPool descriptor_pool;
+    VkDescriptorSetLayout descriptor_set_layout;
+    VkPipelineLayout pipeline_layout;
+    VkPipeline pipeline;
+
     struct wine_vk_mapping mapping;
 };


From 16dc52e38a40f4feae70ece79e3ad2d715cf0620 Mon Sep 17 00:00:00 2001
From: Kai Krakow <kai@kaishome.de>
Date: Sun, 10 Oct 2021 20:48:24 +0200
Subject: [PATCH] winex11.drv: Bypass compositor in fullscreen mode.

Bypass the compositor in fullscreen mode. This reduces stutter
introduced by window updates in the background and also allows for maybe
a few more FPS. To not change the visual appearance of the desktop for
windowed games, this hack only enables itself when the game was switched
to fullscreen mode, and returns to default WM setting when the game
leaves fullscreen mode.

Compositors tend to cause severe stutter if the game is GPU-bound.
---
 dlls/winex11.drv/window.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 45a45a29f1a..c6b23d857af 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -1144,6 +1144,7 @@ void update_user_time( Time time )
 void update_net_wm_states( struct x11drv_win_data *data )
 {
     DWORD i, style, ex_style, new_state = 0;
+    unsigned long net_wm_bypass_compositor = 0;

     if (!data->managed) return;
     if (data->whole_window == root_window) return;
@@ -1156,7 +1157,10 @@ void update_net_wm_states( struct x11drv_win_data *data )
         if ((style & WS_MAXIMIZE) && (style & WS_CAPTION) == WS_CAPTION)
             new_state |= (1 << NET_WM_STATE_MAXIMIZED);
         else if (!(style & WS_MINIMIZE))
+        {
+            net_wm_bypass_compositor = 1;
             new_state |= (1 << NET_WM_STATE_FULLSCREEN);
+        }
     }
     else if (style & WS_MAXIMIZE)
         new_state |= (1 << NET_WM_STATE_MAXIMIZED);
@@ -1218,6 +1222,9 @@ void update_net_wm_states( struct x11drv_win_data *data )
         }
     }
     data->net_wm_state = new_state;
+
+    XChangeProperty( data->display, data->whole_window, x11drv_atom(_NET_WM_BYPASS_COMPOSITOR), XA_CARDINAL,
+                     32, PropModeReplace, (unsigned char *)&net_wm_bypass_compositor, 1 );
 }

 /***********************************************************************
From 045bf41a42665b1a0c56d0549a6b34fd330f052b Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Sun, 10 Oct 2021 20:53:45 +0200
Subject: [PATCH] winex11.drv: Fullscreen hack
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Based on work by Zhiyi Zhang, includes work by Giovanni Mascellani, Rémi
Bernon, Arkadiusz Hiler, Kai Krakow, Joshua Ashton, Zebediah Figura, and
Matteo Bruni.
---
 dlls/winex11.drv/Makefile.in   |   1 +
 dlls/winex11.drv/desktop.c     |   1 +
 dlls/winex11.drv/display.c     |  93 +++-
 dlls/winex11.drv/event.c       |  29 +-
 dlls/winex11.drv/fs.c          | 899 +++++++++++++++++++++++++++++++++
 dlls/winex11.drv/graphics.c    |   3 +-
 dlls/winex11.drv/mouse.c       |  44 +-
 dlls/winex11.drv/opengl.c      | 525 ++++++++++++++++++-
 dlls/winex11.drv/settings.c    |  28 +-
 dlls/winex11.drv/vulkan.c      |  59 +++
 dlls/winex11.drv/window.c      | 152 +++++-
 dlls/winex11.drv/x11drv.h      |  35 ++
 dlls/winex11.drv/x11drv_main.c |   8 +-
 dlls/winex11.drv/xrandr.c      |  20 +
 dlls/winex11.drv/xrender.c     | 137 ++++-
 dlls/winex11.drv/xvidmode.c    |   1 +
 16 files changed, 1967 insertions(+), 68 deletions(-)
 create mode 100644 dlls/winex11.drv/fs.c

diff --git a/dlls/winex11.drv/Makefile.in b/dlls/winex11.drv/Makefile.in
index c64a8464914..d44c9907498 100644
--- a/dlls/winex11.drv/Makefile.in
+++ b/dlls/winex11.drv/Makefile.in
@@ -13,6 +13,7 @@ C_SRCS = \
 	desktop.c \
 	display.c \
 	event.c \
+	fs.c \
 	graphics.c \
 	ime.c \
 	init.c \
diff --git a/dlls/winex11.drv/desktop.c b/dlls/winex11.drv/desktop.c
index 15350244610..ece6c2890ff 100644
--- a/dlls/winex11.drv/desktop.c
+++ b/dlls/winex11.drv/desktop.c
@@ -317,6 +317,7 @@ void X11DRV_init_desktop( Window win, unsigned int width, unsigned int height )
     settings_handler.free_modes = X11DRV_desktop_free_modes;
     settings_handler.get_current_mode = X11DRV_desktop_get_current_mode;
     settings_handler.set_current_mode = X11DRV_desktop_set_current_mode;
+    settings_handler.convert_coordinates = NULL;
     X11DRV_Settings_SetHandler( &settings_handler );
 }

diff --git a/dlls/winex11.drv/display.c b/dlls/winex11.drv/display.c
index 04380ff660f..cf638ff43a0 100644
--- a/dlls/winex11.drv/display.c
+++ b/dlls/winex11.drv/display.c
@@ -139,21 +139,33 @@ static BOOL update_screen_cache(void)

 POINT virtual_screen_to_root(INT x, INT y)
 {
-    RECT virtual = get_virtual_screen_rect();
+    RECT virtual = fs_hack_get_real_virtual_screen();
     POINT pt;

-    pt.x = x - virtual.left;
-    pt.y = y - virtual.top;
+    TRACE("from %d,%d\n", x, y);
+
+    pt.x = x;
+    pt.y = y;
+    fs_hack_point_user_to_real(&pt);
+    TRACE("to real %d,%d\n", pt.x, pt.y);
+
+    pt.x -= virtual.left;
+    pt.y -= virtual.top;
+    TRACE("to root %d,%d\n", pt.x, pt.y);
     return pt;
 }

 POINT root_to_virtual_screen(INT x, INT y)
 {
-    RECT virtual = get_virtual_screen_rect();
+    RECT virtual = fs_hack_get_real_virtual_screen();
     POINT pt;

+    TRACE("from root %d,%d\n", x, y);
     pt.x = x + virtual.left;
     pt.y = y + virtual.top;
+    TRACE("to real %d,%d\n", pt.x, pt.y);
+    fs_hack_point_real_to_user(&pt);
+    TRACE("to user %d,%d\n", pt.x, pt.y);
     return pt;
 }

@@ -283,6 +295,11 @@ void X11DRV_DisplayDevices_SetHandler(const struct x11drv_display_device_handler
     }
 }

+struct x11drv_display_device_handler X11DRV_DisplayDevices_GetHandler(void)
+{
+    return host_handler;
+}
+
 void X11DRV_DisplayDevices_RegisterEventHandlers(void)
 {
     struct x11drv_display_device_handler *handler = is_virtual_desktop() ? &desktop_handler : &host_handler;
@@ -295,22 +312,72 @@ static BOOL CALLBACK update_windows_on_display_change(HWND hwnd, LPARAM lparam)
 {
     struct x11drv_win_data *data;
     UINT mask = (UINT)lparam;
+    HMONITOR monitor;

     if (!(data = get_win_data(hwnd)))
         return TRUE;

-    /* update the full screen state */
-    update_net_wm_states(data);
+    monitor = fs_hack_monitor_from_hwnd( hwnd );
+    if (fs_hack_mapping_required( monitor ) &&
+            fs_hack_matches_current_mode( monitor,
+                data->whole_rect.right - data->whole_rect.left,
+                data->whole_rect.bottom - data->whole_rect.top)){
+        if(!data->fs_hack){
+            RECT real_rect = fs_hack_real_mode( monitor );
+            MONITORINFO monitor_info;
+            UINT width, height;
+            POINT tl;
+
+            monitor_info.cbSize = sizeof(monitor_info);
+            GetMonitorInfoW( monitor, &monitor_info );
+            tl = virtual_screen_to_root( monitor_info.rcMonitor.left, monitor_info.rcMonitor.top );
+            width = real_rect.right - real_rect.left;
+            height = real_rect.bottom - real_rect.top;
+
+            TRACE("Enabling fs hack, resizing window %p to (%u,%u)-(%u,%u)\n", hwnd, tl.x, tl.y, width, height);
+            data->fs_hack = TRUE;
+            set_wm_hints( data );
+            XMoveResizeWindow(data->display, data->whole_window, tl.x, tl.y, width, height);
+            if(data->client_window)
+                XMoveResizeWindow(gdi_display, data->client_window, 0, 0, width, height);
+            sync_gl_drawable(hwnd, FALSE);
+            update_net_wm_states( data );
+        }
+    } else {
+        /* update the full screen state */
+        update_net_wm_states(data);

-    if (mask && data->whole_window)
-    {
-        POINT pos = virtual_screen_to_root(data->whole_rect.left, data->whole_rect.top);
-        XWindowChanges changes;
-        changes.x = pos.x;
-        changes.y = pos.y;
-        XReconfigureWMWindow(data->display, data->whole_window, data->vis.screen, mask, &changes);
+        if (data->fs_hack)
+            mask |= CWX | CWY;
+
+        if (mask && data->whole_window)
+        {
+            POINT pos = virtual_screen_to_root(data->whole_rect.left, data->whole_rect.top);
+            XWindowChanges changes;
+            changes.x = pos.x;
+            changes.y = pos.y;
+            XReconfigureWMWindow(data->display, data->whole_window, data->vis.screen, mask, &changes);
+        }
+
+        if(data->fs_hack && (!fs_hack_mapping_required(monitor) ||
+            !fs_hack_matches_current_mode(monitor,
+                data->whole_rect.right - data->whole_rect.left,
+                data->whole_rect.bottom - data->whole_rect.top))){
+            TRACE("Disabling fs hack\n");
+            data->fs_hack = FALSE;
+            if(data->client_window){
+                XMoveResizeWindow(gdi_display, data->client_window,
+                        data->client_rect.left - data->whole_rect.left,
+                        data->client_rect.top - data->whole_rect.top,
+                        data->client_rect.right - data->client_rect.left,
+                        data->client_rect.bottom - data->client_rect.top);
+            }
+            sync_gl_drawable(hwnd, FALSE);
+        }
     }
     release_win_data(data);
+    if (hwnd == GetForegroundWindow())
+        clip_fullscreen_window(hwnd, TRUE);
     return TRUE;
 }

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index 3a903eebd7e..d22d34ea1c7 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -1186,8 +1186,19 @@ static BOOL X11DRV_ConfigureNotify( HWND hwnd, XEvent *xev )
     }
     else pos = root_to_virtual_screen( x, y );

-    X11DRV_X_to_window_rect( data, &rect, pos.x, pos.y, event->width, event->height );
-    if (root_coords) MapWindowPoints( 0, parent, (POINT *)&rect, 2 );
+    if(data->fs_hack){
+        MONITORINFO monitor_info;
+        HMONITOR monitor;
+
+        monitor = fs_hack_monitor_from_hwnd( hwnd );
+        monitor_info.cbSize = sizeof(monitor_info);
+        GetMonitorInfoW( monitor, &monitor_info );
+        rect = monitor_info.rcMonitor;
+        TRACE( "monitor %p rect: %s\n", monitor, wine_dbgstr_rect(&rect) );
+    }else{
+        X11DRV_X_to_window_rect( data, &rect, pos.x, pos.y, event->width, event->height );
+        if (root_coords) MapWindowPoints( 0, parent, (POINT *)&rect, 2 );
+    }

     TRACE( "win %p/%lx new X rect %d,%d,%dx%d (event %d,%d,%dx%d)\n",
            hwnd, data->whole_window, rect.left, rect.top, rect.right-rect.left, rect.bottom-rect.top,
@@ -1195,6 +1206,19 @@ static BOOL X11DRV_ConfigureNotify( HWND hwnd, XEvent *xev )

     /* Compare what has changed */

+    {
+        const char *steamgameid = getenv("SteamGameId");
+        if(steamgameid && !strcmp(steamgameid, "590380")){
+            /* Into The Breach is extremely picky about the size of its window. */
+            if(is_window_rect_full_screen(&data->whole_rect) &&
+                    is_window_rect_full_screen(&rect)){
+                TRACE("window is fullscreen and new size is also fullscreen, so preserving window size\n");
+                rect.right = rect.left + (data->whole_rect.right - data->whole_rect.left);
+                rect.bottom = rect.top + (data->whole_rect.bottom - data->whole_rect.top);
+            }
+        }
+    }
+
     x     = rect.left;
     y     = rect.top;
     cx    = rect.right - rect.left;
@@ -1596,6 +1620,7 @@ static void EVENT_DropFromOffiX( HWND hWnd, XClientMessageEvent *event )
     Window		win, w_aux_root, w_aux_child;

     if (!(data = get_win_data( hWnd ))) return;
+    ERR("TODO: fs hack\n");
     cx = data->whole_rect.right - data->whole_rect.left;
     cy = data->whole_rect.bottom - data->whole_rect.top;
     win = data->whole_window;
diff --git a/dlls/winex11.drv/fs.c b/dlls/winex11.drv/fs.c
new file mode 100644
index 00000000000..641fdd40d45
--- /dev/null
+++ b/dlls/winex11.drv/fs.c
@@ -0,0 +1,899 @@
+/*
+ * Fullscreen Hack
+ *
+ * Simulate monitor resolution change
+ *
+ * Copyright 2020 Andrew Eikum for CodeWeavers
+ * Copyright 2020 Zhiyi Zhang for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+#include "config.h"
+#include <math.h>
+#include <stdlib.h>
+
+#define NONAMELESSSTRUCT
+#define NONAMELESSUNION
+
+#include "x11drv.h"
+#include "wine/debug.h"
+#include "wine/list.h"
+#include "wine/heap.h"
+#include "wine/unicode.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(fshack);
+
+static struct x11drv_display_device_handler real_device_handler;
+static struct x11drv_settings_handler real_settings_handler;
+static struct list fs_monitors = LIST_INIT(fs_monitors);
+
+/* Access to fs_monitors is protected by fs_section */
+static CRITICAL_SECTION fs_section;
+static CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &fs_section,
+    {&critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList},
+    0, 0, {(DWORD_PTR)(__FILE__ ": fs_section")}
+};
+static CRITICAL_SECTION fs_section = {&critsect_debug, -1, 0, 0, 0, 0};
+
+struct fs_monitor_size
+{
+    DWORD width;
+    DWORD height;
+};
+
+/* A table of resolutions some games expect but host system may not report */
+static struct fs_monitor_size fs_monitor_sizes[] =
+{
+    {640, 480},   /*  4:3 */
+    {800, 600},   /*  4:3 */
+    {1024, 768},  /*  4:3 */
+    {1600, 1200}, /*  4:3 */
+    {960, 540},   /* 16:9 */
+    {1280, 720},  /* 16:9 */
+    {1600, 900},  /* 16:9 */
+    {1920, 1080}, /* 16:9 */
+    {2560, 1440}, /* 16:9 */
+    {2880, 1620}, /* 16:9 */
+    {3200, 1800}, /* 16:9 */
+    {1440, 900},  /*  8:5 */
+    {1680, 1050}, /*  8:5 */
+    {1920, 1200}, /*  8:5 */
+    {2560, 1600}, /*  8:5 */
+    {1440, 960},  /*  3:2 */
+    {1920, 1280}, /*  3:2 */
+    {2560, 1080}, /* 21:9 ultra-wide */
+    {1920, 800},  /* 12:5 */
+    {3840, 1600}, /* 12:5 */
+    {1280, 1024}, /*  5:4 */
+};
+
+/* A fake monitor for the fullscreen hack */
+struct fs_monitor
+{
+    struct list entry;
+
+    DEVMODEW user_mode;         /* Mode changed to by users */
+    DEVMODEW real_mode;         /* Mode actually used by the host system */
+    double user_to_real_scale;  /* Scale factor from fake monitor to real monitor */
+    POINT top_left;             /* Top left corner of the fake monitor rectangle in real virtual screen coordinates */
+    DEVMODEW *modes;            /* Supported display modes */
+    UINT mode_count;            /* Display mode count */
+    UINT unique_resolutions;    /* Number of unique resolutions in terms of WxH */
+};
+
+static void add_fs_mode(struct fs_monitor *fs_monitor, DWORD depth, DWORD width, DWORD height,
+                        DWORD frequency, DWORD orientation)
+{
+    int i;
+    DEVMODEW *mode;
+    const char *appid;
+    BOOL is_new_resolution;
+
+    /* Titan Souls renders incorrectly if we report modes smaller than 800x600 */
+    if ((appid = getenv("SteamAppId")) && !strcmp(appid, "297130"))
+    {
+        if (orientation == DMDO_DEFAULT || orientation == DMDO_180)
+        {
+            if (height <= 600 && !(height == 600 && width == 800))
+                return;
+        }
+        else
+        {
+            if (width <= 600 && !(width == 600 && height == 800))
+                return;
+        }
+    }
+
+    is_new_resolution = TRUE;
+
+    for (i = 0; i < fs_monitor->mode_count; ++i)
+    {
+        if (fs_monitor->modes[i].dmPelsWidth == width &&
+            fs_monitor->modes[i].dmPelsHeight == height)
+        {
+            is_new_resolution = FALSE;
+
+            if (fs_monitor->modes[i].dmBitsPerPel == depth &&
+                fs_monitor->modes[i].dmDisplayFrequency == frequency &&
+                fs_monitor->modes[i].u1.s2.dmDisplayOrientation == orientation)
+                return; /* The exact mode is already added, nothing to do */
+        }
+    }
+
+    if (is_new_resolution) {
+        /* Some games crash if we report too many unique resolutions (in terms of HxW) */
+        if (limit_number_of_resolutions && fs_monitor->unique_resolutions >= limit_number_of_resolutions)
+            return;
+
+        fs_monitor->unique_resolutions++;
+    }
+
+    mode = &fs_monitor->modes[fs_monitor->mode_count++];
+    mode->dmSize = sizeof(*mode);
+
+    mode->dmDriverExtra = 0;
+    mode->dmFields = DM_DISPLAYORIENTATION | DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT |
+                     DM_DISPLAYFLAGS | DM_DISPLAYFREQUENCY;
+    mode->u1.s2.dmDisplayOrientation = orientation;
+    mode->dmBitsPerPel = depth;
+    mode->dmPelsWidth = width;
+    mode->dmPelsHeight = height;
+    mode->u2.dmDisplayFlags = 0;
+    mode->dmDisplayFrequency = frequency;
+}
+
+static BOOL fs_monitor_add_modes(struct fs_monitor *fs_monitor)
+{
+    DEVMODEW *real_modes, *real_mode, current_mode;
+    UINT real_mode_count;
+    DWORD width, height;
+    ULONG_PTR real_id;
+    ULONG offset;
+    UINT i, j;
+
+    if (!real_settings_handler.get_id(fs_monitor->user_mode.dmDeviceName, &real_id))
+        return FALSE;
+
+    if (!real_settings_handler.get_current_mode(real_id, &current_mode))
+        return FALSE;
+
+    /* Fullscreen hack doesn't support changing display orientations */
+    if (!real_settings_handler.get_modes(real_id, 0, &real_modes, &real_mode_count))
+        return FALSE;
+
+    fs_monitor->mode_count = 0;
+    fs_monitor->unique_resolutions = 0;
+    fs_monitor->modes = heap_calloc(ARRAY_SIZE(fs_monitor_sizes) * DEPTH_COUNT + real_mode_count,
+                                    sizeof(*fs_monitor->modes));
+    if (!fs_monitor->modes)
+    {
+        real_settings_handler.free_modes(real_modes);
+        return FALSE;
+    }
+
+    /* Add the current mode early, in case we have to limit */
+    add_fs_mode(fs_monitor, current_mode.dmBitsPerPel, current_mode.dmPelsWidth,
+                current_mode.dmPelsHeight, current_mode.dmDisplayFrequency,
+                current_mode.u1.s2.dmDisplayOrientation);
+
+    /* Linux reports far fewer resolutions than Windows. Add modes that some games may expect. */
+    for (i = 0; i < ARRAY_SIZE(fs_monitor_sizes); ++i)
+    {
+        if (current_mode.u1.s2.dmDisplayOrientation == DMDO_DEFAULT ||
+            current_mode.u1.s2.dmDisplayOrientation == DMDO_180)
+        {
+            width = fs_monitor_sizes[i].width;
+            height = fs_monitor_sizes[i].height;
+        }
+        else
+        {
+            width = fs_monitor_sizes[i].height;
+            height = fs_monitor_sizes[i].width;
+        }
+
+        /* Don't report modes that are larger than the current mode */
+        if (width > current_mode.dmPelsWidth || height > current_mode.dmPelsHeight)
+            continue;
+
+        for (j = 0; j < DEPTH_COUNT; ++j)
+            add_fs_mode(fs_monitor, depths[j], width, height, 60,
+                        current_mode.u1.s2.dmDisplayOrientation);
+    }
+
+    for (i = 0; i < real_mode_count; ++i)
+    {
+        offset = (sizeof(*real_modes) + real_modes[0].dmDriverExtra) * i;
+        real_mode = (DEVMODEW *)((BYTE *)real_modes + offset);
+
+        /* Don't report real modes that are larger than the current mode */
+        if (real_mode->dmPelsWidth > current_mode.dmPelsWidth ||
+            real_mode->dmPelsHeight > current_mode.dmPelsHeight)
+            continue;
+
+        add_fs_mode(fs_monitor, real_mode->dmBitsPerPel, real_mode->dmPelsWidth,
+                    real_mode->dmPelsHeight, real_mode->dmDisplayFrequency,
+                    real_mode->u1.s2.dmDisplayOrientation);
+    }
+    real_settings_handler.free_modes(real_modes);
+
+    /* Sort display modes so that X11DRV_EnumDisplaySettingsEx gets an already sorted mode list */
+    qsort(fs_monitor->modes, fs_monitor->mode_count, sizeof(*fs_monitor->modes), mode_compare);
+    return TRUE;
+}
+
+/* Add a fake monitor to fs_monitors list.
+ * Call this function with fs_section entered */
+static BOOL fs_add_monitor(const WCHAR *device_name)
+{
+    struct fs_monitor *fs_monitor;
+    DEVMODEW real_mode;
+    ULONG_PTR real_id;
+
+    if (!real_settings_handler.get_id(device_name, &real_id))
+        return FALSE;
+
+    if (!real_settings_handler.get_current_mode(real_id, &real_mode))
+        return FALSE;
+
+    if (!(fs_monitor = heap_alloc(sizeof(*fs_monitor))))
+        return FALSE;
+
+    fs_monitor->user_mode = real_mode;
+    fs_monitor->real_mode = real_mode;
+    fs_monitor->user_to_real_scale = 1.0;
+    fs_monitor->top_left.x = real_mode.u1.s2.dmPosition.x;
+    fs_monitor->top_left.y = real_mode.u1.s2.dmPosition.y;
+    lstrcpyW(fs_monitor->user_mode.dmDeviceName, device_name);
+    if (!fs_monitor_add_modes(fs_monitor))
+    {
+        ERR("Failed to initialize display modes.\n");
+        heap_free(fs_monitor);
+        return FALSE;
+    }
+    list_add_tail(&fs_monitors, &fs_monitor->entry);
+    return TRUE;
+}
+
+/* Fullscreen settings handler */
+
+/* Convert fullscreen hack settings handler id to GDI device name */
+static void fs_id_to_device_name(ULONG_PTR id, WCHAR *device_name)
+{
+    static WCHAR display_fmtW[] = {'\\','\\','.','\\','D','I','S','P','L','A','Y','%','d',0};
+    sprintfW(device_name, display_fmtW, (INT)id);
+}
+
+static BOOL fs_get_id(const WCHAR *device_name, ULONG_PTR *id)
+{
+    static const WCHAR displayW[] = {'\\','\\','.','\\','D','I','S','P','L','A','Y'};
+    long int display_index;
+    WCHAR *end;
+
+    if (strncmpiW( device_name, displayW, ARRAY_SIZE(displayW) ))
+        return FALSE;
+
+    display_index = strtolW( device_name + ARRAY_SIZE(displayW), &end, 10 );
+    if (*end)
+        return FALSE;
+
+    *id = (ULONG_PTR)display_index;
+    return TRUE;
+}
+
+/* Find a fs_monitor from a display name.
+ * Call this function with fs_section entered */
+static struct fs_monitor *fs_get_monitor_by_name(const WCHAR *name)
+{
+    struct fs_monitor *fs_monitor;
+
+    TRACE("name %s\n", wine_dbgstr_w(name));
+
+    LIST_FOR_EACH_ENTRY(fs_monitor, &fs_monitors, struct fs_monitor, entry)
+    {
+        if (!lstrcmpiW(fs_monitor->user_mode.dmDeviceName, name))
+            return fs_monitor;
+    }
+
+    return NULL;
+}
+
+static BOOL fs_get_modes(ULONG_PTR id, DWORD flags, DEVMODEW **new_modes, UINT *mode_count)
+{
+    WCHAR device_name[CCHDEVICENAME];
+    struct fs_monitor *fs_monitor;
+
+    fs_id_to_device_name(id, device_name);
+    EnterCriticalSection(&fs_section);
+    if ((fs_monitor = fs_get_monitor_by_name(device_name)))
+    {
+        *new_modes = fs_monitor->modes;
+        *mode_count = fs_monitor->mode_count;
+        LeaveCriticalSection(&fs_section);
+        return TRUE;
+    }
+
+    LeaveCriticalSection(&fs_section);
+    return FALSE;
+}
+
+static void fs_free_modes(DEVMODEW *modes){}
+
+/* Find a fs_monitor from a HMONITOR handle.
+ * Call this function with fs_section entered */
+static struct fs_monitor *fs_find_monitor_by_handle(HMONITOR monitor)
+{
+    MONITORINFOEXW monitor_info;
+
+    TRACE("monitor %p\n", monitor);
+
+    monitor_info.cbSize = sizeof(monitor_info);
+    if (!GetMonitorInfoW(monitor, (MONITORINFO *)&monitor_info))
+        return NULL;
+
+    return fs_get_monitor_by_name(monitor_info.szDevice);
+}
+
+static BOOL fs_get_current_mode(ULONG_PTR id, DEVMODEW *mode)
+{
+    WCHAR device_name[CCHDEVICENAME];
+    struct fs_monitor *fs_monitor;
+
+    fs_id_to_device_name(id, device_name);
+
+    EnterCriticalSection(&fs_section);
+    fs_monitor = fs_get_monitor_by_name(device_name);
+    if (fs_monitor)
+    {
+        *mode = fs_monitor->user_mode;
+        LeaveCriticalSection(&fs_section);
+        return TRUE;
+    }
+    LeaveCriticalSection(&fs_section);
+    return FALSE;
+}
+
+static LONG fs_set_current_mode(ULONG_PTR id, DEVMODEW *user_mode)
+{
+    WCHAR device_name[CCHDEVICENAME];
+    struct fs_monitor *fs_monitor;
+    DEVMODEW real_mode;
+    ULONG_PTR real_id;
+    double scale;
+
+    fs_id_to_device_name(id, device_name);
+
+    EnterCriticalSection(&fs_section);
+    fs_monitor = fs_get_monitor_by_name(device_name);
+    if (!fs_monitor)
+    {
+        LeaveCriticalSection(&fs_section);
+        return DISP_CHANGE_FAILED;
+    }
+
+    if (is_detached_mode(&fs_monitor->real_mode) && !is_detached_mode(user_mode))
+    {
+        FIXME("Attaching adapters is unsupported with fullscreen hack.\n");
+        return DISP_CHANGE_SUCCESSFUL;
+    }
+
+    /* Real modes may be changed since initialization */
+    if (!real_settings_handler.get_id(device_name, &real_id) ||
+        !real_settings_handler.get_current_mode(real_id, &real_mode))
+    {
+        LeaveCriticalSection(&fs_section);
+        return DISP_CHANGE_FAILED;
+    }
+
+    fs_monitor->user_mode = *user_mode;
+    fs_monitor->real_mode = real_mode;
+    lstrcpyW(fs_monitor->user_mode.dmDeviceName, device_name);
+
+    if (is_detached_mode(user_mode))
+    {
+        fs_monitor->user_to_real_scale = 0;
+        fs_monitor->top_left.x = 0;
+        fs_monitor->top_left.y = 0;
+    }
+    /* Integer scaling */
+    else if (fs_hack_is_integer())
+    {
+        scale = min(real_mode.dmPelsWidth / user_mode->dmPelsWidth, real_mode.dmPelsHeight / user_mode->dmPelsHeight);
+        fs_monitor->user_to_real_scale = scale;
+        fs_monitor->top_left.x = real_mode.u1.s2.dmPosition.x + (real_mode.dmPelsWidth - user_mode->dmPelsWidth * scale) / 2;
+        fs_monitor->top_left.y = real_mode.u1.s2.dmPosition.y + (real_mode.dmPelsHeight - user_mode->dmPelsHeight * scale) / 2;
+    }
+    /* If real mode is narrower than fake mode, scale to fit width */
+    else if ((double)real_mode.dmPelsWidth / (double)real_mode.dmPelsHeight
+             < (double)user_mode->dmPelsWidth / (double)user_mode->dmPelsHeight)
+    {
+        scale = (double)real_mode.dmPelsWidth / (double)user_mode->dmPelsWidth;
+        fs_monitor->user_to_real_scale = scale;
+        fs_monitor->top_left.x = real_mode.u1.s2.dmPosition.x;
+        fs_monitor->top_left.y = real_mode.u1.s2.dmPosition.y + (real_mode.dmPelsHeight - user_mode->dmPelsHeight * scale) / 2;
+    }
+    /* Else scale to fit height */
+    else
+    {
+        scale = (double)real_mode.dmPelsHeight / (double)user_mode->dmPelsHeight;
+        fs_monitor->user_to_real_scale = scale;
+        fs_monitor->top_left.x = real_mode.u1.s2.dmPosition.x + (real_mode.dmPelsWidth - user_mode->dmPelsWidth * scale) / 2;
+        fs_monitor->top_left.y = real_mode.u1.s2.dmPosition.y;
+    }
+
+    TRACE("real_mode x %d y %d width %d height %d\n", real_mode.u1.s2.dmPosition.x, real_mode.u1.s2.dmPosition.y,
+          real_mode.dmPelsWidth, real_mode.dmPelsHeight);
+    TRACE("user_mode x %d y %d width %d height %d\n", user_mode->u1.s2.dmPosition.x, user_mode->u1.s2.dmPosition.y,
+          user_mode->dmPelsWidth, user_mode->dmPelsHeight);
+    TRACE("user_to_real_scale %lf\n", fs_monitor->user_to_real_scale);
+    TRACE("top left corner:%s\n", wine_dbgstr_point(&fs_monitor->top_left));
+
+    LeaveCriticalSection(&fs_section);
+    return DISP_CHANGE_SUCCESSFUL;
+}
+
+/* Display device handler functions */
+
+static BOOL fs_get_monitors(ULONG_PTR adapter_id, struct gdi_monitor **new_monitors, int *count)
+{
+    struct gdi_monitor *monitor;
+    struct fs_monitor *fs_monitor;
+    RECT rect;
+    INT i;
+
+    if (!real_device_handler.get_monitors(adapter_id, new_monitors, count))
+        return FALSE;
+
+    EnterCriticalSection(&fs_section);
+    for (i = 0; i < *count; ++i)
+    {
+        monitor = &(*new_monitors)[i];
+
+        LIST_FOR_EACH_ENTRY(fs_monitor, &fs_monitors, struct fs_monitor, entry)
+        {
+            rect.left = fs_monitor->real_mode.u1.s2.dmPosition.x;
+            rect.top = fs_monitor->real_mode.u1.s2.dmPosition.y;
+            rect.right = rect.left + fs_monitor->real_mode.dmPelsWidth;
+            rect.bottom = rect.top + fs_monitor->real_mode.dmPelsHeight;
+
+            if (EqualRect(&rect, &monitor->rc_monitor))
+            {
+                monitor->rc_monitor.left = fs_monitor->user_mode.u1.s2.dmPosition.x;
+                monitor->rc_monitor.top = fs_monitor->user_mode.u1.s2.dmPosition.y;
+                monitor->rc_monitor.right = monitor->rc_monitor.left + fs_monitor->user_mode.dmPelsWidth;
+                monitor->rc_monitor.bottom = monitor->rc_monitor.top + fs_monitor->user_mode.dmPelsHeight;
+                monitor->rc_work = monitor->rc_monitor;
+                monitor->state_flags = DISPLAY_DEVICE_ATTACHED;
+                if (fs_monitor->user_mode.dmPelsWidth && fs_monitor->user_mode.dmPelsHeight)
+                    monitor->state_flags |= DISPLAY_DEVICE_ACTIVE;
+            }
+        }
+    }
+    LeaveCriticalSection(&fs_section);
+    return TRUE;
+}
+
+/* Fullscreen hack helpers */
+
+/* Return whether fullscreen hack is enabled on a specific monitor */
+BOOL fs_hack_enabled(HMONITOR monitor)
+{
+    struct fs_monitor *fs_monitor;
+    BOOL enabled = FALSE;
+
+    TRACE("monitor %p\n", monitor);
+
+    EnterCriticalSection(&fs_section);
+    fs_monitor = fs_find_monitor_by_handle(monitor);
+    if (fs_monitor && (fs_monitor->user_mode.dmPelsWidth != fs_monitor->real_mode.dmPelsWidth ||
+                       fs_monitor->user_mode.dmPelsHeight != fs_monitor->real_mode.dmPelsHeight))
+        enabled = TRUE;
+    LeaveCriticalSection(&fs_section);
+    TRACE("enabled: %s\n", enabled ? "TRUE" : "FALSE");
+    return enabled;
+}
+
+BOOL fs_hack_mapping_required(HMONITOR monitor)
+{
+    BOOL required;
+
+    TRACE("monitor %p\n", monitor);
+
+    /* steamcompmgr does our mapping for us */
+    required = !wm_is_steamcompmgr(NULL) && fs_hack_enabled(monitor);
+    TRACE("required: %s\n", required ? "TRUE" : "FALSE");
+    return required;
+}
+
+/* Return whether integer scaling is on */
+BOOL fs_hack_is_integer(void)
+{
+    static int is_int = -1;
+    if (is_int < 0)
+    {
+        const char *e = getenv("WINE_FULLSCREEN_INTEGER_SCALING");
+        is_int = e && strcmp(e, "0");
+    }
+    TRACE("is_interger_scaling: %s\n", is_int ? "TRUE" : "FALSE");
+    return is_int;
+}
+
+HMONITOR fs_hack_monitor_from_rect(const RECT *in_rect)
+{
+    RECT rect = *in_rect;
+
+    TRACE("rect %s\n", wine_dbgstr_rect(&rect));
+    rect.right = rect.left + 1;
+    rect.bottom = rect.top + 1;
+    return MonitorFromRect(&rect, MONITOR_DEFAULTTOPRIMARY);
+}
+
+/* Get the monitor a window is on. MonitorFromWindow() doesn't work here because it finds the
+ * monitor with the maximum overlapped rectangle when a window is spanned over two monitors, whereas
+ * for the fullscreen hack, the monitor where the left top corner of the window is on is the correct
+ * one. For example, a game with a window of 3840x2160 changes the primary monitor to 1280x720, if
+ * there is a secondary monitor of 3840x2160 to the right, MonitorFromWindow() will return the
+ * secondary monitor instead of the primary one. */
+HMONITOR fs_hack_monitor_from_hwnd(HWND hwnd)
+{
+    RECT rect = {0};
+
+    if (!GetWindowRect(hwnd, &rect))
+        ERR("Invalid hwnd %p.\n", hwnd);
+
+    TRACE("hwnd %p rect %s\n", hwnd, wine_dbgstr_rect(&rect));
+    return fs_hack_monitor_from_rect(&rect);
+}
+
+/* Return the rectangle of a monitor in current mode in user virtual screen coordinates */
+RECT fs_hack_current_mode(HMONITOR monitor)
+{
+    struct fs_monitor *fs_monitor;
+    RECT rect = {0};
+
+    TRACE("monitor %p\n", monitor);
+
+    EnterCriticalSection(&fs_section);
+    fs_monitor = fs_find_monitor_by_handle(monitor);
+    if (!fs_monitor)
+    {
+        LeaveCriticalSection(&fs_section);
+        return rect;
+    }
+
+    rect.left = fs_monitor->user_mode.u1.s2.dmPosition.x;
+    rect.top = fs_monitor->user_mode.u1.s2.dmPosition.y;
+    rect.right = rect.left + fs_monitor->user_mode.dmPelsWidth;
+    rect.bottom = rect.top + fs_monitor->user_mode.dmPelsHeight;
+    LeaveCriticalSection(&fs_section);
+    TRACE("current mode rect: %s\n", wine_dbgstr_rect(&rect));
+    return rect;
+}
+
+/* Return the rectangle of a monitor in real mode in real virtual screen coordinates */
+RECT fs_hack_real_mode(HMONITOR monitor)
+{
+    struct fs_monitor *fs_monitor;
+    RECT rect = {0};
+
+    TRACE("monitor %p\n", monitor);
+
+    EnterCriticalSection(&fs_section);
+    fs_monitor = fs_find_monitor_by_handle(monitor);
+    if (!fs_monitor)
+    {
+        LeaveCriticalSection(&fs_section);
+        return rect;
+    }
+
+    rect.left = fs_monitor->real_mode.u1.s2.dmPosition.x;
+    rect.top = fs_monitor->real_mode.u1.s2.dmPosition.y;
+    rect.right = rect.left + fs_monitor->real_mode.dmPelsWidth;
+    rect.bottom = rect.top + fs_monitor->real_mode.dmPelsHeight;
+    LeaveCriticalSection(&fs_section);
+    TRACE("real mode rect: %s\n", wine_dbgstr_rect(&rect));
+    return rect;
+}
+
+/* Return whether width and height are the same as the current mode used by a monitor */
+BOOL fs_hack_matches_current_mode(HMONITOR monitor, INT width, INT height)
+{
+    MONITORINFO monitor_info;
+    BOOL matched;
+
+    TRACE("monitor %p\n", monitor);
+
+    monitor_info.cbSize = sizeof(monitor_info);
+    if (!GetMonitorInfoW(monitor, &monitor_info))
+        return FALSE;
+
+    matched = (width == monitor_info.rcMonitor.right - monitor_info.rcMonitor.left)
+              && (height == monitor_info.rcMonitor.bottom - monitor_info.rcMonitor.top);
+    TRACE("matched: %s\n", matched ? "TRUE" : "FALSE");
+    return matched;
+}
+
+/* Transform a point in user virtual screen coordinates to real virtual screen coordinates */
+void fs_hack_point_user_to_real(POINT *pos)
+{
+    struct fs_monitor *fs_monitor;
+    RECT rect;
+
+    TRACE("from %d,%d\n", pos->x, pos->y);
+
+    if (wm_is_steamcompmgr(NULL))
+        return;
+
+    EnterCriticalSection(&fs_section);
+    LIST_FOR_EACH_ENTRY(fs_monitor, &fs_monitors, struct fs_monitor, entry)
+    {
+        rect.left = fs_monitor->user_mode.u1.s2.dmPosition.x;
+        rect.top = fs_monitor->user_mode.u1.s2.dmPosition.y;
+        rect.right = rect.left + fs_monitor->user_mode.dmPelsWidth;
+        rect.bottom = rect.top + fs_monitor->user_mode.dmPelsHeight;
+
+        if (PtInRect(&rect, *pos))
+        {
+            pos->x -= fs_monitor->user_mode.u1.s2.dmPosition.x;
+            pos->y -= fs_monitor->user_mode.u1.s2.dmPosition.y;
+            pos->x = lround(pos->x * fs_monitor->user_to_real_scale);
+            pos->y = lround(pos->y * fs_monitor->user_to_real_scale);
+            pos->x += fs_monitor->top_left.x;
+            pos->y += fs_monitor->top_left.y;
+            LeaveCriticalSection(&fs_section);
+            TRACE("to %d,%d\n", pos->x, pos->y);
+            return;
+        }
+    }
+    LeaveCriticalSection(&fs_section);
+    WARN("%d,%d not transformed.\n", pos->x, pos->y);
+}
+
+/* Transform a point in real virtual screen coordinates to user virtual screen coordinates */
+void fs_hack_point_real_to_user(POINT *pos)
+{
+    struct fs_monitor *fs_monitor;
+    RECT rect;
+
+    TRACE("from %d,%d\n", pos->x, pos->y);
+
+    if (wm_is_steamcompmgr(NULL))
+        return;
+
+    EnterCriticalSection(&fs_section);
+    LIST_FOR_EACH_ENTRY(fs_monitor, &fs_monitors, struct fs_monitor, entry)
+    {
+        rect.left = fs_monitor->real_mode.u1.s2.dmPosition.x;
+        rect.top = fs_monitor->real_mode.u1.s2.dmPosition.y;
+        rect.right = rect.left + fs_monitor->real_mode.dmPelsWidth;
+        rect.bottom = rect.top + fs_monitor->real_mode.dmPelsHeight;
+
+        if (PtInRect(&rect, *pos))
+        {
+            pos->x -= fs_monitor->top_left.x;
+            pos->y -= fs_monitor->top_left.y;
+            pos->x = lround(pos->x / fs_monitor->user_to_real_scale);
+            pos->y = lround(pos->y / fs_monitor->user_to_real_scale);
+            pos->x += fs_monitor->user_mode.u1.s2.dmPosition.x;
+            pos->y += fs_monitor->user_mode.u1.s2.dmPosition.y;
+            pos->x = max(pos->x, fs_monitor->user_mode.u1.s2.dmPosition.x);
+            pos->y = max(pos->y, fs_monitor->user_mode.u1.s2.dmPosition.y);
+            pos->x = min(pos->x, fs_monitor->user_mode.u1.s2.dmPosition.x + (INT)fs_monitor->user_mode.dmPelsWidth - 1);
+            pos->y = min(pos->y, fs_monitor->user_mode.u1.s2.dmPosition.y + (INT)fs_monitor->user_mode.dmPelsHeight - 1);
+            LeaveCriticalSection(&fs_section);
+            TRACE("to %d,%d\n", pos->x, pos->y);
+            return;
+        }
+    }
+    LeaveCriticalSection(&fs_section);
+    WARN("%d,%d not transformed.\n", pos->x, pos->y);
+}
+
+/* Transform RGNDATA in user virtual screen coordinates to real virtual screen coordinates.
+ * This is for clipping. Be sure to use Unsorted for Xlib calls after this transformation because
+ * this may break the requirement of using YXBanded. For example, say there are two monitors aligned
+ * horizontally with the primary monitor on the right. Each of monitor is of real resolution
+ * 1920x1080 and the fake primary monitor resolution is 1024x768. Then (0, 10, 1024, 768) should be
+ * transformed to (0, 14, 1920, 1080). While (1024, 10, 2944, 1080) should be transformed to
+ * (1920, 10, 3840, 1080) and this is breaking YXBanded because it requires y in non-decreasing order */
+void fs_hack_rgndata_user_to_real(RGNDATA *data)
+{
+    unsigned int i;
+    XRectangle *xrect;
+    RECT rect;
+
+    if (!data || wm_is_steamcompmgr(NULL))
+        return;
+
+    xrect = (XRectangle *)data->Buffer;
+    for (i = 0; i < data->rdh.nCount; i++)
+    {
+        rect.left = xrect[i].x;
+        rect.top = xrect[i].y;
+        rect.right = xrect[i].x + xrect[i].width;
+        rect.bottom = xrect[i].y + xrect[i].height;
+        TRACE("from rect %s\n", wine_dbgstr_rect(&rect));
+        fs_hack_rect_user_to_real(&rect);
+        TRACE("to rect %s\n", wine_dbgstr_rect(&rect));
+        xrect[i].x = rect.left;
+        xrect[i].y = rect.top;
+        xrect[i].width = rect.right - rect.left;
+        xrect[i].height = rect.bottom - rect.top;
+    }
+}
+
+/* Transform a rectangle in user virtual screen coordinates to real virtual screen coordinates. A
+ * difference compared to fs_hack_point_user_to_real() is that fs_hack_point_user_to_real() finds
+ * the wrong monitor if the point is on the right edge of the monitor rectangle. For example, when
+ * there are two monitors of real size 1920x1080, the primary monitor is of user mode 1024x768 and
+ * the secondary monitor is to the right. Rectangle (0, 0, 1024, 768) should transform to
+ * (0, 0, 1920, 1080). If (1024, 768) is passed to fs_hack_point_user_to_real(),
+ * fs_hack_point_user_to_real() will think (1024, 768) is on the secondary monitor, ends up
+ * returning a wrong result to callers. */
+void fs_hack_rect_user_to_real(RECT *rect)
+{
+    struct fs_monitor *fs_monitor;
+    HMONITOR monitor;
+    POINT point;
+
+    TRACE("from %s\n", wine_dbgstr_rect(rect));
+
+    if (wm_is_steamcompmgr(NULL))
+        return;
+
+    point.x = rect->left;
+    point.y = rect->top;
+    monitor = MonitorFromPoint(point, MONITOR_DEFAULTTONEAREST);
+    EnterCriticalSection(&fs_section);
+    fs_monitor = fs_find_monitor_by_handle(monitor);
+    if (!fs_monitor)
+    {
+        LeaveCriticalSection(&fs_section);
+        WARN("%s not transformed.\n", wine_dbgstr_rect(rect));
+        return;
+    }
+
+    OffsetRect(rect, -fs_monitor->user_mode.u1.s2.dmPosition.x, -fs_monitor->user_mode.u1.s2.dmPosition.y);
+    rect->left = lround(rect->left * fs_monitor->user_to_real_scale);
+    rect->right = lround(rect->right * fs_monitor->user_to_real_scale);
+    rect->top = lround(rect->top * fs_monitor->user_to_real_scale);
+    rect->bottom = lround(rect->bottom * fs_monitor->user_to_real_scale);
+    OffsetRect(rect, fs_monitor->top_left.x, fs_monitor->top_left.y);
+    LeaveCriticalSection(&fs_section);
+    TRACE("to %s\n", wine_dbgstr_rect(rect));
+}
+
+/* Get the user_to_real_scale value in a monitor */
+double fs_hack_get_user_to_real_scale(HMONITOR monitor)
+{
+    struct fs_monitor *fs_monitor;
+    double scale = 1.0;
+
+    TRACE("monitor %p\n", monitor);
+
+    if (wm_is_steamcompmgr(NULL))
+        return scale;
+
+    EnterCriticalSection(&fs_section);
+    fs_monitor = fs_find_monitor_by_handle(monitor);
+    if (!fs_monitor)
+    {
+        LeaveCriticalSection(&fs_section);
+        return scale;
+    }
+    scale = fs_monitor->user_to_real_scale;
+
+    LeaveCriticalSection(&fs_section);
+    TRACE("scale %lf\n", scale);
+    return scale;
+}
+
+/* Get the scaled scree size of a monitor */
+SIZE fs_hack_get_scaled_screen_size(HMONITOR monitor)
+{
+    struct fs_monitor *fs_monitor;
+    SIZE size = {0};
+
+    TRACE("monitor %p\n", monitor);
+
+    EnterCriticalSection(&fs_section);
+    fs_monitor = fs_find_monitor_by_handle(monitor);
+    if (!fs_monitor)
+    {
+        LeaveCriticalSection(&fs_section);
+        return size;
+    }
+
+    if (wm_is_steamcompmgr(NULL))
+    {
+        LeaveCriticalSection(&fs_section);
+        size.cx = fs_monitor->user_mode.dmPelsWidth;
+        size.cy = fs_monitor->user_mode.dmPelsHeight;
+        TRACE("width %d height %d\n", size.cx, size.cy);
+        return size;
+    }
+
+    size.cx = lround(fs_monitor->user_mode.dmPelsWidth * fs_monitor->user_to_real_scale);
+    size.cy = lround(fs_monitor->user_mode.dmPelsHeight * fs_monitor->user_to_real_scale);
+    LeaveCriticalSection(&fs_section);
+    TRACE("width %d height %d\n", size.cx, size.cy);
+    return size;
+}
+
+/* Get the real virtual screen size instead of virtual screen size using fake modes */
+RECT fs_hack_get_real_virtual_screen(void)
+{
+    struct fs_monitor *fs_monitor;
+    RECT rect, virtual = {0};
+
+    EnterCriticalSection(&fs_section);
+    LIST_FOR_EACH_ENTRY(fs_monitor, &fs_monitors, struct fs_monitor, entry)
+    {
+        rect.left = fs_monitor->real_mode.u1.s2.dmPosition.x;
+        rect.top = fs_monitor->real_mode.u1.s2.dmPosition.y;
+        rect.right = rect.left + fs_monitor->real_mode.dmPelsWidth;
+        rect.bottom = rect.top + fs_monitor->real_mode.dmPelsHeight;
+
+        UnionRect(&virtual, &virtual, &rect);
+    }
+    LeaveCriticalSection(&fs_section);
+    TRACE("real virtual screen rect:%s\n", wine_dbgstr_rect(&virtual));
+    return virtual;
+}
+
+/* Initialize the fullscreen hack, which is a layer on top of real settings handlers and real
+ * display device handlers */
+void fs_hack_init(void)
+{
+    static WCHAR display_fmt[] = {'\\','\\','.','\\','D','I','S','P','L','A','Y','%','d',0};
+    struct x11drv_display_device_handler device_handler;
+    struct x11drv_settings_handler settings_handler;
+    WCHAR device_name[CCHDEVICENAME];
+    INT i = 0;
+
+    real_device_handler = X11DRV_DisplayDevices_GetHandler();
+    real_settings_handler = X11DRV_Settings_GetHandler();
+
+    EnterCriticalSection(&fs_section);
+    while (1)
+    {
+        sprintfW(device_name, display_fmt, ++i);
+        if (!fs_add_monitor(device_name))
+            break;
+    }
+    LeaveCriticalSection(&fs_section);
+
+    settings_handler.name = "Fullscreen Hack";
+    settings_handler.priority = 500;
+    settings_handler.get_id = fs_get_id;
+    settings_handler.get_modes = fs_get_modes;
+    settings_handler.free_modes = fs_free_modes;
+    settings_handler.get_current_mode = fs_get_current_mode;
+    settings_handler.set_current_mode = fs_set_current_mode;
+    settings_handler.convert_coordinates = NULL;
+    X11DRV_Settings_SetHandler(&settings_handler);
+
+    device_handler.name = "Fullscreen Hack";
+    device_handler.priority = 500;
+    device_handler.get_gpus = real_device_handler.get_gpus;
+    device_handler.get_adapters = real_device_handler.get_adapters;
+    device_handler.get_monitors = fs_get_monitors;
+    device_handler.free_gpus = real_device_handler.free_gpus;
+    device_handler.free_adapters = real_device_handler.free_adapters;
+    device_handler.free_monitors = real_device_handler.free_monitors;
+    device_handler.register_event_handlers = NULL;
+    X11DRV_DisplayDevices_SetHandler(&device_handler);
+}
diff --git a/dlls/winex11.drv/graphics.c b/dlls/winex11.drv/graphics.c
index b3df3cafcb1..a486f78746b 100644
--- a/dlls/winex11.drv/graphics.c
+++ b/dlls/winex11.drv/graphics.c
@@ -251,8 +251,9 @@ static void update_x11_clipping( X11DRV_PDEVICE *physDev, HRGN rgn )
     }
     else if ((data = X11DRV_GetRegionData( rgn, 0 )))
     {
+        fs_hack_rgndata_user_to_real(data);
         XSetClipRectangles( gdi_display, physDev->gc, physDev->dc_rect.left, physDev->dc_rect.top,
-                            (XRectangle *)data->Buffer, data->rdh.nCount, YXBanded );
+                            (XRectangle *)data->Buffer, data->rdh.nCount, Unsorted );
         HeapFree( GetProcessHeap(), 0, data );
     }
 }
diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
index 511550a8486..cb4363ae02e 100644
--- a/dlls/winex11.drv/mouse.c
+++ b/dlls/winex11.drv/mouse.c
@@ -433,6 +433,7 @@ static BOOL grab_clipping_window( const RECT *clip )
     Window clip_window;
     HWND msg_hwnd = 0;
     POINT pos;
+    RECT real_clip;

     if (GetWindowThreadProcessId( GetDesktopWindow(), NULL ) == GetCurrentThreadId())
         return TRUE;  /* don't clip in the desktop process */
@@ -450,9 +451,21 @@ static BOOL grab_clipping_window( const RECT *clip )
     TRACE( "clipping to %s win %lx\n", wine_dbgstr_rect(clip), clip_window );

     if (!data->clip_hwnd) XUnmapWindow( data->display, clip_window );
+
+    TRACE("user clip rect %s\n", wine_dbgstr_rect(clip));
+
+    real_clip = *clip;
+    fs_hack_rect_user_to_real(&real_clip);
+
     pos = virtual_screen_to_root( clip->left, clip->top );
+
+    TRACE("setting real clip to %d,%d x %d,%d\n",
+            pos.x, pos.y,
+            real_clip.right - real_clip.left,
+            real_clip.bottom - real_clip.top);
+
     XMoveResizeWindow( data->display, clip_window, pos.x, pos.y,
-                       max( 1, clip->right - clip->left ), max( 1, clip->bottom - clip->top ) );
+                       max( 1, real_clip.right - real_clip.left ), max( 1, real_clip.bottom - real_clip.top ) );
     XMapWindow( data->display, clip_window );

     /* if the rectangle is shrinking we may get a pointer warp */
@@ -631,11 +644,17 @@ static void map_event_coords( HWND hwnd, Window window, Window event_root, int x
         thread_data = x11drv_thread_data();
         if (!thread_data->clip_hwnd) return;
         if (thread_data->clip_window != window) return;
-        pt.x += clip_rect.left;
-        pt.y += clip_rect.top;
+        pt.x = clip_rect.left;
+        pt.y = clip_rect.top;
+        fs_hack_point_user_to_real(&pt);
+
+        pt.x += input->u.mi.dx;
+        pt.y += input->u.mi.dy;
+        fs_hack_point_real_to_user(&pt);
     }
     else if ((data = get_win_data( hwnd )))
     {
+        if (data->fs_hack) fs_hack_point_real_to_user(&pt);
         if (window == root_window) pt = root_to_virtual_screen( pt.x, pt.y );
         else if (event_root == root_window) pt = root_to_virtual_screen( x_root, y_root );
         else
@@ -1513,11 +1532,13 @@ BOOL CDECL X11DRV_SetCursorPos( INT x, INT y )
     struct x11drv_thread_data *data = x11drv_init_thread_data();
     POINT pos = virtual_screen_to_root( x, y );

+    TRACE("real setting to %u, %u\n", pos.x, pos.y);
+
     XWarpPointer( data->display, root_window, root_window, 0, 0, 0, 0, pos.x, pos.y );
     data->warp_serial = NextRequest( data->display );
     XNoOp( data->display );
     XFlush( data->display ); /* avoids bad mouse lag in games that do their own mouse warping */
-    TRACE( "warped to %d,%d serial %lu\n", x, y, data->warp_serial );
+    TRACE( "warped to (fake) %d,%d serial %lu\n", x, y, data->warp_serial );
     return TRUE;
 }

@@ -1933,9 +1933,11 @@ static BOOL map_raw_event_coords( XIRawEvent *event, INPUT *input, RAWINPUT *raw
     struct x11drv_thread_data *thread_data = x11drv_thread_data();
     XIValuatorClassInfo *x = &thread_data->x_valuator, *y = &thread_data->y_valuator;
     const double *values = event->valuators.values, *raw_values = event->raw_values;
-    double x_raw = 0, y_raw = 0, x_value = 0, y_value = 0, x_scale, y_scale;
+    double x_raw = 0, y_raw = 0, x_value = 0, y_value = 0, x_scale, y_scale, user_to_real_scale;
     RECT virtual_rect;
     int i;
+    POINT pt;
+    HMONITOR monitor;

     if (x->number < 0 || y->number < 0) return FALSE;
     if (!event->valuators.mask_len) return FALSE;
@@ -1968,6 +1999,12 @@ static BOOL map_raw_event_coords( XIRawEvent *event, INPUT *input, RAWINPUT *raw
     else
         FIXME( "Unsupported relative/absolute X/Y axis mismatch\n." );

+    GetCursorPos(&pt);
+    monitor = MonitorFromPoint(pt, MONITOR_DEFAULTTONULL);
+    user_to_real_scale = fs_hack_get_user_to_real_scale(monitor);
+    input->u.mi.dx = lround((double)input->u.mi.dx / user_to_real_scale);
+    input->u.mi.dy = lround((double)input->u.mi.dy / user_to_real_scale);
+
     if (input->u.mi.dwFlags & MOUSEEVENTF_VIRTUALDESK) SetRect( &virtual_rect, 0, 0, 65535, 65535 );
     else virtual_rect = get_virtual_screen_rect();

diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index 3f3deae59ba..bf5f9637227 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -40,6 +40,10 @@
 #include "wine/heap.h"
 #include "wine/debug.h"

+#ifndef ARRAY_SIZE
+#define ARRAY_SIZE(array) (sizeof(array) / sizeof((array)[0]))
+#endif
+
 #ifdef SONAME_LIBGL

 WINE_DEFAULT_DEBUG_CHANNEL(wgl);
@@ -203,6 +207,13 @@ struct wgl_context
     struct gl_drawable *drawables[2];
     struct gl_drawable *new_drawables[2];
     BOOL refresh_drawables;
+    BOOL fs_hack;
+    BOOL fs_hack_integer;
+    GLuint fs_hack_fbo, fs_hack_resolve_fbo;
+    GLuint fs_hack_color_texture, fs_hack_ds_texture;
+    GLuint fs_hack_color_renderbuffer, fs_hack_color_resolve_renderbuffer, fs_hack_ds_renderbuffer;
+    POINT setup_for;
+    GLuint current_draw_fbo, current_read_fbo;
     struct list entry;
 };

@@ -247,6 +258,10 @@ struct gl_drawable
     int                            swap_interval;
     BOOL                           refresh_swap_interval;
     BOOL                           mutable_pf;
+    BOOL                           fs_hack;
+    BOOL                           fs_hack_did_swapbuf;
+    BOOL                           fs_hack_context_set_up;
+    BOOL                           has_scissor_indexed;
 };

 enum glx_swap_control_method
@@ -370,6 +385,10 @@ static int   (*pglXSwapIntervalSGI)(int);
 static void* (*pglXAllocateMemoryNV)(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority);
 static void  (*pglXFreeMemoryNV)(GLvoid *pointer);

+static void (*pglScissorIndexed)(GLuint, GLint, GLint, GLsizei, GLsizei);
+static void (*pglScissorIndexedv)(GLuint, const GLint *);
+static void (*pglGetIntegeri_v)(GLenum, GLuint, GLint *);
+
 /* MESA GLX Extensions */
 static void (*pglXCopySubBufferMESA)(Display *dpy, GLXDrawable drawable, int x, int y, int width, int height);
 static int (*pglXSwapIntervalMESA)(unsigned int interval);
@@ -393,6 +412,27 @@ static void wglFinish(void);
 static void wglFlush(void);
 static const GLubyte *wglGetString(GLenum name);

+/* Fullscreen hack */
+static void (*pglBindFramebuffer)( GLenum target, GLuint framebuffer );
+static void (*pglBindFramebufferEXT)( GLenum target, GLuint framebuffer );
+static void (*pglBindRenderbuffer)( GLenum target, GLuint renderbuffer );
+static void (*pglBlitFramebuffer)( GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter );
+void (*pglDeleteFramebuffers)( GLsizei n, const GLuint *framebuffers );
+void (*pglDeleteRenderbuffers)( GLsizei n, const GLuint *renderbuffers );
+static void (*pglDrawBuffer)( GLenum buffer );
+static void (*pglFramebufferRenderbuffer)( GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer );
+static void (*pglFramebufferTexture2D)( GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level );
+static void (*pglGenFramebuffers)( GLsizei n, GLuint *ids );
+static void (*pglGenRenderbuffers)( GLsizei n, GLuint *renderbuffers );
+static void (*pglReadBuffer)( GLenum src );
+static void (*pglRenderbufferStorage)( GLenum target, GLenum internalformat, GLsizei width, GLsizei height );
+static void (*pglRenderbufferStorageMultisample)( GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height );
+
+static void wglBindFramebuffer( GLenum target, GLuint framebuffer );
+static void wglBindFramebufferEXT( GLenum target, GLuint framebuffer );
+static void wglDrawBuffer( GLenum buffer );
+static void wglReadBuffer( GLenum src );
+
 /* check if the extension is present in the list */
 static BOOL has_extension( const char *list, const char *ext )
 {
@@ -568,9 +608,11 @@ static BOOL WINAPI init_opengl( INIT_ONCE *once, void *param, void **context )
     /* redirect some standard OpenGL functions */
 #define REDIRECT(func) \
     do { p##func = opengl_funcs.gl.p_##func; opengl_funcs.gl.p_##func = w##func; } while(0)
+    REDIRECT( glDrawBuffer );
     REDIRECT( glFinish );
     REDIRECT( glFlush );
     REDIRECT( glGetString );
+    REDIRECT( glReadBuffer );
 #undef REDIRECT

     pglXGetProcAddressARB = dlsym(opengl_handle, "glXGetProcAddressARB");
@@ -579,6 +621,22 @@ static BOOL WINAPI init_opengl( INIT_ONCE *once, void *param, void **context )
         goto failed;
     }

+    /* Fullscreen hack */
+#define LOAD_FUNCPTR(func) p##func = (void *)pglXGetProcAddressARB((const unsigned char *)#func);
+    LOAD_FUNCPTR( glBindFramebuffer );
+    LOAD_FUNCPTR( glBindFramebufferEXT );
+    LOAD_FUNCPTR( glBindRenderbuffer );
+    LOAD_FUNCPTR( glBlitFramebuffer );
+    LOAD_FUNCPTR( glDeleteFramebuffers );
+    LOAD_FUNCPTR( glDeleteRenderbuffers );
+    LOAD_FUNCPTR( glFramebufferRenderbuffer );
+    LOAD_FUNCPTR( glFramebufferTexture2D );
+    LOAD_FUNCPTR( glGenFramebuffers );
+    LOAD_FUNCPTR( glGenRenderbuffers );
+    LOAD_FUNCPTR( glRenderbufferStorage );
+    LOAD_FUNCPTR( glRenderbufferStorageMultisample );
+#undef LOAD_FUNCPTR
+
 #define LOAD_FUNCPTR(f) do if((p##f = (void*)pglXGetProcAddressARB((const unsigned char*)#f)) == NULL) \
     { \
         ERR( "%s not found in libGL, disabling OpenGL.\n", #f ); \
@@ -629,6 +687,10 @@ static BOOL WINAPI init_opengl( INIT_ONCE *once, void *param, void **context )
     /* NV GLX Extension */
     LOAD_FUNCPTR(glXAllocateMemoryNV);
     LOAD_FUNCPTR(glXFreeMemoryNV);
+
+    LOAD_FUNCPTR(glScissorIndexed);
+    LOAD_FUNCPTR(glScissorIndexedv);
+    LOAD_FUNCPTR(glGetIntegeri_v);
 #undef LOAD_FUNCPTR

     if(!X11DRV_WineGL_InitOpenglInfo()) goto failed;
@@ -719,6 +781,13 @@ static BOOL WINAPI init_opengl( INIT_ONCE *once, void *param, void **context )
         pglXSwapBuffersMscOML = pglXGetProcAddressARB( (const GLubyte *)"glXSwapBuffersMscOML" );
     }

+    if (has_extension( glExtensions, "GL_ARB_viewport_array"))
+    {
+        opengl_funcs.ext.p_glGetIntegeri_v = pglGetIntegeri_v;
+        opengl_funcs.ext.p_glScissorIndexed = pglScissorIndexed;
+        opengl_funcs.ext.p_glScissorIndexedv = pglScissorIndexedv;
+    }
+
     X11DRV_WineGL_LoadExtensions();
     init_pixel_formats( gdi_display );
     return TRUE;
@@ -1329,10 +1398,17 @@ static struct gl_drawable *create_gl_drawable( HWND hwnd, const struct wgl_pixel

     if (!known_child && !GetWindow( hwnd, GW_CHILD ) && GetAncestor( hwnd, GA_PARENT ) == GetDesktopWindow())  /* childless top-level window */
     {
+        struct x11drv_win_data *data;
+
         gl->type = DC_GL_WINDOW;
         gl->window = create_client_window( hwnd, visual );
         if (gl->window)
             gl->drawable = pglXCreateWindow( gdi_display, gl->format->fbconfig, gl->window, NULL );
+        data = get_win_data( hwnd );
+        gl->fs_hack = data->fs_hack;
+        if (gl->fs_hack)
+            TRACE( "Window %p has the fullscreen hack enabled\n", hwnd );
+        release_win_data( data );
         TRACE( "%p created client %lx drawable %lx\n", hwnd, gl->window, gl->drawable );
     }
 #ifdef SONAME_LIBXCOMPOSITE
@@ -1454,6 +1530,9 @@ static BOOL set_pixel_format(HDC hdc, int format, BOOL allow_change)
 void sync_gl_drawable( HWND hwnd, BOOL known_child )
 {
     struct gl_drawable *old, *new;
+    struct x11drv_win_data *data;
+
+    TRACE("%p\n", hwnd);

     if (!(old = get_gl_drawable( hwnd, 0 ))) return;

@@ -1472,6 +1551,15 @@ void sync_gl_drawable( HWND hwnd, BOOL known_child )
     default:
         break;
     }
+
+    if (DC_GL_PIXMAP_WIN != old->type) {
+        data = get_win_data( hwnd );
+        old->fs_hack = data->fs_hack;
+        if (old->fs_hack)
+            TRACE( "Window %p has the fullscreen hack enabled\n", hwnd );
+        release_win_data( data );
+    }
+
     release_gl_drawable( old );
 }

@@ -1779,6 +1867,10 @@ static BOOL WINAPI glxdrv_wglDeleteContext(struct wgl_context *ctx)
 static PROC WINAPI glxdrv_wglGetProcAddress(LPCSTR lpszProc)
 {
     if (!strncmp(lpszProc, "wgl", 3)) return NULL;
+    if (!strcmp(lpszProc, "glBindFramebuffer"))
+        return (PROC)wglBindFramebuffer;
+    if (!strcmp(lpszProc, "glBindFramebufferEXT"))
+        return (PROC)wglBindFramebufferEXT;
     return pglXGetProcAddressARB((const GLubyte*)lpszProc);
 }

@@ -1798,12 +1890,248 @@ static void set_context_drawables( struct wgl_context *ctx, struct gl_drawable *
     for (i = 0; i < 4; i++) release_gl_drawable( prev[i] );
 }

+struct fs_hack_fbconfig_attribs
+{
+    int render_type;
+    int buffer_size;
+    int red_size;
+    int green_size;
+    int blue_size;
+    int alpha_size;
+    int depth_size;
+    int stencil_size;
+    int doublebuffer;
+    int samples;
+    int srgb;
+};
+
+struct fs_hack_fbo_attachments_config
+{
+    GLint color_internalformat;
+    GLenum color_format;
+    GLenum color_type;
+    GLint ds_internalformat;
+    GLenum ds_format;
+    GLenum ds_type;
+    int samples;
+};
+
+static void fs_hack_get_attachments_config( struct gl_drawable *gl, struct fs_hack_fbconfig_attribs *attribs,
+        struct fs_hack_fbo_attachments_config *config )
+{
+    if (attribs->render_type != GLX_RGBA_BIT)
+        FIXME( "Unsupported GLX_RENDER_TYPE %#x.\n", attribs->render_type );
+    if (attribs->red_size != 8 || attribs->green_size != 8 || attribs->blue_size != 8)
+        FIXME( "Unsupported RGBA color sizes {%u, %u, %u, %u}.\n",
+                attribs->red_size, attribs->green_size, attribs->blue_size, attribs->alpha_size );
+    if (attribs->srgb)
+        config->color_internalformat = attribs->alpha_size ? GL_SRGB8_ALPHA8 : GL_SRGB8;
+    else
+        config->color_internalformat = attribs->alpha_size ? GL_RGBA8 : GL_RGB8;
+    config->color_format = GL_BGRA;
+    config->color_type = GL_UNSIGNED_INT_8_8_8_8_REV;
+    if (attribs->depth_size || attribs->stencil_size)
+    {
+        if (attribs->depth_size != 24)
+            FIXME( "Unsupported depth buffer size %u.\n", attribs->depth_size );
+        if (attribs->stencil_size && attribs->stencil_size != 8)
+            FIXME( "Unsupported stencil buffer size %u.\n", attribs->stencil_size );
+        config->ds_internalformat = attribs->stencil_size ? GL_DEPTH24_STENCIL8 : GL_DEPTH_COMPONENT24;
+        config->ds_format = attribs->stencil_size ? GL_DEPTH_STENCIL : GL_DEPTH_COMPONENT;
+        config->ds_type = attribs->stencil_size ? GL_UNSIGNED_INT_24_8 : GL_UNSIGNED_INT;
+    }
+    else
+    {
+        config->ds_internalformat = config->ds_format = config->ds_type = 0;
+    }
+    config->samples = attribs->samples;
+}
+
+static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *gl )
+{
+    GLuint prev_draw_fbo, prev_read_fbo, prev_texture, prev_renderbuffer;
+    float prev_clear_color[4];
+    unsigned int i;
+    struct fs_hack_fbo_attachments_config config;
+    struct fs_hack_fbconfig_attribs attribs;
+    static const struct fbconfig_attribs_query
+    {
+        int attribute;
+        unsigned int offset;
+    }
+    queries[] =
+    {
+        {GLX_RENDER_TYPE, offsetof(struct fs_hack_fbconfig_attribs, render_type)},
+        {GLX_BUFFER_SIZE, offsetof(struct fs_hack_fbconfig_attribs, buffer_size)},
+        {GLX_RED_SIZE, offsetof(struct fs_hack_fbconfig_attribs, red_size)},
+        {GLX_GREEN_SIZE, offsetof(struct fs_hack_fbconfig_attribs, green_size)},
+        {GLX_BLUE_SIZE, offsetof(struct fs_hack_fbconfig_attribs, blue_size)},
+        {GLX_ALPHA_SIZE, offsetof(struct fs_hack_fbconfig_attribs, alpha_size)},
+        {GLX_DEPTH_SIZE, offsetof(struct fs_hack_fbconfig_attribs, depth_size)},
+        {GLX_STENCIL_SIZE, offsetof(struct fs_hack_fbconfig_attribs, stencil_size)},
+        {GLX_DOUBLEBUFFER, offsetof(struct fs_hack_fbconfig_attribs, doublebuffer)},
+        {GLX_SAMPLES_ARB, offsetof(struct fs_hack_fbconfig_attribs, samples)},
+        {GLX_FRAMEBUFFER_SRGB_CAPABLE_EXT, offsetof(struct fs_hack_fbconfig_attribs, srgb)},
+    };
+    BYTE *ptr = (BYTE *)&attribs;
+
+    if (ctx->fs_hack)
+    {
+        MONITORINFO monitor_info;
+        HMONITOR monitor;
+        int width, height;
+
+        monitor = fs_hack_monitor_from_hwnd(WindowFromDC(ctx->hdc));
+        memset(&monitor_info, 0, sizeof(monitor_info));
+        monitor_info.cbSize = sizeof(monitor_info);
+        GetMonitorInfoW(monitor, &monitor_info);
+        width = monitor_info.rcMonitor.right - monitor_info.rcMonitor.left;
+        height = monitor_info.rcMonitor.bottom - monitor_info.rcMonitor.top;
+
+        TRACE("Render buffer width:%d height:%d\n", width, height);
+
+        opengl_funcs.gl.p_glGetIntegerv( GL_DRAW_FRAMEBUFFER_BINDING, (GLint *)&prev_draw_fbo );
+        opengl_funcs.gl.p_glGetIntegerv( GL_READ_FRAMEBUFFER_BINDING, (GLint *)&prev_read_fbo );
+        opengl_funcs.gl.p_glGetIntegerv( GL_TEXTURE_BINDING_2D, (GLint *)&prev_texture );
+        opengl_funcs.gl.p_glGetIntegerv( GL_RENDERBUFFER_BINDING, (GLint *)&prev_renderbuffer );
+        opengl_funcs.gl.p_glGetFloatv( GL_COLOR_CLEAR_VALUE, prev_clear_color );
+        TRACE( "Previous draw FBO %u, read FBO %u for ctx %p\n", prev_draw_fbo, prev_read_fbo, ctx);
+
+        if (!ctx->fs_hack_fbo)
+        {
+            pglGenFramebuffers( 1, &ctx->fs_hack_fbo );
+            pglGenFramebuffers( 1, &ctx->fs_hack_resolve_fbo );
+            TRACE( "Created FBO %u for fullscreen hack.\n", ctx->fs_hack_fbo );
+        }
+        pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, ctx->fs_hack_fbo );
+
+        for (i = 0; i < ARRAY_SIZE(queries); ++i)
+            pglXGetFBConfigAttrib( gdi_display, gl->format->fbconfig, queries[i].attribute,
+                    (int *)&ptr[queries[i].offset] );
+        fs_hack_get_attachments_config( gl, &attribs, &config );
+
+        if (config.samples)
+        {
+            if (!ctx->fs_hack_color_renderbuffer)
+                pglGenRenderbuffers( 1, &ctx->fs_hack_color_renderbuffer );
+            pglBindRenderbuffer( GL_RENDERBUFFER, ctx->fs_hack_color_renderbuffer );
+            pglRenderbufferStorageMultisample( GL_RENDERBUFFER, config.samples,
+                    config.color_internalformat, width, height );
+            pglFramebufferRenderbuffer( GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
+                    GL_RENDERBUFFER, ctx->fs_hack_color_renderbuffer );
+            TRACE( "Created renderbuffer %u for fullscreen hack.\n", ctx->fs_hack_color_renderbuffer );
+            pglGenRenderbuffers( 1, &ctx->fs_hack_color_resolve_renderbuffer );
+            pglBindRenderbuffer( GL_RENDERBUFFER, ctx->fs_hack_color_resolve_renderbuffer );
+            pglRenderbufferStorage( GL_RENDERBUFFER, config.color_internalformat, width, height );
+            pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, ctx->fs_hack_resolve_fbo );
+            pglFramebufferRenderbuffer( GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
+                    GL_RENDERBUFFER, ctx->fs_hack_color_resolve_renderbuffer );
+            pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, ctx->fs_hack_fbo );
+            pglBindRenderbuffer( GL_RENDERBUFFER, prev_renderbuffer );
+            TRACE( "Also created renderbuffer %u and FBO %u for color resolve.\n",
+                    ctx->fs_hack_color_resolve_renderbuffer, ctx->fs_hack_resolve_fbo );
+        }
+        else
+        {
+            if (!ctx->fs_hack_color_texture)
+                opengl_funcs.gl.p_glGenTextures( 1, &ctx->fs_hack_color_texture );
+            opengl_funcs.gl.p_glBindTexture( GL_TEXTURE_2D, ctx->fs_hack_color_texture );
+            opengl_funcs.gl.p_glTexImage2D( GL_TEXTURE_2D, 0, config.color_internalformat, width, height,
+                    0, config.color_format, config.color_type, NULL);
+            opengl_funcs.gl.p_glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0);
+            opengl_funcs.gl.p_glBindTexture( GL_TEXTURE_2D, prev_texture );
+            pglFramebufferTexture2D( GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
+                    GL_TEXTURE_2D, ctx->fs_hack_color_texture, 0 );
+            TRACE( "Created texture %u for fullscreen hack.\n", ctx->fs_hack_color_texture );
+        }
+
+        if (config.ds_internalformat)
+        {
+            if (config.samples)
+            {
+                if (!ctx->fs_hack_ds_renderbuffer)
+                    pglGenRenderbuffers( 1, &ctx->fs_hack_ds_renderbuffer );
+                pglBindRenderbuffer( GL_RENDERBUFFER, ctx->fs_hack_ds_renderbuffer );
+                pglRenderbufferStorageMultisample( GL_RENDERBUFFER, config.samples,
+                        config.ds_internalformat, width, height );
+                pglBindRenderbuffer( GL_RENDERBUFFER, prev_renderbuffer );
+                if (attribs.depth_size)
+                    pglFramebufferRenderbuffer( GL_DRAW_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
+                            GL_RENDERBUFFER, ctx->fs_hack_ds_renderbuffer );
+                if (attribs.stencil_size)
+                    pglFramebufferRenderbuffer( GL_DRAW_FRAMEBUFFER, GL_STENCIL_ATTACHMENT,
+                            GL_RENDERBUFFER, ctx->fs_hack_ds_renderbuffer );
+                TRACE( "Created DS renderbuffer %u for fullscreen hack.\n", ctx->fs_hack_ds_renderbuffer );
+            }
+            else
+            {
+                if (!ctx->fs_hack_ds_texture)
+                    opengl_funcs.gl.p_glGenTextures( 1, &ctx->fs_hack_ds_texture );
+                opengl_funcs.gl.p_glBindTexture( GL_TEXTURE_2D, ctx->fs_hack_ds_texture );
+                opengl_funcs.gl.p_glTexImage2D( GL_TEXTURE_2D, 0, config.ds_internalformat, width, height,
+                        0, config.ds_format, config.ds_type, NULL);
+                opengl_funcs.gl.p_glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0);
+                opengl_funcs.gl.p_glBindTexture( GL_TEXTURE_2D, prev_texture );
+                if (attribs.depth_size)
+                    pglFramebufferTexture2D( GL_DRAW_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, ctx->fs_hack_ds_texture, 0 );
+                if (attribs.stencil_size)
+                    pglFramebufferTexture2D( GL_DRAW_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_TEXTURE_2D, ctx->fs_hack_ds_texture, 0 );
+                TRACE( "Created DS texture %u for fullscreen hack.\n", ctx->fs_hack_ds_texture );
+            }
+        }
+
+        opengl_funcs.gl.p_glClearColor( 0.0f, 0.0f, 0.0f, 1.0f );
+        if(!gl->fs_hack_context_set_up)
+            opengl_funcs.gl.p_glClear( GL_COLOR_BUFFER_BIT );
+        pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, 0 );
+        pglDrawBuffer( GL_BACK );
+        if(!gl->fs_hack_context_set_up)
+            opengl_funcs.gl.p_glClear( GL_COLOR_BUFFER_BIT );
+        opengl_funcs.gl.p_glClearColor( prev_clear_color[0], prev_clear_color[1], prev_clear_color[2], prev_clear_color[3] );
+        wglBindFramebuffer( GL_DRAW_FRAMEBUFFER, prev_draw_fbo );
+        wglBindFramebuffer( GL_READ_FRAMEBUFFER, prev_read_fbo );
+
+        ctx->setup_for.x = width;
+        ctx->setup_for.y = height;
+        gl->has_scissor_indexed = has_extension(glExtensions, "GL_ARB_viewport_array");
+        ctx->fs_hack_integer = fs_hack_is_integer();
+        gl->fs_hack_context_set_up = TRUE;
+    }
+    else
+    {
+        TRACE( "Releasing fullscreen hack texture %u and FBO %u\n", ctx->fs_hack_color_texture, ctx->fs_hack_fbo );
+        if (ctx->current_draw_fbo == ctx->fs_hack_fbo)
+        {
+            pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, 0 );
+            ctx->current_draw_fbo = 0;
+        }
+        if (ctx->current_read_fbo == ctx->fs_hack_fbo)
+        {
+            pglBindFramebuffer( GL_READ_FRAMEBUFFER, 0 );
+            ctx->current_read_fbo = 0;
+        }
+
+        pglDeleteRenderbuffers( 1, &ctx->fs_hack_ds_renderbuffer );
+        pglDeleteRenderbuffers( 1, &ctx->fs_hack_color_resolve_renderbuffer );
+        pglDeleteRenderbuffers( 1, &ctx->fs_hack_color_renderbuffer );
+        opengl_funcs.gl.p_glDeleteTextures( 1, &ctx->fs_hack_ds_texture );
+        opengl_funcs.gl.p_glDeleteTextures( 1, &ctx->fs_hack_color_texture );
+        ctx->fs_hack_color_renderbuffer = ctx->fs_hack_color_resolve_renderbuffer = ctx->fs_hack_ds_renderbuffer = 0;
+        ctx->fs_hack_color_texture = ctx->fs_hack_ds_texture = 0;
+        pglDeleteFramebuffers( 1, &ctx->fs_hack_resolve_fbo );
+        pglDeleteFramebuffers( 1, &ctx->fs_hack_fbo );
+        ctx->fs_hack_fbo = 0;
+
+        gl->fs_hack_context_set_up = FALSE;
+    }
+}
+
 /***********************************************************************
  *		glxdrv_wglMakeCurrent
  */
 static BOOL WINAPI glxdrv_wglMakeCurrent(HDC hdc, struct wgl_context *ctx)
 {
-    BOOL ret = FALSE;
+    BOOL ret = FALSE, setup_fs_hack = FALSE;
     struct gl_drawable *gl;

     TRACE("(%p,%p)\n", hdc, ctx);
@@ -1832,10 +2160,17 @@ static BOOL WINAPI glxdrv_wglMakeCurrent(HDC hdc, struct wgl_context *ctx)
         if (ret)
         {
             NtCurrentTeb()->glContext = ctx;
-            ctx->has_been_current = TRUE;
+            if (ctx->fs_hack != gl->fs_hack || (ctx->fs_hack && ctx->drawables[0] != gl))
+                setup_fs_hack = TRUE;
             ctx->hdc = hdc;
             set_context_drawables( ctx, gl, gl );
             ctx->refresh_drawables = FALSE;
+            if (setup_fs_hack)
+            {
+                ctx->fs_hack = gl->fs_hack;
+                fs_hack_setup_context( ctx, gl );
+            }
+            ctx->has_been_current = TRUE;
             LeaveCriticalSection( &context_section );
             goto done;
         }
@@ -1854,7 +2189,7 @@ static BOOL WINAPI glxdrv_wglMakeCurrent(HDC hdc, struct wgl_context *ctx)
  */
 static BOOL X11DRV_wglMakeContextCurrentARB( HDC draw_hdc, HDC read_hdc, struct wgl_context *ctx )
 {
-    BOOL ret = FALSE;
+    BOOL ret = FALSE, setup_fs_hack = FALSE;
     struct gl_drawable *draw_gl, *read_gl = NULL;

     TRACE("(%p,%p,%p)\n", draw_hdc, read_hdc, ctx);
@@ -1877,11 +2212,18 @@ static BOOL X11DRV_wglMakeContextCurrentARB( HDC draw_hdc, HDC read_hdc, struct
                                      read_gl ? read_gl->drawable : 0, ctx->ctx);
         if (ret)
         {
-            ctx->has_been_current = TRUE;
+            NtCurrentTeb()->glContext = ctx;
+            if (ctx->fs_hack != draw_gl->fs_hack || (ctx->fs_hack && ctx->drawables[0] != draw_gl))
+                setup_fs_hack = TRUE;
             ctx->hdc = draw_hdc;
             set_context_drawables( ctx, draw_gl, read_gl );
             ctx->refresh_drawables = FALSE;
-            NtCurrentTeb()->glContext = ctx;
+            if (setup_fs_hack)
+            {
+                ctx->fs_hack = draw_gl->fs_hack;
+                fs_hack_setup_context( ctx, draw_gl );
+            }
+            ctx->has_been_current = TRUE;
             LeaveCriticalSection( &context_section );
             goto done;
         }
@@ -1940,6 +2282,145 @@ static BOOL WINAPI glxdrv_wglShareLists(struct wgl_context *org, struct wgl_cont
     return FALSE;
 }

+static void wglBindFramebuffer( GLenum target, GLuint framebuffer )
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+
+    TRACE( "target %#x, framebuffer %u\n", target, framebuffer );
+    if (ctx->fs_hack && !framebuffer)
+        framebuffer = ctx->fs_hack_fbo;
+
+    if (target == GL_DRAW_FRAMEBUFFER || target == GL_FRAMEBUFFER)
+        ctx->current_draw_fbo = framebuffer;
+    if (target == GL_READ_FRAMEBUFFER || target == GL_FRAMEBUFFER)
+        ctx->current_read_fbo = framebuffer;
+
+    pglBindFramebuffer( target, framebuffer );
+}
+
+static void wglBindFramebufferEXT( GLenum target, GLuint framebuffer )
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+
+    TRACE( "target %#x, framebuffer %u\n", target, framebuffer );
+    if (ctx->fs_hack && !framebuffer)
+        framebuffer = ctx->fs_hack_fbo;
+
+    if (target == GL_DRAW_FRAMEBUFFER || target == GL_FRAMEBUFFER)
+        ctx->current_draw_fbo = framebuffer;
+    if (target == GL_READ_FRAMEBUFFER || target == GL_FRAMEBUFFER)
+        ctx->current_read_fbo = framebuffer;
+
+    pglBindFramebufferEXT( target, framebuffer );
+}
+
+static void wglDrawBuffer( GLenum buffer )
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+
+    if (ctx->fs_hack && ctx->current_draw_fbo == ctx->fs_hack_fbo)
+    {
+        TRACE("Overriding %#x with GL_COLOR_ATTACHMENT0\n", buffer);
+        buffer = GL_COLOR_ATTACHMENT0;
+    }
+    pglDrawBuffer( buffer );
+}
+
+static void wglReadBuffer( GLenum buffer )
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+
+    if (ctx->fs_hack && ctx->current_read_fbo == ctx->fs_hack_fbo)
+    {
+        TRACE("Overriding %#x with GL_COLOR_ATTACHMENT0\n", buffer);
+        buffer = GL_COLOR_ATTACHMENT0;
+    }
+    pglReadBuffer( buffer );
+}
+
+static void fs_hack_blit_framebuffer( struct gl_drawable *gl, GLenum draw_buffer )
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+    SIZE scaled, src, real;
+    GLuint prev_draw_fbo, prev_read_fbo;
+    GLint prev_scissor[4];
+    RECT user_rect, real_rect;
+    POINT scaled_origin;
+    float prev_clear_color[4];
+    HMONITOR monitor;
+
+    monitor = fs_hack_monitor_from_hwnd(WindowFromDC(ctx->hdc));
+    scaled = fs_hack_get_scaled_screen_size(monitor);
+    user_rect = fs_hack_current_mode(monitor);
+    real_rect = fs_hack_real_mode(monitor);
+    src.cx = user_rect.right - user_rect.left;
+    src.cy = user_rect.bottom - user_rect.top;
+    real.cx = real_rect.right - real_rect.left;
+    real.cy = real_rect.bottom - real_rect.top;
+    scaled_origin.x = user_rect.left;
+    scaled_origin.y = user_rect.top;
+    fs_hack_point_user_to_real(&scaled_origin);
+    scaled_origin.x -= real_rect.left;
+    scaled_origin.y -= real_rect.top;
+
+    TRACE("scaled:%dx%d src:%dx%d real:%dx%d user_rect:%s real_rect:%s scaled_origin:%s\n", scaled.cx, scaled.cy,
+          src.cx, src.cy, real.cx, real.cy, wine_dbgstr_rect(&user_rect), wine_dbgstr_rect(&real_rect),
+          wine_dbgstr_point(&scaled_origin));
+
+    if(ctx->setup_for.x != src.cx ||
+            ctx->setup_for.y != src.cy)
+        fs_hack_setup_context( ctx, gl );
+
+    TRACE( "Blitting from FBO %u %ux%u to %ux%u\n", ctx->fs_hack_fbo, src.cx, src.cy, scaled.cx, scaled.cy );
+
+    opengl_funcs.gl.p_glGetIntegerv( GL_DRAW_FRAMEBUFFER_BINDING, (GLint *)&prev_draw_fbo );
+    opengl_funcs.gl.p_glGetIntegerv( GL_READ_FRAMEBUFFER_BINDING, (GLint *)&prev_read_fbo );
+    TRACE( "Previous draw FBO %u, read FBO %u\n", prev_draw_fbo, prev_read_fbo );
+
+    if(gl->has_scissor_indexed){
+        opengl_funcs.ext.p_glGetIntegeri_v(GL_SCISSOR_BOX, 0, prev_scissor);
+        opengl_funcs.ext.p_glScissorIndexed(0, 0, 0, real.cx, real.cy);
+    }else{
+        opengl_funcs.gl.p_glGetIntegerv(GL_SCISSOR_BOX, prev_scissor);
+        opengl_funcs.gl.p_glScissor(0, 0, real.cx, real.cy);
+    }
+
+    pglBindFramebuffer( GL_READ_FRAMEBUFFER, ctx->fs_hack_fbo );
+    if (ctx->fs_hack_color_resolve_renderbuffer)
+    {
+        pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, ctx->fs_hack_resolve_fbo );
+        pglBlitFramebuffer( 0, 0, src.cx, src.cy, 0, 0, src.cx, src.cy, GL_COLOR_BUFFER_BIT, GL_NEAREST );
+        pglBindFramebuffer( GL_READ_FRAMEBUFFER, ctx->fs_hack_resolve_fbo );
+    }
+    pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, 0 );
+
+    //HACK
+    //pglDrawBuffer( draw_buffer );
+    pglDrawBuffer( GL_BACK );
+
+    opengl_funcs.gl.p_glGetFloatv( GL_COLOR_CLEAR_VALUE, prev_clear_color );
+    opengl_funcs.gl.p_glClearColor( 0.0f, 0.0f, 0.0f, 1.0f );
+    opengl_funcs.gl.p_glClear( GL_COLOR_BUFFER_BIT );
+    opengl_funcs.gl.p_glClearColor( prev_clear_color[0], prev_clear_color[1], prev_clear_color[2], prev_clear_color[3] );
+
+    pglBlitFramebuffer( 0, 0, src.cx, src.cy,
+            scaled_origin.x, scaled_origin.y, scaled_origin.x + scaled.cx, scaled_origin.y + scaled.cy,
+            GL_COLOR_BUFFER_BIT, ctx->fs_hack_integer ? GL_NEAREST : GL_LINEAR );
+    //HACK
+    if ( draw_buffer == GL_FRONT )
+        pglXSwapBuffers(gdi_display, gl->drawable);
+
+    if(gl->has_scissor_indexed){
+        opengl_funcs.ext.p_glScissorIndexedv(0, prev_scissor);
+    }else{
+        opengl_funcs.gl.p_glScissor(prev_scissor[0], prev_scissor[1],
+                prev_scissor[2], prev_scissor[3]);
+    }
+
+    pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, prev_draw_fbo );
+    pglBindFramebuffer( GL_READ_FRAMEBUFFER, prev_read_fbo );
+}
+
 static void wglFinish(void)
 {
     struct x11drv_escape_present_drawable escape;
@@ -1959,6 +2440,18 @@ static void wglFinish(void)
         default: break;
         }
         sync_context(ctx);
+
+        if (gl->fs_hack) {
+            ctx->fs_hack = gl->fs_hack;
+            if(!gl->fs_hack_context_set_up)
+                fs_hack_setup_context( ctx, gl );
+            if(!gl->fs_hack_did_swapbuf)
+                fs_hack_blit_framebuffer( gl, GL_FRONT );
+        }else if(gl->fs_hack_context_set_up){
+            ctx->fs_hack = FALSE;
+            fs_hack_setup_context(ctx, gl);
+        }
+
         release_gl_drawable( gl );
     }

@@ -1985,6 +2478,18 @@ static void wglFlush(void)
         default: break;
         }
         sync_context(ctx);
+
+        if (gl->fs_hack) {
+            ctx->fs_hack = gl->fs_hack;
+            if(!gl->fs_hack_context_set_up)
+                fs_hack_setup_context( ctx, gl );
+            if(!gl->fs_hack_did_swapbuf)
+                fs_hack_blit_framebuffer( gl, GL_FRONT );
+        }else if(gl->fs_hack_context_set_up){
+            ctx->fs_hack = FALSE;
+            fs_hack_setup_context(ctx, gl);
+        }
+
         release_gl_drawable( gl );
     }

@@ -3363,6 +3868,16 @@ static BOOL WINAPI glxdrv_wglSwapBuffers( HDC hdc )
             target_sbc = pglXSwapBuffersMscOML( gdi_display, gl->drawable, 0, 0, 0 );
             break;
         }
+        if (gl->fs_hack){
+            ctx->fs_hack = gl->fs_hack;
+            if(!gl->fs_hack_context_set_up)
+                fs_hack_setup_context( ctx, gl );
+            fs_hack_blit_framebuffer( gl, GL_BACK );
+            gl->fs_hack_did_swapbuf = TRUE;
+        }else if(gl->fs_hack_context_set_up){
+            ctx->fs_hack = FALSE;
+            fs_hack_setup_context(ctx, gl);
+        }
         pglXSwapBuffers(gdi_display, gl->drawable);
         break;
     }
diff --git a/dlls/winex11.drv/settings.c b/dlls/winex11.drv/settings.c
index cea7ebbc6b7..5af96dfb5be 100644
--- a/dlls/winex11.drv/settings.c
+++ b/dlls/winex11.drv/settings.c
@@ -36,15 +36,6 @@

 WINE_DEFAULT_DEBUG_CHANNEL(x11settings);

-struct x11drv_display_setting
-{
-    ULONG_PTR id;
-    BOOL placed;
-    RECT new_rect;
-    RECT desired_rect;
-    DEVMODEW desired_mode;
-};
-
 struct x11drv_display_depth
 {
     struct list entry;
@@ -88,6 +79,11 @@ void X11DRV_Settings_SetHandler(const struct x11drv_settings_handler *new_handle
     }
 }

+struct x11drv_settings_handler X11DRV_Settings_GetHandler(void)
+{
+    return handler;
+}
+
 /***********************************************************************
  * Default handlers if resolution switching is not enabled
  *
@@ -170,7 +166,6 @@ static LONG nores_set_current_mode(ULONG_PTR id, DEVMODEW *mode)
     return DISP_CHANGE_SUCCESSFUL;
 }

-/* default handler only gets the current X desktop resolution */
 void X11DRV_Settings_Init(void)
 {
     struct x11drv_settings_handler nores_handler;
@@ -184,6 +179,7 @@ void X11DRV_Settings_Init(void)
     nores_handler.free_modes = nores_free_modes;
     nores_handler.get_current_mode = nores_get_current_mode;
     nores_handler.set_current_mode = nores_set_current_mode;
+    nores_handler.convert_coordinates = NULL;
     X11DRV_Settings_SetHandler(&nores_handler);
 }

@@ -367,7 +363,7 @@ BOOL get_primary_adapter(WCHAR *name)
     return FALSE;
 }

-static int mode_compare(const void *p1, const void *p2)
+int mode_compare(const void *p1, const void *p2)
 {
     DWORD a_width, a_height, b_width, b_height;
     const DEVMODEW *a = p1, *b = p2;
@@ -832,7 +828,6 @@ static POINT get_placement_offset(const struct x11drv_display_setting *displays,

 static void place_all_displays(struct x11drv_display_setting *displays, INT display_count)
 {
-    INT left_most = INT_MAX, top_most = INT_MAX;
     INT placing_idx, display_idx;
     POINT min_offset, offset;

@@ -867,15 +862,6 @@ static void place_all_displays(struct x11drv_display_setting *displays, INT disp
     {
         displays[display_idx].desired_mode.u1.s2.dmPosition.x = displays[display_idx].new_rect.left;
         displays[display_idx].desired_mode.u1.s2.dmPosition.y = displays[display_idx].new_rect.top;
-        left_most = min(left_most, displays[display_idx].new_rect.left);
-        top_most = min(top_most, displays[display_idx].new_rect.top);
-    }
-
-    /* Convert virtual screen coordinates to root coordinates */
-    for (display_idx = 0; display_idx < display_count; ++display_idx)
-    {
-        displays[display_idx].desired_mode.u1.s2.dmPosition.x -= left_most;
-        displays[display_idx].desired_mode.u1.s2.dmPosition.y -= top_most;
     }
 }

diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index 1a077d9323e..6bfbb9dc7bc 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -610,6 +610,64 @@ static VkSurfaceKHR X11DRV_wine_get_native_surface(VkSurfaceKHR surface)
     return x11_surface->surface;
 }

+static VkBool32 X11DRV_query_fs_hack(VkSurfaceKHR surface, VkExtent2D *real_sz, VkExtent2D *user_sz,
+        VkRect2D *dst_blit, VkFilter *filter)
+{
+    struct wine_vk_surface *x11_surface = surface_from_handle(surface);
+    HMONITOR monitor;
+    HWND hwnd;
+
+    if (wm_is_steamcompmgr(gdi_display))
+        return VK_FALSE;
+
+    if (XFindContext(gdi_display, x11_surface->window, winContext, (char **)&hwnd) != 0)
+    {
+        ERR("Failed to find hwnd context\n");
+        return VK_FALSE;
+    }
+
+    monitor = fs_hack_monitor_from_hwnd(hwnd);
+    if(fs_hack_enabled(monitor)){
+        RECT real_rect = fs_hack_real_mode(monitor);
+        RECT user_rect = fs_hack_current_mode(monitor);
+        SIZE scaled = fs_hack_get_scaled_screen_size(monitor);
+        POINT scaled_origin;
+
+        scaled_origin.x = user_rect.left;
+        scaled_origin.y = user_rect.top;
+        fs_hack_point_user_to_real(&scaled_origin);
+        scaled_origin.x -= real_rect.left;
+        scaled_origin.y -= real_rect.top;
+
+        TRACE("real_rect:%s user_rect:%s scaled:%dx%d scaled_origin:%s\n", wine_dbgstr_rect(&real_rect),
+              wine_dbgstr_rect(&user_rect), scaled.cx, scaled.cy, wine_dbgstr_point(&scaled_origin));
+
+        if(real_sz){
+            real_sz->width = real_rect.right - real_rect.left;
+            real_sz->height = real_rect.bottom - real_rect.top;
+        }
+
+        if(user_sz){
+            user_sz->width = user_rect.right - user_rect.left;
+            user_sz->height = user_rect.bottom - user_rect.top;
+        }
+
+        if(dst_blit){
+            dst_blit->offset.x = scaled_origin.x;
+            dst_blit->offset.y = scaled_origin.y;
+            dst_blit->extent.width = scaled.cx;
+            dst_blit->extent.height = scaled.cy;
+        }
+
+        if(filter)
+            *filter = fs_hack_is_integer() ? VK_FILTER_NEAREST : VK_FILTER_LINEAR;
+
+        return VK_TRUE;
+    }
+
+    return VK_FALSE;
+}
+
 static const struct vulkan_funcs vulkan_funcs =
 {
     X11DRV_vkCreateInstance,
@@ -634,6 +692,7 @@ static const struct vulkan_funcs vulkan_funcs =
     X11DRV_vkQueuePresentKHR,

     X11DRV_wine_get_native_surface,
+    X11DRV_query_fs_hack,
 };

 static void *X11DRV_get_vk_device_proc_addr(const char *name)
diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index c6b23d857af..a60001aec6d 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -475,6 +475,11 @@ static void sync_window_region( struct x11drv_win_data *data, HRGN win_region )
     HRGN hrgn = win_region;

     if (!data->whole_window) return;
+
+    if(data->fs_hack){
+        ERR("shaped windows with fs hack not supported, things may go badly\n");
+    }
+
     data->shaped = FALSE;

     if (IsRectEmpty( &data->window_rect ))  /* set an empty shape */
@@ -1144,6 +1149,7 @@ void update_user_time( Time time )
 void update_net_wm_states( struct x11drv_win_data *data )
 {
     DWORD i, style, ex_style, new_state = 0;
+    HMONITOR monitor;
     unsigned long net_wm_bypass_compositor = 0;

     if (!data->managed) return;
@@ -1152,21 +1158,38 @@ void update_net_wm_states( struct x11drv_win_data *data )
     style = GetWindowLongW( data->hwnd, GWL_STYLE );
     if (style & WS_MINIMIZE)
         new_state |= data->net_wm_state & ((1 << NET_WM_STATE_FULLSCREEN)|(1 << NET_WM_STATE_MAXIMIZED));
-    if (is_window_rect_full_screen( &data->whole_rect ))
+    monitor = fs_hack_monitor_from_hwnd( data->hwnd );
+    if ((!data->fs_hack || fs_hack_enabled( monitor )) && is_window_rect_full_screen( &data->whole_rect ))
     {
         if ((style & WS_MAXIMIZE) && (style & WS_CAPTION) == WS_CAPTION)
             new_state |= (1 << NET_WM_STATE_MAXIMIZED);
         else if (!(style & WS_MINIMIZE))
         {
-            net_wm_bypass_compositor = 1;
-            new_state |= (1 << NET_WM_STATE_FULLSCREEN);
+            if (!wm_is_steamcompmgr(data->display) || !fs_hack_enabled(monitor))
+            {
+                /* when fs hack is enabled, we don't want steamcompmgr to resize the window to be fullscreened */
+                net_wm_bypass_compositor = 1;
+                new_state |= (1 << NET_WM_STATE_FULLSCREEN);
+            }
         }
     }
     else if (style & WS_MAXIMIZE)
         new_state |= (1 << NET_WM_STATE_MAXIMIZED);

     ex_style = GetWindowLongW( data->hwnd, GWL_EXSTYLE );
-    if (ex_style & WS_EX_TOPMOST)
+    if ((ex_style & WS_EX_TOPMOST) &&
+            /* mutter < 3.31 has a bug where a FULLSCREEN and ABOVE window when
+             * minimized will incorrectly show a black window.  this workaround
+             * should be removed when the fix is widely distributed.  see
+             * mutter issue #306. */
+            !(wm_is_mutter(data->display) && (new_state & (1 << NET_WM_STATE_FULLSCREEN))) &&
+
+            /* KDE refuses to allow alt-tabbing out of fullscreen+above
+             * windows. Other WMs (XFCE) don't make fullscreen (without above)
+             * windows appear above their panels. KDE still does the right
+             * thing with fullscreen-only windows, so let's comprimise by not
+             * setting above on KDE. */
+            !wm_is_kde(data->display))
         new_state |= (1 << NET_WM_STATE_ABOVE);
     if (!data->add_taskbar)
     {
@@ -1213,6 +1236,12 @@ void update_net_wm_states( struct x11drv_win_data *data )
                    i, data->hwnd, data->whole_window,
                    (new_state & (1 << i)) != 0, (data->net_wm_state & (1 << i)) != 0 );

+            if(i == NET_WM_STATE_FULLSCREEN)
+            {
+                data->pending_fullscreen = (new_state & (1 << i)) != 0;
+                TRACE("set pending_fullscreen to: %u\n", data->pending_fullscreen);
+            }
+
             xev.xclient.data.l[0] = (new_state & (1 << i)) ? _NET_WM_STATE_ADD : _NET_WM_STATE_REMOVE;
             xev.xclient.data.l[1] = X11DRV_Atoms[net_wm_state_atoms[i] - FIRST_XATOM];
             xev.xclient.data.l[2] = ((net_wm_state_atoms[i] == XATOM__NET_WM_STATE_MAXIMIZED_VERT) ?
@@ -1458,8 +1487,19 @@ static void sync_window_position( struct x11drv_win_data *data,
     /* resizing a managed maximized window is not allowed */
     if (!(style & WS_MAXIMIZE) || !data->managed)
     {
-        changes.width = data->whole_rect.right - data->whole_rect.left;
-        changes.height = data->whole_rect.bottom - data->whole_rect.top;
+        if(data->fs_hack){
+            HMONITOR monitor;
+            RECT rect;
+
+            monitor = fs_hack_monitor_from_hwnd(data->hwnd);
+            rect = fs_hack_real_mode(monitor);
+            changes.width = rect.right - rect.left;
+            changes.height = rect.bottom - rect.top;
+            TRACE("change width:%d height:%d\n", changes.width, changes.height);
+        }else{
+            changes.width = data->whole_rect.right - data->whole_rect.left;
+            changes.height = data->whole_rect.bottom - data->whole_rect.top;
+        }
         /* if window rect is empty force size to 1x1 */
         if (changes.width <= 0 || changes.height <= 0) changes.width = changes.height = 1;
         if (changes.width > 65535) changes.width = 65535;
@@ -1542,6 +1582,20 @@ static void sync_client_position( struct x11drv_win_data *data,
     if (changes.width  != old_client_rect->right - old_client_rect->left) mask |= CWWidth;
     if (changes.height != old_client_rect->bottom - old_client_rect->top) mask |= CWHeight;

+    if(data->fs_hack){
+        HMONITOR monitor;
+        RECT rect;
+
+        monitor = fs_hack_monitor_from_hwnd(data->hwnd);
+        rect = fs_hack_real_mode(monitor);
+        changes.x = 0;
+        changes.y = 0;
+        changes.width = rect.right - rect.left;
+        changes.height = rect.bottom - rect.top;
+        mask = CWX | CWY | CWWidth | CWHeight;
+        TRACE( "x:%d y:%d width:%d height:%d\n", changes.x, changes.y, changes.width, changes.height );
+    }
+
     if (mask)
     {
         TRACE( "setting client win %lx pos %d,%d,%dx%d changes=%x\n",
@@ -1713,6 +1767,16 @@ Window create_client_window( HWND hwnd, const XVisualInfo *visual )
     cx = min( max( 1, data->client_rect.right - data->client_rect.left ), 65535 );
     cy = min( max( 1, data->client_rect.bottom - data->client_rect.top ), 65535 );

+    if(data->fs_hack){
+        HMONITOR monitor = fs_hack_monitor_from_hwnd(hwnd);
+        RECT rect = fs_hack_real_mode(monitor);
+        cx = rect.right - rect.left;
+        cy = rect.bottom - rect.top;
+
+        TRACE("width:%d height:%d\n", cx, cy);
+    }
+
+    TRACE("setting client rect: %u, %u x %ux%u\n", x, y, cx, cy);
     ret = data->client_window = XCreateWindow( gdi_display,
                                                data->whole_window ? data->whole_window : dummy_parent,
                                                x, y, cx, cy, 0, default_visual.depth, InputOutput,
@@ -1721,6 +1785,8 @@ Window create_client_window( HWND hwnd, const XVisualInfo *visual )
     if (data->client_window)
     {
         XSaveContext( data->display, data->client_window, winContext, (char *)data->hwnd );
+        /* Save to gdi_display as well for fullscreen hack, needed in X11DRV_query_fs_hack() */
+        XSaveContext( gdi_display, data->client_window, winContext, (char *)data->hwnd );
         XMapWindow( gdi_display, data->client_window );
         XSync( gdi_display, False );
         if (data->whole_window) XSelectInput( data->display, data->client_window, ExposureMask );
@@ -1765,11 +1831,25 @@ static void create_whole_window( struct x11drv_win_data *data )

     mask = get_window_attributes( data, &attr );

+    attr.background_pixel = XBlackPixel(data->display, data->vis.screen);
+    mask |= CWBackPixel;
+
     if (!(cx = data->whole_rect.right - data->whole_rect.left)) cx = 1;
     else if (cx > 65535) cx = 65535;
     if (!(cy = data->whole_rect.bottom - data->whole_rect.top)) cy = 1;
     else if (cy > 65535) cy = 65535;

+    if(data->fs_hack){
+        RECT rect = {0, 0, 0, 0};
+        HMONITOR monitor;
+
+        monitor = fs_hack_monitor_from_hwnd(data->hwnd);
+        rect = fs_hack_real_mode(monitor);
+        cx = rect.right - rect.left;
+        cy = rect.bottom - rect.top;
+        TRACE("width:%d height:%d\n", cx, cy);
+    }
+
     pos = virtual_screen_to_root( data->whole_rect.left, data->whole_rect.top );
     data->whole_window = XCreateWindow( data->display, root_window, pos.x, pos.y,
                                         cx, cy, 0, data->vis.depth, InputOutput,
@@ -2540,9 +2620,45 @@ BOOL CDECL X11DRV_WindowPosChanging( HWND hwnd, HWND insert_after, UINT swp_flag
     DWORD flags;
     COLORREF key;
     BOOL layered = GetWindowLongW( hwnd, GWL_EXSTYLE ) & WS_EX_LAYERED;
+    HMONITOR monitor;

     if (!data && !(data = X11DRV_create_win_data( hwnd, window_rect, client_rect ))) return TRUE;

+    monitor = fs_hack_monitor_from_rect(window_rect);
+    if(!wm_is_steamcompmgr(data->display) && !data->fs_hack && fs_hack_enabled(monitor) &&
+            fs_hack_matches_current_mode(monitor,
+                window_rect->right - window_rect->left,
+                window_rect->bottom - window_rect->top)){
+        RECT real_rect = fs_hack_real_mode(monitor);
+        RECT user_rect = fs_hack_current_mode(monitor);
+        POINT tl = virtual_screen_to_root(user_rect.left, user_rect.top);
+
+        TRACE("Enabling fs hack for %p, resizing the window to (%u,%u)-(%u,%u)\n", hwnd, tl.x, tl.y, real_rect.right - real_rect.left, real_rect.bottom - real_rect.top);
+        data->fs_hack = TRUE;
+        if(data->whole_window)
+            XMoveResizeWindow(data->display, data->whole_window, tl.x, tl.y, real_rect.right - real_rect.left, real_rect.bottom - real_rect.top);
+        if(data->client_window)
+            XMoveResizeWindow(data->display, data->client_window, 0, 0, real_rect.right - real_rect.left, real_rect.bottom - real_rect.top);
+    }else if(data->fs_hack && (!fs_hack_enabled(monitor) ||
+            !fs_hack_matches_current_mode(monitor,
+                window_rect->right - window_rect->left,
+                window_rect->bottom - window_rect->top))){
+        TRACE("Disabling fs hack for %p\n", hwnd);
+        data->fs_hack = FALSE;
+        if(data->whole_window)
+            XMoveResizeWindow(data->display, data->whole_window,
+                    window_rect->left, window_rect->top,
+                    window_rect->right - window_rect->left,
+                    window_rect->bottom - window_rect->top);
+        if(data->client_window){
+            XMoveResizeWindow(data->display, data->client_window,
+                    data->client_rect.left - data->whole_rect.left,
+                    data->client_rect.top - data->whole_rect.top,
+                    data->client_rect.right - data->client_rect.left,
+                    data->client_rect.bottom - data->client_rect.top);
+        }
+    }
+
     /* check if we need to switch the window to managed */
     if (!data->managed && data->whole_window && is_window_managed( hwnd, swp_flags, window_rect ))
     {
@@ -2678,6 +2794,9 @@ void CDECL X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags
         return;
     }

+    if (data->fs_hack)
+        sync_gl_drawable( hwnd, FALSE );
+
     /* check if we are currently processing an event relevant to this window */
     event_type = 0;
     if (thread_data &&
@@ -2772,6 +2891,7 @@ UINT CDECL X11DRV_ShowWindow( HWND hwnd, INT cmd, RECT *rect, UINT swp )
     DWORD style = GetWindowLongW( hwnd, GWL_STYLE );
     struct x11drv_thread_data *thread_data = x11drv_thread_data();
     struct x11drv_win_data *data = get_win_data( hwnd );
+    HMONITOR monitor;

     if (!data || !data->whole_window) goto done;
     if (style & WS_MINIMIZE)
@@ -2801,7 +2921,25 @@ UINT CDECL X11DRV_ShowWindow( HWND hwnd, INT cmd, RECT *rect, UINT swp )
                   &root, &x, &y, &width, &height, &border, &depth );
     XTranslateCoordinates( thread_data->display, data->whole_window, root, 0, 0, &x, &y, &top );
     pos = root_to_virtual_screen( x, y );
-    X11DRV_X_to_window_rect( data, rect, pos.x, pos.y, width, height );
+    monitor = fs_hack_monitor_from_hwnd(hwnd);
+    if (data->fs_hack ||
+            (fs_hack_enabled(monitor) &&
+             fs_hack_matches_current_mode(monitor,
+                 rect->right - rect->left,
+                 rect->bottom - rect->top)))
+    {
+        MONITORINFO monitor_info;
+
+        monitor_info.cbSize = sizeof(monitor_info);
+        GetMonitorInfoW( monitor, &monitor_info );
+        X11DRV_X_to_window_rect( data, rect, monitor_info.rcMonitor.left, monitor_info.rcMonitor.top,
+                                 monitor_info.rcMonitor.right - monitor_info.rcMonitor.left,
+                                 monitor_info.rcMonitor.bottom - monitor_info.rcMonitor.top );
+    }
+    else
+    {
+        X11DRV_X_to_window_rect( data, rect, pos.x, pos.y, width, height );
+    }
     swp &= ~(SWP_NOMOVE | SWP_NOCLIENTMOVE | SWP_NOSIZE | SWP_NOCLIENTSIZE);

 done:
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 213143014a7..26843c830eb 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -443,6 +443,7 @@ extern BOOL private_color_map DECLSPEC_HIDDEN;
 extern int primary_monitor DECLSPEC_HIDDEN;
 extern int copy_default_colors DECLSPEC_HIDDEN;
 extern int alloc_system_colors DECLSPEC_HIDDEN;
+extern int limit_number_of_resolutions DECLSPEC_HIDDEN;
 extern int xrender_error_base DECLSPEC_HIDDEN;
 extern int xfixes_event_base DECLSPEC_HIDDEN;
 extern HMODULE x11drv_module DECLSPEC_HIDDEN;
@@ -626,6 +627,7 @@ struct x11drv_win_data
     BOOL        skip_taskbar : 1; /* does window should be deleted from taskbar */
     BOOL        add_taskbar : 1; /* does window should be added to taskbar regardless of style */
     BOOL        pending_fullscreen : 1;
+    BOOL        fs_hack : 1;
     ULONGLONG   take_focus_back;
     int         wm_state;       /* current value of the WM_STATE property */
     DWORD       net_wm_state;   /* bit mask of active x11drv_net_wm_state values */
@@ -670,6 +672,23 @@ extern BOOL wm_is_mutter(Display *) DECLSPEC_HIDDEN;
 extern BOOL wm_is_steamcompmgr(Display *) DECLSPEC_HIDDEN;

 extern void set_wm_hints( struct x11drv_win_data *data ) DECLSPEC_HIDDEN;
+extern BOOL fs_hack_enabled(HMONITOR monitor) DECLSPEC_HIDDEN;
+extern BOOL fs_hack_mapping_required(HMONITOR monitor) DECLSPEC_HIDDEN;
+extern BOOL fs_hack_is_integer(void) DECLSPEC_HIDDEN;
+extern HMONITOR fs_hack_monitor_from_hwnd(HWND hwnd) DECLSPEC_HIDDEN;
+extern HMONITOR fs_hack_monitor_from_rect(const RECT *rect) DECLSPEC_HIDDEN;
+extern BOOL fs_hack_matches_current_mode(HMONITOR monitor, INT width, INT height) DECLSPEC_HIDDEN;
+extern RECT fs_hack_current_mode(HMONITOR monitor) DECLSPEC_HIDDEN;
+extern RECT fs_hack_real_mode(HMONITOR monitor) DECLSPEC_HIDDEN;
+extern void fs_hack_point_user_to_real(POINT *pos) DECLSPEC_HIDDEN;
+extern void fs_hack_point_real_to_user(POINT *pos) DECLSPEC_HIDDEN;
+extern void fs_hack_rect_user_to_real(RECT *rect) DECLSPEC_HIDDEN;
+extern void fs_hack_rgndata_user_to_real(RGNDATA *data) DECLSPEC_HIDDEN;
+extern double fs_hack_get_user_to_real_scale(HMONITOR) DECLSPEC_HIDDEN;
+extern SIZE fs_hack_get_scaled_screen_size(HMONITOR monitor) DECLSPEC_HIDDEN;
+extern RECT fs_hack_get_real_virtual_screen(void) DECLSPEC_HIDDEN;
+extern void fs_hack_init(void) DECLSPEC_HIDDEN;
+extern int mode_compare(const void *p1, const void *p2) DECLSPEC_HIDDEN;

 static inline void mirror_rect( const RECT *window_rect, RECT *rect )
 {
@@ -718,6 +737,16 @@ extern void xinerama_init( unsigned int width, unsigned int height ) DECLSPEC_HI
 #define DEPTH_COUNT 3
 extern const unsigned int *depths DECLSPEC_HIDDEN;

+struct x11drv_display_setting
+{
+    ULONG_PTR id;
+    BOOL placed;
+    RECT new_rect;
+    RECT old_rect;
+    RECT desired_rect;
+    DEVMODEW desired_mode;
+};
+
 /* Required functions for changing and enumerating display settings */
 struct x11drv_settings_handler
 {
@@ -761,9 +790,14 @@ struct x11drv_settings_handler
      *
      * Return DISP_CHANGE_*, same as ChangeDisplaySettingsExW() return values */
     LONG (*set_current_mode)(ULONG_PTR id, DEVMODEW *mode);
+
+    /* convert_coordinates() will be called to convert virtual screen coordinates to driver specific coordinates.
+     * This function is optional and can be NULL if driver don't need to convert coordinates */
+    void (*convert_coordinates)(struct x11drv_display_setting *displays, UINT display_count);
 };

 extern void X11DRV_Settings_SetHandler(const struct x11drv_settings_handler *handler) DECLSPEC_HIDDEN;
+extern struct x11drv_settings_handler X11DRV_Settings_GetHandler(void) DECLSPEC_HIDDEN;

 extern void X11DRV_init_desktop( Window win, unsigned int width, unsigned int height ) DECLSPEC_HIDDEN;
 extern void X11DRV_resize_desktop(BOOL) DECLSPEC_HIDDEN;
@@ -825,6 +859,7 @@ extern HANDLE get_display_device_init_mutex(void) DECLSPEC_HIDDEN;
 extern BOOL get_host_primary_gpu(struct gdi_gpu *gpu) DECLSPEC_HIDDEN;
 extern void release_display_device_init_mutex(HANDLE) DECLSPEC_HIDDEN;
 extern void X11DRV_DisplayDevices_SetHandler(const struct x11drv_display_device_handler *handler) DECLSPEC_HIDDEN;
+extern struct x11drv_display_device_handler X11DRV_DisplayDevices_GetHandler(void) DECLSPEC_HIDDEN;
 extern void X11DRV_DisplayDevices_Init(BOOL force) DECLSPEC_HIDDEN;
 extern void X11DRV_DisplayDevices_RegisterEventHandlers(void) DECLSPEC_HIDDEN;
 extern void X11DRV_DisplayDevices_Update(BOOL) DECLSPEC_HIDDEN;
diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index 1e7c140641f..c9ca46364cd 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -63,7 +63,7 @@ Colormap default_colormap = None;
 XPixmapFormatValues **pixmap_formats;
 unsigned int screen_bpp;
 Window root_window;
-BOOL usexvidmode = TRUE;
+BOOL usexvidmode = FALSE;
 BOOL usexrandr = TRUE;
 BOOL usexcomposite = TRUE;
 BOOL use_xfixes = FALSE;
@@ -83,6 +83,7 @@ BOOL client_side_with_render = TRUE;
 BOOL shape_layered_windows = TRUE;
 int copy_default_colors = 128;
 int alloc_system_colors = 256;
+int limit_number_of_resolutions = 0;
 DWORD thread_data_tls_index = TLS_OUT_OF_INDEXES;
 int xrender_error_base = 0;
 int xfixes_event_base = 0;
@@ -456,6 +457,9 @@ static void setup_options(void)
     if (!get_config_key( hkey, appkey, "AllocSystemColors", buffer, sizeof(buffer) ))
         alloc_system_colors = atoi(buffer);

+    if (!get_config_key( hkey, appkey, "LimitNumberOfResolutions", buffer, sizeof(buffer) ))
+        limit_number_of_resolutions = atoi(buffer);
+
     get_config_key( hkey, appkey, "InputStyle", input_style, sizeof(input_style) );

     if (appkey) RegCloseKey( appkey );
@@ -706,6 +710,8 @@ static BOOL process_attach(void)
     X11DRV_InitMouse( gdi_display );
     if (use_xim) use_xim = X11DRV_InitXIM( input_style );

+    fs_hack_init();
+
     init_user_driver();
     X11DRV_DisplayDevices_Init(FALSE);
     return TRUE;
diff --git a/dlls/winex11.drv/xrandr.c b/dlls/winex11.drv/xrandr.c
index fb7a4405a1e..0a080ea6be8 100644
--- a/dlls/winex11.drv/xrandr.c
+++ b/dlls/winex11.drv/xrandr.c
@@ -1647,6 +1647,24 @@ static LONG xrandr14_set_current_mode( ULONG_PTR id, DEVMODEW *mode )

 #endif

+static void xrandr14_convert_coordinates( struct x11drv_display_setting *displays, UINT display_count )
+{
+    INT left_most = INT_MAX, top_most = INT_MAX;
+    UINT display_idx;
+
+    for (display_idx = 0; display_idx < display_count; ++display_idx)
+    {
+        left_most = min( left_most, displays[display_idx].desired_mode.u1.s2.dmPosition.x );
+        top_most = min( top_most, displays[display_idx].desired_mode.u1.s2.dmPosition.y );
+    }
+
+    for (display_idx = 0; display_idx < display_count; ++display_idx)
+    {
+        displays[display_idx].desired_mode.u1.s2.dmPosition.x -= left_most;
+        displays[display_idx].desired_mode.u1.s2.dmPosition.y -= top_most;
+    }
+}
+
 void X11DRV_XRandR_Init(void)
 {
     struct x11drv_display_device_handler display_handler;
@@ -1675,6 +1693,7 @@ void X11DRV_XRandR_Init(void)
     settings_handler.free_modes = xrandr10_free_modes;
     settings_handler.get_current_mode = xrandr10_get_current_mode;
     settings_handler.set_current_mode = xrandr10_set_current_mode;
+    settings_handler.convert_coordinates = NULL;
     X11DRV_Settings_SetHandler( &settings_handler );

 #ifdef HAVE_XRRGETPROVIDERRESOURCES
@@ -1733,6 +1752,7 @@ void X11DRV_XRandR_Init(void)
         settings_handler.free_modes = xrandr14_free_modes;
         settings_handler.get_current_mode = xrandr14_get_current_mode;
         settings_handler.set_current_mode = xrandr14_set_current_mode;
+        settings_handler.convert_coordinates = xrandr14_convert_coordinates;
         X11DRV_Settings_SetHandler( &settings_handler );
     }
 #endif
diff --git a/dlls/winex11.drv/xrender.c b/dlls/winex11.drv/xrender.c
index 92dc35fa9e1..d43d67c02cf 100644
--- a/dlls/winex11.drv/xrender.c
+++ b/dlls/winex11.drv/xrender.c
@@ -475,6 +475,7 @@ static void update_xrender_clipping( struct xrender_physdev *dev, HRGN rgn )
     }
     else if ((data = X11DRV_GetRegionData( rgn, 0 )))
     {
+        fs_hack_rgndata_user_to_real(data);
         pXRenderSetPictureClipRectangles( gdi_display, dev->pict,
                                           dev->x11dev->dc_rect.left, dev->x11dev->dc_rect.top,
                                           (XRectangle *)data->Buffer, data->rdh.nCount );
@@ -1461,13 +1462,77 @@ static void multiply_alpha( Picture pict, XRenderPictFormat *format, int alpha,
     XFreePixmap( gdi_display, mask_pixmap );
 }

+/* if we are letterboxing, draw black bars */
+static void fs_hack_draw_black_bars( HMONITOR monitor, Picture dst_pict )
+{
+    static const XRenderColor black = { 0, 0, 0, 0xffff };
+    POINT tl, br;   /* top-left / bottom-right */
+    RECT user_rect = fs_hack_current_mode(monitor);
+    RECT real_rect = fs_hack_real_mode(monitor);
+    SIZE scaled_screen = fs_hack_get_scaled_screen_size(monitor);
+    XRenderPictureAttributes pa;
+
+    /* first unclip the picture, so that we can actually draw them */
+    pa.clip_mask = None;
+    pXRenderChangePicture( gdi_display, dst_pict, CPClipMask, &pa );
+
+    tl.x = user_rect.left;
+    tl.y = user_rect.top;
+    fs_hack_point_user_to_real(&tl);
+    tl.x = tl.x - real_rect.left;
+    tl.y = tl.y - real_rect.top;
+    br.x = tl.x + scaled_screen.cx;
+    br.y = tl.y + scaled_screen.cy;
+
+    if (tl.x > 0)
+    {
+        /* black bars left & right */
+        pXRenderFillRectangle(gdi_display, PictOpSrc, dst_pict, &black,
+                0, 0, /* x, y */
+                tl.x, real_rect.bottom - real_rect.top);    /* w, h */
+        pXRenderFillRectangle(gdi_display, PictOpSrc, dst_pict, &black,
+                br.x, 0,
+                real_rect.right - real_rect.left - br.x, real_rect.bottom - real_rect.top);
+    }
+    else if (tl.y > 0)
+    {
+        /* black bars top & bottom */
+        pXRenderFillRectangle(gdi_display, PictOpSrc, dst_pict, &black,
+                0, 0,
+                real_rect.right - real_rect.left, tl.y);
+        pXRenderFillRectangle(gdi_display, PictOpSrc, dst_pict, &black,
+                0, br.y,
+                real_rect.right - real_rect.left, real_rect.bottom - real_rect.top - br.y);
+    }
+}
+
 /* Helper function for (stretched) blitting using xrender */
-static void xrender_blit( int op, Picture src_pict, Picture mask_pict, Picture dst_pict,
+static void xrender_blit( struct xrender_physdev *physdev,
+                          int op, Picture src_pict, Picture mask_pict, Picture dst_pict,
                           int x_src, int y_src, int width_src, int height_src,
                           int x_dst, int y_dst, int width_dst, int height_dst,
                           double xscale, double yscale )
 {
     int x_offset, y_offset;
+    HMONITOR monitor;
+
+    monitor = fs_hack_monitor_from_hwnd(WindowFromDC(physdev->dev.hdc));
+    if (fs_hack_mapping_required(monitor))
+    {
+        double user_to_real_scale;
+        POINT p;
+        p.x = x_dst;
+        p.y = y_dst;
+        fs_hack_point_user_to_real(&p);
+        x_dst = p.x;
+        y_dst = p.y;
+
+        user_to_real_scale = fs_hack_get_user_to_real_scale(monitor);
+        width_dst *= user_to_real_scale;
+        height_dst *= user_to_real_scale;
+        xscale /= user_to_real_scale;
+        yscale /= user_to_real_scale;
+    }

     if (width_src < 0)
     {
@@ -1508,6 +1573,9 @@ static void xrender_blit( int op, Picture src_pict, Picture mask_pict, Picture d
     }
     pXRenderComposite( gdi_display, op, src_pict, mask_pict, dst_pict,
                        x_offset, y_offset, 0, 0, x_dst, y_dst, width_dst, height_dst );
+
+    if (fs_hack_mapping_required( monitor ))
+        fs_hack_draw_black_bars( monitor, dst_pict );
 }

 /* Helper function for (stretched) mono->color blitting using xrender */
@@ -1664,7 +1732,7 @@ static void xrender_stretch_blit( struct xrender_physdev *physdev_src, struct xr
         if (physdev_dst->pict_format->depth == 32 && physdev_src->pict_format->depth < 32)
             mask_pict = get_no_alpha_mask();

-        xrender_blit( PictOpSrc, src_pict, mask_pict, dst_pict,
+        xrender_blit( physdev_dst, PictOpSrc, src_pict, mask_pict, dst_pict,
                       physdev_src->x11dev->dc_rect.left + src->x,
                       physdev_src->x11dev->dc_rect.top + src->y,
                       src->width, src->height, x_dst, y_dst, dst->width, dst->height, xscale, yscale );
@@ -1688,6 +1756,7 @@ static void xrender_put_image( Pixmap src_pixmap, Picture src_pict, Picture mask
         RGNDATA *clip_data = NULL;

         if (clip) clip_data = X11DRV_GetRegionData( clip, 0 );
+        fs_hack_rgndata_user_to_real(clip_data);
         x_dst = dst->x;
         y_dst = dst->y;
         dst_pict = pXRenderCreatePicture( gdi_display, drawable, dst_format, 0, NULL );
@@ -1710,7 +1779,7 @@ static void xrender_put_image( Pixmap src_pixmap, Picture src_pict, Picture mask
     }
     else xscale = yscale = 1;  /* no scaling needed with a repeating source */

-    xrender_blit( PictOpSrc, src_pict, mask_pict, dst_pict, src->x, src->y, src->width, src->height,
+    xrender_blit( physdev, PictOpSrc, src_pict, mask_pict, dst_pict, src->x, src->y, src->width, src->height,
                   x_dst, y_dst, dst->width, dst->height, xscale, yscale );

     if (drawable) pXRenderFreePicture( gdi_display, dst_pict );
@@ -1726,6 +1795,11 @@ static BOOL CDECL xrenderdrv_StretchBlt( PHYSDEV dst_dev, struct bitblt_coords *
     struct xrender_physdev *physdev_dst = get_xrender_dev( dst_dev );
     struct xrender_physdev *physdev_src = get_xrender_dev( src_dev );
     BOOL stretch = (src->width != dst->width) || (src->height != dst->height);
+    HMONITOR monitor;
+
+    TRACE("src %d,%d %dx%d vis=%s  dst %d,%d %dx%d vis=%s  rop=%06x\n",
+          src->x, src->y, src->width, src->height, wine_dbgstr_rect(&src->visrect),
+          dst->x, dst->y, dst->width, dst->height, wine_dbgstr_rect(&dst->visrect), rop );

     if (src_dev->funcs != dst_dev->funcs)
     {
@@ -1737,6 +1811,10 @@ static BOOL CDECL xrenderdrv_StretchBlt( PHYSDEV dst_dev, struct bitblt_coords *
     if (physdev_dst->format == WXR_FORMAT_MONO && physdev_src->format != WXR_FORMAT_MONO)
         goto x11drv_fallback;

+    monitor = fs_hack_monitor_from_hwnd(WindowFromDC(dst_dev->hdc));
+    if (fs_hack_mapping_required(monitor))
+        stretch = TRUE;
+
     /* if not stretching, we only need to handle format conversion */
     if (!stretch && physdev_dst->format == physdev_src->format) goto x11drv_fallback;

@@ -1755,8 +1833,20 @@ static BOOL CDECL xrenderdrv_StretchBlt( PHYSDEV dst_dev, struct bitblt_coords *
         tmpGC = XCreateGC( gdi_display, physdev_dst->x11dev->drawable, 0, NULL );
         XSetSubwindowMode( gdi_display, tmpGC, IncludeInferiors );
         XSetGraphicsExposures( gdi_display, tmpGC, False );
-        tmp_pixmap = XCreatePixmap( gdi_display, root_window, tmp.visrect.right - tmp.visrect.left,
-                                    tmp.visrect.bottom - tmp.visrect.top, physdev_dst->pict_format->depth );
+
+        if (fs_hack_mapping_required( monitor ))
+        {
+            double user_to_real_scale;
+            SIZE size;
+
+            user_to_real_scale = fs_hack_get_user_to_real_scale( monitor );
+            size.cx = (tmp.visrect.right - tmp.visrect.left) * user_to_real_scale;
+            size.cy = (tmp.visrect.bottom - tmp.visrect.top) * user_to_real_scale;
+            tmp_pixmap = XCreatePixmap( gdi_display, root_window, size.cx, size.cy, physdev_dst->pict_format->depth );
+        }
+        else
+            tmp_pixmap = XCreatePixmap( gdi_display, root_window, tmp.visrect.right - tmp.visrect.left,
+                                        tmp.visrect.bottom - tmp.visrect.top, physdev_dst->pict_format->depth );

         xrender_stretch_blit( physdev_src, physdev_dst, tmp_pixmap, src, &tmp );
         execute_rop( physdev_dst->x11dev, tmp_pixmap, tmpGC, &dst->visrect, rop );
@@ -1791,6 +1881,10 @@ static DWORD CDECL xrenderdrv_PutImage( PHYSDEV dev, HRGN clip, BITMAPINFO *info
     Picture src_pict, mask_pict = 0;
     BOOL use_repeat;

+    TRACE("src %d,%d %dx%d vis=%s  dst %d,%d %dx%d vis=%s  rop=%06x\n",
+          src->x, src->y, src->width, src->height, wine_dbgstr_rect(&src->visrect),
+          dst->x, dst->y, dst->width, dst->height, wine_dbgstr_rect(&dst->visrect), rop );
+
     dst_format = physdev->format;
     src_format = get_xrender_format_from_bitmapinfo( info );
     if (!(pict_format = pict_formats[src_format])) goto update_format;
@@ -1815,6 +1909,7 @@ static DWORD CDECL xrenderdrv_PutImage( PHYSDEV dev, HRGN clip, BITMAPINFO *info
         if (rop != SRCCOPY)
         {
             BOOL restore_region = add_extra_clipping_region( physdev->x11dev, clip );
+            HMONITOR monitor;

             /* make coordinates relative to tmp pixmap */
             tmp = *dst;
@@ -1825,13 +1920,29 @@ static DWORD CDECL xrenderdrv_PutImage( PHYSDEV dev, HRGN clip, BITMAPINFO *info
             gc = XCreateGC( gdi_display, physdev->x11dev->drawable, 0, NULL );
             XSetSubwindowMode( gdi_display, gc, IncludeInferiors );
             XSetGraphicsExposures( gdi_display, gc, False );
-            tmp_pixmap = XCreatePixmap( gdi_display, root_window,
-                                        tmp.visrect.right - tmp.visrect.left,
-                                        tmp.visrect.bottom - tmp.visrect.top,
-                                        physdev->pict_format->depth );
+
+            monitor = fs_hack_monitor_from_hwnd( WindowFromDC( dev->hdc ) );
+            if (fs_hack_mapping_required( monitor ))
+            {
+                double user_to_real_scale;
+                SIZE size;
+
+                user_to_real_scale = fs_hack_get_user_to_real_scale( monitor );
+                size.cx = (tmp.visrect.right - tmp.visrect.left) * user_to_real_scale;
+                size.cy = (tmp.visrect.bottom - tmp.visrect.top) * user_to_real_scale;
+                tmp_pixmap = XCreatePixmap( gdi_display, root_window, size.cx, size.cy,
+                                            physdev->pict_format->depth );
+            }
+            else
+            {
+                tmp_pixmap = XCreatePixmap( gdi_display, root_window,
+                                            tmp.visrect.right - tmp.visrect.left,
+                                            tmp.visrect.bottom - tmp.visrect.top,
+                                            physdev->pict_format->depth );
+            }

             xrender_put_image( src_pixmap, src_pict, mask_pict, NULL, physdev->pict_format,
-                               NULL, tmp_pixmap, src, &tmp, use_repeat );
+                               physdev, tmp_pixmap, src, &tmp, use_repeat );
             execute_rop( physdev->x11dev, tmp_pixmap, gc, &dst->visrect, rop );

             XFreePixmap( gdi_display, tmp_pixmap );
@@ -1908,7 +2019,7 @@ static DWORD CDECL xrenderdrv_BlendImage( PHYSDEV dev, BITMAPINFO *info, const s
         EnterCriticalSection( &xrender_cs );
         mask_pict = get_mask_pict( func.SourceConstantAlpha * 257 );

-        xrender_blit( PictOpOver, src_pict, mask_pict, dst_pict,
+        xrender_blit( physdev, PictOpOver, src_pict, mask_pict, dst_pict,
                       src->x, src->y, src->width, src->height,
                       physdev->x11dev->dc_rect.left + dst->x,
                       physdev->x11dev->dc_rect.top + dst->y,
@@ -1997,7 +2108,7 @@ static BOOL CDECL xrenderdrv_AlphaBlend( PHYSDEV dst_dev, struct bitblt_coords *
     EnterCriticalSection( &xrender_cs );
     mask_pict = get_mask_pict( blendfn.SourceConstantAlpha * 257 );

-    xrender_blit( PictOpOver, src_pict, mask_pict, dst_pict,
+    xrender_blit( physdev_dst, PictOpOver, src_pict, mask_pict, dst_pict,
                   physdev_src->x11dev->dc_rect.left + src->x,
                   physdev_src->x11dev->dc_rect.top + src->y,
                   src->width, src->height,
@@ -2100,7 +2211,7 @@ static BOOL CDECL xrenderdrv_GradientFill( PHYSDEV dev, TRIVERTEX *vert_array, U
             dst_pict = get_xrender_picture( physdev, 0, NULL );

             src_pict = pXRenderCreateLinearGradient( gdi_display, &gradient, stops, colors, 2 );
-            xrender_blit( PictOpSrc, src_pict, 0, dst_pict,
+            xrender_blit( physdev, PictOpSrc, src_pict, 0, dst_pict,
                           0, 0, rc.right - rc.left, rc.bottom - rc.top,
                           physdev->x11dev->dc_rect.left + rc.left,
                           physdev->x11dev->dc_rect.top + rc.top,
diff --git a/dlls/winex11.drv/xvidmode.c b/dlls/winex11.drv/xvidmode.c
index d0be58342a5..123e5d036a9 100644
--- a/dlls/winex11.drv/xvidmode.c
+++ b/dlls/winex11.drv/xvidmode.c
@@ -313,6 +313,7 @@ void X11DRV_XF86VM_Init(void)
   xf86vm_handler.free_modes = xf86vm_free_modes;
   xf86vm_handler.get_current_mode = xf86vm_get_current_mode;
   xf86vm_handler.set_current_mode = xf86vm_set_current_mode;
+  xf86vm_handler.convert_coordinates = NULL;
   X11DRV_Settings_SetHandler(&xf86vm_handler);
   return;

From b2f26fe9bab670740b6298e99a99f34509dcd6b4 Mon Sep 17 00:00:00 2001
From: Matteo Bruni <mbruni@codeweavers.com>
Date: Tue, 16 Feb 2021 13:30:51 -0600
Subject: [PATCH] winex11: Clear fs hack depth / stencil attachment.

---
 dlls/winex11.drv/opengl.c | 19 +++++++++++++++----
 1 file changed, 15 insertions(+), 4 deletions(-)

diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index bf5f9637227..53ac19dfe50 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -1950,7 +1950,8 @@ static void fs_hack_get_attachments_config( struct gl_drawable *gl, struct fs_ha
 static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *gl )
 {
     GLuint prev_draw_fbo, prev_read_fbo, prev_texture, prev_renderbuffer;
-    float prev_clear_color[4];
+    float prev_clear_color[4], prev_clear_depth;
+    int prev_clear_stencil;
     unsigned int i;
     struct fs_hack_fbo_attachments_config config;
     struct fs_hack_fbconfig_attribs attribs;
@@ -1995,6 +1996,8 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
         opengl_funcs.gl.p_glGetIntegerv( GL_TEXTURE_BINDING_2D, (GLint *)&prev_texture );
         opengl_funcs.gl.p_glGetIntegerv( GL_RENDERBUFFER_BINDING, (GLint *)&prev_renderbuffer );
         opengl_funcs.gl.p_glGetFloatv( GL_COLOR_CLEAR_VALUE, prev_clear_color );
+        opengl_funcs.gl.p_glGetFloatv( GL_DEPTH_CLEAR_VALUE, &prev_clear_depth );
+        opengl_funcs.gl.p_glGetIntegerv( GL_STENCIL_CLEAR_VALUE, &prev_clear_stencil );
         TRACE( "Previous draw FBO %u, read FBO %u for ctx %p\n", prev_draw_fbo, prev_read_fbo, ctx);

         if (!ctx->fs_hack_fbo)
@@ -2080,14 +2083,22 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
             }
         }

-        opengl_funcs.gl.p_glClearColor( 0.0f, 0.0f, 0.0f, 1.0f );
         if(!gl->fs_hack_context_set_up)
-            opengl_funcs.gl.p_glClear( GL_COLOR_BUFFER_BIT );
+        {
+            opengl_funcs.gl.p_glClearColor( 0.0f, 0.0f, 0.0f, 1.0f );
+            opengl_funcs.gl.p_glClearDepth( 1.0 );
+            opengl_funcs.gl.p_glClearStencil( 0 );
+            opengl_funcs.gl.p_glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT );
+        }
         pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, 0 );
         pglDrawBuffer( GL_BACK );
         if(!gl->fs_hack_context_set_up)
+        {
             opengl_funcs.gl.p_glClear( GL_COLOR_BUFFER_BIT );
-        opengl_funcs.gl.p_glClearColor( prev_clear_color[0], prev_clear_color[1], prev_clear_color[2], prev_clear_color[3] );
+            opengl_funcs.gl.p_glClearColor( prev_clear_color[0], prev_clear_color[1], prev_clear_color[2], prev_clear_color[3] );
+            opengl_funcs.gl.p_glClearDepth( prev_clear_depth );
+            opengl_funcs.gl.p_glClearStencil( prev_clear_stencil );
+        }
         wglBindFramebuffer( GL_DRAW_FRAMEBUFFER, prev_draw_fbo );
         wglBindFramebuffer( GL_READ_FRAMEBUFFER, prev_read_fbo );

From ba4e9dc41c7fb272c4354669b032b781d96e2e59 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 19 Dec 2019 09:12:17 -0600
Subject: [PATCH] winex11.drv: Remove nvidia hack workaround

This breaks things for users who legitimately have only one resolution.
---
 dlls/winex11.drv/xrandr.c | 13 -------------
 1 file changed, 13 deletions(-)

diff --git a/dlls/winex11.drv/xrandr.c b/dlls/winex11.drv/xrandr.c
index 0a080ea6be8..667013df5ac 100644
--- a/dlls/winex11.drv/xrandr.c
+++ b/dlls/winex11.drv/xrandr.c
@@ -28,9 +28,6 @@
 #include "wine/debug.h"

 WINE_DEFAULT_DEBUG_CHANNEL(xrandr);
-#ifdef HAVE_XRRGETPROVIDERRESOURCES
-WINE_DECLARE_DEBUG_CHANNEL(winediag);
-#endif

 #ifdef SONAME_LIBXRANDR

@@ -378,7 +375,6 @@ static BOOL is_broken_driver(void)
     XRRScreenResources *screen_resources;
     XRROutputInfo *output_info;
     XRRModeInfo *first_mode;
-    INT major, event, error;
     INT output_idx, i, j;
     BOOL only_one_mode;

@@ -429,15 +425,6 @@ static BOOL is_broken_driver(void)

         if (!only_one_mode)
             continue;
-
-        /* Check if it is NVIDIA proprietary driver */
-        if (XQueryExtension( gdi_display, "NV-CONTROL", &major, &event, &error ))
-        {
-            ERR_(winediag)("Broken NVIDIA RandR detected, falling back to RandR 1.0. "
-                           "Please consider using the Nouveau driver instead.\n");
-            pXRRFreeScreenResources( screen_resources );
-            return TRUE;
-        }
     }
     pXRRFreeScreenResources( screen_resources );
     return FALSE;
From efc3bf9dd9f195641604d0fe392f542bdde2c5f8 Mon Sep 17 00:00:00 2001
From: Zhiyi Zhang <zzhang@codeweavers.com>
Date: Mon, 6 Apr 2020 15:30:40 +0800
Subject: [PATCH] winex11.drv: Bypass compositor only when a window is full
 virtual screen.

Bypass compositor only when a window is full virtual screen. Otherwise, it might cause flicking on
other monitors.

Signed-off-by: Zhiyi Zhang <zzhang@codeweavers.com>
---
 dlls/winex11.drv/window.c | 10 +++++++++-
 dlls/winex11.drv/x11drv.h |  1 +
 2 files changed, 10 insertions(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index a60001aec6d..ac7c0005a14 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -386,6 +386,13 @@ BOOL is_window_rect_full_screen( const RECT *rect )
     return info.full_screen;
 }

+BOOL is_window_rect_full_virtual_screen( const RECT *rect )
+{
+    RECT virtual_rect = get_virtual_screen_rect();
+    return (rect->left <= virtual_rect.left && rect->right >= virtual_rect.right &&
+            rect->top <= virtual_rect.top && rect->bottom >= virtual_rect.bottom);
+}
+
 /***********************************************************************
  *              get_mwm_decorations
  */
@@ -1168,7 +1175,8 @@ void update_net_wm_states( struct x11drv_win_data *data )
             if (!wm_is_steamcompmgr(data->display) || !fs_hack_enabled(monitor))
             {
                 /* when fs hack is enabled, we don't want steamcompmgr to resize the window to be fullscreened */
-                net_wm_bypass_compositor = 1;
+                if (is_window_rect_full_virtual_screen( &data->whole_rect ))
+                    net_wm_bypass_compositor = 1;
                 new_state |= (1 << NET_WM_STATE_FULLSCREEN);
             }
         }
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 26843c830eb..55875edc788 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -726,6 +726,7 @@ extern void X11DRV_expect_error( Display *display, x11drv_error_callback callbac
 extern int X11DRV_check_error(void) DECLSPEC_HIDDEN;
 extern void X11DRV_X_to_window_rect( struct x11drv_win_data *data, RECT *rect, int x, int y, int cx, int cy ) DECLSPEC_HIDDEN;
 extern BOOL is_window_rect_full_screen( const RECT *rect ) DECLSPEC_HIDDEN;
+extern BOOL is_window_rect_full_virtual_screen( const RECT *rect ) DECLSPEC_HIDDEN;
 extern POINT virtual_screen_to_root( INT x, INT y ) DECLSPEC_HIDDEN;
 extern POINT root_to_virtual_screen( INT x, INT y ) DECLSPEC_HIDDEN;
 extern RECT get_virtual_screen_rect(void) DECLSPEC_HIDDEN;
From 37b625a90d44c24f3bdc8c5a61f0dd5b0d37a924 Mon Sep 17 00:00:00 2001
From: Zhiyi Zhang <zzhang@codeweavers.com>
Date: Sun, 17 May 2020 23:27:59 +0800
Subject: [PATCH] user32/tests: Test moving full screen windows.

Signed-off-by: Zhiyi Zhang <zzhang@codeweavers.com>
---
 dlls/user32/tests/win.c | 79 +++++++++++++++++++++++++++++++++++++++--
 1 file changed, 76 insertions(+), 3 deletions(-)

diff --git a/dlls/user32/tests/win.c b/dlls/user32/tests/win.c
index 0156987f529..83969bf89f6 100644
--- a/dlls/user32/tests/win.c
+++ b/dlls/user32/tests/win.c
@@ -92,8 +92,8 @@ static void dump_minmax_info( const MINMAXINFO *minmax )
 static void flush_events( BOOL remove_messages )
 {
     MSG msg;
-    int diff = 200;
-    int min_timeout = 100;
+    int diff = 500;
+    int min_timeout = 200;
     DWORD time = GetTickCount() + diff;

     while (diff > 0)
@@ -102,7 +102,6 @@ static void flush_events( BOOL remove_messages )
         if (remove_messages)
             while (PeekMessageA( &msg, 0, 0, 0, PM_REMOVE )) DispatchMessageA( &msg );
         diff = time - GetTickCount();
-        min_timeout = 50;
     }
 }

@@ -8587,6 +8586,29 @@ static LRESULT CALLBACK fullscreen_wnd_proc(HWND hwnd, UINT msg, WPARAM wp, LPAR
     return DefWindowProcA(hwnd, msg, wp, lp);
 }

+struct monitor_info
+{
+    RECT first_monitor;
+    RECT second_monitor;
+};
+
+static BOOL CALLBACK enum_monitor_cb(HMONITOR monitor, HDC hdc, RECT *monitor_rect, LPARAM lparam)
+{
+    struct monitor_info *info = (struct monitor_info *)lparam;
+
+    if (IsRectEmpty(&info->first_monitor))
+    {
+        info->first_monitor = *monitor_rect;
+    }
+    else
+    {
+        info->second_monitor = *monitor_rect;
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
 static void test_fullscreen(void)
 {
     static const DWORD t_style[] = {
@@ -8595,6 +8617,7 @@ static void test_fullscreen(void)
     static const DWORD t_ex_style[] = {
         0, WS_EX_APPWINDOW, WS_EX_TOOLWINDOW
     };
+    struct monitor_info monitor_info;
     WNDCLASSA cls;
     int timeout;
     HWND hwnd;
@@ -8747,6 +8770,56 @@ static void test_fullscreen(void)
     DestroyWindow(hwnd);

     UnregisterClassA("fullscreen_class", GetModuleHandleA(NULL));
+
+    /* Test moving a full screen window to another monitor */
+    memset(&monitor_info, 0, sizeof(monitor_info));
+    EnumDisplayMonitors(NULL, NULL, enum_monitor_cb, (LPARAM)&monitor_info);
+    if (!IsRectEmpty(&monitor_info.first_monitor) && !IsRectEmpty(&monitor_info.second_monitor))
+    {
+        hwnd = CreateWindowA("static", "static1", WS_POPUP | WS_VISIBLE,
+                monitor_info.first_monitor.left, monitor_info.first_monitor.top,
+                monitor_info.first_monitor.right - monitor_info.first_monitor.left,
+                monitor_info.first_monitor.bottom - monitor_info.first_monitor.top, NULL, NULL,
+                GetModuleHandleA(NULL), NULL);
+        ok(!!hwnd, "CreateWindow failed, error %#x.\n", GetLastError());
+        flush_events(TRUE);
+
+        GetWindowRect(hwnd, &rc);
+        ok(EqualRect(&rc, &monitor_info.first_monitor), "Expected window rect %s, got %s.\n",
+                wine_dbgstr_rect(&monitor_info.first_monitor), wine_dbgstr_rect(&rc));
+
+        SetWindowPos(hwnd, 0, monitor_info.second_monitor.left, monitor_info.second_monitor.top,
+                monitor_info.second_monitor.right - monitor_info.second_monitor.left,
+                monitor_info.second_monitor.bottom - monitor_info.second_monitor.top, SWP_NOZORDER);
+        flush_events(TRUE);
+        GetWindowRect(hwnd, &rc);
+        /* todo_wine on KWin */
+        todo_wine_if(!EqualRect(&rc, &monitor_info.second_monitor))
+        ok(EqualRect(&rc, &monitor_info.second_monitor), "Expected window rect %s, got %s.\n",
+                wine_dbgstr_rect(&monitor_info.second_monitor), wine_dbgstr_rect(&rc));
+        DestroyWindow(hwnd);
+
+        hwnd = CreateWindowA("static", "static2", WS_POPUP | WS_VISIBLE,
+                monitor_info.second_monitor.left, monitor_info.second_monitor.top,
+                100, 100, NULL, NULL, NULL, NULL);
+        ok(!!hwnd, "CreateWindow failed, error %#x.\n", GetLastError());
+        flush_events(TRUE);
+
+        SetWindowPos(hwnd, 0, monitor_info.first_monitor.left, monitor_info.first_monitor.top,
+                monitor_info.first_monitor.right - monitor_info.first_monitor.left,
+                monitor_info.first_monitor.bottom - monitor_info.first_monitor.top, SWP_NOZORDER);
+        flush_events(TRUE);
+        GetWindowRect(hwnd, &rc);
+        /* todo_wine on KWin */
+        todo_wine_if(!EqualRect(&rc, &monitor_info.first_monitor))
+        ok(EqualRect(&rc, &monitor_info.first_monitor), "Expected window rect %s, got %s.\n",
+                wine_dbgstr_rect(&monitor_info.first_monitor), wine_dbgstr_rect(&rc));
+        DestroyWindow(hwnd);
+    }
+    else
+    {
+        skip("This test requires two monitors present.\n");
+    }
 }

 static BOOL test_thick_child_got_minmax;
From 533d833c1ae99a2b51bf8389b3bfd55ed6dbb3b5 Mon Sep 17 00:00:00 2001
From: Zhiyi Zhang <zzhang@codeweavers.com>
Date: Mon, 11 Oct 2021 11:03:06 +0200
Subject: [PATCH] gdi32/tests: Test GetDeviceCaps() for DCs on multiple monitor
 systems.

Signed-off-by: Zhiyi Zhang <zzhang@codeweavers.com>
---
 dlls/gdi32/tests/dc.c | 217 ++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 217 insertions(+)

diff --git a/dlls/gdi32/tests/dc.c b/dlls/gdi32/tests/dc.c
index 2e005f23f3c..1cc6c4cc81f 100644
--- a/dlls/gdi32/tests/dc.c
+++ b/dlls/gdi32/tests/dc.c
@@ -1698,6 +1698,222 @@ static void test_SetPixel(void)
     ok(c == ~0, "SetPixel returned: %x\n", c);
 }

+static void test_multi_monitor_dc(void)
+{
+    INT value, count, old_count;
+    DWORD device_idx, mode_idx;
+    DEVMODEA dm, dm2, dm3;
+    DISPLAY_DEVICEA dd;
+    BOOL ret;
+    LONG res;
+    HDC hdc;
+
+    /* Test DCs covering the entire virtual screen */
+    hdc = CreateDCA("DISPLAY", NULL, NULL, NULL);
+    ok(!!hdc, "CreateDCA failed.\n");
+
+    memset(&dm, 0, sizeof(dm));
+    dm.dmSize = sizeof(dm);
+    ret = EnumDisplaySettingsA(NULL, ENUM_CURRENT_SETTINGS, &dm);
+    ok(ret, "EnumDisplaySettingsA failed.\n");
+
+    value = GetDeviceCaps(hdc, HORZRES);
+    ok(value == dm.dmPelsWidth, "Expected %d, got %d.\n", dm.dmPelsWidth, value);
+
+    value = GetDeviceCaps(hdc, VERTRES);
+    ok(value == dm.dmPelsHeight, "Expected %d, got %d.\n", dm.dmPelsHeight, value);
+
+    value = GetDeviceCaps(hdc, DESKTOPHORZRES);
+    todo_wine_if(dm.dmPelsWidth != GetSystemMetrics(SM_CXVIRTUALSCREEN)
+                 && value == GetSystemMetrics(SM_CXVIRTUALSCREEN))
+    ok(value == dm.dmPelsWidth, "Expected %d, got %d.\n", dm.dmPelsWidth, value);
+
+    value = GetDeviceCaps(hdc, DESKTOPVERTRES);
+    todo_wine_if(dm.dmPelsHeight != GetSystemMetrics(SM_CYVIRTUALSCREEN)
+                 && value == GetSystemMetrics(SM_CYVIRTUALSCREEN))
+    ok(value == dm.dmPelsHeight, "Expected %d, got %d.\n", dm.dmPelsHeight, value);
+
+    value = GetDeviceCaps(hdc, VREFRESH);
+    todo_wine_if(value != dm.dmDisplayFrequency && value == 1)
+    ok(value == dm.dmDisplayFrequency, "Expected %d, got %d.\n", dm.dmDisplayFrequency, value);
+
+    /* Test GetDeviceCaps() values after mode changes */
+    memset(&dm2, 0, sizeof(dm2));
+    dm2.dmSize = sizeof(dm2);
+    for (mode_idx = 0; EnumDisplaySettingsA(NULL, mode_idx, &dm2); ++mode_idx)
+    {
+        if (dm2.dmPelsWidth != dm.dmPelsWidth && dm2.dmPelsHeight != dm.dmPelsHeight)
+            break;
+    }
+    ok(dm2.dmPelsWidth && dm2.dmPelsWidth != dm.dmPelsWidth && dm2.dmPelsHeight != dm.dmPelsHeight,
+       "Failed to find a different resolution.\n");
+
+    res = ChangeDisplaySettingsExA(NULL, &dm2, NULL, CDS_RESET, NULL);
+    ok(res == DISP_CHANGE_SUCCESSFUL || broken(res == DISP_CHANGE_FAILED), /* Win8 TestBots */
+       "ChangeDisplaySettingsExA returned unexpected %d.\n", res);
+    if (res == DISP_CHANGE_SUCCESSFUL)
+    {
+        value = GetDeviceCaps(hdc, HORZRES);
+        ok(value == dm2.dmPelsWidth, "Expected %d, got %d.\n", dm2.dmPelsWidth, value);
+
+        value = GetDeviceCaps(hdc, VERTRES);
+        ok(value == dm2.dmPelsHeight, "Expected %d, got %d.\n", dm2.dmPelsHeight, value);
+
+        value = GetDeviceCaps(hdc, DESKTOPHORZRES);
+        todo_wine_if(dm2.dmPelsWidth != GetSystemMetrics(SM_CXVIRTUALSCREEN)
+                     && value == GetSystemMetrics(SM_CXVIRTUALSCREEN))
+        ok(value == dm2.dmPelsWidth, "Expected %d, got %d.\n", dm2.dmPelsWidth, value);
+
+        value = GetDeviceCaps(hdc, DESKTOPVERTRES);
+        todo_wine_if(dm2.dmPelsHeight != GetSystemMetrics(SM_CYVIRTUALSCREEN)
+                     && value == GetSystemMetrics(SM_CYVIRTUALSCREEN))
+        ok(value == dm2.dmPelsHeight, "Expected %d, got %d.\n", dm2.dmPelsHeight, value);
+
+        value = GetDeviceCaps(hdc, VREFRESH);
+        todo_wine_if(value != dm2.dmDisplayFrequency && value == 1)
+        ok(value == dm2.dmDisplayFrequency, "Expected %d, got %d.\n", dm2.dmDisplayFrequency, value);
+
+        res = ChangeDisplaySettingsExA(NULL, NULL, NULL, 0, NULL);
+        ok(res == DISP_CHANGE_SUCCESSFUL, "ChangeDisplaySettingsExA returned unexpected %d.\n", res);
+    }
+
+    DeleteDC(hdc);
+
+    /* Test DCs covering a specific monitor */
+    dd.cb = sizeof(dd);
+    for (device_idx = 0; EnumDisplayDevicesA(NULL, device_idx, &dd, 0); ++device_idx)
+    {
+        if (!(dd.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP))
+            continue;
+
+        memset(&dm, 0, sizeof(dm));
+        dm.dmSize = sizeof(dm);
+        ret = EnumDisplaySettingsA(dd.DeviceName, ENUM_CURRENT_SETTINGS, &dm);
+        ok(ret, "EnumDisplaySettingsA %s failed.\n", dd.DeviceName);
+
+        hdc = CreateDCA(dd.DeviceName, NULL, NULL, NULL);
+        ok(!!hdc, "CreateDCA %s failed.\n", dd.DeviceName);
+
+        value = GetDeviceCaps(hdc, HORZRES);
+        todo_wine_if(dm.dmPelsWidth != GetSystemMetrics(SM_CXSCREEN))
+        ok(value == dm.dmPelsWidth, "Expected %d, got %d.\n", dm.dmPelsWidth, value);
+
+        value = GetDeviceCaps(hdc, VERTRES);
+        todo_wine_if(dm.dmPelsHeight != GetSystemMetrics(SM_CYSCREEN))
+        ok(value == dm.dmPelsHeight, "Expected %d, got %d.\n", dm.dmPelsHeight, value);
+
+        value = GetDeviceCaps(hdc, DESKTOPHORZRES);
+        todo_wine_if(dm.dmPelsWidth != GetSystemMetrics(SM_CXVIRTUALSCREEN)
+                     && value == GetSystemMetrics(SM_CXVIRTUALSCREEN))
+        ok(value == dm.dmPelsWidth, "Expected %d, got %d.\n", dm.dmPelsWidth, value);
+
+        value = GetDeviceCaps(hdc, DESKTOPVERTRES);
+        todo_wine_if(dm.dmPelsHeight != GetSystemMetrics(SM_CYVIRTUALSCREEN)
+                     && value == GetSystemMetrics(SM_CYVIRTUALSCREEN))
+        ok(value == dm.dmPelsHeight, "Expected %d, got %d.\n", dm.dmPelsHeight, value);
+
+        value = GetDeviceCaps(hdc, VREFRESH);
+        todo_wine_if(value != dm.dmDisplayFrequency && value == 1)
+        ok(value == dm.dmDisplayFrequency, "Expected %d, got %d.\n", dm.dmDisplayFrequency, value);
+
+        /* Test GetDeviceCaps() values after mode changes */
+        memset(&dm2, 0, sizeof(dm2));
+        dm2.dmSize = sizeof(dm2);
+        for (mode_idx = 0; EnumDisplaySettingsA(dd.DeviceName, mode_idx, &dm2); ++mode_idx)
+        {
+            if (dm2.dmPelsWidth != dm.dmPelsWidth && dm2.dmPelsHeight != dm.dmPelsHeight)
+                break;
+        }
+        ok(dm2.dmPelsWidth && dm2.dmPelsWidth != dm.dmPelsWidth && dm2.dmPelsHeight != dm.dmPelsHeight,
+           "Failed to find a different resolution for %s.\n", dd.DeviceName);
+
+        res = ChangeDisplaySettingsExA(dd.DeviceName, &dm2, NULL, CDS_RESET, NULL);
+        ok(res == DISP_CHANGE_SUCCESSFUL
+           || broken(res == DISP_CHANGE_FAILED), /* Win8 TestBots */
+           "ChangeDisplaySettingsExA %s returned unexpected %d.\n", dd.DeviceName, res);
+        if (res != DISP_CHANGE_SUCCESSFUL)
+        {
+            win_skip("Failed to change display mode for %s.\n", dd.DeviceName);
+            DeleteDC(hdc);
+            continue;
+        }
+
+        value = GetDeviceCaps(hdc, HORZRES);
+        todo_wine_if(dm2.dmPelsWidth != GetSystemMetrics(SM_CXSCREEN))
+        ok(value == dm2.dmPelsWidth, "Expected %d, got %d.\n", dm2.dmPelsWidth, value);
+
+        value = GetDeviceCaps(hdc, VERTRES);
+        todo_wine_if(dm2.dmPelsHeight != GetSystemMetrics(SM_CYSCREEN))
+        ok(value == dm2.dmPelsHeight, "Expected %d, got %d.\n", dm2.dmPelsHeight, value);
+
+        value = GetDeviceCaps(hdc, DESKTOPHORZRES);
+        todo_wine_if(dm2.dmPelsWidth != GetSystemMetrics(SM_CXVIRTUALSCREEN)
+                     && value == GetSystemMetrics(SM_CXVIRTUALSCREEN))
+        ok(value == dm2.dmPelsWidth, "Expected %d, got %d.\n", dm2.dmPelsWidth, value);
+
+        value = GetDeviceCaps(hdc, DESKTOPVERTRES);
+        todo_wine_if(dm2.dmPelsHeight != GetSystemMetrics(SM_CYVIRTUALSCREEN)
+                     && value == GetSystemMetrics(SM_CYVIRTUALSCREEN))
+        ok(value == dm2.dmPelsHeight, "Expected %d, got %d.\n", dm2.dmPelsHeight, value);
+
+        value = GetDeviceCaps(hdc, VREFRESH);
+        todo_wine_if(value != dm2.dmDisplayFrequency && value == 1)
+        ok(value == dm2.dmDisplayFrequency, "Expected %d, got %d.\n", dm2.dmDisplayFrequency, value);
+
+        /* Test GetDeviceCaps() values after monitor detach */
+        if (!(dd.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE))
+        {
+            old_count = GetSystemMetrics(SM_CMONITORS);
+
+            ret = EnumDisplaySettingsA(dd.DeviceName, ENUM_CURRENT_SETTINGS, &dm3);
+            ok(ret, "EnumDisplaySettingsA %s failed.\n", dd.DeviceName);
+
+            dm3.dmFields = DM_POSITION | DM_PELSWIDTH | DM_PELSHEIGHT;
+            dm3.dmPelsWidth = 0;
+            dm3.dmPelsHeight = 0;
+            res = ChangeDisplaySettingsExA(dd.DeviceName, &dm3, NULL, CDS_UPDATEREGISTRY | CDS_NORESET, NULL);
+            ok(res == DISP_CHANGE_SUCCESSFUL, "ChangeDisplaySettingsExA %s returned unexpected %d.\n",
+               dd.DeviceName, res);
+            res = ChangeDisplaySettingsExA(dd.DeviceName, NULL, NULL, 0, NULL);
+            ok(res == DISP_CHANGE_SUCCESSFUL, "ChangeDisplaySettingsExA %s returned unexpected %d.\n",
+               dd.DeviceName, res);
+
+            count = GetSystemMetrics(SM_CMONITORS);
+            ok(count == old_count - 1, "Expect monitor count %d, got %d.\n", old_count - 1, count);
+
+            /* Should report the same values before detach */
+            value = GetDeviceCaps(hdc, HORZRES);
+            todo_wine_if(dm2.dmPelsWidth != GetSystemMetrics(SM_CXSCREEN))
+            ok(value == dm2.dmPelsWidth, "Expected %d, got %d.\n", dm2.dmPelsWidth, value);
+
+            value = GetDeviceCaps(hdc, VERTRES);
+            todo_wine_if(dm2.dmPelsHeight != GetSystemMetrics(SM_CYSCREEN))
+            ok(value == dm2.dmPelsHeight, "Expected %d, got %d.\n", dm2.dmPelsHeight, value);
+
+            value = GetDeviceCaps(hdc, DESKTOPHORZRES);
+            todo_wine_if(dm2.dmPelsWidth != GetSystemMetrics(SM_CXVIRTUALSCREEN)
+                         && value == GetSystemMetrics(SM_CXVIRTUALSCREEN))
+            ok(value == dm2.dmPelsWidth, "Expected %d, got %d.\n", dm2.dmPelsWidth, value);
+
+            value = GetDeviceCaps(hdc, DESKTOPVERTRES);
+            todo_wine_if(dm2.dmPelsHeight != GetSystemMetrics(SM_CYVIRTUALSCREEN)
+                         && value == GetSystemMetrics(SM_CYVIRTUALSCREEN))
+            ok(value == dm2.dmPelsHeight, "Expected %d, got %d.\n", dm2.dmPelsHeight, value);
+
+            value = GetDeviceCaps(hdc, VREFRESH);
+            todo_wine_if(value != dm2.dmDisplayFrequency && value == 1)
+            ok(value == dm2.dmDisplayFrequency, "Expected %d, got %d.\n", dm2.dmDisplayFrequency, value);
+        }
+
+        res = ChangeDisplaySettingsExA(dd.DeviceName, &dm, NULL, CDS_UPDATEREGISTRY | CDS_NORESET, NULL);
+        ok(res == DISP_CHANGE_SUCCESSFUL, "ChangeDisplaySettingsExA %s returned unexpected %d.\n",
+           dd.DeviceName, res);
+        res = ChangeDisplaySettingsExA(NULL, NULL, NULL, 0, NULL);
+        ok(res == DISP_CHANGE_SUCCESSFUL, "ChangeDisplaySettingsExA %s returned unexpected %d.\n",
+           dd.DeviceName, res);
+        DeleteDC(hdc);
+    }
+}

 START_TEST(dc)
 {
@@ -1716,4 +1932,5 @@ START_TEST(dc)
     test_pscript_printer_dc();
     test_clip_box();
     test_SetPixel();
+    test_multi_monitor_dc();
 }
From 9807dd24837a522537dfc0e84cdf5e29693df837 Mon Sep 17 00:00:00 2001
From: Zhiyi Zhang <zzhang@codeweavers.com>
Date: Tue, 26 May 2020 22:36:07 +0800
Subject: [PATCH] winex11.drv: Do not move window with _NET_WM_STATE_FULLSCREEN
 set.

Signed-off-by: Zhiyi Zhang <zzhang@codeweavers.com>
---
 dlls/user32/tests/win.c   |  4 ----
 dlls/winex11.drv/window.c | 13 +++++++++++++
 2 files changed, 13 insertions(+), 4 deletions(-)

diff --git a/dlls/user32/tests/win.c b/dlls/user32/tests/win.c
index 83969bf89f6..4722be3fd47 100644
--- a/dlls/user32/tests/win.c
+++ b/dlls/user32/tests/win.c
@@ -8793,8 +8793,6 @@ static void test_fullscreen(void)
                 monitor_info.second_monitor.bottom - monitor_info.second_monitor.top, SWP_NOZORDER);
         flush_events(TRUE);
         GetWindowRect(hwnd, &rc);
-        /* todo_wine on KWin */
-        todo_wine_if(!EqualRect(&rc, &monitor_info.second_monitor))
         ok(EqualRect(&rc, &monitor_info.second_monitor), "Expected window rect %s, got %s.\n",
                 wine_dbgstr_rect(&monitor_info.second_monitor), wine_dbgstr_rect(&rc));
         DestroyWindow(hwnd);
@@ -8810,8 +8808,6 @@ static void test_fullscreen(void)
                 monitor_info.first_monitor.bottom - monitor_info.first_monitor.top, SWP_NOZORDER);
         flush_events(TRUE);
         GetWindowRect(hwnd, &rc);
-        /* todo_wine on KWin */
-        todo_wine_if(!EqualRect(&rc, &monitor_info.first_monitor))
         ok(EqualRect(&rc, &monitor_info.first_monitor), "Expected window rect %s, got %s.\n",
                 wine_dbgstr_rect(&monitor_info.first_monitor), wine_dbgstr_rect(&rc));
         DestroyWindow(hwnd);
diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index ac7c0005a14..bbe2a1728b5 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -1487,6 +1487,7 @@ static void sync_window_position( struct x11drv_win_data *data,
 {
     DWORD style = GetWindowLongW( data->hwnd, GWL_STYLE );
     DWORD ex_style = GetWindowLongW( data->hwnd, GWL_EXSTYLE );
+    RECT original_rect = {0};
     XWindowChanges changes;
     unsigned int mask = 0;

@@ -1541,9 +1542,21 @@ static void sync_window_position( struct x11drv_win_data *data,

     set_size_hints( data, style );
     set_mwm_hints( data, style, ex_style );
+    /* KWin doesn't allow moving a window with _NET_WM_STATE_FULLSCREEN set. So we need to remove
+     * _NET_WM_STATE_FULLSCREEN before moving the window and restore it later */
+    if (wm_is_kde( data->display ) && is_window_rect_full_screen( &data->whole_rect ))
+    {
+        original_rect = data->whole_rect;
+        SetRectEmpty( &data->whole_rect );
+    }
     update_net_wm_states( data );
     data->configure_serial = NextRequest( data->display );
     XReconfigureWMWindow( data->display, data->whole_window, data->vis.screen, mask, &changes );
+    if (!IsRectEmpty( &original_rect ))
+    {
+        data->whole_rect = original_rect;
+        update_net_wm_states( data );
+    }
 #ifdef HAVE_LIBXSHAPE
     if (IsRectEmpty( old_window_rect ) != IsRectEmpty( &data->window_rect ))
         sync_window_region( data, (HRGN)1 );
From fa17abadf6856748a1502464dcb0c56fea0d58a8 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 18 Feb 2021 10:05:52 -0600
Subject: [PATCH] winex11.drv: Support adjusting gamma in the fshack

CW-Bug-Id: 16421
---
 dlls/winex11.drv/fs.c       |  33 ++
 dlls/winex11.drv/opengl.c   | 637 ++++++++++++++++++++++++++++++++----
 dlls/winex11.drv/x11drv.h   |   2 +
 dlls/winex11.drv/xvidmode.c |  23 +-
 4 files changed, 622 insertions(+), 73 deletions(-)

diff --git a/dlls/winex11.drv/fs.c b/dlls/winex11.drv/fs.c
index 641fdd40d45..913c37dee68 100644
--- a/dlls/winex11.drv/fs.c
+++ b/dlls/winex11.drv/fs.c
@@ -39,6 +39,10 @@ static struct x11drv_display_device_handler real_device_handler;
 static struct x11drv_settings_handler real_settings_handler;
 static struct list fs_monitors = LIST_INIT(fs_monitors);

+static WORD gamma_ramp_i[GAMMA_RAMP_SIZE * 3];
+static float gamma_ramp[GAMMA_RAMP_SIZE * 4];
+static LONG gamma_serial;
+
 /* Access to fs_monitors is protected by fs_section */
 static CRITICAL_SECTION fs_section;
 static CRITICAL_SECTION_DEBUG critsect_debug =
@@ -897,3 +901,32 @@ void fs_hack_init(void)
     device_handler.register_event_handlers = NULL;
     X11DRV_DisplayDevices_SetHandler(&device_handler);
 }
+
+const float *fs_hack_get_gamma_ramp(LONG *serial)
+{
+    if(gamma_serial == 0)
+        return NULL;
+    if(serial)
+        *serial = gamma_serial;
+    return gamma_ramp;
+}
+
+void fs_hack_set_gamma_ramp(const WORD *ramp)
+{
+    int i;
+    if(memcmp(gamma_ramp_i, ramp, sizeof(gamma_ramp_i)) == 0){
+        /* identical */
+        return;
+    }
+    for(i = 0; i < GAMMA_RAMP_SIZE; ++i){
+        gamma_ramp[i * 4    ] = ramp[i                      ] / 65535.f;
+        gamma_ramp[i * 4 + 1] = ramp[i +     GAMMA_RAMP_SIZE] / 65535.f;
+        gamma_ramp[i * 4 + 2] = ramp[i + 2 * GAMMA_RAMP_SIZE] / 65535.f;
+    }
+    memcpy(gamma_ramp_i, ramp, sizeof(gamma_ramp_i));
+    InterlockedIncrement(&gamma_serial);
+    TRACE("new gamma serial: %u\n", gamma_serial);
+    if(gamma_serial == 0){
+        InterlockedIncrement(&gamma_serial);
+    }
+}
diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index 53ac19dfe50..fab13d5b1df 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -209,9 +209,11 @@ struct wgl_context
     BOOL refresh_drawables;
     BOOL fs_hack;
     BOOL fs_hack_integer;
+    BOOL is_core;
     GLuint fs_hack_fbo, fs_hack_resolve_fbo;
     GLuint fs_hack_color_texture, fs_hack_ds_texture;
-    GLuint fs_hack_color_renderbuffer, fs_hack_color_resolve_renderbuffer, fs_hack_ds_renderbuffer;
+    GLuint fs_hack_color_renderbuffer, fs_hack_ds_renderbuffer;
+    GLuint fs_hack_gamma_pgm, ramp_ubo;
     POINT setup_for;
     GLuint current_draw_fbo, current_read_fbo;
     struct list entry;
@@ -262,6 +264,11 @@ struct gl_drawable
     BOOL                           fs_hack_did_swapbuf;
     BOOL                           fs_hack_context_set_up;
     BOOL                           has_scissor_indexed;
+    BOOL                           has_clip_control;
+    BOOL                           has_ati_frag_shader;
+    BOOL                           has_fragment_program;
+    BOOL                           has_vertex_program;
+    LONG                           last_gamma_serial;
 };

 enum glx_swap_control_method
@@ -385,10 +392,6 @@ static int   (*pglXSwapIntervalSGI)(int);
 static void* (*pglXAllocateMemoryNV)(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority);
 static void  (*pglXFreeMemoryNV)(GLvoid *pointer);

-static void (*pglScissorIndexed)(GLuint, GLint, GLint, GLsizei, GLsizei);
-static void (*pglScissorIndexedv)(GLuint, const GLint *);
-static void (*pglGetIntegeri_v)(GLenum, GLuint, GLint *);
-
 /* MESA GLX Extensions */
 static void (*pglXCopySubBufferMESA)(Display *dpy, GLXDrawable drawable, int x, int y, int width, int height);
 static int (*pglXSwapIntervalMESA)(unsigned int interval);
@@ -413,21 +416,57 @@ static void wglFlush(void);
 static const GLubyte *wglGetString(GLenum name);

 /* Fullscreen hack */
+static void (*pglActiveTexture)( GLenum texture );
+static void (*pglAttachShader)( GLuint program, GLuint shader );
+static void (*pglBindBuffer)( GLenum target, GLuint buffer );
+static void (*pglBindBufferBase)( GLenum target, GLuint index, GLuint buffer );
+static void (*pglBindBufferRange)( GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size );
 static void (*pglBindFramebuffer)( GLenum target, GLuint framebuffer );
 static void (*pglBindFramebufferEXT)( GLenum target, GLuint framebuffer );
 static void (*pglBindRenderbuffer)( GLenum target, GLuint renderbuffer );
+static void (*pglBindSampler)( GLuint target, GLuint sampler );
 static void (*pglBlitFramebuffer)( GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter );
-void (*pglDeleteFramebuffers)( GLsizei n, const GLuint *framebuffers );
-void (*pglDeleteRenderbuffers)( GLsizei n, const GLuint *renderbuffers );
+static void (*pglBufferData)( GLenum target, GLsizeiptr size, const void *data, GLenum usage );
+static void (*pglClipControl)( GLenum origin, GLenum depth );
+static void (*pglColorMaski)( GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a );
+static void (*pglCompileShader)( GLuint shader );
+static GLuint (*pglCreateProgram)( void );
+static GLuint (*pglCreateShader)( GLenum type );
+static void (*pglDeleteBuffers)( GLsizei n, GLuint *buffers );
+static void (*pglDeleteFramebuffers)( GLsizei n, const GLuint *framebuffers );
+static void (*pglDeleteProgram)( GLuint program );
+static void (*pglDeleteRenderbuffers)( GLsizei n, const GLuint *renderbuffers );
+static void (*pglDeleteShader)( GLuint shader );
+static void (*pglDrawArrays)( GLenum mode, GLint first, GLsizei count );
 static void (*pglDrawBuffer)( GLenum buffer );
 static void (*pglFramebufferRenderbuffer)( GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer );
 static void (*pglFramebufferTexture2D)( GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level );
+static void (*pglGenBuffers)( GLsizei n, GLuint *buffers );
 static void (*pglGenFramebuffers)( GLsizei n, GLuint *ids );
+static void (*pglGetBooleani_v )(GLenum target, GLuint index, GLboolean *data);
+static void (*pglGetInteger64i_v)(GLenum target, GLuint index, GLint64 *data);
+static void (*pglGetIntegeri_v)(GLenum, GLuint, GLint *);
+static void (*pglGetFloati_v)(GLenum, GLuint, GLfloat *);
 static void (*pglGenRenderbuffers)( GLsizei n, GLuint *renderbuffers );
+static void (*pglGetProgramiv)( GLuint program, GLenum pname, GLint *params );
+static void (*pglGetProgramInfoLog)( GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog );
+static void (*pglGetShaderiv)( GLuint shader, GLenum pname, GLint *params );
+static void (*pglGetShaderInfoLog)( GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog );
+static GLuint (*pglGetUniformBlockIndex)( GLuint program, const GLchar *uniformBlockName );
+static GLint (*pglGetUniformLocation)( GLuint program, const GLchar *name );
+static void (*pglLinkProgram)( GLuint program );
 static void (*pglReadBuffer)( GLenum src );
 static void (*pglRenderbufferStorage)( GLenum target, GLenum internalformat, GLsizei width, GLsizei height );
 static void (*pglRenderbufferStorageMultisample)( GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height );
-
+static void (*pglScissorIndexed)(GLuint, GLint, GLint, GLsizei, GLsizei);
+static void (*pglScissorIndexedv)(GLuint, const GLint *);
+static void (*pglShaderSource)( GLuint shader, GLsizei count, const GLchar *const *string, const GLint *length );
+static void (*pglUniformBlockBinding)( GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding );
+static void (*pglUniform1i)( GLint location, GLint v0 );
+static void (*pglUseProgram)( GLuint program );
+static void (*pglViewportIndexedf)( GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h );
+static void (*pglViewportIndexedfv)( GLuint index, const GLfloat *v );
+static void (*pglGetFramebufferAttachmentParameteriv)(GLenum target, GLenum attachment, GLenum pname, GLint *params);
 static void wglBindFramebuffer( GLenum target, GLuint framebuffer );
 static void wglBindFramebufferEXT( GLenum target, GLuint framebuffer );
 static void wglDrawBuffer( GLenum buffer );
@@ -623,18 +662,55 @@ static BOOL WINAPI init_opengl( INIT_ONCE *once, void *param, void **context )

     /* Fullscreen hack */
 #define LOAD_FUNCPTR(func) p##func = (void *)pglXGetProcAddressARB((const unsigned char *)#func);
+    LOAD_FUNCPTR( glActiveTexture );
+    LOAD_FUNCPTR( glAttachShader );
+    LOAD_FUNCPTR( glBindBuffer );
+    LOAD_FUNCPTR( glBindBufferBase );
+    LOAD_FUNCPTR( glBindBufferRange );
     LOAD_FUNCPTR( glBindFramebuffer );
     LOAD_FUNCPTR( glBindFramebufferEXT );
     LOAD_FUNCPTR( glBindRenderbuffer );
+    LOAD_FUNCPTR( glBindSampler );
     LOAD_FUNCPTR( glBlitFramebuffer );
+    LOAD_FUNCPTR( glBufferData );
+    LOAD_FUNCPTR( glClipControl );
+    LOAD_FUNCPTR( glColorMaski );
+    LOAD_FUNCPTR( glCompileShader );
+    LOAD_FUNCPTR( glCreateProgram );
+    LOAD_FUNCPTR( glCreateShader );
+    LOAD_FUNCPTR( glDeleteBuffers );
     LOAD_FUNCPTR( glDeleteFramebuffers );
+    LOAD_FUNCPTR( glDeleteProgram );
     LOAD_FUNCPTR( glDeleteRenderbuffers );
+    LOAD_FUNCPTR( glDeleteShader );
+    LOAD_FUNCPTR( glDrawArrays );
     LOAD_FUNCPTR( glFramebufferRenderbuffer );
     LOAD_FUNCPTR( glFramebufferTexture2D );
+    LOAD_FUNCPTR( glGenBuffers );
     LOAD_FUNCPTR( glGenFramebuffers );
+    LOAD_FUNCPTR( glGetBooleani_v );
+    LOAD_FUNCPTR( glGetInteger64i_v );
+    LOAD_FUNCPTR( glGetIntegeri_v );
+    LOAD_FUNCPTR( glGetFloati_v );
     LOAD_FUNCPTR( glGenRenderbuffers );
+    LOAD_FUNCPTR( glGetProgramiv );
+    LOAD_FUNCPTR( glGetProgramInfoLog );
+    LOAD_FUNCPTR( glGetShaderiv );
+    LOAD_FUNCPTR( glGetShaderInfoLog );
+    LOAD_FUNCPTR( glGetUniformBlockIndex );
+    LOAD_FUNCPTR( glGetUniformLocation );
+    LOAD_FUNCPTR( glLinkProgram );
     LOAD_FUNCPTR( glRenderbufferStorage );
     LOAD_FUNCPTR( glRenderbufferStorageMultisample );
+    LOAD_FUNCPTR( glScissorIndexed );
+    LOAD_FUNCPTR( glScissorIndexedv );
+    LOAD_FUNCPTR( glShaderSource );
+    LOAD_FUNCPTR( glUniformBlockBinding );
+    LOAD_FUNCPTR( glUniform1i );
+    LOAD_FUNCPTR( glUseProgram );
+    LOAD_FUNCPTR( glViewportIndexedf );
+    LOAD_FUNCPTR( glViewportIndexedfv );
+    LOAD_FUNCPTR( glGetFramebufferAttachmentParameteriv );
 #undef LOAD_FUNCPTR

 #define LOAD_FUNCPTR(f) do if((p##f = (void*)pglXGetProcAddressARB((const unsigned char*)#f)) == NULL) \
@@ -687,10 +763,6 @@ static BOOL WINAPI init_opengl( INIT_ONCE *once, void *param, void **context )
     /* NV GLX Extension */
     LOAD_FUNCPTR(glXAllocateMemoryNV);
     LOAD_FUNCPTR(glXFreeMemoryNV);
-
-    LOAD_FUNCPTR(glScissorIndexed);
-    LOAD_FUNCPTR(glScissorIndexedv);
-    LOAD_FUNCPTR(glGetIntegeri_v);
 #undef LOAD_FUNCPTR

     if(!X11DRV_WineGL_InitOpenglInfo()) goto failed;
@@ -781,13 +853,6 @@ static BOOL WINAPI init_opengl( INIT_ONCE *once, void *param, void **context )
         pglXSwapBuffersMscOML = pglXGetProcAddressARB( (const GLubyte *)"glXSwapBuffersMscOML" );
     }

-    if (has_extension( glExtensions, "GL_ARB_viewport_array"))
-    {
-        opengl_funcs.ext.p_glGetIntegeri_v = pglGetIntegeri_v;
-        opengl_funcs.ext.p_glScissorIndexed = pglScissorIndexed;
-        opengl_funcs.ext.p_glScissorIndexedv = pglScissorIndexedv;
-    }
-
     X11DRV_WineGL_LoadExtensions();
     init_pixel_formats( gdi_display );
     return TRUE;
@@ -1554,7 +1619,7 @@ void sync_gl_drawable( HWND hwnd, BOOL known_child )

     if (DC_GL_PIXMAP_WIN != old->type) {
         data = get_win_data( hwnd );
-        old->fs_hack = data->fs_hack;
+        old->fs_hack = data->fs_hack || fs_hack_get_gamma_ramp(NULL) != NULL;
         if (old->fs_hack)
             TRACE( "Window %p has the fullscreen hack enabled\n", hwnd );
         release_win_data( data );
@@ -1902,7 +1967,6 @@ struct fs_hack_fbconfig_attribs
     int stencil_size;
     int doublebuffer;
     int samples;
-    int srgb;
 };

 struct fs_hack_fbo_attachments_config
@@ -1924,10 +1988,7 @@ static void fs_hack_get_attachments_config( struct gl_drawable *gl, struct fs_ha
     if (attribs->red_size != 8 || attribs->green_size != 8 || attribs->blue_size != 8)
         FIXME( "Unsupported RGBA color sizes {%u, %u, %u, %u}.\n",
                 attribs->red_size, attribs->green_size, attribs->blue_size, attribs->alpha_size );
-    if (attribs->srgb)
-        config->color_internalformat = attribs->alpha_size ? GL_SRGB8_ALPHA8 : GL_SRGB8;
-    else
-        config->color_internalformat = attribs->alpha_size ? GL_RGBA8 : GL_RGB8;
+    config->color_internalformat = attribs->alpha_size ? GL_SRGB8_ALPHA8 : GL_SRGB8;
     config->color_format = GL_BGRA;
     config->color_type = GL_UNSIGNED_INT_8_8_8_8_REV;
     if (attribs->depth_size || attribs->stencil_size)
@@ -1947,6 +2008,161 @@ static void fs_hack_get_attachments_config( struct gl_drawable *gl, struct fs_ha
     config->samples = attribs->samples;
 }

+static const float *fs_hack_get_default_gamma_ramp(void)
+{
+    static float default_gamma_ramp[GAMMA_RAMP_SIZE * 4];
+    static BOOL initialized;
+    unsigned int i;
+
+    if (!initialized)
+    {
+        for (i = 0; i < GAMMA_RAMP_SIZE; i++)
+            default_gamma_ramp[i * 4    ] =
+            default_gamma_ramp[i * 4 + 1] =
+            default_gamma_ramp[i * 4 + 2] =
+                i / (float)(GAMMA_RAMP_SIZE - 1);
+        initialized = TRUE;
+    }
+    return default_gamma_ramp;
+}
+
+static const char *fs_hack_gamma_vertex_shader_src =
+"#version 330\n"
+"\n"
+"const vec4 square[4] = vec4[4](\n"
+"    vec4(-1.0, -1.0, 0.0, 1.0),\n"
+"    vec4(-1.0, 1.0, 0.0, 1.0),\n"
+"    vec4(1.0, -1.0, 0.0, 1.0),\n"
+"    vec4(1.0, 1.0, 0.0, 1.0)\n"
+");\n"
+"const vec2 texsq[4] = vec2[4](\n"
+"    vec2(0.0, 0.0),\n"
+"    vec2(0.0, 1.0),\n"
+"    vec2(1.0, 0.0),\n"
+"    vec2(1.0, 1.0)\n"
+");\n"
+"\n"
+"out vec2 texCoord;\n"
+"\n"
+"void main(void)\n"
+"{\n"
+"    gl_Position = square[gl_VertexID];\n"
+"    texCoord = texsq[gl_VertexID];\n"
+"}\n"
+;
+
+static const char *fs_hack_gamma_frag_shader_src =
+"#version 330\n"
+"\n"
+"uniform sampler2D tex;\n"
+"in vec2 texCoord;\n"
+"layout (std140) uniform ramp {\n"
+"    vec3 values[256];\n"
+"};\n"
+"\n"
+"layout(location = 0) out vec4 outColor;\n"
+"\n"
+"void main(void)\n"
+"{\n"
+"    vec4 lookup = texture(tex, texCoord) * 255.0;\n"
+"    outColor.r = values[int(lookup.r)].r;\n"
+"    outColor.g = values[int(lookup.g)].g;\n"
+"    outColor.b = values[int(lookup.b)].b;\n"
+"    outColor.a = 1.0;\n"
+"}\n"
+;
+
+static void fs_hack_setup_gamma_shader( struct wgl_context *ctx, struct gl_drawable *gl )
+{
+    GLint success;
+    GLuint vshader, fshader, program, ramp_index, tex_loc, prev_program;
+    char errstr[512];
+    const float *default_gamma_ramp = fs_hack_get_default_gamma_ramp();
+
+    opengl_funcs.gl.p_glGetIntegerv( GL_CURRENT_PROGRAM, (GLint *)&prev_program );
+    /* vertex shader */
+    vshader = pglCreateShader(GL_VERTEX_SHADER);
+    if(vshader == 0){
+        ERR("Failed to create gamma vertex shader\n");
+        return;
+    }
+    pglShaderSource(vshader, 1, &fs_hack_gamma_vertex_shader_src, NULL);
+    pglCompileShader(vshader);
+
+    pglGetShaderiv(vshader, GL_COMPILE_STATUS, &success);
+    if(!success){
+        pglGetShaderInfoLog(vshader, sizeof(errstr), NULL, errstr);
+        ERR("Compiling gamma vertex shader failed: %s\n", errstr);
+        pglDeleteShader(vshader);
+        return;
+    }
+
+
+    /* fragment shader */
+    fshader = pglCreateShader(GL_FRAGMENT_SHADER);
+    if(fshader == 0){
+        ERR("Failed to create gamma fragment shader\n");
+        pglDeleteShader(vshader);
+        return;
+    }
+    pglShaderSource(fshader, 1, &fs_hack_gamma_frag_shader_src, NULL);
+    pglCompileShader(fshader);
+
+    pglGetShaderiv(fshader, GL_COMPILE_STATUS, &success);
+    if(!success){
+        pglGetShaderInfoLog(fshader, sizeof(errstr), NULL, errstr);
+        ERR("Compiling gamma fragment shader failed: %s\n", errstr);
+        pglDeleteShader(fshader);
+        pglDeleteShader(vshader);
+        return;
+    }
+
+
+    /* gamma program */
+    program = pglCreateProgram();
+    if(program == 0){
+        ERR("Failed to create gamma program\n");
+        pglDeleteShader(fshader);
+        pglDeleteShader(vshader);
+        return;
+    }
+
+    pglAttachShader(program, vshader);
+    pglAttachShader(program, fshader);
+
+    pglLinkProgram(program);
+
+    pglGetProgramiv(program, GL_LINK_STATUS, &success);
+    if(!success){
+        pglGetProgramInfoLog(program, sizeof(errstr), NULL, errstr);
+        ERR("Linking gamma shader failed: %s\n", errstr);
+        pglDeleteProgram(program);
+        pglDeleteShader(fshader);
+        pglDeleteShader(vshader);
+        return;
+    }
+
+    pglDeleteShader(fshader);
+    pglDeleteShader(vshader);
+
+    pglGenBuffers(1, &ctx->ramp_ubo);
+    pglBindBuffer(GL_UNIFORM_BUFFER, ctx->ramp_ubo);
+    pglBufferData(GL_UNIFORM_BUFFER, sizeof(float) * 4 * GAMMA_RAMP_SIZE, default_gamma_ramp, GL_DYNAMIC_DRAW);
+    gl->last_gamma_serial = 0;
+
+    ramp_index = pglGetUniformBlockIndex(program, "ramp");
+    pglUniformBlockBinding(program, ramp_index, 0);
+
+    pglUseProgram( program );
+
+    tex_loc = pglGetUniformLocation(program, "tex");
+    pglUniform1i(tex_loc, 0);
+
+    ctx->fs_hack_gamma_pgm = program;
+
+    pglUseProgram( prev_program );
+}
+
 static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *gl )
 {
     GLuint prev_draw_fbo, prev_read_fbo, prev_texture, prev_renderbuffer;
@@ -1972,7 +2188,6 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
         {GLX_STENCIL_SIZE, offsetof(struct fs_hack_fbconfig_attribs, stencil_size)},
         {GLX_DOUBLEBUFFER, offsetof(struct fs_hack_fbconfig_attribs, doublebuffer)},
         {GLX_SAMPLES_ARB, offsetof(struct fs_hack_fbconfig_attribs, samples)},
-        {GLX_FRAMEBUFFER_SRGB_CAPABLE_EXT, offsetof(struct fs_hack_fbconfig_attribs, srgb)},
     };
     BYTE *ptr = (BYTE *)&attribs;

@@ -1981,6 +2196,7 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
         MONITORINFO monitor_info;
         HMONITOR monitor;
         int width, height;
+        GLuint profile;

         monitor = fs_hack_monitor_from_hwnd(WindowFromDC(ctx->hdc));
         memset(&monitor_info, 0, sizeof(monitor_info));
@@ -1991,6 +2207,9 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *

         TRACE("Render buffer width:%d height:%d\n", width, height);

+        opengl_funcs.gl.p_glGetIntegerv( GL_CONTEXT_PROFILE_MASK, (GLint *)&profile );
+        ctx->is_core = (profile & GL_CONTEXT_CORE_PROFILE_BIT) != 0;
+
         opengl_funcs.gl.p_glGetIntegerv( GL_DRAW_FRAMEBUFFER_BINDING, (GLint *)&prev_draw_fbo );
         opengl_funcs.gl.p_glGetIntegerv( GL_READ_FRAMEBUFFER_BINDING, (GLint *)&prev_read_fbo );
         opengl_funcs.gl.p_glGetIntegerv( GL_TEXTURE_BINDING_2D, (GLint *)&prev_texture );
@@ -2006,13 +2225,27 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
             pglGenFramebuffers( 1, &ctx->fs_hack_resolve_fbo );
             TRACE( "Created FBO %u for fullscreen hack.\n", ctx->fs_hack_fbo );
         }
-        pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, ctx->fs_hack_fbo );
+        pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, 0);

         for (i = 0; i < ARRAY_SIZE(queries); ++i)
             pglXGetFBConfigAttrib( gdi_display, gl->format->fbconfig, queries[i].attribute,
                     (int *)&ptr[queries[i].offset] );
+
+        pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, ctx->fs_hack_fbo );
+
         fs_hack_get_attachments_config( gl, &attribs, &config );

+        if (!ctx->fs_hack_color_texture)
+            opengl_funcs.gl.p_glGenTextures( 1, &ctx->fs_hack_color_texture );
+        opengl_funcs.gl.p_glBindTexture( GL_TEXTURE_2D, ctx->fs_hack_color_texture );
+        opengl_funcs.gl.p_glTexImage2D( GL_TEXTURE_2D, 0, config.color_internalformat, width, height,
+                0, config.color_format, config.color_type, NULL);
+        opengl_funcs.gl.p_glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0);
+        opengl_funcs.gl.p_glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
+                ctx->fs_hack_integer ? GL_NEAREST : GL_LINEAR);
+        opengl_funcs.gl.p_glBindTexture( GL_TEXTURE_2D, prev_texture );
+        TRACE( "Created texture %u for fullscreen hack.\n", ctx->fs_hack_color_texture );
+
         if (config.samples)
         {
             if (!ctx->fs_hack_color_renderbuffer)
@@ -2022,30 +2255,17 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
                     config.color_internalformat, width, height );
             pglFramebufferRenderbuffer( GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
                     GL_RENDERBUFFER, ctx->fs_hack_color_renderbuffer );
-            TRACE( "Created renderbuffer %u for fullscreen hack.\n", ctx->fs_hack_color_renderbuffer );
-            pglGenRenderbuffers( 1, &ctx->fs_hack_color_resolve_renderbuffer );
-            pglBindRenderbuffer( GL_RENDERBUFFER, ctx->fs_hack_color_resolve_renderbuffer );
-            pglRenderbufferStorage( GL_RENDERBUFFER, config.color_internalformat, width, height );
+            TRACE( "Created renderbuffer %u and FBO %u for fullscreen hack.\n", ctx->fs_hack_color_renderbuffer, ctx->fs_hack_resolve_fbo );
             pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, ctx->fs_hack_resolve_fbo );
-            pglFramebufferRenderbuffer( GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
-                    GL_RENDERBUFFER, ctx->fs_hack_color_resolve_renderbuffer );
+            pglFramebufferTexture2D( GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
+                    GL_TEXTURE_2D, ctx->fs_hack_color_texture, 0 );
             pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, ctx->fs_hack_fbo );
             pglBindRenderbuffer( GL_RENDERBUFFER, prev_renderbuffer );
-            TRACE( "Also created renderbuffer %u and FBO %u for color resolve.\n",
-                    ctx->fs_hack_color_resolve_renderbuffer, ctx->fs_hack_resolve_fbo );
         }
         else
         {
-            if (!ctx->fs_hack_color_texture)
-                opengl_funcs.gl.p_glGenTextures( 1, &ctx->fs_hack_color_texture );
-            opengl_funcs.gl.p_glBindTexture( GL_TEXTURE_2D, ctx->fs_hack_color_texture );
-            opengl_funcs.gl.p_glTexImage2D( GL_TEXTURE_2D, 0, config.color_internalformat, width, height,
-                    0, config.color_format, config.color_type, NULL);
-            opengl_funcs.gl.p_glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0);
-            opengl_funcs.gl.p_glBindTexture( GL_TEXTURE_2D, prev_texture );
             pglFramebufferTexture2D( GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
                     GL_TEXTURE_2D, ctx->fs_hack_color_texture, 0 );
-            TRACE( "Created texture %u for fullscreen hack.\n", ctx->fs_hack_color_texture );
         }

         if (config.ds_internalformat)
@@ -2083,6 +2303,8 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
             }
         }

+        fs_hack_setup_gamma_shader(ctx, gl);
+
         if(!gl->fs_hack_context_set_up)
         {
             opengl_funcs.gl.p_glClearColor( 0.0f, 0.0f, 0.0f, 1.0f );
@@ -2105,6 +2327,10 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
         ctx->setup_for.x = width;
         ctx->setup_for.y = height;
         gl->has_scissor_indexed = has_extension(glExtensions, "GL_ARB_viewport_array");
+        gl->has_clip_control = has_extension(glExtensions, "GL_ARB_clip_control");
+        gl->has_ati_frag_shader = !ctx->is_core && has_extension(glExtensions, "GL_ATI_fragment_shader");
+        gl->has_fragment_program = !ctx->is_core && has_extension(glExtensions, "GL_ARB_fragment_program");
+        gl->has_vertex_program = !ctx->is_core && has_extension(glExtensions, "GL_ARB_vertex_program");
         ctx->fs_hack_integer = fs_hack_is_integer();
         gl->fs_hack_context_set_up = TRUE;
     }
@@ -2122,12 +2348,15 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
             ctx->current_read_fbo = 0;
         }

+        pglDeleteBuffers(1, &ctx->ramp_ubo);
+        pglDeleteProgram(ctx->fs_hack_gamma_pgm);
+        ctx->fs_hack_gamma_pgm = 0;
+
         pglDeleteRenderbuffers( 1, &ctx->fs_hack_ds_renderbuffer );
-        pglDeleteRenderbuffers( 1, &ctx->fs_hack_color_resolve_renderbuffer );
         pglDeleteRenderbuffers( 1, &ctx->fs_hack_color_renderbuffer );
         opengl_funcs.gl.p_glDeleteTextures( 1, &ctx->fs_hack_ds_texture );
         opengl_funcs.gl.p_glDeleteTextures( 1, &ctx->fs_hack_color_texture );
-        ctx->fs_hack_color_renderbuffer = ctx->fs_hack_color_resolve_renderbuffer = ctx->fs_hack_ds_renderbuffer = 0;
+        ctx->fs_hack_color_renderbuffer = ctx->fs_hack_ds_renderbuffer = 0;
         ctx->fs_hack_color_texture = ctx->fs_hack_ds_texture = 0;
         pglDeleteFramebuffers( 1, &ctx->fs_hack_resolve_fbo );
         pglDeleteFramebuffers( 1, &ctx->fs_hack_fbo );
@@ -2349,16 +2578,264 @@ static void wglReadBuffer( GLenum buffer )
     pglReadBuffer( buffer );
 }

+struct fs_hack_gl_state {
+    GLuint draw_fbo;
+    GLuint read_fbo;
+    GLuint program;
+    GLuint bound_texture;
+    GLint active_texture;
+    GLint clip_origin, clip_depth_mode;
+    GLuint ubo;
+    GLint64 ubo_size, ubo_start;
+    GLint viewporti[4];
+    GLfloat viewportf[4];
+    float clear_color[4];
+    GLboolean scissor_test, cull_face, blend, alpha_test, depth_test, stencil_test;
+    GLboolean arb_frag, arb_vert, ati_frag, fb_srgb;
+    GLboolean clip_distance[8];
+    GLboolean color_mask[4];
+    GLuint sampler;
+};
+
+#define SET 0
+#define RESET 1
+
+static void fs_hack_handle_enable_switch(int mode, GLenum cap, GLboolean *b, BOOL new)
+{
+    if(mode == SET){
+        *b = opengl_funcs.gl.p_glIsEnabled(cap);
+        if(new)
+            opengl_funcs.gl.p_glEnable(cap);
+        else
+            opengl_funcs.gl.p_glDisable(cap);
+    }else{
+        if(*b)
+            opengl_funcs.gl.p_glEnable(cap);
+        else
+            opengl_funcs.gl.p_glDisable(cap);
+    }
+}
+
+static void fs_hack_handle_fbo_state(int mode, struct gl_drawable *gl,
+        struct wgl_context *ctx, struct fs_hack_gl_state *state, const SIZE *real,
+        const SIZE *scaled, const POINT *scaled_origin)
+{
+    if(mode == SET){
+        opengl_funcs.gl.p_glGetIntegerv( GL_DRAW_FRAMEBUFFER_BINDING, (GLint *)&state->draw_fbo );
+        opengl_funcs.gl.p_glGetIntegerv( GL_READ_FRAMEBUFFER_BINDING, (GLint *)&state->read_fbo );
+        TRACE( "Previous draw FBO %u, read FBO %u\n", state->draw_fbo, state->read_fbo );
+
+    }else{
+        pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, state->draw_fbo );
+        pglBindFramebuffer( GL_READ_FRAMEBUFFER, state->read_fbo );
+    }
+}
+
+static void fs_hack_handle_clip_control(int mode, struct gl_drawable *gl,
+        struct wgl_context *ctx, struct fs_hack_gl_state *state, const SIZE *real,
+        const SIZE *scaled, const POINT *scaled_origin)
+{
+    if(!gl->has_clip_control)
+        return;
+
+    if(mode == SET){
+        opengl_funcs.gl.p_glGetIntegerv(GL_CLIP_ORIGIN, (GLint *)&state->clip_origin);
+        opengl_funcs.gl.p_glGetIntegerv(GL_CLIP_DEPTH_MODE, (GLint *)&state->clip_depth_mode);
+
+
+        pglClipControl(GL_LOWER_LEFT, GL_NEGATIVE_ONE_TO_ONE);
+
+    }else{
+        pglClipControl(state->clip_origin, state->clip_depth_mode);
+    }
+}
+
+static void fs_hack_handle_shaders(int mode, struct gl_drawable *gl,
+        struct wgl_context *ctx, struct fs_hack_gl_state *state, const SIZE *real,
+        const SIZE *scaled, const POINT *scaled_origin)
+{
+    if (gl->has_fragment_program)
+        fs_hack_handle_enable_switch(mode, GL_FRAGMENT_PROGRAM_ARB, &state->arb_frag, FALSE);
+    if (gl->has_vertex_program)
+        fs_hack_handle_enable_switch(mode, GL_VERTEX_PROGRAM_ARB, &state->arb_vert, FALSE);
+    fs_hack_handle_enable_switch(mode, GL_FRAMEBUFFER_SRGB, &state->fb_srgb, TRUE);
+
+    if(gl->has_ati_frag_shader)
+        fs_hack_handle_enable_switch(mode, GL_FRAGMENT_SHADER_ATI, &state->ati_frag, FALSE);
+
+    if(mode == SET){
+        opengl_funcs.gl.p_glGetIntegerv( GL_CURRENT_PROGRAM, (GLint *)&state->program );
+
+        pglGetIntegeri_v( GL_UNIFORM_BUFFER_BINDING, 0, (GLint *)&state->ubo );
+        pglGetInteger64i_v( GL_UNIFORM_BUFFER_START, 0, &state->ubo_start );
+        pglGetInteger64i_v( GL_UNIFORM_BUFFER_SIZE, 0, &state->ubo_size );
+
+        opengl_funcs.gl.p_glGetIntegerv(GL_ACTIVE_TEXTURE, &state->active_texture);
+        pglActiveTexture(GL_TEXTURE0);
+        opengl_funcs.gl.p_glGetIntegerv( GL_TEXTURE_BINDING_2D, (GLint *)&state->bound_texture );
+        pglGetIntegeri_v(GL_SAMPLER_BINDING, 0, (GLint *)&state->sampler);
+
+        pglBindBufferBase(GL_UNIFORM_BUFFER, 0, ctx->ramp_ubo);
+
+        opengl_funcs.gl.p_glBindTexture( GL_TEXTURE_2D, ctx->fs_hack_color_texture );
+        pglBindSampler( 0, 0 );
+
+        pglUseProgram( ctx->fs_hack_gamma_pgm );
+
+    }else{
+        pglUseProgram( state->program );
+
+        pglBindSampler( 0, state->sampler );
+
+        opengl_funcs.gl.p_glBindTexture( GL_TEXTURE_2D, state->bound_texture );
+        pglActiveTexture(state->active_texture);
+
+        pglBindBufferRange(GL_UNIFORM_BUFFER, 0, state->ubo, state->ubo_start, state->ubo_size);
+    }
+}
+
+static void fs_hack_handle_viewport(int mode, struct gl_drawable *gl,
+        struct wgl_context *ctx, struct fs_hack_gl_state *state, const SIZE *real,
+        const SIZE *scaled, const POINT *scaled_origin)
+{
+    if(mode == SET){
+        if(gl->has_scissor_indexed){
+            pglGetFloati_v(GL_VIEWPORT, 0, state->viewportf);
+            pglViewportIndexedf(0, scaled_origin->x, scaled_origin->y, scaled->cx, scaled->cy);
+        }else{
+            opengl_funcs.gl.p_glGetIntegerv(GL_VIEWPORT, state->viewporti);
+            opengl_funcs.gl.p_glViewport(scaled_origin->x, scaled_origin->y, scaled->cx, scaled->cy);
+        }
+
+    }else{
+        if(gl->has_scissor_indexed){
+            pglViewportIndexedfv(0, state->viewportf);
+        }else{
+            opengl_funcs.gl.p_glViewport(state->viewporti[0], state->viewporti[1],
+                    state->viewporti[2], state->viewporti[3]);
+        }
+    }
+}
+
+static void fs_hack_handle_clear_color(int mode, struct gl_drawable *gl,
+        struct wgl_context *ctx, struct fs_hack_gl_state *state, const SIZE *real,
+        const SIZE *scaled, const POINT *scaled_origin)
+{
+    if(mode == SET){
+        opengl_funcs.gl.p_glGetFloatv( GL_COLOR_CLEAR_VALUE, state->clear_color );
+        opengl_funcs.gl.p_glClearColor( 0.0f, 0.0f, 0.0f, 1.0f );
+    }else{
+        opengl_funcs.gl.p_glClearColor( state->clear_color[0], state->clear_color[1], state->clear_color[2], state->clear_color[3] );
+    }
+}
+
+static void fs_hack_handle_clip_distance(int mode, struct gl_drawable *gl,
+        struct wgl_context *ctx, struct fs_hack_gl_state *state, const SIZE *real,
+        const SIZE *scaled, const POINT *scaled_origin)
+{
+    unsigned int i;
+    if(mode == SET){
+        for(i = 0; i < ARRAY_SIZE(state->clip_distance); ++i){
+            state->clip_distance[i] = opengl_funcs.gl.p_glIsEnabled(GL_CLIP_DISTANCE0 + i);
+            opengl_funcs.gl.p_glDisable(GL_CLIP_DISTANCE0 + i);
+        }
+    }else{
+        for(i = 0; i < ARRAY_SIZE(state->clip_distance); ++i){
+            if(state->clip_distance[i])
+                opengl_funcs.gl.p_glEnable(GL_CLIP_DISTANCE0 + i);
+        }
+    }
+}
+
+static void fs_hack_handle_color_mask(int mode, struct gl_drawable *gl,
+        struct wgl_context *ctx, struct fs_hack_gl_state *state, const SIZE *real,
+        const SIZE *scaled, const POINT *scaled_origin)
+{
+    if(mode == SET){
+        pglGetBooleani_v(GL_COLOR_WRITEMASK, 0, state->color_mask);
+
+        pglColorMaski(0, GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
+    }else{
+        pglColorMaski(0, state->color_mask[0],
+                state->color_mask[1], state->color_mask[2],
+                state->color_mask[3]);
+    }
+}
+
+static void fs_hack_handle_scissor(int mode, struct gl_drawable *gl,
+        struct wgl_context *ctx, struct fs_hack_gl_state *state,
+        const SIZE *real, const SIZE *scaled, const POINT *scaled_origin)
+{
+    fs_hack_handle_enable_switch(mode, GL_SCISSOR_TEST, &state->scissor_test, FALSE);
+}
+
+static void fs_hack_handle_cull_face(int mode, struct gl_drawable *gl,
+        struct wgl_context *ctx, struct fs_hack_gl_state *state, const SIZE *real,
+        const SIZE *scaled, const POINT *scaled_origin)
+{
+    fs_hack_handle_enable_switch(mode, GL_CULL_FACE, &state->cull_face, FALSE);
+}
+
+static void fs_hack_handle_blend(int mode, struct gl_drawable *gl,
+        struct wgl_context *ctx, struct fs_hack_gl_state *state, const SIZE *real,
+        const SIZE *scaled, const POINT *scaled_origin)
+{
+    fs_hack_handle_enable_switch(mode, GL_BLEND, &state->blend, FALSE);
+}
+
+static void fs_hack_handle_alpha_test(int mode, struct gl_drawable *gl,
+        struct wgl_context *ctx, struct fs_hack_gl_state *state, const SIZE *real,
+        const SIZE *scaled, const POINT *scaled_origin)
+{
+    if(ctx->is_core)
+        return;
+
+    fs_hack_handle_enable_switch(mode, GL_ALPHA_TEST, &state->alpha_test, FALSE);
+}
+
+static void fs_hack_handle_ds_test(int mode, struct gl_drawable *gl,
+        struct wgl_context *ctx, struct fs_hack_gl_state *state, const SIZE *real,
+        const SIZE *scaled, const POINT *scaled_origin)
+{
+    fs_hack_handle_enable_switch(mode, GL_DEPTH_TEST, &state->depth_test, FALSE);
+    fs_hack_handle_enable_switch(mode, GL_STENCIL_TEST, &state->stencil_test, FALSE);
+}
+
 static void fs_hack_blit_framebuffer( struct gl_drawable *gl, GLenum draw_buffer )
 {
+    static const struct
+    {
+        void (*state_handler)(int mode, struct gl_drawable *gl, struct wgl_context *ctx,
+                struct fs_hack_gl_state *state, const SIZE *real,
+                const SIZE *scaled, const POINT *scaled_origin);
+    }
+    general_state_handlers[] =
+    {
+        {fs_hack_handle_fbo_state},
+        {fs_hack_handle_scissor},
+        {fs_hack_handle_clear_color},
+    },
+    draw_state_handlers[] =
+    {
+        {fs_hack_handle_clip_control},
+        {fs_hack_handle_shaders},
+        {fs_hack_handle_viewport},
+        {fs_hack_handle_cull_face},
+        {fs_hack_handle_clip_distance},
+        {fs_hack_handle_color_mask},
+        {fs_hack_handle_blend},
+        {fs_hack_handle_alpha_test},
+        {fs_hack_handle_ds_test},
+    };
     struct wgl_context *ctx = NtCurrentTeb()->glContext;
     SIZE scaled, src, real;
-    GLuint prev_draw_fbo, prev_read_fbo;
-    GLint prev_scissor[4];
     RECT user_rect, real_rect;
     POINT scaled_origin;
-    float prev_clear_color[4];
     HMONITOR monitor;
+    struct fs_hack_gl_state state;
+    const float *gamma_ramp;
+    LONG gamma_serial;
+    unsigned int i;

     monitor = fs_hack_monitor_from_hwnd(WindowFromDC(ctx->hdc));
     scaled = fs_hack_get_scaled_screen_size(monitor);
@@ -2374,6 +2851,8 @@ static void fs_hack_blit_framebuffer( struct gl_drawable *gl, GLenum draw_buffer
     scaled_origin.x -= real_rect.left;
     scaled_origin.y -= real_rect.top;

+    gamma_ramp = fs_hack_get_gamma_ramp(&gamma_serial);
+
     TRACE("scaled:%dx%d src:%dx%d real:%dx%d user_rect:%s real_rect:%s scaled_origin:%s\n", scaled.cx, scaled.cy,
           src.cx, src.cy, real.cx, real.cy, wine_dbgstr_rect(&user_rect), wine_dbgstr_rect(&real_rect),
           wine_dbgstr_point(&scaled_origin));
@@ -2382,54 +2861,68 @@ static void fs_hack_blit_framebuffer( struct gl_drawable *gl, GLenum draw_buffer
             ctx->setup_for.y != src.cy)
         fs_hack_setup_context( ctx, gl );

-    TRACE( "Blitting from FBO %u %ux%u to %ux%u\n", ctx->fs_hack_fbo, src.cx, src.cy, scaled.cx, scaled.cy );
+    /* Can't stretch blit with multisampled renderbuffers */
+    if (ctx->fs_hack_color_renderbuffer && !gamma_ramp){
+        gamma_ramp = fs_hack_get_default_gamma_ramp();
+        gamma_serial = 0;
+    }

-    opengl_funcs.gl.p_glGetIntegerv( GL_DRAW_FRAMEBUFFER_BINDING, (GLint *)&prev_draw_fbo );
-    opengl_funcs.gl.p_glGetIntegerv( GL_READ_FRAMEBUFFER_BINDING, (GLint *)&prev_read_fbo );
-    TRACE( "Previous draw FBO %u, read FBO %u\n", prev_draw_fbo, prev_read_fbo );
+    TRACE( "Stretching from FBO %u %ux%u to %ux%u\n", ctx->fs_hack_fbo, src.cx, src.cy, scaled.cx, scaled.cy );

-    if(gl->has_scissor_indexed){
-        opengl_funcs.ext.p_glGetIntegeri_v(GL_SCISSOR_BOX, 0, prev_scissor);
-        opengl_funcs.ext.p_glScissorIndexed(0, 0, 0, real.cx, real.cy);
-    }else{
-        opengl_funcs.gl.p_glGetIntegerv(GL_SCISSOR_BOX, prev_scissor);
-        opengl_funcs.gl.p_glScissor(0, 0, real.cx, real.cy);
+    for (i = 0; i < ARRAY_SIZE(general_state_handlers); i++)
+        general_state_handlers[i].state_handler(SET, gl, ctx, &state, &real, &scaled, &scaled_origin);
+
+    if(gamma_ramp){
+        for (i = 0; i < ARRAY_SIZE(draw_state_handlers); i++)
+            draw_state_handlers[i].state_handler(SET, gl, ctx, &state, &real, &scaled, &scaled_origin);
     }

     pglBindFramebuffer( GL_READ_FRAMEBUFFER, ctx->fs_hack_fbo );
-    if (ctx->fs_hack_color_resolve_renderbuffer)
+
+    if (ctx->fs_hack_color_renderbuffer)
     {
         pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, ctx->fs_hack_resolve_fbo );
+
         pglBlitFramebuffer( 0, 0, src.cx, src.cy, 0, 0, src.cx, src.cy, GL_COLOR_BUFFER_BIT, GL_NEAREST );
+
         pglBindFramebuffer( GL_READ_FRAMEBUFFER, ctx->fs_hack_resolve_fbo );
     }
+
     pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, 0 );

     //HACK
     //pglDrawBuffer( draw_buffer );
     pglDrawBuffer( GL_BACK );

-    opengl_funcs.gl.p_glGetFloatv( GL_COLOR_CLEAR_VALUE, prev_clear_color );
-    opengl_funcs.gl.p_glClearColor( 0.0f, 0.0f, 0.0f, 1.0f );
     opengl_funcs.gl.p_glClear( GL_COLOR_BUFFER_BIT );
-    opengl_funcs.gl.p_glClearColor( prev_clear_color[0], prev_clear_color[1], prev_clear_color[2], prev_clear_color[3] );

-    pglBlitFramebuffer( 0, 0, src.cx, src.cy,
-            scaled_origin.x, scaled_origin.y, scaled_origin.x + scaled.cx, scaled_origin.y + scaled.cy,
-            GL_COLOR_BUFFER_BIT, ctx->fs_hack_integer ? GL_NEAREST : GL_LINEAR );
+    if(gamma_ramp){
+        if(gamma_serial != gl->last_gamma_serial){
+            TRACE("updating gamma ramp (serial: %u)\n", gamma_serial);
+
+            pglBufferData(GL_UNIFORM_BUFFER, sizeof(float) * 4 * GAMMA_RAMP_SIZE, gamma_ramp, GL_DYNAMIC_DRAW);
+
+            gl->last_gamma_serial = gamma_serial;
+        }
+
+        pglDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
+    }else{
+        pglBlitFramebuffer( 0, 0, src.cx, src.cy,
+                scaled_origin.x, scaled_origin.y, scaled_origin.x + scaled.cx, scaled_origin.y + scaled.cy,
+                GL_COLOR_BUFFER_BIT, ctx->fs_hack_integer ? GL_NEAREST : GL_LINEAR );
+    }
+
     //HACK
     if ( draw_buffer == GL_FRONT )
         pglXSwapBuffers(gdi_display, gl->drawable);

-    if(gl->has_scissor_indexed){
-        opengl_funcs.ext.p_glScissorIndexedv(0, prev_scissor);
-    }else{
-        opengl_funcs.gl.p_glScissor(prev_scissor[0], prev_scissor[1],
-                prev_scissor[2], prev_scissor[3]);
+    if(gamma_ramp){
+        for (i = 0; i < ARRAY_SIZE(draw_state_handlers); i++)
+            draw_state_handlers[i].state_handler(RESET, gl, ctx, &state, NULL, NULL, NULL);
     }

-    pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, prev_draw_fbo );
-    pglBindFramebuffer( GL_READ_FRAMEBUFFER, prev_read_fbo );
+    for (i = 0; i < ARRAY_SIZE(general_state_handlers); i++)
+        general_state_handlers[i].state_handler(RESET, gl, ctx, &state, NULL, NULL, NULL);
 }

 static void wglFinish(void)
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 55875edc788..3e162382975 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -688,6 +688,8 @@ extern double fs_hack_get_user_to_real_scale(HMONITOR) DECLSPEC_HIDDEN;
 extern SIZE fs_hack_get_scaled_screen_size(HMONITOR monitor) DECLSPEC_HIDDEN;
 extern RECT fs_hack_get_real_virtual_screen(void) DECLSPEC_HIDDEN;
 extern void fs_hack_init(void) DECLSPEC_HIDDEN;
+extern const float *fs_hack_get_gamma_ramp(LONG *serial);
+extern void fs_hack_set_gamma_ramp(const WORD *ramp);
 extern int mode_compare(const void *p1, const void *p2) DECLSPEC_HIDDEN;

 static inline void mirror_rect( const RECT *window_rect, RECT *rect )
diff --git a/dlls/winex11.drv/xvidmode.c b/dlls/winex11.drv/xvidmode.c
index 123e5d036a9..828aeb83d0c 100644
--- a/dlls/winex11.drv/xvidmode.c
+++ b/dlls/winex11.drv/xvidmode.c
@@ -554,6 +554,25 @@ void X11DRV_XF86VM_Init(void)

 #endif /* SONAME_LIBXXF86VM */

+static BOOL CALLBACK gammahack_UpdateWindowGamma(HWND hwnd, LPARAM lparam)
+{
+    /* XXX: Technically, the ramp should only apply to windows on the given
+     * device, but I can't think of a situation in which that would matter. */
+
+    sync_gl_drawable(hwnd, FALSE);
+
+    return TRUE;
+}
+
+static BOOL gamma_hack_SetGammaRamp(PHYSDEV dev, const WORD *ramp)
+{
+    fs_hack_set_gamma_ramp(ramp);
+
+    EnumWindows(gammahack_UpdateWindowGamma, 0);
+
+    return TRUE;
+}
+
 /***********************************************************************
  *		GetDeviceGammaRamp (X11DRV.@)
  *
@@ -580,7 +599,9 @@ BOOL CDECL X11DRV_GetDeviceGammaRamp(PHYSDEV dev, LPVOID ramp)
 BOOL CDECL X11DRV_SetDeviceGammaRamp(PHYSDEV dev, LPVOID ramp)
 {
 #ifdef SONAME_LIBXXF86VM
-  return X11DRV_XF86VM_SetGammaRamp(ramp);
+  if(!X11DRV_XF86VM_SetGammaRamp(ramp))
+      return gamma_hack_SetGammaRamp(dev, ramp);
+  return TRUE;
 #else
   return FALSE;
 #endif
From d342a851179df02705f463d6cac444cbe6607868 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 22 Jun 2021 18:57:49 +0300
Subject: [PATCH] fshack: Setup gamma shader only once per context.

Fixes GL objects leak and avoids unneccessary shader recreation
when the fs_hack_setup_context() is called due to switching GL
drawable.

For Star Wars - Knights of the Old Republic blank screen.

CW-Bug-Id: #19002
---
 dlls/winex11.drv/opengl.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index fab13d5b1df..db66aabff59 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -2079,6 +2079,11 @@ static void fs_hack_setup_gamma_shader( struct wgl_context *ctx, struct gl_drawa
     char errstr[512];
     const float *default_gamma_ramp = fs_hack_get_default_gamma_ramp();

+    gl->last_gamma_serial = 0;
+
+    if (ctx->fs_hack_gamma_pgm)
+        return;
+
     opengl_funcs.gl.p_glGetIntegerv( GL_CURRENT_PROGRAM, (GLint *)&prev_program );
     /* vertex shader */
     vshader = pglCreateShader(GL_VERTEX_SHADER);
@@ -2148,7 +2153,6 @@ static void fs_hack_setup_gamma_shader( struct wgl_context *ctx, struct gl_drawa
     pglGenBuffers(1, &ctx->ramp_ubo);
     pglBindBuffer(GL_UNIFORM_BUFFER, ctx->ramp_ubo);
     pglBufferData(GL_UNIFORM_BUFFER, sizeof(float) * 4 * GAMMA_RAMP_SIZE, default_gamma_ramp, GL_DYNAMIC_DRAW);
-    gl->last_gamma_serial = 0;

     ramp_index = pglGetUniformBlockIndex(program, "ramp");
     pglUniformBlockBinding(program, ramp_index, 0);
From b52e6329eb7ff2feec0ef0b4b2bb638abe57e200 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 22 Jun 2021 23:56:20 +0300
Subject: [PATCH] fshack: Track if multisample resolve is needed in
 gl_drawable.

As that changes per drawable and not per context.
---
 dlls/winex11.drv/opengl.c | 9 +++++++--
 1 file changed, 7 insertions(+), 2 deletions(-)

diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index db66aabff59..5b4a7456e29 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -263,6 +263,7 @@ struct gl_drawable
     BOOL                           fs_hack;
     BOOL                           fs_hack_did_swapbuf;
     BOOL                           fs_hack_context_set_up;
+    BOOL                           fs_hack_needs_resolve;
     BOOL                           has_scissor_indexed;
     BOOL                           has_clip_control;
     BOOL                           has_ati_frag_shader;
@@ -2252,11 +2253,13 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *

         if (config.samples)
         {
+            gl->fs_hack_needs_resolve = TRUE;
             if (!ctx->fs_hack_color_renderbuffer)
                 pglGenRenderbuffers( 1, &ctx->fs_hack_color_renderbuffer );
             pglBindRenderbuffer( GL_RENDERBUFFER, ctx->fs_hack_color_renderbuffer );
             pglRenderbufferStorageMultisample( GL_RENDERBUFFER, config.samples,
                     config.color_internalformat, width, height );
+
             pglFramebufferRenderbuffer( GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
                     GL_RENDERBUFFER, ctx->fs_hack_color_renderbuffer );
             TRACE( "Created renderbuffer %u and FBO %u for fullscreen hack.\n", ctx->fs_hack_color_renderbuffer, ctx->fs_hack_resolve_fbo );
@@ -2268,6 +2271,7 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
         }
         else
         {
+            gl->fs_hack_needs_resolve = FALSE;
             pglFramebufferTexture2D( GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
                     GL_TEXTURE_2D, ctx->fs_hack_color_texture, 0 );
         }
@@ -2281,6 +2285,7 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
                 pglBindRenderbuffer( GL_RENDERBUFFER, ctx->fs_hack_ds_renderbuffer );
                 pglRenderbufferStorageMultisample( GL_RENDERBUFFER, config.samples,
                         config.ds_internalformat, width, height );
+
                 pglBindRenderbuffer( GL_RENDERBUFFER, prev_renderbuffer );
                 if (attribs.depth_size)
                     pglFramebufferRenderbuffer( GL_DRAW_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
@@ -2866,7 +2871,7 @@ static void fs_hack_blit_framebuffer( struct gl_drawable *gl, GLenum draw_buffer
         fs_hack_setup_context( ctx, gl );

     /* Can't stretch blit with multisampled renderbuffers */
-    if (ctx->fs_hack_color_renderbuffer && !gamma_ramp){
+    if (gl->fs_hack_needs_resolve && !gamma_ramp){
         gamma_ramp = fs_hack_get_default_gamma_ramp();
         gamma_serial = 0;
     }
@@ -2883,7 +2888,7 @@ static void fs_hack_blit_framebuffer( struct gl_drawable *gl, GLenum draw_buffer

     pglBindFramebuffer( GL_READ_FRAMEBUFFER, ctx->fs_hack_fbo );

-    if (ctx->fs_hack_color_renderbuffer)
+    if (gl->fs_hack_needs_resolve)
     {
         pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, ctx->fs_hack_resolve_fbo );

From d4eb7bd91e076ae6531fe87d83dae2ad07042caa Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Wed, 23 Jun 2021 20:26:27 +0300
Subject: [PATCH] fshack: Destroy fshack GL objects only at GL context destroy.

---
 dlls/winex11.drv/opengl.c | 59 ++++++++++++++++++++++++++++-----------
 1 file changed, 43 insertions(+), 16 deletions(-)

diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index 5b4a7456e29..ff5c9969aab 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -1899,6 +1899,40 @@ static struct wgl_context * WINAPI glxdrv_wglCreateContext( HDC hdc )
     return ret;
 }

+static void fs_hack_destroy_context( struct wgl_context *ctx )
+{
+    GLXContext prev_context;
+    GLXDrawable prev_drawable;
+
+    if (!ctx->drawables[0]) return;
+
+    prev_context = pglXGetCurrentContext();
+    prev_drawable = pglXGetCurrentDrawable();
+    pglXMakeCurrent(gdi_display, ctx->drawables[0]->drawable, ctx->ctx);
+
+    pglDeleteBuffers(1, &ctx->ramp_ubo);
+    pglDeleteProgram(ctx->fs_hack_gamma_pgm);
+    ctx->fs_hack_gamma_pgm = 0;
+
+    if (ctx->fs_hack_ds_renderbuffer)
+        pglDeleteRenderbuffers( 1, &ctx->fs_hack_ds_renderbuffer );
+    if (ctx->fs_hack_color_renderbuffer)
+        pglDeleteRenderbuffers( 1, &ctx->fs_hack_color_renderbuffer );
+    if (ctx->fs_hack_ds_texture)
+        opengl_funcs.gl.p_glDeleteTextures( 1, &ctx->fs_hack_ds_texture );
+    if (ctx->fs_hack_color_texture)
+        opengl_funcs.gl.p_glDeleteTextures( 1, &ctx->fs_hack_color_texture );
+    ctx->fs_hack_color_renderbuffer = ctx->fs_hack_ds_renderbuffer = 0;
+    ctx->fs_hack_color_texture = ctx->fs_hack_ds_texture = 0;
+    if (ctx->fs_hack_resolve_fbo)
+        pglDeleteFramebuffers( 1, &ctx->fs_hack_resolve_fbo );
+    if (ctx->fs_hack_fbo)
+        pglDeleteFramebuffers( 1, &ctx->fs_hack_fbo );
+    ctx->fs_hack_resolve_fbo = ctx->fs_hack_fbo = 0;
+
+    pglXMakeCurrent(gdi_display, prev_drawable, prev_context);
+}
+
 /***********************************************************************
  *		glxdrv_wglDeleteContext
  */
@@ -1908,6 +1942,8 @@ static BOOL WINAPI glxdrv_wglDeleteContext(struct wgl_context *ctx)

     TRACE("(%p)\n", ctx);

+    fs_hack_destroy_context( ctx );
+
     EnterCriticalSection( &context_section );
     list_remove( &ctx->entry );
     LIST_FOR_EACH_ENTRY( pb, &pbuffer_list, struct wgl_pbuffer, entry )
@@ -2227,7 +2263,6 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
         if (!ctx->fs_hack_fbo)
         {
             pglGenFramebuffers( 1, &ctx->fs_hack_fbo );
-            pglGenFramebuffers( 1, &ctx->fs_hack_resolve_fbo );
             TRACE( "Created FBO %u for fullscreen hack.\n", ctx->fs_hack_fbo );
         }
         pglBindFramebuffer( GL_DRAW_FRAMEBUFFER, 0);
@@ -2254,6 +2289,13 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
         if (config.samples)
         {
             gl->fs_hack_needs_resolve = TRUE;
+
+            if (!ctx->fs_hack_resolve_fbo)
+            {
+                pglGenFramebuffers( 1, &ctx->fs_hack_resolve_fbo );
+                TRACE( "Created resolve FBO %u for fullscreen hack.\n", ctx->fs_hack_resolve_fbo );
+            }
+
             if (!ctx->fs_hack_color_renderbuffer)
                 pglGenRenderbuffers( 1, &ctx->fs_hack_color_renderbuffer );
             pglBindRenderbuffer( GL_RENDERBUFFER, ctx->fs_hack_color_renderbuffer );
@@ -2356,21 +2398,6 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
             pglBindFramebuffer( GL_READ_FRAMEBUFFER, 0 );
             ctx->current_read_fbo = 0;
         }
-
-        pglDeleteBuffers(1, &ctx->ramp_ubo);
-        pglDeleteProgram(ctx->fs_hack_gamma_pgm);
-        ctx->fs_hack_gamma_pgm = 0;
-
-        pglDeleteRenderbuffers( 1, &ctx->fs_hack_ds_renderbuffer );
-        pglDeleteRenderbuffers( 1, &ctx->fs_hack_color_renderbuffer );
-        opengl_funcs.gl.p_glDeleteTextures( 1, &ctx->fs_hack_ds_texture );
-        opengl_funcs.gl.p_glDeleteTextures( 1, &ctx->fs_hack_color_texture );
-        ctx->fs_hack_color_renderbuffer = ctx->fs_hack_ds_renderbuffer = 0;
-        ctx->fs_hack_color_texture = ctx->fs_hack_ds_texture = 0;
-        pglDeleteFramebuffers( 1, &ctx->fs_hack_resolve_fbo );
-        pglDeleteFramebuffers( 1, &ctx->fs_hack_fbo );
-        ctx->fs_hack_fbo = 0;
-
         gl->fs_hack_context_set_up = FALSE;
     }
 }
From f4dc9634f2036de04260193c2beca61aa1bf8dd1 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 22 Jun 2021 00:36:17 +0300
Subject: [PATCH] fshack: Set viewport in fs_hack_setup_context().

For Star Wars - Knights of the Old Republic blank screen.

CW-Bug-Id: #19002
---
 dlls/winex11.drv/opengl.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index ff5c9969aab..d0089806155 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -2356,6 +2356,9 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *

         fs_hack_setup_gamma_shader(ctx, gl);

+        if (!ctx->has_been_current)
+            opengl_funcs.gl.p_glViewport(0, 0, width, height);
+
         if(!gl->fs_hack_context_set_up)
         {
             opengl_funcs.gl.p_glClearColor( 0.0f, 0.0f, 0.0f, 1.0f );
@@ -2383,6 +2386,7 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
         gl->has_fragment_program = !ctx->is_core && has_extension(glExtensions, "GL_ARB_fragment_program");
         gl->has_vertex_program = !ctx->is_core && has_extension(glExtensions, "GL_ARB_vertex_program");
         ctx->fs_hack_integer = fs_hack_is_integer();
+
         gl->fs_hack_context_set_up = TRUE;
     }
     else
From 79f3013b06b7502fa2875aac989335ec0d8576b5 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 22 Jun 2021 19:03:16 +0300
Subject: [PATCH] fshack: Also enable fshack for drawable due to gamma in
 create_gl_drawable().

For Star Wars - Knights of the Old Republic blank screen.

CW-Bug-Id: #19002
---
 dlls/winex11.drv/opengl.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index d0089806155..0a08c0a2261 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -1471,7 +1471,7 @@ static struct gl_drawable *create_gl_drawable( HWND hwnd, const struct wgl_pixel
         if (gl->window)
             gl->drawable = pglXCreateWindow( gdi_display, gl->format->fbconfig, gl->window, NULL );
         data = get_win_data( hwnd );
-        gl->fs_hack = data->fs_hack;
+        gl->fs_hack = data->fs_hack || fs_hack_get_gamma_ramp(NULL);
         if (gl->fs_hack)
             TRACE( "Window %p has the fullscreen hack enabled\n", hwnd );
         release_win_data( data );
From a770d875cd09a714bedcbfeef16062a62a77c169 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 22 Jun 2021 18:54:20 +0300
Subject: [PATCH] fshack: Use window dimensions in GL if fshack is enabled for
 gamma only.

For Star Wars - Knights of the Old Republic blank screen.

CW-Bug-Id: #19002
---
 dlls/winex11.drv/opengl.c | 49 ++++++++++++++++++++++++++++++---------
 1 file changed, 38 insertions(+), 11 deletions(-)

diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index 0a08c0a2261..175b183dc44 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -2237,14 +2237,27 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *
         MONITORINFO monitor_info;
         HMONITOR monitor;
         int width, height;
+        RECT rect = {0};
         GLuint profile;
+        HWND hwnd;

-        monitor = fs_hack_monitor_from_hwnd(WindowFromDC(ctx->hdc));
-        memset(&monitor_info, 0, sizeof(monitor_info));
-        monitor_info.cbSize = sizeof(monitor_info);
-        GetMonitorInfoW(monitor, &monitor_info);
-        width = monitor_info.rcMonitor.right - monitor_info.rcMonitor.left;
-        height = monitor_info.rcMonitor.bottom - monitor_info.rcMonitor.top;
+        hwnd = WindowFromDC(ctx->hdc);
+        monitor = fs_hack_monitor_from_hwnd(hwnd);
+
+        if (fs_hack_enabled(monitor))
+        {
+            memset(&monitor_info, 0, sizeof(monitor_info));
+            monitor_info.cbSize = sizeof(monitor_info);
+            GetMonitorInfoW(monitor, &monitor_info);
+            rect = monitor_info.rcMonitor;
+        }
+        else
+        {
+            GetClientRect(hwnd, &rect);
+        }
+
+        width = rect.right - rect.left;
+        height = rect.bottom - rect.top;

         TRACE("Render buffer width:%d height:%d\n", width, height);

@@ -2869,18 +2882,32 @@ static void fs_hack_blit_framebuffer( struct gl_drawable *gl, GLenum draw_buffer
     };
     struct wgl_context *ctx = NtCurrentTeb()->glContext;
     SIZE scaled, src, real;
-    RECT user_rect, real_rect;
+    RECT user_rect = {0}, real_rect;
     POINT scaled_origin;
     HMONITOR monitor;
     struct fs_hack_gl_state state;
     const float *gamma_ramp;
     LONG gamma_serial;
     unsigned int i;
+    HWND hwnd;
+
+    hwnd = WindowFromDC(ctx->hdc);
+    monitor = fs_hack_monitor_from_hwnd(hwnd);
+
+    if (fs_hack_enabled(monitor))
+    {
+        user_rect = fs_hack_current_mode(monitor);
+        real_rect = fs_hack_real_mode(monitor);
+        scaled = fs_hack_get_scaled_screen_size(monitor);
+    }
+    else
+    {
+        GetClientRect(hwnd, &user_rect);
+        real_rect = user_rect;
+        scaled.cx = user_rect.right - user_rect.left;
+        scaled.cy = user_rect.bottom - user_rect.top;
+    }

-    monitor = fs_hack_monitor_from_hwnd(WindowFromDC(ctx->hdc));
-    scaled = fs_hack_get_scaled_screen_size(monitor);
-    user_rect = fs_hack_current_mode(monitor);
-    real_rect = fs_hack_real_mode(monitor);
     src.cx = user_rect.right - user_rect.left;
     src.cy = user_rect.bottom - user_rect.top;
     real.cx = real_rect.right - real_rect.left;
From 2452e8f4855dbd27e2f1a951fad2da7d21ddf711 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Wed, 23 Jun 2021 00:01:57 +0300
Subject: [PATCH] fshack: Use window size for texture and framebuffers in
 fs_hack_setup_context().

For Star Wars - Knights of the Old Republic blank screen.

CW-Bug-Id: #19002
---
 dlls/winex11.drv/opengl.c | 16 +---------------
 1 file changed, 1 insertion(+), 15 deletions(-)

diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index 175b183dc44..91119e8d393 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -2234,27 +2234,13 @@ static void fs_hack_setup_context( struct wgl_context *ctx, struct gl_drawable *

     if (ctx->fs_hack)
     {
-        MONITORINFO monitor_info;
-        HMONITOR monitor;
         int width, height;
         RECT rect = {0};
         GLuint profile;
         HWND hwnd;

         hwnd = WindowFromDC(ctx->hdc);
-        monitor = fs_hack_monitor_from_hwnd(hwnd);
-
-        if (fs_hack_enabled(monitor))
-        {
-            memset(&monitor_info, 0, sizeof(monitor_info));
-            monitor_info.cbSize = sizeof(monitor_info);
-            GetMonitorInfoW(monitor, &monitor_info);
-            rect = monitor_info.rcMonitor;
-        }
-        else
-        {
-            GetClientRect(hwnd, &rect);
-        }
+        GetClientRect(hwnd, &rect);

         width = rect.right - rect.left;
         height = rect.bottom - rect.top;
From 3b91dfd727758caf874bbcfaedd8a0f4d4822320 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 23 Feb 2021 11:28:28 +0100
Subject: [PATCH] HACK: fshack: winex11.drv: Use gdi_display for client_window
 requests.

CW-Bug-Id: 16608
---
 dlls/winex11.drv/window.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index bbe2a1728b5..e785e0c0563 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -2659,7 +2659,7 @@ BOOL CDECL X11DRV_WindowPosChanging( HWND hwnd, HWND insert_after, UINT swp_flag
         if(data->whole_window)
             XMoveResizeWindow(data->display, data->whole_window, tl.x, tl.y, real_rect.right - real_rect.left, real_rect.bottom - real_rect.top);
         if(data->client_window)
-            XMoveResizeWindow(data->display, data->client_window, 0, 0, real_rect.right - real_rect.left, real_rect.bottom - real_rect.top);
+            XMoveResizeWindow(gdi_display, data->client_window, 0, 0, real_rect.right - real_rect.left, real_rect.bottom - real_rect.top);
     }else if(data->fs_hack && (!fs_hack_enabled(monitor) ||
             !fs_hack_matches_current_mode(monitor,
                 window_rect->right - window_rect->left,
@@ -2672,7 +2672,7 @@ BOOL CDECL X11DRV_WindowPosChanging( HWND hwnd, HWND insert_after, UINT swp_flag
                     window_rect->right - window_rect->left,
                     window_rect->bottom - window_rect->top);
         if(data->client_window){
-            XMoveResizeWindow(data->display, data->client_window,
+            XMoveResizeWindow(gdi_display, data->client_window,
                     data->client_rect.left - data->whole_rect.left,
                     data->client_rect.top - data->whole_rect.top,
                     data->client_rect.right - data->client_rect.left,
From 4640b0cc2479c0a78e151bd0459d3ffa160ca73b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 26 Feb 2021 17:34:56 +0100
Subject: [PATCH] HACK: fshack: winex11.drv: Simply scale offscreen vulkan
 surfaces.

They will be copied manually onto the screen, so we don't need to scale
them to the screen dimensions.

CW-Bug-Id: 16608
---
 dlls/winex11.drv/vulkan.c | 34 +++++++++++++++++++++++++++++++++-
 1 file changed, 33 insertions(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index 6bfbb9dc7bc..1afb62c0b7d 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -854,7 +854,7 @@ static VkBool32 X11DRV_query_fs_hack(VkSurfaceKHR surface, VkExtent2D *real_sz,
     }

     monitor = fs_hack_monitor_from_hwnd(hwnd);
-    if(fs_hack_enabled(monitor)){
+    if(fs_hack_enabled(monitor) && !x11_surface->offscreen){
         RECT real_rect = fs_hack_real_mode(monitor);
         RECT user_rect = fs_hack_current_mode(monitor);
         SIZE scaled = fs_hack_get_scaled_screen_size(monitor);
@@ -886,6 +886,38 @@ static VkBool32 X11DRV_query_fs_hack(VkSurfaceKHR surface, VkExtent2D *real_sz,
             dst_blit->extent.height = scaled.cy;
         }

+        if (filter)
+            *filter = fs_hack_is_integer() ? VK_FILTER_NEAREST : VK_FILTER_LINEAR;
+
+        return VK_TRUE;
+    }
+    else if (fs_hack_enabled(monitor))
+    {
+        double scale = fs_hack_get_user_to_real_scale( monitor );
+        RECT client_rect;
+
+        GetClientRect( hwnd, &client_rect );
+
+        if (real_sz)
+        {
+            real_sz->width = (client_rect.right - client_rect.left) * scale;
+            real_sz->height = (client_rect.bottom - client_rect.top) * scale;
+        }
+
+        if (user_sz)
+        {
+            user_sz->width = client_rect.right - client_rect.left;
+            user_sz->height = client_rect.bottom - client_rect.top;
+        }
+
+        if (dst_blit)
+        {
+            dst_blit->offset.x = client_rect.left * scale;
+            dst_blit->offset.y = client_rect.top * scale;
+            dst_blit->extent.width = (client_rect.right - client_rect.left) * scale;
+            dst_blit->extent.height = (client_rect.bottom - client_rect.top) * scale;
+        }
+
         if(filter)
             *filter = fs_hack_is_integer() ? VK_FILTER_NEAREST : VK_FILTER_LINEAR;

From 65ee4143317ed95b33ee67a9714b1269de7dc17e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 25 Feb 2021 19:12:10 +0100
Subject: [PATCH] HACK: fshack: winex11.drv: Resize child window client_windows
 too.

CW-Bug-Id: 16608
---
 dlls/winex11.drv/display.c | 40 ++++++++++++++++++++++++++++++++++++++
 dlls/winex11.drv/window.c  |  2 ++
 dlls/winex11.drv/x11drv.h  |  1 +
 3 files changed, 43 insertions(+)

diff --git a/dlls/winex11.drv/display.c b/dlls/winex11.drv/display.c
index cf638ff43a0..56a0bf35070 100644
--- a/dlls/winex11.drv/display.c
+++ b/dlls/winex11.drv/display.c
@@ -308,6 +308,44 @@ void X11DRV_DisplayDevices_RegisterEventHandlers(void)
         handler->register_event_handlers();
 }

+BOOL CALLBACK fs_hack_update_child_window_client_surface(HWND hwnd, LPARAM enable_fs_hack)
+{
+    struct x11drv_win_data *data;
+    RECT client_rect;
+
+    if (!(data = get_win_data( hwnd )))
+        return TRUE;
+
+    if (enable_fs_hack && data->client_window)
+    {
+        client_rect = data->client_rect;
+        ClientToScreen( hwnd, (POINT *)&client_rect.left );
+        ClientToScreen( hwnd, (POINT *)&client_rect.right );
+        fs_hack_rect_user_to_real( &client_rect );
+
+        FIXME( "Enabling child fshack, resizing window %p to %s.\n", hwnd, wine_dbgstr_rect( &client_rect ) );
+        XMoveResizeWindow( gdi_display, data->client_window,
+                           client_rect.left, client_rect.top,
+                           client_rect.right - client_rect.left,
+                           client_rect.bottom - client_rect.top );
+        data->fs_hack = TRUE;
+    }
+    else if (!enable_fs_hack && data->client_window)
+    {
+        FIXME( "Disabling child fshack, restoring window %p.\n", hwnd );
+        XMoveResizeWindow( gdi_display, data->client_window,
+                           data->client_rect.left - data->whole_rect.left,
+                           data->client_rect.top - data->whole_rect.top,
+                           data->client_rect.right - data->client_rect.left,
+                           data->client_rect.bottom - data->client_rect.top );
+        data->fs_hack = FALSE;
+    }
+
+    if (data->client_window) sync_gl_drawable( hwnd, TRUE );
+    release_win_data( data );
+    return TRUE;
+}
+
 static BOOL CALLBACK update_windows_on_display_change(HWND hwnd, LPARAM lparam)
 {
     struct x11drv_win_data *data;
@@ -342,6 +380,7 @@ static BOOL CALLBACK update_windows_on_display_change(HWND hwnd, LPARAM lparam)
                 XMoveResizeWindow(gdi_display, data->client_window, 0, 0, width, height);
             sync_gl_drawable(hwnd, FALSE);
             update_net_wm_states( data );
+            EnumChildWindows( hwnd, fs_hack_update_child_window_client_surface, TRUE );
         }
     } else {
         /* update the full screen state */
@@ -373,6 +412,7 @@ static BOOL CALLBACK update_windows_on_display_change(HWND hwnd, LPARAM lparam)
                         data->client_rect.bottom - data->client_rect.top);
             }
             sync_gl_drawable(hwnd, FALSE);
+            EnumChildWindows( hwnd, fs_hack_update_child_window_client_surface, FALSE );
         }
     }
     release_win_data(data);
diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index e785e0c0563..4cd2324bff2 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -2660,6 +2660,7 @@ BOOL CDECL X11DRV_WindowPosChanging( HWND hwnd, HWND insert_after, UINT swp_flag
             XMoveResizeWindow(data->display, data->whole_window, tl.x, tl.y, real_rect.right - real_rect.left, real_rect.bottom - real_rect.top);
         if(data->client_window)
             XMoveResizeWindow(gdi_display, data->client_window, 0, 0, real_rect.right - real_rect.left, real_rect.bottom - real_rect.top);
+        EnumChildWindows( hwnd, fs_hack_update_child_window_client_surface, TRUE );
     }else if(data->fs_hack && (!fs_hack_enabled(monitor) ||
             !fs_hack_matches_current_mode(monitor,
                 window_rect->right - window_rect->left,
@@ -2678,6 +2679,7 @@ BOOL CDECL X11DRV_WindowPosChanging( HWND hwnd, HWND insert_after, UINT swp_flag
                     data->client_rect.right - data->client_rect.left,
                     data->client_rect.bottom - data->client_rect.top);
         }
+        EnumChildWindows( hwnd, fs_hack_update_child_window_client_surface, FALSE );
     }

     /* check if we need to switch the window to managed */
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 3e162382975..4e7d602ee73 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -691,6 +691,7 @@ extern void fs_hack_init(void) DECLSPEC_HIDDEN;
 extern const float *fs_hack_get_gamma_ramp(LONG *serial);
 extern void fs_hack_set_gamma_ramp(const WORD *ramp);
 extern int mode_compare(const void *p1, const void *p2) DECLSPEC_HIDDEN;
+BOOL CALLBACK fs_hack_update_child_window_client_surface(HWND hwnd, LPARAM enable_fs_hack) DECLSPEC_HIDDEN;

 static inline void mirror_rect( const RECT *window_rect, RECT *rect )
 {
From b7eccbd7f418ad20822b5113277963e001368640 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 17 May 2021 10:54:27 +0200
Subject: [PATCH] HACK: fshack: winex11.drv: Transform X11DRV_FLUSH_VK_DRAWABLE
 rects.

CW-Bug-Id: #16608
---
 dlls/winex11.drv/init.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/dlls/winex11.drv/init.c b/dlls/winex11.drv/init.c
index 8f152eedc69..095a3778089 100644
--- a/dlls/winex11.drv/init.c
+++ b/dlls/winex11.drv/init.c
@@ -227,13 +227,15 @@ static INT CDECL X11DRV_ExtEscape( PHYSDEV dev, INT escape, INT in_count, LPCVOI
                 {
                     const struct x11drv_escape_present_drawable *data = in_data;
                     RECT rect = physDev->dc_rect;
+                    RECT real_rect = physDev->dc_rect;

+                    fs_hack_rect_user_to_real( &real_rect );
                     OffsetRect( &rect, -physDev->dc_rect.left, -physDev->dc_rect.top );
                     if (data->flush) XFlush( gdi_display );
                     XSetFunction( gdi_display, physDev->gc, GXcopy );
                     XCopyArea( gdi_display, data->drawable, physDev->drawable, physDev->gc,
-                               0, 0, rect.right, rect.bottom,
-                               physDev->dc_rect.left, physDev->dc_rect.top );
+                               0, 0, real_rect.right - real_rect.left, real_rect.bottom - real_rect.top,
+                               real_rect.left, real_rect.top );
                     add_device_bounds( physDev, &rect );
                     return TRUE;
                 }
From 9e86e5142b754c7265fb505ea1208e3b2d34a23e Mon Sep 17 00:00:00 2001
From: Brendan Shanks <bshanks@codeweavers.com>
Date: Sat, 11 Dec 2021 12:38:26 +0100
Subject: [PATCH] HACK: winevulkan: Add vkGetPhysicalDeviceProperties thunks to
 fake NVIDIA PCI IDs as AMD

Needed for RDR2 with NVIDIA cards, otherwise game crashes or gets stuck
trying to load nvapi64.dll
---
 dlls/winevulkan/loader.c        | 48 +++++++++++++++++++++++++++++++++
 dlls/winevulkan/make_vulkan     |  1 +
 dlls/winevulkan/vulkan_loader.h |  3 +++
 3 files changed, 52 insertions(+)

diff --git a/dlls/winevulkan/loader.c b/dlls/winevulkan/loader.c
index 0b2c4241f75..d3ac9f57763 100644
--- a/dlls/winevulkan/loader.c
+++ b/dlls/winevulkan/loader.c
@@ -368,6 +368,30 @@ static void fill_luid_property(VkPhysicalDeviceProperties2 *properties2)
             id->deviceNodeMask);
 }

+void WINAPI vkGetPhysicalDeviceProperties(VkPhysicalDevice physical_device,
+        VkPhysicalDeviceProperties *properties)
+{
+    struct vkGetPhysicalDeviceProperties_params params;
+
+    TRACE("%p, %p\n", physical_device, properties);
+
+    params.physicalDevice = physical_device;
+    params.pProperties = properties;
+    vk_unix_call(unix_vkGetPhysicalDeviceProperties, &params);
+
+    {
+        const char *sgi = getenv("WINE_HIDE_NVIDIA_GPU");
+        if (sgi && *sgi != '0')
+        {
+            if (properties->vendorID == 0x10de /* NVIDIA */)
+            {
+                properties->vendorID = 0x1002; /* AMD */
+                properties->deviceID = 0x67df; /* RX 480 */
+            }
+        }
+    }
+}
+
 void WINAPI vkGetPhysicalDeviceProperties2(VkPhysicalDevice phys_dev,
         VkPhysicalDeviceProperties2 *properties2)
 {
@@ -379,6 +403,18 @@ void WINAPI vkGetPhysicalDeviceProperties2(VkPhysicalDevice phys_dev,
     params.pProperties = properties2;
     vk_unix_call(unix_vkGetPhysicalDeviceProperties2, &params);
     fill_luid_property(properties2);
+
+    {
+        const char *sgi = getenv("WINE_HIDE_NVIDIA_GPU");
+        if (sgi && *sgi != '0')
+        {
+            if (properties2->properties.vendorID == 0x10de /* NVIDIA */)
+            {
+                properties2->properties.vendorID = 0x1002; /* AMD */
+                properties2->properties.deviceID = 0x67df; /* RX 480 */
+            }
+        }
+    }
 }

 void WINAPI vkGetPhysicalDeviceProperties2KHR(VkPhysicalDevice phys_dev,
@@ -392,6 +428,18 @@ void WINAPI vkGetPhysicalDeviceProperties2KHR(VkPhysicalDevice phys_dev,
     params.pProperties = properties2;
     vk_unix_call(unix_vkGetPhysicalDeviceProperties2KHR, &params);
     fill_luid_property(properties2);
+
+    {
+        const char *sgi = getenv("WINE_HIDE_NVIDIA_GPU");
+        if (sgi && *sgi != '0')
+        {
+            if (properties2->properties.vendorID == 0x10de /* NVIDIA */)
+            {
+                properties2->properties.vendorID = 0x1002; /* AMD */
+                properties2->properties.deviceID = 0x67df; /* RX 480 */
+            }
+        }
+    }
 }

 static BOOL WINAPI call_vulkan_debug_report_callback( struct wine_vk_debug_report_params *params, ULONG size )
diff --git a/dlls/winevulkan/vulkan_loader.h b/dlls/winevulkan/vulkan_loader.h
index 05913756fbc..275242657e3 100644
--- a/dlls/winevulkan/vulkan_loader.h
+++ b/dlls/winevulkan/vulkan_loader.h
@@ -20,6 +20,9 @@
 #ifndef __WINE_VULKAN_LOADER_H
 #define __WINE_VULKAN_LOADER_H

+#include <stdarg.h>
+#include <stdlib.h>
+
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include <stdarg.h>
From b3f1bd23771192f136ed9b4f93a1f4b6087611a0 Mon Sep 17 00:00:00 2001
From: Thomas Crider <gloriouseggroll@gmail.com>
Date: Sat, 19 Feb 2022 01:55:40 -0700
Subject: [PATCH] revert 656edbb and 587f377 to retain fshack compat patch
 compatibility

---
 dlls/win32u/win32u_private.h |   2 +-
 dlls/win32u/sysparams.c      |  14 ++---
 dlls/winex11.drv/Makefile.in |   2 +-
 dlls/winex11.drv/display.c   | 109 ++++++++++++++++++++++++++++++++++-
 include/ntuser.h             |   2 -
 5 files changed, 112 insertions(+), 17 deletions(-)

diff --git a/dlls/win32u/win32u_private.h b/dlls/win32u/win32u_private.h
--- a/dlls/win32u/win32u_private.h
+++ b/dlls/win32u/win32u_private.h
@@ -1474,7 +1474,7 @@ RECT get_display_rect( const WCHAR *display )
 extern RECT get_display_rect( const WCHAR *display ) DECLSPEC_HIDDEN;
 extern UINT get_monitor_dpi( HMONITOR monitor ) DECLSPEC_HIDDEN;
 extern UINT get_win_monitor_dpi( HWND hwnd ) DECLSPEC_HIDDEN;
-extern RECT get_primary_monitor_rect( UINT dpi ) DECLSPEC_HIDDEN;
+extern RECT get_primary_monitor_rect(void) DECLSPEC_HIDDEN;
 extern UINT get_system_dpi(void) DECLSPEC_HIDDEN;
 extern int get_system_metrics( int index ) DECLSPEC_HIDDEN;
 extern UINT get_thread_dpi(void) DECLSPEC_HIDDEN;
diff --git a/dlls/win32u/sysparams.c b/dlls/win32u/sysparams.c
index 58bd22a3adf..7af1e20f008 100644
--- a/dlls/win32u/sysparams.c
+++ b/dlls/win32u/sysparams.c
@@ -1474,7 +1474,7 @@ RECT get_display_rect( const WCHAR *display )
     return map_dpi_rect( rect, system_dpi, get_thread_dpi() );
 }

-RECT get_primary_monitor_rect( UINT dpi )
+RECT get_primary_monitor_rect(void)
 {
     struct monitor *monitor;
     RECT rect = {0};
@@ -1489,7 +1489,7 @@ static RECT get_primary_monitor_rect( UINT dpi )
     }

     unlock_display_devices();
-    return map_dpi_rect( rect, system_dpi, dpi );
+    return map_dpi_rect( rect, system_dpi, get_thread_dpi() );
 }

 /**********************************************************************
@@ -4203,10 +4203,10 @@ int get_system_metrics( int index )
     case SM_MOUSEWHEELPRESENT:
         return 1;
     case SM_CXSCREEN:
-        rect = get_primary_monitor_rect( get_thread_dpi() );
+        rect = get_primary_monitor_rect();
         return rect.right - rect.left;
     case SM_CYSCREEN:
-        rect = get_primary_monitor_rect( get_thread_dpi() );
+        rect = get_primary_monitor_rect();
         return rect.bottom - rect.top;
     case SM_XVIRTUALSCREEN:
         rect = get_virtual_screen_rect( get_thread_dpi() );
@@ -4528,18 +4528,12 @@ ULONG_PTR WINAPI NtUserCallOneParam( ULONG_PTR arg, ULONG code )
         return get_sys_color( arg );
     case NtUserRealizePalette:
         return realize_palette( UlongToHandle(arg) );
-    case NtUserGetPrimaryMonitorRect:
-        *(RECT *)arg = get_primary_monitor_rect( 0 );
-        return 1;
     case NtUserGetSysColorBrush:
         return HandleToUlong( get_sys_color_brush(arg) );
     case NtUserGetSysColorPen:
         return HandleToUlong( get_sys_color_pen(arg) );
     case NtUserGetSystemMetrics:
         return get_system_metrics( arg );
-    case NtUserGetVirtualScreenRect:
-        *(RECT *)arg = get_virtual_screen_rect( 0 );
-        return 1;
     case NtUserMessageBeep:
         return message_beep( arg );
     /* temporary exports */
diff --git a/dlls/win32u/window.c b/dlls/win32u/window.c
--- a/dlls/win32u/window.c
+++ b/dlls/win32u/window.c
@@ -1074,7 +1074,7 @@ BOOL get_window_rects( HWND hwnd, enum coords_relative relative, RECT *window_rect,
         }
         else
         {
-            rect = get_primary_monitor_rect( dpi );
+            rect = get_primary_monitor_rect();
         }
         if (window_rect) *window_rect = rect;
         if (client_rect) *client_rect = rect;
@@ -1593,7 +1593,7 @@ static RECT get_maximized_work_rect( HWND hwnd )
     if ((get_window_long( hwnd, GWL_STYLE ) & (WS_MINIMIZE | WS_MAXIMIZE)) == WS_MAXIMIZE)
     {
         if (!get_work_rect( hwnd, &work_rect ))
-            work_rect = get_primary_monitor_rect( get_thread_dpi() );
+            work_rect = get_primary_monitor_rect();
     }
     return work_rect;
 }
@@ -3334,7 +3334,7 @@ static MINMAXINFO get_min_max_info( HWND hwnd )

     if (get_work_rect( hwnd, &rc_work ))
     {
-        rc_primary = get_primary_monitor_rect( get_thread_dpi() );
+        rc_primary = get_primary_monitor_rect();
         if (minmax.ptMaxSize.x == (rc_primary.right - rc_primary.left) + 2 * xinc &&
             minmax.ptMaxSize.y == (rc_primary.bottom - rc_primary.top) + 2 * yinc)
         {
diff --git a/dlls/winex11.drv/Makefile.in b/dlls/winex11.drv/Makefile.in
index 93a975d7f63..64df2075cc4 100644
--- a/dlls/winex11.drv/Makefile.in
+++ b/dlls/winex11.drv/Makefile.in
@@ -1,6 +1,6 @@
 EXTRADEFS = -DWINE_NO_LONG_TYPES
 MODULE    = winex11.drv
-IMPORTS   = uuid user32 gdi32 advapi32 win32u
+IMPORTS   = uuid setupapi rpcrt4 user32 gdi32 advapi32 win32u
 DELAYIMPORTS = comctl32 ole32 shell32 imm32
 EXTRAINCL = $(X_CFLAGS)
 EXTRALIBS = $(X_LIBS) $(X_EXTRA_LIBS)
diff --git a/dlls/winex11.drv/display.c b/dlls/winex11.drv/display.c
index ab5dcdac23f..04380ff660f 100644
--- a/dlls/winex11.drv/display.c
+++ b/dlls/winex11.drv/display.c
@@ -19,14 +19,53 @@
  */

 #include "config.h"
-#include "x11drv.h"
+
+#include <stdarg.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "rpc.h"
+#include "winreg.h"
+#include "cfgmgr32.h"
+#include "initguid.h"
+#include "devguid.h"
+#include "devpkey.h"
+#include "ntddvdeo.h"
+#include "setupapi.h"
+#define WIN32_NO_STATUS
+#include "winternl.h"
 #include "wine/debug.h"
+#include "wine/unicode.h"
+#include "x11drv.h"

 WINE_DEFAULT_DEBUG_CHANNEL(x11drv);

+/* Wine specific properties */
+DEFINE_DEVPROPKEY(WINE_DEVPROPKEY_MONITOR_RCMONITOR, 0x233a9ef3, 0xafc4, 0x4abd, 0xb5, 0x64, 0xc3, 0x2f, 0x21, 0xf1, 0x53, 0x5b, 3);
+
+static const WCHAR displayW[] = {'D','I','S','P','L','A','Y',0};
+static const WCHAR video_keyW[] = {
+    'H','A','R','D','W','A','R','E','\\',
+    'D','E','V','I','C','E','M','A','P','\\',
+    'V','I','D','E','O',0};
+
 static struct x11drv_display_device_handler host_handler;
 struct x11drv_display_device_handler desktop_handler;

+/* Cached screen information, protected by screen_section */
+static HKEY video_key;
+static RECT virtual_screen_rect;
+static RECT primary_monitor_rect;
+static FILETIME last_query_screen_time;
+static CRITICAL_SECTION screen_section;
+static CRITICAL_SECTION_DEBUG screen_critsect_debug =
+{
+    0, 0, &screen_section,
+    {&screen_critsect_debug.ProcessLocksList, &screen_critsect_debug.ProcessLocksList},
+     0, 0, {(DWORD_PTR)(__FILE__ ": screen_section")}
+};
+static CRITICAL_SECTION screen_section = {&screen_critsect_debug, -1, 0, 0, 0, 0};
+
 HANDLE get_display_device_init_mutex(void)
 {
     static const WCHAR init_mutexW[] = {'d','i','s','p','l','a','y','_','d','e','v','i','c','e','_','i','n','i','t',0};
@@ -42,6 +81,62 @@ void release_display_device_init_mutex(HANDLE mutex)
     CloseHandle(mutex);
 }

+/* Update screen rectangle cache from SetupAPI if it's outdated, return FALSE on failure and TRUE on success */
+static BOOL update_screen_cache(void)
+{
+    RECT virtual_rect = {0}, primary_rect = {0}, monitor_rect;
+    SP_DEVINFO_DATA device_data = {sizeof(device_data)};
+    HDEVINFO devinfo = INVALID_HANDLE_VALUE;
+    FILETIME filetime = {0};
+    HANDLE mutex = NULL;
+    DWORD i = 0;
+    INT result;
+    DWORD type;
+    BOOL ret = FALSE;
+
+    EnterCriticalSection(&screen_section);
+    if ((!video_key && RegOpenKeyW(HKEY_LOCAL_MACHINE, video_keyW, &video_key))
+        || RegQueryInfoKeyW(video_key, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, &filetime))
+    {
+        LeaveCriticalSection(&screen_section);
+        return FALSE;
+    }
+    result = CompareFileTime(&filetime, &last_query_screen_time);
+    LeaveCriticalSection(&screen_section);
+    if (result < 1)
+        return TRUE;
+
+    mutex = get_display_device_init_mutex();
+
+    devinfo = SetupDiGetClassDevsW(&GUID_DEVCLASS_MONITOR, displayW, NULL, DIGCF_PRESENT);
+    if (devinfo == INVALID_HANDLE_VALUE)
+        goto fail;
+
+    while (SetupDiEnumDeviceInfo(devinfo, i++, &device_data))
+    {
+        if (!SetupDiGetDevicePropertyW(devinfo, &device_data, &WINE_DEVPROPKEY_MONITOR_RCMONITOR, &type,
+                                       (BYTE *)&monitor_rect, sizeof(monitor_rect), NULL, 0))
+            goto fail;
+
+        UnionRect(&virtual_rect, &virtual_rect, &monitor_rect);
+        if (i == 1)
+            primary_rect = monitor_rect;
+    }
+
+    EnterCriticalSection(&screen_section);
+    virtual_screen_rect = virtual_rect;
+    primary_monitor_rect = primary_rect;
+    last_query_screen_time = filetime;
+    LeaveCriticalSection(&screen_section);
+    ret = TRUE;
+fail:
+    SetupDiDestroyDeviceInfoList(devinfo);
+    release_display_device_init_mutex(mutex);
+    if (!ret)
+        WARN("Update screen cache failed!\n");
+    return ret;
+}
+
 POINT virtual_screen_to_root(INT x, INT y)
 {
     RECT virtual = get_virtual_screen_rect();
@@ -65,14 +160,22 @@ POINT root_to_virtual_screen(INT x, INT y)
 RECT get_virtual_screen_rect(void)
 {
     RECT virtual;
-    NtUserCallOneParam( (UINT_PTR)&virtual, NtUserGetVirtualScreenRect );
+
+    update_screen_cache();
+    EnterCriticalSection(&screen_section);
+    virtual = virtual_screen_rect;
+    LeaveCriticalSection(&screen_section);
     return virtual;
 }

 RECT get_primary_monitor_rect(void)
 {
     RECT primary;
-    NtUserCallOneParam( (UINT_PTR)&primary, NtUserGetPrimaryMonitorRect );
+
+    update_screen_cache();
+    EnterCriticalSection(&screen_section);
+    primary = primary_monitor_rect;
+    LeaveCriticalSection(&screen_section);
     return primary;
 }

diff --git a/include/ntuser.h b/include/ntuser.h
index b7e2e63dcb3..51f1c624ba6 100644
--- a/include/ntuser.h
+++ b/include/ntuser.h
@@ -75,12 +75,10 @@ enum
     NtUserGetClipCursor,
     NtUserGetCursorPos,
     NtUserGetIconParam,
-    NtUserGetPrimaryMonitorRect,
     NtUserGetSysColor,
     NtUserGetSysColorBrush,
     NtUserGetSysColorPen,
     NtUserGetSystemMetrics,
-    NtUserGetVirtualScreenRect,
     NtUserMessageBeep,
     NtUserRealizePalette,
     /* temporary exports */
--
2.34.1

From 398e397881820bff2add3dd68f1bbc4207294318 Mon Sep 17 00:00:00 2001
From: Brendan Shanks <bshanks@codeweavers.com>
Date: Wed, 15 Jul 2020 11:25:13 -0700
Subject: [PATCH] HACK: winex11: Support faking AMD PCI IDs for NVIDIA cards

---
 dlls/winex11.drv/display.c | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/dlls/winex11.drv/display.c b/dlls/winex11.drv/display.c
index 56a0bf35070..b3ed448c43f 100644
--- a/dlls/winex11.drv/display.c
+++ b/dlls/winex11.drv/display.c
@@ -21,6 +21,7 @@
 #include "config.h"

 #include <stdarg.h>
+#include <stdlib.h>

 #include "windef.h"
 #include "winbase.h"
@@ -474,6 +475,18 @@ void CDECL X11DRV_UpdateDisplayDevices( const struct gdi_device_manager *device_

     for (gpu = 0; gpu < gpu_count; gpu++)
     {
+        {
+            const char *sgi = getenv("WINE_HIDE_NVIDIA_GPU");
+            if (sgi && *sgi != '0')
+            {
+                if (gpus[gpu].vendor_id == 0x10de /* NVIDIA */)
+                {
+                    gpus[gpu].vendor_id = 0x1002; /* AMD */
+                    gpus[gpu].device_id = 0x67df; /* RX 480 */
+                }
+            }
+        }
+
         device_manager->add_gpu( &gpus[gpu], param );

         /* Initialize adapters */
diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index f584330dc6e..3efdcb4c88c 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -169,6 +169,7 @@ FUNCTION_OVERRIDES = {
     "vkGetPhysicalDeviceExternalFenceProperties" : {"dispatch" : False, "driver" : False, "thunk" : ThunkType.NONE},
     "vkGetPhysicalDeviceExternalSemaphoreProperties" : {"dispatch" : False, "driver" : False, "thunk" : ThunkType.NONE},
     "vkGetPhysicalDeviceImageFormatProperties2" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.PRIVATE},
+    "vkGetPhysicalDeviceProperties" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.PUBLIC, "loader_thunk" : ThunkType.PRIVATE},
     "vkGetPhysicalDeviceProperties2" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.PUBLIC, "loader_thunk" : ThunkType.PRIVATE},
     "vkGetPhysicalDeviceProperties2KHR" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.PUBLIC, "loader_thunk" : ThunkType.PRIVATE},

From f649de43236f67943a44ae89dfbbd3d4c7d9eeb4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 17 Dec 2020 18:47:44 +0100
Subject: [PATCH] HACK: steam: winex11.drv: Check Steam overlay presence and
 drop events when enabled.

---
 dlls/winex11.drv/event.c       | 7 ++++++-
 dlls/winex11.drv/x11drv.h      | 1 +
 dlls/winex11.drv/x11drv_main.c | 5 +++++
 3 files changed, 12 insertions(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index 89a9974529b..baec41d0296 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -433,13 +433,18 @@ static BOOL process_events( Display *display, Bool (*filter)(Display*, XEvent*,X
 {
     XEvent event, prev_event;
     int count = 0;
-    BOOL queued = FALSE;
+    BOOL queued = FALSE, overlay_enabled = FALSE;
     enum event_merge_action action = MERGE_DISCARD;
+    ULONG_PTR overlay_filter = QS_KEY | QS_MOUSEBUTTON | QS_MOUSEMOVE;
+
+    if (WaitForSingleObject(steam_overlay_event, 0) == WAIT_OBJECT_0)
+        overlay_enabled = TRUE;

     prev_event.type = 0;
     while (XCheckIfEvent( display, &event, filter, (char *)arg ))
     {
         count++;
+        if (overlay_enabled && filter_event( display, &event, (char *)overlay_filter )) continue;
         if (XFilterEvent( &event, None ))
         {
             /*
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 147087e3220..e4164eba5d2 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -412,6 +412,7 @@ extern int xrender_error_base DECLSPEC_HIDDEN;
 extern HMODULE x11drv_module DECLSPEC_HIDDEN;
 extern char *process_name DECLSPEC_HIDDEN;
 extern Display *clipboard_display DECLSPEC_HIDDEN;
+extern HANDLE steam_overlay_event DECLSPEC_HIDDEN;

 /* atoms */

diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index f23ce260a7f..17d80458c54 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -90,6 +90,7 @@ DWORD thread_data_tls_index = TLS_OUT_OF_INDEXES;
 int xrender_error_base = 0;
 HMODULE x11drv_module = 0;
 char *process_name = NULL;
+HANDLE steam_overlay_event;

 static x11drv_error_callback err_callback;   /* current callback for error */
 static Display *err_callback_display;        /* display callback is set for */
@@ -738,6 +739,10 @@ BOOL WINAPI DllMain( HINSTANCE hinst, DWORD reason, LPVOID reserved )
         DisableThreadLibraryCalls( hinst );
         x11drv_module = hinst;
         ret = process_attach();
+        steam_overlay_event = CreateEventA(NULL, TRUE, FALSE, "__wine_steamclient_GameOverlayActivated");
+        break;
+    case DLL_PROCESS_DETACH:
+        CloseHandle(steam_overlay_event);
         break;
     }
     return ret;
From 4a40cbd45d370563da0717f965ea19f8016c401f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 11 Oct 2021 10:48:49 +0200
Subject: [PATCH] HACK: steam: xinput1_3: Check Steam overlay presence and
 disconnect controllers when enabled.

---
 dlls/xinput1_3/main.c | 12 +++++++++---
 1 file changed, 9 insertions(+), 3 deletions(-)

diff --git a/dlls/xinput1_3/main.c b/dlls/xinput1_3/main.c
index 506802d142a..cd273c5dd16 100644
--- a/dlls/xinput1_3/main.c
+++ b/dlls/xinput1_3/main.c
@@ -124,6 +124,7 @@ static HANDLE start_event;
 static HANDLE stop_event;
 static HANDLE done_event;
 static HANDLE update_event;
+static HANDLE steam_overlay_event;

 static BOOL find_opened_device(SP_DEVICE_INTERFACE_DETAIL_DATA_W *detail, int *free_slot)
 {
@@ -528,6 +529,7 @@ static void stop_update_thread(void)
     CloseHandle(stop_event);
     CloseHandle(done_event);
     CloseHandle(update_event);
+    CloseHandle(steam_overlay_event);

     for (i = 0; i < XUSER_MAX_COUNT; i++) controller_destroy(&controllers[i], FALSE);
 }
@@ -717,6 +719,8 @@ static BOOL WINAPI start_update_thread_once( INIT_ONCE *once, void *param, void
 {
     HANDLE thread;

+    steam_overlay_event = CreateEventA(NULL, TRUE, FALSE, "__wine_steamclient_GameOverlayActivated");
+
     start_event = CreateEventA(NULL, FALSE, FALSE, NULL);
     if (!start_event) ERR("failed to create start event, error %u\n", GetLastError());

@@ -811,7 +815,8 @@ DWORD WINAPI DECLSPEC_HOTPATCH XInputSetState(DWORD index, XINPUT_VIBRATION *vib
     if (index >= XUSER_MAX_COUNT) return ERROR_BAD_ARGUMENTS;
     if (!controller_lock(&controllers[index])) return ERROR_DEVICE_NOT_CONNECTED;

-    ret = HID_set_state(&controllers[index], vibration);
+    if (WaitForSingleObject(steam_overlay_event, 0) == WAIT_OBJECT_0) ret = ERROR_SUCCESS;
+    else ret = HID_set_state(&controllers[index], vibration);

     controller_unlock(&controllers[index]);

@@ -829,7 +834,9 @@ static DWORD xinput_get_state(DWORD index, XINPUT_STATE *state)
     if (index >= XUSER_MAX_COUNT) return ERROR_BAD_ARGUMENTS;
     if (!controller_lock(&controllers[index])) return ERROR_DEVICE_NOT_CONNECTED;

-    *state = controllers[index].state;
+    if (WaitForSingleObject(steam_overlay_event, 0) == WAIT_OBJECT_0) memset(state, 0, sizeof(*state));
+    else *state = controllers[index].state;
+
     controller_unlock(&controllers[index]);

     return ERROR_SUCCESS;
@@ -1075,7 +1082,6 @@ DWORD WINAPI DECLSPEC_HOTPATCH XInputGetCapabilities(DWORD index, DWORD flags, X
     start_update_thread();

     if (index >= XUSER_MAX_COUNT) return ERROR_BAD_ARGUMENTS;
-
     if (!controller_lock(&controllers[index])) return ERROR_DEVICE_NOT_CONNECTED;

     if (flags & XINPUT_FLAG_GAMEPAD && controllers[index].caps.SubType != XINPUT_DEVSUBTYPE_GAMEPAD)
From 34007908d03fc78d14087772f32c4a5a4be217ba Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Sat, 9 Jan 2021 20:11:52 +0100
Subject: [PATCH] HACK: steam: dinput: Check Steam overlay presence and clear
 device state when enabled.

CW-Bug-Id: #20083
---
 dlls/dinput/dinput_main.c    |  4 ++++
 dlls/dinput/dinput_private.h |  1 +
 dlls/dinput/joystick_hid.c   | 19 +++++++++++++++++++
 3 files changed, 24 insertions(+)

diff --git a/dlls/dinput/dinput_main.c b/dlls/dinput/dinput_main.c
index 8347e3aa586..d1cd10fa04d 100644
--- a/dlls/dinput/dinput_main.c
+++ b/dlls/dinput/dinput_main.c
@@ -1424,6 +1424,8 @@ void check_dinput_events(void)
     MsgWaitForMultipleObjectsEx(0, NULL, 0, QS_ALLINPUT, 0);
 }

+HANDLE steam_overlay_event;
+
 BOOL WINAPI DllMain( HINSTANCE inst, DWORD reason, void *reserved )
 {
     TRACE( "inst %p, reason %lu, reserved %p.\n", inst, reason, reserved );
@@ -1432,6 +1434,7 @@ BOOL WINAPI DllMain( HINSTANCE inst, DWORD reason, void *reserved )
     {
       case DLL_PROCESS_ATTACH:
         DisableThreadLibraryCalls(inst);
+        steam_overlay_event = CreateEventA(NULL, TRUE, FALSE, "__wine_steamclient_GameOverlayActivated");
         DINPUT_instance = inst;
         register_di_em_win_class();
         break;
@@ -1476,6 +1479,7 @@ BOOL WINAPI DllMain( HINSTANCE inst, DWORD reason, LPVOID reserved)
         if (reserved) break;
         dinput_thread_stop();
         unregister_di_em_win_class();
+        CloseHandle(steam_overlay_event);
         break;
     }
     return TRUE;
diff --git a/dlls/dinput/dinput_private.h b/dlls/dinput/dinput_private.h
index 4b36a69c0e1..37d4a4a060a 100644
--- a/dlls/dinput/dinput_private.h
+++ b/dlls/dinput/dinput_private.h
@@ -48,6 +48,7 @@ struct IDirectInputImpl

 extern const IDirectInput7AVtbl dinput7_a_vtbl DECLSPEC_HIDDEN;
 extern const IDirectInput8AVtbl dinput8_a_vtbl DECLSPEC_HIDDEN;
+extern HANDLE steam_overlay_event DECLSPEC_HIDDEN;

 extern HRESULT mouse_enum_device( DWORD type, DWORD flags, DIDEVICEINSTANCEW *instance, DWORD version );
 extern HRESULT mouse_create_device( IDirectInputImpl *dinput, const GUID *guid, IDirectInputDevice8W **out );
diff --git a/dlls/dinput/joystick_hid.c b/dlls/dinput/joystick_hid.c
index 29d1de8b98e..1c17b786fb5 100644
--- a/dlls/dinput/joystick_hid.c
+++ b/dlls/dinput/joystick_hid.c
@@ -1092,6 +1092,7 @@ struct parse_device_state_params
 {
     BYTE old_state[DEVICE_STATE_MAX_SIZE];
     BYTE buttons[128];
+    BOOL reset_state;
     DWORD time;
     DWORD seq;
 };
@@ -1107,6 +1108,9 @@ static BOOL check_device_state_button( struct hid_joystick *impl, struct hid_val

     value = params->buttons[instance->wUsage - 1];
     old_value = params->old_state[instance->dwOfs];
+
+    if (params->reset_state) value = 0;
+
     impl->base.device_state[instance->dwOfs] = value;
     if (old_value != value)
         queue_event( iface, instance->dwType, value, params->time, params->seq );
@@ -1189,6 +1193,16 @@ static BOOL read_device_state_value( struct hid_joystick *impl, struct hid_value
     if (instance->dwType & DIDFT_AXIS) value = scale_axis_value( logical_value, properties );
     else value = scale_value( logical_value, properties );

+    if (params->reset_state)
+    {
+        if (instance->dwType & DIDFT_POV) value = -1;
+        else if (instance->dwType & DIDFT_AXIS)
+        {
+            if (!properties->range_min) value = properties->range_max / 2;
+            else value = round( (properties->range_min + properties->range_max) / 2.0 );
+        }
+    }
+
     old_value = *(LONG *)(params->old_state + instance->dwOfs);
     *(LONG *)(impl->base.device_state + instance->dwOfs) = value;
     if (old_value != value)
@@ -1233,6 +1247,11 @@ static HRESULT hid_joystick_read( IDirectInputDevice8W *iface )
         }
     }

+    if (WaitForSingleObject(steam_overlay_event, 0) == WAIT_OBJECT_0) /* steam overlay is enabled */
+        params.reset_state = TRUE;
+    else
+        params.reset_state = FALSE;
+
     EnterCriticalSection( &impl->base.crit );
     while (ret)
     {
From 714c65ccd3985c25b8f24bfbe8f34d5dba7305fd Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 1 Feb 2021 15:34:05 +0100
Subject: [PATCH] winex11.drv: Don't allow querying pointer while overlay is
 active.

---
 dlls/winex11.drv/mouse.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
index cb4363ae02e..0e13ce0e773 100644
--- a/dlls/winex11.drv/mouse.c
+++ b/dlls/winex11.drv/mouse.c
@@ -1553,6 +1553,8 @@ BOOL CDECL X11DRV_GetCursorPos(LPPOINT pos)
     unsigned int xstate;
     BOOL ret;

+    if (WaitForSingleObject(steam_overlay_event, 0) == WAIT_OBJECT_0) return FALSE;
+
     ret = XQueryPointer( display, root_window, &root, &child, &rootX, &rootY, &winX, &winY, &xstate );
     if (ret)
     {

From c5a21ea2930f5e391b62c492bdf3f2fd075f310d Mon Sep 17 00:00:00 2001
From: Giovanni Mascellani <gmascellani@codeweavers.com>
Date: Tue, 27 Apr 2021 10:51:12 +0200
Subject: [PATCH] HACK: winex11.drv: Fix drawing of layered windows with a
 client window.

CW-Bug-Id: #18807
---
 dlls/winex11.drv/event.c       |  5 ++++-
 dlls/winex11.drv/x11drv.h      |  2 ++
 dlls/winex11.drv/x11drv_main.c | 12 ++++++++++++
 3 files changed, 18 insertions(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index 5cb08de99eb..b0ef922ca5d 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -992,7 +992,10 @@ static BOOL X11DRV_Expose( HWND hwnd, XEvent *xev )
     rect.right  = pos.x + event->width;
     rect.bottom = pos.y + event->height;

-    if (event->window != data->client_window)
+    if (layered_window_client_hack && event->window == data->client_window)
+        OffsetRect( &rect, data->client_rect.left - data->whole_rect.left,
+                    data->client_rect.top - data->whole_rect.top );
+    if (layered_window_client_hack || event->window != data->client_window)
     {
         if (data->surface)
         {
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index fb4546e302c..ed4abd802c1 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -890,4 +890,6 @@ static inline BOOL is_window_rect_mapped( const RECT *rect )
             max( rect->bottom, rect->top + 1 ) > virtual_rect.top);
 }

+extern BOOL layered_window_client_hack;
+
 #endif  /* __WINE_X11DRV_H */
diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index 4e49de12138..a03eb52ad46 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -90,6 +90,7 @@ int xfixes_event_base = 0;
 HMODULE x11drv_module = 0;
 char *process_name = NULL;
 HANDLE steam_overlay_event;
+BOOL layered_window_client_hack = FALSE;

 static x11drv_error_callback err_callback;   /* current callback for error */
 static Display *err_callback_display;        /* display callback is set for */
@@ -713,6 +714,17 @@ static BOOL process_attach(void)

     fs_hack_init();

+    {
+        const char *sgi = getenv("SteamGameId");
+        const char *e = getenv("WINE_LAYERED_WINDOW_CLIENT_HACK");
+        layered_window_client_hack =
+            (sgi && (
+                strcmp(sgi, "435150") == 0 || /* Divinity: Original Sin 2 launcher */
+                strcmp(sgi, "227020") == 0 /* Rise of Venice launcher */
+            )) ||
+            (e && *e != '\0' && *e != '0');
+    }
+
     init_user_driver();
     X11DRV_DisplayDevices_Init(FALSE);
     return TRUE;
From c5aa20a70a5e681ba718feb7db9adc357cb7bec0 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 31 Aug 2021 00:41:15 +0300
Subject: [PATCH] winex11.drv: HACK: Mind insert_after X11DRV_WindowPosChanged
 in some cases.

Fixes FH4 rendering black window until focus is lost.

CW-Bug-Id: #19335
---
 dlls/winex11.drv/window.c | 51 ++++++++++++++++++++++++++++++++++-----
 1 file changed, 45 insertions(+), 6 deletions(-)

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 4cd2324bff2..815a6279e59 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -1481,17 +1481,18 @@ void X11DRV_X_to_window_rect( struct x11drv_win_data *data, RECT *rect, int x, i
  *
  * Synchronize the X window position with the Windows one
  */
-static void sync_window_position( struct x11drv_win_data *data,
+static HWND sync_window_position( struct x11drv_win_data *data,
                                   UINT swp_flags, const RECT *old_window_rect,
                                   const RECT *old_whole_rect, const RECT *old_client_rect )
 {
     DWORD style = GetWindowLongW( data->hwnd, GWL_STYLE );
     DWORD ex_style = GetWindowLongW( data->hwnd, GWL_EXSTYLE );
+    HWND prev_window = NULL;
     RECT original_rect = {0};
     XWindowChanges changes;
     unsigned int mask = 0;

-    if (data->managed && data->iconic) return;
+    if (data->managed && data->iconic) return NULL;

     /* resizing a managed maximized window is not allowed */
     if (!(style & WS_MAXIMIZE) || !data->managed)
@@ -1529,9 +1530,10 @@ static void sync_window_position( struct x11drv_win_data *data,
     {
         /* find window that this one must be after */
         HWND prev = GetWindow( data->hwnd, GW_HWNDPREV );
+
         while (prev && !(GetWindowLongW( prev, GWL_STYLE ) & WS_VISIBLE))
             prev = GetWindow( prev, GW_HWNDPREV );
-        if (!prev)  /* top child */
+        if (!(prev_window = prev))  /* top child */
         {
             changes.stack_mode = Above;
             mask |= CWStackMode;
@@ -1552,6 +1554,7 @@ static void sync_window_position( struct x11drv_win_data *data,
     update_net_wm_states( data );
     data->configure_serial = NextRequest( data->display );
     XReconfigureWMWindow( data->display, data->whole_window, data->vis.screen, mask, &changes );
+
     if (!IsRectEmpty( &original_rect ))
     {
         data->whole_rect = original_rect;
@@ -1577,6 +1580,8 @@ static void sync_window_position( struct x11drv_win_data *data,
            data->whole_rect.right - data->whole_rect.left,
            data->whole_rect.bottom - data->whole_rect.top,
            changes.sibling, mask, data->configure_serial );
+
+    return prev_window;
 }


@@ -2733,6 +2738,25 @@ BOOL CDECL X11DRV_WindowPosChanging( HWND hwnd, HWND insert_after, UINT swp_flag
 }


+static void restack_windows( struct x11drv_win_data *data, HWND prev )
+{
+    struct x11drv_win_data *prev_data;
+
+    TRACE("data->hwnd %p, prev %p.\n", data->hwnd, prev);
+
+    while (prev)
+    {
+        if (!(prev_data = get_win_data( prev ))) break;
+
+        TRACE( "Raising window %p.\n", prev );
+
+        if (prev_data->whole_window && data->display == prev_data->display)
+            XRaiseWindow( prev_data->display, prev_data->whole_window );
+        release_win_data( prev_data );
+        prev = GetWindow( prev, GW_HWNDPREV );
+    }
+}
+
 /***********************************************************************
  *		WindowPosChanged   (X11DRV.@)
  */
@@ -2745,6 +2769,7 @@ void CDECL X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags
     struct x11drv_win_data *data;
     DWORD new_style = GetWindowLongW( hwnd, GWL_STYLE );
     RECT old_window_rect, old_whole_rect, old_client_rect;
+    HWND prev_window = NULL;
     int event_type;

     if (!(data = get_win_data( hwnd ))) return;
@@ -2847,8 +2872,8 @@ void CDECL X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags

     /* don't change position if we are about to minimize or maximize a managed window */
     if ((!event_type || event_type == PropertyNotify) &&
-        !(data->managed && (swp_flags & SWP_STATECHANGED) && (new_style & (WS_MINIMIZE|WS_MAXIMIZE))))
-        sync_window_position( data, swp_flags, &old_window_rect, &old_whole_rect, &old_client_rect );
+            !(data->managed && (swp_flags & SWP_STATECHANGED) && (new_style & (WS_MINIMIZE|WS_MAXIMIZE))))
+        prev_window = sync_window_position( data, swp_flags, &old_window_rect, &old_whole_rect, &old_client_rect );

     if ((new_style & WS_VISIBLE) &&
         ((new_style & WS_MINIMIZE) || is_window_rect_mapped( rectWindow )))
@@ -2864,6 +2889,10 @@ void CDECL X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags
             release_win_data( data );
             if (needs_icon) fetch_icon_data( hwnd, 0, 0 );
             if (needs_map) map_window( hwnd, new_style );
+
+            if (!(data = get_win_data( hwnd ))) return;
+            restack_windows( data, prev_window );
+            release_win_data( data );
             return;
         }
         else if ((swp_flags & SWP_STATECHANGED) && (!data->iconic != !(new_style & WS_MINIMIZE)))
@@ -2880,10 +2909,20 @@ void CDECL X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags
         else
         {
             if (swp_flags & (SWP_FRAMECHANGED|SWP_STATECHANGED)) set_wm_hints( data );
-            if (!event_type || event_type == PropertyNotify) update_net_wm_states( data );
+            if (!event_type || event_type == PropertyNotify)
+            {
+                update_net_wm_states( data );
+                if (!prev_window && insert_after && data->net_wm_state & (1 << NET_WM_STATE_FULLSCREEN))
+                {
+                    prev_window = GetWindow( hwnd, GW_HWNDPREV );
+                    if (prev_window != insert_after) prev_window = NULL;
+                }
+            }
         }
     }

+    restack_windows( data, prev_window );
+
     XFlush( data->display );  /* make sure changes are done before we start painting again */
     if (data->surface && data->vis.visualid != default_visual.visualid)
         data->surface->funcs->flush( data->surface );
From ae84583fc7b97f3cc1d582fb3a91aea31492f637 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Wed, 19 Jan 2022 18:19:55 +0300
Subject: [PATCH] winevulkan: HACK: Report Windows driver version for AMD VAN
 GOGH.

CW-Bug-Id: #20009
---
 dlls/winevulkan/loader.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/dlls/winevulkan/loader.c b/dlls/winevulkan/loader.c
index fcb79983114..8095f7d4310 100644
--- a/dlls/winevulkan/loader.c
+++ b/dlls/winevulkan/loader.c
@@ -368,6 +368,15 @@ static void fill_luid_property(VkPhysicalDeviceProperties2 *properties2)
             id->deviceNodeMask);
 }

+static void update_driver_version( VkPhysicalDeviceProperties *properties )
+{
+    if (properties->vendorID == 0x1002 && properties->deviceID == 0x163f)
+    {
+        /* AMD VANGOGH */
+        properties->driverVersion = VK_MAKE_VERSION(21, 20, 1);
+    }
+}
+
 void WINAPI vkGetPhysicalDeviceProperties(VkPhysicalDevice physical_device,
         VkPhysicalDeviceProperties *properties)
 {
@@ -390,6 +399,7 @@ void WINAPI vkGetPhysicalDeviceProperties(VkPhysicalDevice physical_device,
             }
         }
     }
+    update_driver_version(properties);
 }

 void WINAPI vkGetPhysicalDeviceProperties2(VkPhysicalDevice phys_dev,
@@ -415,6 +425,7 @@ void WINAPI vkGetPhysicalDeviceProperties2(VkPhysicalDevice phys_dev,
             }
         }
     }
+    update_driver_version(&properties2->properties);
 }

 void WINAPI vkGetPhysicalDeviceProperties2KHR(VkPhysicalDevice phys_dev,
@@ -440,6 +451,7 @@ void WINAPI vkGetPhysicalDeviceProperties2KHR(VkPhysicalDevice phys_dev,
             }
         }
     }
+    update_driver_version(&properties2->properties);
 }

 VkResult WINAPI vkGetCalibratedTimestampsEXT(VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoEXT *pTimestampInfos, uint64_t *pTimestamps, uint64_t *pMaxDeviation)
From 399675bd511cbfd57a44e3afaae32a9ddf6dac87 Mon Sep 17 00:00:00 2001
From: Zhiyi Zhang <zzhang@codeweavers.com>
Date: Wed, 11 Nov 2020 10:41:42 +0800
Subject: [PATCH] winex11.drv: Call XIconifyWindow() after XMapWindow() with a
 minimized window.

Mutter always unminimizes a window when handling map requests. So a window could be in
normal state as far as Mutter concerns while Wine mistakenly considers it still minimized.

Fix Disgaea PC black screen after Alt+Tab in fullscreen mode.

CW-Bug-Id: #18364
Signed-off-by: Zhiyi Zhang <zzhang@codeweavers.com>
---
 dlls/winex11.drv/window.c | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 76d06b57814..b8cba02a0a8 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -1346,6 +1346,9 @@ static void map_window( HWND hwnd, DWORD new_style )
             update_net_wm_states( data );
             sync_window_style( data );
             XMapWindow( data->display, data->whole_window );
+            /* Mutter always unminimizes windows when handling map requests. Restore iconic state */
+            if (new_style & WS_MINIMIZE)
+                XIconifyWindow( data->display, data->whole_window, data->vis.screen );
             XFlush( data->display );
             if (data->surface && data->vis.visualid != default_visual.visualid)
                 data->surface->funcs->flush( data->surface );
@@ -2947,9 +2950,17 @@ void CDECL X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags
             data->iconic = (new_style & WS_MINIMIZE) != 0;
             TRACE( "changing win %p iconic state to %u\n", data->hwnd, data->iconic );
             if (data->iconic)
+            {
                 XIconifyWindow( data->display, data->whole_window, data->vis.screen );
+            }
             else if (is_window_rect_mapped( rectWindow ))
+            {
+                /* whole_window could be both iconic and mapped. Since XMapWindow() doesn't do
+                 * anything if the window is already mapped, we need to unmap it first */
+                if (data->mapped)
+                    XUnmapWindow( data->display, data->whole_window );
                 XMapWindow( data->display, data->whole_window );
+            }
             update_net_wm_states( data );
         }
         else

From cbb473f9808f96bb948229536eb5d57ea7629a58 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 23 Nov 2021 10:54:06 +0100
Subject: [PATCH] winex11.drv: Listen to the root window property changes.

CW-Bug-Id: #19673
CW-Bug-Id: #19991
---
 dlls/winex11.drv/systray.c | 2 +-
 dlls/winex11.drv/window.c  | 1 +
 2 files changed, 2 insertions(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/systray.c b/dlls/winex11.drv/systray.c
index c6d12b21c28..ac6e317ea5c 100644
--- a/dlls/winex11.drv/systray.c
+++ b/dlls/winex11.drv/systray.c
@@ -625,7 +625,7 @@ static BOOL init_systray(void)
         sprintf( systray_buffer, "_NET_SYSTEM_TRAY_S%u", DefaultScreen( display ) );
         systray_atom = XInternAtom( display, systray_buffer, False );
     }
-    XSelectInput( display, root_window, StructureNotifyMask );
+    XSelectInput( display, root_window, StructureNotifyMask | PropertyChangeMask );

     init_done = TRUE;
     return TRUE;
diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index b8cba02a0a8..a0d71c6e7f6 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -2233,6 +2233,7 @@ BOOL CDECL X11DRV_CreateWindow( HWND hwnd )
                                            InputOnly, default_visual.visual,
                                            CWOverrideRedirect | CWEventMask, &attr );
         x11drv_xinput_enable( data->display, data->clip_window, attr.event_mask );
+        XSelectInput( data->display, DefaultRootWindow( data->display ), PropertyChangeMask );
         XFlush( data->display );
         SetPropA( hwnd, clip_window_prop, (HANDLE)data->clip_window );
         X11DRV_InitClipboard();
From 14de66fd7ca005a0a4f8ef2d3357a477ad054e5d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 23 Nov 2021 11:15:12 +0100
Subject: [PATCH] HACK: gamescope: winex11.drv: Track GAMESCOPE_FOCUSED_APP
 property changes.

CW-Bug-Id: #19673
---
 dlls/winex11.drv/event.c       | 32 ++++++++++++++++++++++++++++++++
 dlls/winex11.drv/x11drv.h      |  1 +
 dlls/winex11.drv/x11drv_main.c |  3 ++-
 3 files changed, 35 insertions(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index b0ef922ca5d..53fd1e00b1c 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -1450,6 +1450,36 @@ static void handle__net_wm_state_notify( HWND hwnd, XPropertyEvent *event )
     release_win_data( data );
 }

+static int handle_gamescope_focused_app_error( Display *dpy, XErrorEvent *event, void *arg )
+{
+    WARN( "Failed to read GAMESCOPE_FOCUSED_APP property, ignoring.\n" );
+    return 1;
+}
+
+static void handle_gamescope_focused_app( XPropertyEvent *event )
+{
+    static const char *sgi = NULL;
+
+    unsigned long count, remaining, *property;
+    int format, app_id, focused_app_id;
+    Atom type;
+
+    if (!sgi && !(sgi = getenv( "SteamGameId" ))) return;
+    app_id = atoi( sgi );
+
+    X11DRV_expect_error( event->display, handle_gamescope_focused_app_error, NULL );
+    XGetWindowProperty( event->display, DefaultRootWindow( event->display ), x11drv_atom( GAMESCOPE_FOCUSED_APP ),
+                        0, ~0UL, False, XA_CARDINAL, &type, &format, &count, &remaining, (unsigned char **)&property );
+    if (X11DRV_check_error()) focused_app_id = app_id;
+    else
+    {
+        if (!property) focused_app_id = app_id;
+        else focused_app_id = *property;
+        XFree( property );
+    }
+
+    TRACE( "Got app id %u, focused app %u\n", app_id, focused_app_id );
+}

 /***********************************************************************
  *           X11DRV_PropertyNotify
@@ -1459,6 +1489,8 @@ static BOOL X11DRV_PropertyNotify( HWND hwnd, XEvent *xev )
     XPropertyEvent *event = &xev->xproperty;
     char *name;

+    if (event->atom == x11drv_atom( GAMESCOPE_FOCUSED_APP )) handle_gamescope_focused_app( event );
+
     if (!hwnd) return FALSE;

     name = XGetAtomName(event->display, event->atom);
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 7bb0e95d8d3..c9033074585 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -547,6 +547,7 @@ enum x11drv_atoms
     XATOM_text_rtf,
     XATOM_text_richtext,
     XATOM_text_uri_list,
+    XATOM_GAMESCOPE_FOCUSED_APP,
     NB_XATOMS
 };

diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index a03eb52ad46..2dd81a39e28 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -228,7 +228,8 @@ static const char * const atom_names[NB_XATOMS - FIRST_XATOM] =
     "text/plain",
     "text/rtf",
     "text/richtext",
-    "text/uri-list"
+    "text/uri-list",
+    "GAMESCOPE_FOCUSED_APP"
 };

 /***********************************************************************
From 266d6749771c5fa21403809f0277070a90626d48 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 23 Nov 2021 11:17:18 +0100
Subject: [PATCH] HACK: gamescope: winex11.drv: Ignore mouse events when Steam
 Keyboard is opened.

Using a global __wine_steamclient_KeyboardActivated event. We need to
keep keyboard events though as it's how the OSK will communicate its
input.

CW-Bug-Id: #19673
---
 dlls/winex11.drv/event.c       | 22 +++++++++++++++++++++-
 dlls/winex11.drv/mouse.c       |  1 +
 dlls/winex11.drv/x11drv.h      |  1 +
 dlls/winex11.drv/x11drv_main.c |  3 +++
 4 files changed, 26 insertions(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index 53fd1e00b1c..6aaeafb5dd4 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -447,18 +447,22 @@ static BOOL process_events( Display *display, Bool (*filter)(Display*, XEvent*,X
 {
     XEvent event, prev_event;
     int count = 0;
-    BOOL queued = FALSE, overlay_enabled = FALSE;
+    BOOL queued = FALSE, overlay_enabled = FALSE, steam_keyboard_opened = FALSE;
     enum event_merge_action action = MERGE_DISCARD;
     ULONG_PTR overlay_filter = QS_KEY | QS_MOUSEBUTTON | QS_MOUSEMOVE;
+    ULONG_PTR keyboard_filter = QS_MOUSEBUTTON | QS_MOUSEMOVE;

     if (WaitForSingleObject(steam_overlay_event, 0) == WAIT_OBJECT_0)
         overlay_enabled = TRUE;
+    if (WaitForSingleObject(steam_keyboard_event, 0) == WAIT_OBJECT_0)
+        steam_keyboard_opened = TRUE;

     prev_event.type = 0;
     while (XCheckIfEvent( display, &event, filter, (char *)arg ))
     {
         count++;
         if (overlay_enabled && filter_event( display, &event, (char *)overlay_filter )) continue;
+        if (steam_keyboard_opened && filter_event( display, &event, (char *)keyboard_filter )) continue;
         if (XFilterEvent( &event, None ))
         {
             /*
@@ -1459,9 +1463,11 @@ static int handle_gamescope_focused_app_error( Display *dpy, XErrorEvent *event,
 static void handle_gamescope_focused_app( XPropertyEvent *event )
 {
     static const char *sgi = NULL;
+    static BOOL steam_keyboard_opened;

     unsigned long count, remaining, *property;
     int format, app_id, focused_app_id;
+    BOOL keyboard_opened;
     Atom type;

     if (!sgi && !(sgi = getenv( "SteamGameId" ))) return;
@@ -1478,7 +1484,21 @@ static void handle_gamescope_focused_app( XPropertyEvent *event )
         XFree( property );
     }

+    keyboard_opened = app_id != focused_app_id;
+    if (steam_keyboard_opened == keyboard_opened) return;
+    steam_keyboard_opened = keyboard_opened;
+
     TRACE( "Got app id %u, focused app %u\n", app_id, focused_app_id );
+    if (keyboard_opened)
+    {
+        TRACE( "Steam Keyboard is opened, filtering events.\n" );
+        SetEvent( steam_keyboard_event );
+    }
+    else
+    {
+        TRACE( "Steam Keyboard is closed, stopping events filter.\n" );
+        ResetEvent( steam_keyboard_event );
+    }
 }

 /***********************************************************************
diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
index 0e13ce0e773..ea479d58264 100644
--- a/dlls/winex11.drv/mouse.c
+++ b/dlls/winex11.drv/mouse.c
@@ -1554,6 +1554,7 @@ BOOL CDECL X11DRV_GetCursorPos(LPPOINT pos)
     BOOL ret;

     if (WaitForSingleObject(steam_overlay_event, 0) == WAIT_OBJECT_0) return FALSE;
+    if (WaitForSingleObject(steam_keyboard_event, 0) == WAIT_OBJECT_0) return FALSE;

     ret = XQueryPointer( display, root_window, &root, &child, &rootX, &rootY, &winX, &winY, &xstate );
     if (ret)
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index c9033074585..612069d30cf 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -450,6 +450,7 @@ extern HMODULE x11drv_module DECLSPEC_HIDDEN;
 extern char *process_name DECLSPEC_HIDDEN;
 extern Display *clipboard_display DECLSPEC_HIDDEN;
 extern HANDLE steam_overlay_event DECLSPEC_HIDDEN;
+extern HANDLE steam_keyboard_event DECLSPEC_HIDDEN;

 /* atoms */

diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index 2dd81a39e28..e22528bdd34 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -90,6 +90,7 @@ int xfixes_event_base = 0;
 HMODULE x11drv_module = 0;
 char *process_name = NULL;
 HANDLE steam_overlay_event;
+HANDLE steam_keyboard_event;
 BOOL layered_window_client_hack = FALSE;

 static x11drv_error_callback err_callback;   /* current callback for error */
@@ -834,9 +835,11 @@ BOOL WINAPI DllMain( HINSTANCE hinst, DWORD reason, LPVOID reserved )
         x11drv_module = hinst;
         ret = process_attach();
         steam_overlay_event = CreateEventA(NULL, TRUE, FALSE, "__wine_steamclient_GameOverlayActivated");
+        steam_keyboard_event = CreateEventA(NULL, TRUE, FALSE, "__wine_steamclient_KeyboardActivated");
         break;
     case DLL_PROCESS_DETACH:
         CloseHandle(steam_overlay_event);
+        CloseHandle(steam_keyboard_event);
         break;
     }
     return ret;
From ed9751078cc384274d780e7ecf2a212e9ea737d4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 26 Jan 2022 19:25:56 +0100
Subject: [PATCH] HACK: gamescope: dinput: Ignore joystick input when Steam
 Keyboard is opened.

---
 dlls/dinput/dinput_main.c    | 3 +++
 dlls/dinput/dinput_private.h | 1 +
 dlls/dinput/joystick_hid.c   | 3 ++-
 3 files changed, 6 insertions(+), 1 deletion(-)

diff --git a/dlls/dinput/dinput_main.c b/dlls/dinput/dinput_main.c
index 87226fff1b9..11ac7c13b8c 100644
--- a/dlls/dinput/dinput_main.c
+++ b/dlls/dinput/dinput_main.c
@@ -1465,6 +1465,7 @@ void check_dinput_events(void)
 }

 HANDLE steam_overlay_event;
+HANDLE steam_keyboard_event;

 BOOL WINAPI DllMain( HINSTANCE inst, DWORD reason, LPVOID reserved)
 {
@@ -1473,6 +1474,7 @@ BOOL WINAPI DllMain( HINSTANCE inst, DWORD reason, LPVOID reserved)
       case DLL_PROCESS_ATTACH:
         DisableThreadLibraryCalls(inst);
         steam_overlay_event = CreateEventA(NULL, TRUE, FALSE, "__wine_steamclient_GameOverlayActivated");
+        steam_keyboard_event = CreateEventA(NULL, TRUE, FALSE, "__wine_steamclient_KeyboardActivated");
         DINPUT_instance = inst;
         register_di_em_win_class();
         break;
@@ -1482,6 +1484,7 @@ BOOL WINAPI DllMain( HINSTANCE inst, DWORD reason, LPVOID reserved)
         unregister_di_em_win_class();
         DeleteCriticalSection(&dinput_hook_crit);
         CloseHandle(steam_overlay_event);
+        CloseHandle(steam_keyboard_event);
         break;
     }
     return TRUE;
diff --git a/dlls/dinput/dinput_private.h b/dlls/dinput/dinput_private.h
index 37d4a4a060a..4c5660baca1 100644
--- a/dlls/dinput/dinput_private.h
+++ b/dlls/dinput/dinput_private.h
@@ -49,6 +49,7 @@ struct IDirectInputImpl
 extern const IDirectInput7AVtbl dinput7_a_vtbl DECLSPEC_HIDDEN;
 extern const IDirectInput8AVtbl dinput8_a_vtbl DECLSPEC_HIDDEN;
 extern HANDLE steam_overlay_event DECLSPEC_HIDDEN;
+extern HANDLE steam_keyboard_event DECLSPEC_HIDDEN;

 extern HRESULT mouse_enum_device( DWORD type, DWORD flags, DIDEVICEINSTANCEW *instance, DWORD version );
 extern HRESULT mouse_create_device( IDirectInputImpl *dinput, const GUID *guid, IDirectInputDevice8W **out );
diff --git a/dlls/dinput/joystick_hid.c b/dlls/dinput/joystick_hid.c
index 9ffaa2786d4..dd17cd478ae 100644
--- a/dlls/dinput/joystick_hid.c
+++ b/dlls/dinput/joystick_hid.c
@@ -1252,7 +1252,8 @@ static HRESULT hid_joystick_read( IDirectInputDevice8W *iface )
         }
     }

-    if (WaitForSingleObject(steam_overlay_event, 0) == WAIT_OBJECT_0) /* steam overlay is enabled */
+    if (WaitForSingleObject(steam_overlay_event, 0) == WAIT_OBJECT_0 || /* steam overlay is enabled */
+        WaitForSingleObject(steam_keyboard_event, 0) == WAIT_OBJECT_0) /* steam keyboard is enabled */
         params.reset_state = TRUE;
     else
         params.reset_state = FALSE;
From c00909b683c229658ad89f77ceea724e2f0f1bd1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 26 Jan 2022 19:26:19 +0100
Subject: [PATCH] HACK: gamescope: xinput1_3: Ignore gamepad input when Steam
 Keyboard is opened.

---
 dlls/xinput1_3/main.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/dlls/xinput1_3/main.c b/dlls/xinput1_3/main.c
index f57b5ee360b..ee132d58aed 100644
--- a/dlls/xinput1_3/main.c
+++ b/dlls/xinput1_3/main.c
@@ -125,6 +125,7 @@ static HANDLE stop_event;
 static HANDLE done_event;
 static HANDLE update_event;
 static HANDLE steam_overlay_event;
+static HANDLE steam_keyboard_event;

 static BOOL find_opened_device(const WCHAR *device_path, int *free_slot)
 {
@@ -547,6 +548,7 @@ static void stop_update_thread(void)
     CloseHandle(done_event);
     CloseHandle(update_event);
     CloseHandle(steam_overlay_event);
+    CloseHandle(steam_keyboard_event);

     for (i = 0; i < XUSER_MAX_COUNT; i++) controller_destroy(&controllers[i], FALSE);
 }
@@ -743,6 +745,7 @@ static BOOL WINAPI start_update_thread_once( INIT_ONCE *once, void *param, void
     HANDLE thread;

     steam_overlay_event = CreateEventA(NULL, TRUE, FALSE, "__wine_steamclient_GameOverlayActivated");
+    steam_keyboard_event = CreateEventA(NULL, TRUE, FALSE, "__wine_steamclient_KeyboardActivated");

     start_event = CreateEventA(NULL, FALSE, FALSE, NULL);
     if (!start_event) ERR("failed to create start event, error %u\n", GetLastError());
@@ -839,6 +842,7 @@ DWORD WINAPI DECLSPEC_HOTPATCH XInputSetState(DWORD index, XINPUT_VIBRATION *vib
     if (!controller_lock(&controllers[index])) return ERROR_DEVICE_NOT_CONNECTED;

     if (WaitForSingleObject(steam_overlay_event, 0) == WAIT_OBJECT_0) ret = ERROR_SUCCESS;
+    else if (WaitForSingleObject(steam_keyboard_event, 0) == WAIT_OBJECT_0) ret = ERROR_SUCCESS;
     else ret = HID_set_state(&controllers[index], vibration);

     controller_unlock(&controllers[index]);
@@ -858,6 +862,7 @@ static DWORD xinput_get_state(DWORD index, XINPUT_STATE *state)
     if (!controller_lock(&controllers[index])) return ERROR_DEVICE_NOT_CONNECTED;

     if (WaitForSingleObject(steam_overlay_event, 0) == WAIT_OBJECT_0) memset(state, 0, sizeof(*state));
+    else if (WaitForSingleObject(steam_keyboard_event, 0) == WAIT_OBJECT_0) memset(state, 0, sizeof(*state));
     else *state = controllers[index].state;

     controller_unlock(&controllers[index]);
From ef828e66f330bc8eaaad45609c45699bba371270 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 28 Oct 2021 16:41:17 +0200
Subject: [PATCH] HACK: gamescope: winex11.drv: Use native screen rect for
 absolute raw event positions.

CW-Bug-Id: #18214
---
 dlls/winex11.drv/display.c | 13 +++++++++++++
 dlls/winex11.drv/mouse.c   |  1 +
 dlls/winex11.drv/x11drv.h  |  1 +
 3 files changed, 15 insertions(+)

diff --git a/dlls/winex11.drv/display.c b/dlls/winex11.drv/display.c
index b3ed448c43f..f3e928ac25e 100644
--- a/dlls/winex11.drv/display.c
+++ b/dlls/winex11.drv/display.c
@@ -55,6 +55,7 @@ struct x11drv_display_device_handler desktop_handler;

 /* Cached screen information, protected by screen_section */
 static HKEY video_key;
+static RECT native_screen_rect;
 static RECT virtual_screen_rect;
 static RECT primary_monitor_rect;
 static FILETIME last_query_screen_time;
@@ -125,6 +126,7 @@ static BOOL update_screen_cache(void)
     }

     EnterCriticalSection(&screen_section);
+    if (!native_screen_rect.bottom) native_screen_rect = virtual_rect;
     virtual_screen_rect = virtual_rect;
     primary_monitor_rect = primary_rect;
     last_query_screen_time = filetime;
@@ -170,6 +172,17 @@ POINT root_to_virtual_screen(INT x, INT y)
     return pt;
 }

+RECT get_native_screen_rect(void)
+{
+    RECT rect;
+
+    update_screen_cache();
+    EnterCriticalSection(&screen_section);
+    rect = native_screen_rect;
+    LeaveCriticalSection(&screen_section);
+    return rect;
+}
+
 RECT get_virtual_screen_rect(void)
 {
     RECT virtual;
diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
index a7fabcf860d..9511590cdb0 100644
--- a/dlls/winex11.drv/mouse.c
+++ b/dlls/winex11.drv/mouse.c
@@ -1895,6 +1895,7 @@ static BOOL map_raw_event_coords( XIRawEvent *event, INPUT *input )
         FIXME( "Unsupported relative/absolute X/Y axis mismatch\n." );

     if (input->u.mi.dwFlags & MOUSEEVENTF_VIRTUALDESK) SetRect( &virtual_rect, 0, 0, 65535, 65535 );
+    else if (wm_is_steamcompmgr( event->display )) virtual_rect = get_native_screen_rect();
     else virtual_rect = get_virtual_screen_rect();

     if (x->max <= x->min) x_scale = 1;
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 5c9dbb88aad..a3f2b5a93e3 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -743,6 +743,7 @@ extern BOOL is_window_rect_full_screen( const RECT *rect ) DECLSPEC_HIDDEN;
 extern BOOL is_window_rect_full_virtual_screen( const RECT *rect ) DECLSPEC_HIDDEN;
 extern POINT virtual_screen_to_root( INT x, INT y ) DECLSPEC_HIDDEN;
 extern POINT root_to_virtual_screen( INT x, INT y ) DECLSPEC_HIDDEN;
+extern RECT get_native_screen_rect(void) DECLSPEC_HIDDEN;
 extern RECT get_virtual_screen_rect(void) DECLSPEC_HIDDEN;
 extern RECT get_primary_monitor_rect(void) DECLSPEC_HIDDEN;
 extern RECT get_host_primary_monitor_rect(void) DECLSPEC_HIDDEN;
From 61521e371ac42b8d91b9af163bbc350bd89e0c5b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 30 Nov 2021 10:38:13 +0100
Subject: [PATCH] HACK: server: Close desktop immediately when last user is
 removed.

This should speed up prefix shutdown by 1s, making it only depend on
master socket timeout.

CW-Bug-Id: #19584
---
 server/user.h       |  1 -
 server/winstation.c | 12 ++----------
 2 files changed, 2 insertions(+), 11 deletions(-)

diff --git a/server/user.h b/server/user.h
index 3f7341a120f..a274b66383d 100644
--- a/server/user.h
+++ b/server/user.h
@@ -72,7 +72,6 @@ struct desktop
     struct window       *msg_window;       /* HWND_MESSAGE top window */
     struct hook_table   *global_hooks;     /* table of global hooks on this desktop */
     struct list          hotkeys;          /* list of registered hotkeys */
-    struct timeout_user *close_timeout;    /* timeout before closing the desktop */
     struct thread_input *foreground_input; /* thread input of foreground thread */
     unsigned int         users;            /* processes and threads using this desktop */
     struct global_cursor cursor;           /* global cursor information */
diff --git a/server/winstation.c b/server/winstation.c
index fabd892f4cc..a9b161312dd 100644
--- a/server/winstation.c
+++ b/server/winstation.c
@@ -252,7 +252,6 @@ static struct desktop *create_desktop( const struct unicode_str *name, unsigned
             desktop->top_window = NULL;
             desktop->msg_window = NULL;
             desktop->global_hooks = NULL;
-            desktop->close_timeout = NULL;
             desktop->foreground_input = NULL;
             desktop->users = 0;
             desktop->cursor_clip_msg = 0;
@@ -318,7 +317,6 @@ static void desktop_destroy( struct object *obj )
     if (desktop->top_window) destroy_window( desktop->top_window );
     if (desktop->msg_window) destroy_window( desktop->msg_window );
     if (desktop->global_hooks) release_object( desktop->global_hooks );
-    if (desktop->close_timeout) remove_timeout_user( desktop->close_timeout );
     list_remove( &desktop->entry );
     release_object( desktop->shared_mapping );
     release_object( desktop->winstation );
@@ -334,7 +332,6 @@ static void close_desktop_timeout( void *private )
 {
     struct desktop *desktop = private;

-    desktop->close_timeout = NULL;
     unlink_named_object( &desktop->obj );  /* make sure no other process can open it */
     post_desktop_message( desktop, WM_CLOSE, 0, 0 );  /* and signal the owner to quit */
 }
@@ -343,11 +340,6 @@ static void close_desktop_timeout( void *private )
 static void add_desktop_user( struct desktop *desktop )
 {
     desktop->users++;
-    if (desktop->close_timeout)
-    {
-        remove_timeout_user( desktop->close_timeout );
-        desktop->close_timeout = NULL;
-    }
 }

 /* remove a user of the desktop and start the close timeout if necessary */
@@ -358,8 +350,8 @@ static void remove_desktop_user( struct desktop *desktop )
     desktop->users--;

     /* if we have one remaining user, it has to be the manager of the desktop window */
-    if ((process = get_top_window_owner( desktop )) && desktop->users == process->running_threads && !desktop->close_timeout)
-        desktop->close_timeout = add_timeout_user( -TICKS_PER_SEC, close_desktop_timeout, desktop );
+    if ((process = get_top_window_owner( desktop )) && desktop->users == process->running_threads)
+        close_desktop_timeout( desktop );
 }

 /* set the thread default desktop handle */
From f5e6cd76159d7bcc4fc8589bbad8e163d3756c85 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 4 Feb 2022 11:34:26 +0100
Subject: [PATCH] HACK: steam: hidclass.sys: Do not send WM_INPUT messages when
 overlay is open.

So that games listening to them, such as ICEY, do not have input
bleeding through the overlay. Note that some other games, such as Hades,
which are reading the HID devices directly, have the input bleeding
through on Windows, so we do the same here.

CW-Bug-Id: #20083
---
 dlls/hidclass.sys/device.c |  7 ++++++-
 dlls/hidclass.sys/hid.h    |  6 ++++++
 dlls/hidclass.sys/pnp.c    | 12 ++++++++++++
 3 files changed, 24 insertions(+), 1 deletion(-)

diff --git a/dlls/hidclass.sys/device.c b/dlls/hidclass.sys/device.c
index 70e1c3d12d4..a0e5e75382d 100644
--- a/dlls/hidclass.sys/device.c
+++ b/dlls/hidclass.sys/device.c
@@ -223,6 +223,7 @@ static void hid_device_queue_input( DEVICE_OBJECT *device, HID_XFER_PACKET *pack
     const BOOL polled = ext->u.pdo.information.Polled;
     ULONG size, report_len = polled ? packet->reportBufferLen : desc->InputLength;
     struct hid_report *last_report, *report;
+    BOOL steam_overlay_open = FALSE;
     struct hid_queue *queue;
     LIST_ENTRY completed, *entry;
     RAWINPUT *rawinput;
@@ -231,7 +232,11 @@ static void hid_device_queue_input( DEVICE_OBJECT *device, HID_XFER_PACKET *pack

     TRACE("device %p, packet %p\n", device, packet);

-    if (IsEqualGUID( ext->class_guid, &GUID_DEVINTERFACE_HID ))
+    if (WaitForSingleObject(ext->steam_overlay_event, 0) == WAIT_OBJECT_0 || /* steam overlay is open */
+        WaitForSingleObject(ext->steam_keyboard_event, 0) == WAIT_OBJECT_0) /* steam keyboard is open */
+        steam_overlay_open = TRUE;
+
+    if (IsEqualGUID( ext->class_guid, &GUID_DEVINTERFACE_HID ) && !steam_overlay_open)
     {
         size = offsetof( RAWINPUT, data.hid.bRawData[report_len] );
         if (!(rawinput = malloc( size ))) ERR( "Failed to allocate rawinput data!\n" );
diff --git a/dlls/hidclass.sys/hid.h b/dlls/hidclass.sys/hid.h
index e20f12809eb..042695dba63 100644
--- a/dlls/hidclass.sys/hid.h
+++ b/dlls/hidclass.sys/hid.h
@@ -83,6 +83,9 @@ typedef struct _BASE_DEVICE_EXTENSION
     WCHAR instance_id[MAX_DEVICE_ID_LEN];
     const GUID *class_guid;

+    HANDLE steam_overlay_event;
+    HANDLE steam_keyboard_event;
+
     BOOL is_fdo;
 } BASE_DEVICE_EXTENSION;

@@ -114,6 +117,9 @@ typedef struct _minidriver

     PDRIVER_ADD_DEVICE AddDevice;
     PDRIVER_DISPATCH PNPDispatch;
+
+    HANDLE steam_overlay_event;
+    HANDLE steam_keyboard_event;
 } minidriver;

 void call_minidriver( ULONG code, DEVICE_OBJECT *device, void *in_buff, ULONG in_size,
diff --git a/dlls/hidclass.sys/pnp.c b/dlls/hidclass.sys/pnp.c
index 096fe54c51b..681fafd610f 100644
--- a/dlls/hidclass.sys/pnp.c
+++ b/dlls/hidclass.sys/pnp.c
@@ -172,6 +172,9 @@ static NTSTATUS WINAPI driver_add_device(DRIVER_OBJECT *driver, DEVICE_OBJECT *b
     swprintf(ext->device_id, ARRAY_SIZE(ext->device_id), L"HID\\%s", wcsrchr(device_id, '\\') + 1);
     wcscpy(ext->instance_id, instance_id);

+    ext->steam_overlay_event = minidriver->steam_overlay_event;
+    ext->steam_keyboard_event = minidriver->steam_keyboard_event;
+
     is_xinput_class = !wcsncmp(device_id, L"WINEXINPUT\\", 7) && wcsstr(device_id, L"&XI_") != NULL;
     if (is_xinput_class) ext->class_guid = &GUID_DEVINTERFACE_WINEXINPUT;
     else ext->class_guid = &GUID_DEVINTERFACE_HID;
@@ -235,6 +238,9 @@ static void create_child(minidriver *minidriver, DEVICE_OBJECT *fdo)
     pdo_ext->u.pdo.information.VersionNumber = attr.VersionNumber;
     pdo_ext->u.pdo.information.Polled = minidriver->minidriver.DevicesArePolled;

+    pdo_ext->steam_overlay_event = minidriver->steam_overlay_event;
+    pdo_ext->steam_keyboard_event = minidriver->steam_keyboard_event;
+
     call_minidriver( IOCTL_HID_GET_DEVICE_DESCRIPTOR, fdo, NULL, 0, &descriptor, sizeof(descriptor), &io );
     if (io.Status != STATUS_SUCCESS)
     {
@@ -582,6 +588,9 @@ static void WINAPI driver_unload(DRIVER_OBJECT *driver)
         if (md->DriverUnload)
             md->DriverUnload(md->minidriver.DriverObject);
         list_remove(&md->entry);
+
+        CloseHandle(md->steam_overlay_event);
+        CloseHandle(md->steam_keyboard_event);
         free(md);
     }
 }
@@ -593,6 +602,9 @@ NTSTATUS WINAPI HidRegisterMinidriver(HID_MINIDRIVER_REGISTRATION *registration)
     if (!(driver = calloc(1, sizeof(*driver))))
         return STATUS_NO_MEMORY;

+    driver->steam_overlay_event = CreateEventA(NULL, TRUE, FALSE, "__wine_steamclient_GameOverlayActivated");
+    driver->steam_keyboard_event = CreateEventA(NULL, TRUE, FALSE, "__wine_steamclient_KeyboardActivated");
+
     driver->DriverUnload = registration->DriverObject->DriverUnload;
     registration->DriverObject->DriverUnload = driver_unload;

From 37a429a3e2966d5ccabd48e093fc717957649108 Mon Sep 17 00:00:00 2001
From: Arkadiusz Hiler <ahiler@codeweavers.com>
Date: Mon, 4 Apr 2022 15:21:16 +0300
Subject: [PATCH] fixup! winex11.drv: Fullscreen hack

Add option to disable fshack via env variable. Useful for testing with
Wayland compositors, like gamescope which handle fullscreen much better
than native X.
---
 dlls/winex11.drv/x11drv_main.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index fbf21003620..f5aaeab0df3 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -718,7 +718,10 @@ static BOOL process_attach(void)
     X11DRV_InitMouse( gdi_display );
     if (use_xim) use_xim = X11DRV_InitXIM( input_style );

-    fs_hack_init();
+    {
+        const char *e = getenv("WINE_DISABLE_FULLSCREEN_HACK");
+        if (!e || *e == '\0' || *e == '0') fs_hack_init();
+    }

     {
         const char *sgi = getenv("SteamGameId");

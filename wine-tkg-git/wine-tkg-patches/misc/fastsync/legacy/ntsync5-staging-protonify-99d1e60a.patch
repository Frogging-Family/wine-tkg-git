diff --color -u -r -N a/configure b/configure
--- a/configure	2025-04-11 19:05:01.184350510 +0500
+++ b/configure	2025-04-11 19:11:08.122235246 +0500
@@ -7776,6 +7776,12 @@
   printf "%s\n" "#define HAVE_LINUX_MAJOR_H 1" >>confdefs.h
 
 fi
+ac_fn_c_check_header_compile "$LINENO" "linux/ntsync.h" "ac_cv_header_linux_ntsync_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_ntsync_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_NTSYNC_H 1" >>confdefs.h
+
+fi
 ac_fn_c_check_header_compile "$LINENO" "linux/param.h" "ac_cv_header_linux_param_h" "$ac_includes_default"
 if test "x$ac_cv_header_linux_param_h" = xyes
 then :
@@ -7950,12 +7956,6 @@
   printf "%s\n" "#define HAVE_SYS_EVENT_H 1" >>confdefs.h
 
 fi
-ac_fn_c_check_header_compile "$LINENO" "sys/eventfd.h" "ac_cv_header_sys_eventfd_h" "$ac_includes_default"
-if test "x$ac_cv_header_sys_eventfd_h" = xyes
-then :
-  printf "%s\n" "#define HAVE_SYS_EVENTFD_H 1" >>confdefs.h
-
-fi
 ac_fn_c_check_header_compile "$LINENO" "sys/extattr.h" "ac_cv_header_sys_extattr_h" "$ac_includes_default"
 if test "x$ac_cv_header_sys_extattr_h" = xyes
 then :
@@ -21195,12 +21195,6 @@
   printf "%s\n" "#define HAVE_POSIX_FALLOCATE 1" >>confdefs.h
 
 fi
-ac_fn_c_check_func "$LINENO" "ppoll" "ac_cv_func_ppoll"
-if test "x$ac_cv_func_ppoll" = xyes
-then :
-  printf "%s\n" "#define HAVE_PPOLL 1" >>confdefs.h
-
-fi
 ac_fn_c_check_func "$LINENO" "prctl" "ac_cv_func_prctl"
 if test "x$ac_cv_func_prctl" = xyes
 then :
@@ -21344,80 +21338,6 @@
 
 LIBS=$ac_save_LIBS
 
-ac_save_LIBS=$LIBS
-{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for library containing shm_open" >&5
-printf %s "checking for library containing shm_open... " >&6; }
-if test ${ac_cv_search_shm_open+y}
-then :
-  printf %s "(cached) " >&6
-else case e in #(
-  e) ac_func_search_save_LIBS=$LIBS
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.
-   The 'extern "C"' is for builds by C++ compilers;
-   although this is not generally supported in C code supporting it here
-   has little cost and some practical benefit (sr 110532).  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char shm_open (void);
-int
-main (void)
-{
-return shm_open ();
-  ;
-  return 0;
-}
-_ACEOF
-for ac_lib in '' rt
-do
-  if test -z "$ac_lib"; then
-    ac_res="none required"
-  else
-    ac_res=-l$ac_lib
-    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
-  fi
-  if ac_fn_c_try_link "$LINENO"
-then :
-  ac_cv_search_shm_open=$ac_res
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.beam \
-    conftest$ac_exeext
-  if test ${ac_cv_search_shm_open+y}
-then :
-  break
-fi
-done
-if test ${ac_cv_search_shm_open+y}
-then :
-
-else case e in #(
-  e) ac_cv_search_shm_open=no ;;
-esac
-fi
-rm conftest.$ac_ext
-LIBS=$ac_func_search_save_LIBS ;;
-esac
-fi
-{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_shm_open" >&5
-printf "%s\n" "$ac_cv_search_shm_open" >&6; }
-ac_res=$ac_cv_search_shm_open
-if test "$ac_res" != no
-then :
-  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
-
-printf "%s\n" "#define HAVE_SHM_OPEN 1" >>confdefs.h
-
-                test "$ac_res" = "none required" || RT_LIBS="$ac_res"
-
-fi
-
-LIBS=$ac_save_LIBS
-
 { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for sched_setaffinity" >&5
 printf %s "checking for sched_setaffinity... " >&6; }
 if test ${wine_cv_have_sched_setaffinity+y}
diff --color -u -r -N a/configure.ac b/configure.ac
--- a/configure.ac	2025-04-11 19:05:01.155620232 +0500
+++ b/configure.ac	2025-04-11 19:11:08.122876691 +0500
@@ -390,6 +390,7 @@
 	linux/input.h \
 	linux/ioctl.h \
 	linux/major.h \
+	linux/ntsync.h \
 	linux/param.h \
 	linux/seccomp.h \
 	linux/serial.h \
@@ -419,7 +420,6 @@
 	sys/cdio.h \
 	sys/epoll.h \
 	sys/event.h \
-	sys/eventfd.h \
 	sys/extattr.h \
 	sys/filio.h \
 	sys/ipc.h \
@@ -2096,7 +2096,6 @@
 	port_create \
 	posix_fadvise \
 	posix_fallocate \
-	ppoll \
 	prctl \
 	sched_getcpu \
 	sched_yield \
@@ -2118,12 +2117,6 @@
                 test "$ac_res" = "none required" || AC_SUBST(RT_LIBS,"$ac_res")])
 LIBS=$ac_save_LIBS
 
-ac_save_LIBS=$LIBS
-AC_SEARCH_LIBS(shm_open, rt,
-               [AC_DEFINE(HAVE_SHM_OPEN, 1, [Define to 1 if you have the `shm_open' function.])
-                test "$ac_res" = "none required" || AC_SUBST(RT_LIBS,"$ac_res")])
-LIBS=$ac_save_LIBS
-
 AC_CACHE_CHECK([for sched_setaffinity],wine_cv_have_sched_setaffinity,
                 AC_LINK_IFELSE([AC_LANG_PROGRAM(
 [[#include <sched.h>]], [[sched_setaffinity(0, 0, 0);]])],[wine_cv_have_sched_setaffinity=yes],[wine_cv_have_sched_setaffinity=no]))
diff --color -u -r -N a/dlls/kernel32/tests/sync.c b/dlls/kernel32/tests/sync.c
--- a/dlls/kernel32/tests/sync.c	2025-04-11 19:04:48.323211191 +0500
+++ b/dlls/kernel32/tests/sync.c	2025-04-11 19:10:08.128971080 +0500
@@ -58,7 +58,6 @@
 
 static NTSTATUS (WINAPI *pNtAllocateVirtualMemory)(HANDLE, PVOID *, ULONG_PTR, SIZE_T *, ULONG, ULONG);
 static NTSTATUS (WINAPI *pNtFreeVirtualMemory)(HANDLE, PVOID *, SIZE_T *, ULONG);
-static NTSTATUS (WINAPI *pNtQuerySystemTime)(LARGE_INTEGER *);
 static NTSTATUS (WINAPI *pNtWaitForSingleObject)(HANDLE, BOOLEAN, const LARGE_INTEGER *);
 static NTSTATUS (WINAPI *pNtWaitForMultipleObjects)(ULONG,const HANDLE*,BOOLEAN,BOOLEAN,const LARGE_INTEGER*);
 static PSLIST_ENTRY (__fastcall *pRtlInterlockedPushListSList)(PSLIST_HEADER list, PSLIST_ENTRY first,
@@ -229,23 +228,8 @@
     ok(GetLastError() == ERROR_FILE_NOT_FOUND, "wrong error %lu\n", GetLastError());
 }
 
-static HANDLE mutex, mutex2, mutices[2];
-
-static DWORD WINAPI mutex_thread( void *param )
-{
-    DWORD expect = (DWORD)(DWORD_PTR)param;
-    DWORD ret;
-
-    ret = WaitForSingleObject( mutex, 0 );
-    ok(ret == expect, "expected %lu, got %lu\n", expect, ret);
-
-    if (!ret) ReleaseMutex( mutex );
-    return 0;
-}
-
 static void test_mutex(void)
 {
-    HANDLE thread;
     DWORD wait_ret;
     BOOL ret;
     HANDLE hCreated;
@@ -283,8 +267,7 @@
     SetLastError(0xdeadbeef);
     hOpened = OpenMutexA(GENERIC_READ | GENERIC_WRITE, FALSE, "WineTestMutex");
     ok(hOpened != NULL, "OpenMutex failed with error %ld\n", GetLastError());
-    wait_ret = WaitForSingleObject(hOpened, 0);
-todo_wine_if(getenv("WINEESYNC"))   /* XFAIL: validation is not implemented */
+    wait_ret = WaitForSingleObject(hOpened, INFINITE);
     ok(wait_ret == WAIT_FAILED, "WaitForSingleObject succeeded\n");
     CloseHandle(hOpened);
 
@@ -315,7 +298,6 @@
 
     SetLastError(0xdeadbeef);
     ret = ReleaseMutex(hCreated);
-todo_wine_if(getenv("WINEESYNC"))   /* XFAIL: due to the above */
     ok(!ret && (GetLastError() == ERROR_NOT_OWNER),
         "ReleaseMutex should have failed with ERROR_NOT_OWNER instead of %ld\n", GetLastError());
 
@@ -354,85 +336,6 @@
     CloseHandle(hOpened);
 
     CloseHandle(hCreated);
-
-    mutex = CreateMutexA( NULL, FALSE, NULL );
-    ok(!!mutex, "got error %lu\n", GetLastError());
-
-    ret = ReleaseMutex( mutex );
-    ok(!ret, "got %d\n", ret);
-    ok(GetLastError() == ERROR_NOT_OWNER, "got error %lu\n", GetLastError());
-
-    for (i = 0; i < 100; i++)
-    {
-        ret = WaitForSingleObject( mutex, 0 );
-        ok(ret == 0, "got %u\n", ret);
-    }
-
-    for (i = 0; i < 100; i++)
-    {
-        ret = ReleaseMutex( mutex );
-        ok(ret, "got error %lu\n", GetLastError());
-    }
-
-    ret = ReleaseMutex( mutex );
-    ok(!ret, "got %d\n", ret);
-    ok(GetLastError() == ERROR_NOT_OWNER, "got error %lu\n", GetLastError());
-
-    thread = CreateThread( NULL, 0, mutex_thread, (void *)0, 0, NULL );
-    ret = WaitForSingleObject( thread, 2000 );
-    ok(ret == 0, "wait failed: %u\n", ret);
-
-    WaitForSingleObject( mutex, 0 );
-
-    thread = CreateThread( NULL, 0, mutex_thread, (void *)WAIT_TIMEOUT, 0, NULL );
-    ret = WaitForSingleObject( thread, 2000 );
-    ok(ret == 0, "wait failed: %u\n", ret);
-
-    ret = ReleaseMutex( mutex );
-        ok(ret, "got error %lu\n", GetLastError());
-
-    thread = CreateThread( NULL, 0, mutex_thread, (void *)0, 0, NULL );
-    ret = WaitForSingleObject( thread, 2000 );
-    ok(ret == 0, "wait failed: %u\n", ret);
-
-    mutex2 = CreateMutexA( NULL, TRUE, NULL );
-    ok(!!mutex2, "got error %lu\n", GetLastError());
-
-    ret = ReleaseMutex( mutex2 );
-    ok(ret, "got error %lu\n", GetLastError());
-
-    ret = ReleaseMutex( mutex2 );
-    ok(!ret, "got %d\n", ret);
-    ok(GetLastError() == ERROR_NOT_OWNER, "got error %lu\n", GetLastError());
-
-    mutices[0] = mutex;
-    mutices[1] = mutex2;
-
-    ret = WaitForMultipleObjects( 2, mutices, FALSE, 0 );
-    ok(ret == 0, "got %u\n", ret);
-
-    ret = ReleaseMutex( mutex );
-    ok(ret, "got error %lu\n", GetLastError());
-
-    ret = ReleaseMutex( mutex2 );
-    ok(!ret, "got %d\n", ret);
-    ok(GetLastError() == ERROR_NOT_OWNER, "got error %lu\n", GetLastError());
-
-    ret = WaitForMultipleObjects( 2, mutices, TRUE, 0 );
-    ok(ret == 0, "got %u\n", ret);
-
-    ret = ReleaseMutex( mutex );
-    ok(ret, "got error %lu\n", GetLastError());
-
-    ret = ReleaseMutex( mutex2 );
-    ok(ret, "got error %lu\n", GetLastError());
-
-    ret = CloseHandle( mutex );
-    ok(ret, "got error %lu\n", GetLastError());
-
-    ret = CloseHandle( mutex2 );
-    ok(ret, "got error %lu\n", GetLastError());
-
 }
 
 static void test_slist(void)
@@ -608,13 +511,12 @@
 
 static void test_event(void)
 {
-    HANDLE handle, handle2, handles[2];
+    HANDLE handle, handle2;
     SECURITY_ATTRIBUTES sa;
     SECURITY_DESCRIPTOR sd;
     ACL acl;
     DWORD ret;
     BOOL val;
-    int i;
 
     /* no sd */
     handle = CreateEventA(NULL, FALSE, FALSE, __FILE__ ": Test Event");
@@ -718,130 +620,11 @@
     ok( ret, "QueryMemoryResourceNotification failed err %lu\n", GetLastError() );
     ok( val == FALSE || val == TRUE, "wrong value %u\n", val );
     CloseHandle( handle );
-
-    handle = CreateEventA( NULL, TRUE, FALSE, NULL );
-    ok(!!handle, "got error %lu\n", GetLastError());
-
-    ret = WaitForSingleObject( handle, 0 );
-    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
-
-    ret = SetEvent( handle );
-    ok(ret, "got error %lu\n", GetLastError());
-
-    ret = SetEvent( handle );
-    ok(ret, "got error %lu\n", GetLastError());
-
-    for (i = 0; i < 100; i++)
-    {
-        ret = WaitForSingleObject( handle, 0 );
-        ok(ret == 0, "got %lu\n", ret);
-    }
-
-    ret = ResetEvent( handle );
-    ok(ret, "got error %lu\n", GetLastError());
-
-    ret = ResetEvent( handle );
-    ok(ret, "got error %lu\n", GetLastError());
-
-    ret = WaitForSingleObject( handle, 0 );
-    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
-
-    handle2 = CreateEventA( NULL, FALSE, TRUE, NULL );
-    ok(!!handle2, "got error %lu\n", GetLastError());
-
-    ret = WaitForSingleObject( handle2, 0 );
-    ok(ret == 0, "got %lu\n", ret);
-
-    ret = WaitForSingleObject( handle2, 0 );
-    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
-
-    ret = SetEvent( handle2 );
-    ok(ret, "got error %lu\n", GetLastError());
-
-    ret = SetEvent( handle2 );
-    ok(ret, "got error %lu\n", GetLastError());
-
-    ret = ResetEvent( handle2 );
-    ok(ret, "got error %lu\n", GetLastError());
-
-    ret = ResetEvent( handle2 );
-    ok(ret, "got error %lu\n", GetLastError());
-
-    ret = WaitForSingleObject( handle2, 0 );
-    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
-
-    handles[0] = handle;
-    handles[1] = handle2;
-
-    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
-    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
-
-    SetEvent( handle );
-    SetEvent( handle2 );
-
-    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
-    ok(ret == 0, "got %lu\n", ret);
-
-    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
-    ok(ret == 0, "got %lu\n", ret);
-
-    ret = WaitForSingleObject( handle2, 0 );
-    ok(ret == 0, "got %lu\n", ret);
-
-    ResetEvent( handle );
-    SetEvent( handle2 );
-
-    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
-    ok(ret == 1, "got %lu\n", ret);
-
-    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
-    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
-
-    SetEvent( handle );
-    SetEvent( handle2 );
-
-    ret = WaitForMultipleObjects( 2, handles, TRUE, 0 );
-    ok(ret == 0, "got %lu\n", ret);
-
-    ret = WaitForMultipleObjects( 2, handles, TRUE, 0 );
-    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
-
-    SetEvent( handle2 );
-    ResetEvent( handle );
-
-    ret = WaitForMultipleObjects( 2, handles, TRUE, 0 );
-    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
-
-    ret = WaitForSingleObject( handle2, 0 );
-    ok(ret == 0, "got %lu\n", ret);
-
-    handles[0] = handle2;
-    handles[1] = handle;
-    SetEvent( handle );
-    SetEvent( handle2 );
-
-    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
-    ok(ret == 0, "got %lu\n", ret);
-
-    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
-    ok(ret == 1, "got %lu\n", ret);
-
-    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
-    ok(ret == 1, "got %lu\n", ret);
-
-    ret = CloseHandle( handle );
-    ok(ret, "got error %lu\n", GetLastError());
-
-    ret = CloseHandle( handle2 );
-    ok(ret, "got error %lu\n", GetLastError());
 }
 
 static void test_semaphore(void)
 {
-    HANDLE handle, handle2, handles[2];
-    DWORD ret;
-    LONG prev;
-    int i;
+    HANDLE handle, handle2;
 
     /* test case sensitivity */
 
@@ -883,99 +666,6 @@
     ok( GetLastError() == ERROR_INVALID_PARAMETER, "wrong error %lu\n", GetLastError());
 
     CloseHandle( handle );
-
-    handle = CreateSemaphoreA( NULL, 0, 5, NULL );
-    ok(!!handle, "CreateSemaphore failed: %lu\n", GetLastError());
-
-    ret = WaitForSingleObject( handle, 0 );
-    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
-
-    ret = ReleaseSemaphore( handle, 1, &prev );
-    ok(ret, "got error %lu\n", GetLastError());
-    ok(prev == 0, "got prev %ld\n", prev);
-
-    ret = ReleaseSemaphore( handle, 1, &prev );
-    ok(ret, "got error %lu\n", GetLastError());
-    ok(prev == 1, "got prev %ld\n", prev);
-
-    ret = ReleaseSemaphore( handle, 5, &prev );
-    ok(!ret, "got %ld\n", ret);
-    ok(GetLastError() == ERROR_TOO_MANY_POSTS, "got error %lu\n", GetLastError());
-    ok(prev == 1, "got prev %ld\n", prev);
-
-    ret = ReleaseSemaphore( handle, 2, &prev );
-    ok(ret, "got error %lu\n", GetLastError());
-    ok(prev == 2, "got prev %ld\n", prev);
-
-    ret = ReleaseSemaphore( handle, 1, &prev );
-    ok(ret, "got error %lu\n", GetLastError());
-    ok(prev == 4, "got prev %ld\n", prev);
-
-    for (i = 0; i < 5; i++)
-    {
-        ret = WaitForSingleObject( handle, 0 );
-        ok(ret == 0, "got %lu\n", ret);
-    }
-
-    ret = WaitForSingleObject( handle, 0 );
-    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
-
-    handle2 = CreateSemaphoreA( NULL, 3, 5, NULL );
-    ok(!!handle2, "CreateSemaphore failed: %lu\n", GetLastError());
-
-    ret = ReleaseSemaphore( handle2, 1, &prev );
-    ok(ret, "got error %lu\n", GetLastError());
-    ok(prev == 3, "got prev %ld\n", prev);
-
-    for (i = 0; i < 4; i++)
-    {
-        ret = WaitForSingleObject( handle2, 0 );
-        ok(ret == 0, "got %lu\n", ret);
-    }
-
-    ret = WaitForSingleObject( handle2, 0 );
-    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
-
-    handles[0] = handle;
-    handles[1] = handle2;
-
-    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
-    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
-
-    ReleaseSemaphore( handle, 1, NULL );
-    ReleaseSemaphore( handle2, 1, NULL );
-
-    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
-    ok(ret == 0, "got %lu\n", ret);
-
-    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
-    ok(ret == 1, "got %lu\n", ret);
-
-    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
-    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
-
-    ReleaseSemaphore( handle, 1, NULL );
-    ReleaseSemaphore( handle2, 1, NULL );
-
-    ret = WaitForMultipleObjects( 2, handles, TRUE, 0 );
-    ok(ret == 0, "got %lu\n", ret);
-
-    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
-    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
-
-    ReleaseSemaphore( handle, 1, NULL );
-
-    ret = WaitForMultipleObjects( 2, handles, TRUE, 0 );
-    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
-
-    ret = WaitForSingleObject( handle, 0 );
-    ok(ret == 0, "got %lu\n", ret);
-
-    ret = CloseHandle( handle );
-    ok(ret, "got error %lu\n", ret);
-
-    ret = CloseHandle( handle2 );
-    ok(ret, "got error %lu\n", ret);
 }
 
 static void test_waitable_timer(void)
@@ -1530,15 +1220,11 @@
     return ULongToHandle(tmp);
 }
 
-#define TIMEOUT_INFINITE (((LONGLONG)0x7fffffff) << 32 | 0xffffffff)
-
 static void test_WaitForSingleObject(void)
 {
     HANDLE signaled, nonsignaled, invalid;
-    LARGE_INTEGER ntnow, ntthen;
     LARGE_INTEGER timeout;
     NTSTATUS status;
-    DWORD now, then;
     DWORD ret;
 
     signaled = CreateEventW(NULL, TRUE, TRUE, NULL);
@@ -1623,68 +1309,6 @@
     status = pNtWaitForSingleObject(GetCurrentThread(), FALSE, &timeout);
     ok(status == STATUS_TIMEOUT, "expected STATUS_TIMEOUT, got %08lx\n", status);
 
-    ret = WaitForSingleObject( signaled, 0 );
-    ok(ret == 0, "got %lu\n", ret);
-
-    ret = WaitForSingleObject( nonsignaled, 0 );
-    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
-
-    /* test that a timed wait actually does wait */
-    now = GetTickCount();
-    ret = WaitForSingleObject( nonsignaled, 100 );
-    then = GetTickCount();
-    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
-    ok(abs((then - now) - 100) < 5, "got %lu ms\n", then - now);
-
-    now = GetTickCount();
-    ret = WaitForSingleObject( signaled, 100 );
-    then = GetTickCount();
-    ok(ret == 0, "got %lu\n", ret);
-    ok(abs(then - now) < 5, "got %lu ms\n", then - now);
-
-    ret = WaitForSingleObject( signaled, INFINITE );
-    ok(ret == 0, "got %lu\n", ret);
-
-    /* test NT timeouts */
-    pNtQuerySystemTime( &ntnow );
-    timeout.QuadPart = ntnow.QuadPart + 100 * 10000;
-    status = pNtWaitForSingleObject( nonsignaled, FALSE, &timeout );
-    pNtQuerySystemTime( &ntthen );
-    ok(status == STATUS_TIMEOUT, "got %#lx\n", status);
-    ok(abs(((ntthen.QuadPart - ntnow.QuadPart) / 10000) - 100) < 5, "got %s ns\n",
-        wine_dbgstr_longlong((ntthen.QuadPart - ntnow.QuadPart) * 100));
-
-    pNtQuerySystemTime( &ntnow );
-    timeout.QuadPart = -100 * 10000;
-    status = pNtWaitForSingleObject( nonsignaled, FALSE, &timeout );
-    pNtQuerySystemTime( &ntthen );
-    ok(status == STATUS_TIMEOUT, "got %#lx\n", status);
-    ok(abs(((ntthen.QuadPart - ntnow.QuadPart) / 10000) - 100) < 5, "got %s ns\n",
-        wine_dbgstr_longlong((ntthen.QuadPart - ntnow.QuadPart) * 100));
-
-    status = pNtWaitForSingleObject( signaled, FALSE, NULL );
-    ok(status == 0, "got %#lx\n", status);
-
-    timeout.QuadPart = TIMEOUT_INFINITE;
-    status = pNtWaitForSingleObject( signaled, FALSE, &timeout );
-    ok(status == 0, "got %#lx\n", status);
-
-    pNtQuerySystemTime( &ntnow );
-    timeout.QuadPart = ntnow.QuadPart;
-    status = pNtWaitForSingleObject( nonsignaled, FALSE, &timeout );
-    pNtQuerySystemTime( &ntthen );
-    ok(status == STATUS_TIMEOUT, "got %#lx\n", status);
-    ok(abs((ntthen.QuadPart - ntnow.QuadPart) / 10000) < 5, "got %s ns\n",
-        wine_dbgstr_longlong((ntthen.QuadPart - ntnow.QuadPart) * 100));
-
-    pNtQuerySystemTime( &ntnow );
-    timeout.QuadPart = ntnow.QuadPart - 100 * 10000;
-    status = pNtWaitForSingleObject( nonsignaled, FALSE, &timeout );
-    pNtQuerySystemTime( &ntthen );
-    ok(status == STATUS_TIMEOUT, "got %#lx\n", status);
-    ok(abs((ntthen.QuadPart - ntnow.QuadPart) / 10000) < 5, "got %s ns\n",
-        wine_dbgstr_longlong((ntthen.QuadPart - ntnow.QuadPart) * 100));
-
     CloseHandle(signaled);
     CloseHandle(nonsignaled);
 }
@@ -3278,84 +2902,6 @@
     ok(apc_count == 1, "APC count %u\n", apc_count);
 }
 
-static int zigzag_state, zigzag_count[2], zigzag_stop;
-
-static DWORD CALLBACK zigzag_event0(void *arg)
-{
-    HANDLE *events = arg;
-
-    while (!zigzag_stop)
-    {
-        WaitForSingleObject(events[0], INFINITE);
-        ResetEvent(events[0]);
-        ok(zigzag_state == 0, "got wrong state %d\n", zigzag_state);
-        zigzag_state++;
-        SetEvent(events[1]);
-        zigzag_count[0]++;
-    }
-    trace("thread 0 got done\n");
-    return 0;
-}
-
-static DWORD CALLBACK zigzag_event1(void *arg)
-{
-    HANDLE *events = arg;
-
-    while (!zigzag_stop)
-    {
-        WaitForSingleObject(events[1], INFINITE);
-        ResetEvent(events[1]);
-        ok(zigzag_state == 1, "got wrong state %d\n", zigzag_state);
-        zigzag_state--;
-        SetEvent(events[0]);
-        zigzag_count[1]++;
-    }
-    trace("thread 1 got done\n");
-    return 0;
-}
-
-static void test_zigzag_event(void)
-{
-    /* The basic idea is to test SetEvent/Wait back and forth between two
-     * threads. Each thread clears their own event, sets some common data,
-     * signals the other's, then waits on their own. We make sure the common
-     * data is always in the right state. We also print performance data. */
-
-    HANDLE threads[2], events[2];
-    BOOL ret;
-
-    events[0] = CreateEventA(NULL, FALSE, FALSE, NULL);
-    events[1] = CreateEventA(NULL, FALSE, FALSE, NULL);
-
-    threads[0] = CreateThread(NULL, 0, zigzag_event0, events, 0, NULL);
-    threads[1] = CreateThread(NULL, 0, zigzag_event1, events, 0, NULL);
-
-    zigzag_state = 0;
-    zigzag_count[0] = zigzag_count[1] = 0;
-    zigzag_stop = 0;
-
-    trace("starting zigzag test (events)\n");
-    SetEvent(events[0]);
-    Sleep(2000);
-    zigzag_stop = 1;
-    ret = WaitForMultipleObjects(2, threads, FALSE, INFINITE);
-    trace("%d\n", ret);
-    ok(ret == 0 || ret == 1, "wait failed: %u\n", ret);
-
-    ok(zigzag_count[0] == zigzag_count[1] || zigzag_count[0] == zigzag_count[1] + 1,
-        "count did not match: %d != %d\n", zigzag_count[0], zigzag_count[1]);
-
-    /* signal the other thread to finish, if it didn't already
-     * (in theory they both would at the same time, but there's a slight race on teardown if we get
-     * thread 1 SetEvent -> thread 0 ResetEvent -> thread 0 Wait -> thread 1 exits */
-    zigzag_state = 1-ret;
-    SetEvent(events[1-ret]);
-    ret = WaitForSingleObject(threads[1-ret], 1000);
-    ok(!ret, "wait failed: %u\n", ret);
-
-    trace("count: %d\n", zigzag_count[0]);
-}
-
 START_TEST(sync)
 {
     char **argv;
@@ -3382,7 +2928,6 @@
     pTryAcquireSRWLockShared = (void *)GetProcAddress(hdll, "TryAcquireSRWLockShared");
     pNtAllocateVirtualMemory = (void *)GetProcAddress(hntdll, "NtAllocateVirtualMemory");
     pNtFreeVirtualMemory = (void *)GetProcAddress(hntdll, "NtFreeVirtualMemory");
-    pNtQuerySystemTime = (void *)GetProcAddress(hntdll, "NtQuerySystemTime");
     pNtWaitForSingleObject = (void *)GetProcAddress(hntdll, "NtWaitForSingleObject");
     pNtWaitForMultipleObjects = (void *)GetProcAddress(hntdll, "NtWaitForMultipleObjects");
     pRtlInterlockedPushListSList = (void *)GetProcAddress(hntdll, "RtlInterlockedPushListSList");
@@ -3427,6 +2972,5 @@
     test_srwlock_example();
     test_alertable_wait();
     test_apc_deadlock();
-    test_zigzag_event();
     test_crit_section();
 }
diff --color -u -r -N a/dlls/ntdll/Makefile.in b/dlls/ntdll/Makefile.in
--- a/dlls/ntdll/Makefile.in	2025-04-11 19:05:01.164051360 +0500
+++ b/dlls/ntdll/Makefile.in	2025-04-11 19:10:51.766675863 +0500
@@ -49,7 +49,6 @@
 	unix/cdrom.c \
 	unix/debug.c \
 	unix/env.c \
-	unix/esync.c \
 	unix/file.c \
 	unix/loader.c \
 	unix/loadorder.c \
diff --color -r -u -N a/dlls/ntdll/unix/esync.c b/dlls/ntdll/unix/esync.c
--- a/dlls/ntdll/unix/esync.c	2025-02-26 17:47:50.925968525 +0500
+++ b/dlls/ntdll/unix/esync.c	1970-01-01 05:00:00.000000000 +0500
@@ -1,1337 +0,0 @@
-/*
- * eventfd-based synchronization objects
- *
- * Copyright (C) 2018 Zebediah Figura
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#if 0
-#pragma makedep unix
-#endif
-
-#include "config.h"
-
-#ifndef _GNU_SOURCE
-#define _GNU_SOURCE
-#endif
-
-#include <assert.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <stdarg.h>
-#include <stdint.h>
-#include <stdlib.h>
-#include <sys/mman.h>
-#ifdef HAVE_SYS_STAT_H
-# include <sys/stat.h>
-#endif
-#include <poll.h>
-#include <sys/types.h>
-#include <unistd.h>
-
-#include "ntstatus.h"
-#define WIN32_NO_STATUS
-#include "windef.h"
-#include "winternl.h"
-#include "wine/server.h"
-#include "wine/debug.h"
-
-#include "unix_private.h"
-#include "esync.h"
-
-WINE_DEFAULT_DEBUG_CHANNEL(esync);
-
-int do_esync(void)
-{
-#ifdef HAVE_SYS_EVENTFD_H
-    static int do_esync_cached = -1;
-
-    if (do_esync_cached == -1)
-        do_esync_cached = getenv("WINEESYNC") && atoi(getenv("WINEESYNC"));
-
-    return do_esync_cached;
-#else
-    static int once;
-    if (!once++)
-        FIXME("eventfd not supported on this platform.\n");
-    return 0;
-#endif
-}
-
-struct esync
-{
-    LONG type;
-    int fd;
-    void *shm;
-};
-
-struct semaphore
-{
-    LONG max;
-    LONG count;
-};
-C_ASSERT(sizeof(struct semaphore) == 8);
-
-struct mutex
-{
-    LONG tid;
-    LONG count;    /* recursion count */
-};
-C_ASSERT(sizeof(struct mutex) == 8);
-
-struct event
-{
-    LONG signaled;
-    LONG locked;
-};
-C_ASSERT(sizeof(struct event) == 8);
-
-static char shm_name[29];
-static int shm_fd;
-static void **shm_addrs;
-static int shm_addrs_size;  /* length of the allocated shm_addrs array */
-static long pagesize;
-
-static pthread_mutex_t shm_addrs_mutex = PTHREAD_MUTEX_INITIALIZER;
-
-static void *get_shm( unsigned int idx )
-{
-    int entry  = (idx * 8) / pagesize;
-    int offset = (idx * 8) % pagesize;
-    void *ret;
-
-    pthread_mutex_lock( &shm_addrs_mutex );
-
-    if (entry >= shm_addrs_size)
-    {
-        int new_size = max(shm_addrs_size * 2, entry + 1);
-
-        if (!(shm_addrs = realloc( shm_addrs, new_size * sizeof(shm_addrs[0]) )))
-            ERR("Failed to grow shm_addrs array to size %d.\n", shm_addrs_size);
-        memset( shm_addrs + shm_addrs_size, 0, (new_size - shm_addrs_size) * sizeof(shm_addrs[0]) );
-        shm_addrs_size = new_size;
-    }
-
-    if (!shm_addrs[entry])
-    {
-        void *addr = mmap( NULL, pagesize, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, entry * pagesize );
-        if (addr == (void *)-1)
-            ERR("Failed to map page %d (offset %#lx).\n", entry, entry * pagesize);
-
-        TRACE("Mapping page %d at %p.\n", entry, addr);
-
-        if (InterlockedCompareExchangePointer( &shm_addrs[entry], addr, 0 ))
-            munmap( addr, pagesize ); /* someone beat us to it */
-    }
-
-    ret = (void *)((unsigned long)shm_addrs[entry] + offset);
-
-    pthread_mutex_unlock( &shm_addrs_mutex );
-
-    return ret;
-}
-
-/* We'd like lookup to be fast. To that end, we use a static list indexed by handle.
- * This is copied and adapted from the fd cache code. */
-
-#define ESYNC_LIST_BLOCK_SIZE  (65536 / sizeof(struct esync))
-#define ESYNC_LIST_ENTRIES     256
-
-static struct esync *esync_list[ESYNC_LIST_ENTRIES];
-static struct esync esync_list_initial_block[ESYNC_LIST_BLOCK_SIZE];
-
-static inline UINT_PTR handle_to_index( HANDLE handle, UINT_PTR *entry )
-{
-    UINT_PTR idx = (((UINT_PTR)handle) >> 2) - 1;
-    *entry = idx / ESYNC_LIST_BLOCK_SIZE;
-    return idx % ESYNC_LIST_BLOCK_SIZE;
-}
-
-static struct esync *add_to_list( HANDLE handle, enum esync_type type, int fd, void *shm )
-{
-    UINT_PTR entry, idx = handle_to_index( handle, &entry );
-
-    if (entry >= ESYNC_LIST_ENTRIES)
-    {
-        FIXME( "too many allocated handles, not caching %p\n", handle );
-        return FALSE;
-    }
-
-    if (!esync_list[entry])  /* do we need to allocate a new block of entries? */
-    {
-        if (!entry) esync_list[0] = esync_list_initial_block;
-        else
-        {
-            void *ptr = anon_mmap_alloc( ESYNC_LIST_BLOCK_SIZE * sizeof(struct esync),
-                                         PROT_READ | PROT_WRITE );
-            if (ptr == MAP_FAILED) return FALSE;
-            esync_list[entry] = ptr;
-        }
-    }
-
-    if (!InterlockedCompareExchange( &esync_list[entry][idx].type, type, 0 ))
-    {
-        esync_list[entry][idx].fd = fd;
-        esync_list[entry][idx].shm = shm;
-    }
-    return &esync_list[entry][idx];
-}
-
-static struct esync *get_cached_object( HANDLE handle )
-{
-    UINT_PTR entry, idx = handle_to_index( handle, &entry );
-
-    if (entry >= ESYNC_LIST_ENTRIES || !esync_list[entry]) return NULL;
-    if (!esync_list[entry][idx].type) return NULL;
-
-    return &esync_list[entry][idx];
-}
-
-/* Gets an object. This is either a proper esync object (i.e. an event,
- * semaphore, etc. created using create_esync) or a generic synchronizable
- * server-side object which the server will signal (e.g. a process, thread,
- * message queue, etc.) */
-static NTSTATUS get_object( HANDLE handle, struct esync **obj )
-{
-    int ret = STATUS_SUCCESS;
-    enum esync_type type = 0;
-    unsigned int shm_idx = 0;
-    obj_handle_t fd_handle;
-    sigset_t sigset;
-    int fd = -1;
-
-    if ((*obj = get_cached_object( handle ))) return STATUS_SUCCESS;
-
-    if ((INT_PTR)handle < 0)
-    {
-        /* We can deal with pseudo-handles, but it's just easier this way */
-        return STATUS_NOT_IMPLEMENTED;
-    }
-
-    if (!handle)
-    {
-        /* Shadow of the Tomb Raider really likes passing in NULL handles to
-         * various functions. Concerning, but let's avoid a server call. */
-        return STATUS_INVALID_HANDLE;
-    }
-
-    /* We need to try grabbing it from the server. */
-    server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
-    if (!(*obj = get_cached_object( handle )))
-    {
-        SERVER_START_REQ( get_esync_fd )
-        {
-            req->handle = wine_server_obj_handle( handle );
-            if (!(ret = wine_server_call( req )))
-            {
-                type = reply->type;
-                shm_idx = reply->shm_idx;
-                fd = receive_fd( &fd_handle );
-                assert( wine_server_ptr_handle(fd_handle) == handle );
-            }
-        }
-        SERVER_END_REQ;
-    }
-    server_leave_uninterrupted_section( &fd_cache_mutex, &sigset );
-
-    if (*obj)
-    {
-        /* We managed to grab it while in the CS; return it. */
-        return STATUS_SUCCESS;
-    }
-
-    if (ret)
-    {
-        WARN("Failed to retrieve fd for handle %p, status %#x.\n", handle, ret);
-        *obj = NULL;
-        return ret;
-    }
-
-    TRACE("Got fd %d for handle %p.\n", fd, handle);
-
-    *obj = add_to_list( handle, type, fd, shm_idx ? get_shm( shm_idx ) : 0 );
-    return ret;
-}
-
-NTSTATUS esync_close( HANDLE handle )
-{
-    UINT_PTR entry, idx = handle_to_index( handle, &entry );
-
-    TRACE("%p.\n", handle);
-
-    if (entry < ESYNC_LIST_ENTRIES && esync_list[entry])
-    {
-        if (InterlockedExchange(&esync_list[entry][idx].type, 0))
-        {
-            close( esync_list[entry][idx].fd );
-            return STATUS_SUCCESS;
-        }
-    }
-
-    return STATUS_INVALID_HANDLE;
-}
-
-static NTSTATUS create_esync( enum esync_type type, HANDLE *handle, ACCESS_MASK access,
-                              const OBJECT_ATTRIBUTES *attr, int initval, int max )
-{
-    NTSTATUS ret;
-    data_size_t len;
-    struct object_attributes *objattr;
-    obj_handle_t fd_handle;
-    unsigned int shm_idx;
-    sigset_t sigset;
-    int fd;
-
-    if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
-
-    /* We have to synchronize on the fd cache CS so that our calls to
-     * receive_fd don't race with theirs. */
-    server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
-    SERVER_START_REQ( create_esync )
-    {
-        req->access  = access;
-        req->initval = initval;
-        req->type    = type;
-        req->max     = max;
-        wine_server_add_data( req, objattr, len );
-        ret = wine_server_call( req );
-        if (!ret || ret == STATUS_OBJECT_NAME_EXISTS)
-        {
-            *handle = wine_server_ptr_handle( reply->handle );
-            type = reply->type;
-            shm_idx = reply->shm_idx;
-            fd = receive_fd( &fd_handle );
-            assert( wine_server_ptr_handle(fd_handle) == *handle );
-        }
-    }
-    SERVER_END_REQ;
-    server_leave_uninterrupted_section( &fd_cache_mutex, &sigset );
-
-    if (!ret || ret == STATUS_OBJECT_NAME_EXISTS)
-    {
-        add_to_list( *handle, type, fd, shm_idx ? get_shm( shm_idx ) : 0 );
-        TRACE("-> handle %p, fd %d.\n", *handle, fd);
-    }
-
-    free( objattr );
-    return ret;
-}
-
-static NTSTATUS open_esync( enum esync_type type, HANDLE *handle,
-    ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr )
-{
-    NTSTATUS ret;
-    obj_handle_t fd_handle;
-    unsigned int shm_idx;
-    sigset_t sigset;
-    int fd;
-
-    server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
-    SERVER_START_REQ( open_esync )
-    {
-        req->access     = access;
-        req->attributes = attr->Attributes;
-        req->rootdir    = wine_server_obj_handle( attr->RootDirectory );
-        req->type       = type;
-        if (attr->ObjectName)
-            wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
-        if (!(ret = wine_server_call( req )))
-        {
-            *handle = wine_server_ptr_handle( reply->handle );
-            type = reply->type;
-            shm_idx = reply->shm_idx;
-            fd = receive_fd( &fd_handle );
-            assert( wine_server_ptr_handle(fd_handle) == *handle );
-        }
-    }
-    SERVER_END_REQ;
-    server_leave_uninterrupted_section( &fd_cache_mutex, &sigset );
-
-    if (!ret)
-    {
-        add_to_list( *handle, type, fd, shm_idx ? get_shm( shm_idx ) : 0 );
-
-        TRACE("-> handle %p, fd %d.\n", *handle, fd);
-    }
-    return ret;
-}
-
-extern NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
-    const OBJECT_ATTRIBUTES *attr, int initial, int max)
-{
-    TRACE("name %s, initial %d, max %d.\n",
-        attr ? debugstr_us(attr->ObjectName) : "<no name>", initial, max);
-
-    return create_esync( ESYNC_SEMAPHORE, handle, access, attr, initial, max );
-}
-
-NTSTATUS esync_open_semaphore( HANDLE *handle, ACCESS_MASK access,
-    const OBJECT_ATTRIBUTES *attr )
-{
-    TRACE("name %s.\n", debugstr_us(attr->ObjectName));
-
-    return open_esync( ESYNC_SEMAPHORE, handle, access, attr );
-}
-
-NTSTATUS esync_release_semaphore( HANDLE handle, unsigned int count, ULONG *prev )
-{
-    struct esync *obj;
-    struct semaphore *semaphore;
-    uint64_t count64 = count;
-    ULONG current;
-    NTSTATUS ret;
-
-    TRACE("%p, %d, %p.\n", handle, count, prev);
-
-    if ((ret = get_object( handle, &obj))) return ret;
-    semaphore = obj->shm;
-
-    do
-    {
-        current = semaphore->count;
-
-        if (count + current > semaphore->max)
-            return STATUS_SEMAPHORE_LIMIT_EXCEEDED;
-    } while (InterlockedCompareExchange( &semaphore->count, count + current, current ) != current);
-
-    if (prev) *prev = current;
-
-    /* We don't have to worry about a race between increasing the count and
-     * write(). The fact that we were able to increase the count means that we
-     * have permission to actually write that many releases to the semaphore. */
-
-    if (write( obj->fd, &count64, sizeof(count64) ) == -1)
-        return errno_to_status( errno );
-
-    return STATUS_SUCCESS;
-}
-
-NTSTATUS esync_query_semaphore( HANDLE handle, void *info, ULONG *ret_len )
-{
-    struct esync *obj;
-    struct semaphore *semaphore;
-    SEMAPHORE_BASIC_INFORMATION *out = info;
-    NTSTATUS ret;
-
-    TRACE("handle %p, info %p, ret_len %p.\n", handle, info, ret_len);
-
-    if ((ret = get_object( handle, &obj ))) return ret;
-    semaphore = obj->shm;
-
-    out->CurrentCount = semaphore->count;
-    out->MaximumCount = semaphore->max;
-    if (ret_len) *ret_len = sizeof(*out);
-
-    return STATUS_SUCCESS;
-}
-
-NTSTATUS esync_create_event( HANDLE *handle, ACCESS_MASK access,
-    const OBJECT_ATTRIBUTES *attr, EVENT_TYPE event_type, BOOLEAN initial )
-{
-    enum esync_type type = (event_type == SynchronizationEvent ? ESYNC_AUTO_EVENT : ESYNC_MANUAL_EVENT);
-
-    TRACE("name %s, %s-reset, initial %d.\n",
-        attr ? debugstr_us(attr->ObjectName) : "<no name>",
-        event_type == NotificationEvent ? "manual" : "auto", initial);
-
-    return create_esync( type, handle, access, attr, initial, 0 );
-}
-
-NTSTATUS esync_open_event( HANDLE *handle, ACCESS_MASK access,
-    const OBJECT_ATTRIBUTES *attr )
-{
-    TRACE("name %s.\n", debugstr_us(attr->ObjectName));
-
-    return open_esync( ESYNC_AUTO_EVENT, handle, access, attr ); /* doesn't matter which */
-}
-
-static inline void small_pause(void)
-{
-#ifdef __i386__
-    __asm__ __volatile__( "rep;nop" : : : "memory" );
-#else
-    __asm__ __volatile__( "" : : : "memory" );
-#endif
-}
-
-/* Manual-reset events are actually racier than other objects in terms of shm
- * state. With other objects, races don't matter, because we only treat the shm
- * state as a hint that lets us skip poll()â€”we still have to read(). But with
- * manual-reset events we don't, which means that the shm state can be out of
- * sync with the actual state.
- *
- * In general we shouldn't have to worry about races between modifying the
- * event and waiting on it. If the state changes while we're waiting, it's
- * equally plausible that we caught it before or after the state changed.
- * However, we can have races between SetEvent() and ResetEvent(), so that the
- * event has inconsistent internal state.
- *
- * To solve this we have to use the other field to lock the event. Currently
- * this is implemented as a spinlock, but I'm not sure if a futex might be
- * better. I'm also not sure if it's possible to obviate locking by arranging
- * writes and reads in a certain way.
- *
- * Note that we don't have to worry about locking in esync_wait_objects().
- * There's only two general patterns:
- *
- * WaitFor()    SetEvent()
- * -------------------------
- * read()
- * signaled = 0
- *              signaled = 1
- *              write()
- * -------------------------
- * read()
- *              signaled = 1
- * signaled = 0
- *              <no write(), because it was already signaled>
- * -------------------------
- *
- * That is, if SetEvent() tries to signal the event before WaitFor() resets its
- * signaled state, it won't bother trying to write(), and then the signaled
- * state will be reset, so the result is a consistent non-signaled event.
- * There's several variations to this pattern but all of them are protected in
- * the same way. Note however this is why we have to use interlocked_xchg()
- * event inside of the lock.
- */
-
-/* Removing this spinlock is harder than it looks. esync_wait_objects() can
- * deal with inconsistent state well enough, and a race between SetEvent() and
- * ResetEvent() gives us license to yield either result as long as we act
- * consistently, but that's not enough. Notably, esync_wait_objects() should
- * probably act like a fence, so that the second half of esync_set_event() does
- * not seep past a subsequent reset. That's one problem, but no guarantee there
- * aren't others. */
-
-NTSTATUS esync_set_event( HANDLE handle )
-{
-    static const uint64_t value = 1;
-    struct esync *obj;
-    struct event *event;
-    NTSTATUS ret;
-
-    TRACE("%p.\n", handle);
-
-    if ((ret = get_object( handle, &obj ))) return ret;
-    event = obj->shm;
-
-    if (obj->type == ESYNC_MANUAL_EVENT)
-    {
-        /* Acquire the spinlock. */
-        while (InterlockedCompareExchange( &event->locked, 1, 0 ))
-            small_pause();
-    }
-
-    /* For manual-reset events, as long as we're in a lock, we can take the
-     * optimization of only calling write() if the event wasn't already
-     * signaled.
-     *
-     * For auto-reset events, esync_wait_objects() must grab the kernel object.
-     * Thus if we got into a race so that the shm state is signaled but the
-     * eventfd is unsignaled (i.e. reset shm, set shm, set fd, reset fd), we
-     * *must* signal the fd now, or any waiting threads will never wake up. */
-
-    if (!InterlockedExchange( &event->signaled, 1 ) || obj->type == ESYNC_AUTO_EVENT)
-    {
-        if (write( obj->fd, &value, sizeof(value) ) == -1)
-            ERR("write: %s\n", strerror(errno));
-    }
-
-    if (obj->type == ESYNC_MANUAL_EVENT)
-    {
-        /* Release the spinlock. */
-        event->locked = 0;
-    }
-
-    return STATUS_SUCCESS;
-}
-
-NTSTATUS esync_reset_event( HANDLE handle )
-{
-    uint64_t value;
-    struct esync *obj;
-    struct event *event;
-    NTSTATUS ret;
-
-    TRACE("%p.\n", handle);
-
-    if ((ret = get_object( handle, &obj ))) return ret;
-    event = obj->shm;
-
-    if (obj->type == ESYNC_MANUAL_EVENT)
-    {
-        /* Acquire the spinlock. */
-        while (InterlockedCompareExchange( &event->locked, 1, 0 ))
-            small_pause();
-    }
-
-    /* For manual-reset events, as long as we're in a lock, we can take the
-     * optimization of only calling read() if the event was already signaled.
-     *
-     * For auto-reset events, we have no guarantee that the previous "signaled"
-     * state is actually correct. We need to leave both states unsignaled after
-     * leaving this function, so we always have to read(). */
-    if (InterlockedExchange( &event->signaled, 0 ) || obj->type == ESYNC_AUTO_EVENT)
-    {
-        if (read( obj->fd, &value, sizeof(value) ) == -1 && errno != EWOULDBLOCK && errno != EAGAIN)
-        {
-            ERR("read: %s\n", strerror(errno));
-        }
-    }
-
-    if (obj->type == ESYNC_MANUAL_EVENT)
-    {
-        /* Release the spinlock. */
-        event->locked = 0;
-    }
-
-    return STATUS_SUCCESS;
-}
-
-NTSTATUS esync_pulse_event( HANDLE handle )
-{
-    uint64_t value = 1;
-    struct esync *obj;
-    NTSTATUS ret;
-
-    TRACE("%p.\n", handle);
-
-    if ((ret = get_object( handle, &obj ))) return ret;
-
-    /* This isn't really correct; an application could miss the write.
-     * Unfortunately we can't really do much better. Fortunately this is rarely
-     * used (and publicly deprecated). */
-    if (write( obj->fd, &value, sizeof(value) ) == -1)
-        return errno_to_status( errno );
-
-    /* Try to give other threads a chance to wake up. Hopefully erring on this
-     * side is the better thing to do... */
-    NtYieldExecution();
-
-    read( obj->fd, &value, sizeof(value) );
-
-    return STATUS_SUCCESS;
-}
-
-NTSTATUS esync_query_event( HANDLE handle, void *info, ULONG *ret_len )
-{
-    struct esync *obj;
-    EVENT_BASIC_INFORMATION *out = info;
-    struct pollfd fd;
-    NTSTATUS ret;
-
-    TRACE("handle %p, info %p, ret_len %p.\n", handle, info, ret_len);
-
-    if ((ret = get_object( handle, &obj ))) return ret;
-
-    fd.fd = obj->fd;
-    fd.events = POLLIN;
-    out->EventState = poll( &fd, 1, 0 );
-    out->EventType = (obj->type == ESYNC_AUTO_EVENT ? SynchronizationEvent : NotificationEvent);
-    if (ret_len) *ret_len = sizeof(*out);
-
-    return STATUS_SUCCESS;
-}
-
-NTSTATUS esync_create_mutex( HANDLE *handle, ACCESS_MASK access,
-    const OBJECT_ATTRIBUTES *attr, BOOLEAN initial )
-{
-    TRACE("name %s, initial %d.\n",
-        attr ? debugstr_us(attr->ObjectName) : "<no name>", initial);
-
-    return create_esync( ESYNC_MUTEX, handle, access, attr, initial ? 0 : 1, 0 );
-}
-
-NTSTATUS esync_open_mutex( HANDLE *handle, ACCESS_MASK access,
-    const OBJECT_ATTRIBUTES *attr )
-{
-    TRACE("name %s.\n", debugstr_us(attr->ObjectName));
-
-    return open_esync( ESYNC_MUTEX, handle, access, attr );
-}
-
-NTSTATUS esync_release_mutex( HANDLE *handle, LONG *prev )
-{
-    struct esync *obj;
-    struct mutex *mutex;
-    static const uint64_t value = 1;
-    NTSTATUS ret;
-
-    TRACE("%p, %p.\n", handle, prev);
-
-    if ((ret = get_object( handle, &obj ))) return ret;
-    mutex = obj->shm;
-
-    /* This is thread-safe, because the only thread that can change the tid to
-     * or from our tid is ours. */
-    if (mutex->tid != GetCurrentThreadId()) return STATUS_MUTANT_NOT_OWNED;
-
-    if (prev) *prev = mutex->count;
-
-    mutex->count--;
-
-    if (!mutex->count)
-    {
-        /* This is also thread-safe, as long as signaling the file is the last
-         * thing we do. Other threads don't care about the tid if it isn't
-         * theirs. */
-        mutex->tid = 0;
-
-        if (write( obj->fd, &value, sizeof(value) ) == -1)
-            return errno_to_status( errno );
-    }
-
-    return STATUS_SUCCESS;
-}
-
-NTSTATUS esync_query_mutex( HANDLE handle, void *info, ULONG *ret_len )
-{
-    struct esync *obj;
-    struct mutex *mutex;
-    MUTANT_BASIC_INFORMATION *out = info;
-    NTSTATUS ret;
-
-    TRACE("handle %p, info %p, ret_len %p.\n", handle, info, ret_len);
-
-    if ((ret = get_object( handle, &obj ))) return ret;
-    mutex = obj->shm;
-
-    out->CurrentCount = 1 - mutex->count;
-    out->OwnedByCaller = (mutex->tid == GetCurrentThreadId());
-    out->AbandonedState = (mutex->tid == ~0);
-    if (ret_len) *ret_len = sizeof(*out);
-
-    return STATUS_SUCCESS;
-}
-
-#define TICKSPERSEC        10000000
-#define TICKSPERMSEC       10000
-
-static LONGLONG update_timeout( ULONGLONG end )
-{
-    LARGE_INTEGER now;
-    LONGLONG timeleft;
-
-    NtQuerySystemTime( &now );
-    timeleft = end - now.QuadPart;
-    if (timeleft < 0) timeleft = 0;
-    return timeleft;
-}
-
-static int do_poll( struct pollfd *fds, nfds_t nfds, ULONGLONG *end )
-{
-    int ret;
-
-    do
-    {
-        if (end)
-        {
-            LONGLONG timeleft = update_timeout( *end );
-
-#ifdef HAVE_PPOLL
-            /* We use ppoll() if available since the time granularity is better. */
-            struct timespec tmo_p;
-            tmo_p.tv_sec = timeleft / (ULONGLONG)TICKSPERSEC;
-            tmo_p.tv_nsec = (timeleft % TICKSPERSEC) * 100;
-            ret = ppoll( fds, nfds, &tmo_p, NULL );
-#else
-            ret = poll( fds, nfds, timeleft / TICKSPERMSEC );
-#endif
-        }
-        else
-            ret = poll( fds, nfds, -1 );
-
-    /* If we receive EINTR we were probably suspended (SIGUSR1), possibly for a
-     * system APC. The right thing to do is just try again. */
-    } while (ret < 0 && errno == EINTR);
-
-    return ret;
-}
-
-/* Return TRUE if abandoned. */
-static BOOL update_grabbed_object( struct esync *obj )
-{
-    BOOL ret = FALSE;
-
-    if (obj->type == ESYNC_MUTEX)
-    {
-        struct mutex *mutex = obj->shm;
-        /* We don't have to worry about a race between this and read(); the
-         * fact that we grabbed it means the count is now zero, so nobody else
-         * can (and the only thread that can release it is us). */
-        if (mutex->tid == ~0)
-            ret = TRUE;
-        mutex->tid = GetCurrentThreadId();
-        mutex->count++;
-    }
-    else if (obj->type == ESYNC_SEMAPHORE)
-    {
-        struct semaphore *semaphore = obj->shm;
-        /* We don't have to worry about a race between this and read(); the
-         * fact that we were able to grab it at all means the count is nonzero,
-         * and if someone else grabbed it then the count must have been >= 2,
-         * etc. */
-        InterlockedExchangeAdd( &semaphore->count, -1 );
-    }
-    else if (obj->type == ESYNC_AUTO_EVENT)
-    {
-        struct event *event = obj->shm;
-        /* We don't have to worry about a race between this and read(), since
-         * this is just a hint, and the real state is in the kernel object.
-         * This might already be 0, but that's okay! */
-        event->signaled = 0;
-    }
-
-    return ret;
-}
-
-/* A value of STATUS_NOT_IMPLEMENTED returned from this function means that we
- * need to delegate to server_select(). */
-static NTSTATUS __esync_wait_objects( unsigned int count, const HANDLE *handles, BOOLEAN wait_any,
-                             BOOLEAN alertable, const LARGE_INTEGER *timeout )
-{
-    static const LARGE_INTEGER zero;
-
-    struct esync *objs[MAXIMUM_WAIT_OBJECTS];
-    struct pollfd fds[MAXIMUM_WAIT_OBJECTS + 1];
-    int has_esync = 0, has_server = 0;
-    BOOL msgwait = FALSE;
-    LONGLONG timeleft;
-    LARGE_INTEGER now;
-    DWORD pollcount;
-    ULONGLONG end;
-    int64_t value;
-    ssize_t size;
-    int i, j, ret;
-
-    /* Grab the APC fd if we don't already have it. */
-    if (alertable && ntdll_get_thread_data()->esync_apc_fd == -1)
-    {
-        obj_handle_t fd_handle;
-        sigset_t sigset;
-        int fd = -1;
-
-        server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
-        SERVER_START_REQ( get_esync_apc_fd )
-        {
-            if (!(ret = wine_server_call( req )))
-            {
-                fd = receive_fd( &fd_handle );
-                assert( fd_handle == GetCurrentThreadId() );
-            }
-        }
-        SERVER_END_REQ;
-        server_leave_uninterrupted_section( &fd_cache_mutex, &sigset );
-
-        ntdll_get_thread_data()->esync_apc_fd = fd;
-    }
-
-    NtQuerySystemTime( &now );
-    if (timeout)
-    {
-        if (timeout->QuadPart == TIMEOUT_INFINITE)
-            timeout = NULL;
-        else if (timeout->QuadPart >= 0)
-            end = timeout->QuadPart;
-        else
-            end = now.QuadPart - timeout->QuadPart;
-    }
-
-    for (i = 0; i < count; i++)
-    {
-        ret = get_object( handles[i], &objs[i] );
-        if (ret == STATUS_SUCCESS)
-            has_esync = 1;
-        else if (ret == STATUS_NOT_IMPLEMENTED)
-            has_server = 1;
-        else
-            return ret;
-    }
-
-    if (objs[count - 1] && objs[count - 1]->type == ESYNC_QUEUE)
-        msgwait = TRUE;
-
-    if (has_esync && has_server)
-        FIXME("Can't wait on esync and server objects at the same time!\n");
-    else if (has_server)
-        return STATUS_NOT_IMPLEMENTED;
-
-    if (TRACE_ON(esync))
-    {
-        TRACE("Waiting for %s of %d handles:", wait_any ? "any" : "all", count);
-        for (i = 0; i < count; i++)
-            TRACE(" %p", handles[i]);
-
-        if (msgwait)
-            TRACE(" or driver events");
-        if (alertable)
-            TRACE(", alertable");
-
-        if (!timeout)
-            TRACE(", timeout = INFINITE.\n");
-        else
-        {
-            timeleft = update_timeout( end );
-            TRACE(", timeout = %ld.%07ld sec.\n",
-                (long) timeleft / TICKSPERSEC, (long) timeleft % TICKSPERSEC);
-        }
-    }
-
-    if (wait_any || count == 1)
-    {
-        /* Try to check objects now, so we can obviate poll() at least. */
-        for (i = 0; i < count; i++)
-        {
-            struct esync *obj = objs[i];
-
-            if (obj)
-            {
-                switch (obj->type)
-                {
-                case ESYNC_MUTEX:
-                {
-                    struct mutex *mutex = obj->shm;
-
-                    if (mutex->tid == GetCurrentThreadId())
-                    {
-                        TRACE("Woken up by handle %p [%d].\n", handles[i], i);
-                        mutex->count++;
-                        return i;
-                    }
-                    else if (!mutex->count)
-                    {
-                        if ((size = read( obj->fd, &value, sizeof(value) )) == sizeof(value))
-                        {
-                            if (mutex->tid == ~0)
-                            {
-                                TRACE("Woken up by abandoned mutex %p [%d].\n", handles[i], i);
-                                i += STATUS_ABANDONED_WAIT_0;
-                            }
-                            else
-                                TRACE("Woken up by handle %p [%d].\n", handles[i], i);
-                            mutex->tid = GetCurrentThreadId();
-                            mutex->count++;
-                            return i;
-                        }
-                    }
-                    break;
-                }
-                case ESYNC_SEMAPHORE:
-                {
-                    struct semaphore *semaphore = obj->shm;
-
-                    if (semaphore->count)
-                    {
-                        if ((size = read( obj->fd, &value, sizeof(value) )) == sizeof(value))
-                        {
-                            TRACE("Woken up by handle %p [%d].\n", handles[i], i);
-                            InterlockedDecrement( &semaphore->count );
-                            return i;
-                        }
-                    }
-                    break;
-                }
-                case ESYNC_AUTO_EVENT:
-                {
-                    struct event *event = obj->shm;
-
-                    if (event->signaled)
-                    {
-                        if ((size = read( obj->fd, &value, sizeof(value) )) == sizeof(value))
-                        {
-                            TRACE("Woken up by handle %p [%d].\n", handles[i], i);
-                            event->signaled = 0;
-                            return i;
-                        }
-                    }
-                    break;
-                }
-                case ESYNC_MANUAL_EVENT:
-                {
-                    struct event *event = obj->shm;
-
-                    if (event->signaled)
-                    {
-                        TRACE("Woken up by handle %p [%d].\n", handles[i], i);
-                        return i;
-                    }
-                    break;
-                }
-                case ESYNC_AUTO_SERVER:
-                case ESYNC_MANUAL_SERVER:
-                case ESYNC_QUEUE:
-                    /* We can't wait on any of these. Fortunately I don't think
-                     * they'll ever be uncontended anyway (at least, they won't be
-                     * performance-critical). */
-                    break;
-                }
-            }
-
-            fds[i].fd = obj ? obj->fd : -1;
-            fds[i].events = POLLIN;
-        }
-        if (alertable)
-        {
-            fds[i].fd = ntdll_get_thread_data()->esync_apc_fd;
-            fds[i].events = POLLIN;
-            i++;
-        }
-        pollcount = i;
-
-        while (1)
-        {
-            ret = do_poll( fds, pollcount, timeout ? &end : NULL );
-            if (ret > 0)
-            {
-                /* We must check this first! The server may set an event that
-                 * we're waiting on, but we need to return STATUS_USER_APC. */
-                if (alertable)
-                {
-                    if (fds[pollcount - 1].revents & POLLIN)
-                        goto userapc;
-                }
-
-                /* Find out which object triggered the wait. */
-                for (i = 0; i < count; i++)
-                {
-                    struct esync *obj = objs[i];
-
-                    if (fds[i].revents & (POLLERR | POLLHUP | POLLNVAL))
-                    {
-                        ERR("Polling on fd %d returned %#x.\n", fds[i].fd, fds[i].revents);
-                        return STATUS_INVALID_HANDLE;
-                    }
-
-                    if (obj)
-                    {
-                        if (obj->type == ESYNC_MANUAL_EVENT
-                                || obj->type == ESYNC_MANUAL_SERVER
-                                || obj->type == ESYNC_QUEUE)
-                        {
-                            /* Don't grab the object, just check if it's signaled. */
-                            if (fds[i].revents & POLLIN)
-                            {
-                                TRACE("Woken up by handle %p [%d].\n", handles[i], i);
-                                return i;
-                            }
-                        }
-                        else
-                        {
-                            if ((size = read( fds[i].fd, &value, sizeof(value) )) == sizeof(value))
-                            {
-                                /* We found our object. */
-                                TRACE("Woken up by handle %p [%d].\n", handles[i], i);
-                                if (update_grabbed_object( obj ))
-                                    return STATUS_ABANDONED_WAIT_0 + i;
-                                return i;
-                            }
-                        }
-                    }
-                }
-
-                /* If we got here, someone else stole (or reset, etc.) whatever
-                 * we were waiting for. So keep waiting. */
-                NtQuerySystemTime( &now );
-            }
-            else
-                goto err;
-        }
-    }
-    else
-    {
-        /* Wait-all is a little trickier to implement correctly. Fortunately,
-         * it's not as common.
-         *
-         * The idea is basically just to wait in sequence on every object in the
-         * set. Then when we're done, try to grab them all in a tight loop. If
-         * that fails, release any resources we've grabbed (and yes, we can
-         * reliably do thisâ€”it's just mutexes and semaphores that we have to
-         * put back, and in both cases we just put back 1), and if any of that
-         * fails we start over.
-         *
-         * What makes this inherently bad is that we might temporarily grab a
-         * resource incorrectly. Hopefully it'll be quick (and hey, it won't
-         * block on wineserver) so nobody will notice. Besides, consider: if
-         * object A becomes signaled but someone grabs it before we can grab it
-         * and everything else, then they could just as well have grabbed it
-         * before it became signaled. Similarly if object A was signaled and we
-         * were blocking on object B, then B becomes available and someone grabs
-         * A before we can, then they might have grabbed A before B became
-         * signaled. In either case anyone who tries to wait on A or B will be
-         * waiting for an instant while we put things back. */
-
-        while (1)
-        {
-tryagain:
-            /* First step: try to poll on each object in sequence. */
-            fds[0].events = POLLIN;
-            pollcount = 1;
-            if (alertable)
-            {
-                /* We also need to wait on APCs. */
-                fds[1].fd = ntdll_get_thread_data()->esync_apc_fd;
-                fds[1].events = POLLIN;
-                pollcount++;
-            }
-            for (i = 0; i < count; i++)
-            {
-                struct esync *obj = objs[i];
-
-                fds[0].fd = obj ? obj->fd : -1;
-
-                if (obj && obj->type == ESYNC_MUTEX)
-                {
-                    /* It might be ours. */
-                    struct mutex *mutex = obj->shm;
-
-                    if (mutex->tid == GetCurrentThreadId())
-                        continue;
-                }
-
-                ret = do_poll( fds, pollcount, timeout ? &end : NULL );
-                if (ret <= 0)
-                    goto err;
-                else if (alertable && (fds[1].revents & POLLIN))
-                    goto userapc;
-
-                if (fds[0].revents & (POLLHUP | POLLERR | POLLNVAL))
-                {
-                    ERR("Polling on fd %d returned %#x.\n", fds[0].fd, fds[0].revents);
-                    return STATUS_INVALID_HANDLE;
-                }
-            }
-
-            /* If we got here and we haven't timed out, that means all of the
-             * handles were signaled. Check to make sure they still are. */
-            for (i = 0; i < count; i++)
-            {
-                fds[i].fd = objs[i] ? objs[i]->fd : -1;
-                fds[i].events = POLLIN;
-            }
-            /* There's no reason to check for APCs here. */
-            pollcount = i;
-
-            /* Poll everything to see if they're still signaled. */
-            ret = poll( fds, pollcount, 0 );
-            if (ret == pollcount)
-            {
-                BOOL abandoned = FALSE;
-
-                /* Quick, grab everything. */
-                for (i = 0; i < count; i++)
-                {
-                    struct esync *obj = objs[i];
-
-                    switch (obj->type)
-                    {
-                    case ESYNC_MUTEX:
-                    {
-                        struct mutex *mutex = obj->shm;
-                        if (mutex->tid == GetCurrentThreadId())
-                            break;
-                        /* otherwise fall through */
-                    }
-                    case ESYNC_SEMAPHORE:
-                    case ESYNC_AUTO_EVENT:
-                        if ((size = read( fds[i].fd, &value, sizeof(value) )) != sizeof(value))
-                        {
-                            /* We were too slow. Put everything back. */
-                            value = 1;
-                            for (j = i - 1; j >= 0; j--)
-                            {
-                                struct esync *obj = objs[j];
-
-                                if (obj->type == ESYNC_MUTEX)
-                                {
-                                    struct mutex *mutex = obj->shm;
-
-                                    if (mutex->tid == GetCurrentThreadId())
-                                        continue;
-                                }
-                                if (write( fds[j].fd, &value, sizeof(value) ) == -1)
-                                {
-                                    ERR("write failed.\n");
-                                    return errno_to_status( errno );
-                                }
-                            }
-
-                            goto tryagain;  /* break out of two loops and a switch */
-                        }
-                        break;
-                    default:
-                        /* If a manual-reset event changed between there and
-                         * here, it's shouldn't be a problem. */
-                        break;
-                    }
-                }
-
-                /* If we got here, we successfully waited on every object. */
-                /* Make sure to let ourselves know that we grabbed the mutexes
-                 * and semaphores. */
-                for (i = 0; i < count; i++)
-                    abandoned |= update_grabbed_object( objs[i] );
-
-                if (abandoned)
-                {
-                    TRACE("Wait successful, but some object(s) were abandoned.\n");
-                    return STATUS_ABANDONED;
-                }
-                TRACE("Wait successful.\n");
-                return STATUS_SUCCESS;
-            }
-
-            /* If we got here, ppoll() returned less than all of our objects.
-             * So loop back to the beginning and try again. */
-        } /* while(1) */
-    } /* else (wait-all) */
-
-err:
-    /* We should only get here if poll() failed. */
-
-    if (ret == 0)
-    {
-        TRACE("Wait timed out.\n");
-        return STATUS_TIMEOUT;
-    }
-    else
-    {
-        ERR("ppoll failed: %s\n", strerror(errno));
-        return errno_to_status( errno );
-    }
-
-userapc:
-    TRACE("Woken up by user APC.\n");
-
-    /* We have to make a server call anyway to get the APC to execute, so just
-     * delegate down to server_select(). */
-    ret = server_wait( NULL, 0, SELECT_INTERRUPTIBLE | SELECT_ALERTABLE, &zero );
-
-    /* This can happen if we received a system APC, and the APC fd was woken up
-     * before we got SIGUSR1. poll() doesn't return EINTR in that case. The
-     * right thing to do seems to be to return STATUS_USER_APC anyway. */
-    if (ret == STATUS_TIMEOUT) ret = STATUS_USER_APC;
-    return ret;
-}
-
-/* We need to let the server know when we are doing a message wait, and when we
- * are done with one, so that all of the code surrounding hung queues works.
- * We also need this for WaitForInputIdle(). */
-static void server_set_msgwait( int in_msgwait )
-{
-    SERVER_START_REQ( esync_msgwait )
-    {
-        req->in_msgwait = in_msgwait;
-        wine_server_call( req );
-    }
-    SERVER_END_REQ;
-}
-
-/* This is a very thin wrapper around the proper implementation above. The
- * purpose is to make sure the server knows when we are doing a message wait.
- * This is separated into a wrapper function since there are at least a dozen
- * exit paths from esync_wait_objects(). */
-NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
-                             BOOLEAN alertable, const LARGE_INTEGER *timeout )
-{
-    BOOL msgwait = FALSE;
-    struct esync *obj;
-    NTSTATUS ret;
-
-    if (count && !get_object( handles[count - 1], &obj ) && obj->type == ESYNC_QUEUE)
-    {
-        msgwait = TRUE;
-        server_set_msgwait( 1 );
-    }
-
-    ret = __esync_wait_objects( count, handles, wait_any, alertable, timeout );
-
-    if (msgwait)
-        server_set_msgwait( 0 );
-
-    return ret;
-}
-
-NTSTATUS esync_signal_and_wait( HANDLE signal, HANDLE wait, BOOLEAN alertable,
-    const LARGE_INTEGER *timeout )
-{
-    struct esync *obj;
-    NTSTATUS ret;
-
-    if ((ret = get_object( signal, &obj ))) return ret;
-
-    switch (obj->type)
-    {
-    case ESYNC_SEMAPHORE:
-        ret = esync_release_semaphore( signal, 1, NULL );
-        break;
-    case ESYNC_AUTO_EVENT:
-    case ESYNC_MANUAL_EVENT:
-        ret = esync_set_event( signal );
-        break;
-    case ESYNC_MUTEX:
-        ret = esync_release_mutex( signal, NULL );
-        break;
-    default:
-        return STATUS_OBJECT_TYPE_MISMATCH;
-    }
-    if (ret) return ret;
-
-    return esync_wait_objects( 1, &wait, TRUE, alertable, timeout );
-}
-
-void esync_init(void)
-{
-    struct stat st;
-
-    if (!do_esync())
-    {
-        /* make sure the server isn't running with WINEESYNC */
-        HANDLE handle;
-        NTSTATUS ret;
-
-        ret = create_esync( 0, &handle, 0, NULL, 0, 0 );
-        if (ret != STATUS_NOT_IMPLEMENTED)
-        {
-            ERR("Server is running with WINEESYNC but this process is not, please enable WINEESYNC or restart wineserver.\n");
-            exit(1);
-        }
-
-        return;
-    }
-
-    if (stat( config_dir, &st ) == -1)
-        ERR("Cannot stat %s\n", config_dir);
-
-    if (st.st_ino != (unsigned long)st.st_ino)
-        sprintf( shm_name, "/wine-%lx%08lx-esync", (unsigned long)((unsigned long long)st.st_ino >> 32), (unsigned long)st.st_ino );
-    else
-        sprintf( shm_name, "/wine-%lx-esync", (unsigned long)st.st_ino );
-
-    if ((shm_fd = shm_open( shm_name, O_RDWR, 0644 )) == -1)
-    {
-        /* probably the server isn't running with WINEESYNC, tell the user and bail */
-        if (errno == ENOENT)
-            ERR("Failed to open esync shared memory file; make sure no stale wineserver instances are running without WINEESYNC.\n");
-        else
-            ERR("Failed to initialize shared memory: %s\n", strerror( errno ));
-        exit(1);
-    }
-
-    pagesize = sysconf( _SC_PAGESIZE );
-
-    shm_addrs = calloc( 128, sizeof(shm_addrs[0]) );
-    shm_addrs_size = 128;
-}
diff --color -u -r -N a/dlls/ntdll/unix/esync.h b/dlls/ntdll/unix/esync.h
--- a/dlls/ntdll/unix/esync.h	2025-04-11 19:04:48.381611046 +0500
+++ b/dlls/ntdll/unix/esync.h	1970-01-01 05:00:00.000000000 +0500
@@ -1,61 +0,0 @@
-/*
- * eventfd-based synchronization objects
- *
- * Copyright (C) 2018 Zebediah Figura
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-extern int do_esync(void);
-extern void esync_init(void);
-extern NTSTATUS esync_close( HANDLE handle );
-
-extern NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
-    const OBJECT_ATTRIBUTES *attr, int initial, int max);
-extern NTSTATUS esync_open_semaphore( HANDLE *handle, ACCESS_MASK access,
-    const OBJECT_ATTRIBUTES *attr );
-extern NTSTATUS esync_query_semaphore( HANDLE handle, void *info, ULONG *ret_len );
-extern NTSTATUS esync_release_semaphore( HANDLE handle, unsigned int count, ULONG *prev );
-
-extern NTSTATUS esync_create_event( HANDLE *handle, ACCESS_MASK access,
-    const OBJECT_ATTRIBUTES *attr, EVENT_TYPE type, BOOLEAN initial );
-extern NTSTATUS esync_open_event( HANDLE *handle, ACCESS_MASK access,
-    const OBJECT_ATTRIBUTES *attr );
-extern NTSTATUS esync_pulse_event( HANDLE handle );
-extern NTSTATUS esync_query_event( HANDLE handle, void *info, ULONG *ret_len );
-extern NTSTATUS esync_reset_event( HANDLE handle );
-extern NTSTATUS esync_set_event( HANDLE handle );
-
-extern NTSTATUS esync_create_mutex( HANDLE *handle, ACCESS_MASK access,
-    const OBJECT_ATTRIBUTES *attr, BOOLEAN initial );
-extern NTSTATUS esync_open_mutex( HANDLE *handle, ACCESS_MASK access,
-    const OBJECT_ATTRIBUTES *attr );
-extern NTSTATUS esync_query_mutex( HANDLE handle, void *info, ULONG *ret_len );
-extern NTSTATUS esync_release_mutex( HANDLE *handle, LONG *prev );
-
-extern NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
-                                    BOOLEAN alertable, const LARGE_INTEGER *timeout );
-extern NTSTATUS esync_signal_and_wait( HANDLE signal, HANDLE wait, BOOLEAN alertable,
-    const LARGE_INTEGER *timeout );
-
-
-/* We have to synchronize on the fd cache mutex so that our calls to receive_fd
- * don't race with theirs. It looks weird, I know.
- *
- * If we weren't trying to avoid touching the code I'd rename the mutex to
- * "server_fd_mutex" or something similar. */
-extern pthread_mutex_t fd_cache_mutex;
-
-extern int receive_fd( obj_handle_t *handle );
diff --color -u -r -N a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
--- a/dlls/ntdll/unix/file.c	2025-04-11 19:04:49.114863864 +0500
+++ b/dlls/ntdll/unix/file.c	2025-04-11 19:11:08.153234433 +0500
@@ -7691,7 +7691,7 @@
         }
         if (handle)
         {
-            NtWaitForSingleObject( handle, FALSE, NULL );
+            server_wait_for_object( handle, FALSE, NULL );
             NtClose( handle );
         }
         else  /* Unix lock conflict, sleep a bit and retry */
diff --color -u -r -N a/dlls/ntdll/unix/loader.c b/dlls/ntdll/unix/loader.c
--- a/dlls/ntdll/unix/loader.c	2025-04-11 19:04:48.155221736 +0500
+++ b/dlls/ntdll/unix/loader.c	2025-04-11 19:10:08.148970446 +0500
@@ -90,7 +90,6 @@
 #include "winioctl.h"
 #include "winternl.h"
 #include "unix_private.h"
-#include "esync.h"
 #include "wine/list.h"
 #include "ntsyscalls.h"
 #include "wine/debug.h"
@@ -1885,7 +1884,6 @@
     signal_alloc_thread( teb );
     dbg_init();
     startup_info_size = server_init_process();
-    esync_init();
     virtual_map_user_shared_data();
     init_cpu_info();
     init_files();
diff --color -u -r -N a/dlls/ntdll/unix/process.c b/dlls/ntdll/unix/process.c
--- a/dlls/ntdll/unix/process.c	2025-04-11 18:23:13.943799153 +0500
+++ b/dlls/ntdll/unix/process.c	2025-04-11 19:11:08.153735485 +0500
@@ -920,7 +920,7 @@
 
     /* wait for the new process info to be ready */
 
-    NtWaitForSingleObject( process_info, FALSE, NULL );
+    server_wait_for_object( process_info, FALSE, NULL );
     SERVER_START_REQ( get_new_process_info )
     {
         req->info = wine_server_obj_handle( process_info );
diff --color -u -r -N a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
--- a/dlls/ntdll/unix/server.c	2025-04-11 19:04:49.146254610 +0500
+++ b/dlls/ntdll/unix/server.c	2025-04-11 19:11:08.157328498 +0500
@@ -83,7 +83,6 @@
 #include "wine/server.h"
 #include "wine/debug.h"
 #include "unix_private.h"
-#include "esync.h"
 #include "ddk/wdm.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(server);
@@ -810,6 +809,21 @@
 }
 
 
+/* helper function to perform a server-side wait on an internal handle without
+ * using the fast synchronization path */
+unsigned int server_wait_for_object( HANDLE handle, BOOL alertable, const LARGE_INTEGER *timeout )
+{
+    union select_op select_op;
+    UINT flags = SELECT_INTERRUPTIBLE;
+
+    if (alertable) flags |= SELECT_ALERTABLE;
+
+    select_op.wait.op = SELECT_WAIT;
+    select_op.wait.handles[0] = wine_server_obj_handle( handle );
+    return server_wait( &select_op, offsetof( union select_op, wait.handles[1] ), flags, timeout );
+}
+
+
 /***********************************************************************
  *              NtContinue  (NTDLL.@)
  */
@@ -886,7 +900,7 @@
         }
         else
         {
-            NtWaitForSingleObject( handle, FALSE, NULL );
+            server_wait_for_object( handle, FALSE, NULL );
 
             SERVER_START_REQ( get_apc_result )
             {
@@ -953,7 +967,7 @@
  *
  * Receive a file descriptor passed from the server.
  */
-int receive_fd( obj_handle_t *handle )
+int wine_server_receive_fd( obj_handle_t *handle )
 {
     struct iovec vec;
     struct msghdr msghdr;
@@ -1148,7 +1162,7 @@
                 if (type) *type = reply->type;
                 if (options) *options = reply->options;
                 access = reply->access;
-                if ((fd = receive_fd( &fd_handle )) != -1)
+                if ((fd = wine_server_receive_fd( &fd_handle )) != -1)
                 {
                     assert( wine_server_ptr_handle(fd_handle) == handle );
                     *needs_close = (!reply->cacheable ||
@@ -1624,7 +1638,7 @@
     pthread_sigmask( SIG_BLOCK, &server_block_set, NULL );
 
     /* receive the first thread request fd on the main socket */
-    ntdll_get_thread_data()->request_fd = receive_fd( &version );
+    ntdll_get_thread_data()->request_fd = wine_server_receive_fd( &version );
 
 #ifdef SO_PASSCRED
     /* now that we hopefully received the server_pid, disable SO_PASSCRED */
@@ -1837,12 +1851,17 @@
         return result.dup_handle.status;
     }
 
+    /* hold fd_cache_mutex to prevent the fd from being added again between the
+     * call to remove_fd_from_cache and close_handle */
     server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
 
     /* always remove the cached fd; if the server request fails we'll just
      * retrieve it again */
     if (options & DUPLICATE_CLOSE_SOURCE)
+    {
         fd = remove_fd_from_cache( source );
+        close_inproc_sync_obj( source );
+    }
 
     SERVER_START_REQ( dup_handle )
     {
@@ -1908,14 +1927,15 @@
     if (HandleToLong( handle ) >= ~5 && HandleToLong( handle ) <= ~0)
         return STATUS_SUCCESS;
 
+    /* hold fd_cache_mutex to prevent the fd from being added again between the
+     * call to remove_fd_from_cache and close_handle */
     server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
 
     /* always remove the cached fd; if the server request fails we'll just
      * retrieve it again */
     fd = remove_fd_from_cache( handle );
 
-    if (do_esync())
-        esync_close( handle );
+    close_inproc_sync_obj( handle );
 
     SERVER_START_REQ( close_handle )
     {
diff --color -u -r -N a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
--- a/dlls/ntdll/unix/sync.c	2025-04-11 19:04:48.362037137 +0500
+++ b/dlls/ntdll/unix/sync.c	2025-04-11 19:11:08.157699404 +0500
@@ -30,9 +30,11 @@
 #include <assert.h>
 #include <errno.h>
 #include <fcntl.h>
+#include <inttypes.h>
 #include <limits.h>
 #include <signal.h>
 #include <sys/types.h>
+#include <sys/ioctl.h>
 #include <sys/mman.h>
 #ifdef HAVE_SYS_SYSCALL_H
 #include <sys/syscall.h>
@@ -48,6 +50,7 @@
 #endif
 #include <string.h>
 #include <stdarg.h>
+#include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
@@ -57,6 +60,9 @@
 #ifdef HAVE_KQUEUE
 # include <sys/event.h>
 #endif
+#ifdef HAVE_LINUX_NTSYNC_H
+# include <linux/ntsync.h>
+#endif
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -66,7 +72,6 @@
 #include "wine/server.h"
 #include "wine/debug.h"
 #include "unix_private.h"
-#include "esync.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(sync);
 
@@ -75,9 +80,11 @@
 static const char *debugstr_timeout( const LARGE_INTEGER *timeout )
 {
     if (!timeout) return "(infinite)";
-    return wine_dbgstr_longlong( timeout->QuadPart );
+    return wine_dbg_sprintf( "%lld.%07ld", (long long)(timeout->QuadPart / TICKSPERSEC),
+                             (long)(timeout->QuadPart % TICKSPERSEC) );
 }
 
+
 /* return a monotonic time counter, in Win32 ticks */
 static inline ULONGLONG monotonic_counter(void)
 {
@@ -302,6 +309,896 @@
 }
 
 
+#ifdef NTSYNC_IOC_EVENT_READ
+
+static int get_linux_sync_device(void)
+{
+    static LONG device = -2;
+
+    if (device == -2)
+    {
+        obj_handle_t handle;
+        sigset_t sigset;
+        NTSTATUS ret;
+        int fd = -1;
+
+        /* We need to use fd_cache_mutex here to protect against races with
+         * other threads trying to receive fds for the fd cache,
+         * and we need to use an uninterrupted section to prevent reentrancy. */
+        server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
+
+        if (device == -2)
+        {
+            SERVER_START_REQ( get_linux_sync_device )
+            {
+                if (!(ret = wine_server_call( req )))
+                {
+                    fd = wine_server_receive_fd( &handle );
+                    assert( !handle );
+                }
+            }
+            SERVER_END_REQ;
+
+            device = fd;
+        }
+
+        server_leave_uninterrupted_section( &fd_cache_mutex, &sigset );
+    }
+    return device;
+}
+
+/* It's possible for synchronization primitives to remain alive even after being
+ * closed, because a thread is still waiting on them. It's rare in practice, and
+ * documented as being undefined behaviour by Microsoft, but it works, and some
+ * applications rely on it. This means we need to refcount handles, and defer
+ * deleting them on the server side until the refcount reaches zero. We do this
+ * by having each client process hold a handle to the in-process synchronization
+ * object, as well as a private refcount. When the client refcount reaches zero,
+ * it closes the handle; when all handles are closed, the server deletes the
+ * in-process synchronization object.
+ *
+ * We also need this for signal-and-wait. The signal and wait operations aren't
+ * atomic, but we can't perform the signal and then return STATUS_INVALID_HANDLE
+ * for the waitwe need to either do both operations or neither. That means we
+ * need to grab references to both objects, and prevent them from being
+ * destroyed before we're done with them.
+ *
+ * We want lookup of objects from the cache to be very fast; ideally, it should
+ * be lock-free. We achieve this by using atomic modifications to "refcount",
+ * and guaranteeing that all other fields are valid and correct *as long as*
+ * refcount is nonzero, and we store the entire structure in memory which will
+ * never be freed.
+ *
+ * This means that acquiring the object can't use a simple atomic increment; it
+ * has to use a compare-and-swap loop to ensure that it doesn't try to increment
+ * an object with a zero refcount. That's still leagues better than a real lock,
+ * though, and release can be a single atomic decrement.
+ *
+ * It also means that threads modifying the cache need to take a lock, to
+ * prevent other threads from writing to it concurrently.
+ *
+ * It's possible for an object currently in use (by a waiter) to be closed and
+ * the same handle immediately reallocated to a different object. This should be
+ * a very rare situation, and in that case we simply don't cache the handle.
+ */
+struct inproc_sync_cache_entry
+{
+    LONG refcount;
+    int fd;
+    unsigned int access;
+    unsigned short type; /* enum inproc_sync_type, stored as short to save space */
+    unsigned short closed;
+};
+
+
+static void release_inproc_sync_obj( struct inproc_sync_cache_entry *cache )
+{
+    /* save the fd now; as soon as the refcount hits 0 we cannot
+     * access the cache anymore */
+    int fd = cache->fd;
+    LONG refcount = InterlockedDecrement( &cache->refcount );
+
+    assert( refcount >= 0 );
+
+    if (!refcount)
+        close( fd );
+}
+
+
+#define INPROC_SYNC_CACHE_BLOCK_SIZE  (65536 / sizeof(struct inproc_sync_cache_entry))
+#define INPROC_SYNC_CACHE_ENTRIES     128
+
+static struct inproc_sync_cache_entry *inproc_sync_cache[INPROC_SYNC_CACHE_ENTRIES];
+static struct inproc_sync_cache_entry inproc_sync_cache_initial_block[INPROC_SYNC_CACHE_BLOCK_SIZE];
+
+static inline unsigned int inproc_sync_handle_to_index( HANDLE handle, unsigned int *entry )
+{
+    unsigned int idx = (wine_server_obj_handle(handle) >> 2) - 1;
+    *entry = idx / INPROC_SYNC_CACHE_BLOCK_SIZE;
+    return idx % INPROC_SYNC_CACHE_BLOCK_SIZE;
+}
+
+
+static struct inproc_sync_cache_entry *cache_inproc_sync_obj( HANDLE handle, obj_handle_t inproc_sync, int fd,
+                                                              enum inproc_sync_type type, unsigned int access )
+{
+    unsigned int entry, idx = inproc_sync_handle_to_index( handle, &entry );
+    struct inproc_sync_cache_entry *cache;
+    int refcount;
+
+    /* don't cache pseudo-handles; waiting on them is pointless anyway */
+    if ((ULONG)(ULONG_PTR)handle > 0xfffffffa)
+        return FALSE;
+
+    if (entry >= INPROC_SYNC_CACHE_ENTRIES)
+    {
+        FIXME( "too many allocated handles, not caching %p\n", handle );
+        return NULL;
+    }
+
+    if (!inproc_sync_cache[entry])  /* do we need to allocate a new block of entries? */
+    {
+        if (!entry) inproc_sync_cache[0] = inproc_sync_cache_initial_block;
+        else
+        {
+            static const size_t size = INPROC_SYNC_CACHE_BLOCK_SIZE * sizeof(struct inproc_sync_cache_entry);
+            void *ptr = anon_mmap_alloc( size, PROT_READ | PROT_WRITE );
+            if (ptr == MAP_FAILED) return NULL;
+            if (InterlockedCompareExchangePointer( (void **)&inproc_sync_cache[entry], ptr, NULL ))
+                munmap( ptr, size ); /* someone beat us to it */
+        }
+    }
+
+    cache = &inproc_sync_cache[entry][idx];
+
+    if (InterlockedCompareExchange( &cache->refcount, 0, 0 ))
+    {
+        /* The handle is currently being used for another object (i.e. it was
+         * closed and then reused, but some thread is waiting on the old handle
+         * or otherwise simultaneously using the old object). We can't cache
+         * this object until the old one is completely destroyed. */
+        return NULL;
+    }
+
+    cache->fd = fd;
+    cache->type = type;
+    cache->access = access;
+    cache->closed = FALSE;
+    /* Make sure we set the other members before the refcount; this store needs
+     * release semantics [paired with the load in get_cached_inproc_sync_obj()].
+     * Set the refcount to 2 (one for the handle, one for the caller). */
+    refcount = InterlockedExchange( &cache->refcount, 2 );
+    assert( !refcount );
+
+    return cache;
+}
+
+
+/* returns the previous value */
+static inline LONG interlocked_inc_if_nonzero( LONG *dest )
+{
+    LONG val, tmp;
+    for (val = *dest;; val = tmp)
+    {
+        if (!val || (tmp = InterlockedCompareExchange( dest, val + 1, val )) == val)
+            break;
+    }
+    return val;
+}
+
+
+static struct inproc_sync_cache_entry *get_cached_inproc_sync_obj( HANDLE handle )
+{
+    unsigned int entry, idx = inproc_sync_handle_to_index( handle, &entry );
+    struct inproc_sync_cache_entry *cache;
+
+    if (entry >= INPROC_SYNC_CACHE_ENTRIES || !inproc_sync_cache[entry])
+        return NULL;
+
+    cache = &inproc_sync_cache[entry][idx];
+
+    /* this load needs acquire semantics [paired with the store in
+     * cache_inproc_sync_obj()] */
+    if (!interlocked_inc_if_nonzero( &cache->refcount ))
+        return NULL;
+
+    if (cache->closed)
+    {
+        /* The object is still being used, but "handle" has been closed. The
+         * handle value might have been reused for another object in the
+         * meantime, in which case we have to report that valid object, so
+         * force the caller to check the server. */
+        release_inproc_sync_obj( cache );
+        return NULL;
+    }
+
+    return cache;
+}
+
+
+static BOOL inproc_sync_types_match( enum inproc_sync_type a, enum inproc_sync_type b )
+{
+    if (a == b) return TRUE;
+    if (a == INPROC_SYNC_AUTO_EVENT && b == INPROC_SYNC_MANUAL_EVENT) return TRUE;
+    if (b == INPROC_SYNC_AUTO_EVENT && a == INPROC_SYNC_MANUAL_EVENT) return TRUE;
+    return FALSE;
+}
+
+
+/* returns a pointer to a cache entry; if the object could not be cached,
+ * returns "stack_cache" instead, which should be allocated on stack */
+static NTSTATUS get_inproc_sync_obj( HANDLE handle, enum inproc_sync_type desired_type,
+                                     ACCESS_MASK desired_access,
+                                     struct inproc_sync_cache_entry *stack_cache,
+                                     struct inproc_sync_cache_entry **ret_cache )
+{
+    struct inproc_sync_cache_entry *cache;
+    obj_handle_t inproc_sync_handle;
+    enum inproc_sync_type type;
+    unsigned int access;
+    sigset_t sigset;
+    NTSTATUS ret;
+    int fd;
+
+    /* We don't need the device right now, but if we can't access it, that
+     * means ntsync isn't available. Fail fast in that case. */
+    if (get_linux_sync_device() < 0)
+        return STATUS_NOT_IMPLEMENTED;
+
+    /* try to find it in the cache already */
+    if ((cache = get_cached_inproc_sync_obj( handle )))
+    {
+        *ret_cache = cache;
+        return STATUS_SUCCESS;
+    }
+
+    /* We need to use fd_cache_mutex here to protect against races with
+     * other threads trying to receive fds for the fd cache,
+     * and we need to use an uninterrupted section to prevent reentrancy.
+     * We also need fd_cache_mutex to protect against the same race with
+     * NtClose, that is, to prevent the object from being cached again between
+     * close_inproc_sync_obj() and close_handle. */
+    server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
+
+    if ((cache = get_cached_inproc_sync_obj( handle )))
+    {
+        server_leave_uninterrupted_section( &fd_cache_mutex, &sigset );
+        *ret_cache = cache;
+        return STATUS_SUCCESS;
+    }
+
+    /* try to retrieve it from the server */
+    SERVER_START_REQ( get_linux_sync_obj )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        if (!(ret = wine_server_call( req )))
+        {
+            obj_handle_t fd_handle;
+            fd = wine_server_receive_fd( &fd_handle );
+            assert( wine_server_ptr_handle(fd_handle) == handle );
+            access = reply->access;
+            type = reply->type;
+        }
+    }
+    SERVER_END_REQ;
+
+    if (ret)
+    {
+        server_leave_uninterrupted_section( &fd_cache_mutex, &sigset );
+        return ret;
+    }
+
+    cache = cache_inproc_sync_obj( handle, inproc_sync_handle, fd, type, access );
+
+    server_leave_uninterrupted_section( &fd_cache_mutex, &sigset );
+
+    if (!cache)
+    {
+        cache = stack_cache;
+        cache->fd = fd;
+        cache->type = type;
+        cache->access = access;
+        cache->closed = FALSE;
+        cache->refcount = 1;
+    }
+
+    *ret_cache = cache;
+
+    if (desired_type && !inproc_sync_types_match( cache->type, desired_type ))
+    {
+        release_inproc_sync_obj( cache );
+        return STATUS_OBJECT_TYPE_MISMATCH;
+    }
+
+    if ((cache->access & desired_access) != desired_access)
+    {
+        release_inproc_sync_obj( cache );
+        return STATUS_ACCESS_DENIED;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+
+/* caller must hold fd_cache_mutex */
+void close_inproc_sync_obj( HANDLE handle )
+{
+    struct inproc_sync_cache_entry *cache = get_cached_inproc_sync_obj( handle );
+
+    if (cache)
+    {
+        cache->closed = TRUE;
+        /* once for the reference we just grabbed, and once for the handle */
+        release_inproc_sync_obj( cache );
+        release_inproc_sync_obj( cache );
+    }
+}
+
+
+static NTSTATUS linux_release_semaphore_obj( int obj, ULONG count, ULONG *prev_count )
+{
+    NTSTATUS ret;
+
+    ret = ioctl( obj, NTSYNC_IOC_SEM_RELEASE, &count );
+    if (ret < 0)
+    {
+        if (errno == EOVERFLOW)
+            return STATUS_SEMAPHORE_LIMIT_EXCEEDED;
+        else
+            return errno_to_status( errno );
+    }
+    if (prev_count) *prev_count = count;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS inproc_release_semaphore( HANDLE handle, ULONG count, ULONG *prev_count )
+{
+    struct inproc_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+
+    if ((ret = get_inproc_sync_obj( handle, INPROC_SYNC_SEMAPHORE,
+                                    SEMAPHORE_MODIFY_STATE, &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_release_semaphore_obj( cache->fd, count, prev_count );
+
+    release_inproc_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS linux_query_semaphore_obj( int obj, SEMAPHORE_BASIC_INFORMATION *info )
+{
+    struct ntsync_sem_args args = {0};
+    NTSTATUS ret;
+
+    ret = ioctl( obj, NTSYNC_IOC_SEM_READ, &args );
+    if (ret < 0)
+        return errno_to_status( errno );
+    info->CurrentCount = args.count;
+    info->MaximumCount = args.max;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS inproc_query_semaphore( HANDLE handle, SEMAPHORE_BASIC_INFORMATION *info )
+{
+    struct inproc_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+
+    if ((ret = get_inproc_sync_obj( handle, INPROC_SYNC_SEMAPHORE,
+                                    SEMAPHORE_QUERY_STATE, &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_query_semaphore_obj( cache->fd, info );
+
+    release_inproc_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS linux_set_event_obj( int obj, LONG *prev_state )
+{
+    NTSTATUS ret;
+    __u32 prev;
+
+    ret = ioctl( obj, NTSYNC_IOC_EVENT_SET, &prev );
+    if (ret < 0)
+        return errno_to_status( errno );
+    if (prev_state) *prev_state = prev;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS inproc_set_event( HANDLE handle, LONG *prev_state )
+{
+    struct inproc_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+
+    if ((ret = get_inproc_sync_obj( handle, INPROC_SYNC_AUTO_EVENT,
+                                    EVENT_MODIFY_STATE, &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_set_event_obj( cache->fd, prev_state );
+
+    release_inproc_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS linux_reset_event_obj( int obj, LONG *prev_state )
+{
+    NTSTATUS ret;
+    __u32 prev;
+
+    ret = ioctl( obj, NTSYNC_IOC_EVENT_RESET, &prev );
+    if (ret < 0)
+        return errno_to_status( errno );
+    if (prev_state) *prev_state = prev;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS inproc_reset_event( HANDLE handle, LONG *prev_state )
+{
+    struct inproc_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+
+    if ((ret = get_inproc_sync_obj( handle, INPROC_SYNC_AUTO_EVENT,
+                                    EVENT_MODIFY_STATE, &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_reset_event_obj( cache->fd, prev_state );
+
+    release_inproc_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS linux_pulse_event_obj( int obj, LONG *prev_state )
+{
+    NTSTATUS ret;
+    __u32 prev;
+
+    ret = ioctl( obj, NTSYNC_IOC_EVENT_PULSE, &prev );
+    if (ret < 0)
+        return errno_to_status( errno );
+    if (prev_state) *prev_state = prev;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS inproc_pulse_event( HANDLE handle, LONG *prev_state )
+{
+    struct inproc_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+
+    if ((ret = get_inproc_sync_obj( handle, INPROC_SYNC_AUTO_EVENT,
+                                    EVENT_MODIFY_STATE, &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_pulse_event_obj( cache->fd, prev_state );
+
+    release_inproc_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS linux_query_event_obj( int obj, enum inproc_sync_type type, EVENT_BASIC_INFORMATION *info )
+{
+    struct ntsync_event_args args = {0};
+    NTSTATUS ret;
+
+    ret = ioctl( obj, NTSYNC_IOC_EVENT_READ, &args );
+    if (ret < 0)
+        return errno_to_status( errno );
+    info->EventType = (type == INPROC_SYNC_AUTO_EVENT) ? SynchronizationEvent : NotificationEvent;
+    info->EventState = args.signaled;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS inproc_query_event( HANDLE handle, EVENT_BASIC_INFORMATION *info )
+{
+    struct inproc_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+
+    if ((ret = get_inproc_sync_obj( handle, INPROC_SYNC_AUTO_EVENT,
+                                    EVENT_QUERY_STATE, &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_query_event_obj( cache->fd, cache->type, info );
+
+    release_inproc_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS linux_release_mutex_obj( int obj, LONG *prev_count )
+{
+    struct ntsync_mutex_args args = {0};
+    NTSTATUS ret;
+
+    args.owner = GetCurrentThreadId();
+    ret = ioctl( obj, NTSYNC_IOC_MUTEX_UNLOCK, &args );
+
+    if (ret < 0)
+    {
+        if (errno == EOVERFLOW)
+            return STATUS_MUTANT_LIMIT_EXCEEDED;
+        else if (errno == EPERM)
+            return STATUS_MUTANT_NOT_OWNED;
+        else
+            return errno_to_status( errno );
+    }
+    if (prev_count) *prev_count = 1 - args.count;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS inproc_release_mutex( HANDLE handle, LONG *prev_count )
+{
+    struct inproc_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+
+    if ((ret = get_inproc_sync_obj( handle, INPROC_SYNC_MUTEX, 0, &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_release_mutex_obj( cache->fd, prev_count );
+
+    release_inproc_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS linux_query_mutex_obj( int obj, MUTANT_BASIC_INFORMATION *info )
+{
+    struct ntsync_mutex_args args = {0};
+    NTSTATUS ret;
+
+    ret = ioctl( obj, NTSYNC_IOC_MUTEX_READ, &args );
+
+    if (ret < 0)
+    {
+        if (errno == EOWNERDEAD)
+        {
+            info->AbandonedState = TRUE;
+            info->OwnedByCaller = FALSE;
+            info->CurrentCount = 1;
+            return STATUS_SUCCESS;
+        }
+        else
+            return errno_to_status( errno );
+    }
+    info->AbandonedState = FALSE;
+    info->OwnedByCaller = (args.owner == GetCurrentThreadId());
+    info->CurrentCount = 1 - args.count;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS inproc_query_mutex( HANDLE handle, MUTANT_BASIC_INFORMATION *info )
+{
+    struct inproc_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+
+    if ((ret = get_inproc_sync_obj( handle, INPROC_SYNC_MUTEX, MUTANT_QUERY_STATE,
+                                    &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_query_mutex_obj( cache->fd, info );
+
+    release_inproc_sync_obj( cache );
+    return ret;
+}
+
+static void select_queue(void)
+{
+    SERVER_START_REQ( select_inproc_queue )
+    {
+        wine_server_call( req );
+    }
+    SERVER_END_REQ;
+}
+
+static void unselect_queue( BOOL signaled )
+{
+    SERVER_START_REQ( unselect_inproc_queue )
+    {
+        req->signaled = signaled;
+        wine_server_call( req );
+    }
+    SERVER_END_REQ;
+}
+
+static int get_inproc_alert_obj(void)
+{
+    struct ntdll_thread_data *data = ntdll_get_thread_data();
+    struct inproc_sync_cache_entry stack_cache, *cache;
+    HANDLE alert_handle;
+    unsigned int ret;
+
+    if (data->linux_alert_obj == -1)
+    {
+        SERVER_START_REQ( get_inproc_alert_event )
+        {
+            if ((ret = wine_server_call( req )))
+                ERR( "failed to get inproc alert event, status %#x\n", ret );
+            alert_handle = wine_server_ptr_handle( reply->handle );
+        }
+        SERVER_END_REQ;
+
+        if ((ret = get_inproc_sync_obj( alert_handle, 0, SYNCHRONIZE, &stack_cache, &cache )))
+            ERR( "failed to get inproc alert obj, status %#x\n", ret );
+        data->linux_alert_obj = cache->fd;
+        /* Set the fd to -1 so release_inproc_sync_obj() won't close it.
+         * Manhandling the cache entry here is fine since we're the only thread
+         * that can access our own alert event. */
+        cache->fd = -1;
+        release_inproc_sync_obj( cache );
+        NtClose( alert_handle );
+    }
+
+    return data->linux_alert_obj;
+}
+
+static NTSTATUS linux_wait_objs( int device, const DWORD count, const int *objs,
+                                 BOOLEAN wait_any, BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    struct ntsync_wait_args args = {0};
+    unsigned long request;
+    struct timespec now;
+    int ret;
+
+    if (!timeout || timeout->QuadPart == TIMEOUT_INFINITE)
+    {
+        args.timeout = ~(__u64)0;
+    }
+    else if (timeout->QuadPart <= 0)
+    {
+        clock_gettime( CLOCK_MONOTONIC, &now );
+        args.timeout = (now.tv_sec * NSECPERSEC) + now.tv_nsec + (-timeout->QuadPart * 100);
+    }
+    else
+    {
+        args.timeout = (timeout->QuadPart * 100) - (SECS_1601_TO_1970 * NSECPERSEC);
+        args.flags |= NTSYNC_WAIT_REALTIME;
+    }
+
+    args.objs = (uintptr_t)objs;
+    args.count = count;
+    args.owner = GetCurrentThreadId();
+    args.index = ~0u;
+
+    if (alertable)
+        args.alert = get_inproc_alert_obj();
+
+    if (wait_any || count == 1)
+        request = NTSYNC_IOC_WAIT_ANY;
+    else
+        request = NTSYNC_IOC_WAIT_ALL;
+
+    do
+    {
+        ret = ioctl( device, request, &args );
+    } while (ret < 0 && errno == EINTR);
+
+    if (!ret)
+    {
+        if (args.index == count)
+        {
+            static const LARGE_INTEGER timeout;
+
+            ret = server_wait( NULL, 0, SELECT_INTERRUPTIBLE | SELECT_ALERTABLE, &timeout );
+            assert( ret == STATUS_USER_APC );
+            return ret;
+        }
+
+        return wait_any ? args.index : 0;
+    }
+    else if (errno == EOWNERDEAD)
+        return STATUS_ABANDONED + (wait_any ? args.index : 0);
+    else if (errno == ETIMEDOUT)
+        return STATUS_TIMEOUT;
+    else
+        return errno_to_status( errno );
+}
+
+static NTSTATUS inproc_wait( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
+                             BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    struct inproc_sync_cache_entry stack_cache[64], *cache[64];
+    int device, objs[64];
+    HANDLE queue = NULL;
+    NTSTATUS ret;
+    DWORD i, j;
+
+    if ((device = get_linux_sync_device()) < 0)
+        return STATUS_NOT_IMPLEMENTED;
+
+    for (i = 0; i < count; ++i)
+    {
+        if ((ret = get_inproc_sync_obj( handles[i], 0, SYNCHRONIZE, &stack_cache[i], &cache[i] )))
+        {
+            for (j = 0; j < i; ++j)
+                release_inproc_sync_obj( cache[j] );
+            return ret;
+        }
+        if (cache[i]->type == INPROC_SYNC_QUEUE)
+            queue = handles[i];
+
+        objs[i] = cache[i]->fd;
+    }
+
+    /* It's common to wait on the message queue alone. Some applications wait
+     * on it in fast paths, with a zero timeout. Since we take two server calls
+     * instead of one when going through inproc_wait(), and since we only need
+     * to go through that path if we're waiting on other objects, just delegate
+     * to the server if we're only waiting on the message queue. */
+    if (count == 1 && queue)
+    {
+        release_inproc_sync_obj( cache[0] );
+        return server_wait_for_object( handles[0], alertable, timeout );
+    }
+
+    if (queue) select_queue();
+
+    ret = linux_wait_objs( device, count, objs, wait_any, alertable, timeout );
+
+    if (queue) unselect_queue( handles[ret] == queue );
+
+    for (i = 0; i < count; ++i)
+        release_inproc_sync_obj( cache[i] );
+
+    return ret;
+}
+
+static NTSTATUS inproc_signal_and_wait( HANDLE signal, HANDLE wait,
+                                        BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    struct inproc_sync_cache_entry signal_stack_cache, *signal_cache;
+    struct inproc_sync_cache_entry wait_stack_cache, *wait_cache;
+    HANDLE queue = NULL;
+    NTSTATUS ret;
+    int device;
+
+    if ((device = get_linux_sync_device()) < 0)
+        return STATUS_NOT_IMPLEMENTED;
+
+    if ((ret = get_inproc_sync_obj( signal, 0, 0, &signal_stack_cache, &signal_cache )))
+        return ret;
+
+    switch (signal_cache->type)
+    {
+        case INPROC_SYNC_SEMAPHORE:
+            if (!(signal_cache->access & SEMAPHORE_MODIFY_STATE))
+            {
+                release_inproc_sync_obj( signal_cache );
+                return STATUS_ACCESS_DENIED;
+            }
+            break;
+
+        case INPROC_SYNC_AUTO_EVENT:
+        case INPROC_SYNC_MANUAL_EVENT:
+            if (!(signal_cache->access & EVENT_MODIFY_STATE))
+            {
+                release_inproc_sync_obj( signal_cache );
+                return STATUS_ACCESS_DENIED;
+            }
+            break;
+
+        case INPROC_SYNC_MUTEX:
+            break;
+
+        default:
+            /* can't be signaled */
+            release_inproc_sync_obj( signal_cache );
+            return STATUS_OBJECT_TYPE_MISMATCH;
+    }
+
+    if ((ret = get_inproc_sync_obj( wait, 0, SYNCHRONIZE, &wait_stack_cache, &wait_cache )))
+    {
+        release_inproc_sync_obj( signal_cache );
+        return ret;
+    }
+
+    if (wait_cache->type == INPROC_SYNC_QUEUE)
+        queue = wait;
+
+    switch (signal_cache->type)
+    {
+        case INPROC_SYNC_SEMAPHORE:
+            ret = linux_release_semaphore_obj( signal_cache->fd, 1, NULL );
+            break;
+
+        case INPROC_SYNC_AUTO_EVENT:
+        case INPROC_SYNC_MANUAL_EVENT:
+            ret = linux_set_event_obj( signal_cache->fd, NULL );
+            break;
+
+        case INPROC_SYNC_MUTEX:
+            ret = linux_release_mutex_obj( signal_cache->fd, NULL );
+            break;
+
+        default:
+            assert( 0 );
+            break;
+    }
+
+    if (!ret)
+    {
+        if (queue) select_queue();
+        ret = linux_wait_objs( device, 1, &wait_cache->fd, TRUE, alertable, timeout );
+        if (queue) unselect_queue( !ret );
+    }
+
+    release_inproc_sync_obj( signal_cache );
+    release_inproc_sync_obj( wait_cache );
+    return ret;
+}
+
+#else
+
+void close_inproc_sync_obj( HANDLE handle )
+{
+}
+
+static NTSTATUS inproc_release_semaphore( HANDLE handle, ULONG count, ULONG *prev_count )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS inproc_query_semaphore( HANDLE handle, SEMAPHORE_BASIC_INFORMATION *info )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS inproc_set_event( HANDLE handle, LONG *prev_state )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS inproc_reset_event( HANDLE handle, LONG *prev_state )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS inproc_pulse_event( HANDLE handle, LONG *prev_state )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS inproc_query_event( HANDLE handle, EVENT_BASIC_INFORMATION *info )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS inproc_release_mutex( HANDLE handle, LONG *prev_count )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS inproc_query_mutex( HANDLE handle, MUTANT_BASIC_INFORMATION *info )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS inproc_wait( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
+                             BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+static NTSTATUS inproc_signal_and_wait( HANDLE signal, HANDLE wait,
+                                        BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+#endif
+
+
 /******************************************************************************
  *              NtCreateSemaphore (NTDLL.@)
  */
@@ -312,13 +1209,13 @@
     data_size_t len;
     struct object_attributes *objattr;
 
+    TRACE( "access %#x, name %s, initial %d, max %d\n", (int)access,
+           attr ? debugstr_us(attr->ObjectName) : "(null)", (int)initial, (int)max );
+
     *handle = 0;
     if (max <= 0 || initial < 0 || initial > max) return STATUS_INVALID_PARAMETER;
     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
 
-    if (do_esync())
-        return esync_create_semaphore( handle, access, attr, initial, max );
-
     SERVER_START_REQ( create_semaphore )
     {
         req->access  = access;
@@ -342,11 +1239,9 @@
 {
     unsigned int ret;
 
-    *handle = 0;
-
-    if (do_esync())
-        return esync_open_semaphore( handle, access, attr );
+    TRACE( "access %#x, name %s\n", (int)access, attr ? debugstr_us(attr->ObjectName) : "(null)" );
 
+    *handle = 0;
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
     SERVER_START_REQ( open_semaphore )
@@ -383,8 +1278,11 @@
 
     if (len != sizeof(SEMAPHORE_BASIC_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
 
-    if (do_esync())
-        return esync_query_semaphore( handle, info, ret_len );
+    if ((ret = inproc_query_semaphore( handle, out )) != STATUS_NOT_IMPLEMENTED)
+    {
+        if (!ret && ret_len) *ret_len = sizeof(SEMAPHORE_BASIC_INFORMATION);
+        return ret;
+    }
 
     SERVER_START_REQ( query_semaphore )
     {
@@ -408,8 +1306,10 @@
 {
     unsigned int ret;
 
-    if (do_esync())
-        return esync_release_semaphore( handle, count, previous );
+    TRACE( "handle %p, count %u, prev_count %p\n", handle, (int)count, previous );
+
+    if ((ret = inproc_release_semaphore( handle, count, previous )) != STATUS_NOT_IMPLEMENTED)
+        return ret;
 
     SERVER_START_REQ( release_semaphore )
     {
@@ -435,12 +1335,11 @@
     data_size_t len;
     struct object_attributes *objattr;
 
+    TRACE( "access %#x, name %s, type %u, state %u\n", (int)access,
+           attr ? debugstr_us(attr->ObjectName) : "(null)", type, state );
+
     *handle = 0;
     if (type != NotificationEvent && type != SynchronizationEvent) return STATUS_INVALID_PARAMETER;
-
-    if (do_esync())
-        return esync_create_event( handle, access, attr, type, state );
-
     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
 
     SERVER_START_REQ( create_event )
@@ -466,12 +1365,11 @@
 {
     unsigned int ret;
 
+    TRACE( "access %#x, name %s\n", (int)access, attr ? debugstr_us(attr->ObjectName) : "(null)" );
+
     *handle = 0;
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
-    if (do_esync())
-        return esync_open_event( handle, access, attr );
-
     SERVER_START_REQ( open_event )
     {
         req->access     = access;
@@ -492,11 +1390,12 @@
  */
 NTSTATUS WINAPI NtSetEvent( HANDLE handle, LONG *prev_state )
 {
-    /* This comment is a dummy to make sure this patch applies in the right place. */
     unsigned int ret;
 
-    if (do_esync())
-        return esync_set_event( handle );
+    TRACE( "handle %p, prev_state %p\n", handle, prev_state );
+
+    if ((ret = inproc_set_event( handle, prev_state )) != STATUS_NOT_IMPLEMENTED)
+        return ret;
 
     SERVER_START_REQ( event_op )
     {
@@ -515,12 +1414,12 @@
  */
 NTSTATUS WINAPI NtResetEvent( HANDLE handle, LONG *prev_state )
 {
-    /* This comment is a dummy to make sure this patch applies in the right place. */
     unsigned int ret;
 
-    if (do_esync())
-        return esync_reset_event( handle );
+    TRACE( "handle %p, prev_state %p\n", handle, prev_state );
 
+    if ((ret = inproc_reset_event( handle, prev_state )) != STATUS_NOT_IMPLEMENTED)
+        return ret;
 
     SERVER_START_REQ( event_op )
     {
@@ -551,8 +1450,10 @@
 {
     unsigned int ret;
 
-    if (do_esync())
-        return esync_pulse_event( handle );
+    TRACE( "handle %p, prev_state %p\n", handle, prev_state );
+
+    if ((ret = inproc_pulse_event( handle, prev_state )) != STATUS_NOT_IMPLEMENTED)
+        return ret;
 
     SERVER_START_REQ( event_op )
     {
@@ -585,8 +1486,11 @@
 
     if (len != sizeof(EVENT_BASIC_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
 
-    if (do_esync())
-        return esync_query_event( handle, info, ret_len );
+    if ((ret = inproc_query_event( handle, out )) != STATUS_NOT_IMPLEMENTED)
+    {
+        if (!ret && ret_len) *ret_len = sizeof(EVENT_BASIC_INFORMATION);
+        return ret;
+    }
 
     SERVER_START_REQ( query_event )
     {
@@ -613,11 +1517,10 @@
     data_size_t len;
     struct object_attributes *objattr;
 
-    *handle = 0;
-
-    if (do_esync())
-        return esync_create_mutex( handle, access, attr, owned );
+    TRACE( "access %#x, name %s, owned %u\n", (int)access,
+           attr ? debugstr_us(attr->ObjectName) : "(null)", owned );
 
+    *handle = 0;
     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
 
     SERVER_START_REQ( create_mutex )
@@ -642,12 +1545,11 @@
 {
     unsigned int ret;
 
+    TRACE( "access %#x, name %s\n", (int)access, attr ? debugstr_us(attr->ObjectName) : "(null)" );
+
     *handle = 0;
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
-    if (do_esync())
-        return esync_open_mutex( handle, access, attr );
-
     SERVER_START_REQ( open_mutex )
     {
         req->access  = access;
@@ -670,8 +1572,10 @@
 {
     unsigned int ret;
 
-    if (do_esync())
-        return esync_release_mutex( handle, prev_count );
+    TRACE( "handle %p, prev_count %p\n", handle, prev_count );
+
+    if ((ret = inproc_release_mutex( handle, prev_count )) != STATUS_NOT_IMPLEMENTED)
+        return ret;
 
     SERVER_START_REQ( release_mutex )
     {
@@ -703,8 +1607,11 @@
 
     if (len != sizeof(MUTANT_BASIC_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
 
-    if (do_esync())
-        return esync_query_mutex( handle, info, ret_len );
+    if ((ret = inproc_query_mutex( handle, out )) != STATUS_NOT_IMPLEMENTED)
+    {
+        if (!ret && ret_len) *ret_len = sizeof(MUTANT_BASIC_INFORMATION);
+        return ret;
+    }
 
     SERVER_START_REQ( query_mutex )
     {
@@ -1475,6 +2382,9 @@
     data_size_t len;
     struct object_attributes *objattr;
 
+    TRACE( "access %#x, name %s, type %u\n", (int)access,
+           attr ? debugstr_us(attr->ObjectName) : "(null)", type );
+
     *handle = 0;
     if (type != NotificationTimer && type != SynchronizationTimer) return STATUS_INVALID_PARAMETER;
     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
@@ -1502,6 +2412,8 @@
 {
     unsigned int ret;
 
+    TRACE( "access %#x, name %s\n", (int)access, attr ? debugstr_us(attr->ObjectName) : "(null)" );
+
     *handle = 0;
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
@@ -1555,6 +2467,8 @@
 {
     unsigned int ret;
 
+    TRACE( "handle %p, state %p\n", handle, state );
+
     SERVER_START_REQ( cancel_timer )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -1623,20 +2537,29 @@
 {
     union select_op select_op;
     UINT i, flags = SELECT_INTERRUPTIBLE;
+    unsigned int ret;
 
     if (!count || count > MAXIMUM_WAIT_OBJECTS) return STATUS_INVALID_PARAMETER_1;
 
-    if (do_esync())
+    if (TRACE_ON(sync))
     {
-        NTSTATUS ret = esync_wait_objects( count, handles, wait_any, alertable, timeout );
-        if (ret != STATUS_NOT_IMPLEMENTED)
-            return ret;
+        TRACE( "wait_any %u, alertable %u, handles {%p", wait_any, alertable, handles[0] );
+        for (i = 1; i < count; i++) TRACE( ", %p", handles[i] );
+        TRACE( "}, timeout %s\n", debugstr_timeout(timeout) );
+    }
+
+    if ((ret = inproc_wait( count, handles, wait_any, alertable, timeout )) != STATUS_NOT_IMPLEMENTED)
+    {
+        TRACE( "-> %#x\n", ret );
+        return ret;
     }
 
     if (alertable) flags |= SELECT_ALERTABLE;
     select_op.wait.op = wait_any ? SELECT_WAIT : SELECT_WAIT_ALL;
     for (i = 0; i < count; i++) select_op.wait.handles[i] = wine_server_obj_handle( handles[i] );
-    return server_wait( &select_op, offsetof( union select_op, wait.handles[count] ), flags, timeout );
+    ret = server_wait( &select_op, offsetof( union select_op, wait.handles[count] ), flags, timeout );
+    TRACE( "-> %#x\n", ret );
+    return ret;
 }
 
 
@@ -1657,12 +2580,15 @@
 {
     union select_op select_op;
     UINT flags = SELECT_INTERRUPTIBLE;
+    NTSTATUS ret;
 
-    if (do_esync())
-        return esync_signal_and_wait( signal, wait, alertable, timeout );
+    TRACE( "signal %p, wait %p, alertable %u, timeout %s\n", signal, wait, alertable, debugstr_timeout(timeout) );
 
     if (!signal) return STATUS_INVALID_HANDLE;
 
+    if ((ret = inproc_signal_and_wait( signal, wait, alertable, timeout )) != STATUS_NOT_IMPLEMENTED)
+        return ret;
+
     if (alertable) flags |= SELECT_ALERTABLE;
     select_op.signal_and_wait.op = SELECT_SIGNAL_AND_WAIT;
     select_op.signal_and_wait.wait = wine_server_obj_handle( wait );
@@ -1905,6 +2831,9 @@
     data_size_t len;
     struct object_attributes *objattr;
 
+    TRACE( "access %#x, name %s, flags %#x\n", (int)access,
+           attr ? debugstr_us(attr->ObjectName) : "(null)", (int)flags );
+
     *handle = 0;
     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
 
@@ -1929,6 +2858,8 @@
 {
     unsigned int ret;
 
+    TRACE( "access %#x, name %s\n", (int)access, attr ? debugstr_us(attr->ObjectName) : "(null)" );
+
     *handle = 0;
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
@@ -1955,6 +2886,8 @@
     union select_op select_op;
     UINT flags = SELECT_INTERRUPTIBLE;
 
+    TRACE( "handle %p, key %p, alertable %u, timeout %s\n", handle, key, alertable, debugstr_timeout(timeout) );
+
     if (!handle) handle = keyed_event;
     if ((ULONG_PTR)key & 1) return STATUS_INVALID_PARAMETER_1;
     if (alertable) flags |= SELECT_ALERTABLE;
@@ -1974,6 +2907,8 @@
     union select_op select_op;
     UINT flags = SELECT_INTERRUPTIBLE;
 
+    TRACE( "handle %p, key %p, alertable %u, timeout %s\n", handle, key, alertable, debugstr_timeout(timeout) );
+
     if (!handle) handle = keyed_event;
     if ((ULONG_PTR)key & 1) return STATUS_INVALID_PARAMETER_1;
     if (alertable) flags |= SELECT_ALERTABLE;
@@ -2118,7 +3053,7 @@
     }
     SERVER_END_REQ;
     if (status != STATUS_PENDING) return status;
-    if (!timeout || timeout->QuadPart) status = NtWaitForSingleObject( wait_handle, FALSE, timeout );
+    if (!timeout || timeout->QuadPart) status = server_wait_for_object( wait_handle, FALSE, timeout );
     else                               status = STATUS_TIMEOUT;
     if (status != WAIT_OBJECT_0) return status;
 
@@ -2182,7 +3117,7 @@
         assert( status == STATUS_USER_APC );
         goto done;
     }
-    if (!timeout || timeout->QuadPart) status = NtWaitForSingleObject( wait_handle, alertable, timeout );
+    if (!timeout || timeout->QuadPart) status = server_wait_for_object( wait_handle, alertable, timeout );
     else                               status = STATUS_TIMEOUT;
     if (status != WAIT_OBJECT_0) goto done;
 
diff --color -u -r -N a/dlls/ntdll/unix/thread.c b/dlls/ntdll/unix/thread.c
--- a/dlls/ntdll/unix/thread.c	2025-04-11 18:23:13.948799167 +0500
+++ b/dlls/ntdll/unix/thread.c	2025-04-11 19:11:08.154765209 +0500
@@ -1801,7 +1801,7 @@
 
     if (ret == STATUS_PENDING)
     {
-        NtWaitForSingleObject( context_handle, FALSE, NULL );
+        server_wait_for_object( context_handle, FALSE, NULL );
 
         SERVER_START_REQ( get_thread_context )
         {
diff --color -u -r -N a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
--- a/dlls/ntdll/unix/unix_private.h	2025-04-11 19:04:49.079148112 +0500
+++ b/dlls/ntdll/unix/unix_private.h	2025-04-11 19:11:08.158114231 +0500
@@ -103,7 +103,6 @@
 {
     void              *cpu_data[16];  /* reserved for CPU-specific data */
     void              *kernel_stack;  /* stack for thread startup and kernel syscalls */
-    int                esync_apc_fd;  /* fd to wait on for user APCs */
     int                request_fd;    /* fd for sending server requests */
     int                reply_fd;      /* fd for receiving server replies */
     int                wait_fd[2];    /* fd for sleeping server requests */
@@ -113,6 +112,7 @@
     PRTL_THREAD_START_ROUTINE start;  /* thread entry point */
     void              *param;         /* thread entry point parameter */
     void              *jmp_buf;       /* setjmp buffer for exception handling */
+    int                linux_alert_obj; /* fd for the linux in-process alert event */
 };
 
 C_ASSERT( sizeof(struct ntdll_thread_data) <= sizeof(((TEB *)0)->GdiTebBatch) );
@@ -208,6 +208,8 @@
 extern ULONG_PTR redirect_arm64ec_rva( void *module, ULONG_PTR rva, const IMAGE_ARM64EC_METADATA *metadata );
 extern void start_server( BOOL debug );
 
+extern pthread_mutex_t fd_cache_mutex;
+
 extern unsigned int server_call_unlocked( void *req_ptr );
 extern void server_enter_uninterrupted_section( pthread_mutex_t *mutex, sigset_t *sigset );
 extern void server_leave_uninterrupted_section( pthread_mutex_t *mutex, sigset_t *sigset );
@@ -215,11 +217,13 @@
                                    timeout_t abs_timeout, struct context_data *context, struct user_apc *user_apc );
 extern unsigned int server_wait( const union select_op *select_op, data_size_t size, UINT flags,
                                  const LARGE_INTEGER *timeout );
+extern unsigned int server_wait_for_object( HANDLE handle, BOOL alertable, const LARGE_INTEGER *timeout );
 extern unsigned int server_queue_process_apc( HANDLE process, const union apc_call *call,
                                               union apc_result *result );
 extern int server_get_unix_fd( HANDLE handle, unsigned int wanted_access, int *unix_fd,
                                int *needs_close, enum server_fd_type *type, unsigned int *options );
 extern void wine_server_send_fd( int fd );
+extern int wine_server_receive_fd( obj_handle_t *handle );
 extern void process_exit_wrapper( int status ) DECLSPEC_NORETURN;
 extern size_t server_init_process(void);
 extern void server_init_process_done(void);
@@ -380,6 +384,8 @@
 
 extern void dbg_init(void);
 
+extern void close_inproc_sync_obj( HANDLE handle );
+
 extern NTSTATUS call_user_apc_dispatcher( CONTEXT *context_ptr, ULONG_PTR arg1, ULONG_PTR arg2, ULONG_PTR arg3,
                                           PNTAPCFUNC func, NTSTATUS status );
 extern NTSTATUS call_user_exception_dispatcher( EXCEPTION_RECORD *rec, CONTEXT *context );
@@ -388,6 +394,7 @@
 #define IMAGE_DLLCHARACTERISTICS_PREFER_NATIVE 0x0010 /* Wine extension */
 
 #define TICKSPERSEC 10000000
+#define NSECPERSEC 1000000000
 #define SECS_1601_TO_1970  ((369 * 365 + 89) * (ULONGLONG)86400)
 
 static inline ULONGLONG ticks_from_time_t( time_t time )
@@ -453,7 +460,7 @@
 
 static inline NTSTATUS wait_async( HANDLE handle, BOOL alertable )
 {
-    return NtWaitForSingleObject( handle, alertable, NULL );
+    return server_wait_for_object( handle, alertable, NULL );
 }
 
 static inline BOOL in_wow64_call(void)
diff --color -u -r -N a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
--- a/dlls/ntdll/unix/virtual.c	2025-04-11 19:04:49.103057248 +0500
+++ b/dlls/ntdll/unix/virtual.c	2025-04-11 19:11:08.156234355 +0500
@@ -3841,11 +3841,11 @@
     teb->StaticUnicodeString.Buffer = teb->StaticUnicodeBuffer;
     teb->StaticUnicodeString.MaximumLength = sizeof(teb->StaticUnicodeBuffer);
     thread_data = (struct ntdll_thread_data *)&teb->GdiTebBatch;
-    thread_data->esync_apc_fd = -1;
     thread_data->request_fd = -1;
     thread_data->reply_fd   = -1;
     thread_data->wait_fd[0] = -1;
     thread_data->wait_fd[1] = -1;
+    thread_data->linux_alert_obj = -1;
     list_add_head( &teb_list, &thread_data->entry );
     return teb;
 }
diff --color -u -r -N a/dlls/rpcrt4/rpc_server.c b/dlls/rpcrt4/rpc_server.c
--- a/dlls/rpcrt4/rpc_server.c	2025-04-11 19:04:48.228317801 +0500
+++ b/dlls/rpcrt4/rpc_server.c	2025-04-11 19:10:08.159970097 +0500
@@ -701,6 +701,10 @@
   }
   LeaveCriticalSection(&cps->cs);
 
+  EnterCriticalSection(&listen_cs);
+  CloseHandle(cps->server_thread);
+  cps->server_thread = NULL;
+  LeaveCriticalSection(&listen_cs);
   TRACE("done\n");
   return 0;
 }
@@ -1566,10 +1570,7 @@
       LIST_FOR_EACH_ENTRY(protseq, &protseqs, RpcServerProtseq, entry)
       {
           if ((wait_thread = protseq->server_thread))
-          {
-              protseq->server_thread = NULL;
               break;
-          }
       }
       LeaveCriticalSection(&server_cs);
       if (!wait_thread)
@@ -1578,7 +1579,6 @@
       TRACE("waiting for thread %lu\n", GetThreadId(wait_thread));
       LeaveCriticalSection(&listen_cs);
       WaitForSingleObject(wait_thread, INFINITE);
-      CloseHandle(wait_thread);
       EnterCriticalSection(&listen_cs);
   }
   if (listen_done_event == event)
diff --color -u -r -N a/include/config.h.in b/include/config.h.in
--- a/include/config.h.in	2025-04-11 19:05:00.758337975 +0500
+++ b/include/config.h.in	2025-04-11 19:11:08.124236656 +0500
@@ -198,6 +198,9 @@
 /* Define to 1 if you have the <linux/major.h> header file. */
 #undef HAVE_LINUX_MAJOR_H
 
+/* Define to 1 if you have the <linux/ntsync.h> header file. */
+#undef HAVE_LINUX_NTSYNC_H
+
 /* Define to 1 if you have the <linux/param.h> header file. */
 #undef HAVE_LINUX_PARAM_H
 
@@ -534,9 +531,6 @@
 /* Define to 1 if you have the <sys/epoll.h> header file. */
 #undef HAVE_SYS_EPOLL_H
 
-/* Define to 1 if you have the <sys/eventfd.h> header file. */
-#undef HAVE_SYS_EVENTFD_H
-
 /* Define to 1 if you have the <sys/event.h> header file. */
 #undef HAVE_SYS_EVENT_H
 
diff --color -u -r -N a/include/wine/server_protocol.h b/include/wine/server_protocol.h
--- a/include/wine/server_protocol.h	2025-04-11 19:04:52.298898712 +0500
+++ b/include/wine/server_protocol.h	2025-04-11 19:23:40.710285002 +0500
@@ -5912,103 +5912,95 @@
     char __pad_12[4];
 };
 
-enum esync_type
-{
-    ESYNC_SEMAPHORE = 1,
-    ESYNC_AUTO_EVENT,
-    ESYNC_MANUAL_EVENT,
-    ESYNC_MUTEX,
-    ESYNC_AUTO_SERVER,
-    ESYNC_MANUAL_SERVER,
-    ESYNC_QUEUE,
-};
 
 
-struct create_esync_request
+struct set_keyboard_repeat_request
 {
     struct request_header __header;
-    unsigned int access;
-    int          initval;
-    int          type;
-    int          max;
-    /* VARARG(objattr,object_attributes); */
-    char __pad_28[4];
+    int enable;
+    int delay;
+    int period;
 };
-struct create_esync_reply
+struct set_keyboard_repeat_reply
 {
     struct reply_header __header;
-    obj_handle_t handle;
-    int          type;
-    unsigned int shm_idx;
-    char __pad_20[4];
+    int enable;
+    char __pad_12[4];
+};
+
+enum inproc_sync_type
+{
+    INPROC_SYNC_UNKNOWN,
+    INPROC_SYNC_AUTO_EVENT,
+    INPROC_SYNC_MANUAL_EVENT,
+    INPROC_SYNC_SEMAPHORE,
+    INPROC_SYNC_MUTEX,
+    INPROC_SYNC_AUTO_SERVER,
+    INPROC_SYNC_MANUAL_SERVER,
+    INPROC_SYNC_QUEUE,
 };
 
-struct open_esync_request
+
+
+struct get_linux_sync_device_request
 {
     struct request_header __header;
-    unsigned int access;
-    unsigned int attributes;
-    obj_handle_t rootdir;
-    int          type;
-    /* VARARG(name,unicode_str); */
-    char __pad_28[4];
+    char __pad_12[4];
 };
-struct open_esync_reply
+struct get_linux_sync_device_reply
 {
     struct reply_header __header;
-    obj_handle_t handle;
-    int          type;
-    unsigned int shm_idx;
-    char __pad_20[4];
 };
 
 
-struct get_esync_fd_request
+struct get_linux_sync_obj_request
 {
     struct request_header __header;
     obj_handle_t handle;
 };
-struct get_esync_fd_reply
+struct get_linux_sync_obj_reply
 {
     struct reply_header __header;
-    int          type;
-    unsigned int shm_idx;
+    int type;
+    unsigned int access;
 };
 
-struct esync_msgwait_request
+
+
+struct select_inproc_queue_request
 {
     struct request_header __header;
-    int          in_msgwait;
+    char __pad_12[4];
 };
-struct esync_msgwait_reply
+struct select_inproc_queue_reply
 {
     struct reply_header __header;
 };
 
 
-struct set_keyboard_repeat_request
+
+struct unselect_inproc_queue_request
 {
     struct request_header __header;
-    int enable;
-    int delay;
-    int period;
+    int          signaled;
 };
-struct set_keyboard_repeat_reply
+struct unselect_inproc_queue_reply
 {
     struct reply_header __header;
-    int enable;
-    char __pad_12[4];
 };
 
 
-struct get_esync_apc_fd_request
+
+struct get_inproc_alert_event_request
 {
     struct request_header __header;
     char __pad_12[4];
 };
-struct get_esync_apc_fd_reply
+struct get_inproc_alert_event_reply
 {
     struct reply_header __header;
+    obj_handle_t handle;
+    char __pad_12[4];
 };
 
 
@@ -6307,12 +6299,12 @@
     REQ_resume_process,
     REQ_get_next_process,
     REQ_get_next_thread,
-    REQ_create_esync,
-    REQ_open_esync,
-    REQ_get_esync_fd,
-    REQ_esync_msgwait,
     REQ_set_keyboard_repeat,
-    REQ_get_esync_apc_fd,
+    REQ_get_linux_sync_device,
+    REQ_get_linux_sync_obj,
+    REQ_select_inproc_queue,
+    REQ_unselect_inproc_queue,
+    REQ_get_inproc_alert_event,
     REQ_NB_REQUESTS
 };
 
@@ -6613,12 +6605,12 @@
     struct resume_process_request resume_process_request;
     struct get_next_process_request get_next_process_request;
     struct get_next_thread_request get_next_thread_request;
-    struct create_esync_request create_esync_request;
-    struct open_esync_request open_esync_request;
-    struct get_esync_fd_request get_esync_fd_request;
-    struct esync_msgwait_request esync_msgwait_request;
     struct set_keyboard_repeat_request set_keyboard_repeat_request;
-    struct get_esync_apc_fd_request get_esync_apc_fd_request;
+    struct get_linux_sync_device_request get_linux_sync_device_request;
+    struct get_linux_sync_obj_request get_linux_sync_obj_request;
+    struct select_inproc_queue_request select_inproc_queue_request;
+    struct unselect_inproc_queue_request unselect_inproc_queue_request;
+    struct get_inproc_alert_event_request get_inproc_alert_event_request;
 };
 union generic_reply
 {
@@ -6917,14 +6909,14 @@
     struct resume_process_reply resume_process_reply;
     struct get_next_process_reply get_next_process_reply;
     struct get_next_thread_reply get_next_thread_reply;
-    struct create_esync_reply create_esync_reply;
-    struct open_esync_reply open_esync_reply;
-    struct get_esync_fd_reply get_esync_fd_reply;
-    struct esync_msgwait_reply esync_msgwait_reply;
     struct set_keyboard_repeat_reply set_keyboard_repeat_reply;
-    struct get_esync_apc_fd_reply get_esync_apc_fd_reply;
+    struct get_linux_sync_device_reply get_linux_sync_device_reply;
+    struct get_linux_sync_obj_reply get_linux_sync_obj_reply;
+    struct select_inproc_queue_reply select_inproc_queue_reply;
+    struct unselect_inproc_queue_reply unselect_inproc_queue_reply;
+    struct get_inproc_alert_event_reply get_inproc_alert_event_reply;
 };
 
-#define SERVER_PROTOCOL_VERSION 866
+#define SERVER_PROTOCOL_VERSION 870
 
 #endif /* __WINE_WINE_SERVER_PROTOCOL_H */
---Zebediah Figura
diff --color -u -r -N a/server/async.c b/server/async.c
--- a/server/async.c	2025-04-11 19:04:48.193791715 +0500
+++ b/server/async.c	2025-04-11 19:11:08.127095010 +0500
@@ -78,7 +78,6 @@
     add_queue,                 /* add_queue */
     remove_queue,              /* remove_queue */
     async_signaled,            /* signaled */
-    NULL,                      /* get_esync_fd */
     async_satisfied,           /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
@@ -91,6 +90,7 @@
     NULL,                      /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_inproc_sync,        /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     async_destroy              /* destroy */
 };
@@ -699,7 +699,6 @@
     no_add_queue,             /* add_queue */
     NULL,                     /* remove_queue */
     NULL,                     /* signaled */
-    NULL,                     /* get_esync_fd */
     NULL,                     /* satisfied */
     no_signal,                /* signal */
     no_get_fd,                /* get_fd */
@@ -712,6 +711,7 @@
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_inproc_sync,       /* get_inproc_sync */
     no_close_handle,          /* close_handle */
     iosb_destroy              /* destroy */
 };
diff --color -u -r -N a/server/atom.c b/server/atom.c
--- a/server/atom.c	2025-04-11 19:04:48.193840177 +0500
+++ b/server/atom.c	2025-04-11 19:11:08.127211245 +0500
@@ -79,7 +79,6 @@
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
-    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
@@ -92,6 +91,7 @@
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     atom_table_destroy            /* destroy */
 };
diff --color -u -r -N a/server/change.c b/server/change.c
--- a/server/change.c	2025-04-11 19:04:49.305105539 +0500
+++ b/server/change.c	2025-04-11 19:11:08.142502927 +0500
@@ -112,7 +112,6 @@
     add_queue,                /* add_queue */
     remove_queue,             /* remove_queue */
     default_fd_signaled,      /* signaled */
-    default_fd_get_esync_fd,  /* get_esync_fd */
     no_satisfied,             /* satisfied */
     no_signal,                /* signal */
     dir_get_fd,               /* get_fd */
@@ -125,6 +124,7 @@
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    default_fd_get_inproc_sync, /* get_inproc_sync */
     dir_close_handle,         /* close_handle */
     dir_destroy               /* destroy */
 };
diff --color -u -r -N a/server/clipboard.c b/server/clipboard.c
--- a/server/clipboard.c	2025-04-11 19:04:48.193912114 +0500
+++ b/server/clipboard.c	2025-04-11 19:11:08.127459584 +0500
@@ -76,7 +76,6 @@
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
-    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
@@ -89,6 +88,7 @@
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     clipboard_destroy             /* destroy */
 };
diff --color -u -r -N a/server/completion.c b/server/completion.c
--- a/server/completion.c	2025-04-11 19:04:48.193949856 +0500
+++ b/server/completion.c	2025-04-11 19:11:08.138016282 +0500
@@ -25,6 +25,7 @@
 
 #include <stdarg.h>
 #include <stdio.h>
+#include <unistd.h>
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -77,6 +78,7 @@
     struct list    wait_queue;
     unsigned int   depth;
     int            closed;
+    int            inproc_sync;
 };
 
 static void completion_wait_dump( struct object*, int );
@@ -92,7 +94,6 @@
     add_queue,                      /* add_queue */
     remove_queue,                   /* remove_queue */
     completion_wait_signaled,       /* signaled */
-    NULL,                           /* get_esync_fd */
     completion_wait_satisfied,      /* satisfied */
     no_signal,                      /* signal */
     no_get_fd,                      /* get_fd */
@@ -105,6 +106,7 @@
     NULL,                           /* unlink_name */
     no_open_file,                   /* open_file */
     no_kernel_obj_list,             /* get_kernel_obj_list */
+    no_get_inproc_sync,             /* get_inproc_sync */
     no_close_handle,                /* close_handle */
     completion_wait_destroy         /* destroy */
 };
@@ -157,6 +159,7 @@
 static void completion_dump( struct object*, int );
 static int completion_signaled( struct object *obj, struct wait_queue_entry *entry );
 static int completion_close_handle( struct object *obj, struct process *process, obj_handle_t handle );
+static int completion_get_inproc_sync( struct object *obj, enum inproc_sync_type *type );
 static void completion_destroy( struct object * );
 
 static const struct object_ops completion_ops =
@@ -167,7 +170,6 @@
     add_queue,                 /* add_queue */
     remove_queue,              /* remove_queue */
     completion_signaled,       /* signaled */
-    NULL,                      /* get_esync_fd */
     no_satisfied,              /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
@@ -180,6 +182,7 @@
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    completion_get_inproc_sync,/* get_inproc_sync */
     completion_close_handle,   /* close_handle */
     completion_destroy         /* destroy */
 };
@@ -193,6 +196,7 @@
     {
         free( tmp );
     }
+    if (use_inproc_sync()) close( completion->inproc_sync );
 }
 
 static void completion_dump( struct object *obj, int verbose )
@@ -230,6 +234,7 @@
     }
     completion->closed = 1;
     wake_up( obj, 0 );
+    set_inproc_event( completion->inproc_sync );
     return 1;
 }
 
@@ -263,6 +268,14 @@
     return wait;
 }
 
+static int completion_get_inproc_sync( struct object *obj, enum inproc_sync_type *type )
+{
+    struct completion *completion = (struct completion *)obj;
+
+    *type = INPROC_SYNC_MANUAL_SERVER;
+    return completion->inproc_sync;
+}
+
 static struct completion *create_completion( struct object *root, const struct unicode_str *name,
                                              unsigned int attr, unsigned int concurrent,
                                              const struct security_descriptor *sd )
@@ -277,6 +290,7 @@
             list_init( &completion->wait_queue );
             completion->depth = 0;
             completion->closed = 0;
+            completion->inproc_sync = create_inproc_event( TRUE, FALSE );
         }
     }
 
@@ -309,7 +323,11 @@
         wake_up( &wait->obj, 1 );
         if (list_empty( &completion->queue )) return;
     }
-    if (!list_empty( &completion->queue )) wake_up( &completion->obj, 0 );
+    if (!list_empty( &completion->queue ))
+    {
+        wake_up( &completion->obj, 0 );
+        set_inproc_event( completion->inproc_sync );
+    }
 }
 
 /* create a completion */
@@ -410,6 +428,8 @@
         reply->information = msg->information;
         free( msg );
         reply->wait_handle = 0;
+        if (list_empty( &completion->queue ))
+            reset_inproc_event( completion->inproc_sync );
     }
 
     release_object( completion );
diff --color -u -r -N a/server/console.c b/server/console.c
--- a/server/console.c	2025-04-11 19:04:48.377703043 +0500
+++ b/server/console.c	2025-04-11 19:11:08.139476171 +0500
@@ -41,7 +41,6 @@
 #include "wincon.h"
 #include "winternl.h"
 #include "wine/condrv.h"
-#include "esync.h"
 
 struct screen_buffer;
 
@@ -55,6 +54,7 @@
 {
     struct object                obj;           /* object header */
     int                          signaled;      /* is console signaled */
+    int                          inproc_sync;   /* in-process synchronization object */
     struct thread               *renderer;      /* console renderer thread */
     struct screen_buffer        *active;        /* active screen buffer */
     struct console_server       *server;        /* console server object */
@@ -75,6 +75,7 @@
                                            unsigned int attr, struct object *root );
 static struct object *console_open_file( struct object *obj, unsigned int access,
                                          unsigned int sharing, unsigned int options );
+static int console_get_inproc_sync( struct object *obj, enum inproc_sync_type *type );
 static int console_add_queue( struct object *obj, struct wait_queue_entry *entry );
 
 static const struct object_ops console_ops =
@@ -85,7 +86,6 @@
     console_add_queue,                /* add_queue */
     remove_queue,                     /* remove_queue */
     console_signaled,                 /* signaled */
-    NULL,                             /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     console_get_fd,                   /* get_fd */
@@ -98,6 +98,7 @@
     NULL,                             /* unlink_name */
     console_open_file,                /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    console_get_inproc_sync,          /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     console_destroy                   /* destroy */
 };
@@ -135,27 +136,27 @@
 
 struct console_server
 {
-    struct object         obj;         /* object header */
-    struct fd            *fd;          /* pseudo-fd for ioctls */
-    struct console       *console;     /* attached console */
-    struct list           queue;       /* ioctl queue */
-    struct list           read_queue;  /* blocking read queue */
+    struct object         obj;            /* object header */
+    struct fd            *fd;             /* pseudo-fd for ioctls */
+    struct console       *console;        /* attached console */
+    struct list           queue;          /* ioctl queue */
+    struct list           read_queue;     /* blocking read queue */
     unsigned int          busy : 1;       /* flag if server processing an ioctl */
     unsigned int          once_input : 1; /* flag if input thread has already been requested */
-    int                   term_fd;     /* UNIX terminal fd */
-    struct termios        termios;     /* original termios */
-    int                   esync_fd;
+    int                   term_fd;        /* UNIX terminal fd */
+    struct termios        termios;        /* original termios */
+    int                   inproc_sync;    /* in-process synchronization object */
 };
 
 static void console_server_dump( struct object *obj, int verbose );
 static void console_server_destroy( struct object *obj );
 static int console_server_signaled( struct object *obj, struct wait_queue_entry *entry );
-static int console_server_get_esync_fd( struct object *obj, enum esync_type *type );
 static struct fd *console_server_get_fd( struct object *obj );
 static struct object *console_server_lookup_name( struct object *obj, struct unicode_str *name,
                                                 unsigned int attr, struct object *root );
 static struct object *console_server_open_file( struct object *obj, unsigned int access,
                                                 unsigned int sharing, unsigned int options );
+static int console_server_get_inproc_sync( struct object *obj, enum inproc_sync_type *type );
 
 static const struct object_ops console_server_ops =
 {
@@ -165,7 +166,6 @@
     add_queue,                        /* add_queue */
     remove_queue,                     /* remove_queue */
     console_server_signaled,          /* signaled */
-    console_server_get_esync_fd,      /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     console_server_get_fd,            /* get_fd */
@@ -178,6 +178,7 @@
     NULL,                             /* unlink_name */
     console_server_open_file,         /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    console_server_get_inproc_sync,   /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     console_server_destroy            /* destroy */
 };
@@ -218,6 +219,7 @@
     unsigned int          id;            /* buffer id */
     struct fd            *fd;            /* for bare console, attached output fd */
     struct async_queue    ioctl_q;       /* ioctl queue */
+    int                   inproc_sync;   /* in-process synchronization object */
 };
 
 static void screen_buffer_dump( struct object *obj, int verbose );
@@ -226,6 +228,7 @@
 static struct fd *screen_buffer_get_fd( struct object *obj );
 static struct object *screen_buffer_open_file( struct object *obj, unsigned int access,
                                                unsigned int sharing, unsigned int options );
+static int screen_buffer_get_inproc_sync( struct object *obj, enum inproc_sync_type *type );
 
 static const struct object_ops screen_buffer_ops =
 {
@@ -235,7 +238,6 @@
     add_queue,                        /* add_queue */
     remove_queue,                     /* remove_queue */
     screen_buffer_signaled,           /* signaled */
-    NULL,                             /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     screen_buffer_get_fd,             /* get_fd */
@@ -248,6 +250,7 @@
     NULL,                             /* unlink_name */
     screen_buffer_open_file,          /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    screen_buffer_get_inproc_sync,    /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     screen_buffer_destroy             /* destroy */
 };
@@ -285,7 +288,6 @@
     no_add_queue,                     /* add_queue */
     NULL,                             /* remove_queue */
     NULL,                             /* signaled */
-    NULL,                             /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     no_get_fd,                        /* get_fd */
@@ -298,6 +300,7 @@
     default_unlink_name,              /* unlink_name */
     console_device_open_file,         /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_inproc_sync,               /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     no_destroy                        /* destroy */
 };
@@ -308,12 +311,14 @@
     struct fd            *fd;          /* pseudo-fd */
     struct list           entry;       /* entry in console->inputs */
     struct console       *console;     /* associated console at creation time */
+    int                   inproc_sync; /* in-process synchronization object */
 };
 
 static void console_input_dump( struct object *obj, int verbose );
 static int console_input_signaled( struct object *obj, struct wait_queue_entry *entry );
 static struct object *console_input_open_file( struct object *obj, unsigned int access,
                                                unsigned int sharing, unsigned int options );
+static int console_input_get_inproc_sync( struct object *obj, enum inproc_sync_type *type );
 static struct fd *console_input_get_fd( struct object *obj );
 static void console_input_destroy( struct object *obj );
 
@@ -325,7 +330,6 @@
     add_queue,                        /* add_queue */
     remove_queue,                     /* remove_queue */
     console_input_signaled,           /* signaled */
-    NULL,                             /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     console_input_get_fd,             /* get_fd */
@@ -338,6 +342,7 @@
     default_unlink_name,              /* unlink_name */
     console_input_open_file,          /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    console_input_get_inproc_sync,    /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     console_input_destroy             /* destroy */
 };
@@ -368,6 +373,7 @@
     struct fd            *fd;          /* pseudo-fd */
     struct list           entry;       /* entry in console->outputs */
     struct console       *console;     /* associated console at creation time */
+    int                   inproc_sync; /* in-process synchronization object */
 };
 
 static void console_output_dump( struct object *obj, int verbose );
@@ -375,6 +381,7 @@
 static struct fd *console_output_get_fd( struct object *obj );
 static struct object *console_output_open_file( struct object *obj, unsigned int access,
                                                 unsigned int sharing, unsigned int options );
+static int console_output_get_inproc_sync( struct object *obj, enum inproc_sync_type *type );
 static void console_output_destroy( struct object *obj );
 
 static const struct object_ops console_output_ops =
@@ -385,7 +392,6 @@
     add_queue,                        /* add_queue */
     remove_queue,                     /* remove_queue */
     console_output_signaled,          /* signaled */
-    NULL,                             /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     console_output_get_fd,            /* get_fd */
@@ -398,6 +404,7 @@
     default_unlink_name,              /* unlink_name */
     console_output_open_file,         /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    console_output_get_inproc_sync,   /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     console_output_destroy            /* destroy */
 };
@@ -444,7 +451,6 @@
     no_add_queue,                     /* add_queue */
     NULL,                             /* remove_queue */
     NULL,                             /* signaled */
-    NULL,                             /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     console_connection_get_fd,        /* get_fd */
@@ -457,6 +463,7 @@
     default_unlink_name,              /* unlink_name */
     console_connection_open_file,     /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_inproc_sync,               /* get_inproc_sync */
     console_connection_close_handle,  /* close_handle */
     console_connection_destroy        /* destroy */
 };
@@ -550,6 +557,7 @@
 
     console->renderer      = NULL;
     console->signaled      = 0;
+    console->inproc_sync   = create_inproc_event( TRUE, console->signaled );
     console->active        = NULL;
     console->server        = NULL;
     console->fd            = NULL;
@@ -596,6 +604,7 @@
     }
     list_add_tail( &server->queue, &ioctl->entry );
     wake_up( &server->obj, 0 );
+    set_inproc_event( server->inproc_sync );
     if (async) set_error( STATUS_PENDING );
     return 1;
 }
@@ -608,8 +617,6 @@
         list_remove( &call->entry );
         console_host_ioctl_terminate( call, STATUS_CANCELLED );
     }
-    if (do_esync())
-        esync_clear( server->esync_fd );
     while (!list_empty( &server->read_queue ))
     {
         struct console_host_ioctl *call = LIST_ENTRY( list_head( &server->read_queue ), struct console_host_ioctl, entry );
@@ -630,6 +637,7 @@
         server->console->server = NULL;
         server->console = NULL;
         wake_up( &server->obj, 0 );
+        set_inproc_event( server->inproc_sync );
     }
 }
 
@@ -658,6 +666,7 @@
 
     screen_buffer->id    = ++console->last_id;
     screen_buffer->input = console;
+    screen_buffer->inproc_sync = create_inproc_event( TRUE, console->signaled );
     init_async_queue( &screen_buffer->ioctl_q );
     list_add_head( &console->screen_buffers, &screen_buffer->entry );
 
@@ -778,18 +787,28 @@
     console->active = NULL;
 
     LIST_FOR_EACH_ENTRY( curr, &console->screen_buffers, struct screen_buffer, entry )
+    {
         curr->input = NULL;
+        reset_inproc_event( curr->inproc_sync );
+    }
 
     LIST_FOR_EACH_ENTRY( input, &console->inputs, struct console_input, entry )
+    {
         input->console = NULL;
+        reset_inproc_event( input->inproc_sync );
+    }
 
     LIST_FOR_EACH_ENTRY( output, &console->outputs, struct console_output, entry )
+    {
         output->console = NULL;
+        reset_inproc_event( output->inproc_sync );
+    }
 
     free_async_queue( &console->ioctl_q );
     free_async_queue( &console->read_q );
     if (console->fd)
         release_object( console->fd );
+    if (use_inproc_sync()) close( console->inproc_sync );
 }
 
 static struct object *create_console_connection( struct console *console )
@@ -843,6 +862,22 @@
     return grab_object( obj );
 }
 
+static int console_get_inproc_sync( struct object *obj, enum inproc_sync_type *type )
+{
+    struct console *console = (struct console *)obj;
+
+    /* cf. console_add_queue() */
+    if (console->server && !console->server->once_input)
+    {
+        console->server->once_input = 1;
+        if (console->server->term_fd == -1)
+            queue_host_ioctl( console->server, IOCTL_CONDRV_PEEK, 0, NULL, NULL );
+    }
+
+    *type = INPROC_SYNC_MANUAL_SERVER;
+    return console->inproc_sync;
+}
+
 static void screen_buffer_dump( struct object *obj, int verbose )
 {
     struct screen_buffer *screen_buffer = (struct screen_buffer *)obj;
@@ -866,6 +901,7 @@
     }
     if (screen_buffer->fd) release_object( screen_buffer->fd );
     free_async_queue( &screen_buffer->ioctl_q );
+    if (use_inproc_sync()) close( screen_buffer->inproc_sync );
 }
 
 static int screen_buffer_signaled( struct object *obj, struct wait_queue_entry *entry )
@@ -882,6 +918,14 @@
     return grab_object( obj );
 }
 
+static int screen_buffer_get_inproc_sync( struct object *obj, enum inproc_sync_type *type )
+{
+    struct screen_buffer *screen_buffer = (struct screen_buffer *)obj;
+
+    *type = INPROC_SYNC_MANUAL_SERVER;
+    return screen_buffer->inproc_sync;
+}
+
 static struct fd *screen_buffer_get_fd( struct object *obj )
 {
     struct screen_buffer *screen_buffer = (struct screen_buffer*)obj;
@@ -904,7 +948,7 @@
     assert( obj->ops == &console_server_ops );
     disconnect_console_server( server );
     if (server->fd) release_object( server->fd );
-    if (do_esync()) close( server->esync_fd );
+    if (use_inproc_sync()) close( server->inproc_sync );
 }
 
 static struct object *console_server_lookup_name( struct object *obj, struct unicode_str *name,
@@ -952,13 +996,6 @@
     return !server->console || !list_empty( &server->queue );
 }
 
-static int console_server_get_esync_fd( struct object *obj, enum esync_type *type )
-{
-    struct console_server *server = (struct console_server*)obj;
-    *type = ESYNC_MANUAL_SERVER;
-    return server->esync_fd;
-}
-
 static struct fd *console_server_get_fd( struct object* obj )
 {
     struct console_server *server = (struct console_server*)obj;
@@ -972,6 +1009,14 @@
     return grab_object( obj );
 }
 
+static int console_server_get_inproc_sync( struct object *obj, enum inproc_sync_type *type )
+{
+    struct console_server *server = (struct console_server *)obj;
+
+    *type = INPROC_SYNC_MANUAL_SERVER;
+    return server->inproc_sync;
+}
+
 static struct object *create_console_server( void )
 {
     struct console_server *server;
@@ -981,6 +1026,7 @@
     server->busy       = 0;
     server->once_input = 0;
     server->term_fd    = -1;
+    server->inproc_sync = create_inproc_event( TRUE, TRUE );
     list_init( &server->queue );
     list_init( &server->read_queue );
     server->fd = alloc_pseudo_fd( &console_server_fd_ops, &server->obj, FILE_SYNCHRONOUS_IO_NONALERT );
@@ -990,10 +1036,6 @@
         return NULL;
     }
     allow_fd_caching(server->fd);
-    server->esync_fd = -1;
-
-    if (do_esync())
-        server->esync_fd = esync_create_fd( 0, 0 );
 
     return &server->obj;
 }
@@ -1370,6 +1412,7 @@
         }
         console_input->console = current->process->console;
         list_add_head( &current->process->console->inputs, &console_input->entry );
+        console_input->inproc_sync = create_inproc_event( TRUE, current->process->console->signaled );
         return &console_input->obj;
     }
 
@@ -1394,6 +1437,7 @@
         }
         console_output->console = current->process->console;
         list_add_head( &current->process->console->outputs, &console_output->entry );
+        console_output->inproc_sync = create_inproc_event( TRUE, current->process->console->signaled );
         return &console_output->obj;
     }
 
@@ -1468,6 +1512,14 @@
     return grab_object( obj );
 }
 
+static int console_input_get_inproc_sync( struct object *obj, enum inproc_sync_type *type )
+{
+    struct console_input *console_input = (struct console_input *)obj;
+
+    *type = INPROC_SYNC_MANUAL_SERVER;
+    return console_input->inproc_sync;
+}
+
 static void console_input_destroy( struct object *obj )
 {
     struct console_input *console_input = (struct console_input *)obj;
@@ -1475,6 +1527,7 @@
     assert( obj->ops == &console_input_ops );
     if (console_input->fd) release_object( console_input->fd );
     if (console_input->console) list_remove( &console_input->entry );
+    if (use_inproc_sync()) close( console_input->inproc_sync );
 }
 
 static void console_input_ioctl( struct fd *fd, ioctl_code_t code, struct async *async )
@@ -1539,6 +1592,14 @@
     return grab_object( obj );
 }
 
+static int console_output_get_inproc_sync( struct object *obj, enum inproc_sync_type *type )
+{
+    struct console_output *console_output = (struct console_output *)obj;
+
+    *type = INPROC_SYNC_MANUAL_SERVER;
+    return console_output->inproc_sync;
+}
+
 static void console_output_destroy( struct object *obj )
 {
     struct console_output *console_output = (struct console_output *)obj;
@@ -1546,6 +1607,7 @@
     assert( obj->ops == &console_output_ops );
     if (console_output->fd) release_object( console_output->fd );
     if (console_output->console) list_remove( &console_output->entry );
+    if (use_inproc_sync()) close( console_output->inproc_sync );
 }
 
 static void console_output_ioctl( struct fd *fd, ioctl_code_t code, struct async *async )
@@ -1600,17 +1662,37 @@
 
     if (!server->console->renderer) server->console->renderer = current;
 
-    if (!req->signal) server->console->signaled = 0;
+    if (!req->signal)
+    {
+        server->console->signaled = 0;
+        reset_inproc_event( server->console->inproc_sync );
+        LIST_FOR_EACH_ENTRY( screen_buffer, &server->console->screen_buffers, struct screen_buffer, entry )
+            reset_inproc_event( screen_buffer->inproc_sync );
+        LIST_FOR_EACH_ENTRY( input, &server->console->inputs, struct console_input, entry )
+            reset_inproc_event( input->inproc_sync );
+        LIST_FOR_EACH_ENTRY( output, &server->console->outputs, struct console_output, entry )
+            reset_inproc_event( output->inproc_sync );
+    }
     else if (!server->console->signaled)
     {
         server->console->signaled = 1;
         wake_up( &server->console->obj, 0 );
+        set_inproc_event( server->console->inproc_sync );
         LIST_FOR_EACH_ENTRY( screen_buffer, &server->console->screen_buffers, struct screen_buffer, entry )
+        {
             wake_up( &screen_buffer->obj, 0 );
+            set_inproc_event( screen_buffer->inproc_sync );
+        }
         LIST_FOR_EACH_ENTRY( input, &server->console->inputs, struct console_input, entry )
+        {
             wake_up( &input->obj, 0 );
+            set_inproc_event( input->inproc_sync );
+        }
         LIST_FOR_EACH_ENTRY( output, &server->console->outputs, struct console_output, entry )
+        {
             wake_up( &output->obj, 0 );
+            set_inproc_event( output->inproc_sync );
+        }
     }
 
     if (req->read)
@@ -1632,10 +1714,11 @@
         /* set result of previous ioctl */
         ioctl = LIST_ENTRY( list_head( &server->queue ), struct console_host_ioctl, entry );
         list_remove( &ioctl->entry );
-        if (do_esync() && list_empty( &server->queue ))
-            esync_clear( server->esync_fd );
     }
 
+    if (list_empty( &server->queue ))
+        reset_inproc_event( server->inproc_sync );
+
     if (ioctl)
     {
         struct async *async = ioctl->async;
@@ -1719,8 +1802,9 @@
     {
         set_error( STATUS_PENDING );
     }
-    if (do_esync() && list_empty( &server->queue ))
-        esync_clear( server->esync_fd );
+
+    if (list_empty( &server->queue ))
+        reset_inproc_event( server->inproc_sync );
 
     release_object( server );
 }
diff --color -u -r -N a/server/debugger.c b/server/debugger.c
--- a/server/debugger.c	2025-04-11 19:04:48.194045528 +0500
+++ b/server/debugger.c	2025-04-11 19:11:08.139680229 +0500
@@ -71,6 +71,7 @@
     struct object        obj;         /* object header */
     struct list          event_queue; /* pending events queue */
     unsigned int         flags;       /* debug flags */
+    int                  inproc_sync; /* in-process synchronization object */
 };
 
 
@@ -86,7 +87,6 @@
     add_queue,                     /* add_queue */
     remove_queue,                  /* remove_queue */
     debug_event_signaled,          /* signaled */
-    NULL,                          /* get_esync_fd */
     no_satisfied,                  /* satisfied */
     no_signal,                     /* signal */
     no_get_fd,                     /* get_fd */
@@ -99,12 +99,14 @@
     NULL,                          /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
+    no_get_inproc_sync,            /* get_inproc_sync */
     no_close_handle,               /* close_handle */
     debug_event_destroy            /* destroy */
 };
 
 static void debug_obj_dump( struct object *obj, int verbose );
 static int debug_obj_signaled( struct object *obj, struct wait_queue_entry *entry );
+static int debug_obj_get_inproc_sync( struct object *obj, enum inproc_sync_type *type );
 static void debug_obj_destroy( struct object *obj );
 
 static const struct object_ops debug_obj_ops =
@@ -115,7 +117,6 @@
     add_queue,                     /* add_queue */
     remove_queue,                  /* remove_queue */
     debug_obj_signaled,            /* signaled */
-    NULL,                          /* get_esync_fd */
     no_satisfied,                  /* satisfied */
     no_signal,                     /* signal */
     no_get_fd,                     /* get_fd */
@@ -128,6 +129,7 @@
     default_unlink_name,           /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
+    debug_obj_get_inproc_sync,     /* get_inproc_sync */
     no_close_handle,               /* close_handle */
     debug_obj_destroy              /* destroy */
 };
@@ -255,6 +257,7 @@
         /* grab reference since debugger could be killed while trying to wake up */
         grab_object( debug_obj );
         wake_up( &debug_obj->obj, 0 );
+        set_inproc_event( debug_obj->inproc_sync );
         release_object( debug_obj );
     }
 }
@@ -267,6 +270,7 @@
     {
         grab_object( debug_obj );
         wake_up( &debug_obj->obj, 0 );
+        set_inproc_event( debug_obj->inproc_sync );
         release_object( debug_obj );
     }
 }
@@ -332,6 +336,14 @@
     return find_event_to_send( debug_obj ) != NULL;
 }
 
+static int debug_obj_get_inproc_sync( struct object *obj, enum inproc_sync_type *type )
+{
+    struct debug_obj *debug_obj = (struct debug_obj *)obj;
+
+    *type = INPROC_SYNC_MANUAL_SERVER;
+    return debug_obj->inproc_sync;
+}
+
 static void debug_obj_destroy( struct object *obj )
 {
     struct list *ptr;
@@ -344,6 +356,8 @@
     /* free all pending events */
     while ((ptr = list_head( &debug_obj->event_queue )))
         unlink_event( debug_obj, LIST_ENTRY( ptr, struct debug_event, entry ));
+
+    if (use_inproc_sync()) close( debug_obj->inproc_sync );
 }
 
 struct debug_obj *get_debug_obj( struct process *process, obj_handle_t handle, unsigned int access )
@@ -363,6 +377,7 @@
         {
             debug_obj->flags = flags;
             list_init( &debug_obj->event_queue );
+            debug_obj->inproc_sync = create_inproc_event( TRUE, FALSE );
         }
     }
     return debug_obj;
@@ -571,6 +586,9 @@
         reply->tid = get_thread_id( event->sender );
         alloc_event_handles( event, current->process );
         set_reply_data( &event->data, min( get_reply_max_size(), sizeof(event->data) ));
+
+        if (!find_event_to_send( debug_obj ))
+            reset_inproc_event( debug_obj->inproc_sync );
     }
     else
     {
diff --color -u -r -N a/server/device.c b/server/device.c
--- a/server/device.c	2025-04-11 19:04:48.241569951 +0500
+++ b/server/device.c	2025-04-11 19:11:08.143119888 +0500
@@ -25,6 +25,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdarg.h>
+#include <unistd.h>
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -38,7 +39,6 @@
 #include "handle.h"
 #include "request.h"
 #include "process.h"
-#include "esync.h"
 
 /* IRP object */
 
@@ -67,7 +67,6 @@
     no_add_queue,                     /* add_queue */
     NULL,                             /* remove_queue */
     NULL,                             /* signaled */
-    NULL,                             /* get_esync_fd */
     NULL,                             /* satisfied */
     no_signal,                        /* signal */
     no_get_fd,                        /* get_fd */
@@ -80,6 +79,7 @@
     NULL,                             /* unlink_name */
     no_open_file,                     /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_inproc_sync,               /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     irp_call_destroy                  /* destroy */
 };
@@ -94,12 +94,12 @@
     struct list            requests;       /* list of pending irps across all devices */
     struct irp_call       *current_call;   /* call currently executed on client side */
     struct wine_rb_tree    kernel_objects; /* map of objects that have client side pointer associated */
-    int                    esync_fd;       /* esync file descriptor */
+    int                    inproc_sync;    /* in-process synchronization object */
 };
 
 static void device_manager_dump( struct object *obj, int verbose );
 static int device_manager_signaled( struct object *obj, struct wait_queue_entry *entry );
-static int device_manager_get_esync_fd( struct object *obj, enum esync_type *type );
+static int device_manager_get_inproc_sync( struct object *obj, enum inproc_sync_type *type );
 static void device_manager_destroy( struct object *obj );
 
 static const struct object_ops device_manager_ops =
@@ -110,7 +110,6 @@
     add_queue,                        /* add_queue */
     remove_queue,                     /* remove_queue */
     device_manager_signaled,          /* signaled */
-    device_manager_get_esync_fd,      /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     no_get_fd,                        /* get_fd */
@@ -123,6 +122,7 @@
     NULL,                             /* unlink_name */
     no_open_file,                     /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    device_manager_get_inproc_sync,   /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     device_manager_destroy            /* destroy */
 };
@@ -168,7 +168,6 @@
     no_add_queue,                     /* add_queue */
     NULL,                             /* remove_queue */
     NULL,                             /* signaled */
-    NULL,                             /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     no_get_fd,                        /* get_fd */
@@ -181,6 +180,7 @@
     default_unlink_name,              /* unlink_name */
     device_open_file,                 /* open_file */
     device_get_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_inproc_sync,               /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     device_destroy                    /* destroy */
 };
@@ -221,7 +221,6 @@
     add_queue,                        /* add_queue */
     remove_queue,                     /* remove_queue */
     default_fd_signaled,              /* signaled */
-    NULL,                             /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     device_file_get_fd,               /* get_fd */
@@ -234,6 +233,7 @@
     NULL,                             /* unlink_name */
     no_open_file,                     /* open_file */
     device_file_get_kernel_obj_list,  /* get_kernel_obj_list */
+    default_fd_get_inproc_sync,       /* get_inproc_sync */
     device_file_close_handle,         /* close_handle */
     device_file_destroy               /* destroy */
 };
@@ -425,7 +425,12 @@
     irp->thread = thread ? (struct thread *)grab_object( thread ) : NULL;
     if (irp->file) list_add_tail( &irp->file->requests, &irp->dev_entry );
     list_add_tail( &manager->requests, &irp->mgr_entry );
-    if (list_head( &manager->requests ) == &irp->mgr_entry) wake_up( &manager->obj, 0 );  /* first one */
+    if (list_head( &manager->requests ) == &irp->mgr_entry)
+    {
+        /* first one */
+        wake_up( &manager->obj, 0 );
+        set_inproc_event( manager->inproc_sync );
+    }
 }
 
 static struct object *device_open_file( struct object *obj, unsigned int access,
@@ -755,13 +760,13 @@
     /* terminate all pending requests */
     LIST_FOR_EACH_ENTRY_SAFE( irp, next, &file->requests, struct irp_call, dev_entry )
     {
-        if (do_esync() && file->device->manager && list_empty( &file->device->manager->requests ))
-            esync_clear( file->device->manager->esync_fd );
-
         list_remove( &irp->mgr_entry );
         set_irp_result( irp, STATUS_FILE_DELETED, NULL, 0, 0 );
     }
 
+    if (list_empty( &file->device->manager->requests ))
+        reset_inproc_event( file->device->manager->inproc_sync );
+
     release_object( file );
 }
 
@@ -793,11 +798,12 @@
     return !list_empty( &manager->requests );
 }
 
-static int device_manager_get_esync_fd( struct object *obj, enum esync_type *type )
+static int device_manager_get_inproc_sync( struct object *obj, enum inproc_sync_type *type )
 {
     struct device_manager *manager = (struct device_manager *)obj;
-    *type = ESYNC_MANUAL_SERVER;
-    return manager->esync_fd;
+
+    *type = INPROC_SYNC_MANUAL_SERVER;
+    return manager->inproc_sync;
 }
 
 static void device_manager_destroy( struct object *obj )
@@ -835,8 +841,7 @@
         release_object( irp );
     }
 
-    if (do_esync())
-        close( manager->esync_fd );
+    if (use_inproc_sync()) close( manager->inproc_sync );
 }
 
 static struct device_manager *create_device_manager(void)
@@ -846,12 +851,10 @@
     if ((manager = alloc_object( &device_manager_ops )))
     {
         manager->current_call = NULL;
+        manager->inproc_sync = create_inproc_event( TRUE, FALSE );
         list_init( &manager->devices );
         list_init( &manager->requests );
         wine_rb_init( &manager->kernel_objects, compare_kernel_object );
-
-        if (do_esync())
-            manager->esync_fd = esync_create_fd( 0, 0 );
     }
     return manager;
 }
@@ -1038,12 +1041,13 @@
                 }
                 list_remove( &irp->mgr_entry );
                 list_init( &irp->mgr_entry );
+
+                if (list_empty( &manager->requests ))
+                    reset_inproc_event( manager->inproc_sync );
+
                 /* we already own the object if it's only on manager queue */
                 if (irp->file) grab_object( irp );
                 manager->current_call = irp;
-
-                if (do_esync() && list_empty( &manager->requests ))
-                    esync_clear( manager->esync_fd );
             }
             else close_handle( current->process, reply->next );
         }
diff --color -u -r -N a/server/directory.c b/server/directory.c
--- a/server/directory.c	2025-04-11 19:04:48.194133446 +0500
+++ b/server/directory.c	2025-04-11 19:11:08.128126157 +0500
@@ -69,7 +69,6 @@
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
-    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
@@ -82,6 +81,7 @@
     default_unlink_name,          /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     no_destroy                    /* destroy */
 };
@@ -120,7 +120,6 @@
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
-    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
@@ -133,6 +132,7 @@
     default_unlink_name,          /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     directory_destroy             /* destroy */
 };
diff --color -u -r -N a/server/esync.c b/server/esync.c
--- a/server/esync.c	2025-04-11 19:04:48.373827562 +0500
+++ b/server/esync.c	1970-01-01 05:00:00.000000000 +0500
@@ -1,588 +0,0 @@
-/*
- * eventfd-based synchronization objects
- *
- * Copyright (C) 2018 Zebediah Figura
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#include "config.h"
-
-
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdarg.h>
-#ifdef HAVE_SYS_EVENTFD_H
-# include <sys/eventfd.h>
-#endif
-#include <sys/mman.h>
-#ifdef HAVE_SYS_STAT_H
-# include <sys/stat.h>
-#endif
-#include <unistd.h>
-
-#include "ntstatus.h"
-#define WIN32_NO_STATUS
-#include "windef.h"
-#include "winternl.h"
-
-#include "handle.h"
-#include "request.h"
-#include "file.h"
-#include "esync.h"
-
-int do_esync(void)
-{
-#ifdef HAVE_SYS_EVENTFD_H
-    static int do_esync_cached = -1;
-
-    if (do_esync_cached == -1)
-        do_esync_cached = getenv("WINEESYNC") && atoi(getenv("WINEESYNC"));
-
-    return do_esync_cached;
-#else
-    return 0;
-#endif
-}
-
-static char shm_name[29];
-static int shm_fd;
-static off_t shm_size;
-static void **shm_addrs;
-static int shm_addrs_size;  /* length of the allocated shm_addrs array */
-static long pagesize;
-
-static void shm_cleanup(void)
-{
-    close( shm_fd );
-    if (shm_unlink( shm_name ) == -1)
-        perror( "shm_unlink" );
-}
-
-void esync_init(void)
-{
-    struct stat st;
-
-    if (fstat( config_dir_fd, &st ) == -1)
-        fatal_error( "cannot stat config dir\n" );
-
-    if (st.st_ino != (unsigned long)st.st_ino)
-        sprintf( shm_name, "/wine-%lx%08lx-esync", (unsigned long)((unsigned long long)st.st_ino >> 32), (unsigned long)st.st_ino );
-    else
-        sprintf( shm_name, "/wine-%lx-esync", (unsigned long)st.st_ino );
-
-    shm_unlink( shm_name );
-
-    shm_fd = shm_open( shm_name, O_RDWR | O_CREAT | O_EXCL, 0644 );
-    if (shm_fd == -1)
-        perror( "shm_open" );
-
-    pagesize = sysconf( _SC_PAGESIZE );
-
-    shm_addrs = calloc( 128, sizeof(shm_addrs[0]) );
-    shm_addrs_size = 128;
-
-    shm_size = pagesize;
-    if (ftruncate( shm_fd, shm_size ) == -1)
-        perror( "ftruncate" );
-
-    fprintf( stderr, "esync: up and running.\n" );
-
-    atexit( shm_cleanup );
-}
-
-static struct list mutex_list = LIST_INIT(mutex_list);
-
-struct esync
-{
-    struct object   obj;            /* object header */
-    int             fd;             /* eventfd file descriptor */
-    enum esync_type type;
-    unsigned int    shm_idx;        /* index into the shared memory section */
-    struct list     mutex_entry;    /* entry in the mutex list (if applicable) */
-};
-
-static void esync_dump( struct object *obj, int verbose );
-static int esync_get_esync_fd( struct object *obj, enum esync_type *type );
-static unsigned int esync_map_access( struct object *obj, unsigned int access );
-static void esync_destroy( struct object *obj );
-
-const struct object_ops esync_ops =
-{
-    sizeof(struct esync),      /* size */
-    &no_type,                  /* type */
-    esync_dump,                /* dump */
-    no_add_queue,              /* add_queue */
-    NULL,                      /* remove_queue */
-    NULL,                      /* signaled */
-    esync_get_esync_fd,        /* get_esync_fd */
-    NULL,                      /* satisfied */
-    no_signal,                 /* signal */
-    no_get_fd,                 /* get_fd */
-    esync_map_access,          /* map_access */
-    default_get_sd,            /* get_sd */
-    default_set_sd,            /* set_sd */
-    default_get_full_name,     /* get_full_name */
-    no_lookup_name,            /* lookup_name */
-    directory_link_name,       /* link_name */
-    default_unlink_name,       /* unlink_name */
-    no_open_file,              /* open_file */
-    no_kernel_obj_list,        /* get_kernel_obj_list */
-    no_close_handle,           /* close_handle */
-    esync_destroy              /* destroy */
-};
-
-static void esync_dump( struct object *obj, int verbose )
-{
-    struct esync *esync = (struct esync *)obj;
-    assert( obj->ops == &esync_ops );
-    fprintf( stderr, "esync fd=%d\n", esync->fd );
-}
-
-static int esync_get_esync_fd( struct object *obj, enum esync_type *type )
-{
-    struct esync *esync = (struct esync *)obj;
-    *type = esync->type;
-    return esync->fd;
-}
-
-static unsigned int esync_map_access( struct object *obj, unsigned int access )
-{
-    /* Sync objects have the same flags. */
-    if (access & GENERIC_READ)    access |= STANDARD_RIGHTS_READ | EVENT_QUERY_STATE;
-    if (access & GENERIC_WRITE)   access |= STANDARD_RIGHTS_WRITE | EVENT_MODIFY_STATE;
-    if (access & GENERIC_EXECUTE) access |= STANDARD_RIGHTS_EXECUTE | SYNCHRONIZE;
-    if (access & GENERIC_ALL)     access |= STANDARD_RIGHTS_ALL | EVENT_QUERY_STATE | EVENT_MODIFY_STATE;
-    return access & ~(GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL);
-}
-
-static void esync_destroy( struct object *obj )
-{
-    struct esync *esync = (struct esync *)obj;
-    if (esync->type == ESYNC_MUTEX)
-        list_remove( &esync->mutex_entry );
-    close( esync->fd );
-}
-
-static int type_matches( enum esync_type type1, enum esync_type type2 )
-{
-    return (type1 == type2) ||
-           ((type1 == ESYNC_AUTO_EVENT || type1 == ESYNC_MANUAL_EVENT) &&
-            (type2 == ESYNC_AUTO_EVENT || type2 == ESYNC_MANUAL_EVENT));
-}
-
-static void *get_shm( unsigned int idx )
-{
-    int entry  = (idx * 8) / pagesize;
-    int offset = (idx * 8) % pagesize;
-
-    if (entry >= shm_addrs_size)
-    {
-        int new_size = max(shm_addrs_size * 2, entry + 1);
-
-        if (!(shm_addrs = realloc( shm_addrs, new_size * sizeof(shm_addrs[0]) )))
-            fprintf( stderr, "esync: couldn't expand shm_addrs array to size %d\n", entry + 1 );
-
-        memset( shm_addrs + shm_addrs_size, 0, (new_size - shm_addrs_size) * sizeof(shm_addrs[0]) );
-
-        shm_addrs_size = new_size;
-    }
-
-    if (!shm_addrs[entry])
-    {
-        void *addr = mmap( NULL, pagesize, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, entry * pagesize );
-        if (addr == (void *)-1)
-        {
-            fprintf( stderr, "esync: failed to map page %d (offset %#lx): ", entry, entry * pagesize );
-            perror( "mmap" );
-        }
-
-        if (debug_level)
-            fprintf( stderr, "esync: Mapping page %d at %p.\n", entry, addr );
-
-        if (__sync_val_compare_and_swap( &shm_addrs[entry], 0, addr ))
-            munmap( addr, pagesize ); /* someone beat us to it */
-    }
-
-    return (void *)((unsigned long)shm_addrs[entry] + offset);
-}
-
-struct semaphore
-{
-    int max;
-    int count;
-};
-C_ASSERT(sizeof(struct semaphore) == 8);
-
-struct mutex
-{
-    DWORD tid;
-    int count;    /* recursion count */
-};
-C_ASSERT(sizeof(struct mutex) == 8);
-
-struct event
-{
-    int signaled;
-    int locked;
-};
-C_ASSERT(sizeof(struct event) == 8);
-
-struct esync *create_esync( struct object *root, const struct unicode_str *name,
-                            unsigned int attr, int initval, int max, enum esync_type type,
-                            const struct security_descriptor *sd )
-{
-#ifdef HAVE_SYS_EVENTFD_H
-    struct esync *esync;
-
-    if ((esync = create_named_object( root, &esync_ops, name, attr, sd )))
-    {
-        if (get_error() != STATUS_OBJECT_NAME_EXISTS)
-        {
-            int flags = EFD_CLOEXEC | EFD_NONBLOCK;
-
-            if (type == ESYNC_SEMAPHORE)
-                flags |= EFD_SEMAPHORE;
-
-            /* initialize it if it didn't already exist */
-            esync->fd = eventfd( initval, flags );
-            if (esync->fd == -1)
-            {
-                perror( "eventfd" );
-                file_set_error();
-                release_object( esync );
-                return NULL;
-            }
-            esync->type = type;
-
-            /* Use the fd as index, since that'll be unique across all
-             * processes, but should hopefully end up also allowing reuse. */
-            esync->shm_idx = esync->fd + 1; /* we keep index 0 reserved */
-            while (esync->shm_idx * 8 >= shm_size)
-            {
-                /* Better expand the shm section. */
-                shm_size += pagesize;
-                if (ftruncate( shm_fd, shm_size ) == -1)
-                {
-                    fprintf( stderr, "esync: couldn't expand %s to size %ld: ",
-                             shm_name, (long)shm_size );
-                    perror( "ftruncate" );
-                }
-            }
-
-            /* Initialize the shared memory portion. We want to do this on the
-             * server side to avoid a potential though unlikely race whereby
-             * the same object is opened and used between the time it's created
-             * and the time its shared memory portion is initialized. */
-            switch (type)
-            {
-            case ESYNC_SEMAPHORE:
-            {
-                struct semaphore *semaphore = get_shm( esync->shm_idx );
-                semaphore->max = max;
-                semaphore->count = initval;
-                break;
-            }
-            case ESYNC_AUTO_EVENT:
-            case ESYNC_MANUAL_EVENT:
-            {
-                struct event *event = get_shm( esync->shm_idx );
-                event->signaled = initval ? 1 : 0;
-                event->locked = 0;
-                break;
-            }
-            case ESYNC_MUTEX:
-            {
-                struct mutex *mutex = get_shm( esync->shm_idx );
-                mutex->tid = initval ? 0 : current->id;
-                mutex->count = initval ? 0 : 1;
-                list_add_tail( &mutex_list, &esync->mutex_entry );
-                break;
-            }
-            default:
-                assert( 0 );
-            }
-        }
-        else
-        {
-            /* validate the type */
-            if (!type_matches( type, esync->type ))
-            {
-                release_object( &esync->obj );
-                set_error( STATUS_OBJECT_TYPE_MISMATCH );
-                return NULL;
-            }
-        }
-    }
-    return esync;
-#else
-    /* FIXME: Provide a fallback implementation using pipe(). */
-    set_error( STATUS_NOT_IMPLEMENTED );
-    return NULL;
-#endif
-}
-
-/* Create a file descriptor for an existing handle.
- * Caller must close the handle when it's done; it's not linked to an esync
- * server object in any way. */
-int esync_create_fd( int initval, int flags )
-{
-#ifdef HAVE_SYS_EVENTFD_H
-    int fd;
-
-    fd = eventfd( initval, flags | EFD_CLOEXEC | EFD_NONBLOCK );
-    if (fd == -1)
-        perror( "eventfd" );
-
-    return fd;
-#else
-    return -1;
-#endif
-}
-
-/* Wake up a specific fd. */
-void esync_wake_fd( int fd )
-{
-    static const uint64_t value = 1;
-
-    if (write( fd, &value, sizeof(value) ) == -1)
-        perror( "esync: write" );
-}
-
-/* Wake up a server-side esync object. */
-void esync_wake_up( struct object *obj )
-{
-    enum esync_type dummy;
-    int fd;
-
-    if (obj->ops->get_esync_fd)
-    {
-        fd = obj->ops->get_esync_fd( obj, &dummy );
-        esync_wake_fd( fd );
-    }
-}
-
-void esync_clear( int fd )
-{
-    uint64_t value;
-
-    /* we don't care about the return value */
-    read( fd, &value, sizeof(value) );
-}
-
-static inline void small_pause(void)
-{
-#ifdef __i386__
-    __asm__ __volatile__( "rep;nop" : : : "memory" );
-#else
-    __asm__ __volatile__( "" : : : "memory" );
-#endif
-}
-
-/* Server-side event support. */
-void esync_set_event( struct esync *esync )
-{
-    static const uint64_t value = 1;
-    struct event *event = get_shm( esync->shm_idx );
-
-    assert( esync->obj.ops == &esync_ops );
-    assert( event != NULL );
-
-    if (debug_level)
-        fprintf( stderr, "esync_set_event() fd=%d\n", esync->fd );
-
-    if (esync->type == ESYNC_MANUAL_EVENT)
-    {
-        /* Acquire the spinlock. */
-        while (__sync_val_compare_and_swap( &event->locked, 0, 1 ))
-            small_pause();
-    }
-
-    if (!__atomic_exchange_n( &event->signaled, 1, __ATOMIC_SEQ_CST ))
-    {
-        if (write( esync->fd, &value, sizeof(value) ) == -1)
-            perror( "esync: write" );
-    }
-
-    if (esync->type == ESYNC_MANUAL_EVENT)
-    {
-        /* Release the spinlock. */
-        event->locked = 0;
-    }
-}
-
-void esync_reset_event( struct esync *esync )
-{
-    static uint64_t value = 1;
-    struct event *event = get_shm( esync->shm_idx );
-
-    assert( esync->obj.ops == &esync_ops );
-    assert( event != NULL );
-
-    if (debug_level)
-        fprintf( stderr, "esync_reset_event() fd=%d\n", esync->fd );
-
-    if (esync->type == ESYNC_MANUAL_EVENT)
-    {
-        /* Acquire the spinlock. */
-        while (__sync_val_compare_and_swap( &event->locked, 0, 1 ))
-            small_pause();
-    }
-
-    /* Only bother signaling the fd if we weren't already signaled. */
-    if (__atomic_exchange_n( &event->signaled, 0, __ATOMIC_SEQ_CST ))
-    {
-        /* we don't care about the return value */
-        read( esync->fd, &value, sizeof(value) );
-    }
-
-    if (esync->type == ESYNC_MANUAL_EVENT)
-    {
-        /* Release the spinlock. */
-        event->locked = 0;
-    }
-}
-
-void esync_abandon_mutexes( struct thread *thread )
-{
-    struct esync *esync;
-
-    LIST_FOR_EACH_ENTRY( esync, &mutex_list, struct esync, mutex_entry )
-    {
-        struct mutex *mutex = get_shm( esync->shm_idx );
-
-        if (mutex->tid == thread->id)
-        {
-            if (debug_level)
-                fprintf( stderr, "esync_abandon_mutexes() fd=%d\n", esync->fd );
-            mutex->tid = ~0;
-            mutex->count = 0;
-            esync_wake_fd( esync->fd );
-        }
-    }
-}
-
-DECL_HANDLER(create_esync)
-{
-    struct esync *esync;
-    struct unicode_str name;
-    struct object *root;
-    const struct security_descriptor *sd;
-    const struct object_attributes *objattr = get_req_object_attributes( &sd, &name, &root );
-
-    if (!do_esync())
-    {
-        set_error( STATUS_NOT_IMPLEMENTED );
-        return;
-    }
-
-    if (!req->type)
-    {
-        set_error( STATUS_INVALID_PARAMETER );
-        return;
-    }
-
-    if (!objattr) return;
-
-    if ((esync = create_esync( root, &name, objattr->attributes, req->initval, req->max, req->type, sd )))
-    {
-        if (get_error() == STATUS_OBJECT_NAME_EXISTS)
-            reply->handle = alloc_handle( current->process, esync, req->access, objattr->attributes );
-        else
-            reply->handle = alloc_handle_no_access_check( current->process, esync,
-                                                          req->access, objattr->attributes );
-
-        reply->type = esync->type;
-        reply->shm_idx = esync->shm_idx;
-        send_client_fd( current->process, esync->fd, reply->handle );
-        release_object( esync );
-    }
-
-    if (root) release_object( root );
-}
-
-DECL_HANDLER(open_esync)
-{
-    struct unicode_str name = get_req_unicode_str();
-
-    reply->handle = open_object( current->process, req->rootdir, req->access,
-                                 &esync_ops, &name, req->attributes );
-
-    /* send over the fd */
-    if (reply->handle)
-    {
-        struct esync *esync;
-
-        if (!(esync = (struct esync *)get_handle_obj( current->process, reply->handle,
-                                                      0, &esync_ops )))
-            return;
-
-        if (!type_matches( req->type, esync->type ))
-        {
-            set_error( STATUS_OBJECT_TYPE_MISMATCH );
-            release_object( esync );
-            return;
-        }
-
-        reply->type = esync->type;
-        reply->shm_idx = esync->shm_idx;
-
-        send_client_fd( current->process, esync->fd, reply->handle );
-        release_object( esync );
-    }
-}
-
-/* Retrieve a file descriptor for an esync object which will be signaled by the
- * server. The client should only read from (i.e. wait on) this object. */
-DECL_HANDLER(get_esync_fd)
-{
-    struct object *obj;
-    enum esync_type type;
-    int fd;
-
-    if (!(obj = get_handle_obj( current->process, req->handle, SYNCHRONIZE, NULL )))
-        return;
-
-    if (obj->ops->get_esync_fd)
-    {
-        fd = obj->ops->get_esync_fd( obj, &type );
-        reply->type = type;
-        if (obj->ops == &esync_ops)
-        {
-            struct esync *esync = (struct esync *)obj;
-            reply->shm_idx = esync->shm_idx;
-        }
-        else
-            reply->shm_idx = 0;
-        send_client_fd( current->process, fd, req->handle );
-    }
-    else
-    {
-        if (debug_level)
-        {
-            fprintf( stderr, "%04x: esync: can't wait on object: ", current->id );
-            obj->ops->dump( obj, 0 );
-        }
-        set_error( STATUS_NOT_IMPLEMENTED );
-    }
-
-    release_object( obj );
-}
-
-/* Return the fd used for waiting on user APCs. */
-DECL_HANDLER(get_esync_apc_fd)
-{
-    send_client_fd( current->process, current->esync_apc_fd, current->id );
-}
diff --color -u -r -N a/server/esync.h b/server/esync.h
--- a/server/esync.h	2025-04-11 19:04:48.373918656 +0500
+++ b/server/esync.h	1970-01-01 05:00:00.000000000 +0500
@@ -1,35 +0,0 @@
-/*
- * eventfd-based synchronization objects
- *
- * Copyright (C) 2018 Zebediah Figura
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#include <unistd.h>
-
-extern int do_esync(void);
-void esync_init(void);
-int esync_create_fd( int initval, int flags );
-void esync_wake_fd( int fd );
-void esync_wake_up( struct object *obj );
-void esync_clear( int fd );
-
-struct esync;
-
-extern const struct object_ops esync_ops;
-void esync_set_event( struct esync *esync );
-void esync_reset_event( struct esync *esync );
-void esync_abandon_mutexes( struct thread *thread );
diff --color -u -r -N a/server/event.c b/server/event.c
--- a/server/event.c	2025-04-11 19:04:48.216999756 +0500
+++ b/server/event.c	2025-04-11 19:11:08.140169423 +0500
@@ -25,6 +25,7 @@
 #include <stdlib.h>
 #include <stdarg.h>
 #include <sys/types.h>
+#include <unistd.h>
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -35,7 +36,6 @@
 #include "thread.h"
 #include "request.h"
 #include "security.h"
-#include "esync.h"
 
 static const WCHAR event_name[] = {'E','v','e','n','t'};
 
@@ -56,16 +56,19 @@
     struct object  obj;             /* object header */
     struct list    kernel_object;   /* list of kernel object pointers */
     int            manual_reset;    /* is it a manual reset event? */
-    int            signaled;        /* event has been signaled */
-    int            esync_fd;        /* esync file descriptor */
+    union
+    {
+        int        signaled;        /* event has been signaled */
+        int        inproc_sync;     /* in-process synchronization object */
+    } u;
 };
 
 static void event_dump( struct object *obj, int verbose );
 static int event_signaled( struct object *obj, struct wait_queue_entry *entry );
 static void event_satisfied( struct object *obj, struct wait_queue_entry *entry );
-static int event_get_esync_fd( struct object *obj, enum esync_type *type );
 static int event_signal( struct object *obj, unsigned int access);
 static struct list *event_get_kernel_obj_list( struct object *obj );
+static int event_get_inproc_sync( struct object *obj, enum inproc_sync_type *type );
 static void event_destroy( struct object *obj );
 
 static const struct object_ops event_ops =
@@ -76,7 +79,6 @@
     add_queue,                 /* add_queue */
     remove_queue,              /* remove_queue */
     event_signaled,            /* signaled */
-    event_get_esync_fd,        /* get_esync_fd */
     event_satisfied,           /* satisfied */
     event_signal,              /* signal */
     no_get_fd,                 /* get_fd */
@@ -89,6 +91,7 @@
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     event_get_kernel_obj_list, /* get_kernel_obj_list */
+    event_get_inproc_sync,     /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     event_destroy              /* destroy */
 };
@@ -111,10 +114,13 @@
 struct keyed_event
 {
     struct object  obj;             /* object header */
+    int inproc_sync;                /* in-process synchronization object */
 };
 
 static void keyed_event_dump( struct object *obj, int verbose );
 static int keyed_event_signaled( struct object *obj, struct wait_queue_entry *entry );
+static int keyed_event_get_inproc_sync( struct object *obj, enum inproc_sync_type *type );
+static void keyed_event_destroy( struct object *obj );
 
 static const struct object_ops keyed_event_ops =
 {
@@ -124,7 +130,6 @@
     add_queue,                   /* add_queue */
     remove_queue,                /* remove_queue */
     keyed_event_signaled,        /* signaled */
-    NULL,                        /* get_esync_fd */
     no_satisfied,                /* satisfied */
     no_signal,                   /* signal */
     no_get_fd,                   /* get_fd */
@@ -137,8 +142,9 @@
     default_unlink_name,         /* unlink_name */
     no_open_file,                /* open_file */
     no_kernel_obj_list,          /* get_kernel_obj_list */
+    keyed_event_get_inproc_sync, /* get_inproc_sync */
     no_close_handle,             /* close_handle */
-    no_destroy                   /* destroy */
+    keyed_event_destroy          /* destroy */
 };
 
 
@@ -155,10 +161,10 @@
             /* initialize it if it didn't already exist */
             list_init( &event->kernel_object );
             event->manual_reset = manual_reset;
-            event->signaled     = initial_state;
-
-            if (do_esync())
-                event->esync_fd = esync_create_fd( initial_state, 0 );
+            if (use_inproc_sync())
+                event->u.inproc_sync = create_inproc_event( event->manual_reset, initial_state );
+            else
+                event->u.signaled = initial_state;
         }
     }
     return event;
@@ -166,45 +172,37 @@
 
 struct event *get_event_obj( struct process *process, obj_handle_t handle, unsigned int access )
 {
-    struct object *obj;
-    if (do_esync() && (obj = get_handle_obj( process, handle, access, &esync_ops)))
-        return (struct event *)obj; /* even though it's not an event */
-
     return (struct event *)get_handle_obj( process, handle, access, &event_ops );
 }
 
 static void pulse_event( struct event *event )
 {
-    event->signaled = 1;
+    event->u.signaled = 1;
     /* wake up all waiters if manual reset, a single one otherwise */
     wake_up( &event->obj, !event->manual_reset );
-    event->signaled = 0;
+    event->u.signaled = 0;
 }
 
 void set_event( struct event *event )
 {
-    if (do_esync() && event->obj.ops == &esync_ops)
+    if (use_inproc_sync())
     {
-        esync_set_event( (struct esync *)event );
-        return;
+        set_inproc_event( event->u.inproc_sync );
+    }
+    else
+    {
+        event->u.signaled = 1;
+        /* wake up all waiters if manual reset, a single one otherwise */
+        wake_up( &event->obj, !event->manual_reset );
     }
-
-    event->signaled = 1;
-    /* wake up all waiters if manual reset, a single one otherwise */
-    wake_up( &event->obj, !event->manual_reset );
 }
 
 void reset_event( struct event *event )
 {
-    if (do_esync() && event->obj.ops == &esync_ops)
-    {
-        esync_reset_event( (struct esync *)event );
-        return;
-    }
-    event->signaled = 0;
-
-    if (do_esync())
-        esync_clear( event->esync_fd );
+    if (use_inproc_sync())
+        reset_inproc_event( event->u.inproc_sync );
+    else
+        event->u.signaled = 0;
 }
 
 static void event_dump( struct object *obj, int verbose )
@@ -212,21 +210,14 @@
     struct event *event = (struct event *)obj;
     assert( obj->ops == &event_ops );
     fprintf( stderr, "Event manual=%d signaled=%d\n",
-             event->manual_reset, event->signaled );
+             event->manual_reset, event->u.signaled );
 }
 
 static int event_signaled( struct object *obj, struct wait_queue_entry *entry )
 {
     struct event *event = (struct event *)obj;
     assert( obj->ops == &event_ops );
-    return event->signaled;
-}
-
-static int event_get_esync_fd( struct object *obj, enum esync_type *type )
-{
-    struct event *event = (struct event *)obj;
-    *type = event->manual_reset ? ESYNC_MANUAL_SERVER : ESYNC_AUTO_SERVER;
-    return event->esync_fd;
+    return event->u.signaled;
 }
 
 static void event_satisfied( struct object *obj, struct wait_queue_entry *entry )
@@ -234,7 +225,7 @@
     struct event *event = (struct event *)obj;
     assert( obj->ops == &event_ops );
     /* Reset if it's an auto-reset event */
-    if (!event->manual_reset) event->signaled = 0;
+    if (!event->manual_reset) event->u.signaled = 0;
 }
 
 static int event_signal( struct object *obj, unsigned int access )
@@ -257,12 +248,19 @@
     return &event->kernel_object;
 }
 
+static int event_get_inproc_sync( struct object *obj, enum inproc_sync_type *type )
+{
+    struct event *event = (struct event *)obj;
+
+    *type = event->manual_reset ? INPROC_SYNC_MANUAL_EVENT : INPROC_SYNC_AUTO_EVENT;
+    return event->u.inproc_sync;
+}
+
 static void event_destroy( struct object *obj )
 {
     struct event *event = (struct event *)obj;
 
-    if (do_esync())
-        close( event->esync_fd );
+    if (use_inproc_sync()) close( event->u.inproc_sync );
 }
 
 struct keyed_event *create_keyed_event( struct object *root, const struct unicode_str *name,
@@ -275,6 +273,7 @@
         if (get_error() != STATUS_OBJECT_NAME_EXISTS)
         {
             /* initialize it if it didn't already exist */
+            event->inproc_sync = create_inproc_event( TRUE, TRUE );
         }
     }
     return event;
@@ -318,6 +317,21 @@
     return 0;
 }
 
+static int keyed_event_get_inproc_sync( struct object *obj, enum inproc_sync_type *type )
+{
+    struct keyed_event *event = (struct keyed_event *)obj;
+
+    *type = INPROC_SYNC_MANUAL_SERVER;
+    return event->inproc_sync;
+}
+
+static void keyed_event_destroy( struct object *obj )
+{
+    struct keyed_event *event = (struct keyed_event *)obj;
+
+    if (use_inproc_sync()) close( event->inproc_sync );
+}
+
 /* create an event */
 DECL_HANDLER(create_event)
 {
@@ -358,7 +372,7 @@
     struct event *event;
 
     if (!(event = get_event_obj( current->process, req->handle, EVENT_MODIFY_STATE ))) return;
-    reply->state = event->signaled;
+    reply->state = event->u.signaled;
     switch(req->op)
     {
     case PULSE_EVENT:
@@ -385,7 +399,7 @@
     if (!(event = get_event_obj( current->process, req->handle, EVENT_QUERY_STATE ))) return;
 
     reply->manual_reset = event->manual_reset;
-    reply->state = event->signaled;
+    reply->state = event->u.signaled;
 
     release_object( event );
 }
diff --color -u -r -N a/server/fd.c b/server/fd.c
--- a/server/fd.c	2025-04-11 19:04:49.807492801 +0500
+++ b/server/fd.c	2025-04-11 19:11:08.143316111 +0500
@@ -95,7 +95,6 @@
 #include "handle.h"
 #include "process.h"
 #include "request.h"
-#include "esync.h"
 
 #include "winternl.h"
 #include "winioctl.h"
@@ -160,7 +159,7 @@
     struct completion   *completion;  /* completion object attached to this fd */
     apc_param_t          comp_key;    /* completion key to set in completion events */
     unsigned int         comp_flags;  /* completion flags */
-    int                  esync_fd;    /* esync file descriptor */
+    int                  inproc_sync; /* in-process synchronization object */
 };
 
 static void fd_dump( struct object *obj, int verbose );
@@ -174,7 +173,6 @@
     no_add_queue,             /* add_queue */
     NULL,                     /* remove_queue */
     NULL,                     /* signaled */
-    NULL,                     /* get_esync_fd */
     NULL,                     /* satisfied */
     no_signal,                /* signal */
     no_get_fd,                /* get_fd */
@@ -187,6 +185,7 @@
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_inproc_sync,       /* get_inproc_sync */
     no_close_handle,          /* close_handle */
     fd_destroy                /* destroy */
 };
@@ -216,7 +215,6 @@
     no_add_queue,             /* add_queue */
     NULL,                     /* remove_queue */
     NULL,                     /* signaled */
-    NULL,                     /* get_esync_fd */
     NULL,                     /* satisfied */
     no_signal,                /* signal */
     no_get_fd,                /* get_fd */
@@ -229,6 +227,7 @@
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_inproc_sync,       /* get_inproc_sync */
     no_close_handle,          /* close_handle */
     device_destroy            /* destroy */
 };
@@ -257,7 +256,6 @@
     no_add_queue,             /* add_queue */
     NULL,                     /* remove_queue */
     NULL,                     /* signaled */
-    NULL,                     /* get_esync_fd */
     NULL,                     /* satisfied */
     no_signal,                /* signal */
     no_get_fd,                /* get_fd */
@@ -270,6 +268,7 @@
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_inproc_sync,       /* get_inproc_sync */
     no_close_handle,          /* close_handle */
     inode_destroy             /* destroy */
 };
@@ -300,7 +299,6 @@
     add_queue,                  /* add_queue */
     remove_queue,               /* remove_queue */
     file_lock_signaled,         /* signaled */
-    NULL,                       /* get_esync_fd */
     no_satisfied,               /* satisfied */
     no_signal,                  /* signal */
     no_get_fd,                  /* get_fd */
@@ -313,6 +311,7 @@
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_get_inproc_sync,         /* get_inproc_sync */
     no_close_handle,            /* close_handle */
     no_destroy                  /* destroy */
 };
@@ -1670,9 +1669,7 @@
         if (fd->unix_fd != -1) close( fd->unix_fd );
         free( fd->unix_name );
     }
-
-    if (do_esync())
-        close( fd->esync_fd );
+    if (use_inproc_sync()) close( fd->inproc_sync );
 }
 
 /* check if the desired access is possible without violating */
@@ -1791,16 +1788,13 @@
     fd->poll_index = -1;
     fd->completion = NULL;
     fd->comp_flags = 0;
-    fd->esync_fd   = -1;
+    fd->inproc_sync = create_inproc_event( TRUE, fd->signaled );
     init_async_queue( &fd->read_q );
     init_async_queue( &fd->write_q );
     init_async_queue( &fd->wait_q );
     list_init( &fd->inode_entry );
     list_init( &fd->locks );
 
-    if (do_esync())
-        fd->esync_fd = esync_create_fd( 1, 0 );
-
     if ((fd->poll_index = add_poll_user( fd )) == -1)
     {
         release_object( fd );
@@ -1835,16 +1829,13 @@
     fd->poll_index = -1;
     fd->completion = NULL;
     fd->comp_flags = 0;
+    fd->inproc_sync = create_inproc_event( TRUE, fd->signaled );
     fd->no_fd_status = STATUS_BAD_DEVICE_TYPE;
-    fd->esync_fd   = -1;
     init_async_queue( &fd->read_q );
     init_async_queue( &fd->write_q );
     init_async_queue( &fd->wait_q );
     list_init( &fd->inode_entry );
     list_init( &fd->locks );
-
-    if (do_esync())
-        fd->esync_fd = esync_create_fd( 0, 0 );
     return fd;
 }
 
@@ -2319,10 +2310,15 @@
 {
     if (fd->comp_flags & FILE_SKIP_SET_EVENT_ON_HANDLE) return;
     fd->signaled = signaled;
-    if (signaled) wake_up( fd->user, 0 );
-
-    if (do_esync() && !signaled)
-        esync_clear( fd->esync_fd );
+    if (signaled)
+    {
+        wake_up( fd->user, 0 );
+        set_inproc_event( fd->inproc_sync );
+    }
+    else
+    {
+        reset_inproc_event( fd->inproc_sync );
+    }
 }
 
 /* check if events are pending and if yes return which one(s) */
@@ -2348,11 +2344,13 @@
     return ret;
 }
 
-int default_fd_get_esync_fd( struct object *obj, enum esync_type *type )
+int default_fd_get_inproc_sync( struct object *obj, enum inproc_sync_type *type )
 {
     struct fd *fd = get_obj_fd( obj );
-    int ret = fd->esync_fd;
-    *type = ESYNC_MANUAL_SERVER;
+    int ret;
+
+    *type = INPROC_SYNC_MANUAL_SERVER;
+    ret = fd->inproc_sync;
     release_object( fd );
     return ret;
 }
diff --color -u -r -N a/server/file.c b/server/file.c
--- a/server/file.c	2025-04-11 19:04:49.320336768 +0500
+++ b/server/file.c	2025-04-11 19:11:08.143623780 +0500
@@ -123,7 +123,6 @@
     add_queue,                    /* add_queue */
     remove_queue,                 /* remove_queue */
     default_fd_signaled,          /* signaled */
-    NULL,                         /* get_esync_fd */
     no_satisfied,                 /* satisfied */
     no_signal,                    /* signal */
     file_get_fd,                  /* get_fd */
@@ -136,6 +135,7 @@
     NULL,                         /* unlink_name */
     file_open_file,               /* open_file */
     file_get_kernel_obj_list,     /* get_kernel_obj_list */
+    default_fd_get_inproc_sync,   /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     file_destroy                  /* destroy */
 };
diff --color -u -r -N a/server/file.h b/server/file.h
--- a/server/file.h	2025-04-11 19:04:49.305491524 +0500
+++ b/server/file.h	2025-04-11 19:11:08.143741277 +0500
@@ -109,7 +109,7 @@
 extern void get_nt_name( struct fd *fd, struct unicode_str *name );
 
 extern int default_fd_signaled( struct object *obj, struct wait_queue_entry *entry );
-extern int default_fd_get_esync_fd( struct object *obj, enum esync_type *type );
+extern int default_fd_get_inproc_sync( struct object *obj, enum inproc_sync_type *type );
 extern int default_fd_get_poll_events( struct fd *fd );
 extern void default_poll_event( struct fd *fd, int event );
 extern void fd_cancel_async( struct fd *fd, struct async *async );
diff --color -u -r -N a/server/handle.c b/server/handle.c
--- a/server/handle.c	2025-04-11 19:04:48.194355068 +0500
+++ b/server/handle.c	2025-04-11 19:11:08.128821132 +0500
@@ -126,7 +126,6 @@
     no_add_queue,                    /* add_queue */
     NULL,                            /* remove_queue */
     NULL,                            /* signaled */
-    NULL,                            /* get_esync_fd */
     NULL,                            /* satisfied */
     no_signal,                       /* signal */
     no_get_fd,                       /* get_fd */
@@ -139,6 +138,7 @@
     NULL,                            /* unlink_name */
     no_open_file,                    /* open_file */
     no_kernel_obj_list,              /* get_kernel_obj_list */
+    no_get_inproc_sync,              /* get_inproc_sync */
     no_close_handle,                 /* close_handle */
     handle_table_destroy             /* destroy */
 };
diff --color -u -r -N a/server/hook.c b/server/hook.c
--- a/server/hook.c	2025-04-11 19:04:48.194396476 +0500
+++ b/server/hook.c	2025-04-11 19:11:08.128938158 +0500
@@ -81,7 +81,6 @@
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
-    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
@@ -94,6 +93,7 @@
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     hook_table_destroy            /* destroy */
 };
diff --color -u -r -N a/server/inproc_sync.c b/server/inproc_sync.c
--- a/server/inproc_sync.c	1970-01-01 05:00:00.000000000 +0500
+++ b/server/inproc_sync.c	2025-04-11 19:11:08.156713340 +0500
@@ -0,0 +1,200 @@
+/*
+ * In-process synchronization primitives
+ *
+ * Copyright (C) 2021-2022 Elizabeth Figura for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include <assert.h>
+#include <stdint.h>
+#include <stdio.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "winternl.h"
+
+#include "file.h"
+#include "handle.h"
+#include "request.h"
+#include "thread.h"
+
+#ifdef HAVE_LINUX_NTSYNC_H
+# include <linux/ntsync.h>
+#endif
+
+#ifdef NTSYNC_IOC_EVENT_READ
+
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+static int get_linux_device(void)
+{
+    static int fd = -2;
+
+    if (fd == -2)
+        fd = open( "/dev/ntsync", O_CLOEXEC | O_RDONLY );
+
+    return fd;
+}
+
+int use_inproc_sync(void)
+{
+    return get_linux_device() >= 0;
+}
+
+int create_inproc_event( int manual_reset, int signaled )
+{
+    struct ntsync_event_args args;
+    int device;
+
+    if ((device = get_linux_device()) < 0) return -1;
+
+    args.signaled = signaled;
+    args.manual = manual_reset;
+    return ioctl( device, NTSYNC_IOC_CREATE_EVENT, &args );
+}
+
+int create_inproc_semaphore( unsigned int count, unsigned int max )
+{
+    struct ntsync_sem_args args;
+    int device;
+
+    if ((device = get_linux_device()) < 0) return -1;
+
+    args.count = count;
+    args.max = max;
+    return ioctl( device, NTSYNC_IOC_CREATE_SEM, &args );
+}
+
+int create_inproc_mutex( thread_id_t owner, unsigned int count )
+{
+    struct ntsync_mutex_args args;
+    int device;
+
+    if ((device = get_linux_device()) < 0) return -1;
+
+    args.owner = owner;
+    args.count = count;
+    return ioctl( device, NTSYNC_IOC_CREATE_MUTEX, &args );
+}
+
+void set_inproc_event( int event )
+{
+    __u32 count;
+
+    if (!use_inproc_sync()) return;
+
+    if (debug_level) fprintf( stderr, "set_inproc_event %d\n", event );
+
+    ioctl( event, NTSYNC_IOC_EVENT_SET, &count );
+}
+
+void reset_inproc_event( int event )
+{
+    __u32 count;
+
+    if (!use_inproc_sync()) return;
+
+    if (debug_level) fprintf( stderr, "reset_inproc_event %d\n", event );
+
+    ioctl( event, NTSYNC_IOC_EVENT_RESET, &count );
+}
+
+void abandon_inproc_mutex( thread_id_t tid, int mutex )
+{
+    ioctl( mutex, NTSYNC_IOC_MUTEX_KILL, &tid );
+}
+
+#else
+
+int use_inproc_sync(void)
+{
+    return 0;
+}
+
+int create_inproc_event( int manual_reset, int signaled )
+{
+    return -1;
+}
+
+int create_inproc_semaphore( unsigned int count, unsigned int max )
+{
+    return -1;
+}
+
+int create_inproc_mutex( thread_id_t owner, unsigned int count )
+{
+    return -1;
+}
+
+void set_inproc_event( int event )
+{
+}
+
+void reset_inproc_event( int event )
+{
+}
+
+void abandon_inproc_mutex( thread_id_t tid, int mutex )
+{
+}
+
+#endif
+
+
+DECL_HANDLER(get_linux_sync_device)
+{
+#ifdef NTSYNC_IOC_EVENT_READ
+    int fd;
+
+    if ((fd = get_linux_device()) >= 0)
+        send_client_fd( current->process, fd, 0 );
+    else
+        set_error( STATUS_NOT_IMPLEMENTED );
+#else
+    set_error( STATUS_NOT_IMPLEMENTED );
+#endif
+}
+
+DECL_HANDLER(get_linux_sync_obj)
+{
+#ifdef NTSYNC_IOC_EVENT_READ
+    struct object *obj;
+    int fd;
+
+    if ((obj = get_handle_obj( current->process, req->handle, 0, NULL )))
+    {
+        enum inproc_sync_type type;
+
+        if ((fd = obj->ops->get_inproc_sync( obj, &type )) >= 0)
+        {
+            reply->type = type;
+            reply->access = get_handle_access( current->process, req->handle );
+            send_client_fd( current->process, fd, req->handle );
+        }
+        else
+            set_error( STATUS_NOT_IMPLEMENTED );
+
+        release_object( obj );
+    }
+#else
+    set_error( STATUS_NOT_IMPLEMENTED );
+#endif
+}
diff --color -u -r -N a/server/mailslot.c b/server/mailslot.c
--- a/server/mailslot.c	2025-04-11 19:04:48.194428257 +0500
+++ b/server/mailslot.c	2025-04-11 19:11:08.143839218 +0500
@@ -81,7 +81,6 @@
     add_queue,                 /* add_queue */
     remove_queue,              /* remove_queue */
     default_fd_signaled,       /* signaled */
-    NULL,                      /* get_esync_fd */
     no_satisfied,              /* satisfied */
     no_signal,                 /* signal */
     mailslot_get_fd,           /* get_fd */
@@ -94,6 +93,7 @@
     default_unlink_name,       /* unlink_name */
     mailslot_open_file,        /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    default_fd_get_inproc_sync,/* get_inproc_sync */
     no_close_handle,           /* close_handle */
     mailslot_destroy           /* destroy */
 };
@@ -143,7 +143,6 @@
     no_add_queue,               /* add_queue */
     NULL,                       /* remove_queue */
     NULL,                       /* signaled */
-    NULL,                       /* get_esync_fd */
     NULL,                       /* satisfied */
     no_signal,                  /* signal */
     mail_writer_get_fd,         /* get_fd */
@@ -156,6 +155,7 @@
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
+    default_fd_get_inproc_sync, /* get_inproc_sync */
     no_close_handle,            /* close_handle */
     mail_writer_destroy         /* destroy */
 };
@@ -209,7 +209,6 @@
     no_add_queue,                   /* add_queue */
     NULL,                           /* remove_queue */
     NULL,                           /* signaled */
-    NULL,                           /* get_esync_fd */
     no_satisfied,                   /* satisfied */
     no_signal,                      /* signal */
     no_get_fd,                      /* get_fd */
@@ -222,6 +221,7 @@
     default_unlink_name,            /* unlink_name */
     mailslot_device_open_file,      /* open_file */
     no_kernel_obj_list,             /* get_kernel_obj_list */
+    no_get_inproc_sync,             /* get_inproc_sync */
     no_close_handle,                /* close_handle */
     mailslot_device_destroy         /* destroy */
 };
@@ -240,7 +240,6 @@
     add_queue,                              /* add_queue */
     remove_queue,                           /* remove_queue */
     default_fd_signaled,                    /* signaled */
-    NULL,                                   /* get_esync_fd */
     no_satisfied,                           /* satisfied */
     no_signal,                              /* signal */
     mailslot_device_file_get_fd,            /* get_fd */
@@ -253,6 +252,7 @@
     NULL,                                   /* unlink_name */
     no_open_file,                           /* open_file */
     no_kernel_obj_list,                     /* get_kernel_obj_list */
+    default_fd_get_inproc_sync,             /* get_inproc_sync */
     no_close_handle,                        /* close_handle */
     mailslot_device_file_destroy            /* destroy */
 };
diff --color -u -r -N a/server/main.c b/server/main.c
--- a/server/main.c	2025-04-11 19:04:48.150159405 +0500
+++ b/server/main.c	2025-04-11 19:10:08.247967306 +0500
@@ -34,7 +34,6 @@
 #include "thread.h"
 #include "request.h"
 #include "unicode.h"
-#include "esync.h"
 
 /* command-line options */
 int debug_level = 0;
@@ -230,9 +229,6 @@
     sock_init();
     open_master_socket();
 
-    if (do_esync())
-        esync_init();
-
     if (debug_level) fprintf( stderr, "wineserver: starting (pid=%ld)\n", (long) getpid() );
     set_current_time();
     init_signals();
diff --color -u -r -N a/server/Makefile.in b/server/Makefile.in
--- a/server/Makefile.in	2025-04-11 19:04:48.150076938 +0500
+++ b/server/Makefile.in	2025-04-11 19:11:08.124883812 +0500
@@ -11,12 +11,12 @@
 	debugger.c \
 	device.c \
 	directory.c \
-	esync.c \
 	event.c \
 	fd.c \
 	file.c \
 	handle.c \
 	hook.c \
+	inproc_sync.c \
 	mach.c \
 	mailslot.c \
 	main.c \
diff --color -u -r -N a/server/mapping.c b/server/mapping.c
--- a/server/mapping.c	2025-04-11 19:04:48.194468093 +0500
+++ b/server/mapping.c	2025-04-11 19:11:08.129190294 +0500
@@ -67,7 +67,6 @@
     no_add_queue,              /* add_queue */
     NULL,                      /* remove_queue */
     NULL,                      /* signaled */
-    NULL,                      /* get_esync_fd */
     NULL,                      /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
@@ -80,6 +79,7 @@
     NULL,                      /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_inproc_sync,        /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     ranges_destroy             /* destroy */
 };
@@ -104,7 +104,6 @@
     no_add_queue,              /* add_queue */
     NULL,                      /* remove_queue */
     NULL,                      /* signaled */
-    NULL,                      /* get_esync_fd */
     NULL,                      /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
@@ -117,6 +116,7 @@
     NULL,                      /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_inproc_sync,        /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     shared_map_destroy         /* destroy */
 };
@@ -178,7 +178,6 @@
     no_add_queue,                /* add_queue */
     NULL,                        /* remove_queue */
     NULL,                        /* signaled */
-    NULL,                        /* get_esync_fd */
     NULL,                        /* satisfied */
     no_signal,                   /* signal */
     mapping_get_fd,              /* get_fd */
@@ -191,6 +190,7 @@
     default_unlink_name,         /* unlink_name */
     no_open_file,                /* open_file */
     no_kernel_obj_list,          /* get_kernel_obj_list */
+    no_get_inproc_sync,          /* get_inproc_sync */
     no_close_handle,             /* close_handle */
     mapping_destroy              /* destroy */
 };
diff --color -u -r -N a/server/mutex.c b/server/mutex.c
--- a/server/mutex.c	2025-04-11 19:04:48.194531093 +0500
+++ b/server/mutex.c	2025-04-11 19:11:08.137669772 +0500
@@ -25,6 +25,7 @@
 #include <stdlib.h>
 #include <stdarg.h>
 #include <sys/types.h>
+#include <unistd.h>
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -38,6 +39,8 @@
 
 static const WCHAR mutex_name[] = {'M','u','t','a','n','t'};
 
+static struct list inproc_mutexes = LIST_INIT(inproc_mutexes);
+
 struct type_descr mutex_type =
 {
     { mutex_name, sizeof(mutex_name) },   /* name */
@@ -53,10 +56,21 @@
 struct mutex
 {
     struct object  obj;             /* object header */
-    struct thread *owner;           /* mutex owner */
-    unsigned int   count;           /* recursion count */
-    int            abandoned;       /* has it been abandoned? */
-    struct list    entry;           /* entry in owner thread mutex list */
+    union
+    {
+        struct
+        {
+            struct thread *owner;   /* mutex owner */
+            unsigned int count;     /* recursion count */
+            int abandoned;          /* has it been abandoned? */
+            struct list entry;      /* entry in owner thread mutex list */
+        } server;
+        struct
+        {
+            int inproc_sync;        /* in-process synchronization object */
+            struct list entry;      /* entry in inproc_mutexes list */
+        } inproc;
+    } u;
 };
 
 static void mutex_dump( struct object *obj, int verbose );
@@ -64,6 +78,7 @@
 static void mutex_satisfied( struct object *obj, struct wait_queue_entry *entry );
 static void mutex_destroy( struct object *obj );
 static int mutex_signal( struct object *obj, unsigned int access );
+static int mutex_get_inproc_sync( struct object *obj, enum inproc_sync_type *type );
 
 static const struct object_ops mutex_ops =
 {
@@ -73,7 +88,6 @@
     add_queue,                 /* add_queue */
     remove_queue,              /* remove_queue */
     mutex_signaled,            /* signaled */
-    NULL,                      /* get_esync_fd */
     mutex_satisfied,           /* satisfied */
     mutex_signal,              /* signal */
     no_get_fd,                 /* get_fd */
@@ -86,6 +100,7 @@
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    mutex_get_inproc_sync,     /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     mutex_destroy              /* destroy */
 };
@@ -94,23 +109,23 @@
 /* grab a mutex for a given thread */
 static void do_grab( struct mutex *mutex, struct thread *thread )
 {
-    assert( !mutex->count || (mutex->owner == thread) );
+    assert( !mutex->u.server.count || (mutex->u.server.owner == thread) );
 
-    if (!mutex->count++)  /* FIXME: avoid wrap-around */
+    if (!mutex->u.server.count++)  /* FIXME: avoid wrap-around */
     {
-        assert( !mutex->owner );
-        mutex->owner = thread;
-        list_add_head( &thread->mutex_list, &mutex->entry );
+        assert( !mutex->u.server.owner );
+        mutex->u.server.owner = thread;
+        list_add_head( &thread->mutex_list, &mutex->u.server.entry );
     }
 }
 
 /* release a mutex once the recursion count is 0 */
 static void do_release( struct mutex *mutex )
 {
-    assert( !mutex->count );
+    assert( !mutex->u.server.count );
     /* remove the mutex from the thread list of owned mutexes */
-    list_remove( &mutex->entry );
-    mutex->owner = NULL;
+    list_remove( &mutex->u.server.entry );
+    mutex->u.server.owner = NULL;
     wake_up( &mutex->obj, 0 );
 }
 
@@ -124,10 +139,18 @@
         if (get_error() != STATUS_OBJECT_NAME_EXISTS)
         {
             /* initialize it if it didn't already exist */
-            mutex->count = 0;
-            mutex->owner = NULL;
-            mutex->abandoned = 0;
-            if (owned) do_grab( mutex, current );
+            if (use_inproc_sync())
+            {
+                mutex->u.inproc.inproc_sync = create_inproc_mutex( owned ? current->id : 0, owned ? 1 : 0 );
+                list_add_tail( &inproc_mutexes, &mutex->u.inproc.entry );
+            }
+            else
+            {
+                mutex->u.server.count = 0;
+                mutex->u.server.owner = NULL;
+                mutex->u.server.abandoned = 0;
+                if (owned) do_grab( mutex, current );
+            }
         }
     }
     return mutex;
@@ -135,30 +158,34 @@
 
 void abandon_mutexes( struct thread *thread )
 {
+    struct mutex *mutex;
     struct list *ptr;
 
     while ((ptr = list_head( &thread->mutex_list )) != NULL)
     {
-        struct mutex *mutex = LIST_ENTRY( ptr, struct mutex, entry );
-        assert( mutex->owner == thread );
-        mutex->count = 0;
-        mutex->abandoned = 1;
+        mutex = LIST_ENTRY( ptr, struct mutex, u.server.entry );
+        assert( mutex->u.server.owner == thread );
+        mutex->u.server.count = 0;
+        mutex->u.server.abandoned = 1;
         do_release( mutex );
     }
+
+    LIST_FOR_EACH_ENTRY(mutex, &inproc_mutexes, struct mutex, u.inproc.entry)
+        abandon_inproc_mutex( thread->id, mutex->u.inproc.inproc_sync );
 }
 
 static void mutex_dump( struct object *obj, int verbose )
 {
     struct mutex *mutex = (struct mutex *)obj;
     assert( obj->ops == &mutex_ops );
-    fprintf( stderr, "Mutex count=%u owner=%p\n", mutex->count, mutex->owner );
+    fprintf( stderr, "Mutex count=%u owner=%p\n", mutex->u.server.count, mutex->u.server.owner );
 }
 
 static int mutex_signaled( struct object *obj, struct wait_queue_entry *entry )
 {
     struct mutex *mutex = (struct mutex *)obj;
     assert( obj->ops == &mutex_ops );
-    return (!mutex->count || (mutex->owner == get_wait_queue_thread( entry )));
+    return (!mutex->u.server.count || (mutex->u.server.owner == get_wait_queue_thread( entry )));
 }
 
 static void mutex_satisfied( struct object *obj, struct wait_queue_entry *entry )
@@ -167,8 +194,8 @@
     assert( obj->ops == &mutex_ops );
 
     do_grab( mutex, get_wait_queue_thread( entry ));
-    if (mutex->abandoned) make_wait_abandoned( entry );
-    mutex->abandoned = 0;
+    if (mutex->u.server.abandoned) make_wait_abandoned( entry );
+    mutex->u.server.abandoned = 0;
 }
 
 static int mutex_signal( struct object *obj, unsigned int access )
@@ -181,23 +208,39 @@
         set_error( STATUS_ACCESS_DENIED );
         return 0;
     }
-    if (!mutex->count || (mutex->owner != current))
+    if (!mutex->u.server.count || (mutex->u.server.owner != current))
     {
         set_error( STATUS_MUTANT_NOT_OWNED );
         return 0;
     }
-    if (!--mutex->count) do_release( mutex );
+    if (!--mutex->u.server.count) do_release( mutex );
     return 1;
 }
 
+static int mutex_get_inproc_sync( struct object *obj, enum inproc_sync_type *type )
+{
+    struct mutex *mutex = (struct mutex *)obj;
+
+    *type = INPROC_SYNC_MUTEX;
+    return mutex->u.inproc.inproc_sync;
+}
+
 static void mutex_destroy( struct object *obj )
 {
     struct mutex *mutex = (struct mutex *)obj;
     assert( obj->ops == &mutex_ops );
 
-    if (!mutex->count) return;
-    mutex->count = 0;
-    do_release( mutex );
+    if (use_inproc_sync())
+    {
+        close( mutex->u.inproc.inproc_sync );
+        list_remove( &mutex->u.inproc.entry );
+    }
+    else
+    {
+        if (!mutex->u.server.count) return;
+        mutex->u.server.count = 0;
+        do_release( mutex );
+    }
 }
 
 /* create a mutex */
@@ -241,11 +284,11 @@
     if ((mutex = (struct mutex *)get_handle_obj( current->process, req->handle,
                                                  0, &mutex_ops )))
     {
-        if (!mutex->count || (mutex->owner != current)) set_error( STATUS_MUTANT_NOT_OWNED );
+        if (!mutex->u.server.count || (mutex->u.server.owner != current)) set_error( STATUS_MUTANT_NOT_OWNED );
         else
         {
-            reply->prev_count = mutex->count;
-            if (!--mutex->count) do_release( mutex );
+            reply->prev_count = mutex->u.server.count;
+            if (!--mutex->u.server.count) do_release( mutex );
         }
         release_object( mutex );
     }
@@ -259,9 +302,9 @@
     if ((mutex = (struct mutex *)get_handle_obj( current->process, req->handle,
                                                  MUTANT_QUERY_STATE, &mutex_ops )))
     {
-        reply->count = mutex->count;
-        reply->owned = (mutex->owner == current);
-        reply->abandoned = mutex->abandoned;
+        reply->count = mutex->u.server.count;
+        reply->owned = (mutex->u.server.owner == current);
+        reply->abandoned = mutex->u.server.abandoned;
 
         release_object( mutex );
     }
diff --color -u -r -N a/server/named_pipe.c b/server/named_pipe.c
--- a/server/named_pipe.c	2025-04-11 19:04:48.340083455 +0500
+++ b/server/named_pipe.c	2025-04-11 19:11:08.143972384 +0500
@@ -119,7 +119,6 @@
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
-    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
@@ -132,6 +131,7 @@
     default_unlink_name,          /* unlink_name */
     named_pipe_open_file,         /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     named_pipe_destroy            /* destroy */
 };
@@ -168,7 +168,6 @@
     add_queue,                    /* add_queue */
     remove_queue,                 /* remove_queue */
     default_fd_signaled,          /* signaled */
-    default_fd_get_esync_fd,      /* get_esync_fd */
     no_satisfied,                 /* satisfied */
     no_signal,                    /* signal */
     pipe_end_get_fd,              /* get_fd */
@@ -181,6 +180,7 @@
     NULL,                         /* unlink_name */
     pipe_server_open_file,        /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    default_fd_get_inproc_sync,   /* get_inproc_sync */
     async_close_obj_handle,       /* close_handle */
     pipe_server_destroy           /* destroy */
 };
@@ -213,7 +213,6 @@
     add_queue,                    /* add_queue */
     remove_queue,                 /* remove_queue */
     default_fd_signaled,          /* signaled */
-    default_fd_get_esync_fd,      /* get_esync_fd */
     no_satisfied,                 /* satisfied */
     no_signal,                    /* signal */
     pipe_end_get_fd,              /* get_fd */
@@ -226,6 +225,7 @@
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    default_fd_get_inproc_sync,   /* get_inproc_sync */
     async_close_obj_handle,       /* close_handle */
     pipe_end_destroy              /* destroy */
 };
@@ -261,7 +261,6 @@
     no_add_queue,                     /* add_queue */
     NULL,                             /* remove_queue */
     NULL,                             /* signaled */
-    NULL,                             /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     no_get_fd,                        /* get_fd */
@@ -274,6 +273,7 @@
     default_unlink_name,              /* unlink_name */
     named_pipe_device_open_file,      /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_inproc_sync,               /* get_inproc_sync */
     no_close_handle,                  /* close_handle */
     named_pipe_device_destroy         /* destroy */
 };
@@ -293,7 +293,6 @@
     add_queue,                               /* add_queue */
     remove_queue,                            /* remove_queue */
     default_fd_signaled,                     /* signaled */
-    NULL,                                    /* get_esync_fd */
     no_satisfied,                            /* satisfied */
     no_signal,                               /* signal */
     named_pipe_device_file_get_fd,           /* get_fd */
@@ -306,6 +305,7 @@
     NULL,                                    /* unlink_name */
     no_open_file,                            /* open_file */
     no_kernel_obj_list,                      /* get_kernel_obj_list */
+    default_fd_get_inproc_sync,              /* get_inproc_sync */
     no_close_handle,                         /* close_handle */
     named_pipe_device_file_destroy           /* destroy */
 };
@@ -344,7 +344,6 @@
     add_queue,                               /* add_queue */
     remove_queue,                            /* remove_queue */
     default_fd_signaled,                     /* signaled */
-    NULL,                                    /* get_esync_fd */
     no_satisfied,                            /* satisfied */
     no_signal,                               /* signal */
     named_pipe_dir_get_fd,                   /* get_fd */
@@ -357,6 +356,7 @@
     NULL,                                    /* unlink_name */
     named_pipe_dir_open_file,                /* open_file */
     no_kernel_obj_list,                      /* get_kernel_obj_list */
+    default_fd_get_inproc_sync,              /* get_inproc_sync */
     no_close_handle,                         /* close_handle */
     named_pipe_dir_destroy                   /* destroy */
 };
diff --color -u -r -N a/server/object.c b/server/object.c
--- a/server/object.c	2025-04-11 19:04:49.298989160 +0500
+++ b/server/object.c	2025-04-11 19:11:08.129647229 +0500
@@ -108,7 +108,6 @@
     no_add_queue,               /* add_queue */
     NULL,                       /* remove_queue */
     NULL,                       /* signaled */
-    NULL,                       /* get_esync_fd */
     no_satisfied,               /* satisfied */
     no_signal,                  /* signal */
     no_get_fd,                  /* get_fd */
@@ -121,6 +120,7 @@
     default_unlink_name,        /* unlink_name */
     no_open_file,               /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_get_inproc_sync,         /* get_inproc_sync */
     no_close_handle,            /* close_handle */
     no_destroy                  /* destroy */
 };
@@ -133,7 +133,6 @@
     no_add_queue,              /* add_queue */
     NULL,                      /* remove_queue */
     NULL,                      /* signaled */
-    NULL,                      /* get_esync_fd */
     no_satisfied,              /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
@@ -146,6 +145,7 @@
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_inproc_sync,        /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     no_destroy                 /* destroy */
 };
@@ -641,6 +641,11 @@
     return NULL;
 }
 
+int no_get_inproc_sync( struct object *obj, enum inproc_sync_type *type )
+{
+    return -1;
+}
+
 unsigned int default_map_access( struct object *obj, unsigned int access )
 {
     return map_access( access, &obj->ops->type->mapping );
diff --color -u -r -N a/server/object.h b/server/object.h
--- a/server/object.h	2025-04-11 19:04:49.299038855 +0500
+++ b/server/object.h	2025-04-11 19:11:08.137903824 +0500
@@ -42,6 +42,7 @@
 struct async_queue;
 struct winstation;
 struct object_type;
+struct inproc_sync;
 
 
 struct unicode_str
@@ -78,8 +79,6 @@
     void (*remove_queue)(struct object *,struct wait_queue_entry *);
     /* is object signaled? */
     int  (*signaled)(struct object *,struct wait_queue_entry *);
-    /* return the esync fd for this object */
-    int (*get_esync_fd)(struct object *, enum esync_type *type);
     /* wait satisfied */
     void (*satisfied)(struct object *,struct wait_queue_entry *);
     /* signal an object */
@@ -105,6 +104,8 @@
                                 unsigned int options);
     /* return list of kernel objects */
     struct list *(*get_kernel_obj_list)(struct object *);
+    /* get a client-waitable in-process synchronization fd for this object */
+    int (*get_inproc_sync)(struct object *, enum inproc_sync_type *type);
     /* close a handle to this object */
     int (*close_handle)(struct object *,struct process *,obj_handle_t);
     /* destroy on refcount == 0 */
@@ -233,6 +234,17 @@
 
 extern void abandon_mutexes( struct thread *thread );
 
+/* in-process synchronization functions */
+
+extern int use_inproc_sync(void);
+extern int create_inproc_event( int manual_reset, int signaled );
+extern int create_inproc_mutex( thread_id_t owner, unsigned int count );
+extern int create_inproc_semaphore( unsigned int count, unsigned int max );
+extern int no_get_inproc_sync( struct object *obj, enum inproc_sync_type *type );
+extern void set_inproc_event( int event );
+extern void reset_inproc_event( int event );
+extern void abandon_inproc_mutex( thread_id_t tid, int mutex );
+
 /* serial functions */
 
 int get_serial_async_timeout(struct object *obj, int type, int count);
diff --color -u -r -N a/server/process.c b/server/process.c
--- a/server/process.c	2025-04-11 19:04:48.204900993 +0500
+++ b/server/process.c	2025-04-11 19:11:08.140826157 +0500
@@ -63,7 +63,6 @@
 #include "request.h"
 #include "user.h"
 #include "security.h"
-#include "esync.h"
 
 /* process object */
 
@@ -95,8 +94,8 @@
 static struct security_descriptor *process_get_sd( struct object *obj );
 static void process_poll_event( struct fd *fd, int event );
 static struct list *process_get_kernel_obj_list( struct object *obj );
+static int process_get_inproc_sync( struct object *obj, enum inproc_sync_type *type );
 static void process_destroy( struct object *obj );
-static int process_get_esync_fd( struct object *obj, enum esync_type *type );
 static void terminate_process( struct process *process, struct thread *skip, int exit_code );
 
 static const struct object_ops process_ops =
@@ -107,7 +106,6 @@
     add_queue,                   /* add_queue */
     remove_queue,                /* remove_queue */
     process_signaled,            /* signaled */
-    process_get_esync_fd,        /* get_esync_fd */
     no_satisfied,                /* satisfied */
     no_signal,                   /* signal */
     no_get_fd,                   /* get_fd */
@@ -120,6 +118,7 @@
     NULL,                        /* unlink_name */
     no_open_file,                /* open_file */
     process_get_kernel_obj_list, /* get_kernel_obj_list */
+    process_get_inproc_sync,     /* get_inproc_sync */
     no_close_handle,             /* close_handle */
     process_destroy              /* destroy */
 };
@@ -159,7 +158,6 @@
     add_queue,                     /* add_queue */
     remove_queue,                  /* remove_queue */
     startup_info_signaled,         /* signaled */
-    NULL,                          /* get_esync_fd */
     no_satisfied,                  /* satisfied */
     no_signal,                     /* signal */
     no_get_fd,                     /* get_fd */
@@ -172,6 +170,7 @@
     NULL,                          /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
+    no_get_inproc_sync,            /* get_inproc_sync */
     no_close_handle,               /* close_handle */
     startup_info_destroy           /* destroy */
 };
@@ -194,6 +193,7 @@
 
 static void job_dump( struct object *obj, int verbose );
 static int job_signaled( struct object *obj, struct wait_queue_entry *entry );
+static int job_get_inproc_sync( struct object *obj, enum inproc_sync_type *type );
 static int job_close_handle( struct object *obj, struct process *process, obj_handle_t handle );
 static void job_destroy( struct object *obj );
 
@@ -211,6 +211,7 @@
     struct job *parent;
     struct list parent_job_entry;  /* list entry for parent job */
     struct list child_job_list;    /* list of child jobs */
+    int inproc_sync;               /* in-process synchronization object */
 };
 
 static const struct object_ops job_ops =
@@ -221,7 +222,6 @@
     add_queue,                     /* add_queue */
     remove_queue,                  /* remove_queue */
     job_signaled,                  /* signaled */
-    NULL,                          /* get_esync_fd */
     no_satisfied,                  /* satisfied */
     no_signal,                     /* signal */
     no_get_fd,                     /* get_fd */
@@ -234,6 +234,7 @@
     default_unlink_name,           /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
+    job_get_inproc_sync,           /* get_inproc_sync */
     job_close_handle,              /* close_handle */
     job_destroy                    /* destroy */
 };
@@ -258,6 +259,7 @@
             job->completion_port = NULL;
             job->completion_key = 0;
             job->parent = NULL;
+            job->inproc_sync = create_inproc_event( TRUE, FALSE );
         }
     }
     return job;
@@ -414,6 +416,15 @@
     job->terminating = 0;
     job->signaled = 1;
     wake_up( &job->obj, 0 );
+    set_inproc_event( job->inproc_sync );
+}
+
+static int job_get_inproc_sync( struct object *obj, enum inproc_sync_type *type )
+{
+    struct job *job = (struct job *)obj;
+
+    *type = INPROC_SYNC_MANUAL_SERVER;
+    return job->inproc_sync;
 }
 
 static int job_close_handle( struct object *obj, struct process *process, obj_handle_t handle )
@@ -444,6 +455,8 @@
         list_remove( &job->parent_job_entry );
         release_object( job->parent );
     }
+
+    if (use_inproc_sync()) close( job->inproc_sync );
 }
 
 static void job_dump( struct object *obj, int verbose )
@@ -689,9 +702,9 @@
     process->rawinput_device_count = 0;
     process->rawinput_mouse  = NULL;
     process->rawinput_kbd    = NULL;
+    process->inproc_sync     = create_inproc_event( TRUE, FALSE );
     memset( &process->image_info, 0, sizeof(process->image_info) );
     list_init( &process->rawinput_entry );
-    process->esync_fd        = -1;
     list_init( &process->kernel_object );
     list_init( &process->thread_list );
     list_init( &process->locks );
@@ -742,9 +755,6 @@
     if (!process->handles || !process->token) goto error;
     process->session_id = token_get_session_id( process->token );
 
-    if (do_esync())
-        process->esync_fd = esync_create_fd( 0, 0 );
-
     set_fd_events( process->msg_fd, POLLIN );  /* start listening to events */
     return process;
 
@@ -793,7 +803,8 @@
     free( process->rawinput_devices );
     free( process->dir_cache );
     free( process->image );
-    if (do_esync()) close( process->esync_fd );
+
+    if (use_inproc_sync()) close( process->inproc_sync );
 }
 
 /* dump a process on stdout for debugging purposes */
@@ -811,13 +822,6 @@
     return !process->running_threads;
 }
 
-static int process_get_esync_fd( struct object *obj, enum esync_type *type )
-{
-    struct process *process = (struct process *)obj;
-    *type = ESYNC_MANUAL_SERVER;
-    return process->esync_fd;
-}
-
 static unsigned int process_map_access( struct object *obj, unsigned int access )
 {
     access = default_map_access( obj, access );
@@ -834,6 +838,14 @@
     return &process->kernel_object;
 }
 
+static int process_get_inproc_sync( struct object *obj, enum inproc_sync_type *type )
+{
+    struct process *process = (struct process *)obj;
+
+    *type = INPROC_SYNC_MANUAL_SERVER;
+    return process->inproc_sync;
+}
+
 static struct security_descriptor *process_get_sd( struct object *obj )
 {
     static struct security_descriptor *process_default_sd;
@@ -998,6 +1010,7 @@
     release_job_process( process );
     start_sigkill_timer( process );
     wake_up( &process->obj, 0 );
+    set_inproc_event( process->inproc_sync );
 }
 
 /* add a thread to a process running threads list */
diff --color -u -r -N a/server/process.h b/server/process.h
--- a/server/process.h	2025-04-11 19:04:48.204972950 +0500
+++ b/server/process.h	2025-04-11 19:11:08.140503150 +0500
@@ -86,7 +86,7 @@
     struct list          rawinput_entry;  /* entry in the rawinput process list */
     struct list          kernel_object;   /* list of kernel object pointers */
     struct pe_image_info image_info;      /* main exe image info */
-    int                  esync_fd;        /* esync file descriptor (signaled on exit) */
+    int                  inproc_sync;     /* in-process synchronization object */
 };
 
 /* process functions */
diff --color -u -r -N a/server/protocol.def b/server/protocol.def
--- a/server/protocol.def	2025-04-11 19:04:49.461162908 +0500
+++ b/server/protocol.def	2025-04-11 19:11:08.150795389 +0500
@@ -4105,63 +4105,55 @@
     obj_handle_t handle;       /* next thread handle */
 @END
 
-enum esync_type
-{
-    ESYNC_SEMAPHORE = 1,
-    ESYNC_AUTO_EVENT,
-    ESYNC_MANUAL_EVENT,
-    ESYNC_MUTEX,
-    ESYNC_AUTO_SERVER,
-    ESYNC_MANUAL_SERVER,
-    ESYNC_QUEUE,
-};
 
-/* Create a new eventfd-based synchronization object */
-@REQ(create_esync)
-    unsigned int access;        /* wanted access rights */
-    int          initval;       /* initial value */
-    int          type;          /* type of esync object */
-    int          max;           /* maximum count on a semaphore */
-    VARARG(objattr,object_attributes); /* object attributes */
+/* Setup keyboard auto-repeat */
+@REQ(set_keyboard_repeat)
+    int enable;                /* whether to enable auto-repeat */
+    int delay;                 /* auto-repeat delay in ms */
+    int period;                /* auto-repeat period in ms */
 @REPLY
-    obj_handle_t handle;        /* handle to the object */
-    int          type;          /* actual type (may be different for events) */
-    unsigned int shm_idx;
+    int enable;                /* previous state of auto-repeat enable */
 @END
 
-@REQ(open_esync)
-    unsigned int access;        /* wanted access rights */
-    unsigned int attributes;    /* object attributes */
-    obj_handle_t rootdir;       /* root directory */
-    int          type;          /* type of esync object (above) */
-    VARARG(name,unicode_str);   /* object name */
-@REPLY
-    obj_handle_t handle;        /* handle to the event */
-    int          type;          /* type of esync object (above) */
-    unsigned int shm_idx;       /* this object's index into the shm section */
+enum inproc_sync_type
+{
+    INPROC_SYNC_UNKNOWN,
+    INPROC_SYNC_AUTO_EVENT,
+    INPROC_SYNC_MANUAL_EVENT,
+    INPROC_SYNC_SEMAPHORE,
+    INPROC_SYNC_MUTEX,
+    INPROC_SYNC_AUTO_SERVER,
+    INPROC_SYNC_MANUAL_SERVER,
+    INPROC_SYNC_QUEUE,
+};
+
+
+/* Obtain a fd for the ntsync device */
+@REQ(get_linux_sync_device)
 @END
 
-/* Retrieve the esync fd for an object. */
-@REQ(get_esync_fd)
+/* Get the in-process synchronization fd associated with the waitable handle */
+@REQ(get_linux_sync_obj)
     obj_handle_t handle;        /* handle to the object */
 @REPLY
-    int          type;
-    unsigned int shm_idx;
+    int type;                   /* object type */
+    unsigned int access;        /* handle access rights */
 @END
 
-@REQ(esync_msgwait)
-    int          in_msgwait;    /* are we in a message wait? */
+
+/* Begin a client-side wait on a message queue */
+@REQ(select_inproc_queue)
 @END
 
-/* Setup keyboard auto-repeat */
-@REQ(set_keyboard_repeat)
-    int enable;                /* whether to enable auto-repeat */
-    int delay;                 /* auto-repeat delay in ms */
-    int period;                /* auto-repeat period in ms */
-@REPLY
-    int enable;                /* previous state of auto-repeat enable */
+
+/* End a client-side wait on a message queue */
+@REQ(unselect_inproc_queue)
+    int          signaled;        /* was the queue signaled? */
 @END
 
-/* Retrieve the fd to wait on for user APCs. */
-@REQ(get_esync_apc_fd)
+
+/* Get an event handle to be used for thread alerts with in-process synchronization */
+@REQ(get_inproc_alert_event)
+@REPLY
+    obj_handle_t handle;          /* handle to the event */
 @END
diff --color -u -r -N a/server/queue.c b/server/queue.c
--- a/server/queue.c	2025-04-11 19:04:49.461361797 +0500
+++ b/server/queue.c	2025-04-11 19:22:48.486171405 +0500
@@ -45,7 +45,6 @@
 #include "process.h"
 #include "request.h"
 #include "user.h"
-#include "esync.h"
 
 #define WM_NCMOUSEFIRST WM_NCMOUSEMOVE
 #define WM_NCMOUSELAST  (WM_NCMOUSEFIRST+(WM_MOUSELAST-WM_MOUSEFIRST))
@@ -134,10 +133,10 @@
     struct hook_table     *hooks;           /* hook table */
     timeout_t              last_get_msg;    /* time of last get message call */
     int                    keystate_lock;   /* owns an input keystate lock */
+    int                    inproc_sync;     /* in-process synchronization object */
+    int                    in_inproc_wait;  /* are we in a client-side wait? */
     queue_shm_t           *shared;          /* queue in session shared memory */
     unsigned int           ignore_post_msg; /* ignore post messages newer than this unique id */
-    int                    esync_fd;        /* esync file descriptor (signalled on message) */
-    int                    esync_in_msgwait; /* our thread is currently waiting on us */
 };
 
 struct hotkey
@@ -154,8 +153,8 @@
 static int msg_queue_add_queue( struct object *obj, struct wait_queue_entry *entry );
 static void msg_queue_remove_queue( struct object *obj, struct wait_queue_entry *entry );
 static int msg_queue_signaled( struct object *obj, struct wait_queue_entry *entry );
-static int msg_queue_get_esync_fd( struct object *obj, enum esync_type *type );
 static void msg_queue_satisfied( struct object *obj, struct wait_queue_entry *entry );
+static int msg_queue_get_inproc_sync( struct object *obj, enum inproc_sync_type *type );
 static void msg_queue_destroy( struct object *obj );
 static void msg_queue_poll_event( struct fd *fd, int event );
 static void thread_input_dump( struct object *obj, int verbose );
@@ -170,7 +169,6 @@
     msg_queue_add_queue,       /* add_queue */
     msg_queue_remove_queue,    /* remove_queue */
     msg_queue_signaled,        /* signaled */
-    msg_queue_get_esync_fd,    /* get_esync_fd */
     msg_queue_satisfied,       /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
@@ -183,6 +181,7 @@
     NULL,                      /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    msg_queue_get_inproc_sync, /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     msg_queue_destroy          /* destroy */
 };
@@ -208,7 +207,6 @@
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
-    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
@@ -221,6 +219,7 @@
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     thread_input_destroy          /* destroy */
 };
@@ -321,8 +320,8 @@
         queue->last_get_msg    = current_time;
         queue->keystate_lock   = 0;
         queue->ignore_post_msg = 0;
-        queue->esync_fd        = -1;
-        queue->esync_in_msgwait = 0;
+        queue->inproc_sync     = create_inproc_event( TRUE, FALSE );
+        queue->in_inproc_wait  = 0;
         list_init( &queue->send_result );
         list_init( &queue->callback_result );
         list_init( &queue->pending_timers );
@@ -345,9 +344,6 @@
         }
         SHARED_WRITE_END;
 
-        if (do_esync())
-            queue->esync_fd = esync_create_fd( 0, 0 );
-
         thread->queue = queue;
 
         if ((desktop = get_thread_desktop( thread, 0 )))
@@ -742,7 +738,11 @@
     }
     SHARED_WRITE_END;
 
-    if (is_signaled( queue )) wake_up( &queue->obj, 0 );
+    if (is_signaled( queue ))
+    {
+        wake_up( &queue->obj, 0 );
+        set_inproc_event( queue->inproc_sync );
+    }
 }
 
 /* clear some queue bits */
@@ -762,9 +762,8 @@
         if (queue->keystate_lock) unlock_input_keystate( queue->input );
         queue->keystate_lock = 0;
     }
-
-    if (do_esync() && !is_signaled( queue ))
-        esync_clear( queue->esync_fd );
+    if (!is_signaled( queue ))
+        reset_inproc_event( queue->inproc_sync );
 }
 
 /* check if message is matched by the filter */
@@ -1294,8 +1293,8 @@
             return 0;  /* thread is waiting on queue -> not hung */
     }
 
-    if (do_esync() && queue->esync_in_msgwait)
-        return 0;   /* thread is waiting on queue in absentia -> not hung */
+    if (queue->in_inproc_wait)
+        return 0;  /* thread is waiting on queue in absentia -> not hung */
 
     return 1;
 }
@@ -1351,13 +1350,6 @@
     return ret || is_signaled( queue );
 }
 
-static int msg_queue_get_esync_fd( struct object *obj, enum esync_type *type )
-{
-    struct msg_queue *queue = (struct msg_queue *)obj;
-    *type = ESYNC_QUEUE;
-    return queue->esync_fd;
-}
-
 static void msg_queue_satisfied( struct object *obj, struct wait_queue_entry *entry )
 {
     struct msg_queue *queue = (struct msg_queue *)obj;
@@ -1369,6 +1361,15 @@
         shared->changed_mask = 0;
     }
     SHARED_WRITE_END;
+    reset_inproc_event( queue->inproc_sync );
+}
+
+static int msg_queue_get_inproc_sync( struct object *obj, enum inproc_sync_type *type )
+{
+    struct msg_queue *queue = (struct msg_queue *)obj;
+
+    *type = INPROC_SYNC_QUEUE;
+    return queue->inproc_sync;
 }
 
 static void msg_queue_destroy( struct object *obj )
@@ -1414,7 +1415,7 @@
     if (queue->hooks) release_object( queue->hooks );
     if (queue->fd) release_object( queue->fd );
     if (queue->shared) free_shared_object( queue->shared );
-    if (do_esync()) close( queue->esync_fd );
+    if (use_inproc_sync()) close( queue->inproc_sync );
 }
 
 static void msg_queue_poll_event( struct fd *fd, int event )
@@ -1425,6 +1426,7 @@
     if (event & (POLLERR | POLLHUP)) set_fd_events( fd, -1 );
     else set_fd_events( queue->fd, 0 );
     wake_up( &queue->obj, 0 );
+    set_inproc_event( queue->inproc_sync );
 }
 
 static void thread_input_dump( struct object *obj, int verbose )
@@ -3209,11 +3211,16 @@
                 }
                 SHARED_WRITE_END;
             }
-            else wake_up( &queue->obj, 0 );
+            else
+            {
+                wake_up( &queue->obj, 0 );
+                set_inproc_event( queue->inproc_sync );
+            }
+        }
+        else
+        {
+            reset_inproc_event( queue->inproc_sync );
         }
-
-        if (do_esync() && !is_signaled( queue ))
-            esync_clear( queue->esync_fd );
     }
 }
 
@@ -3235,8 +3242,8 @@
         }
         SHARED_WRITE_END;
 
-        if (do_esync() && !is_signaled( queue ))
-            esync_clear( queue->esync_fd );
+        if (!is_signaled( queue ))
+            reset_inproc_event( queue->inproc_sync );
     }
     else reply->wake_bits = reply->changed_bits = 0;
 }
@@ -3435,6 +3442,9 @@
     }
     SHARED_WRITE_END;
 
+    if (!is_signaled( queue ))
+        reset_inproc_event( queue->inproc_sync );
+
     /* then check for posted messages */
     if ((filter & QS_POSTMESSAGE) &&
         get_posted_message( queue, queue->ignore_post_msg, get_win, req->get_first, req->get_last, req->flags, reply ))
@@ -3504,11 +3514,8 @@
     }
     SHARED_WRITE_END;
 
+    reset_inproc_event( queue->inproc_sync );
     set_error( STATUS_PENDING );  /* FIXME */
-
-    if (do_esync() && !is_signaled( queue ))
-        esync_clear( queue->esync_fd );
-
     return;
 
 found_msg:
@@ -4293,23 +4300,6 @@
     }
 }
 
-DECL_HANDLER(esync_msgwait)
-{
-    struct msg_queue *queue = get_current_queue();
-    const queue_shm_t *queue_shm;
-
-    if (!queue) return;
-    queue_shm = queue->shared;
-    queue->esync_in_msgwait = req->in_msgwait;
-
-    if (current->process->idle_event && !(queue_shm->wake_mask & QS_SMRESULT))
-        set_event( current->process->idle_event );
-
-    /* and start/stop waiting on the driver */
-    if (queue->fd)
-        set_fd_events( queue->fd, req->in_msgwait ? POLLIN : 0 );
-}
-
 DECL_HANDLER(set_keyboard_repeat)
 {
     struct desktop *desktop;
@@ -4329,3 +4319,41 @@
     release_object( desktop );
 }
 
+DECL_HANDLER(select_inproc_queue)
+{
+    struct msg_queue *queue = current->queue;
+
+    if (queue->in_inproc_wait)
+    {
+        set_error( STATUS_ACCESS_DENIED );
+    }
+    else
+    {
+        check_thread_queue_idle( current );
+
+        if (queue->fd)
+            set_fd_events( queue->fd, POLLIN );
+
+        queue->in_inproc_wait = 1;
+    }
+}
+
+DECL_HANDLER(unselect_inproc_queue)
+{
+    struct msg_queue *queue = current->queue;
+
+    if (!queue->in_inproc_wait)
+    {
+        set_error( STATUS_ACCESS_DENIED );
+    }
+    else
+    {
+        if (queue->fd)
+            set_fd_events( queue->fd, 0 );
+
+        if (req->signaled)
+            msg_queue_satisfied( &queue->obj, NULL );
+
+        queue->in_inproc_wait = 0;
+    }
+}
diff --color -u -r -N a/server/registry.c b/server/registry.c
--- a/server/registry.c	2025-04-11 19:04:49.160719409 +0500
+++ b/server/registry.c	2025-04-11 19:11:08.130894766 +0500
@@ -180,7 +180,6 @@
     no_add_queue,            /* add_queue */
     NULL,                    /* remove_queue */
     NULL,                    /* signaled */
-    NULL,                    /* get_esync_fd */
     NULL,                    /* satisfied */
     no_signal,               /* signal */
     no_get_fd,               /* get_fd */
@@ -193,6 +192,7 @@
     key_unlink_name,         /* unlink_name */
     no_open_file,            /* open_file */
     no_kernel_obj_list,      /* get_kernel_obj_list */
+    no_get_inproc_sync,      /* get_inproc_sync */
     key_close_handle,        /* close_handle */
     key_destroy              /* destroy */
 };
diff --color -u -r -N a/server/request.c b/server/request.c
--- a/server/request.c	2025-04-11 19:04:48.194941765 +0500
+++ b/server/request.c	2025-04-11 19:11:08.131096398 +0500
@@ -89,7 +89,6 @@
     no_add_queue,                  /* add_queue */
     NULL,                          /* remove_queue */
     NULL,                          /* signaled */
-    NULL,                          /* get_esync_fd */
     NULL,                          /* satisfied */
     no_signal,                     /* signal */
     no_get_fd,                     /* get_fd */
@@ -102,6 +101,7 @@
     NULL,                          /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
+    no_get_inproc_sync,            /* get_inproc_sync */
     no_close_handle,               /* close_handle */
     master_socket_destroy          /* destroy */
 };
diff --color -u -r -N a/server/request_handlers.h b/server/request_handlers.h
--- a/server/request_handlers.h	2025-04-11 19:04:52.307088459 +0500
+++ b/server/request_handlers.h	2025-04-11 19:11:08.151234486 +0500
@@ -300,12 +300,12 @@
 DECL_HANDLER(resume_process);
 DECL_HANDLER(get_next_process);
 DECL_HANDLER(get_next_thread);
-DECL_HANDLER(create_esync);
-DECL_HANDLER(open_esync);
-DECL_HANDLER(get_esync_fd);
-DECL_HANDLER(esync_msgwait);
 DECL_HANDLER(set_keyboard_repeat);
-DECL_HANDLER(get_esync_apc_fd);
+DECL_HANDLER(get_linux_sync_device);
+DECL_HANDLER(get_linux_sync_obj);
+DECL_HANDLER(select_inproc_queue);
+DECL_HANDLER(unselect_inproc_queue);
+DECL_HANDLER(get_inproc_alert_event);
 
 typedef void (*req_handler)( const void *req, void *reply );
 static const req_handler req_handlers[REQ_NB_REQUESTS] =
@@ -603,12 +603,12 @@
     (req_handler)req_resume_process,
     (req_handler)req_get_next_process,
     (req_handler)req_get_next_thread,
-    (req_handler)req_create_esync,
-    (req_handler)req_open_esync,
-    (req_handler)req_get_esync_fd,
-    (req_handler)req_esync_msgwait,
     (req_handler)req_set_keyboard_repeat,
-    (req_handler)req_get_esync_apc_fd,
+    (req_handler)req_get_linux_sync_device,
+    (req_handler)req_get_linux_sync_obj,
+    (req_handler)req_select_inproc_queue,
+    (req_handler)req_unselect_inproc_queue,
+    (req_handler)req_get_inproc_alert_event,
 };
 
 C_ASSERT( sizeof(abstime_t) == 8 );
@@ -2295,35 +2295,21 @@
 C_ASSERT( sizeof(struct get_next_thread_request) == 32 );
 C_ASSERT( offsetof(struct get_next_thread_reply, handle) == 8 );
 C_ASSERT( sizeof(struct get_next_thread_reply) == 16 );
-C_ASSERT( offsetof(struct create_esync_request, access) == 12 );
-C_ASSERT( offsetof(struct create_esync_request, initval) == 16 );
-C_ASSERT( offsetof(struct create_esync_request, type) == 20 );
-C_ASSERT( offsetof(struct create_esync_request, max) == 24 );
-C_ASSERT( sizeof(struct create_esync_request) == 32 );
-C_ASSERT( offsetof(struct create_esync_reply, handle) == 8 );
-C_ASSERT( offsetof(struct create_esync_reply, type) == 12 );
-C_ASSERT( offsetof(struct create_esync_reply, shm_idx) == 16 );
-C_ASSERT( sizeof(struct create_esync_reply) == 24 );
-C_ASSERT( offsetof(struct open_esync_request, access) == 12 );
-C_ASSERT( offsetof(struct open_esync_request, attributes) == 16 );
-C_ASSERT( offsetof(struct open_esync_request, rootdir) == 20 );
-C_ASSERT( offsetof(struct open_esync_request, type) == 24 );
-C_ASSERT( sizeof(struct open_esync_request) == 32 );
-C_ASSERT( offsetof(struct open_esync_reply, handle) == 8 );
-C_ASSERT( offsetof(struct open_esync_reply, type) == 12 );
-C_ASSERT( offsetof(struct open_esync_reply, shm_idx) == 16 );
-C_ASSERT( sizeof(struct open_esync_reply) == 24 );
-C_ASSERT( offsetof(struct get_esync_fd_request, handle) == 12 );
-C_ASSERT( sizeof(struct get_esync_fd_request) == 16 );
-C_ASSERT( offsetof(struct get_esync_fd_reply, type) == 8 );
-C_ASSERT( offsetof(struct get_esync_fd_reply, shm_idx) == 12 );
-C_ASSERT( sizeof(struct get_esync_fd_reply) == 16 );
-C_ASSERT( offsetof(struct esync_msgwait_request, in_msgwait) == 12 );
-C_ASSERT( sizeof(struct esync_msgwait_request) == 16 );
 C_ASSERT( offsetof(struct set_keyboard_repeat_request, enable) == 12 );
 C_ASSERT( offsetof(struct set_keyboard_repeat_request, delay) == 16 );
 C_ASSERT( offsetof(struct set_keyboard_repeat_request, period) == 20 );
 C_ASSERT( sizeof(struct set_keyboard_repeat_request) == 24 );
 C_ASSERT( offsetof(struct set_keyboard_repeat_reply, enable) == 8 );
 C_ASSERT( sizeof(struct set_keyboard_repeat_reply) == 16 );
-C_ASSERT( sizeof(struct get_esync_apc_fd_request) == 16 );
+C_ASSERT( sizeof(struct get_linux_sync_device_request) == 16 );
+C_ASSERT( offsetof(struct get_linux_sync_obj_request, handle) == 12 );
+C_ASSERT( sizeof(struct get_linux_sync_obj_request) == 16 );
+C_ASSERT( offsetof(struct get_linux_sync_obj_reply, type) == 8 );
+C_ASSERT( offsetof(struct get_linux_sync_obj_reply, access) == 12 );
+C_ASSERT( sizeof(struct get_linux_sync_obj_reply) == 16 );
+C_ASSERT( sizeof(struct select_inproc_queue_request) == 16 );
+C_ASSERT( offsetof(struct unselect_inproc_queue_request, signaled) == 12 );
+C_ASSERT( sizeof(struct unselect_inproc_queue_request) == 16 );
+C_ASSERT( sizeof(struct get_inproc_alert_event_request) == 16 );
+C_ASSERT( offsetof(struct get_inproc_alert_event_reply, handle) == 8 );
+C_ASSERT( sizeof(struct get_inproc_alert_event_reply) == 16 );
diff --color -u -r -N a/server/request_trace.h b/server/request_trace.h
--- a/server/request_trace.h	2025-04-11 19:04:52.303283693 +0500
+++ b/server/request_trace.h	2025-04-11 19:11:08.151678141 +0500
@@ -3366,68 +3366,49 @@
     fprintf( stderr, " handle=%04x", req->handle );
 }
 
-static void dump_create_esync_request( const struct create_esync_request *req )
-{
-    fprintf( stderr, " access=%08x", req->access );
-    fprintf( stderr, ", initval=%d", req->initval );
-    fprintf( stderr, ", type=%d", req->type );
-    fprintf( stderr, ", max=%d", req->max );
-    dump_varargs_object_attributes( ", objattr=", cur_size );
-}
-
-static void dump_create_esync_reply( const struct create_esync_reply *req )
+static void dump_set_keyboard_repeat_request( const struct set_keyboard_repeat_request *req )
 {
-    fprintf( stderr, " handle=%04x", req->handle );
-    fprintf( stderr, ", type=%d", req->type );
-    fprintf( stderr, ", shm_idx=%08x", req->shm_idx );
+    fprintf( stderr, " enable=%d", req->enable );
+    fprintf( stderr, ", delay=%d", req->delay );
+    fprintf( stderr, ", period=%d", req->period );
 }
 
-static void dump_open_esync_request( const struct open_esync_request *req )
+static void dump_set_keyboard_repeat_reply( const struct set_keyboard_repeat_reply *req )
 {
-    fprintf( stderr, " access=%08x", req->access );
-    fprintf( stderr, ", attributes=%08x", req->attributes );
-    fprintf( stderr, ", rootdir=%04x", req->rootdir );
-    fprintf( stderr, ", type=%d", req->type );
-    dump_varargs_unicode_str( ", name=", cur_size );
+    fprintf( stderr, " enable=%d", req->enable );
 }
 
-static void dump_open_esync_reply( const struct open_esync_reply *req )
+static void dump_get_linux_sync_device_request( const struct get_linux_sync_device_request *req )
 {
-    fprintf( stderr, " handle=%04x", req->handle );
-    fprintf( stderr, ", type=%d", req->type );
-    fprintf( stderr, ", shm_idx=%08x", req->shm_idx );
 }
 
-static void dump_get_esync_fd_request( const struct get_esync_fd_request *req )
+static void dump_get_linux_sync_obj_request( const struct get_linux_sync_obj_request *req )
 {
     fprintf( stderr, " handle=%04x", req->handle );
 }
 
-static void dump_get_esync_fd_reply( const struct get_esync_fd_reply *req )
+static void dump_get_linux_sync_obj_reply( const struct get_linux_sync_obj_reply *req )
 {
     fprintf( stderr, " type=%d", req->type );
-    fprintf( stderr, ", shm_idx=%08x", req->shm_idx );
+    fprintf( stderr, ", access=%08x", req->access );
 }
 
-static void dump_esync_msgwait_request( const struct esync_msgwait_request *req )
+static void dump_select_inproc_queue_request( const struct select_inproc_queue_request *req )
 {
-    fprintf( stderr, " in_msgwait=%d", req->in_msgwait );
 }
 
-static void dump_set_keyboard_repeat_request( const struct set_keyboard_repeat_request *req )
+static void dump_unselect_inproc_queue_request( const struct unselect_inproc_queue_request *req )
 {
-    fprintf( stderr, " enable=%d", req->enable );
-    fprintf( stderr, ", delay=%d", req->delay );
-    fprintf( stderr, ", period=%d", req->period );
+    fprintf( stderr, " signaled=%d", req->signaled );
 }
 
-static void dump_set_keyboard_repeat_reply( const struct set_keyboard_repeat_reply *req )
+static void dump_get_inproc_alert_event_request( const struct get_inproc_alert_event_request *req )
 {
-    fprintf( stderr, " enable=%d", req->enable );
 }
 
-static void dump_get_esync_apc_fd_request( const struct get_esync_apc_fd_request *req )
+static void dump_get_inproc_alert_event_reply( const struct get_inproc_alert_event_reply *req )
 {
+    fprintf( stderr, " handle=%04x", req->handle );
 }
 
 typedef void (*dump_func)( const void *req );
@@ -3727,12 +3708,12 @@
     (dump_func)dump_resume_process_request,
     (dump_func)dump_get_next_process_request,
     (dump_func)dump_get_next_thread_request,
-    (dump_func)dump_create_esync_request,
-    (dump_func)dump_open_esync_request,
-    (dump_func)dump_get_esync_fd_request,
-    (dump_func)dump_esync_msgwait_request,
     (dump_func)dump_set_keyboard_repeat_request,
-    (dump_func)dump_get_esync_apc_fd_request,
+    (dump_func)dump_get_linux_sync_device_request,
+    (dump_func)dump_get_linux_sync_obj_request,
+    (dump_func)dump_select_inproc_queue_request,
+    (dump_func)dump_unselect_inproc_queue_request,
+    (dump_func)dump_get_inproc_alert_event_request,
 };
 
 static const dump_func reply_dumpers[REQ_NB_REQUESTS] =
@@ -4030,12 +4011,12 @@
     NULL,
     (dump_func)dump_get_next_process_reply,
     (dump_func)dump_get_next_thread_reply,
-    (dump_func)dump_create_esync_reply,
-    (dump_func)dump_open_esync_reply,
-    (dump_func)dump_get_esync_fd_reply,
-    NULL,
     (dump_func)dump_set_keyboard_repeat_reply,
     NULL,
+    (dump_func)dump_get_linux_sync_obj_reply,
+    NULL,
+    NULL,
+    (dump_func)dump_get_inproc_alert_event_reply,
 };
 
 static const char * const req_names[REQ_NB_REQUESTS] =
@@ -4333,12 +4314,12 @@
     "resume_process",
     "get_next_process",
     "get_next_thread",
-    "create_esync",
-    "open_esync",
-    "get_esync_fd",
-    "esync_msgwait",
     "set_keyboard_repeat",
-    "get_esync_apc_fd",
+    "get_linux_sync_device",
+    "get_linux_sync_obj",
+    "select_inproc_queue",
+    "unselect_inproc_queue",
+    "get_inproc_alert_event",
 };
 
 static const struct
diff --color -u -r -N a/server/semaphore.c b/server/semaphore.c
--- a/server/semaphore.c	2025-04-11 19:04:48.194987773 +0500
+++ b/server/semaphore.c	2025-04-11 19:11:08.137334542 +0500
@@ -25,6 +25,7 @@
 #include <stdlib.h>
 #include <stdarg.h>
 #include <sys/types.h>
+#include <unistd.h>
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -53,14 +54,23 @@
 struct semaphore
 {
     struct object  obj;    /* object header */
-    unsigned int   count;  /* current count */
-    unsigned int   max;    /* maximum possible count */
+    union
+    {
+        struct
+        {
+            unsigned int count;  /* current count */
+            unsigned int max;    /* maximum possible count */
+        } s;
+        int inproc_sync;         /* in-process synchronization object */
+    } u;
 };
 
 static void semaphore_dump( struct object *obj, int verbose );
 static int semaphore_signaled( struct object *obj, struct wait_queue_entry *entry );
 static void semaphore_satisfied( struct object *obj, struct wait_queue_entry *entry );
 static int semaphore_signal( struct object *obj, unsigned int access );
+static int semaphore_get_inproc_sync( struct object *obj, enum inproc_sync_type *type );
+static void semaphore_destroy( struct object *obj );
 
 static const struct object_ops semaphore_ops =
 {
@@ -70,7 +80,6 @@
     add_queue,                     /* add_queue */
     remove_queue,                  /* remove_queue */
     semaphore_signaled,            /* signaled */
-    NULL,                          /* get_esync_fd */
     semaphore_satisfied,           /* satisfied */
     semaphore_signal,              /* signal */
     no_get_fd,                     /* get_fd */
@@ -83,8 +92,9 @@
     default_unlink_name,           /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
+    semaphore_get_inproc_sync,     /* get_inproc_sync */
     no_close_handle,               /* close_handle */
-    no_destroy                     /* destroy */
+    semaphore_destroy              /* destroy */
 };
 
 
@@ -104,8 +114,15 @@
         if (get_error() != STATUS_OBJECT_NAME_EXISTS)
         {
             /* initialize it if it didn't already exist */
-            sem->count = initial;
-            sem->max   = max;
+            if (use_inproc_sync())
+            {
+                sem->u.inproc_sync = create_inproc_semaphore( initial, max );
+            }
+            else
+            {
+                sem->u.s.count = initial;
+                sem->u.s.max   = max;
+            }
         }
     }
     return sem;
@@ -114,20 +131,20 @@
 static int release_semaphore( struct semaphore *sem, unsigned int count,
                               unsigned int *prev )
 {
-    if (prev) *prev = sem->count;
-    if (sem->count + count < sem->count || sem->count + count > sem->max)
+    if (prev) *prev = sem->u.s.count;
+    if (sem->u.s.count + count < sem->u.s.count || sem->u.s.count + count > sem->u.s.max)
     {
         set_error( STATUS_SEMAPHORE_LIMIT_EXCEEDED );
         return 0;
     }
-    else if (sem->count)
+    else if (sem->u.s.count)
     {
         /* there cannot be any thread to wake up if the count is != 0 */
-        sem->count += count;
+        sem->u.s.count += count;
     }
     else
     {
-        sem->count = count;
+        sem->u.s.count = count;
         wake_up( &sem->obj, count );
     }
     return 1;
@@ -137,22 +154,22 @@
 {
     struct semaphore *sem = (struct semaphore *)obj;
     assert( obj->ops == &semaphore_ops );
-    fprintf( stderr, "Semaphore count=%d max=%d\n", sem->count, sem->max );
+    fprintf( stderr, "Semaphore count=%d max=%d\n", sem->u.s.count, sem->u.s.max );
 }
 
 static int semaphore_signaled( struct object *obj, struct wait_queue_entry *entry )
 {
     struct semaphore *sem = (struct semaphore *)obj;
     assert( obj->ops == &semaphore_ops );
-    return (sem->count > 0);
+    return (sem->u.s.count > 0);
 }
 
 static void semaphore_satisfied( struct object *obj, struct wait_queue_entry *entry )
 {
     struct semaphore *sem = (struct semaphore *)obj;
     assert( obj->ops == &semaphore_ops );
-    assert( sem->count );
-    sem->count--;
+    assert( sem->u.s.count );
+    sem->u.s.count--;
 }
 
 static int semaphore_signal( struct object *obj, unsigned int access )
@@ -168,6 +185,21 @@
     return release_semaphore( sem, 1, NULL );
 }
 
+static int semaphore_get_inproc_sync( struct object *obj, enum inproc_sync_type *type )
+{
+    struct semaphore *semaphore = (struct semaphore *)obj;
+
+    *type = INPROC_SYNC_SEMAPHORE;
+    return semaphore->u.inproc_sync;
+}
+
+static void semaphore_destroy( struct object *obj )
+{
+    struct semaphore *semaphore = (struct semaphore *)obj;
+
+    if (use_inproc_sync()) close( semaphore->u.inproc_sync );
+}
+
 /* create a semaphore */
 DECL_HANDLER(create_semaphore)
 {
@@ -222,8 +254,8 @@
     if ((sem = (struct semaphore *)get_handle_obj( current->process, req->handle,
                                                    SEMAPHORE_QUERY_STATE, &semaphore_ops )))
     {
-        reply->current = sem->count;
-        reply->max = sem->max;
+        reply->current = sem->u.s.count;
+        reply->max = sem->u.s.max;
         release_object( sem );
     }
 }
diff --color -u -r -N a/server/serial.c b/server/serial.c
--- a/server/serial.c	2025-04-11 19:04:48.195012951 +0500
+++ b/server/serial.c	2025-04-11 19:11:08.144134193 +0500
@@ -91,7 +91,6 @@
     add_queue,                    /* add_queue */
     remove_queue,                 /* remove_queue */
     default_fd_signaled,          /* signaled */
-    NULL,                         /* get_esync_fd */
     no_satisfied,                 /* satisfied */
     no_signal,                    /* signal */
     serial_get_fd,                /* get_fd */
@@ -104,6 +103,7 @@
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    default_fd_get_inproc_sync,   /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     serial_destroy                /* destroy */
 };
diff --color -u -r -N a/server/signal.c b/server/signal.c
--- a/server/signal.c	2025-04-11 19:04:48.195040774 +0500
+++ b/server/signal.c	2025-04-11 19:11:08.131378079 +0500
@@ -62,7 +62,6 @@
     no_add_queue,             /* add_queue */
     NULL,                     /* remove_queue */
     NULL,                     /* signaled */
-    NULL,                     /* get_esync_fd */
     NULL,                     /* satisfied */
     no_signal,                /* signal */
     no_get_fd,                /* get_fd */
@@ -75,6 +74,7 @@
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_inproc_sync,       /* get_inproc_sync */
     no_close_handle,          /* close_handle */
     handler_destroy           /* destroy */
 };
diff --color -u -r -N a/server/sock.c b/server/sock.c
--- a/server/sock.c	2025-04-11 19:04:49.816167613 +0500
+++ b/server/sock.c	2025-04-11 19:11:08.144316190 +0500
@@ -491,7 +491,6 @@
     add_queue,                    /* add_queue */
     remove_queue,                 /* remove_queue */
     default_fd_signaled,          /* signaled */
-    NULL,                         /* get_esync_fd */
     no_satisfied,                 /* satisfied */
     no_signal,                    /* signal */
     sock_get_fd,                  /* get_fd */
@@ -504,6 +503,7 @@
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    default_fd_get_inproc_sync,   /* get_inproc_sync */
     sock_close_handle,            /* close_handle */
     sock_destroy                  /* destroy */
 };
@@ -3884,7 +3884,6 @@
     no_add_queue,            /* add_queue */
     NULL,                    /* remove_queue */
     NULL,                    /* signaled */
-    NULL,                    /* get_esync_fd */
     no_satisfied,            /* satisfied */
     no_signal,               /* signal */
     ifchange_get_fd,         /* get_fd */
@@ -3897,6 +3896,7 @@
     NULL,                    /* unlink_name */
     no_open_file,            /* open_file */
     no_kernel_obj_list,      /* get_kernel_obj_list */
+    no_get_inproc_sync,      /* get_inproc_sync */
     no_close_handle,         /* close_handle */
     ifchange_destroy         /* destroy */
 };
@@ -4106,7 +4106,6 @@
     no_add_queue,               /* add_queue */
     NULL,                       /* remove_queue */
     NULL,                       /* signaled */
-    NULL,                       /* get_esync_fd */
     no_satisfied,               /* satisfied */
     no_signal,                  /* signal */
     no_get_fd,                  /* get_fd */
@@ -4119,6 +4118,7 @@
     default_unlink_name,        /* unlink_name */
     socket_device_open_file,    /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_get_inproc_sync,         /* get_inproc_sync */
     no_close_handle,            /* close_handle */
     no_destroy                  /* destroy */
 };
diff --color -u -r -N a/server/symlink.c b/server/symlink.c
--- a/server/symlink.c	2025-04-11 19:04:48.195182453 +0500
+++ b/server/symlink.c	2025-04-11 19:11:08.131889224 +0500
@@ -71,7 +71,6 @@
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
-    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
@@ -84,6 +83,7 @@
     default_unlink_name,          /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     no_close_handle,              /* close_handle */
     symlink_destroy               /* destroy */
 };
diff --color -u -r -N a/server/thread.c b/server/thread.c
--- a/server/thread.c	2025-04-11 19:04:48.373946840 +0500
+++ b/server/thread.c	2025-04-11 19:21:53.993708223 +0500
@@ -60,7 +60,6 @@
 #include "request.h"
 #include "user.h"
 #include "security.h"
-#include "esync.h"
 
 
 /* thread queues */
@@ -107,7 +106,6 @@
     add_queue,                  /* add_queue */
     remove_queue,               /* remove_queue */
     thread_apc_signaled,        /* signaled */
-    NULL,                       /* get_esync_fd */
     no_satisfied,               /* satisfied */
     no_signal,                  /* signal */
     no_get_fd,                  /* get_fd */
@@ -120,6 +118,7 @@
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_get_inproc_sync,         /* get_inproc_sync */
     no_close_handle,            /* close_handle */
     thread_apc_destroy          /* destroy */
 };
@@ -150,7 +149,6 @@
     add_queue,                  /* add_queue */
     remove_queue,               /* remove_queue */
     context_signaled,           /* signaled */
-    NULL,                       /* get_esync_fd */
     no_satisfied,               /* satisfied */
     no_signal,                  /* signal */
     no_get_fd,                  /* get_fd */
@@ -163,6 +161,7 @@
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_get_inproc_sync,         /* get_inproc_sync */
     no_close_handle,            /* close_handle */
     no_destroy                  /* destroy */
 };
@@ -187,10 +186,10 @@
 
 static void dump_thread( struct object *obj, int verbose );
 static int thread_signaled( struct object *obj, struct wait_queue_entry *entry );
-static int thread_get_esync_fd( struct object *obj, enum esync_type *type );
 static unsigned int thread_map_access( struct object *obj, unsigned int access );
 static void thread_poll_event( struct fd *fd, int event );
 static struct list *thread_get_kernel_obj_list( struct object *obj );
+static int thread_get_inproc_sync( struct object *obj, enum inproc_sync_type *type );
 static void destroy_thread( struct object *obj );
 
 static const struct object_ops thread_ops =
@@ -201,7 +200,6 @@
     add_queue,                  /* add_queue */
     remove_queue,               /* remove_queue */
     thread_signaled,            /* signaled */
-    thread_get_esync_fd,        /* get_esync_fd */
     no_satisfied,               /* satisfied */
     no_signal,                  /* signal */
     no_get_fd,                  /* get_fd */
@@ -214,6 +212,7 @@
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     thread_get_kernel_obj_list, /* get_kernel_obj_list */
+    thread_get_inproc_sync,     /* get_inproc_sync */
     no_close_handle,            /* close_handle */
     destroy_thread              /* destroy */
 };
@@ -397,8 +396,6 @@
     thread->context         = NULL;
     thread->teb             = 0;
     thread->entry_point     = 0;
-    thread->esync_fd        = -1;
-    thread->esync_apc_fd    = -1;
     thread->system_regs     = 0;
     thread->queue           = NULL;
     thread->wait            = NULL;
@@ -421,6 +418,8 @@
     thread->desc            = NULL;
     thread->desc_len        = 0;
     thread->exit_poll       = NULL;
+    thread->inproc_sync     = create_inproc_event( TRUE, FALSE );
+    thread->inproc_alert_event = NULL;
 
     thread->creation_time = current_time;
     thread->exit_time     = 0;
@@ -548,12 +547,6 @@
         }
     }
 
-    if (do_esync())
-    {
-        thread->esync_fd = esync_create_fd( 0, 0 );
-        thread->esync_apc_fd = esync_create_fd( 0, 0 );
-    }
-
     set_fd_events( thread->request_fd, POLLIN );  /* start listening to events */
     add_process_thread( thread->process, thread );
     return thread;
@@ -578,6 +571,14 @@
     return &thread->kernel_object;
 }
 
+static int thread_get_inproc_sync( struct object *obj, enum inproc_sync_type *type )
+{
+    struct thread *thread = (struct thread *)obj;
+
+    *type = INPROC_SYNC_MANUAL_SERVER;
+    return thread->inproc_sync;
+}
+
 /* cleanup everything that is no longer needed by a dead thread */
 /* used by destroy_thread and kill_thread */
 static void cleanup_thread( struct thread *thread )
@@ -634,9 +635,8 @@
     if (thread->exit_poll) remove_timeout_user( thread->exit_poll );
     if (thread->id) free_ptid( thread->id );
     if (thread->token) release_object( thread->token );
-
-    if (do_esync())
-        close( thread->esync_fd );
+    if (use_inproc_sync()) close( thread->inproc_sync );
+    if (thread->inproc_alert_event) release_object( thread->inproc_alert_event );
 }
 
 /* dump a thread on stdout for debugging purposes */
@@ -655,13 +655,6 @@
     return mythread->state == TERMINATED && !mythread->exit_poll;
 }
 
-static int thread_get_esync_fd( struct object *obj, enum esync_type *type )
-{
-    struct thread *thread = (struct thread *)obj;
-    *type = ESYNC_MANUAL_SERVER;
-    return thread->esync_fd;
-}
-
 static unsigned int thread_map_access( struct object *obj, unsigned int access )
 {
     access = default_map_access( obj, access );
@@ -1307,9 +1300,6 @@
     struct list *ptr;
     int ret;
 
-    if (do_esync())
-        esync_wake_up( obj );
-
     LIST_FOR_EACH( ptr, &obj->wait_queue )
     {
         struct wait_queue_entry *entry = LIST_ENTRY( ptr, struct wait_queue_entry, entry );
@@ -1397,8 +1387,8 @@
     {
         wake_thread( thread );
 
-        if (do_esync() && queue == &thread->user_apc)
-            esync_wake_fd( thread->esync_apc_fd );
+        if (apc->call.type == APC_USER && thread->inproc_alert_event)
+            set_event( thread->inproc_alert_event );
     }
 
     return 1;
@@ -1431,6 +1421,8 @@
         apc->executed = 1;
         wake_up( &apc->obj, 0 );
         release_object( apc );
+        if (list_empty( &thread->user_apc ) && thread->inproc_alert_event)
+            reset_event( thread->inproc_alert_event );
         return;
     }
 }
@@ -1445,11 +1437,10 @@
     {
         apc = LIST_ENTRY( ptr, struct thread_apc, entry );
         list_remove( ptr );
-    }
-
-    if (do_esync() && list_empty( &thread->system_apc ) && list_empty( &thread->user_apc ))
-        esync_clear( thread->esync_apc_fd );
 
+        if (list_empty( &thread->user_apc ) && thread->inproc_alert_event)
+            reset_event( thread->inproc_alert_event );
+    }
     return apc;
 }
 
@@ -1565,8 +1556,7 @@
     }
     kill_console_processes( thread, 0 );
     abandon_mutexes( thread );
-    if (do_esync())
-        esync_abandon_mutexes( thread );
+    set_inproc_event( thread->inproc_sync );
     if (violent_death)
     {
         send_thread_signal( thread, SIGQUIT );
@@ -2326,3 +2316,12 @@
     set_error( STATUS_NO_MORE_ENTRIES );
     release_object( process );
 }
+
+DECL_HANDLER(get_inproc_alert_event)
+{
+    if (!current->inproc_alert_event)
+        current->inproc_alert_event = create_event( NULL, NULL, 0, 1, !list_empty( &current->user_apc ), NULL );
+
+    if (current->inproc_alert_event)
+        reply->handle = alloc_handle( current->process, current->inproc_alert_event, SYNCHRONIZE, 0 );
+}
diff --color -u -r -N a/server/thread.h b/server/thread.h
--- a/server/thread.h	2025-04-11 19:04:48.294941880 +0500
+++ b/server/thread.h	2025-04-11 19:19:56.793821000 +0500
@@ -56,8 +56,6 @@
     struct process        *process;
     thread_id_t            id;            /* thread id */
     struct list            mutex_list;    /* list of currently owned mutexes */
-    int                    esync_fd;      /* esync file descriptor (signalled on exit) */
-    int                    esync_apc_fd;  /* esync apc fd (signalled when APCs are present) */
     unsigned int           system_regs;   /* which system regs have been set */
     struct msg_queue      *queue;         /* message queue */
     struct thread_wait    *wait;          /* current wait condition if sleeping */
@@ -97,6 +95,8 @@
     WCHAR                 *desc;          /* thread description string */
     struct completion_wait *completion_wait; /* completion port wait object the thread is associated with */
     struct timeout_user   *exit_poll;     /* poll if the thread/process has exited already */
+    int                    inproc_sync;   /* in-process synchronization object */
+    struct event          *inproc_alert_event; /* in-process synchronization alert event */
 };
 
 extern struct thread *current;
diff --color -u -r -N a/server/timer.c b/server/timer.c
--- a/server/timer.c	2025-04-11 19:04:48.288534587 +0500
+++ b/server/timer.c	2025-04-11 19:11:08.142385280 +0500
@@ -26,6 +26,7 @@
 #include <sys/time.h>
 #include <sys/types.h>
 #include <stdarg.h>
+#include <unistd.h>
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -35,7 +36,6 @@
 #include "file.h"
 #include "handle.h"
 #include "request.h"
-#include "esync.h"
 
 static const WCHAR timer_name[] = {'T','i','m','e','r'};
 
@@ -53,22 +53,22 @@
 
 struct timer
 {
-    struct object        obj;       /* object header */
-    int                  manual;    /* manual reset */
-    int                  signaled;  /* current signaled state */
-    unsigned int         period;    /* timer period in ms */
-    abstime_t            when;      /* next expiration */
-    struct timeout_user *timeout;   /* timeout user */
-    struct thread       *thread;    /* thread that set the APC function */
-    client_ptr_t         callback;  /* callback APC function */
-    client_ptr_t         arg;       /* callback argument */
-    int                  esync_fd;  /* esync file descriptor */
+    struct object        obj;           /* object header */
+    int                  manual;        /* manual reset */
+    int                  signaled;      /* current signaled state */
+    unsigned int         period;        /* timer period in ms */
+    abstime_t            when;          /* next expiration */
+    struct timeout_user *timeout;       /* timeout user */
+    struct thread       *thread;        /* thread that set the APC function */
+    client_ptr_t         callback;      /* callback APC function */
+    client_ptr_t         arg;           /* callback argument */
+    int                  inproc_sync;   /* in-process synchronization object */
 };
 
 static void timer_dump( struct object *obj, int verbose );
 static int timer_signaled( struct object *obj, struct wait_queue_entry *entry );
-static int timer_get_esync_fd( struct object *obj, enum esync_type *type );
 static void timer_satisfied( struct object *obj, struct wait_queue_entry *entry );
+static int timer_get_inproc_sync( struct object *obj, enum inproc_sync_type *type );
 static void timer_destroy( struct object *obj );
 
 static const struct object_ops timer_ops =
@@ -79,7 +79,6 @@
     add_queue,                 /* add_queue */
     remove_queue,              /* remove_queue */
     timer_signaled,            /* signaled */
-    timer_get_esync_fd,        /* get_esync_fd */
     timer_satisfied,           /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
@@ -92,6 +91,7 @@
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    timer_get_inproc_sync,     /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     timer_destroy              /* destroy */
 };
@@ -114,10 +114,7 @@
             timer->period   = 0;
             timer->timeout  = NULL;
             timer->thread   = NULL;
-            timer->esync_fd = -1;
-
-            if (do_esync())
-                timer->esync_fd = esync_create_fd( 0, 0 );
+            timer->inproc_sync = create_inproc_event( manual, FALSE );
         }
     }
     return timer;
@@ -159,6 +156,7 @@
     /* wake up waiters */
     timer->signaled = 1;
     wake_up( &timer->obj, 0 );
+    set_inproc_event( timer->inproc_sync );
 }
 
 /* cancel a running timer */
@@ -189,9 +187,7 @@
     {
         period = 0;  /* period doesn't make any sense for a manual timer */
         timer->signaled = 0;
-
-        if (do_esync())
-            esync_clear( timer->esync_fd );
+        reset_inproc_event( timer->inproc_sync );
     }
     timer->when     = (expire <= 0) ? expire - monotonic_time : max( expire, current_time );
     timer->period   = period;
@@ -219,18 +215,19 @@
     return timer->signaled;
 }
 
-static int timer_get_esync_fd( struct object *obj, enum esync_type *type )
+static void timer_satisfied( struct object *obj, struct wait_queue_entry *entry )
 {
     struct timer *timer = (struct timer *)obj;
-    *type = timer->manual ? ESYNC_MANUAL_SERVER : ESYNC_AUTO_SERVER;
-    return timer->esync_fd;
+    assert( obj->ops == &timer_ops );
+    if (!timer->manual) timer->signaled = 0;
 }
 
-static void timer_satisfied( struct object *obj, struct wait_queue_entry *entry )
+static int timer_get_inproc_sync( struct object *obj, enum inproc_sync_type *type )
 {
     struct timer *timer = (struct timer *)obj;
-    assert( obj->ops == &timer_ops );
-    if (!timer->manual) timer->signaled = 0;
+
+    *type = timer->manual ? INPROC_SYNC_MANUAL_SERVER : INPROC_SYNC_AUTO_SERVER;
+    return timer->inproc_sync;
 }
 
 static void timer_destroy( struct object *obj )
@@ -240,7 +237,7 @@
 
     if (timer->timeout) remove_timeout_user( timer->timeout );
     if (timer->thread) release_object( timer->thread );
-    if (do_esync()) close( timer->esync_fd );
+    if (use_inproc_sync()) close( timer->inproc_sync );
 }
 
 /* create a timer */
diff --color -u -r -N a/server/token.c b/server/token.c
--- a/server/token.c	2025-04-11 19:04:48.195312150 +0500
+++ b/server/token.c	2025-04-11 19:11:08.132321844 +0500
@@ -145,7 +145,6 @@
     no_add_queue,              /* add_queue */
     NULL,                      /* remove_queue */
     NULL,                      /* signaled */
-    NULL,                      /* get_esync_fd */
     NULL,                      /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
@@ -158,6 +157,7 @@
     NULL,                      /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_inproc_sync,        /* get_inproc_sync */
     no_close_handle,           /* close_handle */
     token_destroy              /* destroy */
 };
diff --color -u -r -N a/server/window.c b/server/window.c
--- a/server/window.c	2025-04-11 19:04:48.195374329 +0500
+++ b/server/window.c	2025-04-11 19:11:08.132572548 +0500
@@ -107,7 +107,6 @@
     no_add_queue,             /* add_queue */
     NULL,                     /* remove_queue */
     NULL,                     /* signaled */
-    NULL,                     /* get_esync_fd */
     NULL,                     /* satisfied */
     no_signal,                /* signal */
     no_get_fd,                /* get_fd */
@@ -120,6 +119,7 @@
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_inproc_sync,       /* get_inproc_sync */
     no_close_handle,          /* close_handle */
     window_destroy            /* destroy */
 };
diff --color -u -r -N a/server/winstation.c b/server/winstation.c
--- a/server/winstation.c	2025-04-11 19:04:48.195467917 +0500
+++ b/server/winstation.c	2025-04-11 19:11:08.132835373 +0500
@@ -76,7 +76,6 @@
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
-    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
@@ -89,6 +88,7 @@
     default_unlink_name,          /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     winstation_close_handle,      /* close_handle */
     winstation_destroy            /* destroy */
 };
@@ -117,7 +117,6 @@
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
-    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
@@ -130,6 +129,7 @@
     default_unlink_name,          /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_inproc_sync,           /* get_inproc_sync */
     desktop_close_handle,         /* close_handle */
     desktop_destroy               /* destroy */
 };

From 99271b005a49e52dd903872983864456d26fdff7 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 12 Mar 2021 18:27:41 +0100
Subject: [PATCH 01/10] winex11.drv: Store swapchain surfaces associations.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Based on a patch from Felix HÃ¤dicke <felixhaedicke@web.de>.
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45277
---
 dlls/winex11.drv/vulkan.c | 23 +++++++++++++++++++++--
 1 file changed, 21 insertions(+), 2 deletions(-)

diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index 139faf6b407..0baa29b435a 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -54,6 +54,7 @@ static CRITICAL_SECTION_DEBUG critsect_debug =
 static CRITICAL_SECTION context_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
 static XContext vulkan_hwnd_context;
+static XContext vulkan_swapchain_context;
 
 #define VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR 1000004000
 
@@ -138,6 +139,7 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
 #undef LOAD_OPTIONAL_FUNCPTR
 
     vulkan_hwnd_context = XUniqueContext();
+    vulkan_swapchain_context = XUniqueContext();
 
     return TRUE;
 
@@ -255,20 +257,28 @@ static VkResult X11DRV_vkCreateSwapchainKHR(VkDevice device,
         const VkSwapchainCreateInfoKHR *create_info,
         const VkAllocationCallbacks *allocator, VkSwapchainKHR *swapchain)
 {
+    VkResult result;
     struct wine_vk_surface *x11_surface = surface_from_handle(create_info->surface);
     VkSwapchainCreateInfoKHR create_info_host;
     TRACE("%p %p %p %p\n", device, create_info, allocator, swapchain);
 
     if (allocator)
         FIXME("Support for allocation callbacks not implemented yet\n");
 
     if (!x11_surface->hwnd)
         return VK_ERROR_SURFACE_LOST_KHR;
 
     create_info_host = *create_info;
     create_info_host.surface = x11_surface->surface;
 
-    return pvkCreateSwapchainKHR(device, &create_info_host, NULL /* allocator */, swapchain);
+    result = pvkCreateSwapchainKHR(device, &create_info_host, NULL /* allocator */, swapchain);
+    if (result == VK_SUCCESS)
+    {
+        EnterCriticalSection(&context_section);
+        XSaveContext(gdi_display, (XID)(*swapchain), vulkan_swapchain_context, (char *)wine_vk_surface_grab(x11_surface));
+        LeaveCriticalSection(&context_section);
+    }
+    return result;
 }
 
 static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
@@ -366,12 +378,19 @@ static void X11DRV_vkDestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface
 static void X11DRV_vkDestroySwapchainKHR(VkDevice device, VkSwapchainKHR swapchain,
          const VkAllocationCallbacks *allocator)
 {
+    struct wine_vk_surface *surface;
+
     TRACE("%p, 0x%s %p\n", device, wine_dbgstr_longlong(swapchain), allocator);
 
     if (allocator)
         FIXME("Support for allocation callbacks not implemented yet\n");
 
     pvkDestroySwapchainKHR(device, swapchain, NULL /* allocator */);
+
+    EnterCriticalSection(&context_section);
+    if (!XFindContext(gdi_display, (XID)swapchain, vulkan_swapchain_context, (char **)&surface)) wine_vk_surface_release(surface);
+    XDeleteContext(gdi_display, (XID)swapchain, vulkan_swapchain_context);
+    LeaveCriticalSection(&context_section);
 }
 
 static VkResult X11DRV_vkEnumerateInstanceExtensionProperties(const char *layer_name,
-- 
2.31.0

From c53a9587846cb6ad0e08b456de58908d84e39dae Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 12 Mar 2021 18:07:04 +0100
Subject: [PATCH 02/10] winex11.drv: Keep a list of alive vulkan surfaces.

And resize them when client rect size changes.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45277
---
 dlls/winex11.drv/vulkan.c | 47 +++++++++++++++++++++++++++++++++------
 dlls/winex11.drv/window.c |  1 +
 dlls/winex11.drv/x11drv.h |  1 +
 3 files changed, 42 insertions(+), 7 deletions(-)

diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index 0baa29b435a..dd75a159ab1 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -60,6 +60,7 @@ static XContext vulkan_swapchain_context;
 
 struct wine_vk_surface
 {
+    struct list entry;
     LONG ref;
     Window window;
     VkSurfaceKHR surface; /* native surface */
@@ -208,6 +209,10 @@ static void wine_vk_surface_release(struct wine_vk_surface *surface)
     if (InterlockedDecrement(&surface->ref))
         return;
 
+    EnterCriticalSection(&context_section);
+    list_remove(&surface->entry);
+    LeaveCriticalSection(&context_section);
+
     if (surface->window)
         XDestroyWindow(gdi_display, surface->window);
 
@@ -215,14 +220,26 @@ static void wine_vk_surface_release(struct wine_vk_surface *surface)
 }
 
 void wine_vk_surface_destroy(HWND hwnd)
+{
+    struct list *surface_list;
+    EnterCriticalSection(&context_section);
+    if (XFindContext(gdi_display, (XID)hwnd, vulkan_hwnd_context, (char **)&surface_list))
+        surface_list = NULL;
+    XDeleteContext(gdi_display, (XID)hwnd, vulkan_hwnd_context);
+    LeaveCriticalSection(&context_section);
+    heap_free(surface_list);
+}
+
+void resize_vk_surfaces(HWND hwnd, Window active, int mask, XWindowChanges *changes)
 {
     struct wine_vk_surface *surface;
+    struct list *surface_list;
     EnterCriticalSection(&context_section);
-    if (!XFindContext(gdi_display, (XID)hwnd, vulkan_hwnd_context, (char **)&surface))
+    if (!XFindContext(gdi_display, (XID)hwnd, vulkan_hwnd_context, (char **)&surface_list))
     {
-        wine_vk_surface_release(surface);
+        LIST_FOR_EACH_ENTRY(surface, surface_list, struct wine_vk_surface, entry)
+            if (surface->window != active) XConfigureWindow(gdi_display, surface->window, mask, changes);
     }
-    XDeleteContext(gdi_display, (XID)hwnd, vulkan_hwnd_context);
     LeaveCriticalSection(&context_section);
 }
 
@@ -285,7 +302,8 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
 {
     VkResult res;
     VkXlibSurfaceCreateInfoKHR create_info_host;
-    struct wine_vk_surface *x11_surface, *prev;
+    struct wine_vk_surface *x11_surface;
+    struct list *surface_list;
 
     TRACE("%p %p %p %p\n", instance, create_info, allocator, surface);
 
@@ -304,6 +322,7 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
     x11_surface->hwnd = create_info->hwnd;
     x11_surface->window = x11_surface->hwnd ? create_client_window(create_info->hwnd, &default_visual)
                                             : create_dummy_client_window();
+    list_init(&x11_surface->entry);
 
     if (!x11_surface->window)
     {
@@ -329,12 +348,23 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
     if (x11_surface->hwnd)
     {
         EnterCriticalSection(&context_section);
-        if (!XFindContext(gdi_display, (XID)create_info->hwnd, vulkan_hwnd_context, (char **)&prev))
+        if (XFindContext(gdi_display, (XID)create_info->hwnd, vulkan_hwnd_context, (char **)&surface_list) &&
+                (surface_list = heap_alloc_zero(sizeof(*surface_list))))
         {
-            wine_vk_surface_release(prev);
+            list_init(surface_list);
+            XSaveContext(gdi_display, (XID)create_info->hwnd, vulkan_hwnd_context, (char *)surface_list);
         }
-        XSaveContext(gdi_display, (XID)create_info->hwnd, vulkan_hwnd_context, (char *)wine_vk_surface_grab(x11_surface));
+        if (!XFindContext(gdi_display, (XID)create_info->hwnd, vulkan_hwnd_context, (char **)&surface_list))
+            list_add_tail(surface_list, &x11_surface->entry);
         LeaveCriticalSection(&context_section);
+
+        if (!surface_list)
+        {
+            ERR("Failed to allocate surface list %p\n", create_info->hwnd);
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto err;
+        }
+
     }
 
     *surface = (uintptr_t)x11_surface;
@@ -694,4 +723,8 @@ void wine_vk_surface_destroy(HWND hwnd)
 {
 }
 
+void resize_vk_surfaces(HWND hwnd, Window active, int mask, XWindowChanges changes)
+{
+}
+
 #endif /* SONAME_LIBVULKAN */
diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index baaa30d74e3..0cc4c0617c4 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -1362,6 +1362,7 @@ static void sync_client_position( struct x11drv_win_data *data,
         TRACE( "setting client win %lx pos %d,%d,%dx%d changes=%x\n",
                data->client_window, changes.x, changes.y, changes.width, changes.height, mask );
         XConfigureWindow( data->display, data->client_window, mask, &changes );
+        resize_vk_surfaces( data->hwnd, data->client_window, mask, &changes );
     }
 }
 
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 45855976607..bad91f36830 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -594,6 +594,7 @@ extern void sync_gl_drawable( HWND hwnd, BOOL known_child );
 extern void set_gl_drawable_parent( HWND hwnd, HWND parent );
 extern void destroy_gl_drawable( HWND hwnd );
 extern void wine_vk_surface_destroy( HWND hwnd );
+extern void resize_vk_surfaces( HWND hwnd, Window active, int mask, XWindowChanges *changes );
 
 extern void wait_for_withdrawn_state( HWND hwnd, BOOL set );
 extern Window init_clip_window(void);
-- 
2.31.0

From 0880e8b4aa1d90a068e264e6dfa928be151a019f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 12 Mar 2021 18:07:04 +0100
Subject: [PATCH 03/10] winex11.drv: Check client_window pointer on surface
 destroy.

To prevent reusing already destroyed client_window with the thread
display requests.

This lets us restore another client window, as the primary client
window.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45277
---
 dlls/winex11.drv/vulkan.c | 31 +++++++++++++++++++++++++------
 dlls/winex11.drv/window.c | 17 +++++++++++++++++
 dlls/winex11.drv/x11drv.h |  1 +
 3 files changed, 43 insertions(+), 6 deletions(-)

diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index dd75a159ab1..780d689fe47 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -64,6 +64,7 @@ struct wine_vk_surface
     VkPresentModeKHR present_mode;
     BOOL offscreen; /* drawable is offscreen */
     HWND hwnd;
+    HDC dc;
 };
 
 typedef struct VkXlibSurfaceCreateInfoKHR
@@ -206,17 +208,32 @@ static struct wine_vk_surface *wine_vk_surface_grab(struct wine_vk_surface *surf
 
 static void wine_vk_surface_release(struct wine_vk_surface *surface)
 {
-    if (InterlockedDecrement(&surface->ref))
-        return;
+    struct wine_vk_surface *other = NULL;
+    struct list *surface_list, *entry;
+    HWND hwnd = surface->hwnd;
 
+    /* make sure other surface won't destroy itself until we've finished */
     EnterCriticalSection(&context_section);
-    list_remove(&surface->entry);
+    if (!XFindContext(gdi_display, (XID)hwnd, vulkan_hwnd_context, (char **)&surface_list) &&
+        ((entry = list_prev(surface_list, &surface->entry)) || (entry = list_next(surface_list, &surface->entry))))
+        other = wine_vk_surface_grab(LIST_ENTRY(entry, struct wine_vk_surface, entry));
     LeaveCriticalSection(&context_section);
 
-    if (surface->window)
-        XDestroyWindow(gdi_display, surface->window);
+    if (!InterlockedDecrement(&surface->ref))
+    {
+        ReleaseDC(hwnd, surface->dc);
+
+        EnterCriticalSection(&context_section);
+        list_remove(&surface->entry);
+        LeaveCriticalSection(&context_section);
+
+        if (surface->window)
+            destroy_client_window(hwnd, surface->window, other ? other->window : None);
+
+        heap_free(surface);
+    }
 
-    heap_free(surface);
+    if (other) wine_vk_surface_release(other);
 }
 
 void wine_vk_surface_destroy(HWND hwnd)
@@ -322,6 +339,7 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
     x11_surface->hwnd = create_info->hwnd;
     x11_surface->window = x11_surface->hwnd ? create_client_window(create_info->hwnd, &default_visual)
                                             : create_dummy_client_window();
+    x11_surface->dc = GetDC(create_info->hwnd);
     list_init(&x11_surface->entry);
 
     if (!x11_surface->window)
diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 0cc4c0617c4..84da3606d5b 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -1467,6 +1467,23 @@ static Window get_dummy_parent(void)
 }
 
 
+/**********************************************************************
+ *		destroy_client_window
+ */
+void destroy_client_window( HWND hwnd, Window old_window, Window new_window )
+{
+    struct x11drv_win_data *data;
+    if ((data = get_win_data( hwnd )))
+    {
+        if (data->client_window == old_window) data->client_window = new_window;
+        /* make sure any request that could use old_window has been flushed */
+        XFlush( data->display );
+        release_win_data( data );
+    }
+    XDestroyWindow( gdi_display, old_window );
+}
+
+
 /**********************************************************************
  *		create_client_window
  */
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index bad91f36830..0aedaa35f97 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -603,6 +603,7 @@ extern void read_net_wm_states( Display *display, struct x11drv_win_data *data )
 extern void update_net_wm_states( struct x11drv_win_data *data );
 extern void make_window_embedded( struct x11drv_win_data *data );
 extern Window create_client_window( HWND hwnd, const XVisualInfo *visual );
+extern void destroy_client_window( HWND hwnd, Window old_window, Window new_window );
 extern void set_window_visual( struct x11drv_win_data *data, const XVisualInfo *vis, BOOL use_alpha );
 extern void change_systray_owner( Display *display, Window systray_window );
 extern void update_systray_balloon_position(void);
-- 
2.31.0

From eee3a5e320cb1a7c8e16b837602e6fe76a987a80 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 22 Feb 2021 20:55:05 +0100
Subject: [PATCH 04/10] winex11.drv: Hook vkAcquireNextImage(2)KHR functions.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45277
---
 dlls/winemac.drv/vulkan.c    |  2 ++
 dlls/winevulkan/make_vulkan  |  2 ++
 dlls/winex11.drv/vulkan.c    | 19 +++++++++++++++++++
 include/wine/vulkan_driver.h |  6 ++++++
 4 files changed, 29 insertions(+)

diff --git a/dlls/winemac.drv/vulkan.c b/dlls/winemac.drv/vulkan.c
index 21ebcc56519..9046ac9d95f 100644
--- a/dlls/winemac.drv/vulkan.c
+++ b/dlls/winemac.drv/vulkan.c
@@ -569,6 +569,8 @@ static VkSurfaceKHR macdrv_wine_get_native_surface(VkSurfaceKHR surface)
 
 static const struct vulkan_funcs vulkan_funcs =
 {
+    NULL,
+    NULL,
     macdrv_vkCreateInstance,
     macdrv_vkCreateSwapchainKHR,
     macdrv_vkCreateWin32SurfaceKHR,
diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index 66b28bf13df..c49a75746ab 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -208,6 +208,8 @@ FUNCTION_OVERRIDES = {
     "vkDestroySwapchainKHR" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
     "vkGetSwapchainImagesKHR": {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
     "vkQueuePresentKHR": {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
+    "vkAcquireNextImageKHR" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
+    "vkAcquireNextImage2KHR" : {"dispatch" : True, "driver" : True, "thunk" : ThunkType.PUBLIC},
 
     # VK_KHR_external_fence_capabilities
     "vkGetPhysicalDeviceExternalFencePropertiesKHR" : {"dispatch" : False, "driver" : False, "thunk" : ThunkType.NONE},
diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index 780d689fe47..e269398d456 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -77,6 +77,7 @@ typedef struct VkXlibSurfaceCreateInfoKHR
     Window window;
 } VkXlibSurfaceCreateInfoKHR;
 
+static VkResult (*pvkAcquireNextImageKHR)(VkDevice, VkSwapchainKHR, uint64_t, VkSemaphore, VkFence, uint32_t *);
 static VkResult (*pvkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
 static VkResult (*pvkCreateSwapchainKHR)(VkDevice, const VkSwapchainCreateInfoKHR *, const VkAllocationCallbacks *, VkSwapchainKHR *);
 static VkResult (*pvkCreateXlibSurfaceKHR)(VkInstance, const VkXlibSurfaceCreateInfoKHR *, const VkAllocationCallbacks *, VkSurfaceKHR *);
@@ -118,6 +119,7 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
 
 #define LOAD_FUNCPTR(f) if (!(p##f = dlsym(vulkan_handle, #f))) goto fail
 #define LOAD_OPTIONAL_FUNCPTR(f) p##f = dlsym(vulkan_handle, #f)
+    LOAD_FUNCPTR(vkAcquireNextImageKHR);
     LOAD_FUNCPTR(vkCreateInstance);
     LOAD_FUNCPTR(vkCreateSwapchainKHR);
     LOAD_FUNCPTR(vkCreateXlibSurfaceKHR);
@@ -287,6 +289,21 @@ static VkResult X11DRV_vkCreateInstance(const VkInstanceCreateInfo *create_info,
     return res;
 }
 
+static VkResult X11DRV_vkAcquireNextImageKHR(VkDevice device,
+        VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore,
+        VkFence fence, uint32_t *image_index)
+{
+    return pvkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, image_index);
+}
+
+static VkResult X11DRV_vkAcquireNextImage2KHR(VkDevice device,
+        const VkAcquireNextImageInfoKHR *acquire_info, uint32_t *image_index)
+{
+    static int once;
+    if (!once++) FIXME("Emulating vkGetPhysicalDeviceSurfaceCapabilities2KHR with vkGetPhysicalDeviceSurfaceCapabilitiesKHR, pNext is ignored.\n");
+    return X11DRV_vkAcquireNextImageKHR(device, acquire_info->swapchain, acquire_info->timeout, acquire_info->semaphore, acquire_info->fence, image_index);
+}
+
 static VkResult X11DRV_vkCreateSwapchainKHR(VkDevice device,
         const VkSwapchainCreateInfoKHR *create_info,
         const VkAllocationCallbacks *allocator, VkSwapchainKHR *swapchain)
@@ -679,6 +696,8 @@ static VkSurfaceKHR X11DRV_wine_get_native_surface(VkSurfaceKHR surface)
 
 static const struct vulkan_funcs vulkan_funcs =
 {
+    X11DRV_vkAcquireNextImage2KHR,
+    X11DRV_vkAcquireNextImageKHR,
     X11DRV_vkCreateInstance,
     X11DRV_vkCreateSwapchainKHR,
     X11DRV_vkCreateWin32SurfaceKHR,
diff --git a/include/wine/vulkan_driver.h b/include/wine/vulkan_driver.h
index c2a2acfc282..c36724c80c3 100644
--- a/include/wine/vulkan_driver.h
+++ b/include/wine/vulkan_driver.h
@@ -21,6 +21,8 @@ struct vulkan_funcs
      * needs to provide. Other function calls will be provided indirectly by dispatch
      * tables part of dispatchable Vulkan objects such as VkInstance or vkDevice.
      */
+    VkResult (*p_vkAcquireNextImage2KHR)(VkDevice, const VkAcquireNextImageInfoKHR *, uint32_t *);
+    VkResult (*p_vkAcquireNextImageKHR)(VkDevice, VkSwapchainKHR, uint64_t, VkSemaphore, VkFence, uint32_t *);
     VkResult (*p_vkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
     VkResult (*p_vkCreateSwapchainKHR)(VkDevice, const VkSwapchainCreateInfoKHR *, const VkAllocationCallbacks *, VkSwapchainKHR *);
     VkResult (*p_vkCreateWin32SurfaceKHR)(VkInstance, const VkWin32SurfaceCreateInfoKHR *, const VkAllocationCallbacks *, VkSurfaceKHR *);
@@ -55,6 +57,10 @@ static inline void *get_vulkan_driver_device_proc_addr(
 
     name += 2;
 
+    if (!strcmp(name, "AcquireNextImage2KHR"))
+        return vulkan_funcs->p_vkAcquireNextImage2KHR;
+    if (!strcmp(name, "AcquireNextImageKHR"))
+        return vulkan_funcs->p_vkAcquireNextImageKHR;
     if (!strcmp(name, "CreateSwapchainKHR"))
         return vulkan_funcs->p_vkCreateSwapchainKHR;
     if (!strcmp(name, "DestroySwapchainKHR"))
-- 
2.31.0

From cce417367b62ce4f04b34813e478fd732f72418c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 12 Mar 2021 18:33:06 +0100
Subject: [PATCH 05/10] winex11.drv: Rename X11DRV_FLUSH_GL_DRAWABLE to
 X11DRV_PRESENT_DRAWABLE.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45277
---
 dlls/winex11.drv/init.c   |  8 ++++----
 dlls/winex11.drv/opengl.c | 40 +++++++++++++++++++--------------------
 dlls/winex11.drv/x11drv.h |  8 ++++----
 3 files changed, 28 insertions(+), 28 deletions(-)

diff --git a/dlls/winex11.drv/init.c b/dlls/winex11.drv/init.c
index d070c0f1171..88ef1e3e2f8 100644
--- a/dlls/winex11.drv/init.c
+++ b/dlls/winex11.drv/init.c
@@ -232,16 +232,16 @@ static INT CDECL X11DRV_ExtEscape( PHYSDEV dev, INT escape, INT in_count, LPCVOI
                     return TRUE;
                 }
                 break;
-            case X11DRV_FLUSH_GL_DRAWABLE:
-                if (in_count >= sizeof(struct x11drv_escape_flush_gl_drawable))
+            case X11DRV_PRESENT_DRAWABLE:
+                if (in_count >= sizeof(struct x11drv_escape_present_drawable))
                 {
-                    const struct x11drv_escape_flush_gl_drawable *data = in_data;
+                    const struct x11drv_escape_present_drawable *data = in_data;
                     RECT rect = physDev->dc_rect;
 
                     OffsetRect( &rect, -physDev->dc_rect.left, -physDev->dc_rect.top );
                     if (data->flush) XFlush( gdi_display );
                     XSetFunction( gdi_display, physDev->gc, GXcopy );
-                    XCopyArea( gdi_display, data->gl_drawable, physDev->drawable, physDev->gc,
+                    XCopyArea( gdi_display, data->drawable, physDev->drawable, physDev->gc,
                                0, 0, rect.right, rect.bottom,
                                physDev->dc_rect.left, physDev->dc_rect.top );
                     add_device_bounds( physDev, &rect );
diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index fd39b58bb3b..17fcb7b32a3 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -1945,20 +1945,20 @@ static BOOL WINAPI glxdrv_wglShareLists(struct wgl_context *org, struct wgl_cont
 
 static void wglFinish(void)
 {
-    struct x11drv_escape_flush_gl_drawable escape;
+    struct x11drv_escape_present_drawable escape;
     struct gl_drawable *gl;
     struct wgl_context *ctx = NtCurrentTeb()->glContext;
 
-    escape.code = X11DRV_FLUSH_GL_DRAWABLE;
-    escape.gl_drawable = 0;
+    escape.code = X11DRV_PRESENT_DRAWABLE;
+    escape.drawable = 0;
     escape.flush = FALSE;
 
     if ((gl = get_gl_drawable( WindowFromDC( ctx->hdc ), 0 )))
     {
         switch (gl->type)
         {
-        case DC_GL_PIXMAP_WIN: escape.gl_drawable = gl->pixmap; break;
-        case DC_GL_CHILD_WIN:  escape.gl_drawable = gl->window; break;
+        case DC_GL_PIXMAP_WIN: escape.drawable = gl->pixmap; break;
+        case DC_GL_CHILD_WIN:  escape.drawable = gl->window; break;
         default: break;
         }
         sync_context(ctx);
@@ -1966,25 +1966,25 @@ static void wglFinish(void)
     }
 
     pglFinish();
-    if (escape.gl_drawable) ExtEscape( ctx->hdc, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
+    if (escape.drawable) ExtEscape( ctx->hdc, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
 }
 
 static void wglFlush(void)
 {
-    struct x11drv_escape_flush_gl_drawable escape;
+    struct x11drv_escape_present_drawable escape;
     struct gl_drawable *gl;
     struct wgl_context *ctx = NtCurrentTeb()->glContext;
 
-    escape.code = X11DRV_FLUSH_GL_DRAWABLE;
-    escape.gl_drawable = 0;
+    escape.code = X11DRV_PRESENT_DRAWABLE;
+    escape.drawable = 0;
     escape.flush = FALSE;
 
     if ((gl = get_gl_drawable( WindowFromDC( ctx->hdc ), 0 )))
     {
         switch (gl->type)
         {
-        case DC_GL_PIXMAP_WIN: escape.gl_drawable = gl->pixmap; break;
-        case DC_GL_CHILD_WIN:  escape.gl_drawable = gl->window; break;
+        case DC_GL_PIXMAP_WIN: escape.drawable = gl->pixmap; break;
+        case DC_GL_CHILD_WIN:  escape.drawable = gl->window; break;
         default: break;
         }
         sync_context(ctx);
@@ -1992,7 +1992,7 @@ static void wglFlush(void)
     }
 
     pglFlush();
-    if (escape.gl_drawable) ExtEscape( ctx->hdc, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
+    if (escape.drawable) ExtEscape( ctx->hdc, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
 }
 
 static const GLubyte *wglGetString(GLenum name)
@@ -3307,15 +3307,15 @@ static void X11DRV_WineGL_LoadExtensions(void)
  */
 static BOOL WINAPI glxdrv_wglSwapBuffers( HDC hdc )
 {
-    struct x11drv_escape_flush_gl_drawable escape;
+    struct x11drv_escape_present_drawable escape;
     struct gl_drawable *gl;
     struct wgl_context *ctx = NtCurrentTeb()->glContext;
     INT64 ust, msc, sbc, target_sbc = 0;
 
     TRACE("(%p)\n", hdc);
 
-    escape.code = X11DRV_FLUSH_GL_DRAWABLE;
-    escape.gl_drawable = 0;
+    escape.code = X11DRV_PRESENT_DRAWABLE;
+    escape.drawable = 0;
     escape.flush = !pglXWaitForSbcOML;
 
     if (!(gl = get_gl_drawable( WindowFromDC( hdc ), hdc )))
@@ -3336,7 +3336,7 @@ static BOOL WINAPI glxdrv_wglSwapBuffers( HDC hdc )
     {
     case DC_GL_PIXMAP_WIN:
         if (ctx) sync_context( ctx );
-        escape.gl_drawable = gl->pixmap;
+        escape.drawable = gl->pixmap;
         if (pglXCopySubBufferMESA) {
             /* (glX)SwapBuffers has an implicit glFlush effect, however
              * GLX_MESA_copy_sub_buffer doesn't. Make sure GL is flushed before
@@ -3357,10 +3357,10 @@ static BOOL WINAPI glxdrv_wglSwapBuffers( HDC hdc )
     case DC_GL_WINDOW:
     case DC_GL_CHILD_WIN:
         if (ctx) sync_context( ctx );
-        if (gl->type == DC_GL_CHILD_WIN) escape.gl_drawable = gl->window;
+        if (gl->type == DC_GL_CHILD_WIN) escape.drawable = gl->window;
         /* fall through */
     default:
-        if (escape.gl_drawable && pglXSwapBuffersMscOML)
+        if (escape.drawable && pglXSwapBuffersMscOML)
         {
             pglFlush();
             target_sbc = pglXSwapBuffersMscOML( gdi_display, gl->drawable, 0, 0, 0 );
@@ -3370,12 +3370,12 @@ static BOOL WINAPI glxdrv_wglSwapBuffers( HDC hdc )
         break;
     }
 
-    if (escape.gl_drawable && pglXWaitForSbcOML)
+    if (escape.drawable && pglXWaitForSbcOML)
         pglXWaitForSbcOML( gdi_display, gl->drawable, target_sbc, &ust, &msc, &sbc );
 
     release_gl_drawable( gl );
 
-    if (escape.gl_drawable) ExtEscape( ctx->hdc, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
+    if (escape.drawable) ExtEscape( ctx->hdc, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
     return TRUE;
 }
 
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 0aedaa35f97..1830e58a38e 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -286,7 +286,7 @@ enum x11drv_escape_codes
     X11DRV_GET_DRAWABLE,     /* get current drawable for a DC */
     X11DRV_START_EXPOSURES,  /* start graphics exposures */
     X11DRV_END_EXPOSURES,    /* end graphics exposures */
-    X11DRV_FLUSH_GL_DRAWABLE /* flush changes made to the gl drawable */
+    X11DRV_PRESENT_DRAWABLE, /* present the drawable on screen */
 };
 
 struct x11drv_escape_set_drawable
@@ -305,10 +305,10 @@ struct x11drv_escape_get_drawable
     int                      pixel_format; /* internal GL pixel format */
 };
 
-struct x11drv_escape_flush_gl_drawable
+struct x11drv_escape_present_drawable
 {
-    enum x11drv_escape_codes code;         /* escape code (X11DRV_FLUSH_GL_DRAWABLE) */
-    Drawable                 gl_drawable;  /* GL drawable */
+    enum x11drv_escape_codes code;         /* escape code (X11DRV_PRESENT_DRAWABLE) */
+    Drawable                 drawable;     /* GL / VK drawable */
     BOOL                     flush;        /* flush X11 before copying */
 };
 
-- 
2.31.0

From d330ac15847e91ecda488f784b156465c5087aad Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 12 Mar 2021 18:18:44 +0100
Subject: [PATCH 06/10] winex11.drv: Support child window vulkan rendering.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Based on a patch from Felix HÃ¤dicke <felixhaedicke@web.de>.
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45277
---
 dlls/winex11.drv/vulkan.c | 77 +++++++++++++++++++++++++++++++++++----
 dlls/winex11.drv/window.c | 15 ++++++++
 dlls/winex11.drv/x11drv.h |  1 +
 3 files changed, 85 insertions(+), 8 deletions(-)

diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index e269398d456..96b657f93c2 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -32,6 +32,7 @@
 #include "wine/debug.h"
 #include "wine/heap.h"
 #include "x11drv.h"
+#include "xcomposite.h"
 
 #define VK_NO_PROTOTYPES
 #define WINE_VK_HOST
@@ -64,6 +65,7 @@ struct wine_vk_surface
     LONG ref;
     Window window;
     VkSurfaceKHR surface; /* native surface */
+    BOOL offscreen; /* drawable is offscreen */
     HWND hwnd;
     HDC dc;
 };
@@ -249,6 +251,31 @@ void wine_vk_surface_destroy(HWND hwnd)
     heap_free(surface_list);
 }
 
+static BOOL wine_vk_surface_set_offscreen(struct wine_vk_surface *surface, BOOL offscreen)
+{
+#ifdef SONAME_LIBXCOMPOSITE
+    if (usexcomposite)
+    {
+        if (!surface->offscreen && offscreen)
+        {
+            FIXME("Redirecting vulkan surface offscreen, expect degraded performance.\n");
+            pXCompositeRedirectWindow(gdi_display, surface->window, CompositeRedirectManual);
+        }
+        else if (surface->offscreen && !offscreen)
+        {
+            FIXME("Putting vulkan surface back onscreen, expect standard performance.\n");
+            pXCompositeUnredirectWindow(gdi_display, surface->window, CompositeRedirectManual);
+        }
+        surface->offscreen = offscreen;
+        return TRUE;
+    }
+#endif
+
+    if (offscreen) FIXME("Application requires child window rendering, which is not implemented yet!\n");
+    surface->offscreen = offscreen;
+    return !offscreen;
+}
+
 void resize_vk_surfaces(HWND hwnd, Window active, int mask, XWindowChanges *changes)
 {
     struct wine_vk_surface *surface;
@@ -262,6 +289,17 @@ void resize_vk_surfaces(HWND hwnd, Window active, int mask, XWindowChanges *chan
     LeaveCriticalSection(&context_section);
 }
 
+void sync_vk_surface(HWND hwnd, BOOL known_child)
+{
+    struct wine_vk_surface *surface;
+    struct list *surface_list;
+    EnterCriticalSection(&context_section);
+    if (!XFindContext(gdi_display, (XID)hwnd, vulkan_hwnd_context, (char **)&surface_list))
+        LIST_FOR_EACH_ENTRY(surface, surface_list, struct wine_vk_surface, entry)
+            wine_vk_surface_set_offscreen(surface, known_child);
+    LeaveCriticalSection(&context_section);
+}
+
 static VkResult X11DRV_vkCreateInstance(const VkInstanceCreateInfo *create_info,
         const VkAllocationCallbacks *allocator, VkInstance *instance)
 {
@@ -293,7 +331,24 @@ static VkResult X11DRV_vkAcquireNextImageKHR(VkDevice device,
         VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore,
         VkFence fence, uint32_t *image_index)
 {
-    return pvkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, image_index);
+    struct x11drv_escape_present_drawable escape;
+    struct wine_vk_surface *surface;
+    VkResult result;
+
+    EnterCriticalSection(&context_section);
+    if (XFindContext(gdi_display, (XID)swapchain, vulkan_swapchain_context, (char **)&surface)) surface = NULL;
+    LeaveCriticalSection(&context_section);
+
+    result = pvkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, image_index);
+    if (result == VK_SUCCESS && surface && surface->offscreen)
+    {
+        escape.code = X11DRV_PRESENT_DRAWABLE;
+        escape.drawable = surface->window;
+        escape.flush = TRUE;
+        ExtEscape(surface->dc, X11DRV_ESCAPE, sizeof(escape), (char *)&escape, 0, NULL);
+    }
+
+    return result;
 }
 
 static VkResult X11DRV_vkAcquireNextImage2KHR(VkDevice device,
@@ -344,13 +399,6 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
     if (allocator)
         FIXME("Support for allocation callbacks not implemented yet\n");
 
-    /* TODO: support child window rendering. */
-    if (create_info->hwnd && GetAncestor(create_info->hwnd, GA_PARENT) != GetDesktopWindow())
-    {
-        FIXME("Application requires child window rendering, which is not implemented yet!\n");
-        return VK_ERROR_INCOMPATIBLE_DRIVER;
-    }
-
     x11_surface = heap_alloc_zero(sizeof(*x11_surface));
     if (!x11_surface)
         return VK_ERROR_OUT_OF_HOST_MEMORY;
@@ -370,6 +418,15 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
         goto err;
     }
 
+    if (GetWindow( create_info->hwnd, GW_CHILD ) || GetAncestor( create_info->hwnd, GA_PARENT ) != GetDesktopWindow())
+    {
+        if (!wine_vk_surface_set_offscreen(x11_surface, TRUE))
+        {
+            res = VK_ERROR_INCOMPATIBLE_DRIVER;
+            goto err;
+        }
+    }
+
     create_info_host.sType = VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR;
     create_info_host.pNext = NULL;
     create_info_host.flags = 0; /* reserved */
@@ -765,4 +822,8 @@ void resize_vk_surfaces(HWND hwnd, Window active, int mask, XWindowChanges chang
 {
 }
 
+void sync_vk_surface(HWND hwnd, BOOL known_child)
+{
+}
+
 #endif /* SONAME_LIBVULKAN */
diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 84da3606d5b..f1c7f8ec388 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -1727,6 +1727,15 @@ void CDECL X11DRV_SetWindowStyle( HWND hwnd, INT offset, STYLESTRUCT *style )
 {
     struct x11drv_win_data *data;
     DWORD changed = style->styleNew ^ style->styleOld;
+    HWND parent = GetAncestor( hwnd, GA_PARENT );
+
+    if (offset == GWL_STYLE && (changed & WS_CHILD))
+    {
+        if (GetWindow( parent, GW_CHILD ) || GetAncestor( parent, GA_PARENT ) != GetDesktopWindow())
+            sync_vk_surface( parent, TRUE );
+        else
+            sync_vk_surface( parent, FALSE );
+    }
 
     if (hwnd == GetDesktopWindow()) return;
     if (!(data = get_win_data( hwnd ))) return;
@@ -1753,6 +1762,10 @@ void CDECL X11DRV_DestroyWindow( HWND hwnd )
 {
     struct x11drv_thread_data *thread_data = x11drv_thread_data();
     struct x11drv_win_data *data;
+    HWND parent = GetAncestor( hwnd, GA_PARENT );
+
+    if (!GetWindow( parent, GW_CHILD ) && GetAncestor( parent, GA_PARENT ) == GetDesktopWindow())
+        sync_vk_surface( parent, FALSE );
 
     if (!(data = get_win_data( hwnd ))) return;
 
@@ -1958,6 +1971,7 @@ static struct x11drv_win_data *X11DRV_create_win_data( HWND hwnd, const RECT *wi
      * that will need clipping support.
      */
     sync_gl_drawable( parent, TRUE );
+    sync_vk_surface( parent, TRUE );
 
     display = thread_init_display();
     init_clip_window();  /* make sure the clip window is initialized in this thread */
@@ -2296,6 +2310,7 @@ done:
      * that will need clipping support.
      */
     sync_gl_drawable( parent, TRUE );
+    sync_vk_surface( parent, TRUE );
 
     fetch_icon_data( hwnd, 0, 0 );
 }
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 1830e58a38e..166d50c20ad 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -595,6 +595,7 @@ extern void set_gl_drawable_parent( HWND hwnd, HWND parent );
 extern void destroy_gl_drawable( HWND hwnd );
 extern void wine_vk_surface_destroy( HWND hwnd );
 extern void resize_vk_surfaces( HWND hwnd, Window active, int mask, XWindowChanges *changes );
+extern void sync_vk_surface( HWND hwnd, BOOL known_child );
 
 extern void wait_for_withdrawn_state( HWND hwnd, BOOL set );
 extern Window init_clip_window(void);
-- 
2.31.0

From 2841e0a5b2025d9a13fbf8c1579cf393ff5f1b39 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 11 Mar 2021 23:30:04 +0100
Subject: [PATCH 07/10] winex11.drv: Wait on vkAcquireNextImageKHR before
 flushing.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

To prevent tearing, when present mode is mailbox or fifo.

Based on a patch from Felix HÃ¤dicke <felixhaedicke@web.de>.
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45277
---
 dlls/winex11.drv/vulkan.c | 35 +++++++++++++++++++++++++++++++++++
 1 file changed, 35 insertions(+)

diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index 96b657f93c2..fd0e47233fd 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -65,6 +65,7 @@ struct wine_vk_surface
     LONG ref;
     Window window;
     VkSurfaceKHR surface; /* native surface */
+    VkPresentModeKHR present_mode;
     BOOL offscreen; /* drawable is offscreen */
     HWND hwnd;
     HDC dc;
@@ -100,6 +101,9 @@ static VkResult (*pvkGetPhysicalDeviceSurfaceSupportKHR)(VkPhysicalDevice, uint3
 static VkBool32 (*pvkGetPhysicalDeviceXlibPresentationSupportKHR)(VkPhysicalDevice, uint32_t, Display *, VisualID);
 static VkResult (*pvkGetSwapchainImagesKHR)(VkDevice, VkSwapchainKHR, uint32_t *, VkImage *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
+static VkResult (*pvkWaitForFences)(VkDevice device, uint32_t fenceCount, const VkFence *pFences, VkBool32 waitAll, uint64_t timeout);
+static VkResult (*pvkCreateFence)(VkDevice device, const VkFenceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence);
+static void (*pvkDestroyFence)(VkDevice device, VkFence fence, const VkAllocationCallbacks *pAllocator);
 
 static void *X11DRV_get_vk_device_proc_addr(const char *name);
 static void *X11DRV_get_vk_instance_proc_addr(VkInstance instance, const char *name);
@@ -142,6 +146,9 @@ static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
     LOAD_FUNCPTR(vkQueuePresentKHR);
     LOAD_OPTIONAL_FUNCPTR(vkGetDeviceGroupSurfacePresentModesKHR);
     LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDevicePresentRectanglesKHR);
+    LOAD_FUNCPTR(vkWaitForFences);
+    LOAD_FUNCPTR(vkCreateFence);
+    LOAD_FUNCPTR(vkDestroyFence);
 #undef LOAD_FUNCPTR
 #undef LOAD_OPTIONAL_FUNCPTR
 
@@ -331,23 +338,46 @@ static VkResult X11DRV_vkAcquireNextImageKHR(VkDevice device,
         VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore,
         VkFence fence, uint32_t *image_index)
 {
+    static int once;
     struct x11drv_escape_present_drawable escape;
     struct wine_vk_surface *surface;
     VkResult result;
+    VkFence orig_fence;
+    BOOL wait_fence = FALSE;
 
     EnterCriticalSection(&context_section);
     if (XFindContext(gdi_display, (XID)swapchain, vulkan_swapchain_context, (char **)&surface)) surface = NULL;
     LeaveCriticalSection(&context_section);
 
+    if (!surface || !surface->offscreen)
+        wait_fence = FALSE;
+    else if (surface->present_mode == VK_PRESENT_MODE_MAILBOX_KHR ||
+             surface->present_mode == VK_PRESENT_MODE_FIFO_KHR)
+        wait_fence = TRUE;
+
+    orig_fence = fence;
+    if (wait_fence && !fence)
+    {
+        VkFenceCreateInfo create_info;
+        create_info.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
+        create_info.pNext = NULL;
+        create_info.flags = 0;
+        pvkCreateFence(device, &create_info, NULL, &fence);
+    }
+
     result = pvkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, image_index);
     if (result == VK_SUCCESS && surface && surface->offscreen)
     {
+        if (wait_fence) pvkWaitForFences(device, 1, &fence, 0, timeout);
         escape.code = X11DRV_PRESENT_DRAWABLE;
         escape.drawable = surface->window;
         escape.flush = TRUE;
         ExtEscape(surface->dc, X11DRV_ESCAPE, sizeof(escape), (char *)&escape, 0, NULL);
+        if (surface->present_mode == VK_PRESENT_MODE_MAILBOX_KHR)
+            if (once++) FIXME("Application requires child window rendering with mailbox present mode, expect possible tearing!\n");
     }
 
+    if (fence != orig_fence) pvkDestroyFence(device, fence, NULL);
     return result;
 }
 
@@ -375,6 +405,11 @@ static VkResult X11DRV_vkCreateSwapchainKHR(VkDevice device,
     create_info_host = *create_info;
     create_info_host.surface = x11_surface->surface;
 
+    /* force fifo when running offscreen so the acquire fence is more likely to be vsynced */
+    if (x11_surface->offscreen && create_info->presentMode == VK_PRESENT_MODE_MAILBOX_KHR)
+        create_info_host.presentMode = VK_PRESENT_MODE_FIFO_KHR;
+    x11_surface->present_mode = create_info->presentMode;
+
     result = pvkCreateSwapchainKHR(device, &create_info_host, NULL /* allocator */, swapchain);
     if (result == VK_SUCCESS)
     {
-- 
2.31.0

From 4e89def87b7c3a6f75e6853efb8e8698c381deea Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 11 Mar 2021 23:27:57 +0100
Subject: [PATCH 08/10] winex11.drv: Remove unused X11DRV_GET_DRAWABLE
 ExtEscape code.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45277
---
 dlls/winex11.drv/init.c   | 8 --------
 dlls/winex11.drv/x11drv.h | 9 ---------
 2 files changed, 17 deletions(-)

diff --git a/dlls/winex11.drv/init.c b/dlls/winex11.drv/init.c
index 88ef1e3e2f8..cdb3dd931e9 100644
--- a/dlls/winex11.drv/init.c
+++ b/dlls/winex11.drv/init.c
@@ -224,14 +224,6 @@ static INT CDECL X11DRV_ExtEscape( PHYSDEV dev, INT escape, INT in_count, LPCVOI
                     return TRUE;
                 }
                 break;
-            case X11DRV_GET_DRAWABLE:
-                if (out_count >= sizeof(struct x11drv_escape_get_drawable))
-                {
-                    struct x11drv_escape_get_drawable *data = out_data;
-                    data->drawable = physDev->drawable;
-                    return TRUE;
-                }
-                break;
             case X11DRV_PRESENT_DRAWABLE:
                 if (in_count >= sizeof(struct x11drv_escape_present_drawable))
                 {
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 166d50c20ad..565b0dedbb1 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -283,7 +283,6 @@ extern int *get_window_surface_mapping( int bpp, int *mapping );
 enum x11drv_escape_codes
 {
     X11DRV_SET_DRAWABLE,     /* set current drawable for a DC */
-    X11DRV_GET_DRAWABLE,     /* get current drawable for a DC */
     X11DRV_START_EXPOSURES,  /* start graphics exposures */
     X11DRV_END_EXPOSURES,    /* end graphics exposures */
     X11DRV_PRESENT_DRAWABLE, /* present the drawable on screen */
@@ -297,14 +296,6 @@ struct x11drv_escape_set_drawable
     RECT                     dc_rect;      /* DC rectangle relative to drawable */
 };
 
-struct x11drv_escape_get_drawable
-{
-    enum x11drv_escape_codes code;         /* escape code (X11DRV_GET_DRAWABLE) */
-    Drawable                 drawable;     /* X drawable */
-    Drawable                 gl_drawable;  /* GL drawable */
-    int                      pixel_format; /* internal GL pixel format */
-};
-
 struct x11drv_escape_present_drawable
 {
     enum x11drv_escape_codes code;         /* escape code (X11DRV_PRESENT_DRAWABLE) */
-- 
2.31.0

From f693181afe52898711b3edce27793f8268bd4e8e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 12 Mar 2021 00:10:49 +0100
Subject: [PATCH 09/10] winex11.drv: Move Xfixes extension query to
 process_attach.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45277
---
 dlls/winex11.drv/clipboard.c   | 26 ++------------
 dlls/winex11.drv/x11drv.h      |  2 ++
 dlls/winex11.drv/x11drv_main.c | 63 ++++++++++++++++++++++++++++++++++
 dlls/winex11.drv/xfixes.h      | 36 +++++++++++++++++++
 4 files changed, 103 insertions(+), 24 deletions(-)
 create mode 100644 dlls/winex11.drv/xfixes.h

diff --git a/dlls/winex11.drv/clipboard.c b/dlls/winex11.drv/clipboard.c
index b511af3f691..1f6508df034 100644
--- a/dlls/winex11.drv/clipboard.c
+++ b/dlls/winex11.drv/clipboard.c
@@ -79,6 +79,7 @@
 #include <assert.h>
 
 #include "x11drv.h"
+#include "xfixes.h"
 
 #ifdef HAVE_X11_EXTENSIONS_XFIXES_H
 #include <X11/extensions/Xfixes.h>
@@ -198,7 +199,6 @@ static UINT rendered_formats;
 static ULONG64 last_clipboard_update;
 static struct clipboard_format **current_x11_formats;
 static unsigned int nb_current_x11_formats;
-static BOOL use_xfixes;
 
 Display *clipboard_display = NULL;
 
@@ -1977,28 +1977,6 @@ static BOOL selection_notify_event( HWND hwnd, XEvent *event )
 static void xfixes_init(void)
 {
 #ifdef SONAME_LIBXFIXES
-    typeof(XFixesSelectSelectionInput) *pXFixesSelectSelectionInput;
-    typeof(XFixesQueryExtension) *pXFixesQueryExtension;
-    typeof(XFixesQueryVersion) *pXFixesQueryVersion;
-
-    int event_base, error_base;
-    int major = 3, minor = 0;
-    void *handle;
-
-    handle = dlopen(SONAME_LIBXFIXES, RTLD_NOW);
-    if (!handle) return;
-
-    pXFixesQueryExtension = dlsym(handle, "XFixesQueryExtension");
-    if (!pXFixesQueryExtension) return;
-    pXFixesQueryVersion = dlsym(handle, "XFixesQueryVersion");
-    if (!pXFixesQueryVersion) return;
-    pXFixesSelectSelectionInput = dlsym(handle, "XFixesSelectSelectionInput");
-    if (!pXFixesSelectSelectionInput) return;
-
-    if (!pXFixesQueryExtension(clipboard_display, &event_base, &error_base))
-        return;
-    pXFixesQueryVersion(clipboard_display, &major, &minor);
-    use_xfixes = (major >= 1);
     if (!use_xfixes) return;
 
     pXFixesSelectSelectionInput(clipboard_display, import_window, x11drv_atom(CLIPBOARD),
@@ -2012,7 +1990,7 @@ static void xfixes_init(void)
                 XFixesSelectionWindowDestroyNotifyMask |
                 XFixesSelectionClientCloseNotifyMask);
     }
-    X11DRV_register_event_handler(event_base + XFixesSelectionNotify,
+    X11DRV_register_event_handler(xfixes_event_base + XFixesSelectionNotify,
             selection_notify_event, "XFixesSelectionNotify");
     TRACE("xfixes succesully initialized\n");
 #else
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 565b0dedbb1..73926b23ab4 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -389,6 +389,7 @@ extern BOOL show_systray;
 extern BOOL grab_pointer;
 extern BOOL grab_fullscreen;
 extern BOOL usexcomposite;
+extern BOOL use_xfixes;
 extern BOOL managed_mode;
 extern BOOL decorated_mode;
 extern BOOL private_color_map;
@@ -396,6 +397,7 @@ extern int primary_monitor;
 extern int copy_default_colors;
 extern int alloc_system_colors;
 extern int xrender_error_base;
+extern int xfixes_event_base;
 extern HMODULE x11drv_module;
 extern char *process_name;
 extern Display *clipboard_display;
diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index 9ec4c7a98f6..824237534d6 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -50,6 +50,7 @@
 
 #include "x11drv.h"
 #include "xcomposite.h"
+#include "xfixes.h"
 #include "wine/server.h"
 #include "wine/unicode.h"
 #include "wine/debug.h"
@@ -69,6 +70,7 @@ Window root_window;
 BOOL usexvidmode = TRUE;
 BOOL usexrandr = TRUE;
 BOOL usexcomposite = TRUE;
+BOOL use_xfixes = FALSE;
 BOOL use_xkb = TRUE;
 BOOL use_take_focus = TRUE;
 BOOL use_primary_selection = FALSE;
@@ -87,6 +89,7 @@ int copy_default_colors = 128;
 int alloc_system_colors = 256;
 DWORD thread_data_tls_index = TLS_OUT_OF_INDEXES;
 int xrender_error_base = 0;
+int xfixes_event_base = 0;
 HMODULE x11drv_module = 0;
 char *process_name = NULL;
 
@@ -501,6 +504,63 @@ sym_not_found:
 }
 #endif /* defined(SONAME_LIBXCOMPOSITE) */
 
+#ifdef SONAME_LIBXFIXES
+
+#define MAKE_FUNCPTR(f) typeof(f) * p##f;
+MAKE_FUNCPTR(XFixesQueryExtension)
+MAKE_FUNCPTR(XFixesQueryVersion)
+MAKE_FUNCPTR(XFixesCreateRegion)
+MAKE_FUNCPTR(XFixesCreateRegionFromGC)
+MAKE_FUNCPTR(XFixesSelectSelectionInput)
+#undef MAKE_FUNCPTR
+
+static void x11drv_load_xfixes(void)
+{
+    int event, error, major = 3, minor = 0;
+    void *xfixes;
+
+    if (!(xfixes = dlopen(SONAME_LIBXFIXES, RTLD_NOW)))
+    {
+        WARN("Xfixes library %s not found, disabled.\n", SONAME_LIBXFIXES);
+        return;
+    }
+
+#define LOAD_FUNCPTR(f) \
+    if (!(p##f = dlsym(xfixes, #f)))                          \
+    {                                                         \
+        WARN("Xfixes function %s not found, disabled\n", #f); \
+        dlclose(xfixes);                                      \
+        return;                                               \
+    }
+    LOAD_FUNCPTR(XFixesQueryExtension)
+    LOAD_FUNCPTR(XFixesQueryVersion)
+    LOAD_FUNCPTR(XFixesCreateRegion)
+    LOAD_FUNCPTR(XFixesCreateRegionFromGC)
+    LOAD_FUNCPTR(XFixesSelectSelectionInput)
+#undef LOAD_FUNCPTR
+
+    if (!pXFixesQueryExtension(gdi_display, &event, &error))
+    {
+        WARN("Xfixes extension not found, disabled.\n");
+        dlclose(xfixes);
+        return;
+    }
+
+    if (!pXFixesQueryVersion(gdi_display, &major, &minor) ||
+        major < 2)
+    {
+        WARN("Xfixes version 2.0 not found, disabled.\n");
+        dlclose(xfixes);
+        return;
+    }
+
+    TRACE("Xfixes, error %d, event %d, version %d.%d found\n",
+          error, event, major, minor);
+    use_xfixes = TRUE;
+    xfixes_event_base = event;
+}
+#endif /* SONAME_LIBXFIXES */
+
 static void init_visuals( Display *display, int screen )
 {
     int count;
@@ -607,6 +667,9 @@ static BOOL process_attach(void)
     X11DRV_XF86VM_Init();
     /* initialize XRandR */
     X11DRV_XRandR_Init();
+#ifdef SONAME_LIBXFIXES
+    x11drv_load_xfixes();
+#endif
 #ifdef SONAME_LIBXCOMPOSITE
     X11DRV_XComposite_Init();
 #endif
diff --git a/dlls/winex11.drv/xfixes.h b/dlls/winex11.drv/xfixes.h
new file mode 100644
index 00000000000..3ab31201d3d
--- /dev/null
+++ b/dlls/winex11.drv/xfixes.h
@@ -0,0 +1,36 @@
+/*
+ * Wine X11DRV Xfixes interface
+ *
+ * Copyright 2021 RÃ©mi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+#ifndef __WINE_XFIXES_H
+#define __WINE_XFIXES_H
+
+#ifndef __WINE_CONFIG_H
+# error You must include config.h to use this header
+#endif
+
+#ifdef SONAME_LIBXFIXES
+#include <X11/extensions/Xfixes.h>
+#define MAKE_FUNCPTR(f) extern typeof(f) * p##f;
+MAKE_FUNCPTR(XFixesQueryExtension)
+MAKE_FUNCPTR(XFixesQueryVersion)
+MAKE_FUNCPTR(XFixesSelectSelectionInput)
+#undef MAKE_FUNCPTR
+#endif /* defined(SONAME_LIBXFIXES) */
+
+#endif /* __WINE_XFIXES_H */
-- 
2.31.0

From 96a752ca89816d150c3d0bfb5a417df180ed94d4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 11 Mar 2021 23:38:35 +0100
Subject: [PATCH 10/10] winex11.drv: Use XPresentPixmap instead of XCopyArea
 when available.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45277
---
 configure.ac                   | 13 ++++++++
 dlls/winex11.drv/init.c        | 34 +++++++++++++++++---
 dlls/winex11.drv/vulkan.c      |  9 ++++--
 dlls/winex11.drv/x11drv.h      |  1 +
 dlls/winex11.drv/x11drv_main.c | 58 ++++++++++++++++++++++++++++++++++
 dlls/winex11.drv/xfixes.h      |  3 ++
 dlls/winex11.drv/xpresent.h    | 36 +++++++++++++++++++++
 7 files changed, 147 insertions(+), 7 deletions(-)
 create mode 100644 dlls/winex11.drv/xpresent.h

diff --git a/configure.ac b/configure.ac
index 797f8cfbbbf..91662103ca5 100644
--- a/configure.ac
+++ b/configure.ac
@@ -102,6 +102,8 @@ AC_ARG_WITH(xinput,    AS_HELP_STRING([--without-xinput],[do not use the Xinput
             [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_XInput_h=no; fi])
 AC_ARG_WITH(xinput2,   AS_HELP_STRING([--without-xinput2],[do not use the Xinput 2 extension]),
             [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_XInput2_h=no; fi])
+AC_ARG_WITH(xpresent,  AS_HELP_STRING([--without-xpresent],[do not use the Xpresent extension]),
+            [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_Xpresent_h=no; fi])
 AC_ARG_WITH(xrandr,    AS_HELP_STRING([--without-xrandr],[do not use Xrandr (multi-monitor support)]),
             [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_Xrandr_h=no; fi])
 AC_ARG_WITH(xrender,   AS_HELP_STRING([--without-xrender],[do not use the Xrender extension]),
@@ -1138,6 +1140,7 @@ then
                       X11/extensions/Xcomposite.h \
                       X11/extensions/Xfixes.h \
                       X11/extensions/Xinerama.h \
+                      X11/extensions/Xpresent.h \
                       X11/extensions/Xrandr.h \
                       X11/extensions/Xrender.h \
                       X11/extensions/xf86vmode.h \
@@ -1255,6 +1258,16 @@ then
         WINE_NOTICE_WITH(xinerama,[test "x$ac_cv_lib_soname_Xinerama" = "x"],
                          [libxinerama ${notice_platform}development files not found, multi-monitor setups won't be supported.])
 
+        dnl *** Check for Xpresent extension
+        if test "$ac_cv_header_X11_extensions_Xpresent_h" = "yes"
+        then
+                AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <X11/Xlib.h>
+#include <X11/extensions/Xpresent.h>]], [[static typeof(XPresentQueryVersion) * func; if (func) return 0;]])],
+                  [WINE_CHECK_SONAME(Xpresent,XPresentQueryVersion,,,[$X_LIBS $X_EXTRA_LIBS])])
+        fi
+        WINE_NOTICE_WITH(Xpresent,[test "x$ac_cv_lib_soname_Xpresent" = "x"],
+                         [libXpresent ${notice_platform}development files not found, Xpresent won't be supported.])
+
         dnl *** Check for X Composite extension
         if test "$ac_cv_header_X11_extensions_Xcomposite_h" = "yes"
         then
diff --git a/dlls/winex11.drv/init.c b/dlls/winex11.drv/init.c
index cdb3dd931e9..372ab1f6232 100644
--- a/dlls/winex11.drv/init.c
+++ b/dlls/winex11.drv/init.c
@@ -27,6 +27,9 @@
 #include "winbase.h"
 #include "winreg.h"
 #include "x11drv.h"
+#include "xfixes.h"
+#include "xpresent.h"
+#include "xcomposite.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(x11drv);
@@ -232,10 +235,33 @@ static INT CDECL X11DRV_ExtEscape( PHYSDEV dev, INT escape, INT in_count, LPCVOI
 
                     OffsetRect( &rect, -physDev->dc_rect.left, -physDev->dc_rect.top );
                     if (data->flush) XFlush( gdi_display );
-                    XSetFunction( gdi_display, physDev->gc, GXcopy );
-                    XCopyArea( gdi_display, data->drawable, physDev->drawable, physDev->gc,
-                               0, 0, rect.right, rect.bottom,
-                               physDev->dc_rect.left, physDev->dc_rect.top );
+
+#if defined(SONAME_LIBXPRESENT) && defined(SONAME_LIBXFIXES)
+                    if (use_xpresent && use_xfixes && usexcomposite)
+                    {
+                        XserverRegion update, valid;
+                        XRectangle xrect = {0, 0, rect.right - rect.left, rect.bottom - rect.top};
+                        Drawable drawable = data->drawable;
+                        update = pXFixesCreateRegionFromGC( gdi_display, physDev->gc );
+                        valid = pXFixesCreateRegion( gdi_display, &xrect, 1 );
+#ifdef SONAME_LIBXCOMPOSITE
+                        if (usexcomposite) drawable = pXCompositeNameWindowPixmap( gdi_display, drawable );
+#endif
+                        pXPresentPixmap( gdi_display, physDev->drawable, drawable, XNextRequest( gdi_display ),
+                                         valid, update, physDev->dc_rect.left, physDev->dc_rect.top, None, None,
+                                         None, 0, 0, 0, 0, NULL, 0 );
+                        pXFixesDestroyRegion( gdi_display, update );
+                        pXFixesDestroyRegion( gdi_display, valid );
+                    }
+                    else
+#endif
+                    {
+                        XSetFunction( gdi_display, physDev->gc, GXcopy );
+                        XCopyArea( gdi_display, data->drawable, physDev->drawable, physDev->gc,
+                                   0, 0, rect.right, rect.bottom,
+                                   physDev->dc_rect.left, physDev->dc_rect.top );
+                    }
+
                     add_device_bounds( physDev, &rect );
                     return TRUE;
                 }
diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index fd0e47233fd..686587f225c 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -351,6 +351,8 @@ static VkResult X11DRV_vkAcquireNextImageKHR(VkDevice device,
 
     if (!surface || !surface->offscreen)
         wait_fence = FALSE;
+    else if (use_xpresent && use_xfixes && usexcomposite) /* X11DRV_PRESENT_DRAWABLE will use XPresentPixmap */
+        wait_fence = FALSE;
     else if (surface->present_mode == VK_PRESENT_MODE_MAILBOX_KHR ||
              surface->present_mode == VK_PRESENT_MODE_FIFO_KHR)
         wait_fence = TRUE;
@@ -373,7 +375,7 @@ static VkResult X11DRV_vkAcquireNextImageKHR(VkDevice device,
         escape.drawable = surface->window;
         escape.flush = TRUE;
         ExtEscape(surface->dc, X11DRV_ESCAPE, sizeof(escape), (char *)&escape, 0, NULL);
-        if (surface->present_mode == VK_PRESENT_MODE_MAILBOX_KHR)
+        if (wait_fence && surface->present_mode == VK_PRESENT_MODE_MAILBOX_KHR)
             if (once++) FIXME("Application requires child window rendering with mailbox present mode, expect possible tearing!\n");
     }
 
@@ -405,8 +407,9 @@ static VkResult X11DRV_vkCreateSwapchainKHR(VkDevice device,
     create_info_host = *create_info;
     create_info_host.surface = x11_surface->surface;
 
-    /* force fifo when running offscreen so the acquire fence is more likely to be vsynced */
-    if (x11_surface->offscreen && create_info->presentMode == VK_PRESENT_MODE_MAILBOX_KHR)
+    /* unless we use XPresentPixmap, force fifo when running offscreen so the acquire fence is more likely to be vsynced */
+    if (x11_surface->offscreen && create_info->presentMode == VK_PRESENT_MODE_MAILBOX_KHR &&
+        !(use_xpresent && use_xfixes && usexcomposite))
         create_info_host.presentMode = VK_PRESENT_MODE_FIFO_KHR;
     x11_surface->present_mode = create_info->presentMode;
 
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 73926b23ab4..c56bdc9da75 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -390,6 +390,7 @@ extern BOOL grab_pointer;
 extern BOOL grab_fullscreen;
 extern BOOL usexcomposite;
 extern BOOL use_xfixes;
+extern BOOL use_xpresent;
 extern BOOL managed_mode;
 extern BOOL decorated_mode;
 extern BOOL private_color_map;
diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index 824237534d6..823e25feaf4 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -51,6 +51,7 @@
 #include "x11drv.h"
 #include "xcomposite.h"
 #include "xfixes.h"
+#include "xpresent.h"
 #include "wine/server.h"
 #include "wine/unicode.h"
 #include "wine/debug.h"
@@ -71,6 +72,7 @@ BOOL usexvidmode = TRUE;
 BOOL usexrandr = TRUE;
 BOOL usexcomposite = TRUE;
 BOOL use_xfixes = FALSE;
+BOOL use_xpresent = FALSE;
 BOOL use_xkb = TRUE;
 BOOL use_take_focus = TRUE;
 BOOL use_primary_selection = FALSE;
@@ -511,6 +513,7 @@ MAKE_FUNCPTR(XFixesQueryExtension)
 MAKE_FUNCPTR(XFixesQueryVersion)
 MAKE_FUNCPTR(XFixesCreateRegion)
 MAKE_FUNCPTR(XFixesCreateRegionFromGC)
+MAKE_FUNCPTR(XFixesDestroyRegion)
 MAKE_FUNCPTR(XFixesSelectSelectionInput)
 #undef MAKE_FUNCPTR
 
@@ -536,6 +539,7 @@ static void x11drv_load_xfixes(void)
     LOAD_FUNCPTR(XFixesQueryVersion)
     LOAD_FUNCPTR(XFixesCreateRegion)
     LOAD_FUNCPTR(XFixesCreateRegionFromGC)
+    LOAD_FUNCPTR(XFixesDestroyRegion)
     LOAD_FUNCPTR(XFixesSelectSelectionInput)
 #undef LOAD_FUNCPTR
 
@@ -561,6 +565,57 @@ static void x11drv_load_xfixes(void)
 }
 #endif /* SONAME_LIBXFIXES */
 
+#ifdef SONAME_LIBXPRESENT
+
+#define MAKE_FUNCPTR(f) typeof(f) * p##f;
+MAKE_FUNCPTR(XPresentQueryExtension)
+MAKE_FUNCPTR(XPresentQueryVersion)
+MAKE_FUNCPTR(XPresentPixmap)
+#undef MAKE_FUNCPTR
+
+static void x11drv_load_xpresent(void)
+{
+    int opcode, event, error, major = 1, minor = 0;
+    void *xpresent;
+
+    if (!(xpresent = dlopen( SONAME_LIBXPRESENT, RTLD_NOW )))
+    {
+        WARN( "Xpresent library %s not found, disabled.\n", SONAME_LIBXPRESENT );
+        return;
+    }
+
+#define LOAD_FUNCPTR(f) \
+    if (!(p##f = dlsym( xpresent, #f )))                          \
+    {                                                             \
+        WARN( "Xpresent function %s not found, disabled\n", #f ); \
+        dlclose( xpresent );                                      \
+        return;                                                   \
+    }
+    LOAD_FUNCPTR(XPresentQueryExtension)
+    LOAD_FUNCPTR(XPresentQueryVersion)
+    LOAD_FUNCPTR(XPresentPixmap)
+#undef LOAD_FUNCPTR
+
+    if (!pXPresentQueryExtension( gdi_display, &opcode, &event, &error ))
+    {
+        WARN("Xpresent extension not found, disabled.\n");
+        dlclose(xpresent);
+        return;
+    }
+
+    if (!pXPresentQueryVersion( gdi_display, &major, &minor ))
+    {
+        WARN("Xpresent version not found, disabled.\n");
+        dlclose(xpresent);
+        return;
+    }
+
+    TRACE( "Xpresent, opcode %d, error %d, event %d, version %d.%d found\n",
+           opcode, error, event, major, minor );
+    use_xpresent = TRUE;
+}
+#endif /* SONAME_LIBXPRESENT */
+
 static void init_visuals( Display *display, int screen )
 {
     int count;
@@ -670,6 +725,9 @@ static BOOL process_attach(void)
 #ifdef SONAME_LIBXFIXES
     x11drv_load_xfixes();
 #endif
+#ifdef SONAME_LIBXPRESENT
+    x11drv_load_xpresent();
+#endif
 #ifdef SONAME_LIBXCOMPOSITE
     X11DRV_XComposite_Init();
 #endif
diff --git a/dlls/winex11.drv/xfixes.h b/dlls/winex11.drv/xfixes.h
index 3ab31201d3d..80f8cca04e4 100644
--- a/dlls/winex11.drv/xfixes.h
+++ b/dlls/winex11.drv/xfixes.h
@@ -29,6 +29,9 @@
 #define MAKE_FUNCPTR(f) extern typeof(f) * p##f;
 MAKE_FUNCPTR(XFixesQueryExtension)
 MAKE_FUNCPTR(XFixesQueryVersion)
+MAKE_FUNCPTR(XFixesCreateRegion)
+MAKE_FUNCPTR(XFixesCreateRegionFromGC)
+MAKE_FUNCPTR(XFixesDestroyRegion)
 MAKE_FUNCPTR(XFixesSelectSelectionInput)
 #undef MAKE_FUNCPTR
 #endif /* defined(SONAME_LIBXFIXES) */
diff --git a/dlls/winex11.drv/xpresent.h b/dlls/winex11.drv/xpresent.h
new file mode 100644
index 00000000000..6fd813a930e
--- /dev/null
+++ b/dlls/winex11.drv/xpresent.h
@@ -0,0 +1,36 @@
+/*
+ * Wine X11DRV Xpresent interface
+ *
+ * Copyright 2021 RÃ©mi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+#ifndef __WINE_XPRESENT_H
+#define __WINE_XPRESENT_H
+
+#ifndef __WINE_CONFIG_H
+# error You must include config.h to use this header
+#endif
+
+#ifdef SONAME_LIBXPRESENT
+#include <X11/extensions/Xpresent.h>
+#define MAKE_FUNCPTR(f) extern typeof(f) * p##f;
+MAKE_FUNCPTR(XPresentQueryExtension)
+MAKE_FUNCPTR(XPresentQueryVersion)
+MAKE_FUNCPTR(XPresentPixmap)
+#undef MAKE_FUNCPTR
+#endif /* defined(SONAME_LIBXPRESENT) */
+
+#endif /* __WINE_XPRESENT_H */
-- 
2.31.0

